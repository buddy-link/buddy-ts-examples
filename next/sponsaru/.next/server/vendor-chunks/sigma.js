"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sigma";
exports.ids = ["vendor-chunks/sigma"];
exports.modules = {

/***/ "(ssr)/./node_modules/sigma/dist/colors-2f6d17f0.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/sigma/dist/colors-2f6d17f0.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   H: () => (/* binding */ HTML_COLORS),\n/* harmony export */   _: () => (/* binding */ _slicedToArray),\n/* harmony export */   a: () => (/* binding */ _arrayLikeToArray),\n/* harmony export */   b: () => (/* binding */ _unsupportedIterableToArray),\n/* harmony export */   c: () => (/* binding */ colorToIndex),\n/* harmony export */   d: () => (/* binding */ colorToArray),\n/* harmony export */   e: () => (/* binding */ extractPixel),\n/* harmony export */   f: () => (/* binding */ floatColor),\n/* harmony export */   g: () => (/* binding */ getPixelColor),\n/* harmony export */   i: () => (/* binding */ indexToColor),\n/* harmony export */   p: () => (/* binding */ parseColor),\n/* harmony export */   r: () => (/* binding */ rgbaToFloat)\n/* harmony export */ });\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n\nfunction _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nvar HTML_COLORS = {\n  black: \"#000000\",\n  silver: \"#C0C0C0\",\n  gray: \"#808080\",\n  grey: \"#808080\",\n  white: \"#FFFFFF\",\n  maroon: \"#800000\",\n  red: \"#FF0000\",\n  purple: \"#800080\",\n  fuchsia: \"#FF00FF\",\n  green: \"#008000\",\n  lime: \"#00FF00\",\n  olive: \"#808000\",\n  yellow: \"#FFFF00\",\n  navy: \"#000080\",\n  blue: \"#0000FF\",\n  teal: \"#008080\",\n  aqua: \"#00FFFF\",\n  darkblue: \"#00008B\",\n  mediumblue: \"#0000CD\",\n  darkgreen: \"#006400\",\n  darkcyan: \"#008B8B\",\n  deepskyblue: \"#00BFFF\",\n  darkturquoise: \"#00CED1\",\n  mediumspringgreen: \"#00FA9A\",\n  springgreen: \"#00FF7F\",\n  cyan: \"#00FFFF\",\n  midnightblue: \"#191970\",\n  dodgerblue: \"#1E90FF\",\n  lightseagreen: \"#20B2AA\",\n  forestgreen: \"#228B22\",\n  seagreen: \"#2E8B57\",\n  darkslategray: \"#2F4F4F\",\n  darkslategrey: \"#2F4F4F\",\n  limegreen: \"#32CD32\",\n  mediumseagreen: \"#3CB371\",\n  turquoise: \"#40E0D0\",\n  royalblue: \"#4169E1\",\n  steelblue: \"#4682B4\",\n  darkslateblue: \"#483D8B\",\n  mediumturquoise: \"#48D1CC\",\n  indigo: \"#4B0082\",\n  darkolivegreen: \"#556B2F\",\n  cadetblue: \"#5F9EA0\",\n  cornflowerblue: \"#6495ED\",\n  rebeccapurple: \"#663399\",\n  mediumaquamarine: \"#66CDAA\",\n  dimgray: \"#696969\",\n  dimgrey: \"#696969\",\n  slateblue: \"#6A5ACD\",\n  olivedrab: \"#6B8E23\",\n  slategray: \"#708090\",\n  slategrey: \"#708090\",\n  lightslategray: \"#778899\",\n  lightslategrey: \"#778899\",\n  mediumslateblue: \"#7B68EE\",\n  lawngreen: \"#7CFC00\",\n  chartreuse: \"#7FFF00\",\n  aquamarine: \"#7FFFD4\",\n  skyblue: \"#87CEEB\",\n  lightskyblue: \"#87CEFA\",\n  blueviolet: \"#8A2BE2\",\n  darkred: \"#8B0000\",\n  darkmagenta: \"#8B008B\",\n  saddlebrown: \"#8B4513\",\n  darkseagreen: \"#8FBC8F\",\n  lightgreen: \"#90EE90\",\n  mediumpurple: \"#9370DB\",\n  darkviolet: \"#9400D3\",\n  palegreen: \"#98FB98\",\n  darkorchid: \"#9932CC\",\n  yellowgreen: \"#9ACD32\",\n  sienna: \"#A0522D\",\n  brown: \"#A52A2A\",\n  darkgray: \"#A9A9A9\",\n  darkgrey: \"#A9A9A9\",\n  lightblue: \"#ADD8E6\",\n  greenyellow: \"#ADFF2F\",\n  paleturquoise: \"#AFEEEE\",\n  lightsteelblue: \"#B0C4DE\",\n  powderblue: \"#B0E0E6\",\n  firebrick: \"#B22222\",\n  darkgoldenrod: \"#B8860B\",\n  mediumorchid: \"#BA55D3\",\n  rosybrown: \"#BC8F8F\",\n  darkkhaki: \"#BDB76B\",\n  mediumvioletred: \"#C71585\",\n  indianred: \"#CD5C5C\",\n  peru: \"#CD853F\",\n  chocolate: \"#D2691E\",\n  tan: \"#D2B48C\",\n  lightgray: \"#D3D3D3\",\n  lightgrey: \"#D3D3D3\",\n  thistle: \"#D8BFD8\",\n  orchid: \"#DA70D6\",\n  goldenrod: \"#DAA520\",\n  palevioletred: \"#DB7093\",\n  crimson: \"#DC143C\",\n  gainsboro: \"#DCDCDC\",\n  plum: \"#DDA0DD\",\n  burlywood: \"#DEB887\",\n  lightcyan: \"#E0FFFF\",\n  lavender: \"#E6E6FA\",\n  darksalmon: \"#E9967A\",\n  violet: \"#EE82EE\",\n  palegoldenrod: \"#EEE8AA\",\n  lightcoral: \"#F08080\",\n  khaki: \"#F0E68C\",\n  aliceblue: \"#F0F8FF\",\n  honeydew: \"#F0FFF0\",\n  azure: \"#F0FFFF\",\n  sandybrown: \"#F4A460\",\n  wheat: \"#F5DEB3\",\n  beige: \"#F5F5DC\",\n  whitesmoke: \"#F5F5F5\",\n  mintcream: \"#F5FFFA\",\n  ghostwhite: \"#F8F8FF\",\n  salmon: \"#FA8072\",\n  antiquewhite: \"#FAEBD7\",\n  linen: \"#FAF0E6\",\n  lightgoldenrodyellow: \"#FAFAD2\",\n  oldlace: \"#FDF5E6\",\n  magenta: \"#FF00FF\",\n  deeppink: \"#FF1493\",\n  orangered: \"#FF4500\",\n  tomato: \"#FF6347\",\n  hotpink: \"#FF69B4\",\n  coral: \"#FF7F50\",\n  darkorange: \"#FF8C00\",\n  lightsalmon: \"#FFA07A\",\n  orange: \"#FFA500\",\n  lightpink: \"#FFB6C1\",\n  pink: \"#FFC0CB\",\n  gold: \"#FFD700\",\n  peachpuff: \"#FFDAB9\",\n  navajowhite: \"#FFDEAD\",\n  moccasin: \"#FFE4B5\",\n  bisque: \"#FFE4C4\",\n  mistyrose: \"#FFE4E1\",\n  blanchedalmond: \"#FFEBCD\",\n  papayawhip: \"#FFEFD5\",\n  lavenderblush: \"#FFF0F5\",\n  seashell: \"#FFF5EE\",\n  cornsilk: \"#FFF8DC\",\n  lemonchiffon: \"#FFFACD\",\n  floralwhite: \"#FFFAF0\",\n  snow: \"#FFFAFA\",\n  lightyellow: \"#FFFFE0\",\n  ivory: \"#FFFFF0\"\n};\n\n/**\n * Function extracting the color at the given pixel.\n */\nfunction extractPixel(gl, x, y, array) {\n  var data = array || new Uint8Array(4);\n  gl.readPixels(x, y, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, data);\n  return data;\n}\n\n/**\n * Memoized function returning a float-encoded color from various string\n * formats describing colors.\n */\nvar INT8 = new Int8Array(4);\nvar INT32 = new Int32Array(INT8.buffer, 0, 1);\nvar FLOAT32 = new Float32Array(INT8.buffer, 0, 1);\nvar RGBA_TEST_REGEX = /^\\s*rgba?\\s*\\(/;\nvar RGBA_EXTRACT_REGEX = /^\\s*rgba?\\s*\\(\\s*([0-9]*)\\s*,\\s*([0-9]*)\\s*,\\s*([0-9]*)(?:\\s*,\\s*(.*)?)?\\)\\s*$/;\nfunction parseColor(val) {\n  var r = 0; // byte\n  var g = 0; // byte\n  var b = 0; // byte\n  var a = 1; // float\n\n  // Handling hexadecimal notation\n  if (val[0] === \"#\") {\n    if (val.length === 4) {\n      r = parseInt(val.charAt(1) + val.charAt(1), 16);\n      g = parseInt(val.charAt(2) + val.charAt(2), 16);\n      b = parseInt(val.charAt(3) + val.charAt(3), 16);\n    } else {\n      r = parseInt(val.charAt(1) + val.charAt(2), 16);\n      g = parseInt(val.charAt(3) + val.charAt(4), 16);\n      b = parseInt(val.charAt(5) + val.charAt(6), 16);\n    }\n    if (val.length === 9) {\n      a = parseInt(val.charAt(7) + val.charAt(8), 16) / 255;\n    }\n  }\n\n  // Handling rgb notation\n  else if (RGBA_TEST_REGEX.test(val)) {\n    var match = val.match(RGBA_EXTRACT_REGEX);\n    if (match) {\n      r = +match[1];\n      g = +match[2];\n      b = +match[3];\n      if (match[4]) a = +match[4];\n    }\n  }\n  return {\n    r: r,\n    g: g,\n    b: b,\n    a: a\n  };\n}\nvar FLOAT_COLOR_CACHE = {};\nfor (var htmlColor in HTML_COLORS) {\n  FLOAT_COLOR_CACHE[htmlColor] = floatColor(HTML_COLORS[htmlColor]);\n  // Replicating cache for hex values for free\n  FLOAT_COLOR_CACHE[HTML_COLORS[htmlColor]] = FLOAT_COLOR_CACHE[htmlColor];\n}\nfunction rgbaToFloat(r, g, b, a, masking) {\n  INT32[0] = a << 24 | b << 16 | g << 8 | r;\n  if (masking) INT32[0] = INT32[0] & 0xfeffffff;\n  return FLOAT32[0];\n}\nfunction floatColor(val) {\n  // The html color names are case-insensitive\n  val = val.toLowerCase();\n\n  // If the color is already computed, we yield it\n  if (typeof FLOAT_COLOR_CACHE[val] !== \"undefined\") return FLOAT_COLOR_CACHE[val];\n  var parsed = parseColor(val);\n  var r = parsed.r,\n    g = parsed.g,\n    b = parsed.b;\n  var a = parsed.a;\n  a = a * 255 | 0;\n  var color = rgbaToFloat(r, g, b, a, true);\n  FLOAT_COLOR_CACHE[val] = color;\n  return color;\n}\nfunction colorToArray(val, masking) {\n  FLOAT32[0] = floatColor(val);\n  var intValue = INT32[0];\n  if (masking) {\n    intValue = intValue | 0x01000000;\n  }\n  var r = intValue & 0xff;\n  var g = intValue >> 8 & 0xff;\n  var b = intValue >> 16 & 0xff;\n  var a = intValue >> 24 & 0xff;\n  return [r, g, b, a];\n}\nvar FLOAT_INDEX_CACHE = {};\nfunction indexToColor(index) {\n  // If the index is already computed, we yield it\n  if (typeof FLOAT_INDEX_CACHE[index] !== \"undefined\") return FLOAT_INDEX_CACHE[index];\n\n  // To address issue #1397, one strategy is to keep encoding 4 bytes colors,\n  // but with alpha hard-set to 1.0 (or 255):\n  var r = (index & 0x00ff0000) >>> 16;\n  var g = (index & 0x0000ff00) >>> 8;\n  var b = index & 0x000000ff;\n  var a = 0x000000ff;\n\n  // The original 4 bytes color encoding was the following:\n  // const r = (index & 0xff000000) >>> 24;\n  // const g = (index & 0x00ff0000) >>> 16;\n  // const b = (index & 0x0000ff00) >>> 8;\n  // const a = index & 0x000000ff;\n\n  var color = rgbaToFloat(r, g, b, a, true);\n  FLOAT_INDEX_CACHE[index] = color;\n  return color;\n}\nfunction colorToIndex(r, g, b, _a) {\n  // As for the function indexToColor, because of #1397 and the \"alpha is always\n  // 1.0\" strategy, we need to fix this function as well:\n  return b + (g << 8) + (r << 16);\n\n  // The original 4 bytes color decoding is the following:\n  // return a + (b << 8) + (g << 16) + (r << 24);\n}\nfunction getPixelColor(gl, frameBuffer, x, y, pixelRatio, downSizingRatio) {\n  var bufferX = Math.floor(x / downSizingRatio * pixelRatio);\n  var bufferY = Math.floor(gl.drawingBufferHeight / downSizingRatio - y / downSizingRatio * pixelRatio);\n  var pixel = new Uint8Array(4);\n  gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n  gl.readPixels(bufferX, bufferY, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixel);\n  var _pixel = _slicedToArray(pixel, 4),\n    r = _pixel[0],\n    g = _pixel[1],\n    b = _pixel[2],\n    a = _pixel[3];\n  return [r, g, b, a];\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2lnbWEvZGlzdC9jb2xvcnMtMmY2ZDE3ZjAuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxZQUFZLGtFQUFrRTtBQUN0RixNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGFBQWE7QUFDYixhQUFhO0FBQ2IsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUrUCIsInNvdXJjZXMiOlsid2VicGFjazovL3Nwb25zYXJ1Ly4vbm9kZV9tb2R1bGVzL3NpZ21hL2Rpc3QvY29sb3JzLTJmNmQxN2YwLmVzbS5qcz8zZDJhIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn1cblxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KHIsIGwpIHtcbiAgdmFyIHQgPSBudWxsID09IHIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIHJbU3ltYm9sLml0ZXJhdG9yXSB8fCByW1wiQEBpdGVyYXRvclwiXTtcbiAgaWYgKG51bGwgIT0gdCkge1xuICAgIHZhciBlLFxuICAgICAgbixcbiAgICAgIGksXG4gICAgICB1LFxuICAgICAgYSA9IFtdLFxuICAgICAgZiA9ICEwLFxuICAgICAgbyA9ICExO1xuICAgIHRyeSB7XG4gICAgICBpZiAoaSA9ICh0ID0gdC5jYWxsKHIpKS5uZXh0LCAwID09PSBsKSB7XG4gICAgICAgIGlmIChPYmplY3QodCkgIT09IHQpIHJldHVybjtcbiAgICAgICAgZiA9ICExO1xuICAgICAgfSBlbHNlIGZvciAoOyAhKGYgPSAoZSA9IGkuY2FsbCh0KSkuZG9uZSkgJiYgKGEucHVzaChlLnZhbHVlKSwgYS5sZW5ndGggIT09IGwpOyBmID0gITApO1xuICAgIH0gY2F0Y2ggKHIpIHtcbiAgICAgIG8gPSAhMCwgbiA9IHI7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghZiAmJiBudWxsICE9IHQucmV0dXJuICYmICh1ID0gdC5yZXR1cm4oKSwgT2JqZWN0KHUpICE9PSB1KSkgcmV0dXJuO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKG8pIHRocm93IG47XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XG4gIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gIGlmICghbykgcmV0dXJuO1xuICBpZiAodHlwZW9mIG8gPT09IFwic3RyaW5nXCIpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gIGlmIChuID09PSBcIk9iamVjdFwiICYmIG8uY29uc3RydWN0b3IpIG4gPSBvLmNvbnN0cnVjdG9yLm5hbWU7XG4gIGlmIChuID09PSBcIk1hcFwiIHx8IG4gPT09IFwiU2V0XCIpIHJldHVybiBBcnJheS5mcm9tKG8pO1xuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gZGVzdHJ1Y3R1cmUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gX2FycmF5V2l0aEhvbGVzKGFycikgfHwgX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgX25vbkl0ZXJhYmxlUmVzdCgpO1xufVxuXG52YXIgSFRNTF9DT0xPUlMgPSB7XG4gIGJsYWNrOiBcIiMwMDAwMDBcIixcbiAgc2lsdmVyOiBcIiNDMEMwQzBcIixcbiAgZ3JheTogXCIjODA4MDgwXCIsXG4gIGdyZXk6IFwiIzgwODA4MFwiLFxuICB3aGl0ZTogXCIjRkZGRkZGXCIsXG4gIG1hcm9vbjogXCIjODAwMDAwXCIsXG4gIHJlZDogXCIjRkYwMDAwXCIsXG4gIHB1cnBsZTogXCIjODAwMDgwXCIsXG4gIGZ1Y2hzaWE6IFwiI0ZGMDBGRlwiLFxuICBncmVlbjogXCIjMDA4MDAwXCIsXG4gIGxpbWU6IFwiIzAwRkYwMFwiLFxuICBvbGl2ZTogXCIjODA4MDAwXCIsXG4gIHllbGxvdzogXCIjRkZGRjAwXCIsXG4gIG5hdnk6IFwiIzAwMDA4MFwiLFxuICBibHVlOiBcIiMwMDAwRkZcIixcbiAgdGVhbDogXCIjMDA4MDgwXCIsXG4gIGFxdWE6IFwiIzAwRkZGRlwiLFxuICBkYXJrYmx1ZTogXCIjMDAwMDhCXCIsXG4gIG1lZGl1bWJsdWU6IFwiIzAwMDBDRFwiLFxuICBkYXJrZ3JlZW46IFwiIzAwNjQwMFwiLFxuICBkYXJrY3lhbjogXCIjMDA4QjhCXCIsXG4gIGRlZXBza3libHVlOiBcIiMwMEJGRkZcIixcbiAgZGFya3R1cnF1b2lzZTogXCIjMDBDRUQxXCIsXG4gIG1lZGl1bXNwcmluZ2dyZWVuOiBcIiMwMEZBOUFcIixcbiAgc3ByaW5nZ3JlZW46IFwiIzAwRkY3RlwiLFxuICBjeWFuOiBcIiMwMEZGRkZcIixcbiAgbWlkbmlnaHRibHVlOiBcIiMxOTE5NzBcIixcbiAgZG9kZ2VyYmx1ZTogXCIjMUU5MEZGXCIsXG4gIGxpZ2h0c2VhZ3JlZW46IFwiIzIwQjJBQVwiLFxuICBmb3Jlc3RncmVlbjogXCIjMjI4QjIyXCIsXG4gIHNlYWdyZWVuOiBcIiMyRThCNTdcIixcbiAgZGFya3NsYXRlZ3JheTogXCIjMkY0RjRGXCIsXG4gIGRhcmtzbGF0ZWdyZXk6IFwiIzJGNEY0RlwiLFxuICBsaW1lZ3JlZW46IFwiIzMyQ0QzMlwiLFxuICBtZWRpdW1zZWFncmVlbjogXCIjM0NCMzcxXCIsXG4gIHR1cnF1b2lzZTogXCIjNDBFMEQwXCIsXG4gIHJveWFsYmx1ZTogXCIjNDE2OUUxXCIsXG4gIHN0ZWVsYmx1ZTogXCIjNDY4MkI0XCIsXG4gIGRhcmtzbGF0ZWJsdWU6IFwiIzQ4M0Q4QlwiLFxuICBtZWRpdW10dXJxdW9pc2U6IFwiIzQ4RDFDQ1wiLFxuICBpbmRpZ286IFwiIzRCMDA4MlwiLFxuICBkYXJrb2xpdmVncmVlbjogXCIjNTU2QjJGXCIsXG4gIGNhZGV0Ymx1ZTogXCIjNUY5RUEwXCIsXG4gIGNvcm5mbG93ZXJibHVlOiBcIiM2NDk1RURcIixcbiAgcmViZWNjYXB1cnBsZTogXCIjNjYzMzk5XCIsXG4gIG1lZGl1bWFxdWFtYXJpbmU6IFwiIzY2Q0RBQVwiLFxuICBkaW1ncmF5OiBcIiM2OTY5NjlcIixcbiAgZGltZ3JleTogXCIjNjk2OTY5XCIsXG4gIHNsYXRlYmx1ZTogXCIjNkE1QUNEXCIsXG4gIG9saXZlZHJhYjogXCIjNkI4RTIzXCIsXG4gIHNsYXRlZ3JheTogXCIjNzA4MDkwXCIsXG4gIHNsYXRlZ3JleTogXCIjNzA4MDkwXCIsXG4gIGxpZ2h0c2xhdGVncmF5OiBcIiM3Nzg4OTlcIixcbiAgbGlnaHRzbGF0ZWdyZXk6IFwiIzc3ODg5OVwiLFxuICBtZWRpdW1zbGF0ZWJsdWU6IFwiIzdCNjhFRVwiLFxuICBsYXduZ3JlZW46IFwiIzdDRkMwMFwiLFxuICBjaGFydHJldXNlOiBcIiM3RkZGMDBcIixcbiAgYXF1YW1hcmluZTogXCIjN0ZGRkQ0XCIsXG4gIHNreWJsdWU6IFwiIzg3Q0VFQlwiLFxuICBsaWdodHNreWJsdWU6IFwiIzg3Q0VGQVwiLFxuICBibHVldmlvbGV0OiBcIiM4QTJCRTJcIixcbiAgZGFya3JlZDogXCIjOEIwMDAwXCIsXG4gIGRhcmttYWdlbnRhOiBcIiM4QjAwOEJcIixcbiAgc2FkZGxlYnJvd246IFwiIzhCNDUxM1wiLFxuICBkYXJrc2VhZ3JlZW46IFwiIzhGQkM4RlwiLFxuICBsaWdodGdyZWVuOiBcIiM5MEVFOTBcIixcbiAgbWVkaXVtcHVycGxlOiBcIiM5MzcwREJcIixcbiAgZGFya3Zpb2xldDogXCIjOTQwMEQzXCIsXG4gIHBhbGVncmVlbjogXCIjOThGQjk4XCIsXG4gIGRhcmtvcmNoaWQ6IFwiIzk5MzJDQ1wiLFxuICB5ZWxsb3dncmVlbjogXCIjOUFDRDMyXCIsXG4gIHNpZW5uYTogXCIjQTA1MjJEXCIsXG4gIGJyb3duOiBcIiNBNTJBMkFcIixcbiAgZGFya2dyYXk6IFwiI0E5QTlBOVwiLFxuICBkYXJrZ3JleTogXCIjQTlBOUE5XCIsXG4gIGxpZ2h0Ymx1ZTogXCIjQUREOEU2XCIsXG4gIGdyZWVueWVsbG93OiBcIiNBREZGMkZcIixcbiAgcGFsZXR1cnF1b2lzZTogXCIjQUZFRUVFXCIsXG4gIGxpZ2h0c3RlZWxibHVlOiBcIiNCMEM0REVcIixcbiAgcG93ZGVyYmx1ZTogXCIjQjBFMEU2XCIsXG4gIGZpcmVicmljazogXCIjQjIyMjIyXCIsXG4gIGRhcmtnb2xkZW5yb2Q6IFwiI0I4ODYwQlwiLFxuICBtZWRpdW1vcmNoaWQ6IFwiI0JBNTVEM1wiLFxuICByb3N5YnJvd246IFwiI0JDOEY4RlwiLFxuICBkYXJra2hha2k6IFwiI0JEQjc2QlwiLFxuICBtZWRpdW12aW9sZXRyZWQ6IFwiI0M3MTU4NVwiLFxuICBpbmRpYW5yZWQ6IFwiI0NENUM1Q1wiLFxuICBwZXJ1OiBcIiNDRDg1M0ZcIixcbiAgY2hvY29sYXRlOiBcIiNEMjY5MUVcIixcbiAgdGFuOiBcIiNEMkI0OENcIixcbiAgbGlnaHRncmF5OiBcIiNEM0QzRDNcIixcbiAgbGlnaHRncmV5OiBcIiNEM0QzRDNcIixcbiAgdGhpc3RsZTogXCIjRDhCRkQ4XCIsXG4gIG9yY2hpZDogXCIjREE3MEQ2XCIsXG4gIGdvbGRlbnJvZDogXCIjREFBNTIwXCIsXG4gIHBhbGV2aW9sZXRyZWQ6IFwiI0RCNzA5M1wiLFxuICBjcmltc29uOiBcIiNEQzE0M0NcIixcbiAgZ2FpbnNib3JvOiBcIiNEQ0RDRENcIixcbiAgcGx1bTogXCIjRERBMEREXCIsXG4gIGJ1cmx5d29vZDogXCIjREVCODg3XCIsXG4gIGxpZ2h0Y3lhbjogXCIjRTBGRkZGXCIsXG4gIGxhdmVuZGVyOiBcIiNFNkU2RkFcIixcbiAgZGFya3NhbG1vbjogXCIjRTk5NjdBXCIsXG4gIHZpb2xldDogXCIjRUU4MkVFXCIsXG4gIHBhbGVnb2xkZW5yb2Q6IFwiI0VFRThBQVwiLFxuICBsaWdodGNvcmFsOiBcIiNGMDgwODBcIixcbiAga2hha2k6IFwiI0YwRTY4Q1wiLFxuICBhbGljZWJsdWU6IFwiI0YwRjhGRlwiLFxuICBob25leWRldzogXCIjRjBGRkYwXCIsXG4gIGF6dXJlOiBcIiNGMEZGRkZcIixcbiAgc2FuZHlicm93bjogXCIjRjRBNDYwXCIsXG4gIHdoZWF0OiBcIiNGNURFQjNcIixcbiAgYmVpZ2U6IFwiI0Y1RjVEQ1wiLFxuICB3aGl0ZXNtb2tlOiBcIiNGNUY1RjVcIixcbiAgbWludGNyZWFtOiBcIiNGNUZGRkFcIixcbiAgZ2hvc3R3aGl0ZTogXCIjRjhGOEZGXCIsXG4gIHNhbG1vbjogXCIjRkE4MDcyXCIsXG4gIGFudGlxdWV3aGl0ZTogXCIjRkFFQkQ3XCIsXG4gIGxpbmVuOiBcIiNGQUYwRTZcIixcbiAgbGlnaHRnb2xkZW5yb2R5ZWxsb3c6IFwiI0ZBRkFEMlwiLFxuICBvbGRsYWNlOiBcIiNGREY1RTZcIixcbiAgbWFnZW50YTogXCIjRkYwMEZGXCIsXG4gIGRlZXBwaW5rOiBcIiNGRjE0OTNcIixcbiAgb3JhbmdlcmVkOiBcIiNGRjQ1MDBcIixcbiAgdG9tYXRvOiBcIiNGRjYzNDdcIixcbiAgaG90cGluazogXCIjRkY2OUI0XCIsXG4gIGNvcmFsOiBcIiNGRjdGNTBcIixcbiAgZGFya29yYW5nZTogXCIjRkY4QzAwXCIsXG4gIGxpZ2h0c2FsbW9uOiBcIiNGRkEwN0FcIixcbiAgb3JhbmdlOiBcIiNGRkE1MDBcIixcbiAgbGlnaHRwaW5rOiBcIiNGRkI2QzFcIixcbiAgcGluazogXCIjRkZDMENCXCIsXG4gIGdvbGQ6IFwiI0ZGRDcwMFwiLFxuICBwZWFjaHB1ZmY6IFwiI0ZGREFCOVwiLFxuICBuYXZham93aGl0ZTogXCIjRkZERUFEXCIsXG4gIG1vY2Nhc2luOiBcIiNGRkU0QjVcIixcbiAgYmlzcXVlOiBcIiNGRkU0QzRcIixcbiAgbWlzdHlyb3NlOiBcIiNGRkU0RTFcIixcbiAgYmxhbmNoZWRhbG1vbmQ6IFwiI0ZGRUJDRFwiLFxuICBwYXBheWF3aGlwOiBcIiNGRkVGRDVcIixcbiAgbGF2ZW5kZXJibHVzaDogXCIjRkZGMEY1XCIsXG4gIHNlYXNoZWxsOiBcIiNGRkY1RUVcIixcbiAgY29ybnNpbGs6IFwiI0ZGRjhEQ1wiLFxuICBsZW1vbmNoaWZmb246IFwiI0ZGRkFDRFwiLFxuICBmbG9yYWx3aGl0ZTogXCIjRkZGQUYwXCIsXG4gIHNub3c6IFwiI0ZGRkFGQVwiLFxuICBsaWdodHllbGxvdzogXCIjRkZGRkUwXCIsXG4gIGl2b3J5OiBcIiNGRkZGRjBcIlxufTtcblxuLyoqXG4gKiBGdW5jdGlvbiBleHRyYWN0aW5nIHRoZSBjb2xvciBhdCB0aGUgZ2l2ZW4gcGl4ZWwuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RQaXhlbChnbCwgeCwgeSwgYXJyYXkpIHtcbiAgdmFyIGRhdGEgPSBhcnJheSB8fCBuZXcgVWludDhBcnJheSg0KTtcbiAgZ2wucmVhZFBpeGVscyh4LCB5LCAxLCAxLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBkYXRhKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogTWVtb2l6ZWQgZnVuY3Rpb24gcmV0dXJuaW5nIGEgZmxvYXQtZW5jb2RlZCBjb2xvciBmcm9tIHZhcmlvdXMgc3RyaW5nXG4gKiBmb3JtYXRzIGRlc2NyaWJpbmcgY29sb3JzLlxuICovXG52YXIgSU5UOCA9IG5ldyBJbnQ4QXJyYXkoNCk7XG52YXIgSU5UMzIgPSBuZXcgSW50MzJBcnJheShJTlQ4LmJ1ZmZlciwgMCwgMSk7XG52YXIgRkxPQVQzMiA9IG5ldyBGbG9hdDMyQXJyYXkoSU5UOC5idWZmZXIsIDAsIDEpO1xudmFyIFJHQkFfVEVTVF9SRUdFWCA9IC9eXFxzKnJnYmE/XFxzKlxcKC87XG52YXIgUkdCQV9FWFRSQUNUX1JFR0VYID0gL15cXHMqcmdiYT9cXHMqXFwoXFxzKihbMC05XSopXFxzKixcXHMqKFswLTldKilcXHMqLFxccyooWzAtOV0qKSg/OlxccyosXFxzKiguKik/KT9cXClcXHMqJC87XG5mdW5jdGlvbiBwYXJzZUNvbG9yKHZhbCkge1xuICB2YXIgciA9IDA7IC8vIGJ5dGVcbiAgdmFyIGcgPSAwOyAvLyBieXRlXG4gIHZhciBiID0gMDsgLy8gYnl0ZVxuICB2YXIgYSA9IDE7IC8vIGZsb2F0XG5cbiAgLy8gSGFuZGxpbmcgaGV4YWRlY2ltYWwgbm90YXRpb25cbiAgaWYgKHZhbFswXSA9PT0gXCIjXCIpIHtcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gNCkge1xuICAgICAgciA9IHBhcnNlSW50KHZhbC5jaGFyQXQoMSkgKyB2YWwuY2hhckF0KDEpLCAxNik7XG4gICAgICBnID0gcGFyc2VJbnQodmFsLmNoYXJBdCgyKSArIHZhbC5jaGFyQXQoMiksIDE2KTtcbiAgICAgIGIgPSBwYXJzZUludCh2YWwuY2hhckF0KDMpICsgdmFsLmNoYXJBdCgzKSwgMTYpO1xuICAgIH0gZWxzZSB7XG4gICAgICByID0gcGFyc2VJbnQodmFsLmNoYXJBdCgxKSArIHZhbC5jaGFyQXQoMiksIDE2KTtcbiAgICAgIGcgPSBwYXJzZUludCh2YWwuY2hhckF0KDMpICsgdmFsLmNoYXJBdCg0KSwgMTYpO1xuICAgICAgYiA9IHBhcnNlSW50KHZhbC5jaGFyQXQoNSkgKyB2YWwuY2hhckF0KDYpLCAxNik7XG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSA5KSB7XG4gICAgICBhID0gcGFyc2VJbnQodmFsLmNoYXJBdCg3KSArIHZhbC5jaGFyQXQoOCksIDE2KSAvIDI1NTtcbiAgICB9XG4gIH1cblxuICAvLyBIYW5kbGluZyByZ2Igbm90YXRpb25cbiAgZWxzZSBpZiAoUkdCQV9URVNUX1JFR0VYLnRlc3QodmFsKSkge1xuICAgIHZhciBtYXRjaCA9IHZhbC5tYXRjaChSR0JBX0VYVFJBQ1RfUkVHRVgpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgciA9ICttYXRjaFsxXTtcbiAgICAgIGcgPSArbWF0Y2hbMl07XG4gICAgICBiID0gK21hdGNoWzNdO1xuICAgICAgaWYgKG1hdGNoWzRdKSBhID0gK21hdGNoWzRdO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHI6IHIsXG4gICAgZzogZyxcbiAgICBiOiBiLFxuICAgIGE6IGFcbiAgfTtcbn1cbnZhciBGTE9BVF9DT0xPUl9DQUNIRSA9IHt9O1xuZm9yICh2YXIgaHRtbENvbG9yIGluIEhUTUxfQ09MT1JTKSB7XG4gIEZMT0FUX0NPTE9SX0NBQ0hFW2h0bWxDb2xvcl0gPSBmbG9hdENvbG9yKEhUTUxfQ09MT1JTW2h0bWxDb2xvcl0pO1xuICAvLyBSZXBsaWNhdGluZyBjYWNoZSBmb3IgaGV4IHZhbHVlcyBmb3IgZnJlZVxuICBGTE9BVF9DT0xPUl9DQUNIRVtIVE1MX0NPTE9SU1todG1sQ29sb3JdXSA9IEZMT0FUX0NPTE9SX0NBQ0hFW2h0bWxDb2xvcl07XG59XG5mdW5jdGlvbiByZ2JhVG9GbG9hdChyLCBnLCBiLCBhLCBtYXNraW5nKSB7XG4gIElOVDMyWzBdID0gYSA8PCAyNCB8IGIgPDwgMTYgfCBnIDw8IDggfCByO1xuICBpZiAobWFza2luZykgSU5UMzJbMF0gPSBJTlQzMlswXSAmIDB4ZmVmZmZmZmY7XG4gIHJldHVybiBGTE9BVDMyWzBdO1xufVxuZnVuY3Rpb24gZmxvYXRDb2xvcih2YWwpIHtcbiAgLy8gVGhlIGh0bWwgY29sb3IgbmFtZXMgYXJlIGNhc2UtaW5zZW5zaXRpdmVcbiAgdmFsID0gdmFsLnRvTG93ZXJDYXNlKCk7XG5cbiAgLy8gSWYgdGhlIGNvbG9yIGlzIGFscmVhZHkgY29tcHV0ZWQsIHdlIHlpZWxkIGl0XG4gIGlmICh0eXBlb2YgRkxPQVRfQ09MT1JfQ0FDSEVbdmFsXSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIEZMT0FUX0NPTE9SX0NBQ0hFW3ZhbF07XG4gIHZhciBwYXJzZWQgPSBwYXJzZUNvbG9yKHZhbCk7XG4gIHZhciByID0gcGFyc2VkLnIsXG4gICAgZyA9IHBhcnNlZC5nLFxuICAgIGIgPSBwYXJzZWQuYjtcbiAgdmFyIGEgPSBwYXJzZWQuYTtcbiAgYSA9IGEgKiAyNTUgfCAwO1xuICB2YXIgY29sb3IgPSByZ2JhVG9GbG9hdChyLCBnLCBiLCBhLCB0cnVlKTtcbiAgRkxPQVRfQ09MT1JfQ0FDSEVbdmFsXSA9IGNvbG9yO1xuICByZXR1cm4gY29sb3I7XG59XG5mdW5jdGlvbiBjb2xvclRvQXJyYXkodmFsLCBtYXNraW5nKSB7XG4gIEZMT0FUMzJbMF0gPSBmbG9hdENvbG9yKHZhbCk7XG4gIHZhciBpbnRWYWx1ZSA9IElOVDMyWzBdO1xuICBpZiAobWFza2luZykge1xuICAgIGludFZhbHVlID0gaW50VmFsdWUgfCAweDAxMDAwMDAwO1xuICB9XG4gIHZhciByID0gaW50VmFsdWUgJiAweGZmO1xuICB2YXIgZyA9IGludFZhbHVlID4+IDggJiAweGZmO1xuICB2YXIgYiA9IGludFZhbHVlID4+IDE2ICYgMHhmZjtcbiAgdmFyIGEgPSBpbnRWYWx1ZSA+PiAyNCAmIDB4ZmY7XG4gIHJldHVybiBbciwgZywgYiwgYV07XG59XG52YXIgRkxPQVRfSU5ERVhfQ0FDSEUgPSB7fTtcbmZ1bmN0aW9uIGluZGV4VG9Db2xvcihpbmRleCkge1xuICAvLyBJZiB0aGUgaW5kZXggaXMgYWxyZWFkeSBjb21wdXRlZCwgd2UgeWllbGQgaXRcbiAgaWYgKHR5cGVvZiBGTE9BVF9JTkRFWF9DQUNIRVtpbmRleF0gIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBGTE9BVF9JTkRFWF9DQUNIRVtpbmRleF07XG5cbiAgLy8gVG8gYWRkcmVzcyBpc3N1ZSAjMTM5Nywgb25lIHN0cmF0ZWd5IGlzIHRvIGtlZXAgZW5jb2RpbmcgNCBieXRlcyBjb2xvcnMsXG4gIC8vIGJ1dCB3aXRoIGFscGhhIGhhcmQtc2V0IHRvIDEuMCAob3IgMjU1KTpcbiAgdmFyIHIgPSAoaW5kZXggJiAweDAwZmYwMDAwKSA+Pj4gMTY7XG4gIHZhciBnID0gKGluZGV4ICYgMHgwMDAwZmYwMCkgPj4+IDg7XG4gIHZhciBiID0gaW5kZXggJiAweDAwMDAwMGZmO1xuICB2YXIgYSA9IDB4MDAwMDAwZmY7XG5cbiAgLy8gVGhlIG9yaWdpbmFsIDQgYnl0ZXMgY29sb3IgZW5jb2Rpbmcgd2FzIHRoZSBmb2xsb3dpbmc6XG4gIC8vIGNvbnN0IHIgPSAoaW5kZXggJiAweGZmMDAwMDAwKSA+Pj4gMjQ7XG4gIC8vIGNvbnN0IGcgPSAoaW5kZXggJiAweDAwZmYwMDAwKSA+Pj4gMTY7XG4gIC8vIGNvbnN0IGIgPSAoaW5kZXggJiAweDAwMDBmZjAwKSA+Pj4gODtcbiAgLy8gY29uc3QgYSA9IGluZGV4ICYgMHgwMDAwMDBmZjtcblxuICB2YXIgY29sb3IgPSByZ2JhVG9GbG9hdChyLCBnLCBiLCBhLCB0cnVlKTtcbiAgRkxPQVRfSU5ERVhfQ0FDSEVbaW5kZXhdID0gY29sb3I7XG4gIHJldHVybiBjb2xvcjtcbn1cbmZ1bmN0aW9uIGNvbG9yVG9JbmRleChyLCBnLCBiLCBfYSkge1xuICAvLyBBcyBmb3IgdGhlIGZ1bmN0aW9uIGluZGV4VG9Db2xvciwgYmVjYXVzZSBvZiAjMTM5NyBhbmQgdGhlIFwiYWxwaGEgaXMgYWx3YXlzXG4gIC8vIDEuMFwiIHN0cmF0ZWd5LCB3ZSBuZWVkIHRvIGZpeCB0aGlzIGZ1bmN0aW9uIGFzIHdlbGw6XG4gIHJldHVybiBiICsgKGcgPDwgOCkgKyAociA8PCAxNik7XG5cbiAgLy8gVGhlIG9yaWdpbmFsIDQgYnl0ZXMgY29sb3IgZGVjb2RpbmcgaXMgdGhlIGZvbGxvd2luZzpcbiAgLy8gcmV0dXJuIGEgKyAoYiA8PCA4KSArIChnIDw8IDE2KSArIChyIDw8IDI0KTtcbn1cbmZ1bmN0aW9uIGdldFBpeGVsQ29sb3IoZ2wsIGZyYW1lQnVmZmVyLCB4LCB5LCBwaXhlbFJhdGlvLCBkb3duU2l6aW5nUmF0aW8pIHtcbiAgdmFyIGJ1ZmZlclggPSBNYXRoLmZsb29yKHggLyBkb3duU2l6aW5nUmF0aW8gKiBwaXhlbFJhdGlvKTtcbiAgdmFyIGJ1ZmZlclkgPSBNYXRoLmZsb29yKGdsLmRyYXdpbmdCdWZmZXJIZWlnaHQgLyBkb3duU2l6aW5nUmF0aW8gLSB5IC8gZG93blNpemluZ1JhdGlvICogcGl4ZWxSYXRpbyk7XG4gIHZhciBwaXhlbCA9IG5ldyBVaW50OEFycmF5KDQpO1xuICBnbC5iaW5kRnJhbWVidWZmZXIoZ2wuRlJBTUVCVUZGRVIsIGZyYW1lQnVmZmVyKTtcbiAgZ2wucmVhZFBpeGVscyhidWZmZXJYLCBidWZmZXJZLCAxLCAxLCBnbC5SR0JBLCBnbC5VTlNJR05FRF9CWVRFLCBwaXhlbCk7XG4gIHZhciBfcGl4ZWwgPSBfc2xpY2VkVG9BcnJheShwaXhlbCwgNCksXG4gICAgciA9IF9waXhlbFswXSxcbiAgICBnID0gX3BpeGVsWzFdLFxuICAgIGIgPSBfcGl4ZWxbMl0sXG4gICAgYSA9IF9waXhlbFszXTtcbiAgcmV0dXJuIFtyLCBnLCBiLCBhXTtcbn1cblxuZXhwb3J0IHsgSFRNTF9DT0xPUlMgYXMgSCwgX3NsaWNlZFRvQXJyYXkgYXMgXywgX2FycmF5TGlrZVRvQXJyYXkgYXMgYSwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGFzIGIsIGNvbG9yVG9JbmRleCBhcyBjLCBjb2xvclRvQXJyYXkgYXMgZCwgZXh0cmFjdFBpeGVsIGFzIGUsIGZsb2F0Q29sb3IgYXMgZiwgZ2V0UGl4ZWxDb2xvciBhcyBnLCBpbmRleFRvQ29sb3IgYXMgaSwgcGFyc2VDb2xvciBhcyBwLCByZ2JhVG9GbG9hdCBhcyByIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sigma/dist/colors-2f6d17f0.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sigma/dist/data-31990a76.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/sigma/dist/data-31990a76.esm.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   a: () => (/* binding */ assign),\n/* harmony export */   b: () => (/* binding */ assignDeep),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   i: () => (/* binding */ isPlainObject)\n/* harmony export */ });\nfunction _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}\n\n/**\n * Extends the target array with the given values.\n */\nfunction extend(array, values) {\n  var l2 = values.size;\n  if (l2 === 0) return;\n  var l1 = array.length;\n  array.length += l2;\n  var i = 0;\n  values.forEach(function (value) {\n    array[l1 + i] = value;\n    i++;\n  });\n}\n\n/**\n * Checks whether the given value is a plain object.\n */\nfunction isPlainObject(value) {\n  return _typeof(value) === \"object\" && value !== null && value.constructor === Object;\n}\n\n/**\n * Helper to use `Object.assign` with more than two objects.\n */\nfunction assign(target) {\n  target = target || {};\n  for (var i = 0, l = arguments.length <= 1 ? 0 : arguments.length - 1; i < l; i++) {\n    var o = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];\n    if (!o) continue;\n    Object.assign(target, o);\n  }\n  return target;\n}\n\n/**\n * Very simple recursive `Object.assign` like function.\n */\nfunction assignDeep(target) {\n  target = target || {};\n  for (var i = 0, l = arguments.length <= 1 ? 0 : arguments.length - 1; i < l; i++) {\n    var o = i + 1 < 1 || arguments.length <= i + 1 ? undefined : arguments[i + 1];\n    if (!o) continue;\n    for (var k in o) {\n      if (isPlainObject(o[k])) {\n        target[k] = assignDeep(target[k], o[k]);\n      } else {\n        target[k] = o[k];\n      }\n    }\n  }\n  return target;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2lnbWEvZGlzdC9kYXRhLTMxOTkwYTc2LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxPQUFPO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLE9BQU87QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXlFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BvbnNhcnUvLi9ub2RlX21vZHVsZXMvc2lnbWEvZGlzdC9kYXRhLTMxOTkwYTc2LmVzbS5qcz8xMjc1Il0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90eXBlb2Yobykge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykge1xuICAgIHJldHVybiB0eXBlb2YgbztcbiAgfSA6IGZ1bmN0aW9uIChvKSB7XG4gICAgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87XG4gIH0sIF90eXBlb2Yobyk7XG59XG5cbi8qKlxuICogRXh0ZW5kcyB0aGUgdGFyZ2V0IGFycmF5IHdpdGggdGhlIGdpdmVuIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGFycmF5LCB2YWx1ZXMpIHtcbiAgdmFyIGwyID0gdmFsdWVzLnNpemU7XG4gIGlmIChsMiA9PT0gMCkgcmV0dXJuO1xuICB2YXIgbDEgPSBhcnJheS5sZW5ndGg7XG4gIGFycmF5Lmxlbmd0aCArPSBsMjtcbiAgdmFyIGkgPSAwO1xuICB2YWx1ZXMuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBhcnJheVtsMSArIGldID0gdmFsdWU7XG4gICAgaSsrO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIF90eXBlb2YodmFsdWUpID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XG59XG5cbi8qKlxuICogSGVscGVyIHRvIHVzZSBgT2JqZWN0LmFzc2lnbmAgd2l0aCBtb3JlIHRoYW4gdHdvIG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGFzc2lnbih0YXJnZXQpIHtcbiAgdGFyZ2V0ID0gdGFyZ2V0IHx8IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSA/IDAgOiBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA8IGw7IGkrKykge1xuICAgIHZhciBvID0gaSArIDEgPCAxIHx8IGFyZ3VtZW50cy5sZW5ndGggPD0gaSArIDEgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbaSArIDFdO1xuICAgIGlmICghbykgY29udGludWU7XG4gICAgT2JqZWN0LmFzc2lnbih0YXJnZXQsIG8pO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogVmVyeSBzaW1wbGUgcmVjdXJzaXZlIGBPYmplY3QuYXNzaWduYCBsaWtlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBhc3NpZ25EZWVwKHRhcmdldCkge1xuICB0YXJnZXQgPSB0YXJnZXQgfHwge307XG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxID8gMCA6IGFyZ3VtZW50cy5sZW5ndGggLSAxOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIG8gPSBpICsgMSA8IDEgfHwgYXJndW1lbnRzLmxlbmd0aCA8PSBpICsgMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1tpICsgMV07XG4gICAgaWYgKCFvKSBjb250aW51ZTtcbiAgICBmb3IgKHZhciBrIGluIG8pIHtcbiAgICAgIGlmIChpc1BsYWluT2JqZWN0KG9ba10pKSB7XG4gICAgICAgIHRhcmdldFtrXSA9IGFzc2lnbkRlZXAodGFyZ2V0W2tdLCBvW2tdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtrXSA9IG9ba107XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmV4cG9ydCB7IGFzc2lnbiBhcyBhLCBhc3NpZ25EZWVwIGFzIGIsIGV4dGVuZCBhcyBlLCBpc1BsYWluT2JqZWN0IGFzIGkgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sigma/dist/data-31990a76.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sigma/dist/index-29acc883.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/sigma/dist/index-29acc883.esm.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ AbstractNodeProgram),\n/* harmony export */   E: () => (/* binding */ EdgeArrowProgram$1),\n/* harmony export */   N: () => (/* binding */ NodeCircleProgram),\n/* harmony export */   P: () => (/* binding */ Program),\n/* harmony export */   _: () => (/* binding */ _defineProperty),\n/* harmony export */   a: () => (/* binding */ _objectSpread2),\n/* harmony export */   b: () => (/* binding */ drawDiscNodeLabel),\n/* harmony export */   c: () => (/* binding */ drawDiscNodeHover),\n/* harmony export */   d: () => (/* binding */ drawStraightEdgeLabel),\n/* harmony export */   e: () => (/* binding */ EdgeRectangleProgram),\n/* harmony export */   f: () => (/* binding */ NodeProgram),\n/* harmony export */   g: () => (/* binding */ EdgeProgram),\n/* harmony export */   h: () => (/* binding */ createNodeCompoundProgram),\n/* harmony export */   i: () => (/* binding */ AbstractEdgeProgram),\n/* harmony export */   j: () => (/* binding */ createEdgeCompoundProgram),\n/* harmony export */   k: () => (/* binding */ AbstractProgram),\n/* harmony export */   l: () => (/* binding */ EdgeArrowHeadProgram),\n/* harmony export */   m: () => (/* binding */ EdgeClampedProgram),\n/* harmony export */   n: () => (/* binding */ loadVertexShader),\n/* harmony export */   o: () => (/* binding */ loadFragmentShader),\n/* harmony export */   p: () => (/* binding */ loadProgram),\n/* harmony export */   q: () => (/* binding */ numberToGLSLFloat)\n/* harmony export */ });\n/* harmony import */ var _inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./inherits-8fbdedb5.esm.js */ \"(ssr)/./node_modules/sigma/dist/inherits-8fbdedb5.esm.js\");\n/* harmony import */ var _colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colors-2f6d17f0.esm.js */ \"(ssr)/./node_modules/sigma/dist/colors-2f6d17f0.esm.js\");\n\n\n\nfunction _defineProperty(obj, key, value) {\n  key = (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.t)(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\n/**\n * Sigma.js Shader Utils\n * ======================\n *\n * Code used to load sigma's shaders.\n * @module\n */\n\n/**\n * Function used to load a shader.\n */\nfunction loadShader(type, gl, source) {\n  var glType = type === \"VERTEX\" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER;\n\n  // Creating the shader\n  var shader = gl.createShader(glType);\n  if (shader === null) {\n    throw new Error(\"loadShader: error while creating the shader\");\n  }\n\n  // Loading source\n  gl.shaderSource(shader, source);\n\n  // Compiling the shader\n  gl.compileShader(shader);\n\n  // Retrieving compilation status\n  var successfullyCompiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n\n  // Throwing if something went awry\n  if (!successfullyCompiled) {\n    var infoLog = gl.getShaderInfoLog(shader);\n    gl.deleteShader(shader);\n    throw new Error(\"loadShader: error while compiling the shader:\\n\".concat(infoLog, \"\\n\").concat(source));\n  }\n  return shader;\n}\nfunction loadVertexShader(gl, source) {\n  return loadShader(\"VERTEX\", gl, source);\n}\nfunction loadFragmentShader(gl, source) {\n  return loadShader(\"FRAGMENT\", gl, source);\n}\n\n/**\n * Function used to load a program.\n */\nfunction loadProgram(gl, shaders) {\n  var program = gl.createProgram();\n  if (program === null) {\n    throw new Error(\"loadProgram: error while creating the program.\");\n  }\n  var i, l;\n\n  // Attaching the shaders\n  for (i = 0, l = shaders.length; i < l; i++) gl.attachShader(program, shaders[i]);\n  gl.linkProgram(program);\n\n  // Checking status\n  var successfullyLinked = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (!successfullyLinked) {\n    gl.deleteProgram(program);\n    throw new Error(\"loadProgram: error while linking the program.\");\n  }\n  return program;\n}\n\n/**\n * Function use to print a float for inserting in a GLSL program.\n */\nfunction numberToGLSLFloat(n) {\n  return n % 1 === 0 ? n.toFixed(1) : n.toString();\n}\n\nvar PICKING_PREFIX = \"#define PICKING_MODE\\n\";\nvar SIZE_FACTOR_PER_ATTRIBUTE_TYPE = _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, WebGL2RenderingContext.BOOL, 1), WebGL2RenderingContext.BYTE, 1), WebGL2RenderingContext.UNSIGNED_BYTE, 1), WebGL2RenderingContext.SHORT, 2), WebGL2RenderingContext.UNSIGNED_SHORT, 2), WebGL2RenderingContext.INT, 4), WebGL2RenderingContext.UNSIGNED_INT, 4), WebGL2RenderingContext.FLOAT, 4);\nfunction getAttributeItemsCount(attr) {\n  return attr.normalized ? 1 : attr.size;\n}\nfunction getAttributesItemsCount(attrs) {\n  var res = 0;\n  attrs.forEach(function (attr) {\n    return res += getAttributeItemsCount(attr);\n  });\n  return res;\n}\nvar AbstractProgram = /*#__PURE__*/(0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction AbstractProgram(_gl, _pickGl, _renderer) {\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, AbstractProgram);\n});\nvar Program = /*#__PURE__*/function () {\n  function Program(gl, pickingBuffer, renderer) {\n    (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, Program);\n    _defineProperty(this, \"array\", new Float32Array());\n    _defineProperty(this, \"constantArray\", new Float32Array());\n    _defineProperty(this, \"capacity\", 0);\n    _defineProperty(this, \"verticesCount\", 0);\n    // Reading and caching program definition\n    var def = this.getDefinition();\n    this.VERTICES = def.VERTICES;\n    this.VERTEX_SHADER_SOURCE = def.VERTEX_SHADER_SOURCE;\n    this.FRAGMENT_SHADER_SOURCE = def.FRAGMENT_SHADER_SOURCE;\n    this.UNIFORMS = def.UNIFORMS;\n    this.ATTRIBUTES = def.ATTRIBUTES;\n    this.METHOD = def.METHOD;\n    this.CONSTANT_ATTRIBUTES = \"CONSTANT_ATTRIBUTES\" in def ? def.CONSTANT_ATTRIBUTES : [];\n    this.CONSTANT_DATA = \"CONSTANT_DATA\" in def ? def.CONSTANT_DATA : [];\n    this.isInstanced = \"CONSTANT_ATTRIBUTES\" in def;\n\n    // Computing stride\n    this.ATTRIBUTES_ITEMS_COUNT = getAttributesItemsCount(this.ATTRIBUTES);\n    this.STRIDE = this.VERTICES * this.ATTRIBUTES_ITEMS_COUNT;\n\n    // Members\n    this.renderer = renderer;\n    this.normalProgram = this.getProgramInfo(\"normal\", gl, def.VERTEX_SHADER_SOURCE, def.FRAGMENT_SHADER_SOURCE, null);\n    this.pickProgram = pickingBuffer ? this.getProgramInfo(\"pick\", gl, PICKING_PREFIX + def.VERTEX_SHADER_SOURCE, PICKING_PREFIX + def.FRAGMENT_SHADER_SOURCE, pickingBuffer) : null;\n\n    // For instanced programs:\n    if (this.isInstanced) {\n      var constantAttributesItemsCount = getAttributesItemsCount(this.CONSTANT_ATTRIBUTES);\n      if (this.CONSTANT_DATA.length !== this.VERTICES) throw new Error(\"Program: error while getting constant data (expected \".concat(this.VERTICES, \" items, received \").concat(this.CONSTANT_DATA.length, \" instead)\"));\n      this.constantArray = new Float32Array(this.CONSTANT_DATA.length * constantAttributesItemsCount);\n      for (var i = 0; i < this.CONSTANT_DATA.length; i++) {\n        var vector = this.CONSTANT_DATA[i];\n        if (vector.length !== constantAttributesItemsCount) throw new Error(\"Program: error while getting constant data (one vector has \".concat(vector.length, \" items instead of \").concat(constantAttributesItemsCount, \")\"));\n        for (var j = 0; j < vector.length; j++) this.constantArray[i * constantAttributesItemsCount + j] = vector[j];\n      }\n      this.STRIDE = this.ATTRIBUTES_ITEMS_COUNT;\n    }\n  }\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(Program, [{\n    key: \"getProgramInfo\",\n    value: function getProgramInfo(name, gl, vertexShaderSource, fragmentShaderSource, frameBuffer) {\n      var def = this.getDefinition();\n\n      // WebGL buffers\n      var buffer = gl.createBuffer();\n      if (buffer === null) throw new Error(\"Program: error while creating the WebGL buffer.\");\n\n      // Shaders and program\n      var vertexShader = loadVertexShader(gl, vertexShaderSource);\n      var fragmentShader = loadFragmentShader(gl, fragmentShaderSource);\n      var program = loadProgram(gl, [vertexShader, fragmentShader]);\n\n      // Initializing locations\n      var uniformLocations = {};\n      def.UNIFORMS.forEach(function (uniformName) {\n        var location = gl.getUniformLocation(program, uniformName);\n        if (location) uniformLocations[uniformName] = location;\n      });\n      var attributeLocations = {};\n      def.ATTRIBUTES.forEach(function (attr) {\n        attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);\n      });\n\n      // For instanced programs:\n      var constantBuffer;\n      if (\"CONSTANT_ATTRIBUTES\" in def) {\n        def.CONSTANT_ATTRIBUTES.forEach(function (attr) {\n          attributeLocations[attr.name] = gl.getAttribLocation(program, attr.name);\n        });\n        constantBuffer = gl.createBuffer();\n        if (constantBuffer === null) throw new Error(\"Program: error while creating the WebGL constant buffer.\");\n      }\n      return {\n        name: name,\n        program: program,\n        gl: gl,\n        frameBuffer: frameBuffer,\n        buffer: buffer,\n        constantBuffer: constantBuffer || {},\n        uniformLocations: uniformLocations,\n        attributeLocations: attributeLocations,\n        isPicking: name === \"pick\"\n      };\n    }\n  }, {\n    key: \"bindProgram\",\n    value: function bindProgram(program) {\n      var _this = this;\n      var offset = 0;\n      var gl = program.gl,\n        buffer = program.buffer;\n      if (!this.isInstanced) {\n        gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n        offset = 0;\n        this.ATTRIBUTES.forEach(function (attr) {\n          return offset += _this.bindAttribute(attr, program, offset);\n        });\n        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n      } else {\n        // Handle constant data (things that remain unchanged for all items):\n        gl.bindBuffer(gl.ARRAY_BUFFER, program.constantBuffer);\n        offset = 0;\n        this.CONSTANT_ATTRIBUTES.forEach(function (attr) {\n          return offset += _this.bindAttribute(attr, program, offset, false);\n        });\n        gl.bufferData(gl.ARRAY_BUFFER, this.constantArray, gl.STATIC_DRAW);\n\n        // Handle \"instance specific\" data (things that vary for each item):\n        gl.bindBuffer(gl.ARRAY_BUFFER, program.buffer);\n        offset = 0;\n        this.ATTRIBUTES.forEach(function (attr) {\n          return offset += _this.bindAttribute(attr, program, offset, true);\n        });\n        gl.bufferData(gl.ARRAY_BUFFER, this.array, gl.DYNAMIC_DRAW);\n      }\n      gl.bindBuffer(gl.ARRAY_BUFFER, null);\n    }\n  }, {\n    key: \"unbindProgram\",\n    value: function unbindProgram(program) {\n      var _this2 = this;\n      if (!this.isInstanced) {\n        this.ATTRIBUTES.forEach(function (attr) {\n          return _this2.unbindAttribute(attr, program);\n        });\n      } else {\n        this.CONSTANT_ATTRIBUTES.forEach(function (attr) {\n          return _this2.unbindAttribute(attr, program, false);\n        });\n        this.ATTRIBUTES.forEach(function (attr) {\n          return _this2.unbindAttribute(attr, program, true);\n        });\n      }\n    }\n  }, {\n    key: \"bindAttribute\",\n    value: function bindAttribute(attr, program, offset, setDivisor) {\n      var sizeFactor = SIZE_FACTOR_PER_ATTRIBUTE_TYPE[attr.type];\n      if (typeof sizeFactor !== \"number\") throw new Error(\"Program.bind: yet unsupported attribute type \\\"\".concat(attr.type, \"\\\"\"));\n      var location = program.attributeLocations[attr.name];\n      var gl = program.gl;\n      if (location !== -1) {\n        gl.enableVertexAttribArray(location);\n        var stride = !this.isInstanced ? this.ATTRIBUTES_ITEMS_COUNT * Float32Array.BYTES_PER_ELEMENT : (setDivisor ? this.ATTRIBUTES_ITEMS_COUNT : getAttributesItemsCount(this.CONSTANT_ATTRIBUTES)) * Float32Array.BYTES_PER_ELEMENT;\n        gl.vertexAttribPointer(location, attr.size, attr.type, attr.normalized || false, stride, offset);\n        if (this.isInstanced && setDivisor) {\n          if (gl instanceof WebGL2RenderingContext) {\n            gl.vertexAttribDivisor(location, 1);\n          } else {\n            var ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n            if (ext) ext.vertexAttribDivisorANGLE(location, 1);\n          }\n        }\n      }\n      return attr.size * sizeFactor;\n    }\n  }, {\n    key: \"unbindAttribute\",\n    value: function unbindAttribute(attr, program, unsetDivisor) {\n      var location = program.attributeLocations[attr.name];\n      var gl = program.gl;\n      if (location !== -1) {\n        gl.disableVertexAttribArray(location);\n        if (this.isInstanced && unsetDivisor) {\n          if (gl instanceof WebGL2RenderingContext) {\n            gl.vertexAttribDivisor(location, 0);\n          } else {\n            var ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n            if (ext) ext.vertexAttribDivisorANGLE(location, 0);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"reallocate\",\n    value: function reallocate(capacity) {\n      // If desired capacity has not changed we do nothing\n      // NOTE: it's possible here to implement more subtle reallocation schemes\n      // when the number of rendered items increase or decrease\n      if (capacity === this.capacity) return;\n      this.capacity = capacity;\n      this.verticesCount = this.VERTICES * capacity;\n      this.array = new Float32Array(!this.isInstanced ? this.verticesCount * this.ATTRIBUTES_ITEMS_COUNT : this.capacity * this.ATTRIBUTES_ITEMS_COUNT);\n    }\n  }, {\n    key: \"hasNothingToRender\",\n    value: function hasNothingToRender() {\n      return this.verticesCount === 0;\n    }\n  }, {\n    key: \"renderProgram\",\n    value: function renderProgram(params, programInfo) {\n      var gl = programInfo.gl,\n        program = programInfo.program;\n\n      // With the current fix for #1397, the alpha blending is enabled for the\n      // picking layer:\n      gl.enable(gl.BLEND);\n\n      // Original code:\n      // if (!isPicking) gl.enable(gl.BLEND);\n      // else gl.disable(gl.BLEND);\n\n      gl.useProgram(program);\n      this.setUniforms(params, programInfo);\n      this.drawWebGL(this.METHOD, programInfo);\n    }\n  }, {\n    key: \"render\",\n    value: function render(params) {\n      if (this.hasNothingToRender()) return;\n      if (this.pickProgram) {\n        this.pickProgram.gl.viewport(0, 0, params.width * params.pixelRatio / params.downSizingRatio, params.height * params.pixelRatio / params.downSizingRatio);\n        this.bindProgram(this.pickProgram);\n        this.renderProgram(_objectSpread2(_objectSpread2({}, params), {}, {\n          pixelRatio: params.pixelRatio / params.downSizingRatio\n        }), this.pickProgram);\n        this.unbindProgram(this.pickProgram);\n      }\n      this.normalProgram.gl.viewport(0, 0, params.width * params.pixelRatio, params.height * params.pixelRatio);\n      this.bindProgram(this.normalProgram);\n      this.renderProgram(params, this.normalProgram);\n      this.unbindProgram(this.normalProgram);\n    }\n  }, {\n    key: \"drawWebGL\",\n    value: function drawWebGL(method, _ref) {\n      var gl = _ref.gl,\n        frameBuffer = _ref.frameBuffer;\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n      if (!this.isInstanced) {\n        gl.drawArrays(method, 0, this.verticesCount);\n      } else {\n        if (gl instanceof WebGL2RenderingContext) {\n          gl.drawArraysInstanced(method, 0, this.VERTICES, this.capacity);\n        } else {\n          var ext = gl.getExtension(\"ANGLE_instanced_arrays\");\n          if (ext) ext.drawArraysInstancedANGLE(method, 0, this.VERTICES, this.capacity);\n        }\n      }\n    }\n  }]);\n  return Program;\n}();\n\nvar AbstractNodeProgram = /*#__PURE__*/function (_AbstractProgram) {\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(AbstractNodeProgram, _AbstractProgram);\n  function AbstractNodeProgram() {\n    (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, AbstractNodeProgram);\n    return (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, AbstractNodeProgram, arguments);\n  }\n  return (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(AbstractNodeProgram);\n}(AbstractProgram);\nvar NodeProgram = /*#__PURE__*/function (_ref) {\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(NodeProgram, _ref);\n  function NodeProgram() {\n    (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, NodeProgram);\n    return (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, NodeProgram, arguments);\n  }\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(NodeProgram, [{\n    key: \"kill\",\n    value: function kill() {\n      return undefined;\n    }\n  }, {\n    key: \"process\",\n    value: function process(nodeIndex, offset, data) {\n      var i = offset * this.STRIDE;\n      // NOTE: dealing with hidden items automatically\n      if (data.hidden) {\n        for (var l = i + this.STRIDE; i < l; i++) {\n          this.array[i] = 0;\n        }\n        return;\n      }\n      return this.processVisibleItem((0,_colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)(nodeIndex), i, data);\n    }\n  }]);\n  return NodeProgram;\n}(Program);\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @param  {function} drawLabel - An optional node \"draw label\" function.\n * @param  {function} drawHover - An optional node \"draw hover\" function.\n * @return {function}\n */\nfunction createNodeCompoundProgram(programClasses, drawLabel, drawHover) {\n  return /*#__PURE__*/function () {\n    function NodeCompoundProgram(gl, pickingBuffer, renderer) {\n      (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, NodeCompoundProgram);\n      _defineProperty(this, \"drawLabel\", drawLabel);\n      _defineProperty(this, \"drawHover\", drawHover);\n      this.programs = programClasses.map(function (Program) {\n        return new Program(gl, pickingBuffer, renderer);\n      });\n    }\n    (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(NodeCompoundProgram, [{\n      key: \"reallocate\",\n      value: function reallocate(capacity) {\n        this.programs.forEach(function (program) {\n          return program.reallocate(capacity);\n        });\n      }\n    }, {\n      key: \"process\",\n      value: function process(nodeIndex, offset, data) {\n        this.programs.forEach(function (program) {\n          return program.process(nodeIndex, offset, data);\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render(params) {\n        this.programs.forEach(function (program) {\n          return program.render(params);\n        });\n      }\n    }, {\n      key: \"kill\",\n      value: function kill() {\n        this.programs.forEach(function (program) {\n          return program.kill();\n        });\n      }\n    }]);\n    return NodeCompoundProgram;\n  }();\n}\n\nvar AbstractEdgeProgram = /*#__PURE__*/function (_AbstractProgram) {\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(AbstractEdgeProgram, _AbstractProgram);\n  function AbstractEdgeProgram() {\n    (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, AbstractEdgeProgram);\n    return (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, AbstractEdgeProgram, arguments);\n  }\n  return (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(AbstractEdgeProgram);\n}(AbstractProgram);\nvar EdgeProgram = /*#__PURE__*/function (_ref) {\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeProgram, _ref);\n  function EdgeProgram() {\n    var _this;\n    (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, EdgeProgram);\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    _this = (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeProgram, [].concat(args));\n    _defineProperty((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(_this), \"drawLabel\", undefined);\n    return _this;\n  }\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(EdgeProgram, [{\n    key: \"kill\",\n    value: function kill() {\n      return undefined;\n    }\n  }, {\n    key: \"process\",\n    value: function process(edgeIndex, offset, sourceData, targetData, data) {\n      var i = offset * this.STRIDE;\n      // NOTE: dealing with hidden items automatically\n      if (data.hidden || sourceData.hidden || targetData.hidden) {\n        for (var l = i + this.STRIDE; i < l; i++) {\n          this.array[i] = 0;\n        }\n        return;\n      }\n      return this.processVisibleItem((0,_colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_1__.i)(edgeIndex), i, sourceData, targetData, data);\n    }\n  }]);\n  return EdgeProgram;\n}(Program);\n/**\n * Helper function combining two or more programs into a single compound one.\n * Note that this is more a quick & easy way to combine program than a really\n * performant option. More performant programs can be written entirely.\n *\n * @param  {array}    programClasses - Program classes to combine.\n * @param  {function} drawLabel - An optional edge \"draw label\" function.\n * @return {function}\n */\nfunction createEdgeCompoundProgram(programClasses, drawLabel) {\n  return /*#__PURE__*/function () {\n    function EdgeCompoundProgram(gl, pickingBuffer, renderer) {\n      (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, EdgeCompoundProgram);\n      _defineProperty(this, \"drawLabel\", drawLabel);\n      this.programs = programClasses.map(function (Program) {\n        return new Program(gl, pickingBuffer, renderer);\n      });\n    }\n    (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(EdgeCompoundProgram, [{\n      key: \"reallocate\",\n      value: function reallocate(capacity) {\n        this.programs.forEach(function (program) {\n          return program.reallocate(capacity);\n        });\n      }\n    }, {\n      key: \"process\",\n      value: function process(edgeIndex, offset, sourceData, targetData, data) {\n        this.programs.forEach(function (program) {\n          return program.process(edgeIndex, offset, sourceData, targetData, data);\n        });\n      }\n    }, {\n      key: \"render\",\n      value: function render(params) {\n        this.programs.forEach(function (program) {\n          return program.render(params);\n        });\n      }\n    }, {\n      key: \"kill\",\n      value: function kill() {\n        this.programs.forEach(function (program) {\n          return program.kill();\n        });\n      }\n    }]);\n    return EdgeCompoundProgram;\n  }();\n}\n\nfunction drawStraightEdgeLabel(context, edgeData, sourceData, targetData, settings) {\n  var size = settings.edgeLabelSize,\n    font = settings.edgeLabelFont,\n    weight = settings.edgeLabelWeight,\n    color = settings.edgeLabelColor.attribute ? edgeData[settings.edgeLabelColor.attribute] || settings.edgeLabelColor.color || \"#000\" : settings.edgeLabelColor.color;\n  var label = edgeData.label;\n  if (!label) return;\n  context.fillStyle = color;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n\n  // Computing positions without considering nodes sizes:\n  var sSize = sourceData.size;\n  var tSize = targetData.size;\n  var sx = sourceData.x;\n  var sy = sourceData.y;\n  var tx = targetData.x;\n  var ty = targetData.y;\n  var cx = (sx + tx) / 2;\n  var cy = (sy + ty) / 2;\n  var dx = tx - sx;\n  var dy = ty - sy;\n  var d = Math.sqrt(dx * dx + dy * dy);\n  if (d < sSize + tSize) return;\n\n  // Adding nodes sizes:\n  sx += dx * sSize / d;\n  sy += dy * sSize / d;\n  tx -= dx * tSize / d;\n  ty -= dy * tSize / d;\n  cx = (sx + tx) / 2;\n  cy = (sy + ty) / 2;\n  dx = tx - sx;\n  dy = ty - sy;\n  d = Math.sqrt(dx * dx + dy * dy);\n\n  // Handling ellipsis\n  var textLength = context.measureText(label).width;\n  if (textLength > d) {\n    var ellipsis = \"\";\n    label = label + ellipsis;\n    textLength = context.measureText(label).width;\n    while (textLength > d && label.length > 1) {\n      label = label.slice(0, -2) + ellipsis;\n      textLength = context.measureText(label).width;\n    }\n    if (label.length < 4) return;\n  }\n  var angle;\n  if (dx > 0) {\n    if (dy > 0) angle = Math.acos(dx / d);else angle = Math.asin(dy / d);\n  } else {\n    if (dy > 0) angle = Math.acos(dx / d) + Math.PI;else angle = Math.asin(dx / d) + Math.PI / 2;\n  }\n  context.save();\n  context.translate(cx, cy);\n  context.rotate(angle);\n  context.fillText(label, -textLength / 2, edgeData.size / 2 + size);\n  context.restore();\n}\n\nfunction drawDiscNodeLabel(context, data, settings) {\n  if (!data.label) return;\n  var size = settings.labelSize,\n    font = settings.labelFont,\n    weight = settings.labelWeight,\n    color = settings.labelColor.attribute ? data[settings.labelColor.attribute] || settings.labelColor.color || \"#000\" : settings.labelColor.color;\n  context.fillStyle = color;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n  context.fillText(data.label, data.x + data.size + 3, data.y + size / 3);\n}\n\n/**\n * Draw an hovered node.\n * - if there is no label => display a shadow on the node\n * - if the label box is bigger than node size => display a label box that contains the node with a shadow\n * - else node with shadow and the label box\n */\nfunction drawDiscNodeHover(context, data, settings) {\n  var size = settings.labelSize,\n    font = settings.labelFont,\n    weight = settings.labelWeight;\n  context.font = \"\".concat(weight, \" \").concat(size, \"px \").concat(font);\n\n  // Then we draw the label background\n  context.fillStyle = \"#FFF\";\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 8;\n  context.shadowColor = \"#000\";\n  var PADDING = 2;\n  if (typeof data.label === \"string\") {\n    var textWidth = context.measureText(data.label).width,\n      boxWidth = Math.round(textWidth + 5),\n      boxHeight = Math.round(size + 2 * PADDING),\n      radius = Math.max(data.size, size / 2) + PADDING;\n    var angleRadian = Math.asin(boxHeight / 2 / radius);\n    var xDeltaCoord = Math.sqrt(Math.abs(Math.pow(radius, 2) - Math.pow(boxHeight / 2, 2)));\n    context.beginPath();\n    context.moveTo(data.x + xDeltaCoord, data.y + boxHeight / 2);\n    context.lineTo(data.x + radius + boxWidth, data.y + boxHeight / 2);\n    context.lineTo(data.x + radius + boxWidth, data.y - boxHeight / 2);\n    context.lineTo(data.x + xDeltaCoord, data.y - boxHeight / 2);\n    context.arc(data.x, data.y, radius, angleRadian, -angleRadian);\n    context.closePath();\n    context.fill();\n  } else {\n    context.beginPath();\n    context.arc(data.x, data.y, data.size + PADDING, 0, Math.PI * 2);\n    context.closePath();\n    context.fill();\n  }\n  context.shadowOffsetX = 0;\n  context.shadowOffsetY = 0;\n  context.shadowBlur = 0;\n\n  // And finally we draw the label\n  drawDiscNodeLabel(context, data, settings);\n}\n\n// language=GLSL\nvar SHADER_SOURCE$6 = /*glsl*/\"\\nprecision highp float;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_diffVector;\\nvarying float v_radius;\\n\\nuniform float u_correctionRatio;\\n\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  float border = u_correctionRatio * 2.0;\\n  float dist = length(v_diffVector) - v_radius + border;\\n\\n  // No antialiasing for picking mode:\\n  #ifdef PICKING_MODE\\n  if (dist > border)\\n    gl_FragColor = transparent;\\n  else\\n    gl_FragColor = v_color;\\n\\n  #else\\n  float t = 0.0;\\n  if (dist > border)\\n    t = 1.0;\\n  else if (dist > 0.0)\\n    t = dist / border;\\n\\n  gl_FragColor = mix(v_color, transparent, t);\\n  #endif\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$2 = SHADER_SOURCE$6;\n\n// language=GLSL\nvar SHADER_SOURCE$5 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_position;\\nattribute float a_size;\\nattribute float a_angle;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_diffVector;\\nvarying float v_radius;\\nvarying float v_border;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  float size = a_size * u_correctionRatio / u_sizeRatio * 4.0;\\n  vec2 diffVector = size * vec2(cos(a_angle), sin(a_angle));\\n  vec2 position = a_position + diffVector;\\n  gl_Position = vec4(\\n    (u_matrix * vec3(position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  v_diffVector = diffVector;\\n  v_radius = size / 2.0;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$3 = SHADER_SOURCE$5;\n\nvar _WebGLRenderingContex$3 = WebGLRenderingContext,\n  UNSIGNED_BYTE$3 = _WebGLRenderingContex$3.UNSIGNED_BYTE,\n  FLOAT$3 = _WebGLRenderingContex$3.FLOAT;\nvar UNIFORMS$2 = [\"u_sizeRatio\", \"u_correctionRatio\", \"u_matrix\"];\nvar NodeCircleProgram = /*#__PURE__*/function (_NodeProgram) {\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(NodeCircleProgram, _NodeProgram);\n  function NodeCircleProgram() {\n    (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, NodeCircleProgram);\n    return (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, NodeCircleProgram, arguments);\n  }\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(NodeCircleProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 3,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$3,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$2,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS: UNIFORMS$2,\n        ATTRIBUTES: [{\n          name: \"a_position\",\n          size: 2,\n          type: FLOAT$3\n        }, {\n          name: \"a_size\",\n          size: 1,\n          type: FLOAT$3\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$3,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$3,\n          normalized: true\n        }],\n        CONSTANT_ATTRIBUTES: [{\n          name: \"a_angle\",\n          size: 1,\n          type: FLOAT$3\n        }],\n        CONSTANT_DATA: [[NodeCircleProgram.ANGLE_1], [NodeCircleProgram.ANGLE_2], [NodeCircleProgram.ANGLE_3]]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(nodeIndex, startIndex, data) {\n      var array = this.array;\n      var color = (0,_colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);\n      array[startIndex++] = data.x;\n      array[startIndex++] = data.y;\n      array[startIndex++] = data.size;\n      array[startIndex++] = color;\n      array[startIndex++] = nodeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_correctionRatio = uniformLocations.u_correctionRatio,\n        u_matrix = uniformLocations.u_matrix;\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n    }\n  }]);\n  return NodeCircleProgram;\n}(NodeProgram);\n_defineProperty(NodeCircleProgram, \"ANGLE_1\", 0);\n_defineProperty(NodeCircleProgram, \"ANGLE_2\", 2 * Math.PI / 3);\n_defineProperty(NodeCircleProgram, \"ANGLE_3\", 4 * Math.PI / 3);\n\n// language=GLSL\nvar SHADER_SOURCE$4 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\n\\nvoid main(void) {\\n  gl_FragColor = v_color;\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$1 = SHADER_SOURCE$4;\n\n// language=GLSL\nvar SHADER_SOURCE$3 = /*glsl*/\"\\nattribute vec2 a_position;\\nattribute vec2 a_normal;\\nattribute float a_radius;\\nattribute vec3 a_barycentric;\\n\\n#ifdef PICKING_MODE\\nattribute vec4 a_id;\\n#else\\nattribute vec4 a_color;\\n#endif\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\n\\nconst float minThickness = 1.7;\\nconst float bias = 255.0 / 254.0;\\nconst float arrowHeadWidthLengthRatio = 0.66;\\nconst float arrowHeadLengthThicknessRatio = 2.5;\\n\\nvoid main() {\\n  float normalLength = length(a_normal);\\n  vec2 unitNormal = a_normal / normalLength;\\n\\n  // These first computations are taken from edge.vert.glsl and\\n  // edge.clamped.vert.glsl. Please read it to get better comments on what's\\n  // happening:\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n  float webGLNodeRadius = a_radius * 2.0 * u_correctionRatio / u_sizeRatio;\\n  float webGLArrowHeadLength = webGLThickness * 2.0 * arrowHeadLengthThicknessRatio;\\n  float webGLArrowHeadHalfWidth = webGLArrowHeadLength * arrowHeadWidthLengthRatio / 2.0;\\n\\n  float da = a_barycentric.x;\\n  float db = a_barycentric.y;\\n  float dc = a_barycentric.z;\\n\\n  vec2 delta = vec2(\\n      da * (webGLNodeRadius * unitNormal.y)\\n    + db * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y + webGLArrowHeadHalfWidth * unitNormal.x)\\n    + dc * ((webGLNodeRadius + webGLArrowHeadLength) * unitNormal.y - webGLArrowHeadHalfWidth * unitNormal.x),\\n\\n      da * (-webGLNodeRadius * unitNormal.x)\\n    + db * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x + webGLArrowHeadHalfWidth * unitNormal.y)\\n    + dc * (-(webGLNodeRadius + webGLArrowHeadLength) * unitNormal.x - webGLArrowHeadHalfWidth * unitNormal.y)\\n  );\\n\\n  vec2 position = (u_matrix * vec3(a_position + delta, 1)).xy;\\n\\n  gl_Position = vec4(position, 0, 1);\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$2 = SHADER_SOURCE$3;\n\nvar _WebGLRenderingContex$2 = WebGLRenderingContext,\n  UNSIGNED_BYTE$2 = _WebGLRenderingContex$2.UNSIGNED_BYTE,\n  FLOAT$2 = _WebGLRenderingContex$2.FLOAT;\nvar UNIFORMS$1 = [\"u_matrix\", \"u_sizeRatio\", \"u_correctionRatio\"];\nvar EdgeArrowHeadProgram = /*#__PURE__*/function (_EdgeProgram) {\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeArrowHeadProgram, _EdgeProgram);\n  function EdgeArrowHeadProgram() {\n    (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, EdgeArrowHeadProgram);\n    return (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeArrowHeadProgram, arguments);\n  }\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(EdgeArrowHeadProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 3,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$2,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$1,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS: UNIFORMS$1,\n        ATTRIBUTES: [{\n          name: \"a_position\",\n          size: 2,\n          type: FLOAT$2\n        }, {\n          name: \"a_normal\",\n          size: 2,\n          type: FLOAT$2\n        }, {\n          name: \"a_radius\",\n          size: 1,\n          type: FLOAT$2\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$2,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$2,\n          normalized: true\n        }],\n        CONSTANT_ATTRIBUTES: [{\n          name: \"a_barycentric\",\n          size: 3,\n          type: FLOAT$2\n        }],\n        CONSTANT_DATA: [[1, 0, 0], [0, 1, 0], [0, 0, 1]]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var thickness = data.size || 1;\n      var radius = targetData.size || 1;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = (0,_colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);\n\n      // Computing normals\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var len = dx * dx + dy * dy;\n      var n1 = 0;\n      var n2 = 0;\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len * thickness;\n        n2 = dx * len * thickness;\n      }\n      var array = this.array;\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = -n1;\n      array[startIndex++] = -n2;\n      array[startIndex++] = radius;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_matrix = uniformLocations.u_matrix,\n        u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_correctionRatio = uniformLocations.u_correctionRatio;\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n    }\n  }]);\n  return EdgeArrowHeadProgram;\n}(EdgeProgram);\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(object);\n    if (object === null) break;\n  }\n  return object;\n}\n\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get.bind();\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}\n\n// language=GLSL\nvar SHADER_SOURCE$2 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\n\\nconst float feather = 0.001;\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  // We only handle antialiasing for normal mode:\\n  #ifdef PICKING_MODE\\n  gl_FragColor = v_color;\\n  #else\\n  float dist = length(v_normal) * v_thickness;\\n\\n  float t = smoothstep(\\n    v_thickness - feather,\\n    v_thickness,\\n    dist\\n  );\\n\\n  gl_FragColor = mix(v_color, transparent, t);\\n  #endif\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE = SHADER_SOURCE$2;\n\n// language=GLSL\nvar SHADER_SOURCE$1 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute float a_normalCoef;\\nattribute vec2 a_positionStart;\\nattribute vec2 a_positionEnd;\\nattribute float a_positionCoef;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_zoomRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\n\\nconst float minThickness = 1.7;\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  vec2 normal = a_normal * a_normalCoef;\\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\\n\\n  float normalLength = length(normal);\\n  vec2 unitNormal = normal / normalLength;\\n\\n  // We require edges to be at least \\\"minThickness\\\" pixels thick *on screen*\\n  // (so we need to compensate the size ratio):\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n\\n  // Then, we need to retrieve the normalized thickness of the edge in the WebGL\\n  // referential (in a ([0, 1], [0, 1]) space), using our \\\"magic\\\" correction\\n  // ratio:\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n\\n  // Here is the proper position of the vertex\\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness, 1)).xy, 0, 1);\\n\\n  // For the fragment shader though, we need a thickness that takes the \\\"magic\\\"\\n  // correction ratio into account (as in webGLThickness), but so that the\\n  // antialiasing effect does not depend on the zoom level. So here's yet\\n  // another thickness version:\\n  v_thickness = webGLThickness / u_zoomRatio;\\n\\n  v_normal = unitNormal;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$1 = SHADER_SOURCE$1;\n\nvar _WebGLRenderingContex$1 = WebGLRenderingContext,\n  UNSIGNED_BYTE$1 = _WebGLRenderingContex$1.UNSIGNED_BYTE,\n  FLOAT$1 = _WebGLRenderingContex$1.FLOAT;\nvar UNIFORMS = [\"u_matrix\", \"u_zoomRatio\", \"u_sizeRatio\", \"u_correctionRatio\"];\nvar EdgeRectangleProgram = /*#__PURE__*/function (_EdgeProgram) {\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeRectangleProgram, _EdgeProgram);\n  function EdgeRectangleProgram() {\n    (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, EdgeRectangleProgram);\n    return (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeRectangleProgram, arguments);\n  }\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(EdgeRectangleProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 6,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$1,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS: UNIFORMS,\n        ATTRIBUTES: [{\n          name: \"a_positionStart\",\n          size: 2,\n          type: FLOAT$1\n        }, {\n          name: \"a_positionEnd\",\n          size: 2,\n          type: FLOAT$1\n        }, {\n          name: \"a_normal\",\n          size: 2,\n          type: FLOAT$1\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$1,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$1,\n          normalized: true\n        }],\n        CONSTANT_ATTRIBUTES: [\n        // If 0, then position will be a_positionStart\n        // If 2, then position will be a_positionEnd\n        {\n          name: \"a_positionCoef\",\n          size: 1,\n          type: FLOAT$1\n        }, {\n          name: \"a_normalCoef\",\n          size: 1,\n          type: FLOAT$1\n        }],\n        CONSTANT_DATA: [[0, 1], [0, -1], [1, 1], [1, 1], [0, -1], [1, -1]]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var thickness = data.size || 1;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = (0,_colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);\n\n      // Computing normals\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var len = dx * dx + dy * dy;\n      var n1 = 0;\n      var n2 = 0;\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len * thickness;\n        n2 = dx * len * thickness;\n      }\n      var array = this.array;\n      array[startIndex++] = x1;\n      array[startIndex++] = y1;\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = n1;\n      array[startIndex++] = n2;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_matrix = uniformLocations.u_matrix,\n        u_zoomRatio = uniformLocations.u_zoomRatio,\n        u_correctionRatio = uniformLocations.u_correctionRatio,\n        u_sizeRatio = uniformLocations.u_sizeRatio;\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n      gl.uniform1f(u_zoomRatio, params.zoomRatio);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n    }\n  }]);\n  return EdgeRectangleProgram;\n}(EdgeProgram);\n\n// language=GLSL\nvar SHADER_SOURCE = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute float a_normalCoef;\\nattribute vec2 a_positionStart;\\nattribute vec2 a_positionEnd;\\nattribute float a_positionCoef;\\nattribute float a_radius;\\nattribute float a_radiusCoef;\\n\\nuniform mat3 u_matrix;\\nuniform float u_zoomRatio;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_normal;\\nvarying float v_thickness;\\n\\nconst float minThickness = 1.7;\\nconst float bias = 255.0 / 254.0;\\nconst float arrowHeadLengthThicknessRatio = 2.5;\\n\\nvoid main() {\\n  float radius = a_radius * a_radiusCoef;\\n  vec2 normal = a_normal * a_normalCoef;\\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\\n\\n  float normalLength = length(normal);\\n  vec2 unitNormal = normal / normalLength;\\n\\n  // These first computations are taken from edge.vert.glsl. Please read it to\\n  // get better comments on what's happening:\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n\\n  // Here, we move the point to leave space for the arrow head:\\n  float direction = sign(radius);\\n  float webGLNodeRadius = direction * radius * 2.0 * u_correctionRatio / u_sizeRatio;\\n  float webGLArrowHeadLength = webGLThickness * 2.0 * arrowHeadLengthThicknessRatio;\\n\\n  vec2 compensationVector = vec2(-direction * unitNormal.y, direction * unitNormal.x) * (webGLNodeRadius + webGLArrowHeadLength);\\n\\n  // Here is the proper position of the vertex\\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness + compensationVector, 1)).xy, 0, 1);\\n\\n  v_thickness = webGLThickness / u_zoomRatio;\\n\\n  v_normal = unitNormal;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE = SHADER_SOURCE;\n\nvar _WebGLRenderingContex = WebGLRenderingContext,\n  UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE,\n  FLOAT = _WebGLRenderingContex.FLOAT;\nvar EdgeClampedProgram = /*#__PURE__*/function (_EdgeRectangleProgram) {\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__._)(EdgeClampedProgram, _EdgeRectangleProgram);\n  function EdgeClampedProgram() {\n    (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(this, EdgeClampedProgram);\n    return (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(this, EdgeClampedProgram, arguments);\n  }\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(EdgeClampedProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return _objectSpread2(_objectSpread2({}, _get((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(EdgeClampedProgram.prototype), \"getDefinition\", this).call(this)), {}, {\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,\n        ATTRIBUTES: [{\n          name: \"a_positionStart\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_positionEnd\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_normal\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }, {\n          name: \"a_radius\",\n          size: 1,\n          type: FLOAT\n        }],\n        CONSTANT_ATTRIBUTES: [\n        // If 0, then position will be a_positionStart\n        // If 1, then position will be a_positionEnd\n        {\n          name: \"a_positionCoef\",\n          size: 1,\n          type: FLOAT\n        }, {\n          name: \"a_normalCoef\",\n          size: 1,\n          type: FLOAT\n        }, {\n          name: \"a_radiusCoef\",\n          size: 1,\n          type: FLOAT\n        }],\n        CONSTANT_DATA: [[0, 1, 0], [0, -1, 0], [1, 1, 1], [1, 1, 1], [0, -1, 0], [1, -1, -1]]\n      });\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var thickness = data.size || 1;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = (0,_colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_1__.f)(data.color);\n\n      // Computing normals\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var radius = targetData.size || 1;\n      var len = dx * dx + dy * dy;\n      var n1 = 0;\n      var n2 = 0;\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len * thickness;\n        n2 = dx * len * thickness;\n      }\n      var array = this.array;\n      array[startIndex++] = x1;\n      array[startIndex++] = y1;\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = n1;\n      array[startIndex++] = n2;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n      array[startIndex++] = radius;\n    }\n  }]);\n  return EdgeClampedProgram;\n}(EdgeRectangleProgram);\n\n/**\n * Sigma.js WebGL Renderer Edge Arrow Program\n * ===========================================\n *\n * Compound program rendering edges as an arrow from the source to the target.\n * @module\n */\nvar EdgeArrowProgram = createEdgeCompoundProgram([EdgeClampedProgram, EdgeArrowHeadProgram]);\nvar EdgeArrowProgram$1 = EdgeArrowProgram;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2lnbWEvZGlzdC9pbmRleC0yOWFjYzg4My5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZMO0FBQy9HOztBQUU5RTtBQUNBLFFBQVEsNERBQWE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLE9BQU87QUFDekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1S0FBdUs7QUFDdks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLG1DQUFtQyw0REFBWTtBQUMvQztBQUNBO0FBQ0EsRUFBRSw0REFBZTtBQUNqQixDQUFDO0FBQ0Q7QUFDQTtBQUNBLElBQUksNERBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QXNHLHVGQUF1RixzRkFBc0YscUlBQXFJLHFLQUFxSyxpREFBaUQsNEJBQTRCLGdHQUFnRyx3RUFBd0Usa0NBQWtDLEdBQUc7QUFDbCtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSw0REFBUztBQUNYO0FBQ0EsSUFBSSw0REFBZTtBQUNuQixXQUFXLDREQUFVO0FBQ3JCO0FBQ0EsRUFBRSw0REFBWTtBQUNkO0FBQ0E7QUFDQSw2Q0FBNkMsT0FBTyw0REFBZSxzRUFBc0U7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDBEQUFVOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRXVoQiIsInNvdXJjZXMiOlsid2VicGFjazovL3Nwb25zYXJ1Ly4vbm9kZV9tb2R1bGVzL3NpZ21hL2Rpc3QvaW5kZXgtMjlhY2M4ODMuZXNtLmpzPzc3YmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdCBhcyB0b1Byb3BlcnR5S2V5LCBkIGFzIF9jcmVhdGVDbGFzcywgYSBhcyBfY2xhc3NDYWxsQ2hlY2ssIF8gYXMgX2luaGVyaXRzLCBiIGFzIF9jYWxsU3VwZXIsIGMgYXMgX2Fzc2VydFRoaXNJbml0aWFsaXplZCwgZSBhcyBfZ2V0UHJvdG90eXBlT2YgfSBmcm9tICcuL2luaGVyaXRzLThmYmRlZGI1LmVzbS5qcyc7XG5pbXBvcnQgeyBpIGFzIGluZGV4VG9Db2xvciwgZiBhcyBmbG9hdENvbG9yIH0gZnJvbSAnLi9jb2xvcnMtMmY2ZDE3ZjAuZXNtLmpzJztcblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSB0b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIG93bktleXMoZSwgcikge1xuICB2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7XG4gICAgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMihlKSB7XG4gIGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7XG4gICAgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9O1xuICAgIHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5cbi8qKlxuICogU2lnbWEuanMgU2hhZGVyIFV0aWxzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogQ29kZSB1c2VkIHRvIGxvYWQgc2lnbWEncyBzaGFkZXJzLlxuICogQG1vZHVsZVxuICovXG5cbi8qKlxuICogRnVuY3Rpb24gdXNlZCB0byBsb2FkIGEgc2hhZGVyLlxuICovXG5mdW5jdGlvbiBsb2FkU2hhZGVyKHR5cGUsIGdsLCBzb3VyY2UpIHtcbiAgdmFyIGdsVHlwZSA9IHR5cGUgPT09IFwiVkVSVEVYXCIgPyBnbC5WRVJURVhfU0hBREVSIDogZ2wuRlJBR01FTlRfU0hBREVSO1xuXG4gIC8vIENyZWF0aW5nIHRoZSBzaGFkZXJcbiAgdmFyIHNoYWRlciA9IGdsLmNyZWF0ZVNoYWRlcihnbFR5cGUpO1xuICBpZiAoc2hhZGVyID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibG9hZFNoYWRlcjogZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIHNoYWRlclwiKTtcbiAgfVxuXG4gIC8vIExvYWRpbmcgc291cmNlXG4gIGdsLnNoYWRlclNvdXJjZShzaGFkZXIsIHNvdXJjZSk7XG5cbiAgLy8gQ29tcGlsaW5nIHRoZSBzaGFkZXJcbiAgZ2wuY29tcGlsZVNoYWRlcihzaGFkZXIpO1xuXG4gIC8vIFJldHJpZXZpbmcgY29tcGlsYXRpb24gc3RhdHVzXG4gIHZhciBzdWNjZXNzZnVsbHlDb21waWxlZCA9IGdsLmdldFNoYWRlclBhcmFtZXRlcihzaGFkZXIsIGdsLkNPTVBJTEVfU1RBVFVTKTtcblxuICAvLyBUaHJvd2luZyBpZiBzb21ldGhpbmcgd2VudCBhd3J5XG4gIGlmICghc3VjY2Vzc2Z1bGx5Q29tcGlsZWQpIHtcbiAgICB2YXIgaW5mb0xvZyA9IGdsLmdldFNoYWRlckluZm9Mb2coc2hhZGVyKTtcbiAgICBnbC5kZWxldGVTaGFkZXIoc2hhZGVyKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJsb2FkU2hhZGVyOiBlcnJvciB3aGlsZSBjb21waWxpbmcgdGhlIHNoYWRlcjpcXG5cIi5jb25jYXQoaW5mb0xvZywgXCJcXG5cIikuY29uY2F0KHNvdXJjZSkpO1xuICB9XG4gIHJldHVybiBzaGFkZXI7XG59XG5mdW5jdGlvbiBsb2FkVmVydGV4U2hhZGVyKGdsLCBzb3VyY2UpIHtcbiAgcmV0dXJuIGxvYWRTaGFkZXIoXCJWRVJURVhcIiwgZ2wsIHNvdXJjZSk7XG59XG5mdW5jdGlvbiBsb2FkRnJhZ21lbnRTaGFkZXIoZ2wsIHNvdXJjZSkge1xuICByZXR1cm4gbG9hZFNoYWRlcihcIkZSQUdNRU5UXCIsIGdsLCBzb3VyY2UpO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHVzZWQgdG8gbG9hZCBhIHByb2dyYW0uXG4gKi9cbmZ1bmN0aW9uIGxvYWRQcm9ncmFtKGdsLCBzaGFkZXJzKSB7XG4gIHZhciBwcm9ncmFtID0gZ2wuY3JlYXRlUHJvZ3JhbSgpO1xuICBpZiAocHJvZ3JhbSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImxvYWRQcm9ncmFtOiBlcnJvciB3aGlsZSBjcmVhdGluZyB0aGUgcHJvZ3JhbS5cIik7XG4gIH1cbiAgdmFyIGksIGw7XG5cbiAgLy8gQXR0YWNoaW5nIHRoZSBzaGFkZXJzXG4gIGZvciAoaSA9IDAsIGwgPSBzaGFkZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykgZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHNoYWRlcnNbaV0pO1xuICBnbC5saW5rUHJvZ3JhbShwcm9ncmFtKTtcblxuICAvLyBDaGVja2luZyBzdGF0dXNcbiAgdmFyIHN1Y2Nlc3NmdWxseUxpbmtlZCA9IGdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgZ2wuTElOS19TVEFUVVMpO1xuICBpZiAoIXN1Y2Nlc3NmdWxseUxpbmtlZCkge1xuICAgIGdsLmRlbGV0ZVByb2dyYW0ocHJvZ3JhbSk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibG9hZFByb2dyYW06IGVycm9yIHdoaWxlIGxpbmtpbmcgdGhlIHByb2dyYW0uXCIpO1xuICB9XG4gIHJldHVybiBwcm9ncmFtO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHVzZSB0byBwcmludCBhIGZsb2F0IGZvciBpbnNlcnRpbmcgaW4gYSBHTFNMIHByb2dyYW0uXG4gKi9cbmZ1bmN0aW9uIG51bWJlclRvR0xTTEZsb2F0KG4pIHtcbiAgcmV0dXJuIG4gJSAxID09PSAwID8gbi50b0ZpeGVkKDEpIDogbi50b1N0cmluZygpO1xufVxuXG52YXIgUElDS0lOR19QUkVGSVggPSBcIiNkZWZpbmUgUElDS0lOR19NT0RFXFxuXCI7XG52YXIgU0laRV9GQUNUT1JfUEVSX0FUVFJJQlVURV9UWVBFID0gX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eShfZGVmaW5lUHJvcGVydHkoX2RlZmluZVByb3BlcnR5KF9kZWZpbmVQcm9wZXJ0eSh7fSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5CT09MLCAxKSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5CWVRFLCAxKSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5VTlNJR05FRF9CWVRFLCAxKSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5TSE9SVCwgMiksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfU0hPUlQsIDIpLCBXZWJHTDJSZW5kZXJpbmdDb250ZXh0LklOVCwgNCksIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQuVU5TSUdORURfSU5ULCA0KSwgV2ViR0wyUmVuZGVyaW5nQ29udGV4dC5GTE9BVCwgNCk7XG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVJdGVtc0NvdW50KGF0dHIpIHtcbiAgcmV0dXJuIGF0dHIubm9ybWFsaXplZCA/IDEgOiBhdHRyLnNpemU7XG59XG5mdW5jdGlvbiBnZXRBdHRyaWJ1dGVzSXRlbXNDb3VudChhdHRycykge1xuICB2YXIgcmVzID0gMDtcbiAgYXR0cnMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgIHJldHVybiByZXMgKz0gZ2V0QXR0cmlidXRlSXRlbXNDb3VudChhdHRyKTtcbiAgfSk7XG4gIHJldHVybiByZXM7XG59XG52YXIgQWJzdHJhY3RQcm9ncmFtID0gLyojX19QVVJFX18qL19jcmVhdGVDbGFzcyhcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZW1wdHktZnVuY3Rpb25cbmZ1bmN0aW9uIEFic3RyYWN0UHJvZ3JhbShfZ2wsIF9waWNrR2wsIF9yZW5kZXJlcikge1xuICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJzdHJhY3RQcm9ncmFtKTtcbn0pO1xudmFyIFByb2dyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQcm9ncmFtKGdsLCBwaWNraW5nQnVmZmVyLCByZW5kZXJlcikge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBQcm9ncmFtKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJhcnJheVwiLCBuZXcgRmxvYXQzMkFycmF5KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbnN0YW50QXJyYXlcIiwgbmV3IEZsb2F0MzJBcnJheSgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjYXBhY2l0eVwiLCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJ0aWNlc0NvdW50XCIsIDApO1xuICAgIC8vIFJlYWRpbmcgYW5kIGNhY2hpbmcgcHJvZ3JhbSBkZWZpbml0aW9uXG4gICAgdmFyIGRlZiA9IHRoaXMuZ2V0RGVmaW5pdGlvbigpO1xuICAgIHRoaXMuVkVSVElDRVMgPSBkZWYuVkVSVElDRVM7XG4gICAgdGhpcy5WRVJURVhfU0hBREVSX1NPVVJDRSA9IGRlZi5WRVJURVhfU0hBREVSX1NPVVJDRTtcbiAgICB0aGlzLkZSQUdNRU5UX1NIQURFUl9TT1VSQ0UgPSBkZWYuRlJBR01FTlRfU0hBREVSX1NPVVJDRTtcbiAgICB0aGlzLlVOSUZPUk1TID0gZGVmLlVOSUZPUk1TO1xuICAgIHRoaXMuQVRUUklCVVRFUyA9IGRlZi5BVFRSSUJVVEVTO1xuICAgIHRoaXMuTUVUSE9EID0gZGVmLk1FVEhPRDtcbiAgICB0aGlzLkNPTlNUQU5UX0FUVFJJQlVURVMgPSBcIkNPTlNUQU5UX0FUVFJJQlVURVNcIiBpbiBkZWYgPyBkZWYuQ09OU1RBTlRfQVRUUklCVVRFUyA6IFtdO1xuICAgIHRoaXMuQ09OU1RBTlRfREFUQSA9IFwiQ09OU1RBTlRfREFUQVwiIGluIGRlZiA/IGRlZi5DT05TVEFOVF9EQVRBIDogW107XG4gICAgdGhpcy5pc0luc3RhbmNlZCA9IFwiQ09OU1RBTlRfQVRUUklCVVRFU1wiIGluIGRlZjtcblxuICAgIC8vIENvbXB1dGluZyBzdHJpZGVcbiAgICB0aGlzLkFUVFJJQlVURVNfSVRFTVNfQ09VTlQgPSBnZXRBdHRyaWJ1dGVzSXRlbXNDb3VudCh0aGlzLkFUVFJJQlVURVMpO1xuICAgIHRoaXMuU1RSSURFID0gdGhpcy5WRVJUSUNFUyAqIHRoaXMuQVRUUklCVVRFU19JVEVNU19DT1VOVDtcblxuICAgIC8vIE1lbWJlcnNcbiAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgdGhpcy5ub3JtYWxQcm9ncmFtID0gdGhpcy5nZXRQcm9ncmFtSW5mbyhcIm5vcm1hbFwiLCBnbCwgZGVmLlZFUlRFWF9TSEFERVJfU09VUkNFLCBkZWYuRlJBR01FTlRfU0hBREVSX1NPVVJDRSwgbnVsbCk7XG4gICAgdGhpcy5waWNrUHJvZ3JhbSA9IHBpY2tpbmdCdWZmZXIgPyB0aGlzLmdldFByb2dyYW1JbmZvKFwicGlja1wiLCBnbCwgUElDS0lOR19QUkVGSVggKyBkZWYuVkVSVEVYX1NIQURFUl9TT1VSQ0UsIFBJQ0tJTkdfUFJFRklYICsgZGVmLkZSQUdNRU5UX1NIQURFUl9TT1VSQ0UsIHBpY2tpbmdCdWZmZXIpIDogbnVsbDtcblxuICAgIC8vIEZvciBpbnN0YW5jZWQgcHJvZ3JhbXM6XG4gICAgaWYgKHRoaXMuaXNJbnN0YW5jZWQpIHtcbiAgICAgIHZhciBjb25zdGFudEF0dHJpYnV0ZXNJdGVtc0NvdW50ID0gZ2V0QXR0cmlidXRlc0l0ZW1zQ291bnQodGhpcy5DT05TVEFOVF9BVFRSSUJVVEVTKTtcbiAgICAgIGlmICh0aGlzLkNPTlNUQU5UX0RBVEEubGVuZ3RoICE9PSB0aGlzLlZFUlRJQ0VTKSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9ncmFtOiBlcnJvciB3aGlsZSBnZXR0aW5nIGNvbnN0YW50IGRhdGEgKGV4cGVjdGVkIFwiLmNvbmNhdCh0aGlzLlZFUlRJQ0VTLCBcIiBpdGVtcywgcmVjZWl2ZWQgXCIpLmNvbmNhdCh0aGlzLkNPTlNUQU5UX0RBVEEubGVuZ3RoLCBcIiBpbnN0ZWFkKVwiKSk7XG4gICAgICB0aGlzLmNvbnN0YW50QXJyYXkgPSBuZXcgRmxvYXQzMkFycmF5KHRoaXMuQ09OU1RBTlRfREFUQS5sZW5ndGggKiBjb25zdGFudEF0dHJpYnV0ZXNJdGVtc0NvdW50KTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5DT05TVEFOVF9EQVRBLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB2ZWN0b3IgPSB0aGlzLkNPTlNUQU5UX0RBVEFbaV07XG4gICAgICAgIGlmICh2ZWN0b3IubGVuZ3RoICE9PSBjb25zdGFudEF0dHJpYnV0ZXNJdGVtc0NvdW50KSB0aHJvdyBuZXcgRXJyb3IoXCJQcm9ncmFtOiBlcnJvciB3aGlsZSBnZXR0aW5nIGNvbnN0YW50IGRhdGEgKG9uZSB2ZWN0b3IgaGFzIFwiLmNvbmNhdCh2ZWN0b3IubGVuZ3RoLCBcIiBpdGVtcyBpbnN0ZWFkIG9mIFwiKS5jb25jYXQoY29uc3RhbnRBdHRyaWJ1dGVzSXRlbXNDb3VudCwgXCIpXCIpKTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2ZWN0b3IubGVuZ3RoOyBqKyspIHRoaXMuY29uc3RhbnRBcnJheVtpICogY29uc3RhbnRBdHRyaWJ1dGVzSXRlbXNDb3VudCArIGpdID0gdmVjdG9yW2pdO1xuICAgICAgfVxuICAgICAgdGhpcy5TVFJJREUgPSB0aGlzLkFUVFJJQlVURVNfSVRFTVNfQ09VTlQ7XG4gICAgfVxuICB9XG4gIF9jcmVhdGVDbGFzcyhQcm9ncmFtLCBbe1xuICAgIGtleTogXCJnZXRQcm9ncmFtSW5mb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQcm9ncmFtSW5mbyhuYW1lLCBnbCwgdmVydGV4U2hhZGVyU291cmNlLCBmcmFnbWVudFNoYWRlclNvdXJjZSwgZnJhbWVCdWZmZXIpIHtcbiAgICAgIHZhciBkZWYgPSB0aGlzLmdldERlZmluaXRpb24oKTtcblxuICAgICAgLy8gV2ViR0wgYnVmZmVyc1xuICAgICAgdmFyIGJ1ZmZlciA9IGdsLmNyZWF0ZUJ1ZmZlcigpO1xuICAgICAgaWYgKGJ1ZmZlciA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvZ3JhbTogZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIFdlYkdMIGJ1ZmZlci5cIik7XG5cbiAgICAgIC8vIFNoYWRlcnMgYW5kIHByb2dyYW1cbiAgICAgIHZhciB2ZXJ0ZXhTaGFkZXIgPSBsb2FkVmVydGV4U2hhZGVyKGdsLCB2ZXJ0ZXhTaGFkZXJTb3VyY2UpO1xuICAgICAgdmFyIGZyYWdtZW50U2hhZGVyID0gbG9hZEZyYWdtZW50U2hhZGVyKGdsLCBmcmFnbWVudFNoYWRlclNvdXJjZSk7XG4gICAgICB2YXIgcHJvZ3JhbSA9IGxvYWRQcm9ncmFtKGdsLCBbdmVydGV4U2hhZGVyLCBmcmFnbWVudFNoYWRlcl0pO1xuXG4gICAgICAvLyBJbml0aWFsaXppbmcgbG9jYXRpb25zXG4gICAgICB2YXIgdW5pZm9ybUxvY2F0aW9ucyA9IHt9O1xuICAgICAgZGVmLlVOSUZPUk1TLmZvckVhY2goZnVuY3Rpb24gKHVuaWZvcm1OYW1lKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IGdsLmdldFVuaWZvcm1Mb2NhdGlvbihwcm9ncmFtLCB1bmlmb3JtTmFtZSk7XG4gICAgICAgIGlmIChsb2NhdGlvbikgdW5pZm9ybUxvY2F0aW9uc1t1bmlmb3JtTmFtZV0gPSBsb2NhdGlvbjtcbiAgICAgIH0pO1xuICAgICAgdmFyIGF0dHJpYnV0ZUxvY2F0aW9ucyA9IHt9O1xuICAgICAgZGVmLkFUVFJJQlVURVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICBhdHRyaWJ1dGVMb2NhdGlvbnNbYXR0ci5uYW1lXSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sIGF0dHIubmFtZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gRm9yIGluc3RhbmNlZCBwcm9ncmFtczpcbiAgICAgIHZhciBjb25zdGFudEJ1ZmZlcjtcbiAgICAgIGlmIChcIkNPTlNUQU5UX0FUVFJJQlVURVNcIiBpbiBkZWYpIHtcbiAgICAgICAgZGVmLkNPTlNUQU5UX0FUVFJJQlVURVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIGF0dHJpYnV0ZUxvY2F0aW9uc1thdHRyLm5hbWVdID0gZ2wuZ2V0QXR0cmliTG9jYXRpb24ocHJvZ3JhbSwgYXR0ci5uYW1lKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0YW50QnVmZmVyID0gZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIGlmIChjb25zdGFudEJ1ZmZlciA9PT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKFwiUHJvZ3JhbTogZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIFdlYkdMIGNvbnN0YW50IGJ1ZmZlci5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICBwcm9ncmFtOiBwcm9ncmFtLFxuICAgICAgICBnbDogZ2wsXG4gICAgICAgIGZyYW1lQnVmZmVyOiBmcmFtZUJ1ZmZlcixcbiAgICAgICAgYnVmZmVyOiBidWZmZXIsXG4gICAgICAgIGNvbnN0YW50QnVmZmVyOiBjb25zdGFudEJ1ZmZlciB8fCB7fSxcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9uczogdW5pZm9ybUxvY2F0aW9ucyxcbiAgICAgICAgYXR0cmlidXRlTG9jYXRpb25zOiBhdHRyaWJ1dGVMb2NhdGlvbnMsXG4gICAgICAgIGlzUGlja2luZzogbmFtZSA9PT0gXCJwaWNrXCJcbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImJpbmRQcm9ncmFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRQcm9ncmFtKHByb2dyYW0pIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICB2YXIgb2Zmc2V0ID0gMDtcbiAgICAgIHZhciBnbCA9IHByb2dyYW0uZ2wsXG4gICAgICAgIGJ1ZmZlciA9IHByb2dyYW0uYnVmZmVyO1xuICAgICAgaWYgKCF0aGlzLmlzSW5zdGFuY2VkKSB7XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBidWZmZXIpO1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLkFUVFJJQlVURVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIHJldHVybiBvZmZzZXQgKz0gX3RoaXMuYmluZEF0dHJpYnV0ZShhdHRyLCBwcm9ncmFtLCBvZmZzZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZ2wuYnVmZmVyRGF0YShnbC5BUlJBWV9CVUZGRVIsIHRoaXMuYXJyYXksIGdsLkRZTkFNSUNfRFJBVyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBIYW5kbGUgY29uc3RhbnQgZGF0YSAodGhpbmdzIHRoYXQgcmVtYWluIHVuY2hhbmdlZCBmb3IgYWxsIGl0ZW1zKTpcbiAgICAgICAgZ2wuYmluZEJ1ZmZlcihnbC5BUlJBWV9CVUZGRVIsIHByb2dyYW0uY29uc3RhbnRCdWZmZXIpO1xuICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICB0aGlzLkNPTlNUQU5UX0FUVFJJQlVURVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIHJldHVybiBvZmZzZXQgKz0gX3RoaXMuYmluZEF0dHJpYnV0ZShhdHRyLCBwcm9ncmFtLCBvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGdsLmJ1ZmZlckRhdGEoZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmNvbnN0YW50QXJyYXksIGdsLlNUQVRJQ19EUkFXKTtcblxuICAgICAgICAvLyBIYW5kbGUgXCJpbnN0YW5jZSBzcGVjaWZpY1wiIGRhdGEgKHRoaW5ncyB0aGF0IHZhcnkgZm9yIGVhY2ggaXRlbSk6XG4gICAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBwcm9ncmFtLmJ1ZmZlcik7XG4gICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIHRoaXMuQVRUUklCVVRFUy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgcmV0dXJuIG9mZnNldCArPSBfdGhpcy5iaW5kQXR0cmlidXRlKGF0dHIsIHByb2dyYW0sIG9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBnbC5idWZmZXJEYXRhKGdsLkFSUkFZX0JVRkZFUiwgdGhpcy5hcnJheSwgZ2wuRFlOQU1JQ19EUkFXKTtcbiAgICAgIH1cbiAgICAgIGdsLmJpbmRCdWZmZXIoZ2wuQVJSQVlfQlVGRkVSLCBudWxsKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5iaW5kUHJvZ3JhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRQcm9ncmFtKHByb2dyYW0pIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLmlzSW5zdGFuY2VkKSB7XG4gICAgICAgIHRoaXMuQVRUUklCVVRFUy5mb3JFYWNoKGZ1bmN0aW9uIChhdHRyKSB7XG4gICAgICAgICAgcmV0dXJuIF90aGlzMi51bmJpbmRBdHRyaWJ1dGUoYXR0ciwgcHJvZ3JhbSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5DT05TVEFOVF9BVFRSSUJVVEVTLmZvckVhY2goZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXMyLnVuYmluZEF0dHJpYnV0ZShhdHRyLCBwcm9ncmFtLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLkFUVFJJQlVURVMuZm9yRWFjaChmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgIHJldHVybiBfdGhpczIudW5iaW5kQXR0cmlidXRlKGF0dHIsIHByb2dyYW0sIHRydWUpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZEF0dHJpYnV0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kQXR0cmlidXRlKGF0dHIsIHByb2dyYW0sIG9mZnNldCwgc2V0RGl2aXNvcikge1xuICAgICAgdmFyIHNpemVGYWN0b3IgPSBTSVpFX0ZBQ1RPUl9QRVJfQVRUUklCVVRFX1RZUEVbYXR0ci50eXBlXTtcbiAgICAgIGlmICh0eXBlb2Ygc2l6ZUZhY3RvciAhPT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IEVycm9yKFwiUHJvZ3JhbS5iaW5kOiB5ZXQgdW5zdXBwb3J0ZWQgYXR0cmlidXRlIHR5cGUgXFxcIlwiLmNvbmNhdChhdHRyLnR5cGUsIFwiXFxcIlwiKSk7XG4gICAgICB2YXIgbG9jYXRpb24gPSBwcm9ncmFtLmF0dHJpYnV0ZUxvY2F0aW9uc1thdHRyLm5hbWVdO1xuICAgICAgdmFyIGdsID0gcHJvZ3JhbS5nbDtcbiAgICAgIGlmIChsb2NhdGlvbiAhPT0gLTEpIHtcbiAgICAgICAgZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkobG9jYXRpb24pO1xuICAgICAgICB2YXIgc3RyaWRlID0gIXRoaXMuaXNJbnN0YW5jZWQgPyB0aGlzLkFUVFJJQlVURVNfSVRFTVNfQ09VTlQgKiBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQgOiAoc2V0RGl2aXNvciA/IHRoaXMuQVRUUklCVVRFU19JVEVNU19DT1VOVCA6IGdldEF0dHJpYnV0ZXNJdGVtc0NvdW50KHRoaXMuQ09OU1RBTlRfQVRUUklCVVRFUykpICogRmxvYXQzMkFycmF5LkJZVEVTX1BFUl9FTEVNRU5UO1xuICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKGxvY2F0aW9uLCBhdHRyLnNpemUsIGF0dHIudHlwZSwgYXR0ci5ub3JtYWxpemVkIHx8IGZhbHNlLCBzdHJpZGUsIG9mZnNldCk7XG4gICAgICAgIGlmICh0aGlzLmlzSW5zdGFuY2VkICYmIHNldERpdmlzb3IpIHtcbiAgICAgICAgICBpZiAoZ2wgaW5zdGFuY2VvZiBXZWJHTDJSZW5kZXJpbmdDb250ZXh0KSB7XG4gICAgICAgICAgICBnbC52ZXJ0ZXhBdHRyaWJEaXZpc29yKGxvY2F0aW9uLCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGV4dCA9IGdsLmdldEV4dGVuc2lvbihcIkFOR0xFX2luc3RhbmNlZF9hcnJheXNcIik7XG4gICAgICAgICAgICBpZiAoZXh0KSBleHQudmVydGV4QXR0cmliRGl2aXNvckFOR0xFKGxvY2F0aW9uLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhdHRyLnNpemUgKiBzaXplRmFjdG9yO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bmJpbmRBdHRyaWJ1dGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdW5iaW5kQXR0cmlidXRlKGF0dHIsIHByb2dyYW0sIHVuc2V0RGl2aXNvcikge1xuICAgICAgdmFyIGxvY2F0aW9uID0gcHJvZ3JhbS5hdHRyaWJ1dGVMb2NhdGlvbnNbYXR0ci5uYW1lXTtcbiAgICAgIHZhciBnbCA9IHByb2dyYW0uZ2w7XG4gICAgICBpZiAobG9jYXRpb24gIT09IC0xKSB7XG4gICAgICAgIGdsLmRpc2FibGVWZXJ0ZXhBdHRyaWJBcnJheShsb2NhdGlvbik7XG4gICAgICAgIGlmICh0aGlzLmlzSW5zdGFuY2VkICYmIHVuc2V0RGl2aXNvcikge1xuICAgICAgICAgIGlmIChnbCBpbnN0YW5jZW9mIFdlYkdMMlJlbmRlcmluZ0NvbnRleHQpIHtcbiAgICAgICAgICAgIGdsLnZlcnRleEF0dHJpYkRpdmlzb3IobG9jYXRpb24sIDApO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKFwiQU5HTEVfaW5zdGFuY2VkX2FycmF5c1wiKTtcbiAgICAgICAgICAgIGlmIChleHQpIGV4dC52ZXJ0ZXhBdHRyaWJEaXZpc29yQU5HTEUobG9jYXRpb24sIDApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZWFsbG9jYXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWxsb2NhdGUoY2FwYWNpdHkpIHtcbiAgICAgIC8vIElmIGRlc2lyZWQgY2FwYWNpdHkgaGFzIG5vdCBjaGFuZ2VkIHdlIGRvIG5vdGhpbmdcbiAgICAgIC8vIE5PVEU6IGl0J3MgcG9zc2libGUgaGVyZSB0byBpbXBsZW1lbnQgbW9yZSBzdWJ0bGUgcmVhbGxvY2F0aW9uIHNjaGVtZXNcbiAgICAgIC8vIHdoZW4gdGhlIG51bWJlciBvZiByZW5kZXJlZCBpdGVtcyBpbmNyZWFzZSBvciBkZWNyZWFzZVxuICAgICAgaWYgKGNhcGFjaXR5ID09PSB0aGlzLmNhcGFjaXR5KSByZXR1cm47XG4gICAgICB0aGlzLmNhcGFjaXR5ID0gY2FwYWNpdHk7XG4gICAgICB0aGlzLnZlcnRpY2VzQ291bnQgPSB0aGlzLlZFUlRJQ0VTICogY2FwYWNpdHk7XG4gICAgICB0aGlzLmFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSghdGhpcy5pc0luc3RhbmNlZCA/IHRoaXMudmVydGljZXNDb3VudCAqIHRoaXMuQVRUUklCVVRFU19JVEVNU19DT1VOVCA6IHRoaXMuY2FwYWNpdHkgKiB0aGlzLkFUVFJJQlVURVNfSVRFTVNfQ09VTlQpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYXNOb3RoaW5nVG9SZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzTm90aGluZ1RvUmVuZGVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmVydGljZXNDb3VudCA9PT0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyUHJvZ3JhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJQcm9ncmFtKHBhcmFtcywgcHJvZ3JhbUluZm8pIHtcbiAgICAgIHZhciBnbCA9IHByb2dyYW1JbmZvLmdsLFxuICAgICAgICBwcm9ncmFtID0gcHJvZ3JhbUluZm8ucHJvZ3JhbTtcblxuICAgICAgLy8gV2l0aCB0aGUgY3VycmVudCBmaXggZm9yICMxMzk3LCB0aGUgYWxwaGEgYmxlbmRpbmcgaXMgZW5hYmxlZCBmb3IgdGhlXG4gICAgICAvLyBwaWNraW5nIGxheWVyOlxuICAgICAgZ2wuZW5hYmxlKGdsLkJMRU5EKTtcblxuICAgICAgLy8gT3JpZ2luYWwgY29kZTpcbiAgICAgIC8vIGlmICghaXNQaWNraW5nKSBnbC5lbmFibGUoZ2wuQkxFTkQpO1xuICAgICAgLy8gZWxzZSBnbC5kaXNhYmxlKGdsLkJMRU5EKTtcblxuICAgICAgZ2wudXNlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgIHRoaXMuc2V0VW5pZm9ybXMocGFyYW1zLCBwcm9ncmFtSW5mbyk7XG4gICAgICB0aGlzLmRyYXdXZWJHTCh0aGlzLk1FVEhPRCwgcHJvZ3JhbUluZm8pO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHBhcmFtcykge1xuICAgICAgaWYgKHRoaXMuaGFzTm90aGluZ1RvUmVuZGVyKCkpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLnBpY2tQcm9ncmFtKSB7XG4gICAgICAgIHRoaXMucGlja1Byb2dyYW0uZ2wudmlld3BvcnQoMCwgMCwgcGFyYW1zLndpZHRoICogcGFyYW1zLnBpeGVsUmF0aW8gLyBwYXJhbXMuZG93blNpemluZ1JhdGlvLCBwYXJhbXMuaGVpZ2h0ICogcGFyYW1zLnBpeGVsUmF0aW8gLyBwYXJhbXMuZG93blNpemluZ1JhdGlvKTtcbiAgICAgICAgdGhpcy5iaW5kUHJvZ3JhbSh0aGlzLnBpY2tQcm9ncmFtKTtcbiAgICAgICAgdGhpcy5yZW5kZXJQcm9ncmFtKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBwYXJhbXMpLCB7fSwge1xuICAgICAgICAgIHBpeGVsUmF0aW86IHBhcmFtcy5waXhlbFJhdGlvIC8gcGFyYW1zLmRvd25TaXppbmdSYXRpb1xuICAgICAgICB9KSwgdGhpcy5waWNrUHJvZ3JhbSk7XG4gICAgICAgIHRoaXMudW5iaW5kUHJvZ3JhbSh0aGlzLnBpY2tQcm9ncmFtKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubm9ybWFsUHJvZ3JhbS5nbC52aWV3cG9ydCgwLCAwLCBwYXJhbXMud2lkdGggKiBwYXJhbXMucGl4ZWxSYXRpbywgcGFyYW1zLmhlaWdodCAqIHBhcmFtcy5waXhlbFJhdGlvKTtcbiAgICAgIHRoaXMuYmluZFByb2dyYW0odGhpcy5ub3JtYWxQcm9ncmFtKTtcbiAgICAgIHRoaXMucmVuZGVyUHJvZ3JhbShwYXJhbXMsIHRoaXMubm9ybWFsUHJvZ3JhbSk7XG4gICAgICB0aGlzLnVuYmluZFByb2dyYW0odGhpcy5ub3JtYWxQcm9ncmFtKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZHJhd1dlYkdMXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRyYXdXZWJHTChtZXRob2QsIF9yZWYpIHtcbiAgICAgIHZhciBnbCA9IF9yZWYuZ2wsXG4gICAgICAgIGZyYW1lQnVmZmVyID0gX3JlZi5mcmFtZUJ1ZmZlcjtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICAgICAgaWYgKCF0aGlzLmlzSW5zdGFuY2VkKSB7XG4gICAgICAgIGdsLmRyYXdBcnJheXMobWV0aG9kLCAwLCB0aGlzLnZlcnRpY2VzQ291bnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGdsIGluc3RhbmNlb2YgV2ViR0wyUmVuZGVyaW5nQ29udGV4dCkge1xuICAgICAgICAgIGdsLmRyYXdBcnJheXNJbnN0YW5jZWQobWV0aG9kLCAwLCB0aGlzLlZFUlRJQ0VTLCB0aGlzLmNhcGFjaXR5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgZXh0ID0gZ2wuZ2V0RXh0ZW5zaW9uKFwiQU5HTEVfaW5zdGFuY2VkX2FycmF5c1wiKTtcbiAgICAgICAgICBpZiAoZXh0KSBleHQuZHJhd0FycmF5c0luc3RhbmNlZEFOR0xFKG1ldGhvZCwgMCwgdGhpcy5WRVJUSUNFUywgdGhpcy5jYXBhY2l0eSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFByb2dyYW07XG59KCk7XG5cbnZhciBBYnN0cmFjdE5vZGVQcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfQWJzdHJhY3RQcm9ncmFtKSB7XG4gIF9pbmhlcml0cyhBYnN0cmFjdE5vZGVQcm9ncmFtLCBfQWJzdHJhY3RQcm9ncmFtKTtcbiAgZnVuY3Rpb24gQWJzdHJhY3ROb2RlUHJvZ3JhbSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQWJzdHJhY3ROb2RlUHJvZ3JhbSk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgQWJzdHJhY3ROb2RlUHJvZ3JhbSwgYXJndW1lbnRzKTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUNsYXNzKEFic3RyYWN0Tm9kZVByb2dyYW0pO1xufShBYnN0cmFjdFByb2dyYW0pO1xudmFyIE5vZGVQcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfcmVmKSB7XG4gIF9pbmhlcml0cyhOb2RlUHJvZ3JhbSwgX3JlZik7XG4gIGZ1bmN0aW9uIE5vZGVQcm9ncmFtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlUHJvZ3JhbSk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgTm9kZVByb2dyYW0sIGFyZ3VtZW50cyk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKE5vZGVQcm9ncmFtLCBbe1xuICAgIGtleTogXCJraWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3Mobm9kZUluZGV4LCBvZmZzZXQsIGRhdGEpIHtcbiAgICAgIHZhciBpID0gb2Zmc2V0ICogdGhpcy5TVFJJREU7XG4gICAgICAvLyBOT1RFOiBkZWFsaW5nIHdpdGggaGlkZGVuIGl0ZW1zIGF1dG9tYXRpY2FsbHlcbiAgICAgIGlmIChkYXRhLmhpZGRlbikge1xuICAgICAgICBmb3IgKHZhciBsID0gaSArIHRoaXMuU1RSSURFOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5hcnJheVtpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMucHJvY2Vzc1Zpc2libGVJdGVtKGluZGV4VG9Db2xvcihub2RlSW5kZXgpLCBpLCBkYXRhKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE5vZGVQcm9ncmFtO1xufShQcm9ncmFtKTtcbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGNvbWJpbmluZyB0d28gb3IgbW9yZSBwcm9ncmFtcyBpbnRvIGEgc2luZ2xlIGNvbXBvdW5kIG9uZS5cbiAqIE5vdGUgdGhhdCB0aGlzIGlzIG1vcmUgYSBxdWljayAmIGVhc3kgd2F5IHRvIGNvbWJpbmUgcHJvZ3JhbSB0aGFuIGEgcmVhbGx5XG4gKiBwZXJmb3JtYW50IG9wdGlvbi4gTW9yZSBwZXJmb3JtYW50IHByb2dyYW1zIGNhbiBiZSB3cml0dGVuIGVudGlyZWx5LlxuICpcbiAqIEBwYXJhbSAge2FycmF5fSAgICBwcm9ncmFtQ2xhc3NlcyAtIFByb2dyYW0gY2xhc3NlcyB0byBjb21iaW5lLlxuICogQHBhcmFtICB7ZnVuY3Rpb259IGRyYXdMYWJlbCAtIEFuIG9wdGlvbmFsIG5vZGUgXCJkcmF3IGxhYmVsXCIgZnVuY3Rpb24uXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gZHJhd0hvdmVyIC0gQW4gb3B0aW9uYWwgbm9kZSBcImRyYXcgaG92ZXJcIiBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBjcmVhdGVOb2RlQ29tcG91bmRQcm9ncmFtKHByb2dyYW1DbGFzc2VzLCBkcmF3TGFiZWwsIGRyYXdIb3Zlcikge1xuICByZXR1cm4gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBOb2RlQ29tcG91bmRQcm9ncmFtKGdsLCBwaWNraW5nQnVmZmVyLCByZW5kZXJlcikge1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVDb21wb3VuZFByb2dyYW0pO1xuICAgICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiZHJhd0xhYmVsXCIsIGRyYXdMYWJlbCk7XG4gICAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJkcmF3SG92ZXJcIiwgZHJhd0hvdmVyKTtcbiAgICAgIHRoaXMucHJvZ3JhbXMgPSBwcm9ncmFtQ2xhc3Nlcy5tYXAoZnVuY3Rpb24gKFByb2dyYW0pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9ncmFtKGdsLCBwaWNraW5nQnVmZmVyLCByZW5kZXJlcik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgX2NyZWF0ZUNsYXNzKE5vZGVDb21wb3VuZFByb2dyYW0sIFt7XG4gICAgICBrZXk6IFwicmVhbGxvY2F0ZVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlYWxsb2NhdGUoY2FwYWNpdHkpIHtcbiAgICAgICAgdGhpcy5wcm9ncmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2dyYW0ucmVhbGxvY2F0ZShjYXBhY2l0eSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJwcm9jZXNzXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzcyhub2RlSW5kZXgsIG9mZnNldCwgZGF0YSkge1xuICAgICAgICB0aGlzLnByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICByZXR1cm4gcHJvZ3JhbS5wcm9jZXNzKG5vZGVJbmRleCwgb2Zmc2V0LCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbmRlclwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcihwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5wcm9ncmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2dyYW0ucmVuZGVyKHBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIGtleTogXCJraWxsXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24ga2lsbCgpIHtcbiAgICAgICAgdGhpcy5wcm9ncmFtcy5mb3JFYWNoKGZ1bmN0aW9uIChwcm9ncmFtKSB7XG4gICAgICAgICAgcmV0dXJuIHByb2dyYW0ua2lsbCgpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIE5vZGVDb21wb3VuZFByb2dyYW07XG4gIH0oKTtcbn1cblxudmFyIEFic3RyYWN0RWRnZVByb2dyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9BYnN0cmFjdFByb2dyYW0pIHtcbiAgX2luaGVyaXRzKEFic3RyYWN0RWRnZVByb2dyYW0sIF9BYnN0cmFjdFByb2dyYW0pO1xuICBmdW5jdGlvbiBBYnN0cmFjdEVkZ2VQcm9ncmFtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBYnN0cmFjdEVkZ2VQcm9ncmFtKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBBYnN0cmFjdEVkZ2VQcm9ncmFtLCBhcmd1bWVudHMpO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQWJzdHJhY3RFZGdlUHJvZ3JhbSk7XG59KEFic3RyYWN0UHJvZ3JhbSk7XG52YXIgRWRnZVByb2dyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9yZWYpIHtcbiAgX2luaGVyaXRzKEVkZ2VQcm9ncmFtLCBfcmVmKTtcbiAgZnVuY3Rpb24gRWRnZVByb2dyYW0oKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlUHJvZ3JhbSk7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXldID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgRWRnZVByb2dyYW0sIFtdLmNvbmNhdChhcmdzKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImRyYXdMYWJlbFwiLCB1bmRlZmluZWQpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfY3JlYXRlQ2xhc3MoRWRnZVByb2dyYW0sIFt7XG4gICAga2V5OiBcImtpbGxcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24ga2lsbCgpIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2VzcyhlZGdlSW5kZXgsIG9mZnNldCwgc291cmNlRGF0YSwgdGFyZ2V0RGF0YSwgZGF0YSkge1xuICAgICAgdmFyIGkgPSBvZmZzZXQgKiB0aGlzLlNUUklERTtcbiAgICAgIC8vIE5PVEU6IGRlYWxpbmcgd2l0aCBoaWRkZW4gaXRlbXMgYXV0b21hdGljYWxseVxuICAgICAgaWYgKGRhdGEuaGlkZGVuIHx8IHNvdXJjZURhdGEuaGlkZGVuIHx8IHRhcmdldERhdGEuaGlkZGVuKSB7XG4gICAgICAgIGZvciAodmFyIGwgPSBpICsgdGhpcy5TVFJJREU7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICB0aGlzLmFycmF5W2ldID0gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wcm9jZXNzVmlzaWJsZUl0ZW0oaW5kZXhUb0NvbG9yKGVkZ2VJbmRleCksIGksIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRWRnZVByb2dyYW07XG59KFByb2dyYW0pO1xuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gY29tYmluaW5nIHR3byBvciBtb3JlIHByb2dyYW1zIGludG8gYSBzaW5nbGUgY29tcG91bmQgb25lLlxuICogTm90ZSB0aGF0IHRoaXMgaXMgbW9yZSBhIHF1aWNrICYgZWFzeSB3YXkgdG8gY29tYmluZSBwcm9ncmFtIHRoYW4gYSByZWFsbHlcbiAqIHBlcmZvcm1hbnQgb3B0aW9uLiBNb3JlIHBlcmZvcm1hbnQgcHJvZ3JhbXMgY2FuIGJlIHdyaXR0ZW4gZW50aXJlbHkuXG4gKlxuICogQHBhcmFtICB7YXJyYXl9ICAgIHByb2dyYW1DbGFzc2VzIC0gUHJvZ3JhbSBjbGFzc2VzIHRvIGNvbWJpbmUuXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gZHJhd0xhYmVsIC0gQW4gb3B0aW9uYWwgZWRnZSBcImRyYXcgbGFiZWxcIiBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBjcmVhdGVFZGdlQ29tcG91bmRQcm9ncmFtKHByb2dyYW1DbGFzc2VzLCBkcmF3TGFiZWwpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRWRnZUNvbXBvdW5kUHJvZ3JhbShnbCwgcGlja2luZ0J1ZmZlciwgcmVuZGVyZXIpIHtcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlQ29tcG91bmRQcm9ncmFtKTtcbiAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImRyYXdMYWJlbFwiLCBkcmF3TGFiZWwpO1xuICAgICAgdGhpcy5wcm9ncmFtcyA9IHByb2dyYW1DbGFzc2VzLm1hcChmdW5jdGlvbiAoUHJvZ3JhbSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb2dyYW0oZ2wsIHBpY2tpbmdCdWZmZXIsIHJlbmRlcmVyKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfY3JlYXRlQ2xhc3MoRWRnZUNvbXBvdW5kUHJvZ3JhbSwgW3tcbiAgICAgIGtleTogXCJyZWFsbG9jYXRlXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVhbGxvY2F0ZShjYXBhY2l0eSkge1xuICAgICAgICB0aGlzLnByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICByZXR1cm4gcHJvZ3JhbS5yZWFsbG9jYXRlKGNhcGFjaXR5KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInByb2Nlc3NcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzKGVkZ2VJbmRleCwgb2Zmc2V0LCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhLCBkYXRhKSB7XG4gICAgICAgIHRoaXMucHJvZ3JhbXMuZm9yRWFjaChmdW5jdGlvbiAocHJvZ3JhbSkge1xuICAgICAgICAgIHJldHVybiBwcm9ncmFtLnByb2Nlc3MoZWRnZUluZGV4LCBvZmZzZXQsIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyKHBhcmFtcykge1xuICAgICAgICB0aGlzLnByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICByZXR1cm4gcHJvZ3JhbS5yZW5kZXIocGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcImtpbGxcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgICB0aGlzLnByb2dyYW1zLmZvckVhY2goZnVuY3Rpb24gKHByb2dyYW0pIHtcbiAgICAgICAgICByZXR1cm4gcHJvZ3JhbS5raWxsKCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1dKTtcbiAgICByZXR1cm4gRWRnZUNvbXBvdW5kUHJvZ3JhbTtcbiAgfSgpO1xufVxuXG5mdW5jdGlvbiBkcmF3U3RyYWlnaHRFZGdlTGFiZWwoY29udGV4dCwgZWRnZURhdGEsIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIHNldHRpbmdzKSB7XG4gIHZhciBzaXplID0gc2V0dGluZ3MuZWRnZUxhYmVsU2l6ZSxcbiAgICBmb250ID0gc2V0dGluZ3MuZWRnZUxhYmVsRm9udCxcbiAgICB3ZWlnaHQgPSBzZXR0aW5ncy5lZGdlTGFiZWxXZWlnaHQsXG4gICAgY29sb3IgPSBzZXR0aW5ncy5lZGdlTGFiZWxDb2xvci5hdHRyaWJ1dGUgPyBlZGdlRGF0YVtzZXR0aW5ncy5lZGdlTGFiZWxDb2xvci5hdHRyaWJ1dGVdIHx8IHNldHRpbmdzLmVkZ2VMYWJlbENvbG9yLmNvbG9yIHx8IFwiIzAwMFwiIDogc2V0dGluZ3MuZWRnZUxhYmVsQ29sb3IuY29sb3I7XG4gIHZhciBsYWJlbCA9IGVkZ2VEYXRhLmxhYmVsO1xuICBpZiAoIWxhYmVsKSByZXR1cm47XG4gIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3I7XG4gIGNvbnRleHQuZm9udCA9IFwiXCIuY29uY2F0KHdlaWdodCwgXCIgXCIpLmNvbmNhdChzaXplLCBcInB4IFwiKS5jb25jYXQoZm9udCk7XG5cbiAgLy8gQ29tcHV0aW5nIHBvc2l0aW9ucyB3aXRob3V0IGNvbnNpZGVyaW5nIG5vZGVzIHNpemVzOlxuICB2YXIgc1NpemUgPSBzb3VyY2VEYXRhLnNpemU7XG4gIHZhciB0U2l6ZSA9IHRhcmdldERhdGEuc2l6ZTtcbiAgdmFyIHN4ID0gc291cmNlRGF0YS54O1xuICB2YXIgc3kgPSBzb3VyY2VEYXRhLnk7XG4gIHZhciB0eCA9IHRhcmdldERhdGEueDtcbiAgdmFyIHR5ID0gdGFyZ2V0RGF0YS55O1xuICB2YXIgY3ggPSAoc3ggKyB0eCkgLyAyO1xuICB2YXIgY3kgPSAoc3kgKyB0eSkgLyAyO1xuICB2YXIgZHggPSB0eCAtIHN4O1xuICB2YXIgZHkgPSB0eSAtIHN5O1xuICB2YXIgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gIGlmIChkIDwgc1NpemUgKyB0U2l6ZSkgcmV0dXJuO1xuXG4gIC8vIEFkZGluZyBub2RlcyBzaXplczpcbiAgc3ggKz0gZHggKiBzU2l6ZSAvIGQ7XG4gIHN5ICs9IGR5ICogc1NpemUgLyBkO1xuICB0eCAtPSBkeCAqIHRTaXplIC8gZDtcbiAgdHkgLT0gZHkgKiB0U2l6ZSAvIGQ7XG4gIGN4ID0gKHN4ICsgdHgpIC8gMjtcbiAgY3kgPSAoc3kgKyB0eSkgLyAyO1xuICBkeCA9IHR4IC0gc3g7XG4gIGR5ID0gdHkgLSBzeTtcbiAgZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgLy8gSGFuZGxpbmcgZWxsaXBzaXNcbiAgdmFyIHRleHRMZW5ndGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KGxhYmVsKS53aWR0aDtcbiAgaWYgKHRleHRMZW5ndGggPiBkKSB7XG4gICAgdmFyIGVsbGlwc2lzID0gXCLigKZcIjtcbiAgICBsYWJlbCA9IGxhYmVsICsgZWxsaXBzaXM7XG4gICAgdGV4dExlbmd0aCA9IGNvbnRleHQubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuICAgIHdoaWxlICh0ZXh0TGVuZ3RoID4gZCAmJiBsYWJlbC5sZW5ndGggPiAxKSB7XG4gICAgICBsYWJlbCA9IGxhYmVsLnNsaWNlKDAsIC0yKSArIGVsbGlwc2lzO1xuICAgICAgdGV4dExlbmd0aCA9IGNvbnRleHQubWVhc3VyZVRleHQobGFiZWwpLndpZHRoO1xuICAgIH1cbiAgICBpZiAobGFiZWwubGVuZ3RoIDwgNCkgcmV0dXJuO1xuICB9XG4gIHZhciBhbmdsZTtcbiAgaWYgKGR4ID4gMCkge1xuICAgIGlmIChkeSA+IDApIGFuZ2xlID0gTWF0aC5hY29zKGR4IC8gZCk7ZWxzZSBhbmdsZSA9IE1hdGguYXNpbihkeSAvIGQpO1xuICB9IGVsc2Uge1xuICAgIGlmIChkeSA+IDApIGFuZ2xlID0gTWF0aC5hY29zKGR4IC8gZCkgKyBNYXRoLlBJO2Vsc2UgYW5nbGUgPSBNYXRoLmFzaW4oZHggLyBkKSArIE1hdGguUEkgLyAyO1xuICB9XG4gIGNvbnRleHQuc2F2ZSgpO1xuICBjb250ZXh0LnRyYW5zbGF0ZShjeCwgY3kpO1xuICBjb250ZXh0LnJvdGF0ZShhbmdsZSk7XG4gIGNvbnRleHQuZmlsbFRleHQobGFiZWwsIC10ZXh0TGVuZ3RoIC8gMiwgZWRnZURhdGEuc2l6ZSAvIDIgKyBzaXplKTtcbiAgY29udGV4dC5yZXN0b3JlKCk7XG59XG5cbmZ1bmN0aW9uIGRyYXdEaXNjTm9kZUxhYmVsKGNvbnRleHQsIGRhdGEsIHNldHRpbmdzKSB7XG4gIGlmICghZGF0YS5sYWJlbCkgcmV0dXJuO1xuICB2YXIgc2l6ZSA9IHNldHRpbmdzLmxhYmVsU2l6ZSxcbiAgICBmb250ID0gc2V0dGluZ3MubGFiZWxGb250LFxuICAgIHdlaWdodCA9IHNldHRpbmdzLmxhYmVsV2VpZ2h0LFxuICAgIGNvbG9yID0gc2V0dGluZ3MubGFiZWxDb2xvci5hdHRyaWJ1dGUgPyBkYXRhW3NldHRpbmdzLmxhYmVsQ29sb3IuYXR0cmlidXRlXSB8fCBzZXR0aW5ncy5sYWJlbENvbG9yLmNvbG9yIHx8IFwiIzAwMFwiIDogc2V0dGluZ3MubGFiZWxDb2xvci5jb2xvcjtcbiAgY29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcbiAgY29udGV4dC5mb250ID0gXCJcIi5jb25jYXQod2VpZ2h0LCBcIiBcIikuY29uY2F0KHNpemUsIFwicHggXCIpLmNvbmNhdChmb250KTtcbiAgY29udGV4dC5maWxsVGV4dChkYXRhLmxhYmVsLCBkYXRhLnggKyBkYXRhLnNpemUgKyAzLCBkYXRhLnkgKyBzaXplIC8gMyk7XG59XG5cbi8qKlxuICogRHJhdyBhbiBob3ZlcmVkIG5vZGUuXG4gKiAtIGlmIHRoZXJlIGlzIG5vIGxhYmVsID0+IGRpc3BsYXkgYSBzaGFkb3cgb24gdGhlIG5vZGVcbiAqIC0gaWYgdGhlIGxhYmVsIGJveCBpcyBiaWdnZXIgdGhhbiBub2RlIHNpemUgPT4gZGlzcGxheSBhIGxhYmVsIGJveCB0aGF0IGNvbnRhaW5zIHRoZSBub2RlIHdpdGggYSBzaGFkb3dcbiAqIC0gZWxzZSBub2RlIHdpdGggc2hhZG93IGFuZCB0aGUgbGFiZWwgYm94XG4gKi9cbmZ1bmN0aW9uIGRyYXdEaXNjTm9kZUhvdmVyKGNvbnRleHQsIGRhdGEsIHNldHRpbmdzKSB7XG4gIHZhciBzaXplID0gc2V0dGluZ3MubGFiZWxTaXplLFxuICAgIGZvbnQgPSBzZXR0aW5ncy5sYWJlbEZvbnQsXG4gICAgd2VpZ2h0ID0gc2V0dGluZ3MubGFiZWxXZWlnaHQ7XG4gIGNvbnRleHQuZm9udCA9IFwiXCIuY29uY2F0KHdlaWdodCwgXCIgXCIpLmNvbmNhdChzaXplLCBcInB4IFwiKS5jb25jYXQoZm9udCk7XG5cbiAgLy8gVGhlbiB3ZSBkcmF3IHRoZSBsYWJlbCBiYWNrZ3JvdW5kXG4gIGNvbnRleHQuZmlsbFN0eWxlID0gXCIjRkZGXCI7XG4gIGNvbnRleHQuc2hhZG93T2Zmc2V0WCA9IDA7XG4gIGNvbnRleHQuc2hhZG93T2Zmc2V0WSA9IDA7XG4gIGNvbnRleHQuc2hhZG93Qmx1ciA9IDg7XG4gIGNvbnRleHQuc2hhZG93Q29sb3IgPSBcIiMwMDBcIjtcbiAgdmFyIFBBRERJTkcgPSAyO1xuICBpZiAodHlwZW9mIGRhdGEubGFiZWwgPT09IFwic3RyaW5nXCIpIHtcbiAgICB2YXIgdGV4dFdpZHRoID0gY29udGV4dC5tZWFzdXJlVGV4dChkYXRhLmxhYmVsKS53aWR0aCxcbiAgICAgIGJveFdpZHRoID0gTWF0aC5yb3VuZCh0ZXh0V2lkdGggKyA1KSxcbiAgICAgIGJveEhlaWdodCA9IE1hdGgucm91bmQoc2l6ZSArIDIgKiBQQURESU5HKSxcbiAgICAgIHJhZGl1cyA9IE1hdGgubWF4KGRhdGEuc2l6ZSwgc2l6ZSAvIDIpICsgUEFERElORztcbiAgICB2YXIgYW5nbGVSYWRpYW4gPSBNYXRoLmFzaW4oYm94SGVpZ2h0IC8gMiAvIHJhZGl1cyk7XG4gICAgdmFyIHhEZWx0YUNvb3JkID0gTWF0aC5zcXJ0KE1hdGguYWJzKE1hdGgucG93KHJhZGl1cywgMikgLSBNYXRoLnBvdyhib3hIZWlnaHQgLyAyLCAyKSkpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oZGF0YS54ICsgeERlbHRhQ29vcmQsIGRhdGEueSArIGJveEhlaWdodCAvIDIpO1xuICAgIGNvbnRleHQubGluZVRvKGRhdGEueCArIHJhZGl1cyArIGJveFdpZHRoLCBkYXRhLnkgKyBib3hIZWlnaHQgLyAyKTtcbiAgICBjb250ZXh0LmxpbmVUbyhkYXRhLnggKyByYWRpdXMgKyBib3hXaWR0aCwgZGF0YS55IC0gYm94SGVpZ2h0IC8gMik7XG4gICAgY29udGV4dC5saW5lVG8oZGF0YS54ICsgeERlbHRhQ29vcmQsIGRhdGEueSAtIGJveEhlaWdodCAvIDIpO1xuICAgIGNvbnRleHQuYXJjKGRhdGEueCwgZGF0YS55LCByYWRpdXMsIGFuZ2xlUmFkaWFuLCAtYW5nbGVSYWRpYW4pO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH0gZWxzZSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjb250ZXh0LmFyYyhkYXRhLngsIGRhdGEueSwgZGF0YS5zaXplICsgUEFERElORywgMCwgTWF0aC5QSSAqIDIpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH1cbiAgY29udGV4dC5zaGFkb3dPZmZzZXRYID0gMDtcbiAgY29udGV4dC5zaGFkb3dPZmZzZXRZID0gMDtcbiAgY29udGV4dC5zaGFkb3dCbHVyID0gMDtcblxuICAvLyBBbmQgZmluYWxseSB3ZSBkcmF3IHRoZSBsYWJlbFxuICBkcmF3RGlzY05vZGVMYWJlbChjb250ZXh0LCBkYXRhLCBzZXR0aW5ncyk7XG59XG5cbi8vIGxhbmd1YWdlPUdMU0xcbnZhciBTSEFERVJfU09VUkNFJDYgPSAvKmdsc2wqL1wiXFxucHJlY2lzaW9uIGhpZ2hwIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgdmVjMiB2X2RpZmZWZWN0b3I7XFxudmFyeWluZyBmbG9hdCB2X3JhZGl1cztcXG5cXG51bmlmb3JtIGZsb2F0IHVfY29ycmVjdGlvblJhdGlvO1xcblxcbmNvbnN0IHZlYzQgdHJhbnNwYXJlbnQgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIGZsb2F0IGJvcmRlciA9IHVfY29ycmVjdGlvblJhdGlvICogMi4wO1xcbiAgZmxvYXQgZGlzdCA9IGxlbmd0aCh2X2RpZmZWZWN0b3IpIC0gdl9yYWRpdXMgKyBib3JkZXI7XFxuXFxuICAvLyBObyBhbnRpYWxpYXNpbmcgZm9yIHBpY2tpbmcgbW9kZTpcXG4gICNpZmRlZiBQSUNLSU5HX01PREVcXG4gIGlmIChkaXN0ID4gYm9yZGVyKVxcbiAgICBnbF9GcmFnQ29sb3IgPSB0cmFuc3BhcmVudDtcXG4gIGVsc2VcXG4gICAgZ2xfRnJhZ0NvbG9yID0gdl9jb2xvcjtcXG5cXG4gICNlbHNlXFxuICBmbG9hdCB0ID0gMC4wO1xcbiAgaWYgKGRpc3QgPiBib3JkZXIpXFxuICAgIHQgPSAxLjA7XFxuICBlbHNlIGlmIChkaXN0ID4gMC4wKVxcbiAgICB0ID0gZGlzdCAvIGJvcmRlcjtcXG5cXG4gIGdsX0ZyYWdDb2xvciA9IG1peCh2X2NvbG9yLCB0cmFuc3BhcmVudCwgdCk7XFxuICAjZW5kaWZcXG59XFxuXCI7XG52YXIgRlJBR01FTlRfU0hBREVSX1NPVVJDRSQyID0gU0hBREVSX1NPVVJDRSQ2O1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSQ1ID0gLypnbHNsKi9cIlxcbmF0dHJpYnV0ZSB2ZWM0IGFfaWQ7XFxuYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3NpemU7XFxuYXR0cmlidXRlIGZsb2F0IGFfYW5nbGU7XFxuXFxudW5pZm9ybSBtYXQzIHVfbWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV9zaXplUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X2NvcnJlY3Rpb25SYXRpbztcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG52YXJ5aW5nIHZlYzIgdl9kaWZmVmVjdG9yO1xcbnZhcnlpbmcgZmxvYXQgdl9yYWRpdXM7XFxudmFyeWluZyBmbG9hdCB2X2JvcmRlcjtcXG5cXG5jb25zdCBmbG9hdCBiaWFzID0gMjU1LjAgLyAyNTQuMDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICBmbG9hdCBzaXplID0gYV9zaXplICogdV9jb3JyZWN0aW9uUmF0aW8gLyB1X3NpemVSYXRpbyAqIDQuMDtcXG4gIHZlYzIgZGlmZlZlY3RvciA9IHNpemUgKiB2ZWMyKGNvcyhhX2FuZ2xlKSwgc2luKGFfYW5nbGUpKTtcXG4gIHZlYzIgcG9zaXRpb24gPSBhX3Bvc2l0aW9uICsgZGlmZlZlY3RvcjtcXG4gIGdsX1Bvc2l0aW9uID0gdmVjNChcXG4gICAgKHVfbWF0cml4ICogdmVjMyhwb3NpdGlvbiwgMSkpLnh5LFxcbiAgICAwLFxcbiAgICAxXFxuICApO1xcblxcbiAgdl9kaWZmVmVjdG9yID0gZGlmZlZlY3RvcjtcXG4gIHZfcmFkaXVzID0gc2l6ZSAvIDIuMDtcXG5cXG4gICNpZmRlZiBQSUNLSU5HX01PREVcXG4gIC8vIEZvciBwaWNraW5nIG1vZGUsIHdlIHVzZSB0aGUgSUQgYXMgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfaWQ7XFxuICAjZWxzZVxcbiAgLy8gRm9yIG5vcm1hbCBtb2RlLCB3ZSB1c2UgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfY29sb3I7XFxuICAjZW5kaWZcXG5cXG4gIHZfY29sb3IuYSAqPSBiaWFzO1xcbn1cXG5cIjtcbnZhciBWRVJURVhfU0hBREVSX1NPVVJDRSQzID0gU0hBREVSX1NPVVJDRSQ1O1xuXG52YXIgX1dlYkdMUmVuZGVyaW5nQ29udGV4JDMgPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQsXG4gIFVOU0lHTkVEX0JZVEUkMyA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleCQzLlVOU0lHTkVEX0JZVEUsXG4gIEZMT0FUJDMgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMy5GTE9BVDtcbnZhciBVTklGT1JNUyQyID0gW1widV9zaXplUmF0aW9cIiwgXCJ1X2NvcnJlY3Rpb25SYXRpb1wiLCBcInVfbWF0cml4XCJdO1xudmFyIE5vZGVDaXJjbGVQcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZVByb2dyYW0pIHtcbiAgX2luaGVyaXRzKE5vZGVDaXJjbGVQcm9ncmFtLCBfTm9kZVByb2dyYW0pO1xuICBmdW5jdGlvbiBOb2RlQ2lyY2xlUHJvZ3JhbSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTm9kZUNpcmNsZVByb2dyYW0pO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIE5vZGVDaXJjbGVQcm9ncmFtLCBhcmd1bWVudHMpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhOb2RlQ2lyY2xlUHJvZ3JhbSwgW3tcbiAgICBrZXk6IFwiZ2V0RGVmaW5pdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZpbml0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgVkVSVElDRVM6IDMsXG4gICAgICAgIFZFUlRFWF9TSEFERVJfU09VUkNFOiBWRVJURVhfU0hBREVSX1NPVVJDRSQzLFxuICAgICAgICBGUkFHTUVOVF9TSEFERVJfU09VUkNFOiBGUkFHTUVOVF9TSEFERVJfU09VUkNFJDIsXG4gICAgICAgIE1FVEhPRDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFUyxcbiAgICAgICAgVU5JRk9STVM6IFVOSUZPUk1TJDIsXG4gICAgICAgIEFUVFJJQlVURVM6IFt7XG4gICAgICAgICAgbmFtZTogXCJhX3Bvc2l0aW9uXCIsXG4gICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICB0eXBlOiBGTE9BVCQzXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfc2l6ZVwiLFxuICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgdHlwZTogRkxPQVQkM1xuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX2NvbG9yXCIsXG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFJDMsXG4gICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX2lkXCIsXG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFJDMsXG4gICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICB9XSxcbiAgICAgICAgQ09OU1RBTlRfQVRUUklCVVRFUzogW3tcbiAgICAgICAgICBuYW1lOiBcImFfYW5nbGVcIixcbiAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgIHR5cGU6IEZMT0FUJDNcbiAgICAgICAgfV0sXG4gICAgICAgIENPTlNUQU5UX0RBVEE6IFtbTm9kZUNpcmNsZVByb2dyYW0uQU5HTEVfMV0sIFtOb2RlQ2lyY2xlUHJvZ3JhbS5BTkdMRV8yXSwgW05vZGVDaXJjbGVQcm9ncmFtLkFOR0xFXzNdXVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvY2Vzc1Zpc2libGVJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWaXNpYmxlSXRlbShub2RlSW5kZXgsIHN0YXJ0SW5kZXgsIGRhdGEpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICB2YXIgY29sb3IgPSBmbG9hdENvbG9yKGRhdGEuY29sb3IpO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGRhdGEueDtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBkYXRhLnk7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gZGF0YS5zaXplO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGNvbG9yO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IG5vZGVJbmRleDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VW5pZm9ybXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VW5pZm9ybXMocGFyYW1zLCBfcmVmKSB7XG4gICAgICB2YXIgZ2wgPSBfcmVmLmdsLFxuICAgICAgICB1bmlmb3JtTG9jYXRpb25zID0gX3JlZi51bmlmb3JtTG9jYXRpb25zO1xuICAgICAgdmFyIHVfc2l6ZVJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3NpemVSYXRpbyxcbiAgICAgICAgdV9jb3JyZWN0aW9uUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfY29ycmVjdGlvblJhdGlvLFxuICAgICAgICB1X21hdHJpeCA9IHVuaWZvcm1Mb2NhdGlvbnMudV9tYXRyaXg7XG4gICAgICBnbC51bmlmb3JtMWYodV9jb3JyZWN0aW9uUmF0aW8sIHBhcmFtcy5jb3JyZWN0aW9uUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybTFmKHVfc2l6ZVJhdGlvLCBwYXJhbXMuc2l6ZVJhdGlvKTtcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodV9tYXRyaXgsIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE5vZGVDaXJjbGVQcm9ncmFtO1xufShOb2RlUHJvZ3JhbSk7XG5fZGVmaW5lUHJvcGVydHkoTm9kZUNpcmNsZVByb2dyYW0sIFwiQU5HTEVfMVwiLCAwKTtcbl9kZWZpbmVQcm9wZXJ0eShOb2RlQ2lyY2xlUHJvZ3JhbSwgXCJBTkdMRV8yXCIsIDIgKiBNYXRoLlBJIC8gMyk7XG5fZGVmaW5lUHJvcGVydHkoTm9kZUNpcmNsZVByb2dyYW0sIFwiQU5HTEVfM1wiLCA0ICogTWF0aC5QSSAvIDMpO1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSQ0ID0gLypnbHNsKi9cIlxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBnbF9GcmFnQ29sb3IgPSB2X2NvbG9yO1xcbn1cXG5cIjtcbnZhciBGUkFHTUVOVF9TSEFERVJfU09VUkNFJDEgPSBTSEFERVJfU09VUkNFJDQ7XG5cbi8vIGxhbmd1YWdlPUdMU0xcbnZhciBTSEFERVJfU09VUkNFJDMgPSAvKmdsc2wqL1wiXFxuYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbjtcXG5hdHRyaWJ1dGUgdmVjMiBhX25vcm1hbDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9yYWRpdXM7XFxuYXR0cmlidXRlIHZlYzMgYV9iYXJ5Y2VudHJpYztcXG5cXG4jaWZkZWYgUElDS0lOR19NT0RFXFxuYXR0cmlidXRlIHZlYzQgYV9pZDtcXG4jZWxzZVxcbmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxuI2VuZGlmXFxuXFxudW5pZm9ybSBtYXQzIHVfbWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV9zaXplUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X2NvcnJlY3Rpb25SYXRpbztcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXG5jb25zdCBmbG9hdCBtaW5UaGlja25lc3MgPSAxLjc7XFxuY29uc3QgZmxvYXQgYmlhcyA9IDI1NS4wIC8gMjU0LjA7XFxuY29uc3QgZmxvYXQgYXJyb3dIZWFkV2lkdGhMZW5ndGhSYXRpbyA9IDAuNjY7XFxuY29uc3QgZmxvYXQgYXJyb3dIZWFkTGVuZ3RoVGhpY2tuZXNzUmF0aW8gPSAyLjU7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgZmxvYXQgbm9ybWFsTGVuZ3RoID0gbGVuZ3RoKGFfbm9ybWFsKTtcXG4gIHZlYzIgdW5pdE5vcm1hbCA9IGFfbm9ybWFsIC8gbm9ybWFsTGVuZ3RoO1xcblxcbiAgLy8gVGhlc2UgZmlyc3QgY29tcHV0YXRpb25zIGFyZSB0YWtlbiBmcm9tIGVkZ2UudmVydC5nbHNsIGFuZFxcbiAgLy8gZWRnZS5jbGFtcGVkLnZlcnQuZ2xzbC4gUGxlYXNlIHJlYWQgaXQgdG8gZ2V0IGJldHRlciBjb21tZW50cyBvbiB3aGF0J3NcXG4gIC8vIGhhcHBlbmluZzpcXG4gIGZsb2F0IHBpeGVsc1RoaWNrbmVzcyA9IG1heChub3JtYWxMZW5ndGgsIG1pblRoaWNrbmVzcyAqIHVfc2l6ZVJhdGlvKTtcXG4gIGZsb2F0IHdlYkdMVGhpY2tuZXNzID0gcGl4ZWxzVGhpY2tuZXNzICogdV9jb3JyZWN0aW9uUmF0aW8gLyB1X3NpemVSYXRpbztcXG4gIGZsb2F0IHdlYkdMTm9kZVJhZGl1cyA9IGFfcmFkaXVzICogMi4wICogdV9jb3JyZWN0aW9uUmF0aW8gLyB1X3NpemVSYXRpbztcXG4gIGZsb2F0IHdlYkdMQXJyb3dIZWFkTGVuZ3RoID0gd2ViR0xUaGlja25lc3MgKiAyLjAgKiBhcnJvd0hlYWRMZW5ndGhUaGlja25lc3NSYXRpbztcXG4gIGZsb2F0IHdlYkdMQXJyb3dIZWFkSGFsZldpZHRoID0gd2ViR0xBcnJvd0hlYWRMZW5ndGggKiBhcnJvd0hlYWRXaWR0aExlbmd0aFJhdGlvIC8gMi4wO1xcblxcbiAgZmxvYXQgZGEgPSBhX2JhcnljZW50cmljLng7XFxuICBmbG9hdCBkYiA9IGFfYmFyeWNlbnRyaWMueTtcXG4gIGZsb2F0IGRjID0gYV9iYXJ5Y2VudHJpYy56O1xcblxcbiAgdmVjMiBkZWx0YSA9IHZlYzIoXFxuICAgICAgZGEgKiAod2ViR0xOb2RlUmFkaXVzICogdW5pdE5vcm1hbC55KVxcbiAgICArIGRiICogKCh3ZWJHTE5vZGVSYWRpdXMgKyB3ZWJHTEFycm93SGVhZExlbmd0aCkgKiB1bml0Tm9ybWFsLnkgKyB3ZWJHTEFycm93SGVhZEhhbGZXaWR0aCAqIHVuaXROb3JtYWwueClcXG4gICAgKyBkYyAqICgod2ViR0xOb2RlUmFkaXVzICsgd2ViR0xBcnJvd0hlYWRMZW5ndGgpICogdW5pdE5vcm1hbC55IC0gd2ViR0xBcnJvd0hlYWRIYWxmV2lkdGggKiB1bml0Tm9ybWFsLngpLFxcblxcbiAgICAgIGRhICogKC13ZWJHTE5vZGVSYWRpdXMgKiB1bml0Tm9ybWFsLngpXFxuICAgICsgZGIgKiAoLSh3ZWJHTE5vZGVSYWRpdXMgKyB3ZWJHTEFycm93SGVhZExlbmd0aCkgKiB1bml0Tm9ybWFsLnggKyB3ZWJHTEFycm93SGVhZEhhbGZXaWR0aCAqIHVuaXROb3JtYWwueSlcXG4gICAgKyBkYyAqICgtKHdlYkdMTm9kZVJhZGl1cyArIHdlYkdMQXJyb3dIZWFkTGVuZ3RoKSAqIHVuaXROb3JtYWwueCAtIHdlYkdMQXJyb3dIZWFkSGFsZldpZHRoICogdW5pdE5vcm1hbC55KVxcbiAgKTtcXG5cXG4gIHZlYzIgcG9zaXRpb24gPSAodV9tYXRyaXggKiB2ZWMzKGFfcG9zaXRpb24gKyBkZWx0YSwgMSkpLnh5O1xcblxcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KHBvc2l0aW9uLCAwLCAxKTtcXG5cXG4gICNpZmRlZiBQSUNLSU5HX01PREVcXG4gIC8vIEZvciBwaWNraW5nIG1vZGUsIHdlIHVzZSB0aGUgSUQgYXMgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfaWQ7XFxuICAjZWxzZVxcbiAgLy8gRm9yIG5vcm1hbCBtb2RlLCB3ZSB1c2UgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfY29sb3I7XFxuICAjZW5kaWZcXG5cXG4gIHZfY29sb3IuYSAqPSBiaWFzO1xcbn1cXG5cIjtcbnZhciBWRVJURVhfU0hBREVSX1NPVVJDRSQyID0gU0hBREVSX1NPVVJDRSQzO1xuXG52YXIgX1dlYkdMUmVuZGVyaW5nQ29udGV4JDIgPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQsXG4gIFVOU0lHTkVEX0JZVEUkMiA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleCQyLlVOU0lHTkVEX0JZVEUsXG4gIEZMT0FUJDIgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMi5GTE9BVDtcbnZhciBVTklGT1JNUyQxID0gW1widV9tYXRyaXhcIiwgXCJ1X3NpemVSYXRpb1wiLCBcInVfY29ycmVjdGlvblJhdGlvXCJdO1xudmFyIEVkZ2VBcnJvd0hlYWRQcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWRnZVByb2dyYW0pIHtcbiAgX2luaGVyaXRzKEVkZ2VBcnJvd0hlYWRQcm9ncmFtLCBfRWRnZVByb2dyYW0pO1xuICBmdW5jdGlvbiBFZGdlQXJyb3dIZWFkUHJvZ3JhbSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRnZUFycm93SGVhZFByb2dyYW0pO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIEVkZ2VBcnJvd0hlYWRQcm9ncmFtLCBhcmd1bWVudHMpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhFZGdlQXJyb3dIZWFkUHJvZ3JhbSwgW3tcbiAgICBrZXk6IFwiZ2V0RGVmaW5pdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZpbml0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgVkVSVElDRVM6IDMsXG4gICAgICAgIFZFUlRFWF9TSEFERVJfU09VUkNFOiBWRVJURVhfU0hBREVSX1NPVVJDRSQyLFxuICAgICAgICBGUkFHTUVOVF9TSEFERVJfU09VUkNFOiBGUkFHTUVOVF9TSEFERVJfU09VUkNFJDEsXG4gICAgICAgIE1FVEhPRDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFUyxcbiAgICAgICAgVU5JRk9STVM6IFVOSUZPUk1TJDEsXG4gICAgICAgIEFUVFJJQlVURVM6IFt7XG4gICAgICAgICAgbmFtZTogXCJhX3Bvc2l0aW9uXCIsXG4gICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICB0eXBlOiBGTE9BVCQyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfbm9ybWFsXCIsXG4gICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICB0eXBlOiBGTE9BVCQyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfcmFkaXVzXCIsXG4gICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICB0eXBlOiBGTE9BVCQyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfY29sb3JcIixcbiAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgIHR5cGU6IFVOU0lHTkVEX0JZVEUkMixcbiAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfaWRcIixcbiAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgIHR5cGU6IFVOU0lHTkVEX0JZVEUkMixcbiAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXG4gICAgICAgIH1dLFxuICAgICAgICBDT05TVEFOVF9BVFRSSUJVVEVTOiBbe1xuICAgICAgICAgIG5hbWU6IFwiYV9iYXJ5Y2VudHJpY1wiLFxuICAgICAgICAgIHNpemU6IDMsXG4gICAgICAgICAgdHlwZTogRkxPQVQkMlxuICAgICAgICB9XSxcbiAgICAgICAgQ09OU1RBTlRfREFUQTogW1sxLCAwLCAwXSwgWzAsIDEsIDBdLCBbMCwgMCwgMV1dXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzVmlzaWJsZUl0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1Zpc2libGVJdGVtKGVkZ2VJbmRleCwgc3RhcnRJbmRleCwgc291cmNlRGF0YSwgdGFyZ2V0RGF0YSwgZGF0YSkge1xuICAgICAgdmFyIHRoaWNrbmVzcyA9IGRhdGEuc2l6ZSB8fCAxO1xuICAgICAgdmFyIHJhZGl1cyA9IHRhcmdldERhdGEuc2l6ZSB8fCAxO1xuICAgICAgdmFyIHgxID0gc291cmNlRGF0YS54O1xuICAgICAgdmFyIHkxID0gc291cmNlRGF0YS55O1xuICAgICAgdmFyIHgyID0gdGFyZ2V0RGF0YS54O1xuICAgICAgdmFyIHkyID0gdGFyZ2V0RGF0YS55O1xuICAgICAgdmFyIGNvbG9yID0gZmxvYXRDb2xvcihkYXRhLmNvbG9yKTtcblxuICAgICAgLy8gQ29tcHV0aW5nIG5vcm1hbHNcbiAgICAgIHZhciBkeCA9IHgyIC0geDE7XG4gICAgICB2YXIgZHkgPSB5MiAtIHkxO1xuICAgICAgdmFyIGxlbiA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgICAgdmFyIG4xID0gMDtcbiAgICAgIHZhciBuMiA9IDA7XG4gICAgICBpZiAobGVuKSB7XG4gICAgICAgIGxlbiA9IDEgLyBNYXRoLnNxcnQobGVuKTtcbiAgICAgICAgbjEgPSAtZHkgKiBsZW4gKiB0aGlja25lc3M7XG4gICAgICAgIG4yID0gZHggKiBsZW4gKiB0aGlja25lc3M7XG4gICAgICB9XG4gICAgICB2YXIgYXJyYXkgPSB0aGlzLmFycmF5O1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHgyO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHkyO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IC1uMTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSAtbjI7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gcmFkaXVzO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGNvbG9yO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGVkZ2VJbmRleDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VW5pZm9ybXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VW5pZm9ybXMocGFyYW1zLCBfcmVmKSB7XG4gICAgICB2YXIgZ2wgPSBfcmVmLmdsLFxuICAgICAgICB1bmlmb3JtTG9jYXRpb25zID0gX3JlZi51bmlmb3JtTG9jYXRpb25zO1xuICAgICAgdmFyIHVfbWF0cml4ID0gdW5pZm9ybUxvY2F0aW9ucy51X21hdHJpeCxcbiAgICAgICAgdV9zaXplUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfc2l6ZVJhdGlvLFxuICAgICAgICB1X2NvcnJlY3Rpb25SYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9jb3JyZWN0aW9uUmF0aW87XG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHVfbWF0cml4LCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XG4gICAgICBnbC51bmlmb3JtMWYodV9zaXplUmF0aW8sIHBhcmFtcy5zaXplUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybTFmKHVfY29ycmVjdGlvblJhdGlvLCBwYXJhbXMuY29ycmVjdGlvblJhdGlvKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEVkZ2VBcnJvd0hlYWRQcm9ncmFtO1xufShFZGdlUHJvZ3JhbSk7XG5cbmZ1bmN0aW9uIF9zdXBlclByb3BCYXNlKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgd2hpbGUgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSkpIHtcbiAgICBvYmplY3QgPSBfZ2V0UHJvdG90eXBlT2Yob2JqZWN0KTtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsKSBicmVhaztcbiAgfVxuICByZXR1cm4gb2JqZWN0O1xufVxuXG5mdW5jdGlvbiBfZ2V0KCkge1xuICBpZiAodHlwZW9mIFJlZmxlY3QgIT09IFwidW5kZWZpbmVkXCIgJiYgUmVmbGVjdC5nZXQpIHtcbiAgICBfZ2V0ID0gUmVmbGVjdC5nZXQuYmluZCgpO1xuICB9IGVsc2Uge1xuICAgIF9nZXQgPSBmdW5jdGlvbiBfZ2V0KHRhcmdldCwgcHJvcGVydHksIHJlY2VpdmVyKSB7XG4gICAgICB2YXIgYmFzZSA9IF9zdXBlclByb3BCYXNlKHRhcmdldCwgcHJvcGVydHkpO1xuICAgICAgaWYgKCFiYXNlKSByZXR1cm47XG4gICAgICB2YXIgZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoYmFzZSwgcHJvcGVydHkpO1xuICAgICAgaWYgKGRlc2MuZ2V0KSB7XG4gICAgICAgIHJldHVybiBkZXNjLmdldC5jYWxsKGFyZ3VtZW50cy5sZW5ndGggPCAzID8gdGFyZ2V0IDogcmVjZWl2ZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlc2MudmFsdWU7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gX2dldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSQyID0gLypnbHNsKi9cIlxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgdmVjMiB2X25vcm1hbDtcXG52YXJ5aW5nIGZsb2F0IHZfdGhpY2tuZXNzO1xcblxcbmNvbnN0IGZsb2F0IGZlYXRoZXIgPSAwLjAwMTtcXG5jb25zdCB2ZWM0IHRyYW5zcGFyZW50ID0gdmVjNCgwLjAsIDAuMCwgMC4wLCAwLjApO1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICAvLyBXZSBvbmx5IGhhbmRsZSBhbnRpYWxpYXNpbmcgZm9yIG5vcm1hbCBtb2RlOlxcbiAgI2lmZGVmIFBJQ0tJTkdfTU9ERVxcbiAgZ2xfRnJhZ0NvbG9yID0gdl9jb2xvcjtcXG4gICNlbHNlXFxuICBmbG9hdCBkaXN0ID0gbGVuZ3RoKHZfbm9ybWFsKSAqIHZfdGhpY2tuZXNzO1xcblxcbiAgZmxvYXQgdCA9IHNtb290aHN0ZXAoXFxuICAgIHZfdGhpY2tuZXNzIC0gZmVhdGhlcixcXG4gICAgdl90aGlja25lc3MsXFxuICAgIGRpc3RcXG4gICk7XFxuXFxuICBnbF9GcmFnQ29sb3IgPSBtaXgodl9jb2xvciwgdHJhbnNwYXJlbnQsIHQpO1xcbiAgI2VuZGlmXFxufVxcblwiO1xudmFyIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0UgPSBTSEFERVJfU09VUkNFJDI7XG5cbi8vIGxhbmd1YWdlPUdMU0xcbnZhciBTSEFERVJfU09VUkNFJDEgPSAvKmdsc2wqL1wiXFxuYXR0cmlidXRlIHZlYzQgYV9pZDtcXG5hdHRyaWJ1dGUgdmVjNCBhX2NvbG9yO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfbm9ybWFsO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX25vcm1hbENvZWY7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvblN0YXJ0O1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb25FbmQ7XFxuYXR0cmlidXRlIGZsb2F0IGFfcG9zaXRpb25Db2VmO1xcblxcbnVuaWZvcm0gbWF0MyB1X21hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfc2l6ZVJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV96b29tUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X2NvcnJlY3Rpb25SYXRpbztcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG52YXJ5aW5nIHZlYzIgdl9ub3JtYWw7XFxudmFyeWluZyBmbG9hdCB2X3RoaWNrbmVzcztcXG5cXG5jb25zdCBmbG9hdCBtaW5UaGlja25lc3MgPSAxLjc7XFxuY29uc3QgZmxvYXQgYmlhcyA9IDI1NS4wIC8gMjU0LjA7XFxuXFxudm9pZCBtYWluKCkge1xcbiAgdmVjMiBub3JtYWwgPSBhX25vcm1hbCAqIGFfbm9ybWFsQ29lZjtcXG4gIHZlYzIgcG9zaXRpb24gPSBhX3Bvc2l0aW9uU3RhcnQgKiAoMS4wIC0gYV9wb3NpdGlvbkNvZWYpICsgYV9wb3NpdGlvbkVuZCAqIGFfcG9zaXRpb25Db2VmO1xcblxcbiAgZmxvYXQgbm9ybWFsTGVuZ3RoID0gbGVuZ3RoKG5vcm1hbCk7XFxuICB2ZWMyIHVuaXROb3JtYWwgPSBub3JtYWwgLyBub3JtYWxMZW5ndGg7XFxuXFxuICAvLyBXZSByZXF1aXJlIGVkZ2VzIHRvIGJlIGF0IGxlYXN0IFxcXCJtaW5UaGlja25lc3NcXFwiIHBpeGVscyB0aGljayAqb24gc2NyZWVuKlxcbiAgLy8gKHNvIHdlIG5lZWQgdG8gY29tcGVuc2F0ZSB0aGUgc2l6ZSByYXRpbyk6XFxuICBmbG9hdCBwaXhlbHNUaGlja25lc3MgPSBtYXgobm9ybWFsTGVuZ3RoLCBtaW5UaGlja25lc3MgKiB1X3NpemVSYXRpbyk7XFxuXFxuICAvLyBUaGVuLCB3ZSBuZWVkIHRvIHJldHJpZXZlIHRoZSBub3JtYWxpemVkIHRoaWNrbmVzcyBvZiB0aGUgZWRnZSBpbiB0aGUgV2ViR0xcXG4gIC8vIHJlZmVyZW50aWFsIChpbiBhIChbMCwgMV0sIFswLCAxXSkgc3BhY2UpLCB1c2luZyBvdXIgXFxcIm1hZ2ljXFxcIiBjb3JyZWN0aW9uXFxuICAvLyByYXRpbzpcXG4gIGZsb2F0IHdlYkdMVGhpY2tuZXNzID0gcGl4ZWxzVGhpY2tuZXNzICogdV9jb3JyZWN0aW9uUmF0aW8gLyB1X3NpemVSYXRpbztcXG5cXG4gIC8vIEhlcmUgaXMgdGhlIHByb3BlciBwb3NpdGlvbiBvZiB0aGUgdmVydGV4XFxuICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHVfbWF0cml4ICogdmVjMyhwb3NpdGlvbiArIHVuaXROb3JtYWwgKiB3ZWJHTFRoaWNrbmVzcywgMSkpLnh5LCAwLCAxKTtcXG5cXG4gIC8vIEZvciB0aGUgZnJhZ21lbnQgc2hhZGVyIHRob3VnaCwgd2UgbmVlZCBhIHRoaWNrbmVzcyB0aGF0IHRha2VzIHRoZSBcXFwibWFnaWNcXFwiXFxuICAvLyBjb3JyZWN0aW9uIHJhdGlvIGludG8gYWNjb3VudCAoYXMgaW4gd2ViR0xUaGlja25lc3MpLCBidXQgc28gdGhhdCB0aGVcXG4gIC8vIGFudGlhbGlhc2luZyBlZmZlY3QgZG9lcyBub3QgZGVwZW5kIG9uIHRoZSB6b29tIGxldmVsLiBTbyBoZXJlJ3MgeWV0XFxuICAvLyBhbm90aGVyIHRoaWNrbmVzcyB2ZXJzaW9uOlxcbiAgdl90aGlja25lc3MgPSB3ZWJHTFRoaWNrbmVzcyAvIHVfem9vbVJhdGlvO1xcblxcbiAgdl9ub3JtYWwgPSB1bml0Tm9ybWFsO1xcblxcbiAgI2lmZGVmIFBJQ0tJTkdfTU9ERVxcbiAgLy8gRm9yIHBpY2tpbmcgbW9kZSwgd2UgdXNlIHRoZSBJRCBhcyB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9pZDtcXG4gICNlbHNlXFxuICAvLyBGb3Igbm9ybWFsIG1vZGUsIHdlIHVzZSB0aGUgY29sb3I6XFxuICB2X2NvbG9yID0gYV9jb2xvcjtcXG4gICNlbmRpZlxcblxcbiAgdl9jb2xvci5hICo9IGJpYXM7XFxufVxcblwiO1xudmFyIFZFUlRFWF9TSEFERVJfU09VUkNFJDEgPSBTSEFERVJfU09VUkNFJDE7XG5cbnZhciBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMSA9IFdlYkdMUmVuZGVyaW5nQ29udGV4dCxcbiAgVU5TSUdORURfQllURSQxID0gX1dlYkdMUmVuZGVyaW5nQ29udGV4JDEuVU5TSUdORURfQllURSxcbiAgRkxPQVQkMSA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleCQxLkZMT0FUO1xudmFyIFVOSUZPUk1TID0gW1widV9tYXRyaXhcIiwgXCJ1X3pvb21SYXRpb1wiLCBcInVfc2l6ZVJhdGlvXCIsIFwidV9jb3JyZWN0aW9uUmF0aW9cIl07XG52YXIgRWRnZVJlY3RhbmdsZVByb2dyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FZGdlUHJvZ3JhbSkge1xuICBfaW5oZXJpdHMoRWRnZVJlY3RhbmdsZVByb2dyYW0sIF9FZGdlUHJvZ3JhbSk7XG4gIGZ1bmN0aW9uIEVkZ2VSZWN0YW5nbGVQcm9ncmFtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlUmVjdGFuZ2xlUHJvZ3JhbSk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgRWRnZVJlY3RhbmdsZVByb2dyYW0sIGFyZ3VtZW50cyk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKEVkZ2VSZWN0YW5nbGVQcm9ncmFtLCBbe1xuICAgIGtleTogXCJnZXREZWZpbml0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmluaXRpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBWRVJUSUNFUzogNixcbiAgICAgICAgVkVSVEVYX1NIQURFUl9TT1VSQ0U6IFZFUlRFWF9TSEFERVJfU09VUkNFJDEsXG4gICAgICAgIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0U6IEZSQUdNRU5UX1NIQURFUl9TT1VSQ0UsXG4gICAgICAgIE1FVEhPRDogV2ViR0xSZW5kZXJpbmdDb250ZXh0LlRSSUFOR0xFUyxcbiAgICAgICAgVU5JRk9STVM6IFVOSUZPUk1TLFxuICAgICAgICBBVFRSSUJVVEVTOiBbe1xuICAgICAgICAgIG5hbWU6IFwiYV9wb3NpdGlvblN0YXJ0XCIsXG4gICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICB0eXBlOiBGTE9BVCQxXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfcG9zaXRpb25FbmRcIixcbiAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgIHR5cGU6IEZMT0FUJDFcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9ub3JtYWxcIixcbiAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgIHR5cGU6IEZMT0FUJDFcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9jb2xvclwiLFxuICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgdHlwZTogVU5TSUdORURfQllURSQxLFxuICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9pZFwiLFxuICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgdHlwZTogVU5TSUdORURfQllURSQxLFxuICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcbiAgICAgICAgfV0sXG4gICAgICAgIENPTlNUQU5UX0FUVFJJQlVURVM6IFtcbiAgICAgICAgLy8gSWYgMCwgdGhlbiBwb3NpdGlvbiB3aWxsIGJlIGFfcG9zaXRpb25TdGFydFxuICAgICAgICAvLyBJZiAyLCB0aGVuIHBvc2l0aW9uIHdpbGwgYmUgYV9wb3NpdGlvbkVuZFxuICAgICAgICB7XG4gICAgICAgICAgbmFtZTogXCJhX3Bvc2l0aW9uQ29lZlwiLFxuICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgdHlwZTogRkxPQVQkMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX25vcm1hbENvZWZcIixcbiAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgIHR5cGU6IEZMT0FUJDFcbiAgICAgICAgfV0sXG4gICAgICAgIENPTlNUQU5UX0RBVEE6IFtbMCwgMV0sIFswLCAtMV0sIFsxLCAxXSwgWzEsIDFdLCBbMCwgLTFdLCBbMSwgLTFdXVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvY2Vzc1Zpc2libGVJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWaXNpYmxlSXRlbShlZGdlSW5kZXgsIHN0YXJ0SW5kZXgsIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEpIHtcbiAgICAgIHZhciB0aGlja25lc3MgPSBkYXRhLnNpemUgfHwgMTtcbiAgICAgIHZhciB4MSA9IHNvdXJjZURhdGEueDtcbiAgICAgIHZhciB5MSA9IHNvdXJjZURhdGEueTtcbiAgICAgIHZhciB4MiA9IHRhcmdldERhdGEueDtcbiAgICAgIHZhciB5MiA9IHRhcmdldERhdGEueTtcbiAgICAgIHZhciBjb2xvciA9IGZsb2F0Q29sb3IoZGF0YS5jb2xvcik7XG5cbiAgICAgIC8vIENvbXB1dGluZyBub3JtYWxzXG4gICAgICB2YXIgZHggPSB4MiAtIHgxO1xuICAgICAgdmFyIGR5ID0geTIgLSB5MTtcbiAgICAgIHZhciBsZW4gPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgIHZhciBuMSA9IDA7XG4gICAgICB2YXIgbjIgPSAwO1xuICAgICAgaWYgKGxlbikge1xuICAgICAgICBsZW4gPSAxIC8gTWF0aC5zcXJ0KGxlbik7XG4gICAgICAgIG4xID0gLWR5ICogbGVuICogdGhpY2tuZXNzO1xuICAgICAgICBuMiA9IGR4ICogbGVuICogdGhpY2tuZXNzO1xuICAgICAgfVxuICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB4MTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB5MTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB4MjtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSB5MjtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBuMTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBuMjtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBjb2xvcjtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBlZGdlSW5kZXg7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInNldFVuaWZvcm1zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFVuaWZvcm1zKHBhcmFtcywgX3JlZikge1xuICAgICAgdmFyIGdsID0gX3JlZi5nbCxcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9ucyA9IF9yZWYudW5pZm9ybUxvY2F0aW9ucztcbiAgICAgIHZhciB1X21hdHJpeCA9IHVuaWZvcm1Mb2NhdGlvbnMudV9tYXRyaXgsXG4gICAgICAgIHVfem9vbVJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X3pvb21SYXRpbyxcbiAgICAgICAgdV9jb3JyZWN0aW9uUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfY29ycmVjdGlvblJhdGlvLFxuICAgICAgICB1X3NpemVSYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9zaXplUmF0aW87XG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHVfbWF0cml4LCBmYWxzZSwgcGFyYW1zLm1hdHJpeCk7XG4gICAgICBnbC51bmlmb3JtMWYodV96b29tUmF0aW8sIHBhcmFtcy56b29tUmF0aW8pO1xuICAgICAgZ2wudW5pZm9ybTFmKHVfc2l6ZVJhdGlvLCBwYXJhbXMuc2l6ZVJhdGlvKTtcbiAgICAgIGdsLnVuaWZvcm0xZih1X2NvcnJlY3Rpb25SYXRpbywgcGFyYW1zLmNvcnJlY3Rpb25SYXRpbyk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBFZGdlUmVjdGFuZ2xlUHJvZ3JhbTtcbn0oRWRnZVByb2dyYW0pO1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSA9IC8qZ2xzbCovXCJcXG5hdHRyaWJ1dGUgdmVjNCBhX2lkO1xcbmF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XFxuYXR0cmlidXRlIHZlYzIgYV9ub3JtYWw7XFxuYXR0cmlidXRlIGZsb2F0IGFfbm9ybWFsQ29lZjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uU3RhcnQ7XFxuYXR0cmlidXRlIHZlYzIgYV9wb3NpdGlvbkVuZDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9wb3NpdGlvbkNvZWY7XFxuYXR0cmlidXRlIGZsb2F0IGFfcmFkaXVzO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3JhZGl1c0NvZWY7XFxuXFxudW5pZm9ybSBtYXQzIHVfbWF0cml4O1xcbnVuaWZvcm0gZmxvYXQgdV96b29tUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X3NpemVSYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfY29ycmVjdGlvblJhdGlvO1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgdmVjMiB2X25vcm1hbDtcXG52YXJ5aW5nIGZsb2F0IHZfdGhpY2tuZXNzO1xcblxcbmNvbnN0IGZsb2F0IG1pblRoaWNrbmVzcyA9IDEuNztcXG5jb25zdCBmbG9hdCBiaWFzID0gMjU1LjAgLyAyNTQuMDtcXG5jb25zdCBmbG9hdCBhcnJvd0hlYWRMZW5ndGhUaGlja25lc3NSYXRpbyA9IDIuNTtcXG5cXG52b2lkIG1haW4oKSB7XFxuICBmbG9hdCByYWRpdXMgPSBhX3JhZGl1cyAqIGFfcmFkaXVzQ29lZjtcXG4gIHZlYzIgbm9ybWFsID0gYV9ub3JtYWwgKiBhX25vcm1hbENvZWY7XFxuICB2ZWMyIHBvc2l0aW9uID0gYV9wb3NpdGlvblN0YXJ0ICogKDEuMCAtIGFfcG9zaXRpb25Db2VmKSArIGFfcG9zaXRpb25FbmQgKiBhX3Bvc2l0aW9uQ29lZjtcXG5cXG4gIGZsb2F0IG5vcm1hbExlbmd0aCA9IGxlbmd0aChub3JtYWwpO1xcbiAgdmVjMiB1bml0Tm9ybWFsID0gbm9ybWFsIC8gbm9ybWFsTGVuZ3RoO1xcblxcbiAgLy8gVGhlc2UgZmlyc3QgY29tcHV0YXRpb25zIGFyZSB0YWtlbiBmcm9tIGVkZ2UudmVydC5nbHNsLiBQbGVhc2UgcmVhZCBpdCB0b1xcbiAgLy8gZ2V0IGJldHRlciBjb21tZW50cyBvbiB3aGF0J3MgaGFwcGVuaW5nOlxcbiAgZmxvYXQgcGl4ZWxzVGhpY2tuZXNzID0gbWF4KG5vcm1hbExlbmd0aCwgbWluVGhpY2tuZXNzICogdV9zaXplUmF0aW8pO1xcbiAgZmxvYXQgd2ViR0xUaGlja25lc3MgPSBwaXhlbHNUaGlja25lc3MgKiB1X2NvcnJlY3Rpb25SYXRpbyAvIHVfc2l6ZVJhdGlvO1xcblxcbiAgLy8gSGVyZSwgd2UgbW92ZSB0aGUgcG9pbnQgdG8gbGVhdmUgc3BhY2UgZm9yIHRoZSBhcnJvdyBoZWFkOlxcbiAgZmxvYXQgZGlyZWN0aW9uID0gc2lnbihyYWRpdXMpO1xcbiAgZmxvYXQgd2ViR0xOb2RlUmFkaXVzID0gZGlyZWN0aW9uICogcmFkaXVzICogMi4wICogdV9jb3JyZWN0aW9uUmF0aW8gLyB1X3NpemVSYXRpbztcXG4gIGZsb2F0IHdlYkdMQXJyb3dIZWFkTGVuZ3RoID0gd2ViR0xUaGlja25lc3MgKiAyLjAgKiBhcnJvd0hlYWRMZW5ndGhUaGlja25lc3NSYXRpbztcXG5cXG4gIHZlYzIgY29tcGVuc2F0aW9uVmVjdG9yID0gdmVjMigtZGlyZWN0aW9uICogdW5pdE5vcm1hbC55LCBkaXJlY3Rpb24gKiB1bml0Tm9ybWFsLngpICogKHdlYkdMTm9kZVJhZGl1cyArIHdlYkdMQXJyb3dIZWFkTGVuZ3RoKTtcXG5cXG4gIC8vIEhlcmUgaXMgdGhlIHByb3BlciBwb3NpdGlvbiBvZiB0aGUgdmVydGV4XFxuICBnbF9Qb3NpdGlvbiA9IHZlYzQoKHVfbWF0cml4ICogdmVjMyhwb3NpdGlvbiArIHVuaXROb3JtYWwgKiB3ZWJHTFRoaWNrbmVzcyArIGNvbXBlbnNhdGlvblZlY3RvciwgMSkpLnh5LCAwLCAxKTtcXG5cXG4gIHZfdGhpY2tuZXNzID0gd2ViR0xUaGlja25lc3MgLyB1X3pvb21SYXRpbztcXG5cXG4gIHZfbm9ybWFsID0gdW5pdE5vcm1hbDtcXG5cXG4gICNpZmRlZiBQSUNLSU5HX01PREVcXG4gIC8vIEZvciBwaWNraW5nIG1vZGUsIHdlIHVzZSB0aGUgSUQgYXMgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfaWQ7XFxuICAjZWxzZVxcbiAgLy8gRm9yIG5vcm1hbCBtb2RlLCB3ZSB1c2UgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfY29sb3I7XFxuICAjZW5kaWZcXG5cXG4gIHZfY29sb3IuYSAqPSBiaWFzO1xcbn1cXG5cIjtcbnZhciBWRVJURVhfU0hBREVSX1NPVVJDRSA9IFNIQURFUl9TT1VSQ0U7XG5cbnZhciBfV2ViR0xSZW5kZXJpbmdDb250ZXggPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQsXG4gIFVOU0lHTkVEX0JZVEUgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXguVU5TSUdORURfQllURSxcbiAgRkxPQVQgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXguRkxPQVQ7XG52YXIgRWRnZUNsYW1wZWRQcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWRnZVJlY3RhbmdsZVByb2dyYW0pIHtcbiAgX2luaGVyaXRzKEVkZ2VDbGFtcGVkUHJvZ3JhbSwgX0VkZ2VSZWN0YW5nbGVQcm9ncmFtKTtcbiAgZnVuY3Rpb24gRWRnZUNsYW1wZWRQcm9ncmFtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlQ2xhbXBlZFByb2dyYW0pO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIEVkZ2VDbGFtcGVkUHJvZ3JhbSwgYXJndW1lbnRzKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoRWRnZUNsYW1wZWRQcm9ncmFtLCBbe1xuICAgIGtleTogXCJnZXREZWZpbml0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmluaXRpb24oKSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIF9nZXQoX2dldFByb3RvdHlwZU9mKEVkZ2VDbGFtcGVkUHJvZ3JhbS5wcm90b3R5cGUpLCBcImdldERlZmluaXRpb25cIiwgdGhpcykuY2FsbCh0aGlzKSksIHt9LCB7XG4gICAgICAgIFZFUlRFWF9TSEFERVJfU09VUkNFOiBWRVJURVhfU0hBREVSX1NPVVJDRSxcbiAgICAgICAgQVRUUklCVVRFUzogW3tcbiAgICAgICAgICBuYW1lOiBcImFfcG9zaXRpb25TdGFydFwiLFxuICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgdHlwZTogRkxPQVRcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9wb3NpdGlvbkVuZFwiLFxuICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgdHlwZTogRkxPQVRcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9ub3JtYWxcIixcbiAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgIHR5cGU6IEZMT0FUXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfY29sb3JcIixcbiAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgIHR5cGU6IFVOU0lHTkVEX0JZVEUsXG4gICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX2lkXCIsXG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFLFxuICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9yYWRpdXNcIixcbiAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgIHR5cGU6IEZMT0FUXG4gICAgICAgIH1dLFxuICAgICAgICBDT05TVEFOVF9BVFRSSUJVVEVTOiBbXG4gICAgICAgIC8vIElmIDAsIHRoZW4gcG9zaXRpb24gd2lsbCBiZSBhX3Bvc2l0aW9uU3RhcnRcbiAgICAgICAgLy8gSWYgMSwgdGhlbiBwb3NpdGlvbiB3aWxsIGJlIGFfcG9zaXRpb25FbmRcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiYV9wb3NpdGlvbkNvZWZcIixcbiAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgIHR5cGU6IEZMT0FUXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfbm9ybWFsQ29lZlwiLFxuICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgdHlwZTogRkxPQVRcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9yYWRpdXNDb2VmXCIsXG4gICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICB0eXBlOiBGTE9BVFxuICAgICAgICB9XSxcbiAgICAgICAgQ09OU1RBTlRfREFUQTogW1swLCAxLCAwXSwgWzAsIC0xLCAwXSwgWzEsIDEsIDFdLCBbMSwgMSwgMV0sIFswLCAtMSwgMF0sIFsxLCAtMSwgLTFdXVxuICAgICAgfSk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NWaXNpYmxlSXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVmlzaWJsZUl0ZW0oZWRnZUluZGV4LCBzdGFydEluZGV4LCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhLCBkYXRhKSB7XG4gICAgICB2YXIgdGhpY2tuZXNzID0gZGF0YS5zaXplIHx8IDE7XG4gICAgICB2YXIgeDEgPSBzb3VyY2VEYXRhLng7XG4gICAgICB2YXIgeTEgPSBzb3VyY2VEYXRhLnk7XG4gICAgICB2YXIgeDIgPSB0YXJnZXREYXRhLng7XG4gICAgICB2YXIgeTIgPSB0YXJnZXREYXRhLnk7XG4gICAgICB2YXIgY29sb3IgPSBmbG9hdENvbG9yKGRhdGEuY29sb3IpO1xuXG4gICAgICAvLyBDb21wdXRpbmcgbm9ybWFsc1xuICAgICAgdmFyIGR4ID0geDIgLSB4MTtcbiAgICAgIHZhciBkeSA9IHkyIC0geTE7XG4gICAgICB2YXIgcmFkaXVzID0gdGFyZ2V0RGF0YS5zaXplIHx8IDE7XG4gICAgICB2YXIgbGVuID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICB2YXIgbjEgPSAwO1xuICAgICAgdmFyIG4yID0gMDtcbiAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBuMSA9IC1keSAqIGxlbiAqIHRoaWNrbmVzcztcbiAgICAgICAgbjIgPSBkeCAqIGxlbiAqIHRoaWNrbmVzcztcbiAgICAgIH1cbiAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0geDE7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0geTE7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0geDI7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0geTI7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gbjE7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gbjI7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gY29sb3I7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gZWRnZUluZGV4O1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHJhZGl1cztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIEVkZ2VDbGFtcGVkUHJvZ3JhbTtcbn0oRWRnZVJlY3RhbmdsZVByb2dyYW0pO1xuXG4vKipcbiAqIFNpZ21hLmpzIFdlYkdMIFJlbmRlcmVyIEVkZ2UgQXJyb3cgUHJvZ3JhbVxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIENvbXBvdW5kIHByb2dyYW0gcmVuZGVyaW5nIGVkZ2VzIGFzIGFuIGFycm93IGZyb20gdGhlIHNvdXJjZSB0byB0aGUgdGFyZ2V0LlxuICogQG1vZHVsZVxuICovXG52YXIgRWRnZUFycm93UHJvZ3JhbSA9IGNyZWF0ZUVkZ2VDb21wb3VuZFByb2dyYW0oW0VkZ2VDbGFtcGVkUHJvZ3JhbSwgRWRnZUFycm93SGVhZFByb2dyYW1dKTtcbnZhciBFZGdlQXJyb3dQcm9ncmFtJDEgPSBFZGdlQXJyb3dQcm9ncmFtO1xuXG5leHBvcnQgeyBBYnN0cmFjdE5vZGVQcm9ncmFtIGFzIEEsIEVkZ2VBcnJvd1Byb2dyYW0kMSBhcyBFLCBOb2RlQ2lyY2xlUHJvZ3JhbSBhcyBOLCBQcm9ncmFtIGFzIFAsIF9kZWZpbmVQcm9wZXJ0eSBhcyBfLCBfb2JqZWN0U3ByZWFkMiBhcyBhLCBkcmF3RGlzY05vZGVMYWJlbCBhcyBiLCBkcmF3RGlzY05vZGVIb3ZlciBhcyBjLCBkcmF3U3RyYWlnaHRFZGdlTGFiZWwgYXMgZCwgRWRnZVJlY3RhbmdsZVByb2dyYW0gYXMgZSwgTm9kZVByb2dyYW0gYXMgZiwgRWRnZVByb2dyYW0gYXMgZywgY3JlYXRlTm9kZUNvbXBvdW5kUHJvZ3JhbSBhcyBoLCBBYnN0cmFjdEVkZ2VQcm9ncmFtIGFzIGksIGNyZWF0ZUVkZ2VDb21wb3VuZFByb2dyYW0gYXMgaiwgQWJzdHJhY3RQcm9ncmFtIGFzIGssIEVkZ2VBcnJvd0hlYWRQcm9ncmFtIGFzIGwsIEVkZ2VDbGFtcGVkUHJvZ3JhbSBhcyBtLCBsb2FkVmVydGV4U2hhZGVyIGFzIG4sIGxvYWRGcmFnbWVudFNoYWRlciBhcyBvLCBsb2FkUHJvZ3JhbSBhcyBwLCBudW1iZXJUb0dMU0xGbG9hdCBhcyBxIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sigma/dist/index-29acc883.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sigma/dist/inherits-8fbdedb5.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/sigma/dist/inherits-8fbdedb5.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _: () => (/* binding */ _inherits),\n/* harmony export */   a: () => (/* binding */ _classCallCheck),\n/* harmony export */   b: () => (/* binding */ _callSuper),\n/* harmony export */   c: () => (/* binding */ _assertThisInitialized),\n/* harmony export */   d: () => (/* binding */ _createClass),\n/* harmony export */   e: () => (/* binding */ _getPrototypeOf),\n/* harmony export */   t: () => (/* binding */ toPropertyKey)\n/* harmony export */ });\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\n\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2lnbWEvZGlzdC9pbmhlcml0cy04ZmJkZWRiNS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUZBQXlGO0FBQ3pGLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFMkoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcG9uc2FydS8uL25vZGVfbW9kdWxlcy9zaWdtYS9kaXN0L2luaGVyaXRzLThmYmRlZGI1LmVzbS5qcz9iMjYyIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvUHJpbWl0aXZlKHQsIHIpIHtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHQgfHwgIXQpIHJldHVybiB0O1xuICB2YXIgZSA9IHRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHZhciBpID0gZS5jYWxsKHQsIHIgfHwgXCJkZWZhdWx0XCIpO1xuICAgIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiBpKSByZXR1cm4gaTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQEB0b1ByaW1pdGl2ZSBtdXN0IHJldHVybiBhIHByaW1pdGl2ZSB2YWx1ZS5cIik7XG4gIH1cbiAgcmV0dXJuIChcInN0cmluZ1wiID09PSByID8gU3RyaW5nIDogTnVtYmVyKSh0KTtcbn1cblxuZnVuY3Rpb24gdG9Qcm9wZXJ0eUtleSh0KSB7XG4gIHZhciBpID0gdG9QcmltaXRpdmUodCwgXCJzdHJpbmdcIik7XG4gIHJldHVybiBcInN5bWJvbFwiID09IHR5cGVvZiBpID8gaSA6IFN0cmluZyhpKTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgdG9Qcm9wZXJ0eUtleShkZXNjcmlwdG9yLmtleSksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gIGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25zdHJ1Y3RvciwgXCJwcm90b3R5cGVcIiwge1xuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5mdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICBfZ2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3QuZ2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX2dldFByb3RvdHlwZU9mKG8pIHtcbiAgICByZXR1cm4gby5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKG8pO1xuICB9O1xuICByZXR1cm4gX2dldFByb3RvdHlwZU9mKG8pO1xufVxuXG5mdW5jdGlvbiBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkge1xuICB0cnkge1xuICAgIHZhciB0ID0gIUJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2YuY2FsbChSZWZsZWN0LmNvbnN0cnVjdChCb29sZWFuLCBbXSwgZnVuY3Rpb24gKCkge30pKTtcbiAgfSBjYXRjaCAodCkge31cbiAgcmV0dXJuIChfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhIXQ7XG4gIH0pKCk7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoc2VsZikge1xuICBpZiAoc2VsZiA9PT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICB9XG4gIHJldHVybiBzZWxmO1xufVxuXG5mdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gIGlmIChjYWxsICYmICh0eXBlb2YgY2FsbCA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2YgY2FsbCA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgIHJldHVybiBjYWxsO1xuICB9IGVsc2UgaWYgKGNhbGwgIT09IHZvaWQgMCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJEZXJpdmVkIGNvbnN0cnVjdG9ycyBtYXkgb25seSByZXR1cm4gb2JqZWN0IG9yIHVuZGVmaW5lZFwiKTtcbiAgfVxuICByZXR1cm4gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKTtcbn1cblxuZnVuY3Rpb24gX2NhbGxTdXBlcih0LCBvLCBlKSB7XG4gIHJldHVybiBvID0gX2dldFByb3RvdHlwZU9mKG8pLCBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybih0LCBfaXNOYXRpdmVSZWZsZWN0Q29uc3RydWN0KCkgPyBSZWZsZWN0LmNvbnN0cnVjdChvLCBlIHx8IFtdLCBfZ2V0UHJvdG90eXBlT2YodCkuY29uc3RydWN0b3IpIDogby5hcHBseSh0LCBlKSk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZXhwb3J0IHsgX2luaGVyaXRzIGFzIF8sIF9jbGFzc0NhbGxDaGVjayBhcyBhLCBfY2FsbFN1cGVyIGFzIGIsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQgYXMgYywgX2NyZWF0ZUNsYXNzIGFzIGQsIF9nZXRQcm90b3R5cGVPZiBhcyBlLCB0b1Byb3BlcnR5S2V5IGFzIHQgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sigma/dist/inherits-8fbdedb5.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sigma/dist/normalization-8e7b2e97.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/sigma/dist/normalization-8e7b2e97.esm.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ ANIMATE_DEFAULTS),\n/* harmony export */   a: () => (/* binding */ createElement),\n/* harmony export */   b: () => (/* binding */ graphExtent),\n/* harmony export */   c: () => (/* binding */ createNormalizationFunction),\n/* harmony export */   d: () => (/* binding */ getMatrixImpact),\n/* harmony export */   e: () => (/* binding */ easings),\n/* harmony export */   f: () => (/* binding */ multiplyVec2),\n/* harmony export */   g: () => (/* binding */ getPixelRatio),\n/* harmony export */   h: () => (/* binding */ animateNodes),\n/* harmony export */   i: () => (/* binding */ identity),\n/* harmony export */   j: () => (/* binding */ getCorrectionRatio),\n/* harmony export */   k: () => (/* binding */ quadraticOut),\n/* harmony export */   l: () => (/* binding */ linear),\n/* harmony export */   m: () => (/* binding */ matrixFromCamera),\n/* harmony export */   n: () => (/* binding */ quadraticInOut),\n/* harmony export */   o: () => (/* binding */ cubicIn),\n/* harmony export */   p: () => (/* binding */ cubicOut),\n/* harmony export */   q: () => (/* binding */ quadraticIn),\n/* harmony export */   r: () => (/* binding */ cubicInOut),\n/* harmony export */   s: () => (/* binding */ scale),\n/* harmony export */   t: () => (/* binding */ rotate),\n/* harmony export */   u: () => (/* binding */ translate),\n/* harmony export */   v: () => (/* binding */ validateGraph),\n/* harmony export */   w: () => (/* binding */ multiply),\n/* harmony export */   z: () => (/* binding */ zIndexOrdering)\n/* harmony export */ });\n/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! graphology-utils/is-graph */ \"(ssr)/./node_modules/graphology-utils/is-graph.js\");\n/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./colors-2f6d17f0.esm.js */ \"(ssr)/./node_modules/sigma/dist/colors-2f6d17f0.esm.js\");\n\n\n\nvar linear = function linear(k) {\n  return k;\n};\nvar quadraticIn = function quadraticIn(k) {\n  return k * k;\n};\nvar quadraticOut = function quadraticOut(k) {\n  return k * (2 - k);\n};\nvar quadraticInOut = function quadraticInOut(k) {\n  if ((k *= 2) < 1) return 0.5 * k * k;\n  return -0.5 * (--k * (k - 2) - 1);\n};\nvar cubicIn = function cubicIn(k) {\n  return k * k * k;\n};\nvar cubicOut = function cubicOut(k) {\n  return --k * k * k + 1;\n};\nvar cubicInOut = function cubicInOut(k) {\n  if ((k *= 2) < 1) return 0.5 * k * k * k;\n  return 0.5 * ((k -= 2) * k * k + 2);\n};\nvar easings = {\n  linear: linear,\n  quadraticIn: quadraticIn,\n  quadraticOut: quadraticOut,\n  quadraticInOut: quadraticInOut,\n  cubicIn: cubicIn,\n  cubicOut: cubicOut,\n  cubicInOut: cubicInOut\n};\n\n/**\n * Defaults.\n */\n\nvar ANIMATE_DEFAULTS = {\n  easing: \"quadraticInOut\",\n  duration: 150\n};\n\n/**\n * Function used to animate the nodes.\n */\nfunction animateNodes(graph, targets, opts, callback) {\n  var options = Object.assign({}, ANIMATE_DEFAULTS, opts);\n  var easing = typeof options.easing === \"function\" ? options.easing : easings[options.easing];\n  var start = Date.now();\n  var startPositions = {};\n  for (var node in targets) {\n    var attrs = targets[node];\n    startPositions[node] = {};\n    for (var _k in attrs) startPositions[node][_k] = graph.getNodeAttribute(node, _k);\n  }\n  var frame = null;\n  var step = function step() {\n    frame = null;\n    var p = (Date.now() - start) / options.duration;\n    if (p >= 1) {\n      // Animation is done\n      for (var _node in targets) {\n        var _attrs = targets[_node];\n\n        // We use given values to avoid precision issues and for convenience\n        for (var _k2 in _attrs) graph.setNodeAttribute(_node, _k2, _attrs[_k2]);\n      }\n      if (typeof callback === \"function\") callback();\n      return;\n    }\n    p = easing(p);\n    for (var _node2 in targets) {\n      var _attrs2 = targets[_node2];\n      var s = startPositions[_node2];\n      for (var _k3 in _attrs2) graph.setNodeAttribute(_node2, _k3, _attrs2[_k3] * p + s[_k3] * (1 - p));\n    }\n    frame = requestAnimationFrame(step);\n  };\n  step();\n  return function () {\n    if (frame) cancelAnimationFrame(frame);\n  };\n}\n\nfunction identity() {\n  return Float32Array.of(1, 0, 0, 0, 1, 0, 0, 0, 1);\n}\n\n// TODO: optimize\nfunction scale(m, x, y) {\n  m[0] = x;\n  m[4] = typeof y === \"number\" ? y : x;\n  return m;\n}\nfunction rotate(m, r) {\n  var s = Math.sin(r),\n    c = Math.cos(r);\n  m[0] = c;\n  m[1] = s;\n  m[3] = -s;\n  m[4] = c;\n  return m;\n}\nfunction translate(m, x, y) {\n  m[6] = x;\n  m[7] = y;\n  return m;\n}\nfunction multiply(a, b) {\n  var a00 = a[0],\n    a01 = a[1],\n    a02 = a[2];\n  var a10 = a[3],\n    a11 = a[4],\n    a12 = a[5];\n  var a20 = a[6],\n    a21 = a[7],\n    a22 = a[8];\n  var b00 = b[0],\n    b01 = b[1],\n    b02 = b[2];\n  var b10 = b[3],\n    b11 = b[4],\n    b12 = b[5];\n  var b20 = b[6],\n    b21 = b[7],\n    b22 = b[8];\n  a[0] = b00 * a00 + b01 * a10 + b02 * a20;\n  a[1] = b00 * a01 + b01 * a11 + b02 * a21;\n  a[2] = b00 * a02 + b01 * a12 + b02 * a22;\n  a[3] = b10 * a00 + b11 * a10 + b12 * a20;\n  a[4] = b10 * a01 + b11 * a11 + b12 * a21;\n  a[5] = b10 * a02 + b11 * a12 + b12 * a22;\n  a[6] = b20 * a00 + b21 * a10 + b22 * a20;\n  a[7] = b20 * a01 + b21 * a11 + b22 * a21;\n  a[8] = b20 * a02 + b21 * a12 + b22 * a22;\n  return a;\n}\nfunction multiplyVec2(a, b) {\n  var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  var a00 = a[0];\n  var a01 = a[1];\n  var a10 = a[3];\n  var a11 = a[4];\n  var a20 = a[6];\n  var a21 = a[7];\n  var b0 = b.x;\n  var b1 = b.y;\n  return {\n    x: b0 * a00 + b1 * a10 + a20 * z,\n    y: b0 * a01 + b1 * a11 + a21 * z\n  };\n}\n\n/**\n * In sigma, the graph is normalized into a [0, 1], [0, 1] square, before being given to the various renderers. This\n * helps to deal with quadtree in particular.\n * But at some point, we need to rescale it so that it takes the best place in the screen, i.e. we always want to see two\n * nodes \"touching\" opposite sides of the graph, with the camera being at its default state.\n *\n * This function determines this ratio.\n */\nfunction getCorrectionRatio(viewportDimensions, graphDimensions) {\n  var viewportRatio = viewportDimensions.height / viewportDimensions.width;\n  var graphRatio = graphDimensions.height / graphDimensions.width;\n\n  // If the stage and the graphs are in different directions (such as the graph being wider that tall while the stage\n  // is taller than wide), we can stop here to have indeed nodes touching opposite sides:\n  if (viewportRatio < 1 && graphRatio > 1 || viewportRatio > 1 && graphRatio < 1) {\n    return 1;\n  }\n\n  // Else, we need to fit the graph inside the stage:\n  // 1. If the graph is \"squarer\" (i.e. with a ratio closer to 1), we need to make the largest sides touch;\n  // 2. If the stage is \"squarer\", we need to make the smallest sides touch.\n  return Math.min(Math.max(graphRatio, 1 / graphRatio), Math.max(1 / viewportRatio, viewportRatio));\n}\n\n/**\n * Function returning a matrix from the current state of the camera.\n */\nfunction matrixFromCamera(state, viewportDimensions, graphDimensions, padding, inverse) {\n  // TODO: it's possible to optimize this drastically!\n  var angle = state.angle,\n    ratio = state.ratio,\n    x = state.x,\n    y = state.y;\n  var width = viewportDimensions.width,\n    height = viewportDimensions.height;\n  var matrix = identity();\n  var smallestDimension = Math.min(width, height) - 2 * padding;\n  var correctionRatio = getCorrectionRatio(viewportDimensions, graphDimensions);\n  if (!inverse) {\n    multiply(matrix, scale(identity(), 2 * (smallestDimension / width) * correctionRatio, 2 * (smallestDimension / height) * correctionRatio));\n    multiply(matrix, rotate(identity(), -angle));\n    multiply(matrix, scale(identity(), 1 / ratio));\n    multiply(matrix, translate(identity(), -x, -y));\n  } else {\n    multiply(matrix, translate(identity(), x, y));\n    multiply(matrix, scale(identity(), ratio));\n    multiply(matrix, rotate(identity(), angle));\n    multiply(matrix, scale(identity(), width / smallestDimension / 2 / correctionRatio, height / smallestDimension / 2 / correctionRatio));\n  }\n  return matrix;\n}\n\n/**\n * All these transformations we apply on the matrix to get it rescale the graph\n * as we want make it very hard to get pixel-perfect distances in WebGL. This\n * function returns a factor that properly cancels the matrix effect on lengths.\n *\n * [jacomyal]\n * To be fully honest, I can't really explain happens here... I notice that the\n * following ratio works (i.e. it correctly compensates the matrix impact on all\n * camera states I could try):\n * > `R = size(V) / size(M * V) / W`\n * as long as `M * V` is in the direction of W (ie. parallel to (Ox)). It works\n * as well with H and a vector that transforms into something parallel to (Oy).\n *\n * Also, note that we use `angle` and not `-angle` (that would seem logical,\n * since we want to anticipate the rotation), because the image is vertically\n * swapped in WebGL.\n */\nfunction getMatrixImpact(matrix, cameraState, viewportDimensions) {\n  var _multiplyVec = multiplyVec2(matrix, {\n      x: Math.cos(cameraState.angle),\n      y: Math.sin(cameraState.angle)\n    }, 0),\n    x = _multiplyVec.x,\n    y = _multiplyVec.y;\n  return 1 / Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2)) / viewportDimensions.width;\n}\n\n/**\n * Function returning the graph's node extent in x & y.\n */\nfunction graphExtent(graph) {\n  if (!graph.order) return {\n    x: [0, 1],\n    y: [0, 1]\n  };\n  var xMin = Infinity;\n  var xMax = -Infinity;\n  var yMin = Infinity;\n  var yMax = -Infinity;\n  graph.forEachNode(function (_, attr) {\n    var x = attr.x,\n      y = attr.y;\n    if (x < xMin) xMin = x;\n    if (x > xMax) xMax = x;\n    if (y < yMin) yMin = y;\n    if (y > yMax) yMax = y;\n  });\n  return {\n    x: [xMin, xMax],\n    y: [yMin, yMax]\n  };\n}\n\n/**\n * Check if the graph variable is a valid graph, and if sigma can render it.\n */\nfunction validateGraph(graph) {\n  // check if it's a valid graphology instance\n  if (!graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_0___default()(graph)) throw new Error(\"Sigma: invalid graph instance.\");\n\n  // check if nodes have x/y attributes\n  graph.forEachNode(function (key, attributes) {\n    if (!Number.isFinite(attributes.x) || !Number.isFinite(attributes.y)) {\n      throw new Error(\"Sigma: Coordinates of node \".concat(key, \" are invalid. A node must have a numeric 'x' and 'y' attribute.\"));\n    }\n  });\n}\n\n/**\n * Function used to create DOM elements easily.\n */\nfunction createElement(tag, style, attributes) {\n  var element = document.createElement(tag);\n  if (style) {\n    for (var k in style) {\n      element.style[k] = style[k];\n    }\n  }\n  if (attributes) {\n    for (var _k in attributes) {\n      element.setAttribute(_k, attributes[_k]);\n    }\n  }\n  return element;\n}\n\n/**\n * Function returning the browser's pixel ratio.\n */\nfunction getPixelRatio() {\n  if (typeof window.devicePixelRatio !== \"undefined\") return window.devicePixelRatio;\n  return 1;\n}\n\n/**\n * Function ordering the given elements in reverse z-order so they drawn\n * the correct way.\n */\nfunction zIndexOrdering(_extent, getter, elements) {\n  // If k is > n, we'll use a standard sort\n  return elements.sort(function (a, b) {\n    var zA = getter(a) || 0,\n      zB = getter(b) || 0;\n    if (zA < zB) return -1;\n    if (zA > zB) return 1;\n    return 0;\n  });\n\n  // TODO: counting sort optimization\n}\n\n/**\n * Factory returning a function normalizing the given node's position & size.\n */\n\nfunction createNormalizationFunction(extent) {\n  var _extent$x = (0,_colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(extent.x, 2),\n    minX = _extent$x[0],\n    maxX = _extent$x[1],\n    _extent$y = (0,_colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(extent.y, 2),\n    minY = _extent$y[0],\n    maxY = _extent$y[1];\n  var ratio = Math.max(maxX - minX, maxY - minY),\n    dX = (maxX + minX) / 2,\n    dY = (maxY + minY) / 2;\n  if (ratio === 0 || Math.abs(ratio) === Infinity || isNaN(ratio)) ratio = 1;\n  if (isNaN(dX)) dX = 0;\n  if (isNaN(dY)) dY = 0;\n  var fn = function fn(data) {\n    return {\n      x: 0.5 + (data.x - dX) / ratio,\n      y: 0.5 + (data.y - dY) / ratio\n    };\n  };\n\n  // TODO: possibility to apply this in batch over array of indices\n  fn.applyTo = function (data) {\n    data.x = 0.5 + (data.x - dX) / ratio;\n    data.y = 0.5 + (data.y - dY) / ratio;\n  };\n  fn.inverse = function (data) {\n    return {\n      x: dX + ratio * (data.x - 0.5),\n      y: dY + ratio * (data.y - 0.5)\n    };\n  };\n  fn.ratio = ratio;\n  return fn;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2lnbWEvZGlzdC9ub3JtYWxpemF0aW9uLThlN2IyZTk3LmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWdEO0FBQ2U7O0FBRS9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLGdFQUFPOztBQUVkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLDBEQUFjO0FBQ2hDO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQWM7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU0ZCIsInNvdXJjZXMiOlsid2VicGFjazovL3Nwb25zYXJ1Ly4vbm9kZV9tb2R1bGVzL3NpZ21hL2Rpc3Qvbm9ybWFsaXphdGlvbi04ZTdiMmU5Ny5lc20uanM/NDUyOCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgaXNHcmFwaCBmcm9tICdncmFwaG9sb2d5LXV0aWxzL2lzLWdyYXBoJztcbmltcG9ydCB7IF8gYXMgX3NsaWNlZFRvQXJyYXkgfSBmcm9tICcuL2NvbG9ycy0yZjZkMTdmMC5lc20uanMnO1xuXG52YXIgbGluZWFyID0gZnVuY3Rpb24gbGluZWFyKGspIHtcbiAgcmV0dXJuIGs7XG59O1xudmFyIHF1YWRyYXRpY0luID0gZnVuY3Rpb24gcXVhZHJhdGljSW4oaykge1xuICByZXR1cm4gayAqIGs7XG59O1xudmFyIHF1YWRyYXRpY091dCA9IGZ1bmN0aW9uIHF1YWRyYXRpY091dChrKSB7XG4gIHJldHVybiBrICogKDIgLSBrKTtcbn07XG52YXIgcXVhZHJhdGljSW5PdXQgPSBmdW5jdGlvbiBxdWFkcmF0aWNJbk91dChrKSB7XG4gIGlmICgoayAqPSAyKSA8IDEpIHJldHVybiAwLjUgKiBrICogaztcbiAgcmV0dXJuIC0wLjUgKiAoLS1rICogKGsgLSAyKSAtIDEpO1xufTtcbnZhciBjdWJpY0luID0gZnVuY3Rpb24gY3ViaWNJbihrKSB7XG4gIHJldHVybiBrICogayAqIGs7XG59O1xudmFyIGN1YmljT3V0ID0gZnVuY3Rpb24gY3ViaWNPdXQoaykge1xuICByZXR1cm4gLS1rICogayAqIGsgKyAxO1xufTtcbnZhciBjdWJpY0luT3V0ID0gZnVuY3Rpb24gY3ViaWNJbk91dChrKSB7XG4gIGlmICgoayAqPSAyKSA8IDEpIHJldHVybiAwLjUgKiBrICogayAqIGs7XG4gIHJldHVybiAwLjUgKiAoKGsgLT0gMikgKiBrICogayArIDIpO1xufTtcbnZhciBlYXNpbmdzID0ge1xuICBsaW5lYXI6IGxpbmVhcixcbiAgcXVhZHJhdGljSW46IHF1YWRyYXRpY0luLFxuICBxdWFkcmF0aWNPdXQ6IHF1YWRyYXRpY091dCxcbiAgcXVhZHJhdGljSW5PdXQ6IHF1YWRyYXRpY0luT3V0LFxuICBjdWJpY0luOiBjdWJpY0luLFxuICBjdWJpY091dDogY3ViaWNPdXQsXG4gIGN1YmljSW5PdXQ6IGN1YmljSW5PdXRcbn07XG5cbi8qKlxuICogRGVmYXVsdHMuXG4gKi9cblxudmFyIEFOSU1BVEVfREVGQVVMVFMgPSB7XG4gIGVhc2luZzogXCJxdWFkcmF0aWNJbk91dFwiLFxuICBkdXJhdGlvbjogMTUwXG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIHVzZWQgdG8gYW5pbWF0ZSB0aGUgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIGFuaW1hdGVOb2RlcyhncmFwaCwgdGFyZ2V0cywgb3B0cywgY2FsbGJhY2spIHtcbiAgdmFyIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBBTklNQVRFX0RFRkFVTFRTLCBvcHRzKTtcbiAgdmFyIGVhc2luZyA9IHR5cGVvZiBvcHRpb25zLmVhc2luZyA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9ucy5lYXNpbmcgOiBlYXNpbmdzW29wdGlvbnMuZWFzaW5nXTtcbiAgdmFyIHN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgdmFyIHN0YXJ0UG9zaXRpb25zID0ge307XG4gIGZvciAodmFyIG5vZGUgaW4gdGFyZ2V0cykge1xuICAgIHZhciBhdHRycyA9IHRhcmdldHNbbm9kZV07XG4gICAgc3RhcnRQb3NpdGlvbnNbbm9kZV0gPSB7fTtcbiAgICBmb3IgKHZhciBfayBpbiBhdHRycykgc3RhcnRQb3NpdGlvbnNbbm9kZV1bX2tdID0gZ3JhcGguZ2V0Tm9kZUF0dHJpYnV0ZShub2RlLCBfayk7XG4gIH1cbiAgdmFyIGZyYW1lID0gbnVsbDtcbiAgdmFyIHN0ZXAgPSBmdW5jdGlvbiBzdGVwKCkge1xuICAgIGZyYW1lID0gbnVsbDtcbiAgICB2YXIgcCA9IChEYXRlLm5vdygpIC0gc3RhcnQpIC8gb3B0aW9ucy5kdXJhdGlvbjtcbiAgICBpZiAocCA+PSAxKSB7XG4gICAgICAvLyBBbmltYXRpb24gaXMgZG9uZVxuICAgICAgZm9yICh2YXIgX25vZGUgaW4gdGFyZ2V0cykge1xuICAgICAgICB2YXIgX2F0dHJzID0gdGFyZ2V0c1tfbm9kZV07XG5cbiAgICAgICAgLy8gV2UgdXNlIGdpdmVuIHZhbHVlcyB0byBhdm9pZCBwcmVjaXNpb24gaXNzdWVzIGFuZCBmb3IgY29udmVuaWVuY2VcbiAgICAgICAgZm9yICh2YXIgX2syIGluIF9hdHRycykgZ3JhcGguc2V0Tm9kZUF0dHJpYnV0ZShfbm9kZSwgX2syLCBfYXR0cnNbX2syXSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHAgPSBlYXNpbmcocCk7XG4gICAgZm9yICh2YXIgX25vZGUyIGluIHRhcmdldHMpIHtcbiAgICAgIHZhciBfYXR0cnMyID0gdGFyZ2V0c1tfbm9kZTJdO1xuICAgICAgdmFyIHMgPSBzdGFydFBvc2l0aW9uc1tfbm9kZTJdO1xuICAgICAgZm9yICh2YXIgX2szIGluIF9hdHRyczIpIGdyYXBoLnNldE5vZGVBdHRyaWJ1dGUoX25vZGUyLCBfazMsIF9hdHRyczJbX2szXSAqIHAgKyBzW19rM10gKiAoMSAtIHApKTtcbiAgICB9XG4gICAgZnJhbWUgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoc3RlcCk7XG4gIH07XG4gIHN0ZXAoKTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoZnJhbWUpIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaWRlbnRpdHkoKSB7XG4gIHJldHVybiBGbG9hdDMyQXJyYXkub2YoMSwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMSk7XG59XG5cbi8vIFRPRE86IG9wdGltaXplXG5mdW5jdGlvbiBzY2FsZShtLCB4LCB5KSB7XG4gIG1bMF0gPSB4O1xuICBtWzRdID0gdHlwZW9mIHkgPT09IFwibnVtYmVyXCIgPyB5IDogeDtcbiAgcmV0dXJuIG07XG59XG5mdW5jdGlvbiByb3RhdGUobSwgcikge1xuICB2YXIgcyA9IE1hdGguc2luKHIpLFxuICAgIGMgPSBNYXRoLmNvcyhyKTtcbiAgbVswXSA9IGM7XG4gIG1bMV0gPSBzO1xuICBtWzNdID0gLXM7XG4gIG1bNF0gPSBjO1xuICByZXR1cm4gbTtcbn1cbmZ1bmN0aW9uIHRyYW5zbGF0ZShtLCB4LCB5KSB7XG4gIG1bNl0gPSB4O1xuICBtWzddID0geTtcbiAgcmV0dXJuIG07XG59XG5mdW5jdGlvbiBtdWx0aXBseShhLCBiKSB7XG4gIHZhciBhMDAgPSBhWzBdLFxuICAgIGEwMSA9IGFbMV0sXG4gICAgYTAyID0gYVsyXTtcbiAgdmFyIGExMCA9IGFbM10sXG4gICAgYTExID0gYVs0XSxcbiAgICBhMTIgPSBhWzVdO1xuICB2YXIgYTIwID0gYVs2XSxcbiAgICBhMjEgPSBhWzddLFxuICAgIGEyMiA9IGFbOF07XG4gIHZhciBiMDAgPSBiWzBdLFxuICAgIGIwMSA9IGJbMV0sXG4gICAgYjAyID0gYlsyXTtcbiAgdmFyIGIxMCA9IGJbM10sXG4gICAgYjExID0gYls0XSxcbiAgICBiMTIgPSBiWzVdO1xuICB2YXIgYjIwID0gYls2XSxcbiAgICBiMjEgPSBiWzddLFxuICAgIGIyMiA9IGJbOF07XG4gIGFbMF0gPSBiMDAgKiBhMDAgKyBiMDEgKiBhMTAgKyBiMDIgKiBhMjA7XG4gIGFbMV0gPSBiMDAgKiBhMDEgKyBiMDEgKiBhMTEgKyBiMDIgKiBhMjE7XG4gIGFbMl0gPSBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjI7XG4gIGFbM10gPSBiMTAgKiBhMDAgKyBiMTEgKiBhMTAgKyBiMTIgKiBhMjA7XG4gIGFbNF0gPSBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjE7XG4gIGFbNV0gPSBiMTAgKiBhMDIgKyBiMTEgKiBhMTIgKyBiMTIgKiBhMjI7XG4gIGFbNl0gPSBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjA7XG4gIGFbN10gPSBiMjAgKiBhMDEgKyBiMjEgKiBhMTEgKyBiMjIgKiBhMjE7XG4gIGFbOF0gPSBiMjAgKiBhMDIgKyBiMjEgKiBhMTIgKyBiMjIgKiBhMjI7XG4gIHJldHVybiBhO1xufVxuZnVuY3Rpb24gbXVsdGlwbHlWZWMyKGEsIGIpIHtcbiAgdmFyIHogPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDE7XG4gIHZhciBhMDAgPSBhWzBdO1xuICB2YXIgYTAxID0gYVsxXTtcbiAgdmFyIGExMCA9IGFbM107XG4gIHZhciBhMTEgPSBhWzRdO1xuICB2YXIgYTIwID0gYVs2XTtcbiAgdmFyIGEyMSA9IGFbN107XG4gIHZhciBiMCA9IGIueDtcbiAgdmFyIGIxID0gYi55O1xuICByZXR1cm4ge1xuICAgIHg6IGIwICogYTAwICsgYjEgKiBhMTAgKyBhMjAgKiB6LFxuICAgIHk6IGIwICogYTAxICsgYjEgKiBhMTEgKyBhMjEgKiB6XG4gIH07XG59XG5cbi8qKlxuICogSW4gc2lnbWEsIHRoZSBncmFwaCBpcyBub3JtYWxpemVkIGludG8gYSBbMCwgMV0sIFswLCAxXSBzcXVhcmUsIGJlZm9yZSBiZWluZyBnaXZlbiB0byB0aGUgdmFyaW91cyByZW5kZXJlcnMuIFRoaXNcbiAqIGhlbHBzIHRvIGRlYWwgd2l0aCBxdWFkdHJlZSBpbiBwYXJ0aWN1bGFyLlxuICogQnV0IGF0IHNvbWUgcG9pbnQsIHdlIG5lZWQgdG8gcmVzY2FsZSBpdCBzbyB0aGF0IGl0IHRha2VzIHRoZSBiZXN0IHBsYWNlIGluIHRoZSBzY3JlZW4sIGkuZS4gd2UgYWx3YXlzIHdhbnQgdG8gc2VlIHR3b1xuICogbm9kZXMgXCJ0b3VjaGluZ1wiIG9wcG9zaXRlIHNpZGVzIG9mIHRoZSBncmFwaCwgd2l0aCB0aGUgY2FtZXJhIGJlaW5nIGF0IGl0cyBkZWZhdWx0IHN0YXRlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyB0aGlzIHJhdGlvLlxuICovXG5mdW5jdGlvbiBnZXRDb3JyZWN0aW9uUmF0aW8odmlld3BvcnREaW1lbnNpb25zLCBncmFwaERpbWVuc2lvbnMpIHtcbiAgdmFyIHZpZXdwb3J0UmF0aW8gPSB2aWV3cG9ydERpbWVuc2lvbnMuaGVpZ2h0IC8gdmlld3BvcnREaW1lbnNpb25zLndpZHRoO1xuICB2YXIgZ3JhcGhSYXRpbyA9IGdyYXBoRGltZW5zaW9ucy5oZWlnaHQgLyBncmFwaERpbWVuc2lvbnMud2lkdGg7XG5cbiAgLy8gSWYgdGhlIHN0YWdlIGFuZCB0aGUgZ3JhcGhzIGFyZSBpbiBkaWZmZXJlbnQgZGlyZWN0aW9ucyAoc3VjaCBhcyB0aGUgZ3JhcGggYmVpbmcgd2lkZXIgdGhhdCB0YWxsIHdoaWxlIHRoZSBzdGFnZVxuICAvLyBpcyB0YWxsZXIgdGhhbiB3aWRlKSwgd2UgY2FuIHN0b3AgaGVyZSB0byBoYXZlIGluZGVlZCBub2RlcyB0b3VjaGluZyBvcHBvc2l0ZSBzaWRlczpcbiAgaWYgKHZpZXdwb3J0UmF0aW8gPCAxICYmIGdyYXBoUmF0aW8gPiAxIHx8IHZpZXdwb3J0UmF0aW8gPiAxICYmIGdyYXBoUmF0aW8gPCAxKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvLyBFbHNlLCB3ZSBuZWVkIHRvIGZpdCB0aGUgZ3JhcGggaW5zaWRlIHRoZSBzdGFnZTpcbiAgLy8gMS4gSWYgdGhlIGdyYXBoIGlzIFwic3F1YXJlclwiIChpLmUuIHdpdGggYSByYXRpbyBjbG9zZXIgdG8gMSksIHdlIG5lZWQgdG8gbWFrZSB0aGUgbGFyZ2VzdCBzaWRlcyB0b3VjaDtcbiAgLy8gMi4gSWYgdGhlIHN0YWdlIGlzIFwic3F1YXJlclwiLCB3ZSBuZWVkIHRvIG1ha2UgdGhlIHNtYWxsZXN0IHNpZGVzIHRvdWNoLlxuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoZ3JhcGhSYXRpbywgMSAvIGdyYXBoUmF0aW8pLCBNYXRoLm1heCgxIC8gdmlld3BvcnRSYXRpbywgdmlld3BvcnRSYXRpbykpO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybmluZyBhIG1hdHJpeCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBjYW1lcmEuXG4gKi9cbmZ1bmN0aW9uIG1hdHJpeEZyb21DYW1lcmEoc3RhdGUsIHZpZXdwb3J0RGltZW5zaW9ucywgZ3JhcGhEaW1lbnNpb25zLCBwYWRkaW5nLCBpbnZlcnNlKSB7XG4gIC8vIFRPRE86IGl0J3MgcG9zc2libGUgdG8gb3B0aW1pemUgdGhpcyBkcmFzdGljYWxseSFcbiAgdmFyIGFuZ2xlID0gc3RhdGUuYW5nbGUsXG4gICAgcmF0aW8gPSBzdGF0ZS5yYXRpbyxcbiAgICB4ID0gc3RhdGUueCxcbiAgICB5ID0gc3RhdGUueTtcbiAgdmFyIHdpZHRoID0gdmlld3BvcnREaW1lbnNpb25zLndpZHRoLFxuICAgIGhlaWdodCA9IHZpZXdwb3J0RGltZW5zaW9ucy5oZWlnaHQ7XG4gIHZhciBtYXRyaXggPSBpZGVudGl0eSgpO1xuICB2YXIgc21hbGxlc3REaW1lbnNpb24gPSBNYXRoLm1pbih3aWR0aCwgaGVpZ2h0KSAtIDIgKiBwYWRkaW5nO1xuICB2YXIgY29ycmVjdGlvblJhdGlvID0gZ2V0Q29ycmVjdGlvblJhdGlvKHZpZXdwb3J0RGltZW5zaW9ucywgZ3JhcGhEaW1lbnNpb25zKTtcbiAgaWYgKCFpbnZlcnNlKSB7XG4gICAgbXVsdGlwbHkobWF0cml4LCBzY2FsZShpZGVudGl0eSgpLCAyICogKHNtYWxsZXN0RGltZW5zaW9uIC8gd2lkdGgpICogY29ycmVjdGlvblJhdGlvLCAyICogKHNtYWxsZXN0RGltZW5zaW9uIC8gaGVpZ2h0KSAqIGNvcnJlY3Rpb25SYXRpbykpO1xuICAgIG11bHRpcGx5KG1hdHJpeCwgcm90YXRlKGlkZW50aXR5KCksIC1hbmdsZSkpO1xuICAgIG11bHRpcGx5KG1hdHJpeCwgc2NhbGUoaWRlbnRpdHkoKSwgMSAvIHJhdGlvKSk7XG4gICAgbXVsdGlwbHkobWF0cml4LCB0cmFuc2xhdGUoaWRlbnRpdHkoKSwgLXgsIC15KSk7XG4gIH0gZWxzZSB7XG4gICAgbXVsdGlwbHkobWF0cml4LCB0cmFuc2xhdGUoaWRlbnRpdHkoKSwgeCwgeSkpO1xuICAgIG11bHRpcGx5KG1hdHJpeCwgc2NhbGUoaWRlbnRpdHkoKSwgcmF0aW8pKTtcbiAgICBtdWx0aXBseShtYXRyaXgsIHJvdGF0ZShpZGVudGl0eSgpLCBhbmdsZSkpO1xuICAgIG11bHRpcGx5KG1hdHJpeCwgc2NhbGUoaWRlbnRpdHkoKSwgd2lkdGggLyBzbWFsbGVzdERpbWVuc2lvbiAvIDIgLyBjb3JyZWN0aW9uUmF0aW8sIGhlaWdodCAvIHNtYWxsZXN0RGltZW5zaW9uIC8gMiAvIGNvcnJlY3Rpb25SYXRpbykpO1xuICB9XG4gIHJldHVybiBtYXRyaXg7XG59XG5cbi8qKlxuICogQWxsIHRoZXNlIHRyYW5zZm9ybWF0aW9ucyB3ZSBhcHBseSBvbiB0aGUgbWF0cml4IHRvIGdldCBpdCByZXNjYWxlIHRoZSBncmFwaFxuICogYXMgd2Ugd2FudCBtYWtlIGl0IHZlcnkgaGFyZCB0byBnZXQgcGl4ZWwtcGVyZmVjdCBkaXN0YW5jZXMgaW4gV2ViR0wuIFRoaXNcbiAqIGZ1bmN0aW9uIHJldHVybnMgYSBmYWN0b3IgdGhhdCBwcm9wZXJseSBjYW5jZWxzIHRoZSBtYXRyaXggZWZmZWN0IG9uIGxlbmd0aHMuXG4gKlxuICogW2phY29teWFsXVxuICogVG8gYmUgZnVsbHkgaG9uZXN0LCBJIGNhbid0IHJlYWxseSBleHBsYWluIGhhcHBlbnMgaGVyZS4uLiBJIG5vdGljZSB0aGF0IHRoZVxuICogZm9sbG93aW5nIHJhdGlvIHdvcmtzIChpLmUuIGl0IGNvcnJlY3RseSBjb21wZW5zYXRlcyB0aGUgbWF0cml4IGltcGFjdCBvbiBhbGxcbiAqIGNhbWVyYSBzdGF0ZXMgSSBjb3VsZCB0cnkpOlxuICogPiBgUiA9IHNpemUoVikgLyBzaXplKE0gKiBWKSAvIFdgXG4gKiBhcyBsb25nIGFzIGBNICogVmAgaXMgaW4gdGhlIGRpcmVjdGlvbiBvZiBXIChpZS4gcGFyYWxsZWwgdG8gKE94KSkuIEl0IHdvcmtzXG4gKiBhcyB3ZWxsIHdpdGggSCBhbmQgYSB2ZWN0b3IgdGhhdCB0cmFuc2Zvcm1zIGludG8gc29tZXRoaW5nIHBhcmFsbGVsIHRvIChPeSkuXG4gKlxuICogQWxzbywgbm90ZSB0aGF0IHdlIHVzZSBgYW5nbGVgIGFuZCBub3QgYC1hbmdsZWAgKHRoYXQgd291bGQgc2VlbSBsb2dpY2FsLFxuICogc2luY2Ugd2Ugd2FudCB0byBhbnRpY2lwYXRlIHRoZSByb3RhdGlvbiksIGJlY2F1c2UgdGhlIGltYWdlIGlzIHZlcnRpY2FsbHlcbiAqIHN3YXBwZWQgaW4gV2ViR0wuXG4gKi9cbmZ1bmN0aW9uIGdldE1hdHJpeEltcGFjdChtYXRyaXgsIGNhbWVyYVN0YXRlLCB2aWV3cG9ydERpbWVuc2lvbnMpIHtcbiAgdmFyIF9tdWx0aXBseVZlYyA9IG11bHRpcGx5VmVjMihtYXRyaXgsIHtcbiAgICAgIHg6IE1hdGguY29zKGNhbWVyYVN0YXRlLmFuZ2xlKSxcbiAgICAgIHk6IE1hdGguc2luKGNhbWVyYVN0YXRlLmFuZ2xlKVxuICAgIH0sIDApLFxuICAgIHggPSBfbXVsdGlwbHlWZWMueCxcbiAgICB5ID0gX211bHRpcGx5VmVjLnk7XG4gIHJldHVybiAxIC8gTWF0aC5zcXJ0KE1hdGgucG93KHgsIDIpICsgTWF0aC5wb3coeSwgMikpIC8gdmlld3BvcnREaW1lbnNpb25zLndpZHRoO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybmluZyB0aGUgZ3JhcGgncyBub2RlIGV4dGVudCBpbiB4ICYgeS5cbiAqL1xuZnVuY3Rpb24gZ3JhcGhFeHRlbnQoZ3JhcGgpIHtcbiAgaWYgKCFncmFwaC5vcmRlcikgcmV0dXJuIHtcbiAgICB4OiBbMCwgMV0sXG4gICAgeTogWzAsIDFdXG4gIH07XG4gIHZhciB4TWluID0gSW5maW5pdHk7XG4gIHZhciB4TWF4ID0gLUluZmluaXR5O1xuICB2YXIgeU1pbiA9IEluZmluaXR5O1xuICB2YXIgeU1heCA9IC1JbmZpbml0eTtcbiAgZ3JhcGguZm9yRWFjaE5vZGUoZnVuY3Rpb24gKF8sIGF0dHIpIHtcbiAgICB2YXIgeCA9IGF0dHIueCxcbiAgICAgIHkgPSBhdHRyLnk7XG4gICAgaWYgKHggPCB4TWluKSB4TWluID0geDtcbiAgICBpZiAoeCA+IHhNYXgpIHhNYXggPSB4O1xuICAgIGlmICh5IDwgeU1pbikgeU1pbiA9IHk7XG4gICAgaWYgKHkgPiB5TWF4KSB5TWF4ID0geTtcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgeDogW3hNaW4sIHhNYXhdLFxuICAgIHk6IFt5TWluLCB5TWF4XVxuICB9O1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHRoZSBncmFwaCB2YXJpYWJsZSBpcyBhIHZhbGlkIGdyYXBoLCBhbmQgaWYgc2lnbWEgY2FuIHJlbmRlciBpdC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVHcmFwaChncmFwaCkge1xuICAvLyBjaGVjayBpZiBpdCdzIGEgdmFsaWQgZ3JhcGhvbG9neSBpbnN0YW5jZVxuICBpZiAoIWlzR3JhcGgoZ3JhcGgpKSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogaW52YWxpZCBncmFwaCBpbnN0YW5jZS5cIik7XG5cbiAgLy8gY2hlY2sgaWYgbm9kZXMgaGF2ZSB4L3kgYXR0cmlidXRlc1xuICBncmFwaC5mb3JFYWNoTm9kZShmdW5jdGlvbiAoa2V5LCBhdHRyaWJ1dGVzKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYXR0cmlidXRlcy54KSB8fCAhTnVtYmVyLmlzRmluaXRlKGF0dHJpYnV0ZXMueSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBDb29yZGluYXRlcyBvZiBub2RlIFwiLmNvbmNhdChrZXksIFwiIGFyZSBpbnZhbGlkLiBBIG5vZGUgbXVzdCBoYXZlIGEgbnVtZXJpYyAneCcgYW5kICd5JyBhdHRyaWJ1dGUuXCIpKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHVzZWQgdG8gY3JlYXRlIERPTSBlbGVtZW50cyBlYXNpbHkuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQodGFnLCBzdHlsZSwgYXR0cmlidXRlcykge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGFnKTtcbiAgaWYgKHN0eWxlKSB7XG4gICAgZm9yICh2YXIgayBpbiBzdHlsZSkge1xuICAgICAgZWxlbWVudC5zdHlsZVtrXSA9IHN0eWxlW2tdO1xuICAgIH1cbiAgfVxuICBpZiAoYXR0cmlidXRlcykge1xuICAgIGZvciAodmFyIF9rIGluIGF0dHJpYnV0ZXMpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKF9rLCBhdHRyaWJ1dGVzW19rXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybmluZyB0aGUgYnJvd3NlcidzIHBpeGVsIHJhdGlvLlxuICovXG5mdW5jdGlvbiBnZXRQaXhlbFJhdGlvKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICE9PSBcInVuZGVmaW5lZFwiKSByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIHJldHVybiAxO1xufVxuXG4vKipcbiAqIEZ1bmN0aW9uIG9yZGVyaW5nIHRoZSBnaXZlbiBlbGVtZW50cyBpbiByZXZlcnNlIHotb3JkZXIgc28gdGhleSBkcmF3blxuICogdGhlIGNvcnJlY3Qgd2F5LlxuICovXG5mdW5jdGlvbiB6SW5kZXhPcmRlcmluZyhfZXh0ZW50LCBnZXR0ZXIsIGVsZW1lbnRzKSB7XG4gIC8vIElmIGsgaXMgPiBuLCB3ZSdsbCB1c2UgYSBzdGFuZGFyZCBzb3J0XG4gIHJldHVybiBlbGVtZW50cy5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgdmFyIHpBID0gZ2V0dGVyKGEpIHx8IDAsXG4gICAgICB6QiA9IGdldHRlcihiKSB8fCAwO1xuICAgIGlmICh6QSA8IHpCKSByZXR1cm4gLTE7XG4gICAgaWYgKHpBID4gekIpIHJldHVybiAxO1xuICAgIHJldHVybiAwO1xuICB9KTtcblxuICAvLyBUT0RPOiBjb3VudGluZyBzb3J0IG9wdGltaXphdGlvblxufVxuXG4vKipcbiAqIEZhY3RvcnkgcmV0dXJuaW5nIGEgZnVuY3Rpb24gbm9ybWFsaXppbmcgdGhlIGdpdmVuIG5vZGUncyBwb3NpdGlvbiAmIHNpemUuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlTm9ybWFsaXphdGlvbkZ1bmN0aW9uKGV4dGVudCkge1xuICB2YXIgX2V4dGVudCR4ID0gX3NsaWNlZFRvQXJyYXkoZXh0ZW50LngsIDIpLFxuICAgIG1pblggPSBfZXh0ZW50JHhbMF0sXG4gICAgbWF4WCA9IF9leHRlbnQkeFsxXSxcbiAgICBfZXh0ZW50JHkgPSBfc2xpY2VkVG9BcnJheShleHRlbnQueSwgMiksXG4gICAgbWluWSA9IF9leHRlbnQkeVswXSxcbiAgICBtYXhZID0gX2V4dGVudCR5WzFdO1xuICB2YXIgcmF0aW8gPSBNYXRoLm1heChtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpLFxuICAgIGRYID0gKG1heFggKyBtaW5YKSAvIDIsXG4gICAgZFkgPSAobWF4WSArIG1pblkpIC8gMjtcbiAgaWYgKHJhdGlvID09PSAwIHx8IE1hdGguYWJzKHJhdGlvKSA9PT0gSW5maW5pdHkgfHwgaXNOYU4ocmF0aW8pKSByYXRpbyA9IDE7XG4gIGlmIChpc05hTihkWCkpIGRYID0gMDtcbiAgaWYgKGlzTmFOKGRZKSkgZFkgPSAwO1xuICB2YXIgZm4gPSBmdW5jdGlvbiBmbihkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IDAuNSArIChkYXRhLnggLSBkWCkgLyByYXRpbyxcbiAgICAgIHk6IDAuNSArIChkYXRhLnkgLSBkWSkgLyByYXRpb1xuICAgIH07XG4gIH07XG5cbiAgLy8gVE9ETzogcG9zc2liaWxpdHkgdG8gYXBwbHkgdGhpcyBpbiBiYXRjaCBvdmVyIGFycmF5IG9mIGluZGljZXNcbiAgZm4uYXBwbHlUbyA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGF0YS54ID0gMC41ICsgKGRhdGEueCAtIGRYKSAvIHJhdGlvO1xuICAgIGRhdGEueSA9IDAuNSArIChkYXRhLnkgLSBkWSkgLyByYXRpbztcbiAgfTtcbiAgZm4uaW52ZXJzZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGRYICsgcmF0aW8gKiAoZGF0YS54IC0gMC41KSxcbiAgICAgIHk6IGRZICsgcmF0aW8gKiAoZGF0YS55IC0gMC41KVxuICAgIH07XG4gIH07XG4gIGZuLnJhdGlvID0gcmF0aW87XG4gIHJldHVybiBmbjtcbn1cblxuZXhwb3J0IHsgQU5JTUFURV9ERUZBVUxUUyBhcyBBLCBjcmVhdGVFbGVtZW50IGFzIGEsIGdyYXBoRXh0ZW50IGFzIGIsIGNyZWF0ZU5vcm1hbGl6YXRpb25GdW5jdGlvbiBhcyBjLCBnZXRNYXRyaXhJbXBhY3QgYXMgZCwgZWFzaW5ncyBhcyBlLCBtdWx0aXBseVZlYzIgYXMgZiwgZ2V0UGl4ZWxSYXRpbyBhcyBnLCBhbmltYXRlTm9kZXMgYXMgaCwgaWRlbnRpdHkgYXMgaSwgZ2V0Q29ycmVjdGlvblJhdGlvIGFzIGosIHF1YWRyYXRpY091dCBhcyBrLCBsaW5lYXIgYXMgbCwgbWF0cml4RnJvbUNhbWVyYSBhcyBtLCBxdWFkcmF0aWNJbk91dCBhcyBuLCBjdWJpY0luIGFzIG8sIGN1YmljT3V0IGFzIHAsIHF1YWRyYXRpY0luIGFzIHEsIGN1YmljSW5PdXQgYXMgciwgc2NhbGUgYXMgcywgcm90YXRlIGFzIHQsIHRyYW5zbGF0ZSBhcyB1LCB2YWxpZGF0ZUdyYXBoIGFzIHYsIG11bHRpcGx5IGFzIHcsIHpJbmRleE9yZGVyaW5nIGFzIHogfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sigma/dist/normalization-8e7b2e97.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sigma/dist/sigma.esm.js":
/*!**********************************************!*\
  !*** ./node_modules/sigma/dist/sigma.esm.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Camera: () => (/* binding */ Camera),\n/* harmony export */   MouseCaptor: () => (/* binding */ MouseCaptor),\n/* harmony export */   Sigma: () => (/* binding */ Sigma$1),\n/* harmony export */   TouchCaptor: () => (/* binding */ TouchCaptor),\n/* harmony export */   \"default\": () => (/* binding */ Sigma)\n/* harmony export */ });\n/* harmony import */ var _inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./inherits-8fbdedb5.esm.js */ \"(ssr)/./node_modules/sigma/dist/inherits-8fbdedb5.esm.js\");\n/* harmony import */ var _index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./index-29acc883.esm.js */ \"(ssr)/./node_modules/sigma/dist/index-29acc883.esm.js\");\n/* harmony import */ var _types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../types/dist/sigma-types.esm.js */ \"(ssr)/./node_modules/sigma/types/dist/sigma-types.esm.js\");\n/* harmony import */ var _normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./normalization-8e7b2e97.esm.js */ \"(ssr)/./node_modules/sigma/dist/normalization-8e7b2e97.esm.js\");\n/* harmony import */ var _colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./colors-2f6d17f0.esm.js */ \"(ssr)/./node_modules/sigma/dist/colors-2f6d17f0.esm.js\");\n/* harmony import */ var _settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../settings/dist/sigma-settings.esm.js */ \"(ssr)/./node_modules/sigma/settings/dist/sigma-settings.esm.js\");\n/* harmony import */ var _data_31990a76_esm_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./data-31990a76.esm.js */ \"(ssr)/./node_modules/sigma/dist/data-31990a76.esm.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! graphology-utils/is-graph */ \"(ssr)/./node_modules/graphology-utils/is-graph.js\");\n/* harmony import */ var graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(graphology_utils_is_graph__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\n\n\n\n\n\n\n/**\n * Defaults.\n */\nvar DEFAULT_ZOOMING_RATIO = 1.5;\n\n/**\n * Event types.\n */\n/**\n * Camera class\n *\n * @constructor\n */\nvar Camera = /*#__PURE__*/function (_TypedEventEmitter) {\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(Camera, _TypedEventEmitter);\n  function Camera() {\n    var _this;\n    (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(this, Camera);\n    _this = (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, Camera);\n\n    // State\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"x\", 0.5);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"y\", 0.5);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"angle\", 0);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"ratio\", 1);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"minRatio\", null);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"maxRatio\", null);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"nextFrame\", null);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"previousState\", null);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"enabled\", true);\n    _this.previousState = _this.getState();\n    return _this;\n  }\n\n  /**\n   * Static method used to create a Camera object with a given state.\n   *\n   * @param state\n   * @return {Camera}\n   */\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.d)(Camera, [{\n    key: \"enable\",\n    value:\n    /**\n     * Method used to enable the camera.\n     *\n     * @return {Camera}\n     */\n    function enable() {\n      this.enabled = true;\n      return this;\n    }\n\n    /**\n     * Method used to disable the camera.\n     *\n     * @return {Camera}\n     */\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      this.enabled = false;\n      return this;\n    }\n\n    /**\n     * Method used to retrieve the camera's current state.\n     *\n     * @return {object}\n     */\n  }, {\n    key: \"getState\",\n    value: function getState() {\n      return {\n        x: this.x,\n        y: this.y,\n        angle: this.angle,\n        ratio: this.ratio\n      };\n    }\n\n    /**\n     * Method used to check whether the camera has the given state.\n     *\n     * @return {object}\n     */\n  }, {\n    key: \"hasState\",\n    value: function hasState(state) {\n      return this.x === state.x && this.y === state.y && this.ratio === state.ratio && this.angle === state.angle;\n    }\n\n    /**\n     * Method used to retrieve the camera's previous state.\n     *\n     * @return {object}\n     */\n  }, {\n    key: \"getPreviousState\",\n    value: function getPreviousState() {\n      var state = this.previousState;\n      if (!state) return null;\n      return {\n        x: state.x,\n        y: state.y,\n        angle: state.angle,\n        ratio: state.ratio\n      };\n    }\n\n    /**\n     * Method used to check minRatio and maxRatio values.\n     *\n     * @param ratio\n     * @return {number}\n     */\n  }, {\n    key: \"getBoundedRatio\",\n    value: function getBoundedRatio(ratio) {\n      var r = ratio;\n      if (typeof this.minRatio === \"number\") r = Math.max(r, this.minRatio);\n      if (typeof this.maxRatio === \"number\") r = Math.min(r, this.maxRatio);\n      return r;\n    }\n\n    /**\n     * Method used to check various things to return a legit state candidate.\n     *\n     * @param state\n     * @return {object}\n     */\n  }, {\n    key: \"validateState\",\n    value: function validateState(state) {\n      var validatedState = {};\n      if (typeof state.x === \"number\") validatedState.x = state.x;\n      if (typeof state.y === \"number\") validatedState.y = state.y;\n      if (typeof state.angle === \"number\") validatedState.angle = state.angle;\n      if (typeof state.ratio === \"number\") validatedState.ratio = this.getBoundedRatio(state.ratio);\n      return validatedState;\n    }\n\n    /**\n     * Method used to check whether the camera is currently being animated.\n     *\n     * @return {boolean}\n     */\n  }, {\n    key: \"isAnimated\",\n    value: function isAnimated() {\n      return !!this.nextFrame;\n    }\n\n    /**\n     * Method used to set the camera's state.\n     *\n     * @param  {object} state - New state.\n     * @return {Camera}\n     */\n  }, {\n    key: \"setState\",\n    value: function setState(state) {\n      if (!this.enabled) return this;\n\n      // TODO: update by function\n\n      // Keeping track of last state\n      this.previousState = this.getState();\n      var validState = this.validateState(state);\n      if (typeof validState.x === \"number\") this.x = validState.x;\n      if (typeof validState.y === \"number\") this.y = validState.y;\n      if (typeof validState.angle === \"number\") this.angle = validState.angle;\n      if (typeof validState.ratio === \"number\") this.ratio = validState.ratio;\n\n      // Emitting\n      if (!this.hasState(this.previousState)) this.emit(\"updated\", this.getState());\n      return this;\n    }\n\n    /**\n     * Method used to update the camera's state using a function.\n     *\n     * @param  {function} updater - Updated function taking current state and\n     *                              returning next state.\n     * @return {Camera}\n     */\n  }, {\n    key: \"updateState\",\n    value: function updateState(updater) {\n      this.setState(updater(this.getState()));\n      return this;\n    }\n\n    /**\n     * Method used to animate the camera.\n     *\n     * @param  {object}                    state      - State to reach eventually.\n     * @param  {object}                    opts       - Options:\n     * @param  {number}                      duration - Duration of the animation.\n     * @param  {string | number => number}   easing   - Easing function or name of an existing one\n     * @param  {function}                  callback   - Callback\n     */\n  }, {\n    key: \"animate\",\n    value: function animate(state, opts, callback) {\n      var _this2 = this;\n      if (!this.enabled) return;\n      var options = Object.assign({}, _normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.A, opts);\n      var validState = this.validateState(state);\n      var easing = typeof options.easing === \"function\" ? options.easing : _normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.e[options.easing];\n\n      // State\n      var start = Date.now(),\n        initialState = this.getState();\n\n      // Function performing the animation\n      var fn = function fn() {\n        var t = (Date.now() - start) / options.duration;\n\n        // The animation is over:\n        if (t >= 1) {\n          _this2.nextFrame = null;\n          _this2.setState(validState);\n          if (_this2.animationCallback) {\n            _this2.animationCallback.call(null);\n            _this2.animationCallback = undefined;\n          }\n          return;\n        }\n        var coefficient = easing(t);\n        var newState = {};\n        if (typeof validState.x === \"number\") newState.x = initialState.x + (validState.x - initialState.x) * coefficient;\n        if (typeof validState.y === \"number\") newState.y = initialState.y + (validState.y - initialState.y) * coefficient;\n        if (typeof validState.angle === \"number\") newState.angle = initialState.angle + (validState.angle - initialState.angle) * coefficient;\n        if (typeof validState.ratio === \"number\") newState.ratio = initialState.ratio + (validState.ratio - initialState.ratio) * coefficient;\n        _this2.setState(newState);\n        _this2.nextFrame = requestAnimationFrame(fn);\n      };\n      if (this.nextFrame) {\n        cancelAnimationFrame(this.nextFrame);\n        if (this.animationCallback) this.animationCallback.call(null);\n        this.nextFrame = requestAnimationFrame(fn);\n      } else {\n        fn();\n      }\n      this.animationCallback = callback;\n    }\n\n    /**\n     * Method used to zoom the camera.\n     *\n     * @param  {number|object} factorOrOptions - Factor or options.\n     * @return {function}\n     */\n  }, {\n    key: \"animatedZoom\",\n    value: function animatedZoom(factorOrOptions) {\n      if (!factorOrOptions) {\n        this.animate({\n          ratio: this.ratio / DEFAULT_ZOOMING_RATIO\n        });\n      } else {\n        if (typeof factorOrOptions === \"number\") return this.animate({\n          ratio: this.ratio / factorOrOptions\n        });else this.animate({\n          ratio: this.ratio / (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n        }, factorOrOptions);\n      }\n    }\n\n    /**\n     * Method used to unzoom the camera.\n     *\n     * @param  {number|object} factorOrOptions - Factor or options.\n     */\n  }, {\n    key: \"animatedUnzoom\",\n    value: function animatedUnzoom(factorOrOptions) {\n      if (!factorOrOptions) {\n        this.animate({\n          ratio: this.ratio * DEFAULT_ZOOMING_RATIO\n        });\n      } else {\n        if (typeof factorOrOptions === \"number\") return this.animate({\n          ratio: this.ratio * factorOrOptions\n        });else this.animate({\n          ratio: this.ratio * (factorOrOptions.factor || DEFAULT_ZOOMING_RATIO)\n        }, factorOrOptions);\n      }\n    }\n\n    /**\n     * Method used to reset the camera.\n     *\n     * @param  {object} options - Options.\n     */\n  }, {\n    key: \"animatedReset\",\n    value: function animatedReset(options) {\n      this.animate({\n        x: 0.5,\n        y: 0.5,\n        ratio: 1,\n        angle: 0\n      }, options);\n    }\n\n    /**\n     * Returns a new Camera instance, with the same state as the current camera.\n     *\n     * @return {Camera}\n     */\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      return Camera.from(this.getState());\n    }\n  }], [{\n    key: \"from\",\n    value: function from(state) {\n      var camera = new Camera();\n      return camera.setState(state);\n    }\n  }]);\n  return Camera;\n}(_types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter);\n\n/**\n * Captor utils functions\n * ======================\n */\n\n/**\n * Extract the local X and Y coordinates from a mouse event or touch object. If\n * a DOM element is given, it uses this element's offset to compute the position\n * (this allows using events that are not bound to the container itself and\n * still have a proper position).\n *\n * @param  {event}       e - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {number}      The local Y value of the mouse.\n */\nfunction getPosition(e, dom) {\n  var bbox = dom.getBoundingClientRect();\n  return {\n    x: e.clientX - bbox.left,\n    y: e.clientY - bbox.top\n  };\n}\n\n/**\n * Convert mouse coords to sigma coords.\n *\n * @param  {event}       e   - A mouse event or touch object.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getMouseCoords(e, dom) {\n  var res = (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, getPosition(e, dom)), {}, {\n    sigmaDefaultPrevented: false,\n    preventSigmaDefault: function preventSigmaDefault() {\n      res.sigmaDefaultPrevented = true;\n    },\n    original: e\n  });\n  return res;\n}\n\n/**\n * Convert mouse wheel event coords to sigma coords.\n *\n * @param  {event}       e   - A wheel mouse event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getWheelCoords(e, dom) {\n  return (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, getMouseCoords(e, dom)), {}, {\n    delta: getWheelDelta(e)\n  });\n}\nvar MAX_TOUCHES = 2;\nfunction getTouchesArray(touches) {\n  var arr = [];\n  for (var i = 0, l = Math.min(touches.length, MAX_TOUCHES); i < l; i++) arr.push(touches[i]);\n  return arr;\n}\n\n/**\n * Convert touch coords to sigma coords.\n *\n * @param  {event}       e   - A touch event.\n * @param  {HTMLElement} dom - A DOM element to compute offset relatively to.\n * @return {object}\n */\nfunction getTouchCoords(e, dom) {\n  return {\n    touches: getTouchesArray(e.touches).map(function (touch) {\n      return getPosition(touch, dom);\n    }),\n    original: e\n  };\n}\n\n/**\n * Extract the wheel delta from a mouse event or touch object.\n *\n * @param  {event}  e - A mouse event or touch object.\n * @return {number}     The wheel delta of the mouse.\n */\nfunction getWheelDelta(e) {\n  // TODO: check those ratios again to ensure a clean Chrome/Firefox compat\n  if (typeof e.deltaY !== \"undefined\") return e.deltaY * -3 / 360;\n  if (typeof e.detail !== \"undefined\") return e.detail / -9;\n  throw new Error(\"Captor: could not extract delta from event.\");\n}\n\n/**\n * Abstract class representing a captor like the user's mouse or touch controls.\n */\nvar Captor = /*#__PURE__*/function (_TypedEventEmitter) {\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(Captor, _TypedEventEmitter);\n  function Captor(container, renderer) {\n    var _this;\n    (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(this, Captor);\n    _this = (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, Captor);\n    // Properties\n    _this.container = container;\n    _this.renderer = renderer;\n    return _this;\n  }\n  return (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.d)(Captor);\n}(_types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter);\n\n/**\n * Constants.\n */\nvar DRAG_TIMEOUT$1 = 100;\nvar DRAGGED_EVENTS_TOLERANCE = 3;\nvar MOUSE_INERTIA_DURATION = 200;\nvar MOUSE_INERTIA_RATIO = 3;\nvar MOUSE_ZOOM_DURATION = 250;\nvar ZOOMING_RATIO = 1.7;\nvar DOUBLE_CLICK_TIMEOUT = 300;\nvar DOUBLE_CLICK_ZOOMING_RATIO = 2.2;\nvar DOUBLE_CLICK_ZOOMING_DURATION = 200;\n\n/**\n * Event types.\n */\n/**\n * Mouse captor class.\n *\n * @constructor\n */\nvar MouseCaptor = /*#__PURE__*/function (_Captor) {\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(MouseCaptor, _Captor);\n  function MouseCaptor(container, renderer) {\n    var _this;\n    (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(this, MouseCaptor);\n    _this = (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, MouseCaptor, [container, renderer]);\n\n    // Binding methods\n    // State\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"enabled\", true);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"draggedEvents\", 0);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"downStartTime\", null);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"lastMouseX\", null);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"lastMouseY\", null);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"isMouseDown\", false);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"isMoving\", false);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"movingTimeout\", null);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"startCameraState\", null);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"clicks\", 0);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"doubleClickTimeout\", null);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"currentWheelDirection\", 0);\n    _this.handleClick = _this.handleClick.bind((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this));\n    _this.handleRightClick = _this.handleRightClick.bind((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this));\n    _this.handleDown = _this.handleDown.bind((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this));\n    _this.handleUp = _this.handleUp.bind((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this));\n    _this.handleMove = _this.handleMove.bind((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this));\n    _this.handleWheel = _this.handleWheel.bind((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this));\n    _this.handleLeave = _this.handleLeave.bind((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this));\n    _this.handleEnter = _this.handleEnter.bind((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this));\n\n    // Binding events\n    container.addEventListener(\"click\", _this.handleClick, false);\n    container.addEventListener(\"contextmenu\", _this.handleRightClick, false);\n    container.addEventListener(\"mousedown\", _this.handleDown, false);\n    container.addEventListener(\"wheel\", _this.handleWheel, false);\n    container.addEventListener(\"mouseleave\", _this.handleLeave, false);\n    container.addEventListener(\"mouseenter\", _this.handleEnter, false);\n    document.addEventListener(\"mousemove\", _this.handleMove, false);\n    document.addEventListener(\"mouseup\", _this.handleUp, false);\n    return _this;\n  }\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.d)(MouseCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener(\"click\", this.handleClick);\n      container.removeEventListener(\"contextmenu\", this.handleRightClick);\n      container.removeEventListener(\"mousedown\", this.handleDown);\n      container.removeEventListener(\"wheel\", this.handleWheel);\n      container.removeEventListener(\"mouseleave\", this.handleLeave);\n      container.removeEventListener(\"mouseenter\", this.handleEnter);\n      document.removeEventListener(\"mousemove\", this.handleMove);\n      document.removeEventListener(\"mouseup\", this.handleUp);\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(e) {\n      var _this2 = this;\n      if (!this.enabled) return;\n      this.clicks++;\n      if (this.clicks === 2) {\n        this.clicks = 0;\n        if (typeof this.doubleClickTimeout === \"number\") {\n          clearTimeout(this.doubleClickTimeout);\n          this.doubleClickTimeout = null;\n        }\n        return this.handleDoubleClick(e);\n      }\n      setTimeout(function () {\n        _this2.clicks = 0;\n        _this2.doubleClickTimeout = null;\n      }, DOUBLE_CLICK_TIMEOUT);\n\n      // NOTE: this is here to prevent click events on drag\n      if (this.draggedEvents < DRAGGED_EVENTS_TOLERANCE) this.emit(\"click\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleRightClick\",\n    value: function handleRightClick(e) {\n      if (!this.enabled) return;\n      this.emit(\"rightClick\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleDoubleClick\",\n    value: function handleDoubleClick(e) {\n      if (!this.enabled) return;\n      e.preventDefault();\n      e.stopPropagation();\n      var mouseCoords = getMouseCoords(e, this.container);\n      this.emit(\"doubleClick\", mouseCoords);\n      if (mouseCoords.sigmaDefaultPrevented) return;\n\n      // default behavior\n      var camera = this.renderer.getCamera();\n      var newRatio = camera.getBoundedRatio(camera.getState().ratio / DOUBLE_CLICK_ZOOMING_RATIO);\n      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n        easing: \"quadraticInOut\",\n        duration: DOUBLE_CLICK_ZOOMING_DURATION\n      });\n    }\n  }, {\n    key: \"handleDown\",\n    value: function handleDown(e) {\n      if (!this.enabled) return;\n\n      // We only start dragging on left button\n      if (e.button === 0) {\n        this.startCameraState = this.renderer.getCamera().getState();\n        var _getPosition = getPosition(e, this.container),\n          x = _getPosition.x,\n          y = _getPosition.y;\n        this.lastMouseX = x;\n        this.lastMouseY = y;\n        this.draggedEvents = 0;\n        this.downStartTime = Date.now();\n        this.isMouseDown = true;\n      }\n      this.emit(\"mousedown\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleUp\",\n    value: function handleUp(e) {\n      var _this3 = this;\n      if (!this.enabled || !this.isMouseDown) return;\n      var camera = this.renderer.getCamera();\n      this.isMouseDown = false;\n      if (typeof this.movingTimeout === \"number\") {\n        clearTimeout(this.movingTimeout);\n        this.movingTimeout = null;\n      }\n      var _getPosition2 = getPosition(e, this.container),\n        x = _getPosition2.x,\n        y = _getPosition2.y;\n      var cameraState = camera.getState(),\n        previousCameraState = camera.getPreviousState() || {\n          x: 0,\n          y: 0\n        };\n      if (this.isMoving) {\n        camera.animate({\n          x: cameraState.x + MOUSE_INERTIA_RATIO * (cameraState.x - previousCameraState.x),\n          y: cameraState.y + MOUSE_INERTIA_RATIO * (cameraState.y - previousCameraState.y)\n        }, {\n          duration: MOUSE_INERTIA_DURATION,\n          easing: \"quadraticOut\"\n        });\n      } else if (this.lastMouseX !== x || this.lastMouseY !== y) {\n        camera.setState({\n          x: cameraState.x,\n          y: cameraState.y\n        });\n      }\n      this.isMoving = false;\n      setTimeout(function () {\n        var shouldRefresh = _this3.draggedEvents > 0;\n        _this3.draggedEvents = 0;\n\n        // NOTE: this refresh is here to make sure `hideEdgesOnMove` can work\n        // when someone releases camera pan drag after having stopped moving.\n        // See commit: https://github.com/jacomyal/sigma.js/commit/cfd9197f70319109db6b675dd7c82be493ca95a2\n        // See also issue: https://github.com/jacomyal/sigma.js/issues/1290\n        // It could be possible to render instead of scheduling a refresh but for\n        // now it seems good enough.\n        if (shouldRefresh) _this3.renderer.refresh();\n      }, 0);\n      this.emit(\"mouseup\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this4 = this;\n      if (!this.enabled) return;\n      var mouseCoords = getMouseCoords(e, this.container);\n\n      // Always trigger a \"mousemovebody\" event, so that it is possible to develop\n      // a drag-and-drop effect that works even when the mouse is out of the\n      // container:\n      this.emit(\"mousemovebody\", mouseCoords);\n\n      // Only trigger the \"mousemove\" event when the mouse is actually hovering\n      // the container, to avoid weirdly hovering nodes and/or edges when the\n      // mouse is not hover the container:\n      if (e.target === this.container) {\n        this.emit(\"mousemove\", mouseCoords);\n      }\n      if (mouseCoords.sigmaDefaultPrevented) return;\n\n      // Handle the case when \"isMouseDown\" all the time, to allow dragging the\n      // stage while the mouse is not hover the container:\n      if (this.isMouseDown) {\n        this.isMoving = true;\n        this.draggedEvents++;\n        if (typeof this.movingTimeout === \"number\") {\n          clearTimeout(this.movingTimeout);\n        }\n        this.movingTimeout = window.setTimeout(function () {\n          _this4.movingTimeout = null;\n          _this4.isMoving = false;\n        }, DRAG_TIMEOUT$1);\n        var camera = this.renderer.getCamera();\n        var _getPosition3 = getPosition(e, this.container),\n          eX = _getPosition3.x,\n          eY = _getPosition3.y;\n        var lastMouse = this.renderer.viewportToFramedGraph({\n          x: this.lastMouseX,\n          y: this.lastMouseY\n        });\n        var mouse = this.renderer.viewportToFramedGraph({\n          x: eX,\n          y: eY\n        });\n        var offsetX = lastMouse.x - mouse.x,\n          offsetY = lastMouse.y - mouse.y;\n        var cameraState = camera.getState();\n        var x = cameraState.x + offsetX,\n          y = cameraState.y + offsetY;\n        camera.setState({\n          x: x,\n          y: y\n        });\n        this.lastMouseX = eX;\n        this.lastMouseY = eY;\n        e.preventDefault();\n        e.stopPropagation();\n      }\n    }\n  }, {\n    key: \"handleLeave\",\n    value: function handleLeave(e) {\n      this.emit(\"mouseleave\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleEnter\",\n    value: function handleEnter(e) {\n      this.emit(\"mouseenter\", getMouseCoords(e, this.container));\n    }\n  }, {\n    key: \"handleWheel\",\n    value: function handleWheel(e) {\n      var _this5 = this;\n      if (!this.enabled) return;\n      e.preventDefault();\n      e.stopPropagation();\n      var delta = getWheelDelta(e);\n      if (!delta) return;\n      var wheelCoords = getWheelCoords(e, this.container);\n      this.emit(\"wheel\", wheelCoords);\n      if (wheelCoords.sigmaDefaultPrevented) return;\n\n      // Default behavior\n      var ratioDiff = delta > 0 ? 1 / ZOOMING_RATIO : ZOOMING_RATIO;\n      var camera = this.renderer.getCamera();\n      var newRatio = camera.getBoundedRatio(camera.getState().ratio * ratioDiff);\n      var wheelDirection = delta > 0 ? 1 : -1;\n      var now = Date.now();\n\n      // Cancel events that are too close too each other and in the same direction:\n      if (this.currentWheelDirection === wheelDirection && this.lastWheelTriggerTime && now - this.lastWheelTriggerTime < MOUSE_ZOOM_DURATION / 5) {\n        return;\n      }\n      camera.animate(this.renderer.getViewportZoomedState(getPosition(e, this.container), newRatio), {\n        easing: \"quadraticOut\",\n        duration: MOUSE_ZOOM_DURATION\n      }, function () {\n        _this5.currentWheelDirection = 0;\n      });\n      this.currentWheelDirection = wheelDirection;\n      this.lastWheelTriggerTime = now;\n    }\n  }]);\n  return MouseCaptor;\n}(Captor);\n\nvar DRAG_TIMEOUT = 200;\nvar TOUCH_INERTIA_RATIO = 3;\nvar TOUCH_INERTIA_DURATION = 200;\n\n/**\n * Event types.\n */\n/**\n * Touch captor class.\n *\n * @constructor\n */\nvar TouchCaptor = /*#__PURE__*/function (_Captor) {\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(TouchCaptor, _Captor);\n  function TouchCaptor(container, renderer) {\n    var _this;\n    (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(this, TouchCaptor);\n    _this = (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, TouchCaptor, [container, renderer]);\n\n    // Binding methods:\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"enabled\", true);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"isMoving\", false);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"hasMoved\", false);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"touchMode\", 0);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"startTouchesPositions\", []);\n    _this.handleStart = _this.handleStart.bind((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this));\n    _this.handleLeave = _this.handleLeave.bind((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this));\n    _this.handleMove = _this.handleMove.bind((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this));\n\n    // Binding events\n    container.addEventListener(\"touchstart\", _this.handleStart, false);\n    container.addEventListener(\"touchend\", _this.handleLeave, false);\n    container.addEventListener(\"touchcancel\", _this.handleLeave, false);\n    container.addEventListener(\"touchmove\", _this.handleMove, false);\n    return _this;\n  }\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.d)(TouchCaptor, [{\n    key: \"kill\",\n    value: function kill() {\n      var container = this.container;\n      container.removeEventListener(\"touchstart\", this.handleStart);\n      container.removeEventListener(\"touchend\", this.handleLeave);\n      container.removeEventListener(\"touchcancel\", this.handleLeave);\n      container.removeEventListener(\"touchmove\", this.handleMove);\n    }\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return {\n        width: this.container.offsetWidth,\n        height: this.container.offsetHeight\n      };\n    }\n  }, {\n    key: \"dispatchRelatedMouseEvent\",\n    value: function dispatchRelatedMouseEvent(type, e, touch, emitter) {\n      var mousePosition = touch || e.touches[0];\n      var mouseEvent = new MouseEvent(type, {\n        clientX: mousePosition.clientX,\n        clientY: mousePosition.clientY,\n        altKey: e.altKey,\n        ctrlKey: e.ctrlKey\n      });\n      mouseEvent.isFakeSigmaMouseEvent = true;\n      (emitter || this.container).dispatchEvent(mouseEvent);\n    }\n  }, {\n    key: \"handleStart\",\n    value: function handleStart(e) {\n      var _this2 = this;\n      if (!this.enabled) return;\n\n      // Prevent default to avoid default browser behaviors...\n      e.preventDefault();\n      // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n      if (e.touches.length === 1) this.dispatchRelatedMouseEvent(\"mousedown\", e);\n      var touches = getTouchesArray(e.touches);\n      this.touchMode = touches.length;\n      this.startCameraState = this.renderer.getCamera().getState();\n      this.startTouchesPositions = touches.map(function (touch) {\n        return getPosition(touch, _this2.container);\n      });\n      this.lastTouches = touches;\n      this.lastTouchesPositions = this.startTouchesPositions;\n\n      // When there are two touches down, let's record distance and angle as well:\n      if (this.touchMode === 2) {\n        var _this$startTouchesPos = (0,_colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_7__._)(this.startTouchesPositions, 2),\n          _this$startTouchesPos2 = _this$startTouchesPos[0],\n          x0 = _this$startTouchesPos2.x,\n          y0 = _this$startTouchesPos2.y,\n          _this$startTouchesPos3 = _this$startTouchesPos[1],\n          x1 = _this$startTouchesPos3.x,\n          y1 = _this$startTouchesPos3.y;\n        this.startTouchesAngle = Math.atan2(y1 - y0, x1 - x0);\n        this.startTouchesDistance = Math.sqrt(Math.pow(x1 - x0, 2) + Math.pow(y1 - y0, 2));\n      }\n      this.emit(\"touchdown\", getTouchCoords(e, this.container));\n    }\n  }, {\n    key: \"handleLeave\",\n    value: function handleLeave(e) {\n      if (!this.enabled) return;\n\n      // Prevent default to avoid default browser behaviors...\n      e.preventDefault();\n      // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n      if (e.touches.length === 0 && this.lastTouches && this.lastTouches.length) {\n        this.dispatchRelatedMouseEvent(\"mouseup\", e, this.lastTouches[0], document);\n        // ... and only click if no move was made\n        if (!this.hasMoved) {\n          this.dispatchRelatedMouseEvent(\"click\", e, this.lastTouches[0]);\n        }\n      }\n      if (this.movingTimeout) {\n        this.isMoving = false;\n        clearTimeout(this.movingTimeout);\n      }\n      switch (this.touchMode) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        case 2:\n          if (e.touches.length === 1) {\n            this.handleStart(e);\n            e.preventDefault();\n            break;\n          }\n        /* falls through */\n        case 1:\n          // TODO\n          // Dispatch event\n\n          if (this.isMoving) {\n            var camera = this.renderer.getCamera();\n            var cameraState = camera.getState(),\n              previousCameraState = camera.getPreviousState() || {\n                x: 0,\n                y: 0\n              };\n            camera.animate({\n              x: cameraState.x + TOUCH_INERTIA_RATIO * (cameraState.x - previousCameraState.x),\n              y: cameraState.y + TOUCH_INERTIA_RATIO * (cameraState.y - previousCameraState.y)\n            }, {\n              duration: TOUCH_INERTIA_DURATION,\n              easing: \"quadraticOut\"\n            });\n          }\n          this.hasMoved = false;\n          this.isMoving = false;\n          this.touchMode = 0;\n          break;\n      }\n      this.emit(\"touchup\", getTouchCoords(e, this.container));\n    }\n  }, {\n    key: \"handleMove\",\n    value: function handleMove(e) {\n      var _this3 = this;\n      if (!this.enabled) return;\n\n      // Prevent default to avoid default browser behaviors...\n      e.preventDefault();\n      // ...but simulate mouse behavior anyway, to get the MouseCaptor working as well:\n      if (e.touches.length === 1) this.dispatchRelatedMouseEvent(\"mousemove\", e);\n      var touches = getTouchesArray(e.touches);\n      var touchesPositions = touches.map(function (touch) {\n        return getPosition(touch, _this3.container);\n      });\n      this.lastTouches = touches;\n      this.lastTouchesPositions = touchesPositions;\n\n      // If a move was initiated at some point and we get back to startpoint,\n      // we should still consider that we did move (which also happens after a\n      // multiple touch when only one touch remains in which case handleStart\n      // is recalled within handleLeave).\n      // Now, some mobile browsers report zero-distance moves so we also check that\n      // one of the touches did actually move from the origin position.\n      this.hasMoved || (this.hasMoved = touchesPositions.some(function (position, idx) {\n        var startPosition = _this3.startTouchesPositions[idx];\n        return position.x !== startPosition.x || position.y !== startPosition.y;\n      }));\n\n      // If there was no move, do not trigger touch moves behavior\n      if (!this.hasMoved) {\n        return;\n      }\n      this.isMoving = true;\n      if (this.movingTimeout) clearTimeout(this.movingTimeout);\n      this.movingTimeout = window.setTimeout(function () {\n        _this3.isMoving = false;\n      }, DRAG_TIMEOUT);\n      var camera = this.renderer.getCamera();\n      var startCameraState = this.startCameraState;\n      switch (this.touchMode) {\n        case 1:\n          {\n            var _this$renderer$viewpo = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0]),\n              xStart = _this$renderer$viewpo.x,\n              yStart = _this$renderer$viewpo.y;\n            var _this$renderer$viewpo2 = this.renderer.viewportToFramedGraph(touchesPositions[0]),\n              x = _this$renderer$viewpo2.x,\n              y = _this$renderer$viewpo2.y;\n            camera.setState({\n              x: startCameraState.x + xStart - x,\n              y: startCameraState.y + yStart - y\n            });\n            break;\n          }\n        case 2:\n          {\n            /**\n             * Here is the thinking here:\n             *\n             * 1. We can find the new angle and ratio, by comparing the vector from \"touch one\" to \"touch two\" at the start\n             *    of the d'n'd and now\n             *\n             * 2. We can use `Camera#viewportToGraph` inside formula to retrieve the new camera position, using the graph\n             *    position of a touch at the beginning of the d'n'd (using `startCamera.viewportToGraph`) and the viewport\n             *    position of this same touch now\n             */\n            var newCameraState = {};\n            var _touchesPositions$ = touchesPositions[0],\n              x0 = _touchesPositions$.x,\n              y0 = _touchesPositions$.y;\n            var _touchesPositions$2 = touchesPositions[1],\n              x1 = _touchesPositions$2.x,\n              y1 = _touchesPositions$2.y;\n            var angleDiff = Math.atan2(y1 - y0, x1 - x0) - this.startTouchesAngle;\n            var ratioDiff = Math.hypot(y1 - y0, x1 - x0) / this.startTouchesDistance;\n\n            // 1.\n            var newRatio = camera.getBoundedRatio(startCameraState.ratio / ratioDiff);\n            newCameraState.ratio = newRatio;\n            newCameraState.angle = startCameraState.angle + angleDiff;\n\n            // 2.\n            var dimensions = this.getDimensions();\n            var touchGraphPosition = this.renderer.viewportToFramedGraph((this.startTouchesPositions || [])[0], {\n              cameraState: startCameraState\n            });\n            var smallestDimension = Math.min(dimensions.width, dimensions.height);\n            var dx = smallestDimension / dimensions.width;\n            var dy = smallestDimension / dimensions.height;\n            var ratio = newRatio / smallestDimension;\n\n            // Align with center of the graph:\n            var _x = x0 - smallestDimension / 2 / dx;\n            var _y = y0 - smallestDimension / 2 / dy;\n\n            // Rotate:\n            var _ref = [_x * Math.cos(-newCameraState.angle) - _y * Math.sin(-newCameraState.angle), _y * Math.cos(-newCameraState.angle) + _x * Math.sin(-newCameraState.angle)];\n            _x = _ref[0];\n            _y = _ref[1];\n            newCameraState.x = touchGraphPosition.x - _x * ratio;\n            newCameraState.y = touchGraphPosition.y + _y * ratio;\n            camera.setState(newCameraState);\n            break;\n          }\n      }\n      this.emit(\"touchmove\", getTouchCoords(e, this.container));\n    }\n  }]);\n  return TouchCaptor;\n}(Captor);\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return (0,_colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_7__.a)(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || (0,_colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_7__.b)(arr) || _nonIterableSpread();\n}\n\n/**\n * Sigma.js Labels Heuristics\n * ===========================\n *\n * Miscellaneous heuristics related to label display.\n * @module\n */\n/**\n * Class representing a single candidate for the label grid selection.\n *\n * It also describes a deterministic way to compare two candidates to assess\n * which one is better.\n */\nvar LabelCandidate = /*#__PURE__*/function () {\n  function LabelCandidate(key, size) {\n    (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(this, LabelCandidate);\n    this.key = key;\n    this.size = size;\n  }\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.d)(LabelCandidate, null, [{\n    key: \"compare\",\n    value: function compare(first, second) {\n      // First we compare by size\n      if (first.size > second.size) return -1;\n      if (first.size < second.size) return 1;\n\n      // Then since no two nodes can have the same key, we use it to\n      // deterministically tie-break by key\n      if (first.key > second.key) return 1;\n\n      // NOTE: this comparator cannot return 0\n      return -1;\n    }\n  }]);\n  return LabelCandidate;\n}();\n/**\n * Class representing a 2D spatial grid divided into constant-size cells.\n */\nvar LabelGrid = /*#__PURE__*/function () {\n  function LabelGrid() {\n    (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(this, LabelGrid);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)(this, \"width\", 0);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)(this, \"height\", 0);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)(this, \"cellSize\", 0);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)(this, \"columns\", 0);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)(this, \"rows\", 0);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)(this, \"cells\", {});\n  }\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.d)(LabelGrid, [{\n    key: \"resizeAndClear\",\n    value: function resizeAndClear(dimensions, cellSize) {\n      this.width = dimensions.width;\n      this.height = dimensions.height;\n      this.cellSize = cellSize;\n      this.columns = Math.ceil(dimensions.width / cellSize);\n      this.rows = Math.ceil(dimensions.height / cellSize);\n      this.cells = {};\n    }\n  }, {\n    key: \"getIndex\",\n    value: function getIndex(pos) {\n      var xIndex = Math.floor(pos.x / this.cellSize);\n      var yIndex = Math.floor(pos.y / this.cellSize);\n      return yIndex * this.columns + xIndex;\n    }\n  }, {\n    key: \"add\",\n    value: function add(key, size, pos) {\n      var candidate = new LabelCandidate(key, size);\n      var index = this.getIndex(pos);\n      var cell = this.cells[index];\n      if (!cell) {\n        cell = [];\n        this.cells[index] = cell;\n      }\n      cell.push(candidate);\n    }\n  }, {\n    key: \"organize\",\n    value: function organize() {\n      for (var k in this.cells) {\n        var cell = this.cells[k];\n        cell.sort(LabelCandidate.compare);\n      }\n    }\n  }, {\n    key: \"getLabelsToDisplay\",\n    value: function getLabelsToDisplay(ratio, density) {\n      // TODO: work on visible nodes to optimize? ^ -> threshold outside so that memoization works?\n      // TODO: adjust threshold lower, but increase cells a bit?\n      // TODO: hunt for geom issue in disguise\n      // TODO: memoize while ratio does not move. method to force recompute\n      var cellArea = this.cellSize * this.cellSize;\n      var scaledCellArea = cellArea / ratio / ratio;\n      var scaledDensity = scaledCellArea * density / cellArea;\n      var labelsToDisplayPerCell = Math.ceil(scaledDensity);\n      var labels = [];\n      for (var k in this.cells) {\n        var cell = this.cells[k];\n        for (var i = 0; i < Math.min(labelsToDisplayPerCell, cell.length); i++) {\n          labels.push(cell[i].key);\n        }\n      }\n      return labels;\n    }\n  }]);\n  return LabelGrid;\n}();\n\n/**\n * Label heuristic selecting edge labels to display, based on displayed node\n * labels\n *\n * @param  {object} params                 - Parameters:\n * @param  {Set}      displayedNodeLabels  - Currently displayed node labels.\n * @param  {Set}      highlightedNodes     - Highlighted nodes.\n * @param  {Graph}    graph                - The rendered graph.\n * @param  {string}   hoveredNode          - Hovered node (optional)\n * @return {Array}                         - The selected labels.\n */\nfunction edgeLabelsToDisplayFromNodes(params) {\n  var graph = params.graph,\n    hoveredNode = params.hoveredNode,\n    highlightedNodes = params.highlightedNodes,\n    displayedNodeLabels = params.displayedNodeLabels;\n  var worthyEdges = [];\n\n  // TODO: the code below can be optimized using #.forEach and batching the code per adj\n\n  // We should display an edge's label if:\n  //   - Any of its extremities is highlighted or hovered\n  //   - Both of its extremities has its label shown\n  graph.forEachEdge(function (edge, _, source, target) {\n    if (source === hoveredNode || target === hoveredNode || highlightedNodes.has(source) || highlightedNodes.has(target) || displayedNodeLabels.has(source) && displayedNodeLabels.has(target)) {\n      worthyEdges.push(edge);\n    }\n  });\n  return worthyEdges;\n}\n\n/**\n * Constants.\n */\nvar X_LABEL_MARGIN = 150;\nvar Y_LABEL_MARGIN = 50;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\n/**\n * Important functions.\n */\nfunction applyNodeDefaults(settings, key, data) {\n  if (!hasOwnProperty.call(data, \"x\") || !hasOwnProperty.call(data, \"y\")) throw new Error(\"Sigma: could not find a valid position (x, y) for node \\\"\".concat(key, \"\\\". All your nodes must have a number \\\"x\\\" and \\\"y\\\". Maybe your forgot to apply a layout or your \\\"nodeReducer\\\" is not returning the correct data?\"));\n  if (!data.color) data.color = settings.defaultNodeColor;\n  if (!data.label && data.label !== \"\") data.label = null;\n  if (data.label !== undefined && data.label !== null) data.label = \"\" + data.label;else data.label = null;\n  if (!data.size) data.size = 2;\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n  if (!hasOwnProperty.call(data, \"highlighted\")) data.highlighted = false;\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultNodeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\nfunction applyEdgeDefaults(settings, _key, data) {\n  if (!data.color) data.color = settings.defaultEdgeColor;\n  if (!data.label) data.label = \"\";\n  if (!data.size) data.size = 0.5;\n  if (!hasOwnProperty.call(data, \"hidden\")) data.hidden = false;\n  if (!hasOwnProperty.call(data, \"forceLabel\")) data.forceLabel = false;\n  if (!data.type || data.type === \"\") data.type = settings.defaultEdgeType;\n  if (!data.zIndex) data.zIndex = 0;\n  return data;\n}\n\n/**\n * Main class.\n *\n * @constructor\n * @param {Graph}       graph     - Graph to render.\n * @param {HTMLElement} container - DOM container in which to render.\n * @param {object}      settings  - Optional settings.\n */\nvar Sigma$1 = /*#__PURE__*/function (_TypedEventEmitter) {\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__._)(Sigma, _TypedEventEmitter);\n  function Sigma(graph, container) {\n    var _this;\n    var settings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.a)(this, Sigma);\n    _this = (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.b)(this, Sigma);\n\n    // Resolving settings\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"elements\", {});\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"canvasContexts\", {});\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"webGLContexts\", {});\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"pickingLayers\", new Set());\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"textures\", {});\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"frameBuffers\", {});\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"activeListeners\", {});\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"labelGrid\", new LabelGrid());\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"nodeDataCache\", {});\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"edgeDataCache\", {});\n    // Indices to keep track of the index of the item inside programs\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"nodeProgramIndex\", {});\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"edgeProgramIndex\", {});\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"nodesWithForcedLabels\", new Set());\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"edgesWithForcedLabels\", new Set());\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"nodeExtent\", {\n      x: [0, 1],\n      y: [0, 1]\n    });\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"nodeZExtent\", [Infinity, -Infinity]);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"edgeZExtent\", [Infinity, -Infinity]);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"matrix\", (0,_normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.i)());\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"invMatrix\", (0,_normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.i)());\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"correctionRatio\", 1);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"customBBox\", null);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"normalizationFunction\", (0,_normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.c)({\n      x: [0, 1],\n      y: [0, 1]\n    }));\n    // Cache:\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"graphToViewportRatio\", 1);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"itemIDsIndex\", {});\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"nodeIndices\", {});\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"edgeIndices\", {});\n    // Starting dimensions and pixel ratio\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"width\", 0);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"height\", 0);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"pixelRatio\", (0,_normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.g)());\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"pickingDownSizingRatio\", 2 * _this.pixelRatio);\n    // Graph State\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"displayedNodeLabels\", new Set());\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"displayedEdgeLabels\", new Set());\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"highlightedNodes\", new Set());\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"hoveredNode\", null);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"hoveredEdge\", null);\n    // Internal states\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"renderFrame\", null);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"renderHighlightedNodesFrame\", null);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"needToProcess\", false);\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"checkEdgesEventsFrame\", null);\n    // Programs\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"nodePrograms\", {});\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"nodeHoverPrograms\", {});\n    (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__._)((0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this), \"edgePrograms\", {});\n    _this.settings = (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.resolveSettings)(settings);\n\n    // Validating\n    (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.validateSettings)(_this.settings);\n    (0,_normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.v)(graph);\n    if (!(container instanceof HTMLElement)) throw new Error(\"Sigma: container should be an html element.\");\n\n    // Properties\n    _this.graph = graph;\n    _this.container = container;\n\n    // Initializing contexts\n    _this.createWebGLContext(\"edges\", {\n      picking: settings.enableEdgeEvents\n    });\n    _this.createCanvasContext(\"edgeLabels\");\n    _this.createWebGLContext(\"nodes\", {\n      picking: true\n    });\n    _this.createCanvasContext(\"labels\");\n    _this.createCanvasContext(\"hovers\");\n    _this.createWebGLContext(\"hoverNodes\");\n    _this.createCanvasContext(\"mouse\");\n\n    // Initial resize\n    _this.resize();\n\n    // Loading programs\n    for (var type in _this.settings.nodeProgramClasses) {\n      var NodeProgramClass = _this.settings.nodeProgramClasses[type];\n      _this.nodePrograms[type] = new NodeProgramClass(_this.webGLContexts.nodes, _this.frameBuffers.nodes, (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this));\n      var NodeHoverProgram = NodeProgramClass;\n      if (type in _this.settings.nodeHoverProgramClasses) {\n        NodeHoverProgram = _this.settings.nodeHoverProgramClasses[type];\n      }\n      _this.nodeHoverPrograms[type] = new NodeHoverProgram(_this.webGLContexts.hoverNodes, null, (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this));\n    }\n    for (var _type in _this.settings.edgeProgramClasses) {\n      var EdgeProgramClass = _this.settings.edgeProgramClasses[_type];\n      _this.edgePrograms[_type] = new EdgeProgramClass(_this.webGLContexts.edges, _this.frameBuffers.edges, (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this));\n    }\n\n    // Initializing the camera\n    _this.camera = new Camera();\n\n    // Binding camera events\n    _this.bindCameraHandlers();\n\n    // Initializing captors\n    _this.mouseCaptor = new MouseCaptor(_this.elements.mouse, (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this));\n    _this.touchCaptor = new TouchCaptor(_this.elements.mouse, (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.c)(_this));\n\n    // Binding event handlers\n    _this.bindEventHandlers();\n\n    // Binding graph handlers\n    _this.bindGraphHandlers();\n\n    // Trigger eventual settings-related things\n    _this.handleSettingsUpdate();\n\n    // Processing data for the first time & render\n    _this.refresh();\n    return _this;\n  }\n\n  /**---------------------------------------------------------------------------\n   * Internal methods.\n   **---------------------------------------------------------------------------\n   */\n\n  /**\n   * Internal function used to create a canvas element.\n   * @param  {string} id - Context's id.\n   * @return {Sigma}\n   */\n  (0,_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_4__.d)(Sigma, [{\n    key: \"createCanvas\",\n    value: function createCanvas(id) {\n      var canvas = (0,_normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.a)(\"canvas\", {\n        position: \"absolute\"\n      }, {\n        \"class\": \"sigma-\".concat(id)\n      });\n      this.elements[id] = canvas;\n      this.container.appendChild(canvas);\n      return canvas;\n    }\n\n    /**\n     * Internal function used to create a canvas context and add the relevant\n     * DOM elements.\n     *\n     * @param  {string} id - Context's id.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createCanvasContext\",\n    value: function createCanvasContext(id) {\n      var canvas = this.createCanvas(id);\n      var contextOptions = {\n        preserveDrawingBuffer: false,\n        antialias: false\n      };\n      this.canvasContexts[id] = canvas.getContext(\"2d\", contextOptions);\n      return this;\n    }\n\n    /**\n     * Internal function used to create a WebGL context and add the relevant DOM\n     * elements.\n     *\n     * @param  {string}  id      - Context's id.\n     * @param  {object?} options - #getContext params to override (optional)\n     * @return {Sigma}\n     */\n  }, {\n    key: \"createWebGLContext\",\n    value: function createWebGLContext(id, options) {\n      var canvas = this.createCanvas(id);\n      if (options !== null && options !== void 0 && options.hidden) canvas.remove();\n      var contextOptions = (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({\n        preserveDrawingBuffer: false,\n        antialias: false\n      }, options || {});\n      var context;\n\n      // First we try webgl2 for an easy performance boost\n      context = canvas.getContext(\"webgl2\", contextOptions);\n\n      // Else we fall back to webgl\n      if (!context) context = canvas.getContext(\"webgl\", contextOptions);\n\n      // Edge, I am looking right at you...\n      if (!context) context = canvas.getContext(\"experimental-webgl\", contextOptions);\n      var gl = context;\n      this.webGLContexts[id] = gl;\n\n      // Blending:\n      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n\n      // Prepare frame buffer for picking layers:\n      if (options !== null && options !== void 0 && options.picking) {\n        this.pickingLayers.add(id);\n        var newFrameBuffer = gl.createFramebuffer();\n        if (!newFrameBuffer) throw new Error(\"Sigma: cannot create a new frame buffer for layer \".concat(id));\n        this.frameBuffers[id] = newFrameBuffer;\n      }\n      return this;\n    }\n\n    /**\n     * Method (re)binding WebGL texture (for picking).\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"resetWebGLTexture\",\n    value: function resetWebGLTexture(id) {\n      var gl = this.webGLContexts[id];\n      var frameBuffer = this.frameBuffers[id];\n      var currentTexture = this.textures[id];\n      if (currentTexture) gl.deleteTexture(currentTexture);\n      var pickingTexture = gl.createTexture();\n      gl.bindFramebuffer(gl.FRAMEBUFFER, frameBuffer);\n      gl.bindTexture(gl.TEXTURE_2D, pickingTexture);\n      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.width, this.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, pickingTexture, 0);\n      this.textures[id] = pickingTexture;\n      return this;\n    }\n\n    /**\n     * Method binding camera handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindCameraHandlers\",\n    value: function bindCameraHandlers() {\n      var _this2 = this;\n      this.activeListeners.camera = function () {\n        _this2.scheduleRender();\n      };\n      this.camera.on(\"updated\", this.activeListeners.camera);\n      return this;\n    }\n\n    /**\n     * Method unbinding camera handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"unbindCameraHandlers\",\n    value: function unbindCameraHandlers() {\n      this.camera.removeListener(\"updated\", this.activeListeners.camera);\n      return this;\n    }\n\n    /**\n     * Method that returns the closest node to a given position.\n     */\n  }, {\n    key: \"getNodeAtPosition\",\n    value: function getNodeAtPosition(position) {\n      var x = position.x,\n        y = position.y;\n      var color = (0,_colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_7__.g)(this.webGLContexts.nodes, this.frameBuffers.nodes, x, y, this.pixelRatio, this.pickingDownSizingRatio);\n      var index = _colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_7__.c.apply(void 0, _toConsumableArray(color));\n      var itemAt = this.itemIDsIndex[index];\n      return itemAt && itemAt.type === \"node\" ? itemAt.id : null;\n    }\n\n    /**\n     * Method binding event handlers.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindEventHandlers\",\n    value: function bindEventHandlers() {\n      var _this3 = this;\n      // Handling window resize\n      this.activeListeners.handleResize = function () {\n        // need to call a refresh to rebuild the labelgrid\n        _this3.scheduleRefresh();\n      };\n      window.addEventListener(\"resize\", this.activeListeners.handleResize);\n\n      // Handling mouse move\n      this.activeListeners.handleMove = function (e) {\n        var baseEvent = {\n          event: e,\n          preventSigmaDefault: function preventSigmaDefault() {\n            e.preventSigmaDefault();\n          }\n        };\n        var nodeToHover = _this3.getNodeAtPosition(e);\n        if (nodeToHover && _this3.hoveredNode !== nodeToHover && !_this3.nodeDataCache[nodeToHover].hidden) {\n          // Handling passing from one node to the other directly\n          if (_this3.hoveredNode) _this3.emit(\"leaveNode\", (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, baseEvent), {}, {\n            node: _this3.hoveredNode\n          }));\n          _this3.hoveredNode = nodeToHover;\n          _this3.emit(\"enterNode\", (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, baseEvent), {}, {\n            node: nodeToHover\n          }));\n          _this3.scheduleHighlightedNodesRender();\n          return;\n        }\n\n        // Checking if the hovered node is still hovered\n        if (_this3.hoveredNode) {\n          if (_this3.getNodeAtPosition(e) !== _this3.hoveredNode) {\n            var node = _this3.hoveredNode;\n            _this3.hoveredNode = null;\n            _this3.emit(\"leaveNode\", (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, baseEvent), {}, {\n              node: node\n            }));\n            _this3.scheduleHighlightedNodesRender();\n            return;\n          }\n        }\n        if (_this3.settings.enableEdgeEvents) {\n          var edgeToHover = _this3.hoveredNode ? null : _this3.getEdgeAtPoint(baseEvent.event.x, baseEvent.event.y);\n          if (edgeToHover !== _this3.hoveredEdge) {\n            if (_this3.hoveredEdge) _this3.emit(\"leaveEdge\", (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, baseEvent), {}, {\n              edge: _this3.hoveredEdge\n            }));\n            if (edgeToHover) _this3.emit(\"enterEdge\", (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, baseEvent), {}, {\n              edge: edgeToHover\n            }));\n            _this3.hoveredEdge = edgeToHover;\n          }\n        }\n      };\n\n      // Handling mouse leave stage:\n      this.activeListeners.handleLeave = function (e) {\n        var baseEvent = {\n          event: e,\n          preventSigmaDefault: function preventSigmaDefault() {\n            e.preventSigmaDefault();\n          }\n        };\n        if (_this3.hoveredNode) {\n          _this3.emit(\"leaveNode\", (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, baseEvent), {}, {\n            node: _this3.hoveredNode\n          }));\n          _this3.scheduleHighlightedNodesRender();\n        }\n        if (_this3.settings.enableEdgeEvents && _this3.hoveredEdge) {\n          _this3.emit(\"leaveEdge\", (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, baseEvent), {}, {\n            edge: _this3.hoveredEdge\n          }));\n          _this3.scheduleHighlightedNodesRender();\n        }\n        _this3.emit(\"leaveStage\", (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, baseEvent));\n      };\n\n      // Handling mouse enter stage:\n      this.activeListeners.handleEnter = function (e) {\n        var baseEvent = {\n          event: e,\n          preventSigmaDefault: function preventSigmaDefault() {\n            e.preventSigmaDefault();\n          }\n        };\n        _this3.emit(\"enterStage\", (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, baseEvent));\n      };\n\n      // Handling click\n      var createMouseListener = function createMouseListener(eventType) {\n        return function (e) {\n          var baseEvent = {\n            event: e,\n            preventSigmaDefault: function preventSigmaDefault() {\n              e.preventSigmaDefault();\n            }\n          };\n          var isFakeSigmaMouseEvent = e.original.isFakeSigmaMouseEvent;\n          var nodeAtPosition = isFakeSigmaMouseEvent ? _this3.getNodeAtPosition(e) : _this3.hoveredNode;\n          if (nodeAtPosition) return _this3.emit(\"\".concat(eventType, \"Node\"), (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, baseEvent), {}, {\n            node: nodeAtPosition\n          }));\n          if (_this3.settings.enableEdgeEvents) {\n            var edge = _this3.getEdgeAtPoint(e.x, e.y);\n            if (edge) return _this3.emit(\"\".concat(eventType, \"Edge\"), (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, baseEvent), {}, {\n              edge: edge\n            }));\n          }\n          return _this3.emit(\"\".concat(eventType, \"Stage\"), baseEvent);\n        };\n      };\n      this.activeListeners.handleClick = createMouseListener(\"click\");\n      this.activeListeners.handleRightClick = createMouseListener(\"rightClick\");\n      this.activeListeners.handleDoubleClick = createMouseListener(\"doubleClick\");\n      this.activeListeners.handleWheel = createMouseListener(\"wheel\");\n      this.activeListeners.handleDown = createMouseListener(\"down\");\n      this.activeListeners.handleUp = createMouseListener(\"up\");\n      this.mouseCaptor.on(\"mousemove\", this.activeListeners.handleMove);\n      this.mouseCaptor.on(\"click\", this.activeListeners.handleClick);\n      this.mouseCaptor.on(\"rightClick\", this.activeListeners.handleRightClick);\n      this.mouseCaptor.on(\"doubleClick\", this.activeListeners.handleDoubleClick);\n      this.mouseCaptor.on(\"wheel\", this.activeListeners.handleWheel);\n      this.mouseCaptor.on(\"mousedown\", this.activeListeners.handleDown);\n      this.mouseCaptor.on(\"mouseup\", this.activeListeners.handleUp);\n      this.mouseCaptor.on(\"mouseleave\", this.activeListeners.handleLeave);\n      this.mouseCaptor.on(\"mouseenter\", this.activeListeners.handleEnter);\n\n      // TODO\n      // Deal with Touch captor events\n\n      return this;\n    }\n\n    /**\n     * Method binding graph handlers\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"bindGraphHandlers\",\n    value: function bindGraphHandlers() {\n      var _this4 = this;\n      var graph = this.graph;\n      var LAYOUT_IMPACTING_FIELDS = new Set([\"x\", \"y\", \"zIndex\", \"type\"]);\n      this.activeListeners.eachNodeAttributesUpdatedGraphUpdate = function (e) {\n        var _e$hints;\n        var updatedFields = (_e$hints = e.hints) === null || _e$hints === void 0 ? void 0 : _e$hints.attributes;\n        // we process all nodes\n        _this4.graph.forEachNode(function (node) {\n          return _this4.updateNode(node);\n        });\n\n        // if coord, type or zIndex have changed, we need to schedule a render\n        // (zIndex for the programIndex)\n        var layoutChanged = !updatedFields || updatedFields.some(function (f) {\n          return LAYOUT_IMPACTING_FIELDS.has(f);\n        });\n        _this4.refresh({\n          partialGraph: {\n            nodes: graph.nodes()\n          },\n          skipIndexation: !layoutChanged,\n          schedule: true\n        });\n      };\n      this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate = function (e) {\n        var _e$hints2;\n        var updatedFields = (_e$hints2 = e.hints) === null || _e$hints2 === void 0 ? void 0 : _e$hints2.attributes;\n        // we process all edges\n        _this4.graph.forEachEdge(function (edge) {\n          return _this4.updateEdge(edge);\n        });\n        var layoutChanged = updatedFields && [\"zIndex\", \"type\"].some(function (f) {\n          return updatedFields === null || updatedFields === void 0 ? void 0 : updatedFields.includes(f);\n        });\n        _this4.refresh({\n          partialGraph: {\n            edges: graph.edges()\n          },\n          skipIndexation: !layoutChanged,\n          schedule: true\n        });\n      };\n\n      // On add node, we add the node in indices and then call for a render\n      this.activeListeners.addNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // we process the node\n        _this4.addNode(node);\n        // schedule a render for the node\n        _this4.refresh({\n          partialGraph: {\n            nodes: [node]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On update node, we update indices and then call for a render\n      this.activeListeners.updateNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // schedule a render for the node\n        _this4.refresh({\n          partialGraph: {\n            nodes: [node]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On drop node, we remove the node from indices and then call for a refresh\n      this.activeListeners.dropNodeGraphUpdate = function (payload) {\n        var node = payload.key;\n        // we process the node\n        _this4.removeNode(node);\n        // schedule a render for everything\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On add edge, we remove the edge from indices and then call for a refresh\n      this.activeListeners.addEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // we process the edge\n        _this4.addEdge(edge);\n        // schedule a render for the edge\n        _this4.refresh({\n          partialGraph: {\n            edges: [edge]\n          },\n          schedule: true\n        });\n      };\n\n      // On update edge, we update indices and then call for a refresh\n      this.activeListeners.updateEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // schedule a repaint for the edge\n        _this4.refresh({\n          partialGraph: {\n            edges: [edge]\n          },\n          skipIndexation: false,\n          schedule: true\n        });\n      };\n\n      // On drop edge, we remove the edge from indices and then call for a refresh\n      this.activeListeners.dropEdgeGraphUpdate = function (payload) {\n        var edge = payload.key;\n        // we process the edge\n        _this4.removeEdge(edge);\n        // schedule a render for all edges\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On clear edges, we clear the edge indices and then call for a refresh\n      this.activeListeners.clearEdgesGraphUpdate = function () {\n        // we clear the edge data structures\n        _this4.clearEdgeState();\n        _this4.clearEdgeIndices();\n        // schedule a render for all edges\n        _this4.refresh({\n          schedule: true\n        });\n      };\n\n      // On graph clear, we clear indices and then call for a refresh\n      this.activeListeners.clearGraphUpdate = function () {\n        // clear graph state\n        _this4.clearEdgeState();\n        _this4.clearNodeState();\n\n        // clear graph indices\n        _this4.clearEdgeIndices();\n        _this4.clearNodeIndices();\n\n        // schedule a render for all\n        _this4.refresh({\n          schedule: true\n        });\n      };\n      graph.on(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n      graph.on(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n      graph.on(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n      graph.on(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n      graph.on(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n      graph.on(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n      graph.on(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n      graph.on(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n      graph.on(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n      graph.on(\"cleared\", this.activeListeners.clearGraphUpdate);\n      return this;\n    }\n\n    /**\n     * Method used to unbind handlers from the graph.\n     *\n     * @return {undefined}\n     */\n  }, {\n    key: \"unbindGraphHandlers\",\n    value: function unbindGraphHandlers() {\n      var graph = this.graph;\n      graph.removeListener(\"nodeAdded\", this.activeListeners.addNodeGraphUpdate);\n      graph.removeListener(\"nodeDropped\", this.activeListeners.dropNodeGraphUpdate);\n      graph.removeListener(\"nodeAttributesUpdated\", this.activeListeners.updateNodeGraphUpdate);\n      graph.removeListener(\"eachNodeAttributesUpdated\", this.activeListeners.eachNodeAttributesUpdatedGraphUpdate);\n      graph.removeListener(\"edgeAdded\", this.activeListeners.addEdgeGraphUpdate);\n      graph.removeListener(\"edgeDropped\", this.activeListeners.dropEdgeGraphUpdate);\n      graph.removeListener(\"edgeAttributesUpdated\", this.activeListeners.updateEdgeGraphUpdate);\n      graph.removeListener(\"eachEdgeAttributesUpdated\", this.activeListeners.eachEdgeAttributesUpdatedGraphUpdate);\n      graph.removeListener(\"edgesCleared\", this.activeListeners.clearEdgesGraphUpdate);\n      graph.removeListener(\"cleared\", this.activeListeners.clearGraphUpdate);\n    }\n\n    /**\n     * Method looking for an edge colliding with a given point at (x, y). Returns\n     * the key of the edge if any, or null else.\n     */\n  }, {\n    key: \"getEdgeAtPoint\",\n    value: function getEdgeAtPoint(x, y) {\n      var color = (0,_colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_7__.g)(this.webGLContexts.edges, this.frameBuffers.edges, x, y, this.pixelRatio, this.pickingDownSizingRatio);\n      var index = _colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_7__.c.apply(void 0, _toConsumableArray(color));\n      var itemAt = this.itemIDsIndex[index];\n      return itemAt && itemAt.type === \"edge\" ? itemAt.id : null;\n    }\n\n    /**\n     * Method used to process the whole graph's data.\n     *  - extent\n     *  - normalizationFunction\n     *  - compute node's coordinate\n     *  - labelgrid\n     *  - program data allocation\n     * @return {Sigma}\n     */\n  }, {\n    key: \"process\",\n    value: function process() {\n      var _this5 = this;\n      var graph = this.graph;\n      var settings = this.settings;\n      var dimensions = this.getDimensions();\n\n      //\n      // NODES\n      //\n      this.nodeExtent = (0,_normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.b)(this.graph);\n      this.normalizationFunction = (0,_normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.c)(this.customBBox || this.nodeExtent);\n\n      // NOTE: it is important to compute this matrix after computing the node's extent\n      // because #.getGraphDimensions relies on it\n      var nullCamera = new Camera();\n      var nullCameraMatrix = (0,_normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(nullCamera.getState(), dimensions, this.getGraphDimensions(), this.getSetting(\"stagePadding\") || 0);\n      // Resetting the label grid\n      // TODO: it's probably better to do this explicitly or on resizes for layout and anims\n      this.labelGrid.resizeAndClear(dimensions, settings.labelGridCellSize);\n      var nodesPerPrograms = {};\n      var nodeIndices = {};\n      var edgeIndices = {};\n      var itemIDsIndex = {};\n      var incrID = 1;\n      var nodes = graph.nodes();\n\n      // Do some indexation on the whole graph\n      for (var i = 0, l = nodes.length; i < l; i++) {\n        var node = nodes[i];\n        var data = this.nodeDataCache[node];\n\n        // Get initial coordinates\n        var attrs = graph.getNodeAttributes(node);\n        data.x = attrs.x;\n        data.y = attrs.y;\n        this.normalizationFunction.applyTo(data);\n\n        // labelgrid\n        if (typeof data.label === \"string\" && !data.hidden) this.labelGrid.add(node, data.size, this.framedGraphToViewport(data, {\n          matrix: nullCameraMatrix\n        }));\n\n        // update count per program\n        nodesPerPrograms[data.type] = (nodesPerPrograms[data.type] || 0) + 1;\n      }\n      this.labelGrid.organize();\n\n      // Allocate memory to programs\n      for (var type in this.nodePrograms) {\n        if (!hasOwnProperty.call(this.nodePrograms, type)) {\n          throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(type, \"\\\"!\"));\n        }\n        this.nodePrograms[type].reallocate(nodesPerPrograms[type] || 0);\n        // We reset that count here, so that we can reuse it while calling the Program#process methods:\n        nodesPerPrograms[type] = 0;\n      }\n\n      // Order nodes by zIndex before to add them to program\n      if (this.settings.zIndex && this.nodeZExtent[0] !== this.nodeZExtent[1]) nodes = (0,_normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.z)(this.nodeZExtent, function (node) {\n        return _this5.nodeDataCache[node].zIndex;\n      }, nodes);\n\n      // Add data to programs\n      for (var _i = 0, _l = nodes.length; _i < _l; _i++) {\n        var _node = nodes[_i];\n        nodeIndices[_node] = incrID;\n        itemIDsIndex[nodeIndices[_node]] = {\n          type: \"node\",\n          id: _node\n        };\n        incrID++;\n        var _data = this.nodeDataCache[_node];\n        this.addNodeToProgram(_node, nodeIndices[_node], nodesPerPrograms[_data.type]++);\n      }\n\n      //\n      // EDGES\n      //\n\n      var edgesPerPrograms = {};\n      var edges = graph.edges();\n\n      // Allocate memory to programs\n      for (var _i2 = 0, _l2 = edges.length; _i2 < _l2; _i2++) {\n        var edge = edges[_i2];\n        var _data2 = this.edgeDataCache[edge];\n        edgesPerPrograms[_data2.type] = (edgesPerPrograms[_data2.type] || 0) + 1;\n      }\n\n      // Order edges by zIndex before to add them to program\n      if (this.settings.zIndex && this.edgeZExtent[0] !== this.edgeZExtent[1]) edges = (0,_normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.z)(this.edgeZExtent, function (edge) {\n        return _this5.edgeDataCache[edge].zIndex;\n      }, edges);\n      for (var _type2 in this.edgePrograms) {\n        if (!hasOwnProperty.call(this.edgePrograms, _type2)) {\n          throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(_type2, \"\\\"!\"));\n        }\n        this.edgePrograms[_type2].reallocate(edgesPerPrograms[_type2] || 0);\n        // We reset that count here, so that we can reuse it while calling the Program#process methods:\n        edgesPerPrograms[_type2] = 0;\n      }\n\n      // Add data to programs\n      for (var _i3 = 0, _l3 = edges.length; _i3 < _l3; _i3++) {\n        var _edge = edges[_i3];\n        edgeIndices[_edge] = incrID;\n        itemIDsIndex[edgeIndices[_edge]] = {\n          type: \"edge\",\n          id: _edge\n        };\n        incrID++;\n        var _data3 = this.edgeDataCache[_edge];\n        this.addEdgeToProgram(_edge, edgeIndices[_edge], edgesPerPrograms[_data3.type]++);\n      }\n      this.itemIDsIndex = itemIDsIndex;\n      this.nodeIndices = nodeIndices;\n      this.edgeIndices = edgeIndices;\n      return this;\n    }\n\n    /**\n     * Method that backports potential settings updates where it's needed.\n     * @private\n     */\n  }, {\n    key: \"handleSettingsUpdate\",\n    value: function handleSettingsUpdate() {\n      this.camera.minRatio = this.settings.minCameraRatio;\n      this.camera.maxRatio = this.settings.maxCameraRatio;\n      this.camera.setState(this.camera.validateState(this.camera.getState()));\n      return this;\n    }\n\n    /**\n     * Method used to render labels.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderLabels\",\n    value: function renderLabels() {\n      if (!this.settings.renderLabels) return this;\n      var cameraState = this.camera.getState();\n\n      // Selecting labels to draw\n      var labelsToDisplay = this.labelGrid.getLabelsToDisplay(cameraState.ratio, this.settings.labelDensity);\n      (0,_data_31990a76_esm_js__WEBPACK_IMPORTED_MODULE_8__.e)(labelsToDisplay, this.nodesWithForcedLabels);\n      this.displayedNodeLabels = new Set();\n\n      // Drawing labels\n      var context = this.canvasContexts.labels;\n      for (var i = 0, l = labelsToDisplay.length; i < l; i++) {\n        var node = labelsToDisplay[i];\n        var data = this.nodeDataCache[node];\n\n        // If the node was already drawn (like if it is eligible AND has\n        // `forceLabel`), we don't want to draw it again\n        // NOTE: we can do better probably\n        if (this.displayedNodeLabels.has(node)) continue;\n\n        // If the node is hidden, we don't need to display its label obviously\n        if (data.hidden) continue;\n        var _this$framedGraphToVi = this.framedGraphToViewport(data),\n          x = _this$framedGraphToVi.x,\n          y = _this$framedGraphToVi.y;\n\n        // NOTE: we can cache the labels we need to render until the camera's ratio changes\n        var size = this.scaleSize(data.size);\n\n        // Is node big enough?\n        if (!data.forceLabel && size < this.settings.labelRenderedSizeThreshold) continue;\n\n        // Is node actually on screen (with some margin)\n        // NOTE: we used to rely on the quadtree for this, but the coordinates\n        // conversion make it unreliable and at that point we already converted\n        // to viewport coordinates and since the label grid already culls the\n        // number of potential labels to display this looks like a good\n        // performance compromise.\n        // NOTE: labelGrid.getLabelsToDisplay could probably optimize by not\n        // considering cells obviously outside of the range of the current\n        // view rectangle.\n        if (x < -X_LABEL_MARGIN || x > this.width + X_LABEL_MARGIN || y < -Y_LABEL_MARGIN || y > this.height + Y_LABEL_MARGIN) continue;\n\n        // Because displayed edge labels depend directly on actually rendered node\n        // labels, we need to only add to this.displayedNodeLabels nodes whose label\n        // is rendered.\n        // This makes this.displayedNodeLabels depend on viewport, which might become\n        // an issue once we start memoizing getLabelsToDisplay.\n        this.displayedNodeLabels.add(node);\n        var defaultDrawNodeLabel = this.settings.defaultDrawNodeLabel;\n        var nodeProgram = this.nodePrograms[data.type];\n        var drawLabel = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawLabel) || defaultDrawNodeLabel;\n        drawLabel(context, (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({\n          key: node\n        }, data), {}, {\n          size: size,\n          x: x,\n          y: y\n        }), this.settings);\n      }\n      return this;\n    }\n\n    /**\n     * Method used to render edge labels, based on which node labels were\n     * rendered.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderEdgeLabels\",\n    value: function renderEdgeLabels() {\n      if (!this.settings.renderEdgeLabels) return this;\n      var context = this.canvasContexts.edgeLabels;\n\n      // Clearing\n      context.clearRect(0, 0, this.width, this.height);\n      var edgeLabelsToDisplay = edgeLabelsToDisplayFromNodes({\n        graph: this.graph,\n        hoveredNode: this.hoveredNode,\n        displayedNodeLabels: this.displayedNodeLabels,\n        highlightedNodes: this.highlightedNodes\n      });\n      (0,_data_31990a76_esm_js__WEBPACK_IMPORTED_MODULE_8__.e)(edgeLabelsToDisplay, this.edgesWithForcedLabels);\n      var displayedLabels = new Set();\n      for (var i = 0, l = edgeLabelsToDisplay.length; i < l; i++) {\n        var edge = edgeLabelsToDisplay[i],\n          extremities = this.graph.extremities(edge),\n          sourceData = this.nodeDataCache[extremities[0]],\n          targetData = this.nodeDataCache[extremities[1]],\n          edgeData = this.edgeDataCache[edge];\n\n        // If the edge was already drawn (like if it is eligible AND has\n        // `forceLabel`), we don't want to draw it again\n        if (displayedLabels.has(edge)) continue;\n\n        // If the edge is hidden we don't need to display its label\n        // NOTE: the test on sourceData & targetData is probably paranoid at this point?\n        if (edgeData.hidden || sourceData.hidden || targetData.hidden) {\n          continue;\n        }\n        var defaultDrawEdgeLabel = this.settings.defaultDrawEdgeLabel;\n        var edgeProgram = this.edgePrograms[edgeData.type];\n        var drawLabel = (edgeProgram === null || edgeProgram === void 0 ? void 0 : edgeProgram.drawLabel) || defaultDrawEdgeLabel;\n        drawLabel(context, (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({\n          key: edge\n        }, edgeData), {}, {\n          size: this.scaleSize(edgeData.size)\n        }), (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({\n          key: extremities[0]\n        }, sourceData), this.framedGraphToViewport(sourceData)), {}, {\n          size: this.scaleSize(sourceData.size)\n        }), (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({\n          key: extremities[1]\n        }, targetData), this.framedGraphToViewport(targetData)), {}, {\n          size: this.scaleSize(targetData.size)\n        }), this.settings);\n        displayedLabels.add(edge);\n      }\n      this.displayedEdgeLabels = displayedLabels;\n      return this;\n    }\n\n    /**\n     * Method used to render the highlighted nodes.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"renderHighlightedNodes\",\n    value: function renderHighlightedNodes() {\n      var _this6 = this;\n      var context = this.canvasContexts.hovers;\n\n      // Clearing\n      context.clearRect(0, 0, this.width, this.height);\n\n      // Rendering\n      var render = function render(node) {\n        var data = _this6.nodeDataCache[node];\n        var _this6$framedGraphToV = _this6.framedGraphToViewport(data),\n          x = _this6$framedGraphToV.x,\n          y = _this6$framedGraphToV.y;\n        var size = _this6.scaleSize(data.size);\n        var defaultDrawNodeHover = _this6.settings.defaultDrawNodeHover;\n        var nodeProgram = _this6.nodePrograms[data.type];\n        var drawHover = (nodeProgram === null || nodeProgram === void 0 ? void 0 : nodeProgram.drawHover) || defaultDrawNodeHover;\n        drawHover(context, (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({\n          key: node\n        }, data), {}, {\n          size: size,\n          x: x,\n          y: y\n        }), _this6.settings);\n      };\n      var nodesToRender = [];\n      if (this.hoveredNode && !this.nodeDataCache[this.hoveredNode].hidden) {\n        nodesToRender.push(this.hoveredNode);\n      }\n      this.highlightedNodes.forEach(function (node) {\n        // The hovered node has already been highlighted\n        if (node !== _this6.hoveredNode) nodesToRender.push(node);\n      });\n\n      // Draw labels:\n      nodesToRender.forEach(function (node) {\n        return render(node);\n      });\n\n      // Draw WebGL nodes on top of the labels:\n      var nodesPerPrograms = {};\n\n      // 1. Count nodes per type:\n      nodesToRender.forEach(function (node) {\n        var type = _this6.nodeDataCache[node].type;\n        nodesPerPrograms[type] = (nodesPerPrograms[type] || 0) + 1;\n      });\n      // 2. Allocate for each type for the proper number of nodes\n      for (var type in this.nodeHoverPrograms) {\n        this.nodeHoverPrograms[type].reallocate(nodesPerPrograms[type] || 0);\n        // Also reset count, to use when rendering:\n        nodesPerPrograms[type] = 0;\n      }\n      // 3. Process all nodes to render:\n      nodesToRender.forEach(function (node) {\n        var data = _this6.nodeDataCache[node];\n        _this6.nodeHoverPrograms[data.type].process(0, nodesPerPrograms[data.type]++, data);\n      });\n      // 4. Clear hovered nodes layer:\n      this.webGLContexts.hoverNodes.clear(this.webGLContexts.hoverNodes.COLOR_BUFFER_BIT);\n      // 5. Render:\n      for (var _type3 in this.nodeHoverPrograms) {\n        var program = this.nodeHoverPrograms[_type3];\n        program.render({\n          matrix: this.matrix,\n          width: this.width,\n          height: this.height,\n          pixelRatio: this.pixelRatio,\n          cameraAngle: this.camera.angle,\n          zoomRatio: this.camera.ratio,\n          sizeRatio: 1 / this.scaleSize(),\n          correctionRatio: this.correctionRatio,\n          downSizingRatio: this.pickingDownSizingRatio\n        });\n      }\n    }\n\n    /**\n     * Method used to schedule a hover render.\n     *\n     */\n  }, {\n    key: \"scheduleHighlightedNodesRender\",\n    value: function scheduleHighlightedNodesRender() {\n      var _this7 = this;\n      if (this.renderHighlightedNodesFrame || this.renderFrame) return;\n      this.renderHighlightedNodesFrame = requestAnimationFrame(function () {\n        // Resetting state\n        _this7.renderHighlightedNodesFrame = null;\n\n        // Rendering\n        _this7.renderHighlightedNodes();\n        _this7.renderEdgeLabels();\n      });\n    }\n\n    /**\n     * Method used to render.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this8 = this;\n      this.emit(\"beforeRender\");\n      var exitRender = function exitRender() {\n        _this8.emit(\"afterRender\");\n        return _this8;\n      };\n\n      // If a render was scheduled, we cancel it\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n\n      // First we need to resize\n      this.resize();\n\n      // Do we need to reprocess data?\n      if (this.needToProcess) this.process();\n      this.needToProcess = false;\n\n      // Clearing the canvases\n      this.clear();\n\n      // Prepare the textures\n      this.pickingLayers.forEach(function (layer) {\n        return _this8.resetWebGLTexture(layer);\n      });\n\n      // If we have no nodes we can stop right there\n      if (!this.graph.order) return exitRender();\n\n      // TODO: improve this heuristic or move to the captor itself?\n      // TODO: deal with the touch captor here as well\n      var mouseCaptor = this.mouseCaptor;\n      var moving = this.camera.isAnimated() || mouseCaptor.isMoving || mouseCaptor.draggedEvents || mouseCaptor.currentWheelDirection;\n\n      // Then we need to extract a matrix from the camera\n      var cameraState = this.camera.getState();\n      var viewportDimensions = this.getDimensions();\n      var graphDimensions = this.getGraphDimensions();\n      var padding = this.getSetting(\"stagePadding\") || 0;\n      this.matrix = (0,_normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(cameraState, viewportDimensions, graphDimensions, padding);\n      this.invMatrix = (0,_normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(cameraState, viewportDimensions, graphDimensions, padding, true);\n      this.correctionRatio = (0,_normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.d)(this.matrix, cameraState, viewportDimensions);\n      this.graphToViewportRatio = this.getGraphToViewportRatio();\n\n      // [jacomyal]\n      // This comment is related to the one above the `getMatrixImpact` definition:\n      // - `this.correctionRatio` is somehow not completely explained\n      // - `this.graphToViewportRatio` is the ratio of a distance in the viewport divided by the same distance in the\n      //   graph\n      // - `this.normalizationFunction.ratio` is basically `Math.max(graphDX, graphDY)`\n      // And now, I observe that if I multiply these three ratios, I have something constant, which value remains 2, even\n      // when I change the graph, the viewport or the camera. It might be useful later so I prefer to let this comment:\n      // console.log(this.graphToViewportRatio * this.correctionRatio * this.normalizationFunction.ratio * 2);\n\n      var params = {\n        matrix: this.matrix,\n        width: this.width,\n        height: this.height,\n        pixelRatio: this.pixelRatio,\n        zoomRatio: this.camera.ratio,\n        cameraAngle: this.camera.angle,\n        sizeRatio: 1 / this.scaleSize(),\n        correctionRatio: this.correctionRatio,\n        downSizingRatio: this.pickingDownSizingRatio\n      };\n\n      // Drawing nodes\n      for (var type in this.nodePrograms) {\n        var program = this.nodePrograms[type];\n        program.render(params);\n      }\n\n      // Drawing edges\n      if (!this.settings.hideEdgesOnMove || !moving) {\n        for (var _type4 in this.edgePrograms) {\n          var _program = this.edgePrograms[_type4];\n          _program.render(params);\n        }\n      }\n\n      // Do not display labels on move per setting\n      if (this.settings.hideLabelsOnMove && moving) return exitRender();\n      this.renderLabels();\n      this.renderEdgeLabels();\n      this.renderHighlightedNodes();\n      return exitRender();\n    }\n\n    /**\n     * Add a node in the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"addNode\",\n    value: function addNode(key) {\n      // Node display data resolution:\n      //  1. First we get the node's attributes\n      //  2. We optionally reduce them using the function provided by the user\n      //     Note that this function must return a total object and won't be merged\n      //  3. We apply our defaults, while running some vital checks\n      //  4. We apply the normalization function\n      // We shallow copy node data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, this.graph.getNodeAttributes(key));\n      if (this.settings.nodeReducer) attr = this.settings.nodeReducer(key, attr);\n      var data = applyNodeDefaults(this.settings, key, attr);\n      this.nodeDataCache[key] = data;\n\n      // Label:\n      // We delete and add if needed because this function is also used from\n      // update\n      this.nodesWithForcedLabels[\"delete\"](key);\n      if (data.forceLabel && !data.hidden) this.nodesWithForcedLabels.add(key);\n\n      // Highlighted:\n      // We remove and re add if needed because this function is also used from\n      // update\n      this.highlightedNodes[\"delete\"](key);\n      if (data.highlighted && !data.hidden) this.highlightedNodes.add(key);\n\n      // zIndex\n      if (this.settings.zIndex) {\n        if (data.zIndex < this.nodeZExtent[0]) this.nodeZExtent[0] = data.zIndex;\n        if (data.zIndex > this.nodeZExtent[1]) this.nodeZExtent[1] = data.zIndex;\n      }\n    }\n\n    /**\n     * Update a node the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"updateNode\",\n    value: function updateNode(key) {\n      this.addNode(key);\n\n      // Re-apply normalization on the node\n      var data = this.nodeDataCache[key];\n      this.normalizationFunction.applyTo(data);\n    }\n\n    /**\n     * Remove a node from the internal data structures.\n     * @private\n     * @param key The node's graphology ID\n     */\n  }, {\n    key: \"removeNode\",\n    value: function removeNode(key) {\n      // Remove from node cache\n      delete this.nodeDataCache[key];\n      // Remove from node program index\n      delete this.nodeProgramIndex[key];\n      // Remove from higlighted nodes\n      this.highlightedNodes[\"delete\"](key);\n      // Remove from hovered\n      if (this.hoveredNode === key) this.hoveredNode = null;\n      // Remove from forced label\n      this.nodesWithForcedLabels[\"delete\"](key);\n    }\n\n    /**\n     * Add an edge into the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"addEdge\",\n    value: function addEdge(key) {\n      // Edge display data resolution:\n      //  1. First we get the edge's attributes\n      //  2. We optionally reduce them using the function provided by the user\n      //  3. Note that this function must return a total object and won't be merged\n      //  4. We apply our defaults, while running some vital checks\n      // We shallow copy edge data to avoid dangerous behaviors from reducers\n      var attr = Object.assign({}, this.graph.getEdgeAttributes(key));\n      if (this.settings.edgeReducer) attr = this.settings.edgeReducer(key, attr);\n      var data = applyEdgeDefaults(this.settings, key, attr);\n      this.edgeDataCache[key] = data;\n\n      // Forced label\n      // we filter and re push if needed because this function is also used from\n      // update\n      this.edgesWithForcedLabels[\"delete\"](key);\n      if (data.forceLabel && !data.hidden) this.edgesWithForcedLabels.add(key);\n\n      // Check zIndex\n      if (this.settings.zIndex) {\n        if (data.zIndex < this.edgeZExtent[0]) this.edgeZExtent[0] = data.zIndex;\n        if (data.zIndex > this.edgeZExtent[1]) this.edgeZExtent[1] = data.zIndex;\n      }\n    }\n\n    /**\n     * Update an edge in the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"updateEdge\",\n    value: function updateEdge(key) {\n      this.addEdge(key);\n    }\n\n    /**\n     * Remove an edge from the internal data structures.\n     * @private\n     * @param key The edge's graphology ID\n     */\n  }, {\n    key: \"removeEdge\",\n    value: function removeEdge(key) {\n      // Remove from edge cache\n      delete this.edgeDataCache[key];\n      // Remove from programId index\n      delete this.edgeProgramIndex[key];\n      // Remove from hovered\n      if (this.hoveredEdge === key) this.hoveredEdge = null;\n      // Remove from forced label\n      this.edgesWithForcedLabels[\"delete\"](key);\n    }\n\n    /**\n     * Clear all indices related to nodes.\n     * @private\n     */\n  }, {\n    key: \"clearNodeIndices\",\n    value: function clearNodeIndices() {\n      // LabelGrid & nodeExtent are only manage/populated in the process function\n      this.labelGrid = new LabelGrid();\n      this.nodeExtent = {\n        x: [0, 1],\n        y: [0, 1]\n      };\n      this.nodeDataCache = {};\n      this.edgeProgramIndex = {};\n      this.nodesWithForcedLabels = new Set();\n      this.nodeZExtent = [Infinity, -Infinity];\n    }\n\n    /**\n     * Clear all indices related to edges.\n     * @private\n     */\n  }, {\n    key: \"clearEdgeIndices\",\n    value: function clearEdgeIndices() {\n      this.edgeDataCache = {};\n      this.edgeProgramIndex = {};\n      this.edgesWithForcedLabels = new Set();\n      this.edgeZExtent = [Infinity, -Infinity];\n    }\n\n    /**\n     * Clear all indices.\n     * @private\n     */\n  }, {\n    key: \"clearIndices\",\n    value: function clearIndices() {\n      this.clearEdgeIndices();\n      this.clearNodeIndices();\n    }\n\n    /**\n     * Clear all graph state related to nodes.\n     * @private\n     */\n  }, {\n    key: \"clearNodeState\",\n    value: function clearNodeState() {\n      this.displayedNodeLabels = new Set();\n      this.highlightedNodes = new Set();\n      this.hoveredNode = null;\n    }\n\n    /**\n     * Clear all graph state related to edges.\n     * @private\n     */\n  }, {\n    key: \"clearEdgeState\",\n    value: function clearEdgeState() {\n      this.displayedEdgeLabels = new Set();\n      this.highlightedNodes = new Set();\n      this.hoveredEdge = null;\n    }\n\n    /**\n     * Clear all graph state.\n     * @private\n     */\n  }, {\n    key: \"clearState\",\n    value: function clearState() {\n      this.clearEdgeState();\n      this.clearNodeState();\n    }\n\n    /**\n     * Add the node data to its program.\n     * @private\n     * @param node The node's graphology ID\n     * @param fingerprint A fingerprint used to identity the node with picking\n     * @param position The index where to place the node in the program\n     */\n  }, {\n    key: \"addNodeToProgram\",\n    value: function addNodeToProgram(node, fingerprint, position) {\n      var data = this.nodeDataCache[node];\n      var nodeProgram = this.nodePrograms[data.type];\n      if (!nodeProgram) throw new Error(\"Sigma: could not find a suitable program for node type \\\"\".concat(data.type, \"\\\"!\"));\n      nodeProgram.process(fingerprint, position, data);\n      // Saving program index\n      this.nodeProgramIndex[node] = position;\n    }\n\n    /**\n     * Add the edge data to its program.\n     * @private\n     * @param edge The edge's graphology ID\n     * @param fingerprint A fingerprint used to identity the edge with picking\n     * @param position The index where to place the edge in the program\n     */\n  }, {\n    key: \"addEdgeToProgram\",\n    value: function addEdgeToProgram(edge, fingerprint, position) {\n      var data = this.edgeDataCache[edge];\n      var edgeProgram = this.edgePrograms[data.type];\n      if (!edgeProgram) throw new Error(\"Sigma: could not find a suitable program for edge type \\\"\".concat(data.type, \"\\\"!\"));\n      var extremities = this.graph.extremities(edge),\n        sourceData = this.nodeDataCache[extremities[0]],\n        targetData = this.nodeDataCache[extremities[1]];\n      edgeProgram.process(fingerprint, position, sourceData, targetData, data);\n      // Saving program index\n      this.edgeProgramIndex[edge] = position;\n    }\n\n    /**---------------------------------------------------------------------------\n     * Public API.\n     **---------------------------------------------------------------------------\n     */\n\n    /**\n     * Method returning the renderer's camera.\n     *\n     * @return {Camera}\n     */\n  }, {\n    key: \"getCamera\",\n    value: function getCamera() {\n      return this.camera;\n    }\n\n    /**\n     * Method setting the renderer's camera.\n     *\n     * @param  {Camera} camera - New camera.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setCamera\",\n    value: function setCamera(camera) {\n      this.unbindCameraHandlers();\n      this.camera = camera;\n      this.bindCameraHandlers();\n    }\n\n    /**\n     * Method returning the container DOM element.\n     *\n     * @return {HTMLElement}\n     */\n  }, {\n    key: \"getContainer\",\n    value: function getContainer() {\n      return this.container;\n    }\n\n    /**\n     * Method returning the renderer's graph.\n     *\n     * @return {Graph}\n     */\n  }, {\n    key: \"getGraph\",\n    value: function getGraph() {\n      return this.graph;\n    }\n\n    /**\n     * Method used to set the renderer's graph.\n     *\n     * @return {Graph}\n     */\n  }, {\n    key: \"setGraph\",\n    value: function setGraph(graph) {\n      if (graph === this.graph) return;\n\n      // Unbinding handlers on the current graph\n      this.unbindGraphHandlers();\n      if (this.checkEdgesEventsFrame !== null) {\n        cancelAnimationFrame(this.checkEdgesEventsFrame);\n        this.checkEdgesEventsFrame = null;\n      }\n\n      // Installing new graph\n      this.graph = graph;\n\n      // Binding new handlers\n      this.bindGraphHandlers();\n\n      // Re-rendering now to avoid discrepancies from now to next frame\n      this.refresh();\n    }\n\n    /**\n     * Method returning the mouse captor.\n     *\n     * @return {MouseCaptor}\n     */\n  }, {\n    key: \"getMouseCaptor\",\n    value: function getMouseCaptor() {\n      return this.mouseCaptor;\n    }\n\n    /**\n     * Method returning the touch captor.\n     *\n     * @return {TouchCaptor}\n     */\n  }, {\n    key: \"getTouchCaptor\",\n    value: function getTouchCaptor() {\n      return this.touchCaptor;\n    }\n\n    /**\n     * Method returning the current renderer's dimensions.\n     *\n     * @return {Dimensions}\n     */\n  }, {\n    key: \"getDimensions\",\n    value: function getDimensions() {\n      return {\n        width: this.width,\n        height: this.height\n      };\n    }\n\n    /**\n     * Method returning the current graph's dimensions.\n     *\n     * @return {Dimensions}\n     */\n  }, {\n    key: \"getGraphDimensions\",\n    value: function getGraphDimensions() {\n      var extent = this.customBBox || this.nodeExtent;\n      return {\n        width: extent.x[1] - extent.x[0] || 1,\n        height: extent.y[1] - extent.y[0] || 1\n      };\n    }\n\n    /**\n     * Method used to get all the sigma node attributes.\n     * It's usefull for example to get the position of a node\n     * and to get values that are set by the nodeReducer\n     *\n     * @param  {string} key - The node's key.\n     * @return {NodeDisplayData | undefined} A copy of the desired node's attribute or undefined if not found\n     */\n  }, {\n    key: \"getNodeDisplayData\",\n    value: function getNodeDisplayData(key) {\n      var node = this.nodeDataCache[key];\n      return node ? Object.assign({}, node) : undefined;\n    }\n\n    /**\n     * Method used to get all the sigma edge attributes.\n     * It's useful for example to get values that are set by the edgeReducer.\n     *\n     * @param  {string} key - The edge's key.\n     * @return {EdgeDisplayData | undefined} A copy of the desired edge's attribute or undefined if not found\n     */\n  }, {\n    key: \"getEdgeDisplayData\",\n    value: function getEdgeDisplayData(key) {\n      var edge = this.edgeDataCache[key];\n      return edge ? Object.assign({}, edge) : undefined;\n    }\n\n    /**\n     * Method used to get the set of currently displayed node labels.\n     *\n     * @return {Set<string>} A set of node keys whose label is displayed.\n     */\n  }, {\n    key: \"getNodeDisplayedLabels\",\n    value: function getNodeDisplayedLabels() {\n      return new Set(this.displayedNodeLabels);\n    }\n\n    /**\n     * Method used to get the set of currently displayed edge labels.\n     *\n     * @return {Set<string>} A set of edge keys whose label is displayed.\n     */\n  }, {\n    key: \"getEdgeDisplayedLabels\",\n    value: function getEdgeDisplayedLabels() {\n      return new Set(this.displayedEdgeLabels);\n    }\n\n    /**\n     * Method returning a copy of the settings collection.\n     *\n     * @return {Settings} A copy of the settings collection.\n     */\n  }, {\n    key: \"getSettings\",\n    value: function getSettings() {\n      return (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, this.settings);\n    }\n\n    /**\n     * Method returning the current value for a given setting key.\n     *\n     * @param  {string} key - The setting key to get.\n     * @return {any} The value attached to this setting key or undefined if not found\n     */\n  }, {\n    key: \"getSetting\",\n    value: function getSetting(key) {\n      return this.settings[key];\n    }\n\n    /**\n     * Method setting the value of a given setting key. Note that this will schedule\n     * a new render next frame.\n     *\n     * @param  {string} key - The setting key to set.\n     * @param  {any}    value - The value to set.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setSetting\",\n    value: function setSetting(key, value) {\n      this.settings[key] = value;\n      (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.validateSettings)(this.settings);\n      this.handleSettingsUpdate();\n      this.scheduleRefresh();\n      return this;\n    }\n\n    /**\n     * Method updating the value of a given setting key using the provided function.\n     * Note that this will schedule a new render next frame.\n     *\n     * @param  {string}   key     - The setting key to set.\n     * @param  {function} updater - The update function.\n     * @return {Sigma}\n     */\n  }, {\n    key: \"updateSetting\",\n    value: function updateSetting(key, updater) {\n      this.settings[key] = updater(this.settings[key]);\n      (0,_settings_dist_sigma_settings_esm_js__WEBPACK_IMPORTED_MODULE_1__.validateSettings)(this.settings);\n      this.handleSettingsUpdate();\n      this.scheduleRefresh();\n      return this;\n    }\n\n    /**\n     * Method used to resize the renderer.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"resize\",\n    value: function resize() {\n      var previousWidth = this.width,\n        previousHeight = this.height;\n      this.width = this.container.offsetWidth;\n      this.height = this.container.offsetHeight;\n      this.pixelRatio = (0,_normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.g)();\n      if (this.width === 0) {\n        if (this.settings.allowInvalidContainer) this.width = 1;else throw new Error(\"Sigma: Container has no width. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n      }\n      if (this.height === 0) {\n        if (this.settings.allowInvalidContainer) this.height = 1;else throw new Error(\"Sigma: Container has no height. You can set the allowInvalidContainer setting to true to stop seeing this error.\");\n      }\n\n      // If nothing has changed, we can stop right here\n      if (previousWidth === this.width && previousHeight === this.height) return this;\n      this.emit(\"resize\");\n\n      // Sizing dom elements\n      for (var id in this.elements) {\n        var element = this.elements[id];\n        element.style.width = this.width + \"px\";\n        element.style.height = this.height + \"px\";\n      }\n\n      // Sizing canvas contexts\n      for (var _id in this.canvasContexts) {\n        this.elements[_id].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n        this.elements[_id].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n        if (this.pixelRatio !== 1) this.canvasContexts[_id].scale(this.pixelRatio, this.pixelRatio);\n      }\n\n      // Sizing WebGL contexts\n      for (var _id2 in this.webGLContexts) {\n        this.elements[_id2].setAttribute(\"width\", this.width * this.pixelRatio + \"px\");\n        this.elements[_id2].setAttribute(\"height\", this.height * this.pixelRatio + \"px\");\n        var gl = this.webGLContexts[_id2];\n        gl.viewport(0, 0, this.width * this.pixelRatio, this.height * this.pixelRatio);\n\n        // Clear picking texture if needed\n        if (this.pickingLayers.has(_id2)) {\n          var currentTexture = this.textures[_id2];\n          if (currentTexture) gl.deleteTexture(currentTexture);\n        }\n      }\n      return this;\n    }\n\n    /**\n     * Method used to clear all the canvases.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.webGLContexts.nodes.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n      this.webGLContexts.nodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.webGLContexts.edges.bindFramebuffer(WebGLRenderingContext.FRAMEBUFFER, null);\n      this.webGLContexts.edges.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.webGLContexts.hoverNodes.clear(WebGLRenderingContext.COLOR_BUFFER_BIT);\n      this.canvasContexts.labels.clearRect(0, 0, this.width, this.height);\n      this.canvasContexts.hovers.clearRect(0, 0, this.width, this.height);\n      this.canvasContexts.edgeLabels.clearRect(0, 0, this.width, this.height);\n      return this;\n    }\n\n    /**\n     * Method used to refresh, i.e. force the renderer to reprocess graph\n     * data and render, but keep the state.\n     * - if a partialGraph is provided, we only reprocess those nodes & edges.\n     * - if schedule is TRUE, we schedule a render instead of sync render\n     * - if skipIndexation is TRUE, then labelGrid & program indexation are skipped (can be used if you haven't modify x, y, zIndex & size)\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"refresh\",\n    value: function refresh(opts) {\n      var _this9 = this;\n      var skipIndexation = (opts === null || opts === void 0 ? void 0 : opts.skipIndexation) !== undefined ? opts === null || opts === void 0 ? void 0 : opts.skipIndexation : false;\n      var schedule = (opts === null || opts === void 0 ? void 0 : opts.schedule) !== undefined ? opts.schedule : false;\n      var fullRefresh = !opts || !opts.partialGraph;\n      if (fullRefresh) {\n        // Re-index graph data\n        this.clearEdgeIndices();\n        this.clearNodeIndices();\n        this.graph.forEachNode(function (node) {\n          return _this9.addNode(node);\n        });\n        this.graph.forEachEdge(function (edge) {\n          return _this9.addEdge(edge);\n        });\n      } else {\n        var _opts$partialGraph, _opts$partialGraph2;\n        var nodes = ((_opts$partialGraph = opts.partialGraph) === null || _opts$partialGraph === void 0 ? void 0 : _opts$partialGraph.nodes) || [];\n        for (var i = 0, l = (nodes === null || nodes === void 0 ? void 0 : nodes.length) || 0; i < l; i++) {\n          var node = nodes[i];\n          // Recompute node's data (ie. apply reducer)\n          this.updateNode(node);\n          // Add node to the program if layout is unchanged.\n          // otherwise it will be done in the process function\n          if (skipIndexation) {\n            var programIndex = this.nodeProgramIndex[node];\n            if (programIndex === undefined) throw new Error(\"Sigma: node \\\"\".concat(node, \"\\\" can't be repaint\"));\n            this.addNodeToProgram(node, this.nodeIndices[node], programIndex);\n          }\n        }\n        var edges = (opts === null || opts === void 0 || (_opts$partialGraph2 = opts.partialGraph) === null || _opts$partialGraph2 === void 0 ? void 0 : _opts$partialGraph2.edges) || [];\n        for (var _i4 = 0, _l4 = edges.length; _i4 < _l4; _i4++) {\n          var edge = edges[_i4];\n          // Recompute edge's data (ie. apply reducer)\n          this.updateEdge(edge);\n          // Add edge to the program\n          // otherwise it will be done in the process function\n          if (skipIndexation) {\n            var _programIndex = this.edgeProgramIndex[edge];\n            if (_programIndex === undefined) throw new Error(\"Sigma: edge \\\"\".concat(edge, \"\\\" can't be repaint\"));\n            this.addEdgeToProgram(edge, this.edgeIndices[edge], _programIndex);\n          }\n        }\n      }\n\n      // Do we need to call the process function ?\n      if (fullRefresh || !skipIndexation) this.needToProcess = true;\n      if (schedule) this.scheduleRender();else this.render();\n      return this;\n    }\n\n    /**\n     * Method used to schedule a render at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounces refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"scheduleRender\",\n    value: function scheduleRender() {\n      var _this10 = this;\n      if (!this.renderFrame) {\n        this.renderFrame = requestAnimationFrame(function () {\n          _this10.render();\n        });\n      }\n      return this;\n    }\n\n    /**\n     * Method used to schedule a refresh (i.e. fully reprocess graph data and render)\n     * at the next available frame.\n     * This method can be safely called on a same frame because it basically\n     * debounces refresh to the next frame.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"scheduleRefresh\",\n    value: function scheduleRefresh(opts) {\n      return this.refresh((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)((0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, opts), {}, {\n        schedule: true\n      }));\n    }\n\n    /**\n     * Method used to (un)zoom, while preserving the position of a viewport point.\n     * Used for instance to zoom \"on the mouse cursor\".\n     *\n     * @param viewportTarget\n     * @param newRatio\n     * @return {CameraState}\n     */\n  }, {\n    key: \"getViewportZoomedState\",\n    value: function getViewportZoomedState(viewportTarget, newRatio) {\n      var _this$camera$getState = this.camera.getState(),\n        ratio = _this$camera$getState.ratio,\n        angle = _this$camera$getState.angle,\n        x = _this$camera$getState.x,\n        y = _this$camera$getState.y;\n\n      // TODO: handle max zoom\n      var ratioDiff = newRatio / ratio;\n      var center = {\n        x: this.width / 2,\n        y: this.height / 2\n      };\n      var graphMousePosition = this.viewportToFramedGraph(viewportTarget);\n      var graphCenterPosition = this.viewportToFramedGraph(center);\n      return {\n        angle: angle,\n        x: (graphMousePosition.x - graphCenterPosition.x) * (1 - ratioDiff) + x,\n        y: (graphMousePosition.y - graphCenterPosition.y) * (1 - ratioDiff) + y,\n        ratio: newRatio\n      };\n    }\n\n    /**\n     * Method returning the abstract rectangle containing the graph according\n     * to the camera's state.\n     *\n     * @return {object} - The view's rectangle.\n     */\n  }, {\n    key: \"viewRectangle\",\n    value: function viewRectangle() {\n      // TODO: reduce relative margin?\n      var marginX = 0 * this.width / 8,\n        marginY = 0 * this.height / 8;\n      var p1 = this.viewportToFramedGraph({\n          x: 0 - marginX,\n          y: 0 - marginY\n        }),\n        p2 = this.viewportToFramedGraph({\n          x: this.width + marginX,\n          y: 0 - marginY\n        }),\n        h = this.viewportToFramedGraph({\n          x: 0,\n          y: this.height + marginY\n        });\n      return {\n        x1: p1.x,\n        y1: p1.y,\n        x2: p2.x,\n        y2: p2.y,\n        height: p2.y - h.y\n      };\n    }\n\n    /**\n     * Method returning the coordinates of a point from the framed graph system to the viewport system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n  }, {\n    key: \"framedGraphToViewport\",\n    value: function framedGraphToViewport(coordinates) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !!override.graphDimensions;\n      var matrix = override.matrix ? override.matrix : recomputeMatrix ? (0,_normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0) : this.matrix;\n      var viewportPos = (0,_normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.f)(matrix, coordinates);\n      return {\n        x: (1 + viewportPos.x) * this.width / 2,\n        y: (1 - viewportPos.y) * this.height / 2\n      };\n    }\n\n    /**\n     * Method returning the coordinates of a point from the viewport system to the framed graph system. It allows\n     * overriding anything that is used to get the translation matrix, or even the matrix itself.\n     *\n     * Be careful if overriding dimensions, padding or cameraState, as the computation of the matrix is not the lightest\n     * of computations.\n     */\n  }, {\n    key: \"viewportToFramedGraph\",\n    value: function viewportToFramedGraph(coordinates) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var recomputeMatrix = !!override.cameraState || !!override.viewportDimensions || !override.graphDimensions;\n      var invMatrix = override.matrix ? override.matrix : recomputeMatrix ? (0,_normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.m)(override.cameraState || this.camera.getState(), override.viewportDimensions || this.getDimensions(), override.graphDimensions || this.getGraphDimensions(), override.padding || this.getSetting(\"stagePadding\") || 0, true) : this.invMatrix;\n      var res = (0,_normalization_8e7b2e97_esm_js__WEBPACK_IMPORTED_MODULE_6__.f)(invMatrix, {\n        x: coordinates.x / this.width * 2 - 1,\n        y: 1 - coordinates.y / this.height * 2\n      });\n      if (isNaN(res.x)) res.x = 0;\n      if (isNaN(res.y)) res.y = 0;\n      return res;\n    }\n\n    /**\n     * Method used to translate a point's coordinates from the viewport system (pixel distance from the top-left of the\n     * stage) to the graph system (the reference system of data as they are in the given graph instance).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  viewportPoint\n     * @param {CoordinateConversionOverride} override\n     */\n  }, {\n    key: \"viewportToGraph\",\n    value: function viewportToGraph(viewportPoint) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.normalizationFunction.inverse(this.viewportToFramedGraph(viewportPoint, override));\n    }\n\n    /**\n     * Method used to translate a point's coordinates from the graph system (the reference system of data as they are in\n     * the given graph instance) to the viewport system (pixel distance from the top-left of the stage).\n     *\n     * This method accepts an optional camera which can be useful if you need to translate coordinates\n     * based on a different view than the one being currently being displayed on screen.\n     *\n     * @param {Coordinates}                  graphPoint\n     * @param {CoordinateConversionOverride} override\n     */\n  }, {\n    key: \"graphToViewport\",\n    value: function graphToViewport(graphPoint) {\n      var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.framedGraphToViewport(this.normalizationFunction(graphPoint), override);\n    }\n\n    /**\n     * Method returning the distance multiplier between the graph system and the\n     * viewport system.\n     */\n  }, {\n    key: \"getGraphToViewportRatio\",\n    value: function getGraphToViewportRatio() {\n      var graphP1 = {\n        x: 0,\n        y: 0\n      };\n      var graphP2 = {\n        x: 1,\n        y: 1\n      };\n      var graphD = Math.sqrt(Math.pow(graphP1.x - graphP2.x, 2) + Math.pow(graphP1.y - graphP2.y, 2));\n      var viewportP1 = this.graphToViewport(graphP1);\n      var viewportP2 = this.graphToViewport(graphP2);\n      var viewportD = Math.sqrt(Math.pow(viewportP1.x - viewportP2.x, 2) + Math.pow(viewportP1.y - viewportP2.y, 2));\n      return viewportD / graphD;\n    }\n\n    /**\n     * Method returning the graph's bounding box.\n     *\n     * @return {{ x: Extent, y: Extent }}\n     */\n  }, {\n    key: \"getBBox\",\n    value: function getBBox() {\n      return this.nodeExtent;\n    }\n\n    /**\n     * Method returning the graph's custom bounding box, if any.\n     *\n     * @return {{ x: Extent, y: Extent } | null}\n     */\n  }, {\n    key: \"getCustomBBox\",\n    value: function getCustomBBox() {\n      return this.customBBox;\n    }\n\n    /**\n     * Method used to override the graph's bounding box with a custom one. Give `null` as the argument to stop overriding.\n     *\n     * @return {Sigma}\n     */\n  }, {\n    key: \"setCustomBBox\",\n    value: function setCustomBBox(customBBox) {\n      this.customBBox = customBBox;\n      this.scheduleRender();\n      return this;\n    }\n\n    /**\n     * Method used to shut the container & release event listeners.\n     *\n     * @return {undefined}\n     */\n  }, {\n    key: \"kill\",\n    value: function kill() {\n      // Emitting \"kill\" events so that plugins and such can cleanup\n      this.emit(\"kill\");\n\n      // Releasing events\n      this.removeAllListeners();\n\n      // Releasing camera handlers\n      this.unbindCameraHandlers();\n\n      // Releasing DOM events & captors\n      window.removeEventListener(\"resize\", this.activeListeners.handleResize);\n      this.mouseCaptor.kill();\n      this.touchCaptor.kill();\n\n      // Releasing graph handlers\n      this.unbindGraphHandlers();\n\n      // Releasing cache & state\n      this.clearIndices();\n      this.clearState();\n      this.nodeDataCache = {};\n      this.edgeDataCache = {};\n      this.highlightedNodes.clear();\n\n      // Clearing frames\n      if (this.renderFrame) {\n        cancelAnimationFrame(this.renderFrame);\n        this.renderFrame = null;\n      }\n      if (this.renderHighlightedNodesFrame) {\n        cancelAnimationFrame(this.renderHighlightedNodesFrame);\n        this.renderHighlightedNodesFrame = null;\n      }\n\n      // Destroying WebGL contexts\n      for (var id in this.webGLContexts) {\n        var _context$getExtension;\n        var context = this.webGLContexts[id];\n        (_context$getExtension = context.getExtension(\"WEBGL_lose_context\")) === null || _context$getExtension === void 0 || _context$getExtension.loseContext();\n      }\n\n      // Destroying canvases\n      var container = this.container;\n      while (container.firstChild) container.removeChild(container.firstChild);\n\n      // Destroying remaining collections\n      this.canvasContexts = {};\n      this.webGLContexts = {};\n      this.elements = {};\n\n      // Kill programs:\n      for (var type in this.nodePrograms) {\n        this.nodePrograms[type].kill();\n      }\n      for (var _type5 in this.nodeHoverPrograms) {\n        this.nodeHoverPrograms[_type5].kill();\n      }\n      for (var _type6 in this.edgePrograms) {\n        this.edgePrograms[_type6].kill();\n      }\n      this.nodePrograms = {};\n      this.nodeHoverPrograms = {};\n      this.edgePrograms = {};\n    }\n\n    /**\n     * Method used to scale the given size according to the camera's ratio, i.e.\n     * zooming state.\n     *\n     * @param  {number?} size -        The size to scale (node size, edge thickness etc.).\n     * @param  {number?} cameraRatio - A camera ratio (defaults to the actual camera ratio).\n     * @return {number}              - The scaled size.\n     */\n  }, {\n    key: \"scaleSize\",\n    value: function scaleSize() {\n      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var cameraRatio = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.camera.ratio;\n      return size / this.settings.zoomToSizeRatioFunction(cameraRatio) * (this.getSetting(\"itemSizesReference\") === \"positions\" ? cameraRatio * this.graphToViewportRatio : 1);\n    }\n\n    /**\n     * Method that returns the collection of all used canvases.\n     * At the moment, the instantiated canvases are the following, and in the\n     * following order in the DOM:\n     * - `edges`\n     * - `nodes`\n     * - `edgeLabels`\n     * - `labels`\n     * - `hovers`\n     * - `hoverNodes`\n     * - `mouse`\n     *\n     * @return {PlainObject<HTMLCanvasElement>} - The collection of canvases.\n     */\n  }, {\n    key: \"getCanvases\",\n    value: function getCanvases() {\n      return (0,_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_5__.a)({}, this.elements);\n    }\n  }]);\n  return Sigma;\n}(_types_dist_sigma_types_esm_js__WEBPACK_IMPORTED_MODULE_0__.TypedEventEmitter);\n\n/**\n * Sigma.js Library Endpoint\n * =========================\n *\n * The library endpoint.\n * @module\n */\nvar Sigma = Sigma$1;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2lnbWEvZGlzdC9zaWdtYS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFtSjtBQUMvRDtBQUNmO0FBQ3FPO0FBQzFJO0FBQ3JFO0FBQ3RDO0FBQ3JDO0FBQ21COztBQUVuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDREQUFTO0FBQ1g7QUFDQTtBQUNBLElBQUksNERBQWU7QUFDbkIsWUFBWSw0REFBVTs7QUFFdEI7QUFDQSxJQUFJLHlEQUFlLENBQUMsNERBQXNCO0FBQzFDLElBQUkseURBQWUsQ0FBQyw0REFBc0I7QUFDMUMsSUFBSSx5REFBZSxDQUFDLDREQUFzQjtBQUMxQyxJQUFJLHlEQUFlLENBQUMsNERBQXNCO0FBQzFDLElBQUkseURBQWUsQ0FBQyw0REFBc0I7QUFDMUMsSUFBSSx5REFBZSxDQUFDLDREQUFzQjtBQUMxQyxJQUFJLHlEQUFlLENBQUMsNERBQXNCO0FBQzFDLElBQUkseURBQWUsQ0FBQyw0REFBc0I7QUFDMUMsSUFBSSx5REFBZSxDQUFDLDREQUFzQjtBQUMxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxFQUFFLDREQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztB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QTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCO0FBQ2hCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEIsZ0JBQWdCLDZCQUE2QjtBQUM3QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWE7QUFDN0I7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLGFBQWEseURBQWMsR0FBRztBQUM5Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsS0FBSztBQUNyQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQixRQUFRO0FBQ3hCLGdCQUFnQjtBQUNoQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNGQUFnQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQixVQUFVO0FBQzFCLGdCQUFnQjtBQUNoQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxNQUFNLHNGQUFnQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGlFQUFhO0FBQ3JDO0FBQ0EsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBLCtGQUErRixPQUFPO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxXQUFXO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsMEJBQTBCLHlEQUFjLENBQUMseURBQWMsR0FBRyxXQUFXO0FBQ3JFO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxpRUFBZ0I7QUFDekYsd0JBQXdCLGlFQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsaUVBQWdCO0FBQzVGLGdCQUFnQixpRUFBWTtBQUM1QjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4QkFBOEI7QUFDN0MsZUFBZSw4QkFBOEI7QUFDN0M7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsOEJBQThCO0FBQzdDLGVBQWUsOEJBQThCO0FBQzdDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQix1QkFBdUI7QUFDekM7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0IsU0FBUztBQUN6QixnQkFBZ0IscUJBQXFCO0FBQ3JDO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0NBQWdDO0FBQ2hEO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxhQUFhLHlEQUFjLEdBQUc7QUFDOUI7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDLENBQUMsNkVBQWlCOztBQUVuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVnRiIsInNvdXJjZXMiOlsid2VicGFjazovL3Nwb25zYXJ1Ly4vbm9kZV9tb2R1bGVzL3NpZ21hL2Rpc3Qvc2lnbWEuZXNtLmpzPzc3ZGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgXyBhcyBfaW5oZXJpdHMsIGEgYXMgX2NsYXNzQ2FsbENoZWNrLCBiIGFzIF9jYWxsU3VwZXIsIGMgYXMgX2Fzc2VydFRoaXNJbml0aWFsaXplZCwgZCBhcyBfY3JlYXRlQ2xhc3MgfSBmcm9tICcuL2luaGVyaXRzLThmYmRlZGI1LmVzbS5qcyc7XG5pbXBvcnQgeyBfIGFzIF9kZWZpbmVQcm9wZXJ0eSwgYSBhcyBfb2JqZWN0U3ByZWFkMiB9IGZyb20gJy4vaW5kZXgtMjlhY2M4ODMuZXNtLmpzJztcbmltcG9ydCB7IFR5cGVkRXZlbnRFbWl0dGVyIH0gZnJvbSAnLi4vdHlwZXMvZGlzdC9zaWdtYS10eXBlcy5lc20uanMnO1xuaW1wb3J0IHsgQSBhcyBBTklNQVRFX0RFRkFVTFRTLCBlIGFzIGVhc2luZ3MsIGkgYXMgaWRlbnRpdHksIGMgYXMgY3JlYXRlTm9ybWFsaXphdGlvbkZ1bmN0aW9uLCBnIGFzIGdldFBpeGVsUmF0aW8sIHYgYXMgdmFsaWRhdGVHcmFwaCwgYSBhcyBjcmVhdGVFbGVtZW50LCBiIGFzIGdyYXBoRXh0ZW50LCBtIGFzIG1hdHJpeEZyb21DYW1lcmEsIHogYXMgekluZGV4T3JkZXJpbmcsIGQgYXMgZ2V0TWF0cml4SW1wYWN0LCBmIGFzIG11bHRpcGx5VmVjMiB9IGZyb20gJy4vbm9ybWFsaXphdGlvbi04ZTdiMmU5Ny5lc20uanMnO1xuaW1wb3J0IHsgXyBhcyBfc2xpY2VkVG9BcnJheSwgYSBhcyBfYXJyYXlMaWtlVG9BcnJheSwgYiBhcyBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXksIGcgYXMgZ2V0UGl4ZWxDb2xvciwgYyBhcyBjb2xvclRvSW5kZXggfSBmcm9tICcuL2NvbG9ycy0yZjZkMTdmMC5lc20uanMnO1xuaW1wb3J0IHsgcmVzb2x2ZVNldHRpbmdzLCB2YWxpZGF0ZVNldHRpbmdzIH0gZnJvbSAnLi4vc2V0dGluZ3MvZGlzdC9zaWdtYS1zZXR0aW5ncy5lc20uanMnO1xuaW1wb3J0IHsgZSBhcyBleHRlbmQgfSBmcm9tICcuL2RhdGEtMzE5OTBhNzYuZXNtLmpzJztcbmltcG9ydCAnZXZlbnRzJztcbmltcG9ydCAnZ3JhcGhvbG9neS11dGlscy9pcy1ncmFwaCc7XG5cbi8qKlxuICogRGVmYXVsdHMuXG4gKi9cbnZhciBERUZBVUxUX1pPT01JTkdfUkFUSU8gPSAxLjU7XG5cbi8qKlxuICogRXZlbnQgdHlwZXMuXG4gKi9cbi8qKlxuICogQ2FtZXJhIGNsYXNzXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDYW1lcmEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UeXBlZEV2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoQ2FtZXJhLCBfVHlwZWRFdmVudEVtaXR0ZXIpO1xuICBmdW5jdGlvbiBDYW1lcmEoKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDYW1lcmEpO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBDYW1lcmEpO1xuXG4gICAgLy8gU3RhdGVcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwieFwiLCAwLjUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ5XCIsIDAuNSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImFuZ2xlXCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJyYXRpb1wiLCAxKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwibWluUmF0aW9cIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm1heFJhdGlvXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJuZXh0RnJhbWVcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInByZXZpb3VzU3RhdGVcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImVuYWJsZWRcIiwgdHJ1ZSk7XG4gICAgX3RoaXMucHJldmlvdXNTdGF0ZSA9IF90aGlzLmdldFN0YXRlKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXRpYyBtZXRob2QgdXNlZCB0byBjcmVhdGUgYSBDYW1lcmEgb2JqZWN0IHdpdGggYSBnaXZlbiBzdGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlXG4gICAqIEByZXR1cm4ge0NhbWVyYX1cbiAgICovXG4gIF9jcmVhdGVDbGFzcyhDYW1lcmEsIFt7XG4gICAga2V5OiBcImVuYWJsZVwiLFxuICAgIHZhbHVlOlxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGVuYWJsZSB0aGUgY2FtZXJhLlxuICAgICAqXG4gICAgICogQHJldHVybiB7Q2FtZXJhfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVuYWJsZSgpIHtcbiAgICAgIHRoaXMuZW5hYmxlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBkaXNhYmxlIHRoZSBjYW1lcmEuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtDYW1lcmF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZGlzYWJsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkaXNhYmxlKCkge1xuICAgICAgdGhpcy5lbmFibGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byByZXRyaWV2ZSB0aGUgY2FtZXJhJ3MgY3VycmVudCBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRTdGF0ZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHRoaXMueCxcbiAgICAgICAgeTogdGhpcy55LFxuICAgICAgICBhbmdsZTogdGhpcy5hbmdsZSxcbiAgICAgICAgcmF0aW86IHRoaXMucmF0aW9cbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gY2hlY2sgd2hldGhlciB0aGUgY2FtZXJhIGhhcyB0aGUgZ2l2ZW4gc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiaGFzU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFzU3RhdGUoc3RhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnggPT09IHN0YXRlLnggJiYgdGhpcy55ID09PSBzdGF0ZS55ICYmIHRoaXMucmF0aW8gPT09IHN0YXRlLnJhdGlvICYmIHRoaXMuYW5nbGUgPT09IHN0YXRlLmFuZ2xlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJldHJpZXZlIHRoZSBjYW1lcmEncyBwcmV2aW91cyBzdGF0ZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge29iamVjdH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRQcmV2aW91c1N0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFByZXZpb3VzU3RhdGUoKSB7XG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnByZXZpb3VzU3RhdGU7XG4gICAgICBpZiAoIXN0YXRlKSByZXR1cm4gbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHg6IHN0YXRlLngsXG4gICAgICAgIHk6IHN0YXRlLnksXG4gICAgICAgIGFuZ2xlOiBzdGF0ZS5hbmdsZSxcbiAgICAgICAgcmF0aW86IHN0YXRlLnJhdGlvXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGNoZWNrIG1pblJhdGlvIGFuZCBtYXhSYXRpbyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmF0aW9cbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Qm91bmRlZFJhdGlvXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldEJvdW5kZWRSYXRpbyhyYXRpbykge1xuICAgICAgdmFyIHIgPSByYXRpbztcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5taW5SYXRpbyA9PT0gXCJudW1iZXJcIikgciA9IE1hdGgubWF4KHIsIHRoaXMubWluUmF0aW8pO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm1heFJhdGlvID09PSBcIm51bWJlclwiKSByID0gTWF0aC5taW4ociwgdGhpcy5tYXhSYXRpbyk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBjaGVjayB2YXJpb3VzIHRoaW5ncyB0byByZXR1cm4gYSBsZWdpdCBzdGF0ZSBjYW5kaWRhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3RhdGVcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmFsaWRhdGVTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXRlKHN0YXRlKSB7XG4gICAgICB2YXIgdmFsaWRhdGVkU3RhdGUgPSB7fTtcbiAgICAgIGlmICh0eXBlb2Ygc3RhdGUueCA9PT0gXCJudW1iZXJcIikgdmFsaWRhdGVkU3RhdGUueCA9IHN0YXRlLng7XG4gICAgICBpZiAodHlwZW9mIHN0YXRlLnkgPT09IFwibnVtYmVyXCIpIHZhbGlkYXRlZFN0YXRlLnkgPSBzdGF0ZS55O1xuICAgICAgaWYgKHR5cGVvZiBzdGF0ZS5hbmdsZSA9PT0gXCJudW1iZXJcIikgdmFsaWRhdGVkU3RhdGUuYW5nbGUgPSBzdGF0ZS5hbmdsZTtcbiAgICAgIGlmICh0eXBlb2Ygc3RhdGUucmF0aW8gPT09IFwibnVtYmVyXCIpIHZhbGlkYXRlZFN0YXRlLnJhdGlvID0gdGhpcy5nZXRCb3VuZGVkUmF0aW8oc3RhdGUucmF0aW8pO1xuICAgICAgcmV0dXJuIHZhbGlkYXRlZFN0YXRlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGNoZWNrIHdoZXRoZXIgdGhlIGNhbWVyYSBpcyBjdXJyZW50bHkgYmVpbmcgYW5pbWF0ZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImlzQW5pbWF0ZWRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaXNBbmltYXRlZCgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMubmV4dEZyYW1lO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHNldCB0aGUgY2FtZXJhJ3Mgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9IHN0YXRlIC0gTmV3IHN0YXRlLlxuICAgICAqIEByZXR1cm4ge0NhbWVyYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBUT0RPOiB1cGRhdGUgYnkgZnVuY3Rpb25cblxuICAgICAgLy8gS2VlcGluZyB0cmFjayBvZiBsYXN0IHN0YXRlXG4gICAgICB0aGlzLnByZXZpb3VzU3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XG4gICAgICB2YXIgdmFsaWRTdGF0ZSA9IHRoaXMudmFsaWRhdGVTdGF0ZShzdGF0ZSk7XG4gICAgICBpZiAodHlwZW9mIHZhbGlkU3RhdGUueCA9PT0gXCJudW1iZXJcIikgdGhpcy54ID0gdmFsaWRTdGF0ZS54O1xuICAgICAgaWYgKHR5cGVvZiB2YWxpZFN0YXRlLnkgPT09IFwibnVtYmVyXCIpIHRoaXMueSA9IHZhbGlkU3RhdGUueTtcbiAgICAgIGlmICh0eXBlb2YgdmFsaWRTdGF0ZS5hbmdsZSA9PT0gXCJudW1iZXJcIikgdGhpcy5hbmdsZSA9IHZhbGlkU3RhdGUuYW5nbGU7XG4gICAgICBpZiAodHlwZW9mIHZhbGlkU3RhdGUucmF0aW8gPT09IFwibnVtYmVyXCIpIHRoaXMucmF0aW8gPSB2YWxpZFN0YXRlLnJhdGlvO1xuXG4gICAgICAvLyBFbWl0dGluZ1xuICAgICAgaWYgKCF0aGlzLmhhc1N0YXRlKHRoaXMucHJldmlvdXNTdGF0ZSkpIHRoaXMuZW1pdChcInVwZGF0ZWRcIiwgdGhpcy5nZXRTdGF0ZSgpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHVwZGF0ZSB0aGUgY2FtZXJhJ3Mgc3RhdGUgdXNpbmcgYSBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge2Z1bmN0aW9ufSB1cGRhdGVyIC0gVXBkYXRlZCBmdW5jdGlvbiB0YWtpbmcgY3VycmVudCBzdGF0ZSBhbmRcbiAgICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybmluZyBuZXh0IHN0YXRlLlxuICAgICAqIEByZXR1cm4ge0NhbWVyYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTdGF0ZSh1cGRhdGVyKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHVwZGF0ZXIodGhpcy5nZXRTdGF0ZSgpKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBhbmltYXRlIHRoZSBjYW1lcmEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICBzdGF0ZSAgICAgIC0gU3RhdGUgdG8gcmVhY2ggZXZlbnR1YWxseS5cbiAgICAgKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgICAgICAgICAgICBvcHRzICAgICAgIC0gT3B0aW9uczpcbiAgICAgKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgICAgICAgICAgICAgIGR1cmF0aW9uIC0gRHVyYXRpb24gb2YgdGhlIGFuaW1hdGlvbi5cbiAgICAgKiBAcGFyYW0gIHtzdHJpbmcgfCBudW1iZXIgPT4gbnVtYmVyfSAgIGVhc2luZyAgIC0gRWFzaW5nIGZ1bmN0aW9uIG9yIG5hbWUgb2YgYW4gZXhpc3Rpbmcgb25lXG4gICAgICogQHBhcmFtICB7ZnVuY3Rpb259ICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgICAtIENhbGxiYWNrXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYW5pbWF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlKHN0YXRlLCBvcHRzLCBjYWxsYmFjaykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgdmFyIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBBTklNQVRFX0RFRkFVTFRTLCBvcHRzKTtcbiAgICAgIHZhciB2YWxpZFN0YXRlID0gdGhpcy52YWxpZGF0ZVN0YXRlKHN0YXRlKTtcbiAgICAgIHZhciBlYXNpbmcgPSB0eXBlb2Ygb3B0aW9ucy5lYXNpbmcgPT09IFwiZnVuY3Rpb25cIiA/IG9wdGlvbnMuZWFzaW5nIDogZWFzaW5nc1tvcHRpb25zLmVhc2luZ107XG5cbiAgICAgIC8vIFN0YXRlXG4gICAgICB2YXIgc3RhcnQgPSBEYXRlLm5vdygpLFxuICAgICAgICBpbml0aWFsU3RhdGUgPSB0aGlzLmdldFN0YXRlKCk7XG5cbiAgICAgIC8vIEZ1bmN0aW9uIHBlcmZvcm1pbmcgdGhlIGFuaW1hdGlvblxuICAgICAgdmFyIGZuID0gZnVuY3Rpb24gZm4oKSB7XG4gICAgICAgIHZhciB0ID0gKERhdGUubm93KCkgLSBzdGFydCkgLyBvcHRpb25zLmR1cmF0aW9uO1xuXG4gICAgICAgIC8vIFRoZSBhbmltYXRpb24gaXMgb3ZlcjpcbiAgICAgICAgaWYgKHQgPj0gMSkge1xuICAgICAgICAgIF90aGlzMi5uZXh0RnJhbWUgPSBudWxsO1xuICAgICAgICAgIF90aGlzMi5zZXRTdGF0ZSh2YWxpZFN0YXRlKTtcbiAgICAgICAgICBpZiAoX3RoaXMyLmFuaW1hdGlvbkNhbGxiYWNrKSB7XG4gICAgICAgICAgICBfdGhpczIuYW5pbWF0aW9uQ2FsbGJhY2suY2FsbChudWxsKTtcbiAgICAgICAgICAgIF90aGlzMi5hbmltYXRpb25DYWxsYmFjayA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2VmZmljaWVudCA9IGVhc2luZyh0KTtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRTdGF0ZS54ID09PSBcIm51bWJlclwiKSBuZXdTdGF0ZS54ID0gaW5pdGlhbFN0YXRlLnggKyAodmFsaWRTdGF0ZS54IC0gaW5pdGlhbFN0YXRlLngpICogY29lZmZpY2llbnQ7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRTdGF0ZS55ID09PSBcIm51bWJlclwiKSBuZXdTdGF0ZS55ID0gaW5pdGlhbFN0YXRlLnkgKyAodmFsaWRTdGF0ZS55IC0gaW5pdGlhbFN0YXRlLnkpICogY29lZmZpY2llbnQ7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsaWRTdGF0ZS5hbmdsZSA9PT0gXCJudW1iZXJcIikgbmV3U3RhdGUuYW5nbGUgPSBpbml0aWFsU3RhdGUuYW5nbGUgKyAodmFsaWRTdGF0ZS5hbmdsZSAtIGluaXRpYWxTdGF0ZS5hbmdsZSkgKiBjb2VmZmljaWVudDtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWxpZFN0YXRlLnJhdGlvID09PSBcIm51bWJlclwiKSBuZXdTdGF0ZS5yYXRpbyA9IGluaXRpYWxTdGF0ZS5yYXRpbyArICh2YWxpZFN0YXRlLnJhdGlvIC0gaW5pdGlhbFN0YXRlLnJhdGlvKSAqIGNvZWZmaWNpZW50O1xuICAgICAgICBfdGhpczIuc2V0U3RhdGUobmV3U3RhdGUpO1xuICAgICAgICBfdGhpczIubmV4dEZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZuKTtcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5uZXh0RnJhbWUpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5uZXh0RnJhbWUpO1xuICAgICAgICBpZiAodGhpcy5hbmltYXRpb25DYWxsYmFjaykgdGhpcy5hbmltYXRpb25DYWxsYmFjay5jYWxsKG51bGwpO1xuICAgICAgICB0aGlzLm5leHRGcmFtZSA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShmbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmbigpO1xuICAgICAgfVxuICAgICAgdGhpcy5hbmltYXRpb25DYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHpvb20gdGhlIGNhbWVyYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge251bWJlcnxvYmplY3R9IGZhY3Rvck9yT3B0aW9ucyAtIEZhY3RvciBvciBvcHRpb25zLlxuICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVkWm9vbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlZFpvb20oZmFjdG9yT3JPcHRpb25zKSB7XG4gICAgICBpZiAoIWZhY3Rvck9yT3B0aW9ucykge1xuICAgICAgICB0aGlzLmFuaW1hdGUoe1xuICAgICAgICAgIHJhdGlvOiB0aGlzLnJhdGlvIC8gREVGQVVMVF9aT09NSU5HX1JBVElPXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3JPck9wdGlvbnMgPT09IFwibnVtYmVyXCIpIHJldHVybiB0aGlzLmFuaW1hdGUoe1xuICAgICAgICAgIHJhdGlvOiB0aGlzLnJhdGlvIC8gZmFjdG9yT3JPcHRpb25zXG4gICAgICAgIH0pO2Vsc2UgdGhpcy5hbmltYXRlKHtcbiAgICAgICAgICByYXRpbzogdGhpcy5yYXRpbyAvIChmYWN0b3JPck9wdGlvbnMuZmFjdG9yIHx8IERFRkFVTFRfWk9PTUlOR19SQVRJTylcbiAgICAgICAgfSwgZmFjdG9yT3JPcHRpb25zKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byB1bnpvb20gdGhlIGNhbWVyYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge251bWJlcnxvYmplY3R9IGZhY3Rvck9yT3B0aW9ucyAtIEZhY3RvciBvciBvcHRpb25zLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFuaW1hdGVkVW56b29tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFuaW1hdGVkVW56b29tKGZhY3Rvck9yT3B0aW9ucykge1xuICAgICAgaWYgKCFmYWN0b3JPck9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hbmltYXRlKHtcbiAgICAgICAgICByYXRpbzogdGhpcy5yYXRpbyAqIERFRkFVTFRfWk9PTUlOR19SQVRJT1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmFjdG9yT3JPcHRpb25zID09PSBcIm51bWJlclwiKSByZXR1cm4gdGhpcy5hbmltYXRlKHtcbiAgICAgICAgICByYXRpbzogdGhpcy5yYXRpbyAqIGZhY3Rvck9yT3B0aW9uc1xuICAgICAgICB9KTtlbHNlIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgICAgcmF0aW86IHRoaXMucmF0aW8gKiAoZmFjdG9yT3JPcHRpb25zLmZhY3RvciB8fCBERUZBVUxUX1pPT01JTkdfUkFUSU8pXG4gICAgICAgIH0sIGZhY3Rvck9yT3B0aW9ucyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcmVzZXQgdGhlIGNhbWVyYS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge29iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYW5pbWF0ZWRSZXNldFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhbmltYXRlZFJlc2V0KG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuYW5pbWF0ZSh7XG4gICAgICAgIHg6IDAuNSxcbiAgICAgICAgeTogMC41LFxuICAgICAgICByYXRpbzogMSxcbiAgICAgICAgYW5nbGU6IDBcbiAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBuZXcgQ2FtZXJhIGluc3RhbmNlLCB3aXRoIHRoZSBzYW1lIHN0YXRlIGFzIHRoZSBjdXJyZW50IGNhbWVyYS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0NhbWVyYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjb3B5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHkoKSB7XG4gICAgICByZXR1cm4gQ2FtZXJhLmZyb20odGhpcy5nZXRTdGF0ZSgpKTtcbiAgICB9XG4gIH1dLCBbe1xuICAgIGtleTogXCJmcm9tXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGZyb20oc3RhdGUpIHtcbiAgICAgIHZhciBjYW1lcmEgPSBuZXcgQ2FtZXJhKCk7XG4gICAgICByZXR1cm4gY2FtZXJhLnNldFN0YXRlKHN0YXRlKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIENhbWVyYTtcbn0oVHlwZWRFdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIENhcHRvciB1dGlscyBmdW5jdGlvbnNcbiAqID09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIEV4dHJhY3QgdGhlIGxvY2FsIFggYW5kIFkgY29vcmRpbmF0ZXMgZnJvbSBhIG1vdXNlIGV2ZW50IG9yIHRvdWNoIG9iamVjdC4gSWZcbiAqIGEgRE9NIGVsZW1lbnQgaXMgZ2l2ZW4sIGl0IHVzZXMgdGhpcyBlbGVtZW50J3Mgb2Zmc2V0IHRvIGNvbXB1dGUgdGhlIHBvc2l0aW9uXG4gKiAodGhpcyBhbGxvd3MgdXNpbmcgZXZlbnRzIHRoYXQgYXJlIG5vdCBib3VuZCB0byB0aGUgY29udGFpbmVyIGl0c2VsZiBhbmRcbiAqIHN0aWxsIGhhdmUgYSBwcm9wZXIgcG9zaXRpb24pLlxuICpcbiAqIEBwYXJhbSAge2V2ZW50fSAgICAgICBlIC0gQSBtb3VzZSBldmVudCBvciB0b3VjaCBvYmplY3QuXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZG9tIC0gQSBET00gZWxlbWVudCB0byBjb21wdXRlIG9mZnNldCByZWxhdGl2ZWx5IHRvLlxuICogQHJldHVybiB7bnVtYmVyfSAgICAgIFRoZSBsb2NhbCBZIHZhbHVlIG9mIHRoZSBtb3VzZS5cbiAqL1xuZnVuY3Rpb24gZ2V0UG9zaXRpb24oZSwgZG9tKSB7XG4gIHZhciBiYm94ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICByZXR1cm4ge1xuICAgIHg6IGUuY2xpZW50WCAtIGJib3gubGVmdCxcbiAgICB5OiBlLmNsaWVudFkgLSBiYm94LnRvcFxuICB9O1xufVxuXG4vKipcbiAqIENvbnZlcnQgbW91c2UgY29vcmRzIHRvIHNpZ21hIGNvb3Jkcy5cbiAqXG4gKiBAcGFyYW0gIHtldmVudH0gICAgICAgZSAgIC0gQSBtb3VzZSBldmVudCBvciB0b3VjaCBvYmplY3QuXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZG9tIC0gQSBET00gZWxlbWVudCB0byBjb21wdXRlIG9mZnNldCByZWxhdGl2ZWx5IHRvLlxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRNb3VzZUNvb3JkcyhlLCBkb20pIHtcbiAgdmFyIHJlcyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBnZXRQb3NpdGlvbihlLCBkb20pKSwge30sIHtcbiAgICBzaWdtYURlZmF1bHRQcmV2ZW50ZWQ6IGZhbHNlLFxuICAgIHByZXZlbnRTaWdtYURlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnRTaWdtYURlZmF1bHQoKSB7XG4gICAgICByZXMuc2lnbWFEZWZhdWx0UHJldmVudGVkID0gdHJ1ZTtcbiAgICB9LFxuICAgIG9yaWdpbmFsOiBlXG4gIH0pO1xuICByZXR1cm4gcmVzO1xufVxuXG4vKipcbiAqIENvbnZlcnQgbW91c2Ugd2hlZWwgZXZlbnQgY29vcmRzIHRvIHNpZ21hIGNvb3Jkcy5cbiAqXG4gKiBAcGFyYW0gIHtldmVudH0gICAgICAgZSAgIC0gQSB3aGVlbCBtb3VzZSBldmVudC5cbiAqIEBwYXJhbSAge0hUTUxFbGVtZW50fSBkb20gLSBBIERPTSBlbGVtZW50IHRvIGNvbXB1dGUgb2Zmc2V0IHJlbGF0aXZlbHkgdG8uXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGdldFdoZWVsQ29vcmRzKGUsIGRvbSkge1xuICByZXR1cm4gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGdldE1vdXNlQ29vcmRzKGUsIGRvbSkpLCB7fSwge1xuICAgIGRlbHRhOiBnZXRXaGVlbERlbHRhKGUpXG4gIH0pO1xufVxudmFyIE1BWF9UT1VDSEVTID0gMjtcbmZ1bmN0aW9uIGdldFRvdWNoZXNBcnJheSh0b3VjaGVzKSB7XG4gIHZhciBhcnIgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBNYXRoLm1pbih0b3VjaGVzLmxlbmd0aCwgTUFYX1RPVUNIRVMpOyBpIDwgbDsgaSsrKSBhcnIucHVzaCh0b3VjaGVzW2ldKTtcbiAgcmV0dXJuIGFycjtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IHRvdWNoIGNvb3JkcyB0byBzaWdtYSBjb29yZHMuXG4gKlxuICogQHBhcmFtICB7ZXZlbnR9ICAgICAgIGUgICAtIEEgdG91Y2ggZXZlbnQuXG4gKiBAcGFyYW0gIHtIVE1MRWxlbWVudH0gZG9tIC0gQSBET00gZWxlbWVudCB0byBjb21wdXRlIG9mZnNldCByZWxhdGl2ZWx5IHRvLlxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRUb3VjaENvb3JkcyhlLCBkb20pIHtcbiAgcmV0dXJuIHtcbiAgICB0b3VjaGVzOiBnZXRUb3VjaGVzQXJyYXkoZS50b3VjaGVzKS5tYXAoZnVuY3Rpb24gKHRvdWNoKSB7XG4gICAgICByZXR1cm4gZ2V0UG9zaXRpb24odG91Y2gsIGRvbSk7XG4gICAgfSksXG4gICAgb3JpZ2luYWw6IGVcbiAgfTtcbn1cblxuLyoqXG4gKiBFeHRyYWN0IHRoZSB3aGVlbCBkZWx0YSBmcm9tIGEgbW91c2UgZXZlbnQgb3IgdG91Y2ggb2JqZWN0LlxuICpcbiAqIEBwYXJhbSAge2V2ZW50fSAgZSAtIEEgbW91c2UgZXZlbnQgb3IgdG91Y2ggb2JqZWN0LlxuICogQHJldHVybiB7bnVtYmVyfSAgICAgVGhlIHdoZWVsIGRlbHRhIG9mIHRoZSBtb3VzZS5cbiAqL1xuZnVuY3Rpb24gZ2V0V2hlZWxEZWx0YShlKSB7XG4gIC8vIFRPRE86IGNoZWNrIHRob3NlIHJhdGlvcyBhZ2FpbiB0byBlbnN1cmUgYSBjbGVhbiBDaHJvbWUvRmlyZWZveCBjb21wYXRcbiAgaWYgKHR5cGVvZiBlLmRlbHRhWSAhPT0gXCJ1bmRlZmluZWRcIikgcmV0dXJuIGUuZGVsdGFZICogLTMgLyAzNjA7XG4gIGlmICh0eXBlb2YgZS5kZXRhaWwgIT09IFwidW5kZWZpbmVkXCIpIHJldHVybiBlLmRldGFpbCAvIC05O1xuICB0aHJvdyBuZXcgRXJyb3IoXCJDYXB0b3I6IGNvdWxkIG5vdCBleHRyYWN0IGRlbHRhIGZyb20gZXZlbnQuXCIpO1xufVxuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIHJlcHJlc2VudGluZyBhIGNhcHRvciBsaWtlIHRoZSB1c2VyJ3MgbW91c2Ugb3IgdG91Y2ggY29udHJvbHMuXG4gKi9cbnZhciBDYXB0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UeXBlZEV2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoQ2FwdG9yLCBfVHlwZWRFdmVudEVtaXR0ZXIpO1xuICBmdW5jdGlvbiBDYXB0b3IoY29udGFpbmVyLCByZW5kZXJlcikge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2FwdG9yKTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgQ2FwdG9yKTtcbiAgICAvLyBQcm9wZXJ0aWVzXG4gICAgX3RoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIF90aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIHJldHVybiBfY3JlYXRlQ2xhc3MoQ2FwdG9yKTtcbn0oVHlwZWRFdmVudEVtaXR0ZXIpO1xuXG4vKipcbiAqIENvbnN0YW50cy5cbiAqL1xudmFyIERSQUdfVElNRU9VVCQxID0gMTAwO1xudmFyIERSQUdHRURfRVZFTlRTX1RPTEVSQU5DRSA9IDM7XG52YXIgTU9VU0VfSU5FUlRJQV9EVVJBVElPTiA9IDIwMDtcbnZhciBNT1VTRV9JTkVSVElBX1JBVElPID0gMztcbnZhciBNT1VTRV9aT09NX0RVUkFUSU9OID0gMjUwO1xudmFyIFpPT01JTkdfUkFUSU8gPSAxLjc7XG52YXIgRE9VQkxFX0NMSUNLX1RJTUVPVVQgPSAzMDA7XG52YXIgRE9VQkxFX0NMSUNLX1pPT01JTkdfUkFUSU8gPSAyLjI7XG52YXIgRE9VQkxFX0NMSUNLX1pPT01JTkdfRFVSQVRJT04gPSAyMDA7XG5cbi8qKlxuICogRXZlbnQgdHlwZXMuXG4gKi9cbi8qKlxuICogTW91c2UgY2FwdG9yIGNsYXNzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTW91c2VDYXB0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9DYXB0b3IpIHtcbiAgX2luaGVyaXRzKE1vdXNlQ2FwdG9yLCBfQ2FwdG9yKTtcbiAgZnVuY3Rpb24gTW91c2VDYXB0b3IoY29udGFpbmVyLCByZW5kZXJlcikge1xuICAgIHZhciBfdGhpcztcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTW91c2VDYXB0b3IpO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBNb3VzZUNhcHRvciwgW2NvbnRhaW5lciwgcmVuZGVyZXJdKTtcblxuICAgIC8vIEJpbmRpbmcgbWV0aG9kc1xuICAgIC8vIFN0YXRlXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImVuYWJsZWRcIiwgdHJ1ZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImRyYWdnZWRFdmVudHNcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImRvd25TdGFydFRpbWVcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImxhc3RNb3VzZVhcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImxhc3RNb3VzZVlcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImlzTW91c2VEb3duXCIsIGZhbHNlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaXNNb3ZpbmdcIiwgZmFsc2UpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJtb3ZpbmdUaW1lb3V0XCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzdGFydENhbWVyYVN0YXRlXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjbGlja3NcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImRvdWJsZUNsaWNrVGltZW91dFwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiY3VycmVudFdoZWVsRGlyZWN0aW9uXCIsIDApO1xuICAgIF90aGlzLmhhbmRsZUNsaWNrID0gX3RoaXMuaGFuZGxlQ2xpY2suYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuaGFuZGxlUmlnaHRDbGljayA9IF90aGlzLmhhbmRsZVJpZ2h0Q2xpY2suYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuaGFuZGxlRG93biA9IF90aGlzLmhhbmRsZURvd24uYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuaGFuZGxlVXAgPSBfdGhpcy5oYW5kbGVVcC5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5oYW5kbGVNb3ZlID0gX3RoaXMuaGFuZGxlTW92ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5oYW5kbGVXaGVlbCA9IF90aGlzLmhhbmRsZVdoZWVsLmJpbmQoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIF90aGlzLmhhbmRsZUxlYXZlID0gX3RoaXMuaGFuZGxlTGVhdmUuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuaGFuZGxlRW50ZXIgPSBfdGhpcy5oYW5kbGVFbnRlci5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIC8vIEJpbmRpbmcgZXZlbnRzXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBfdGhpcy5oYW5kbGVDbGljaywgZmFsc2UpO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgX3RoaXMuaGFuZGxlUmlnaHRDbGljaywgZmFsc2UpO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIF90aGlzLmhhbmRsZURvd24sIGZhbHNlKTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcIndoZWVsXCIsIF90aGlzLmhhbmRsZVdoZWVsLCBmYWxzZSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWxlYXZlXCIsIF90aGlzLmhhbmRsZUxlYXZlLCBmYWxzZSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIF90aGlzLmhhbmRsZUVudGVyLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBfdGhpcy5oYW5kbGVNb3ZlLCBmYWxzZSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgX3RoaXMuaGFuZGxlVXAsIGZhbHNlKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKE1vdXNlQ2FwdG9yLCBbe1xuICAgIGtleTogXCJraWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHRoaXMuaGFuZGxlQ2xpY2spO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjb250ZXh0bWVudVwiLCB0aGlzLmhhbmRsZVJpZ2h0Q2xpY2spO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5oYW5kbGVEb3duKTtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgdGhpcy5oYW5kbGVXaGVlbCk7XG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgdGhpcy5oYW5kbGVMZWF2ZSk7XG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlZW50ZXJcIiwgdGhpcy5oYW5kbGVFbnRlcik7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIHRoaXMuaGFuZGxlTW92ZSk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCB0aGlzLmhhbmRsZVVwKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlQ2xpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlQ2xpY2soZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuICAgICAgdGhpcy5jbGlja3MrKztcbiAgICAgIGlmICh0aGlzLmNsaWNrcyA9PT0gMikge1xuICAgICAgICB0aGlzLmNsaWNrcyA9IDA7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5kb3VibGVDbGlja1RpbWVvdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5kb3VibGVDbGlja1RpbWVvdXQpO1xuICAgICAgICAgIHRoaXMuZG91YmxlQ2xpY2tUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVEb3VibGVDbGljayhlKTtcbiAgICAgIH1cbiAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuY2xpY2tzID0gMDtcbiAgICAgICAgX3RoaXMyLmRvdWJsZUNsaWNrVGltZW91dCA9IG51bGw7XG4gICAgICB9LCBET1VCTEVfQ0xJQ0tfVElNRU9VVCk7XG5cbiAgICAgIC8vIE5PVEU6IHRoaXMgaXMgaGVyZSB0byBwcmV2ZW50IGNsaWNrIGV2ZW50cyBvbiBkcmFnXG4gICAgICBpZiAodGhpcy5kcmFnZ2VkRXZlbnRzIDwgRFJBR0dFRF9FVkVOVFNfVE9MRVJBTkNFKSB0aGlzLmVtaXQoXCJjbGlja1wiLCBnZXRNb3VzZUNvb3JkcyhlLCB0aGlzLmNvbnRhaW5lcikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVSaWdodENsaWNrXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVJpZ2h0Q2xpY2soZSkge1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcbiAgICAgIHRoaXMuZW1pdChcInJpZ2h0Q2xpY2tcIiwgZ2V0TW91c2VDb29yZHMoZSwgdGhpcy5jb250YWluZXIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlRG91YmxlQ2xpY2tcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRG91YmxlQ2xpY2soZSkge1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB2YXIgbW91c2VDb29yZHMgPSBnZXRNb3VzZUNvb3JkcyhlLCB0aGlzLmNvbnRhaW5lcik7XG4gICAgICB0aGlzLmVtaXQoXCJkb3VibGVDbGlja1wiLCBtb3VzZUNvb3Jkcyk7XG4gICAgICBpZiAobW91c2VDb29yZHMuc2lnbWFEZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICAgIC8vIGRlZmF1bHQgYmVoYXZpb3JcbiAgICAgIHZhciBjYW1lcmEgPSB0aGlzLnJlbmRlcmVyLmdldENhbWVyYSgpO1xuICAgICAgdmFyIG5ld1JhdGlvID0gY2FtZXJhLmdldEJvdW5kZWRSYXRpbyhjYW1lcmEuZ2V0U3RhdGUoKS5yYXRpbyAvIERPVUJMRV9DTElDS19aT09NSU5HX1JBVElPKTtcbiAgICAgIGNhbWVyYS5hbmltYXRlKHRoaXMucmVuZGVyZXIuZ2V0Vmlld3BvcnRab29tZWRTdGF0ZShnZXRQb3NpdGlvbihlLCB0aGlzLmNvbnRhaW5lciksIG5ld1JhdGlvKSwge1xuICAgICAgICBlYXNpbmc6IFwicXVhZHJhdGljSW5PdXRcIixcbiAgICAgICAgZHVyYXRpb246IERPVUJMRV9DTElDS19aT09NSU5HX0RVUkFUSU9OXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlRG93blwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVEb3duKGUpIHtcbiAgICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm47XG5cbiAgICAgIC8vIFdlIG9ubHkgc3RhcnQgZHJhZ2dpbmcgb24gbGVmdCBidXR0b25cbiAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMCkge1xuICAgICAgICB0aGlzLnN0YXJ0Q2FtZXJhU3RhdGUgPSB0aGlzLnJlbmRlcmVyLmdldENhbWVyYSgpLmdldFN0YXRlKCk7XG4gICAgICAgIHZhciBfZ2V0UG9zaXRpb24gPSBnZXRQb3NpdGlvbihlLCB0aGlzLmNvbnRhaW5lciksXG4gICAgICAgICAgeCA9IF9nZXRQb3NpdGlvbi54LFxuICAgICAgICAgIHkgPSBfZ2V0UG9zaXRpb24ueTtcbiAgICAgICAgdGhpcy5sYXN0TW91c2VYID0geDtcbiAgICAgICAgdGhpcy5sYXN0TW91c2VZID0geTtcbiAgICAgICAgdGhpcy5kcmFnZ2VkRXZlbnRzID0gMDtcbiAgICAgICAgdGhpcy5kb3duU3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgdGhpcy5pc01vdXNlRG93biA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoXCJtb3VzZWRvd25cIiwgZ2V0TW91c2VDb29yZHMoZSwgdGhpcy5jb250YWluZXIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlVXBcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlVXAoZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCB8fCAhdGhpcy5pc01vdXNlRG93bikgcmV0dXJuO1xuICAgICAgdmFyIGNhbWVyYSA9IHRoaXMucmVuZGVyZXIuZ2V0Q2FtZXJhKCk7XG4gICAgICB0aGlzLmlzTW91c2VEb3duID0gZmFsc2U7XG4gICAgICBpZiAodHlwZW9mIHRoaXMubW92aW5nVGltZW91dCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tb3ZpbmdUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5tb3ZpbmdUaW1lb3V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBfZ2V0UG9zaXRpb24yID0gZ2V0UG9zaXRpb24oZSwgdGhpcy5jb250YWluZXIpLFxuICAgICAgICB4ID0gX2dldFBvc2l0aW9uMi54LFxuICAgICAgICB5ID0gX2dldFBvc2l0aW9uMi55O1xuICAgICAgdmFyIGNhbWVyYVN0YXRlID0gY2FtZXJhLmdldFN0YXRlKCksXG4gICAgICAgIHByZXZpb3VzQ2FtZXJhU3RhdGUgPSBjYW1lcmEuZ2V0UHJldmlvdXNTdGF0ZSgpIHx8IHtcbiAgICAgICAgICB4OiAwLFxuICAgICAgICAgIHk6IDBcbiAgICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmlzTW92aW5nKSB7XG4gICAgICAgIGNhbWVyYS5hbmltYXRlKHtcbiAgICAgICAgICB4OiBjYW1lcmFTdGF0ZS54ICsgTU9VU0VfSU5FUlRJQV9SQVRJTyAqIChjYW1lcmFTdGF0ZS54IC0gcHJldmlvdXNDYW1lcmFTdGF0ZS54KSxcbiAgICAgICAgICB5OiBjYW1lcmFTdGF0ZS55ICsgTU9VU0VfSU5FUlRJQV9SQVRJTyAqIChjYW1lcmFTdGF0ZS55IC0gcHJldmlvdXNDYW1lcmFTdGF0ZS55KVxuICAgICAgICB9LCB7XG4gICAgICAgICAgZHVyYXRpb246IE1PVVNFX0lORVJUSUFfRFVSQVRJT04sXG4gICAgICAgICAgZWFzaW5nOiBcInF1YWRyYXRpY091dFwiXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmxhc3RNb3VzZVggIT09IHggfHwgdGhpcy5sYXN0TW91c2VZICE9PSB5KSB7XG4gICAgICAgIGNhbWVyYS5zZXRTdGF0ZSh7XG4gICAgICAgICAgeDogY2FtZXJhU3RhdGUueCxcbiAgICAgICAgICB5OiBjYW1lcmFTdGF0ZS55XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzaG91bGRSZWZyZXNoID0gX3RoaXMzLmRyYWdnZWRFdmVudHMgPiAwO1xuICAgICAgICBfdGhpczMuZHJhZ2dlZEV2ZW50cyA9IDA7XG5cbiAgICAgICAgLy8gTk9URTogdGhpcyByZWZyZXNoIGlzIGhlcmUgdG8gbWFrZSBzdXJlIGBoaWRlRWRnZXNPbk1vdmVgIGNhbiB3b3JrXG4gICAgICAgIC8vIHdoZW4gc29tZW9uZSByZWxlYXNlcyBjYW1lcmEgcGFuIGRyYWcgYWZ0ZXIgaGF2aW5nIHN0b3BwZWQgbW92aW5nLlxuICAgICAgICAvLyBTZWUgY29tbWl0OiBodHRwczovL2dpdGh1Yi5jb20vamFjb215YWwvc2lnbWEuanMvY29tbWl0L2NmZDkxOTdmNzAzMTkxMDlkYjZiNjc1ZGQ3YzgyYmU0OTNjYTk1YTJcbiAgICAgICAgLy8gU2VlIGFsc28gaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qYWNvbXlhbC9zaWdtYS5qcy9pc3N1ZXMvMTI5MFxuICAgICAgICAvLyBJdCBjb3VsZCBiZSBwb3NzaWJsZSB0byByZW5kZXIgaW5zdGVhZCBvZiBzY2hlZHVsaW5nIGEgcmVmcmVzaCBidXQgZm9yXG4gICAgICAgIC8vIG5vdyBpdCBzZWVtcyBnb29kIGVub3VnaC5cbiAgICAgICAgaWYgKHNob3VsZFJlZnJlc2gpIF90aGlzMy5yZW5kZXJlci5yZWZyZXNoKCk7XG4gICAgICB9LCAwKTtcbiAgICAgIHRoaXMuZW1pdChcIm1vdXNldXBcIiwgZ2V0TW91c2VDb29yZHMoZSwgdGhpcy5jb250YWluZXIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlTW92ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVNb3ZlKGUpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcbiAgICAgIHZhciBtb3VzZUNvb3JkcyA9IGdldE1vdXNlQ29vcmRzKGUsIHRoaXMuY29udGFpbmVyKTtcblxuICAgICAgLy8gQWx3YXlzIHRyaWdnZXIgYSBcIm1vdXNlbW92ZWJvZHlcIiBldmVudCwgc28gdGhhdCBpdCBpcyBwb3NzaWJsZSB0byBkZXZlbG9wXG4gICAgICAvLyBhIGRyYWctYW5kLWRyb3AgZWZmZWN0IHRoYXQgd29ya3MgZXZlbiB3aGVuIHRoZSBtb3VzZSBpcyBvdXQgb2YgdGhlXG4gICAgICAvLyBjb250YWluZXI6XG4gICAgICB0aGlzLmVtaXQoXCJtb3VzZW1vdmVib2R5XCIsIG1vdXNlQ29vcmRzKTtcblxuICAgICAgLy8gT25seSB0cmlnZ2VyIHRoZSBcIm1vdXNlbW92ZVwiIGV2ZW50IHdoZW4gdGhlIG1vdXNlIGlzIGFjdHVhbGx5IGhvdmVyaW5nXG4gICAgICAvLyB0aGUgY29udGFpbmVyLCB0byBhdm9pZCB3ZWlyZGx5IGhvdmVyaW5nIG5vZGVzIGFuZC9vciBlZGdlcyB3aGVuIHRoZVxuICAgICAgLy8gbW91c2UgaXMgbm90IGhvdmVyIHRoZSBjb250YWluZXI6XG4gICAgICBpZiAoZS50YXJnZXQgPT09IHRoaXMuY29udGFpbmVyKSB7XG4gICAgICAgIHRoaXMuZW1pdChcIm1vdXNlbW92ZVwiLCBtb3VzZUNvb3Jkcyk7XG4gICAgICB9XG4gICAgICBpZiAobW91c2VDb29yZHMuc2lnbWFEZWZhdWx0UHJldmVudGVkKSByZXR1cm47XG5cbiAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVuIFwiaXNNb3VzZURvd25cIiBhbGwgdGhlIHRpbWUsIHRvIGFsbG93IGRyYWdnaW5nIHRoZVxuICAgICAgLy8gc3RhZ2Ugd2hpbGUgdGhlIG1vdXNlIGlzIG5vdCBob3ZlciB0aGUgY29udGFpbmVyOlxuICAgICAgaWYgKHRoaXMuaXNNb3VzZURvd24pIHtcbiAgICAgICAgdGhpcy5pc01vdmluZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZHJhZ2dlZEV2ZW50cysrO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMubW92aW5nVGltZW91dCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm1vdmluZ1RpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubW92aW5nVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczQubW92aW5nVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgX3RoaXM0LmlzTW92aW5nID0gZmFsc2U7XG4gICAgICAgIH0sIERSQUdfVElNRU9VVCQxKTtcbiAgICAgICAgdmFyIGNhbWVyYSA9IHRoaXMucmVuZGVyZXIuZ2V0Q2FtZXJhKCk7XG4gICAgICAgIHZhciBfZ2V0UG9zaXRpb24zID0gZ2V0UG9zaXRpb24oZSwgdGhpcy5jb250YWluZXIpLFxuICAgICAgICAgIGVYID0gX2dldFBvc2l0aW9uMy54LFxuICAgICAgICAgIGVZID0gX2dldFBvc2l0aW9uMy55O1xuICAgICAgICB2YXIgbGFzdE1vdXNlID0gdGhpcy5yZW5kZXJlci52aWV3cG9ydFRvRnJhbWVkR3JhcGgoe1xuICAgICAgICAgIHg6IHRoaXMubGFzdE1vdXNlWCxcbiAgICAgICAgICB5OiB0aGlzLmxhc3RNb3VzZVlcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBtb3VzZSA9IHRoaXMucmVuZGVyZXIudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHtcbiAgICAgICAgICB4OiBlWCxcbiAgICAgICAgICB5OiBlWVxuICAgICAgICB9KTtcbiAgICAgICAgdmFyIG9mZnNldFggPSBsYXN0TW91c2UueCAtIG1vdXNlLngsXG4gICAgICAgICAgb2Zmc2V0WSA9IGxhc3RNb3VzZS55IC0gbW91c2UueTtcbiAgICAgICAgdmFyIGNhbWVyYVN0YXRlID0gY2FtZXJhLmdldFN0YXRlKCk7XG4gICAgICAgIHZhciB4ID0gY2FtZXJhU3RhdGUueCArIG9mZnNldFgsXG4gICAgICAgICAgeSA9IGNhbWVyYVN0YXRlLnkgKyBvZmZzZXRZO1xuICAgICAgICBjYW1lcmEuc2V0U3RhdGUoe1xuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sYXN0TW91c2VYID0gZVg7XG4gICAgICAgIHRoaXMubGFzdE1vdXNlWSA9IGVZO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICB9XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZUxlYXZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZUxlYXZlKGUpIHtcbiAgICAgIHRoaXMuZW1pdChcIm1vdXNlbGVhdmVcIiwgZ2V0TW91c2VDb29yZHMoZSwgdGhpcy5jb250YWluZXIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlRW50ZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlRW50ZXIoZSkge1xuICAgICAgdGhpcy5lbWl0KFwibW91c2VlbnRlclwiLCBnZXRNb3VzZUNvb3JkcyhlLCB0aGlzLmNvbnRhaW5lcikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVXaGVlbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVXaGVlbChlKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5lbmFibGVkKSByZXR1cm47XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgdmFyIGRlbHRhID0gZ2V0V2hlZWxEZWx0YShlKTtcbiAgICAgIGlmICghZGVsdGEpIHJldHVybjtcbiAgICAgIHZhciB3aGVlbENvb3JkcyA9IGdldFdoZWVsQ29vcmRzKGUsIHRoaXMuY29udGFpbmVyKTtcbiAgICAgIHRoaXMuZW1pdChcIndoZWVsXCIsIHdoZWVsQ29vcmRzKTtcbiAgICAgIGlmICh3aGVlbENvb3Jkcy5zaWdtYURlZmF1bHRQcmV2ZW50ZWQpIHJldHVybjtcblxuICAgICAgLy8gRGVmYXVsdCBiZWhhdmlvclxuICAgICAgdmFyIHJhdGlvRGlmZiA9IGRlbHRhID4gMCA/IDEgLyBaT09NSU5HX1JBVElPIDogWk9PTUlOR19SQVRJTztcbiAgICAgIHZhciBjYW1lcmEgPSB0aGlzLnJlbmRlcmVyLmdldENhbWVyYSgpO1xuICAgICAgdmFyIG5ld1JhdGlvID0gY2FtZXJhLmdldEJvdW5kZWRSYXRpbyhjYW1lcmEuZ2V0U3RhdGUoKS5yYXRpbyAqIHJhdGlvRGlmZik7XG4gICAgICB2YXIgd2hlZWxEaXJlY3Rpb24gPSBkZWx0YSA+IDAgPyAxIDogLTE7XG4gICAgICB2YXIgbm93ID0gRGF0ZS5ub3coKTtcblxuICAgICAgLy8gQ2FuY2VsIGV2ZW50cyB0aGF0IGFyZSB0b28gY2xvc2UgdG9vIGVhY2ggb3RoZXIgYW5kIGluIHRoZSBzYW1lIGRpcmVjdGlvbjpcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRXaGVlbERpcmVjdGlvbiA9PT0gd2hlZWxEaXJlY3Rpb24gJiYgdGhpcy5sYXN0V2hlZWxUcmlnZ2VyVGltZSAmJiBub3cgLSB0aGlzLmxhc3RXaGVlbFRyaWdnZXJUaW1lIDwgTU9VU0VfWk9PTV9EVVJBVElPTiAvIDUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FtZXJhLmFuaW1hdGUodGhpcy5yZW5kZXJlci5nZXRWaWV3cG9ydFpvb21lZFN0YXRlKGdldFBvc2l0aW9uKGUsIHRoaXMuY29udGFpbmVyKSwgbmV3UmF0aW8pLCB7XG4gICAgICAgIGVhc2luZzogXCJxdWFkcmF0aWNPdXRcIixcbiAgICAgICAgZHVyYXRpb246IE1PVVNFX1pPT01fRFVSQVRJT05cbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXM1LmN1cnJlbnRXaGVlbERpcmVjdGlvbiA9IDA7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuY3VycmVudFdoZWVsRGlyZWN0aW9uID0gd2hlZWxEaXJlY3Rpb247XG4gICAgICB0aGlzLmxhc3RXaGVlbFRyaWdnZXJUaW1lID0gbm93O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gTW91c2VDYXB0b3I7XG59KENhcHRvcik7XG5cbnZhciBEUkFHX1RJTUVPVVQgPSAyMDA7XG52YXIgVE9VQ0hfSU5FUlRJQV9SQVRJTyA9IDM7XG52YXIgVE9VQ0hfSU5FUlRJQV9EVVJBVElPTiA9IDIwMDtcblxuLyoqXG4gKiBFdmVudCB0eXBlcy5cbiAqL1xuLyoqXG4gKiBUb3VjaCBjYXB0b3IgY2xhc3MuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBUb3VjaENhcHRvciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX0NhcHRvcikge1xuICBfaW5oZXJpdHMoVG91Y2hDYXB0b3IsIF9DYXB0b3IpO1xuICBmdW5jdGlvbiBUb3VjaENhcHRvcihjb250YWluZXIsIHJlbmRlcmVyKSB7XG4gICAgdmFyIF90aGlzO1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb3VjaENhcHRvcik7XG4gICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIFRvdWNoQ2FwdG9yLCBbY29udGFpbmVyLCByZW5kZXJlcl0pO1xuXG4gICAgLy8gQmluZGluZyBtZXRob2RzOlxuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJlbmFibGVkXCIsIHRydWUpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJpc01vdmluZ1wiLCBmYWxzZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImhhc01vdmVkXCIsIGZhbHNlKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwidG91Y2hNb2RlXCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJzdGFydFRvdWNoZXNQb3NpdGlvbnNcIiwgW10pO1xuICAgIF90aGlzLmhhbmRsZVN0YXJ0ID0gX3RoaXMuaGFuZGxlU3RhcnQuYmluZChfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMuaGFuZGxlTGVhdmUgPSBfdGhpcy5oYW5kbGVMZWF2ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICBfdGhpcy5oYW5kbGVNb3ZlID0gX3RoaXMuaGFuZGxlTW92ZS5iaW5kKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIC8vIEJpbmRpbmcgZXZlbnRzXG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIF90aGlzLmhhbmRsZVN0YXJ0LCBmYWxzZSk7XG4gICAgY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCBfdGhpcy5oYW5kbGVMZWF2ZSwgZmFsc2UpO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgX3RoaXMuaGFuZGxlTGVhdmUsIGZhbHNlKTtcbiAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCBfdGhpcy5oYW5kbGVNb3ZlLCBmYWxzZSk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhUb3VjaENhcHRvciwgW3tcbiAgICBrZXk6IFwia2lsbFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBraWxsKCkge1xuICAgICAgdmFyIGNvbnRhaW5lciA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaHN0YXJ0XCIsIHRoaXMuaGFuZGxlU3RhcnQpO1xuICAgICAgY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ0b3VjaGVuZFwiLCB0aGlzLmhhbmRsZUxlYXZlKTtcbiAgICAgIGNvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hjYW5jZWxcIiwgdGhpcy5oYW5kbGVMZWF2ZSk7XG4gICAgICBjb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInRvdWNobW92ZVwiLCB0aGlzLmhhbmRsZU1vdmUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXREaW1lbnNpb25zXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERpbWVuc2lvbnMoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogdGhpcy5jb250YWluZXIub2Zmc2V0V2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0XG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJkaXNwYXRjaFJlbGF0ZWRNb3VzZUV2ZW50XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRpc3BhdGNoUmVsYXRlZE1vdXNlRXZlbnQodHlwZSwgZSwgdG91Y2gsIGVtaXR0ZXIpIHtcbiAgICAgIHZhciBtb3VzZVBvc2l0aW9uID0gdG91Y2ggfHwgZS50b3VjaGVzWzBdO1xuICAgICAgdmFyIG1vdXNlRXZlbnQgPSBuZXcgTW91c2VFdmVudCh0eXBlLCB7XG4gICAgICAgIGNsaWVudFg6IG1vdXNlUG9zaXRpb24uY2xpZW50WCxcbiAgICAgICAgY2xpZW50WTogbW91c2VQb3NpdGlvbi5jbGllbnRZLFxuICAgICAgICBhbHRLZXk6IGUuYWx0S2V5LFxuICAgICAgICBjdHJsS2V5OiBlLmN0cmxLZXlcbiAgICAgIH0pO1xuICAgICAgbW91c2VFdmVudC5pc0Zha2VTaWdtYU1vdXNlRXZlbnQgPSB0cnVlO1xuICAgICAgKGVtaXR0ZXIgfHwgdGhpcy5jb250YWluZXIpLmRpc3BhdGNoRXZlbnQobW91c2VFdmVudCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImhhbmRsZVN0YXJ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZVN0YXJ0KGUpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcblxuICAgICAgLy8gUHJldmVudCBkZWZhdWx0IHRvIGF2b2lkIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvcnMuLi5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIC8vIC4uLmJ1dCBzaW11bGF0ZSBtb3VzZSBiZWhhdmlvciBhbnl3YXksIHRvIGdldCB0aGUgTW91c2VDYXB0b3Igd29ya2luZyBhcyB3ZWxsOlxuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHRoaXMuZGlzcGF0Y2hSZWxhdGVkTW91c2VFdmVudChcIm1vdXNlZG93blwiLCBlKTtcbiAgICAgIHZhciB0b3VjaGVzID0gZ2V0VG91Y2hlc0FycmF5KGUudG91Y2hlcyk7XG4gICAgICB0aGlzLnRvdWNoTW9kZSA9IHRvdWNoZXMubGVuZ3RoO1xuICAgICAgdGhpcy5zdGFydENhbWVyYVN0YXRlID0gdGhpcy5yZW5kZXJlci5nZXRDYW1lcmEoKS5nZXRTdGF0ZSgpO1xuICAgICAgdGhpcy5zdGFydFRvdWNoZXNQb3NpdGlvbnMgPSB0b3VjaGVzLm1hcChmdW5jdGlvbiAodG91Y2gpIHtcbiAgICAgICAgcmV0dXJuIGdldFBvc2l0aW9uKHRvdWNoLCBfdGhpczIuY29udGFpbmVyKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5sYXN0VG91Y2hlcyA9IHRvdWNoZXM7XG4gICAgICB0aGlzLmxhc3RUb3VjaGVzUG9zaXRpb25zID0gdGhpcy5zdGFydFRvdWNoZXNQb3NpdGlvbnM7XG5cbiAgICAgIC8vIFdoZW4gdGhlcmUgYXJlIHR3byB0b3VjaGVzIGRvd24sIGxldCdzIHJlY29yZCBkaXN0YW5jZSBhbmQgYW5nbGUgYXMgd2VsbDpcbiAgICAgIGlmICh0aGlzLnRvdWNoTW9kZSA9PT0gMikge1xuICAgICAgICB2YXIgX3RoaXMkc3RhcnRUb3VjaGVzUG9zID0gX3NsaWNlZFRvQXJyYXkodGhpcy5zdGFydFRvdWNoZXNQb3NpdGlvbnMsIDIpLFxuICAgICAgICAgIF90aGlzJHN0YXJ0VG91Y2hlc1BvczIgPSBfdGhpcyRzdGFydFRvdWNoZXNQb3NbMF0sXG4gICAgICAgICAgeDAgPSBfdGhpcyRzdGFydFRvdWNoZXNQb3MyLngsXG4gICAgICAgICAgeTAgPSBfdGhpcyRzdGFydFRvdWNoZXNQb3MyLnksXG4gICAgICAgICAgX3RoaXMkc3RhcnRUb3VjaGVzUG9zMyA9IF90aGlzJHN0YXJ0VG91Y2hlc1Bvc1sxXSxcbiAgICAgICAgICB4MSA9IF90aGlzJHN0YXJ0VG91Y2hlc1BvczMueCxcbiAgICAgICAgICB5MSA9IF90aGlzJHN0YXJ0VG91Y2hlc1BvczMueTtcbiAgICAgICAgdGhpcy5zdGFydFRvdWNoZXNBbmdsZSA9IE1hdGguYXRhbjIoeTEgLSB5MCwgeDEgLSB4MCk7XG4gICAgICAgIHRoaXMuc3RhcnRUb3VjaGVzRGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coeDEgLSB4MCwgMikgKyBNYXRoLnBvdyh5MSAtIHkwLCAyKSk7XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoXCJ0b3VjaGRvd25cIiwgZ2V0VG91Y2hDb29yZHMoZSwgdGhpcy5jb250YWluZXIpKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiaGFuZGxlTGVhdmVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlTGVhdmUoZSkge1xuICAgICAgaWYgKCF0aGlzLmVuYWJsZWQpIHJldHVybjtcblxuICAgICAgLy8gUHJldmVudCBkZWZhdWx0IHRvIGF2b2lkIGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvcnMuLi5cbiAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgIC8vIC4uLmJ1dCBzaW11bGF0ZSBtb3VzZSBiZWhhdmlvciBhbnl3YXksIHRvIGdldCB0aGUgTW91c2VDYXB0b3Igd29ya2luZyBhcyB3ZWxsOlxuICAgICAgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDAgJiYgdGhpcy5sYXN0VG91Y2hlcyAmJiB0aGlzLmxhc3RUb3VjaGVzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoUmVsYXRlZE1vdXNlRXZlbnQoXCJtb3VzZXVwXCIsIGUsIHRoaXMubGFzdFRvdWNoZXNbMF0sIGRvY3VtZW50KTtcbiAgICAgICAgLy8gLi4uIGFuZCBvbmx5IGNsaWNrIGlmIG5vIG1vdmUgd2FzIG1hZGVcbiAgICAgICAgaWYgKCF0aGlzLmhhc01vdmVkKSB7XG4gICAgICAgICAgdGhpcy5kaXNwYXRjaFJlbGF0ZWRNb3VzZUV2ZW50KFwiY2xpY2tcIiwgZSwgdGhpcy5sYXN0VG91Y2hlc1swXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm1vdmluZ1RpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5pc01vdmluZyA9IGZhbHNlO1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5tb3ZpbmdUaW1lb3V0KTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodGhpcy50b3VjaE1vZGUpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVTdGFydChlKTtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgIC8vIERpc3BhdGNoIGV2ZW50XG5cbiAgICAgICAgICBpZiAodGhpcy5pc01vdmluZykge1xuICAgICAgICAgICAgdmFyIGNhbWVyYSA9IHRoaXMucmVuZGVyZXIuZ2V0Q2FtZXJhKCk7XG4gICAgICAgICAgICB2YXIgY2FtZXJhU3RhdGUgPSBjYW1lcmEuZ2V0U3RhdGUoKSxcbiAgICAgICAgICAgICAgcHJldmlvdXNDYW1lcmFTdGF0ZSA9IGNhbWVyYS5nZXRQcmV2aW91c1N0YXRlKCkgfHwge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgY2FtZXJhLmFuaW1hdGUoe1xuICAgICAgICAgICAgICB4OiBjYW1lcmFTdGF0ZS54ICsgVE9VQ0hfSU5FUlRJQV9SQVRJTyAqIChjYW1lcmFTdGF0ZS54IC0gcHJldmlvdXNDYW1lcmFTdGF0ZS54KSxcbiAgICAgICAgICAgICAgeTogY2FtZXJhU3RhdGUueSArIFRPVUNIX0lORVJUSUFfUkFUSU8gKiAoY2FtZXJhU3RhdGUueSAtIHByZXZpb3VzQ2FtZXJhU3RhdGUueSlcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgZHVyYXRpb246IFRPVUNIX0lORVJUSUFfRFVSQVRJT04sXG4gICAgICAgICAgICAgIGVhc2luZzogXCJxdWFkcmF0aWNPdXRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuaGFzTW92ZWQgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmlzTW92aW5nID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy50b3VjaE1vZGUgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFwidG91Y2h1cFwiLCBnZXRUb3VjaENvb3JkcyhlLCB0aGlzLmNvbnRhaW5lcikpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVNb3ZlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhhbmRsZU1vdmUoZSkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMuZW5hYmxlZCkgcmV0dXJuO1xuXG4gICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgdG8gYXZvaWQgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9ycy4uLlxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgLy8gLi4uYnV0IHNpbXVsYXRlIG1vdXNlIGJlaGF2aW9yIGFueXdheSwgdG8gZ2V0IHRoZSBNb3VzZUNhcHRvciB3b3JraW5nIGFzIHdlbGw6XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMSkgdGhpcy5kaXNwYXRjaFJlbGF0ZWRNb3VzZUV2ZW50KFwibW91c2Vtb3ZlXCIsIGUpO1xuICAgICAgdmFyIHRvdWNoZXMgPSBnZXRUb3VjaGVzQXJyYXkoZS50b3VjaGVzKTtcbiAgICAgIHZhciB0b3VjaGVzUG9zaXRpb25zID0gdG91Y2hlcy5tYXAoZnVuY3Rpb24gKHRvdWNoKSB7XG4gICAgICAgIHJldHVybiBnZXRQb3NpdGlvbih0b3VjaCwgX3RoaXMzLmNvbnRhaW5lcik7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubGFzdFRvdWNoZXMgPSB0b3VjaGVzO1xuICAgICAgdGhpcy5sYXN0VG91Y2hlc1Bvc2l0aW9ucyA9IHRvdWNoZXNQb3NpdGlvbnM7XG5cbiAgICAgIC8vIElmIGEgbW92ZSB3YXMgaW5pdGlhdGVkIGF0IHNvbWUgcG9pbnQgYW5kIHdlIGdldCBiYWNrIHRvIHN0YXJ0cG9pbnQsXG4gICAgICAvLyB3ZSBzaG91bGQgc3RpbGwgY29uc2lkZXIgdGhhdCB3ZSBkaWQgbW92ZSAod2hpY2ggYWxzbyBoYXBwZW5zIGFmdGVyIGFcbiAgICAgIC8vIG11bHRpcGxlIHRvdWNoIHdoZW4gb25seSBvbmUgdG91Y2ggcmVtYWlucyBpbiB3aGljaCBjYXNlIGhhbmRsZVN0YXJ0XG4gICAgICAvLyBpcyByZWNhbGxlZCB3aXRoaW4gaGFuZGxlTGVhdmUpLlxuICAgICAgLy8gTm93LCBzb21lIG1vYmlsZSBicm93c2VycyByZXBvcnQgemVyby1kaXN0YW5jZSBtb3ZlcyBzbyB3ZSBhbHNvIGNoZWNrIHRoYXRcbiAgICAgIC8vIG9uZSBvZiB0aGUgdG91Y2hlcyBkaWQgYWN0dWFsbHkgbW92ZSBmcm9tIHRoZSBvcmlnaW4gcG9zaXRpb24uXG4gICAgICB0aGlzLmhhc01vdmVkIHx8ICh0aGlzLmhhc01vdmVkID0gdG91Y2hlc1Bvc2l0aW9ucy5zb21lKGZ1bmN0aW9uIChwb3NpdGlvbiwgaWR4KSB7XG4gICAgICAgIHZhciBzdGFydFBvc2l0aW9uID0gX3RoaXMzLnN0YXJ0VG91Y2hlc1Bvc2l0aW9uc1tpZHhdO1xuICAgICAgICByZXR1cm4gcG9zaXRpb24ueCAhPT0gc3RhcnRQb3NpdGlvbi54IHx8IHBvc2l0aW9uLnkgIT09IHN0YXJ0UG9zaXRpb24ueTtcbiAgICAgIH0pKTtcblxuICAgICAgLy8gSWYgdGhlcmUgd2FzIG5vIG1vdmUsIGRvIG5vdCB0cmlnZ2VyIHRvdWNoIG1vdmVzIGJlaGF2aW9yXG4gICAgICBpZiAoIXRoaXMuaGFzTW92ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5pc01vdmluZyA9IHRydWU7XG4gICAgICBpZiAodGhpcy5tb3ZpbmdUaW1lb3V0KSBjbGVhclRpbWVvdXQodGhpcy5tb3ZpbmdUaW1lb3V0KTtcbiAgICAgIHRoaXMubW92aW5nVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoaXMzLmlzTW92aW5nID0gZmFsc2U7XG4gICAgICB9LCBEUkFHX1RJTUVPVVQpO1xuICAgICAgdmFyIGNhbWVyYSA9IHRoaXMucmVuZGVyZXIuZ2V0Q2FtZXJhKCk7XG4gICAgICB2YXIgc3RhcnRDYW1lcmFTdGF0ZSA9IHRoaXMuc3RhcnRDYW1lcmFTdGF0ZTtcbiAgICAgIHN3aXRjaCAodGhpcy50b3VjaE1vZGUpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfdGhpcyRyZW5kZXJlciR2aWV3cG8gPSB0aGlzLnJlbmRlcmVyLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCgodGhpcy5zdGFydFRvdWNoZXNQb3NpdGlvbnMgfHwgW10pWzBdKSxcbiAgICAgICAgICAgICAgeFN0YXJ0ID0gX3RoaXMkcmVuZGVyZXIkdmlld3BvLngsXG4gICAgICAgICAgICAgIHlTdGFydCA9IF90aGlzJHJlbmRlcmVyJHZpZXdwby55O1xuICAgICAgICAgICAgdmFyIF90aGlzJHJlbmRlcmVyJHZpZXdwbzIgPSB0aGlzLnJlbmRlcmVyLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh0b3VjaGVzUG9zaXRpb25zWzBdKSxcbiAgICAgICAgICAgICAgeCA9IF90aGlzJHJlbmRlcmVyJHZpZXdwbzIueCxcbiAgICAgICAgICAgICAgeSA9IF90aGlzJHJlbmRlcmVyJHZpZXdwbzIueTtcbiAgICAgICAgICAgIGNhbWVyYS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgIHg6IHN0YXJ0Q2FtZXJhU3RhdGUueCArIHhTdGFydCAtIHgsXG4gICAgICAgICAgICAgIHk6IHN0YXJ0Q2FtZXJhU3RhdGUueSArIHlTdGFydCAtIHlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBIZXJlIGlzIHRoZSB0aGlua2luZyBoZXJlOlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIDEuIFdlIGNhbiBmaW5kIHRoZSBuZXcgYW5nbGUgYW5kIHJhdGlvLCBieSBjb21wYXJpbmcgdGhlIHZlY3RvciBmcm9tIFwidG91Y2ggb25lXCIgdG8gXCJ0b3VjaCB0d29cIiBhdCB0aGUgc3RhcnRcbiAgICAgICAgICAgICAqICAgIG9mIHRoZSBkJ24nZCBhbmQgbm93XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogMi4gV2UgY2FuIHVzZSBgQ2FtZXJhI3ZpZXdwb3J0VG9HcmFwaGAgaW5zaWRlIGZvcm11bGEgdG8gcmV0cmlldmUgdGhlIG5ldyBjYW1lcmEgcG9zaXRpb24sIHVzaW5nIHRoZSBncmFwaFxuICAgICAgICAgICAgICogICAgcG9zaXRpb24gb2YgYSB0b3VjaCBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBkJ24nZCAodXNpbmcgYHN0YXJ0Q2FtZXJhLnZpZXdwb3J0VG9HcmFwaGApIGFuZCB0aGUgdmlld3BvcnRcbiAgICAgICAgICAgICAqICAgIHBvc2l0aW9uIG9mIHRoaXMgc2FtZSB0b3VjaCBub3dcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIG5ld0NhbWVyYVN0YXRlID0ge307XG4gICAgICAgICAgICB2YXIgX3RvdWNoZXNQb3NpdGlvbnMkID0gdG91Y2hlc1Bvc2l0aW9uc1swXSxcbiAgICAgICAgICAgICAgeDAgPSBfdG91Y2hlc1Bvc2l0aW9ucyQueCxcbiAgICAgICAgICAgICAgeTAgPSBfdG91Y2hlc1Bvc2l0aW9ucyQueTtcbiAgICAgICAgICAgIHZhciBfdG91Y2hlc1Bvc2l0aW9ucyQyID0gdG91Y2hlc1Bvc2l0aW9uc1sxXSxcbiAgICAgICAgICAgICAgeDEgPSBfdG91Y2hlc1Bvc2l0aW9ucyQyLngsXG4gICAgICAgICAgICAgIHkxID0gX3RvdWNoZXNQb3NpdGlvbnMkMi55O1xuICAgICAgICAgICAgdmFyIGFuZ2xlRGlmZiA9IE1hdGguYXRhbjIoeTEgLSB5MCwgeDEgLSB4MCkgLSB0aGlzLnN0YXJ0VG91Y2hlc0FuZ2xlO1xuICAgICAgICAgICAgdmFyIHJhdGlvRGlmZiA9IE1hdGguaHlwb3QoeTEgLSB5MCwgeDEgLSB4MCkgLyB0aGlzLnN0YXJ0VG91Y2hlc0Rpc3RhbmNlO1xuXG4gICAgICAgICAgICAvLyAxLlxuICAgICAgICAgICAgdmFyIG5ld1JhdGlvID0gY2FtZXJhLmdldEJvdW5kZWRSYXRpbyhzdGFydENhbWVyYVN0YXRlLnJhdGlvIC8gcmF0aW9EaWZmKTtcbiAgICAgICAgICAgIG5ld0NhbWVyYVN0YXRlLnJhdGlvID0gbmV3UmF0aW87XG4gICAgICAgICAgICBuZXdDYW1lcmFTdGF0ZS5hbmdsZSA9IHN0YXJ0Q2FtZXJhU3RhdGUuYW5nbGUgKyBhbmdsZURpZmY7XG5cbiAgICAgICAgICAgIC8vIDIuXG4gICAgICAgICAgICB2YXIgZGltZW5zaW9ucyA9IHRoaXMuZ2V0RGltZW5zaW9ucygpO1xuICAgICAgICAgICAgdmFyIHRvdWNoR3JhcGhQb3NpdGlvbiA9IHRoaXMucmVuZGVyZXIudmlld3BvcnRUb0ZyYW1lZEdyYXBoKCh0aGlzLnN0YXJ0VG91Y2hlc1Bvc2l0aW9ucyB8fCBbXSlbMF0sIHtcbiAgICAgICAgICAgICAgY2FtZXJhU3RhdGU6IHN0YXJ0Q2FtZXJhU3RhdGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHNtYWxsZXN0RGltZW5zaW9uID0gTWF0aC5taW4oZGltZW5zaW9ucy53aWR0aCwgZGltZW5zaW9ucy5oZWlnaHQpO1xuICAgICAgICAgICAgdmFyIGR4ID0gc21hbGxlc3REaW1lbnNpb24gLyBkaW1lbnNpb25zLndpZHRoO1xuICAgICAgICAgICAgdmFyIGR5ID0gc21hbGxlc3REaW1lbnNpb24gLyBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgICAgIHZhciByYXRpbyA9IG5ld1JhdGlvIC8gc21hbGxlc3REaW1lbnNpb247XG5cbiAgICAgICAgICAgIC8vIEFsaWduIHdpdGggY2VudGVyIG9mIHRoZSBncmFwaDpcbiAgICAgICAgICAgIHZhciBfeCA9IHgwIC0gc21hbGxlc3REaW1lbnNpb24gLyAyIC8gZHg7XG4gICAgICAgICAgICB2YXIgX3kgPSB5MCAtIHNtYWxsZXN0RGltZW5zaW9uIC8gMiAvIGR5O1xuXG4gICAgICAgICAgICAvLyBSb3RhdGU6XG4gICAgICAgICAgICB2YXIgX3JlZiA9IFtfeCAqIE1hdGguY29zKC1uZXdDYW1lcmFTdGF0ZS5hbmdsZSkgLSBfeSAqIE1hdGguc2luKC1uZXdDYW1lcmFTdGF0ZS5hbmdsZSksIF95ICogTWF0aC5jb3MoLW5ld0NhbWVyYVN0YXRlLmFuZ2xlKSArIF94ICogTWF0aC5zaW4oLW5ld0NhbWVyYVN0YXRlLmFuZ2xlKV07XG4gICAgICAgICAgICBfeCA9IF9yZWZbMF07XG4gICAgICAgICAgICBfeSA9IF9yZWZbMV07XG4gICAgICAgICAgICBuZXdDYW1lcmFTdGF0ZS54ID0gdG91Y2hHcmFwaFBvc2l0aW9uLnggLSBfeCAqIHJhdGlvO1xuICAgICAgICAgICAgbmV3Q2FtZXJhU3RhdGUueSA9IHRvdWNoR3JhcGhQb3NpdGlvbi55ICsgX3kgKiByYXRpbztcbiAgICAgICAgICAgIGNhbWVyYS5zZXRTdGF0ZShuZXdDYW1lcmFTdGF0ZSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoXCJ0b3VjaG1vdmVcIiwgZ2V0VG91Y2hDb29yZHMoZSwgdGhpcy5jb250YWluZXIpKTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRvdWNoQ2FwdG9yO1xufShDYXB0b3IpO1xuXG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5KGl0ZXIpIHtcbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgaXRlcltTeW1ib2wuaXRlcmF0b3JdICE9IG51bGwgfHwgaXRlcltcIkBAaXRlcmF0b3JcIl0gIT0gbnVsbCkgcmV0dXJuIEFycmF5LmZyb20oaXRlcik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBfbm9uSXRlcmFibGVTcHJlYWQoKTtcbn1cblxuLyoqXG4gKiBTaWdtYS5qcyBMYWJlbHMgSGV1cmlzdGljc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogTWlzY2VsbGFuZW91cyBoZXVyaXN0aWNzIHJlbGF0ZWQgdG8gbGFiZWwgZGlzcGxheS5cbiAqIEBtb2R1bGVcbiAqL1xuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBzaW5nbGUgY2FuZGlkYXRlIGZvciB0aGUgbGFiZWwgZ3JpZCBzZWxlY3Rpb24uXG4gKlxuICogSXQgYWxzbyBkZXNjcmliZXMgYSBkZXRlcm1pbmlzdGljIHdheSB0byBjb21wYXJlIHR3byBjYW5kaWRhdGVzIHRvIGFzc2Vzc1xuICogd2hpY2ggb25lIGlzIGJldHRlci5cbiAqL1xudmFyIExhYmVsQ2FuZGlkYXRlID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gTGFiZWxDYW5kaWRhdGUoa2V5LCBzaXplKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExhYmVsQ2FuZGlkYXRlKTtcbiAgICB0aGlzLmtleSA9IGtleTtcbiAgICB0aGlzLnNpemUgPSBzaXplO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhMYWJlbENhbmRpZGF0ZSwgbnVsbCwgW3tcbiAgICBrZXk6IFwiY29tcGFyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb21wYXJlKGZpcnN0LCBzZWNvbmQpIHtcbiAgICAgIC8vIEZpcnN0IHdlIGNvbXBhcmUgYnkgc2l6ZVxuICAgICAgaWYgKGZpcnN0LnNpemUgPiBzZWNvbmQuc2l6ZSkgcmV0dXJuIC0xO1xuICAgICAgaWYgKGZpcnN0LnNpemUgPCBzZWNvbmQuc2l6ZSkgcmV0dXJuIDE7XG5cbiAgICAgIC8vIFRoZW4gc2luY2Ugbm8gdHdvIG5vZGVzIGNhbiBoYXZlIHRoZSBzYW1lIGtleSwgd2UgdXNlIGl0IHRvXG4gICAgICAvLyBkZXRlcm1pbmlzdGljYWxseSB0aWUtYnJlYWsgYnkga2V5XG4gICAgICBpZiAoZmlyc3Qua2V5ID4gc2Vjb25kLmtleSkgcmV0dXJuIDE7XG5cbiAgICAgIC8vIE5PVEU6IHRoaXMgY29tcGFyYXRvciBjYW5ub3QgcmV0dXJuIDBcbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIExhYmVsQ2FuZGlkYXRlO1xufSgpO1xuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSAyRCBzcGF0aWFsIGdyaWQgZGl2aWRlZCBpbnRvIGNvbnN0YW50LXNpemUgY2VsbHMuXG4gKi9cbnZhciBMYWJlbEdyaWQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBMYWJlbEdyaWQoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIExhYmVsR3JpZCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwid2lkdGhcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwiaGVpZ2h0XCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNlbGxTaXplXCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImNvbHVtbnNcIiwgMCk7XG4gICAgX2RlZmluZVByb3BlcnR5KHRoaXMsIFwicm93c1wiLCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkodGhpcywgXCJjZWxsc1wiLCB7fSk7XG4gIH1cbiAgX2NyZWF0ZUNsYXNzKExhYmVsR3JpZCwgW3tcbiAgICBrZXk6IFwicmVzaXplQW5kQ2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVzaXplQW5kQ2xlYXIoZGltZW5zaW9ucywgY2VsbFNpemUpIHtcbiAgICAgIHRoaXMud2lkdGggPSBkaW1lbnNpb25zLndpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgIHRoaXMuY2VsbFNpemUgPSBjZWxsU2l6ZTtcbiAgICAgIHRoaXMuY29sdW1ucyA9IE1hdGguY2VpbChkaW1lbnNpb25zLndpZHRoIC8gY2VsbFNpemUpO1xuICAgICAgdGhpcy5yb3dzID0gTWF0aC5jZWlsKGRpbWVuc2lvbnMuaGVpZ2h0IC8gY2VsbFNpemUpO1xuICAgICAgdGhpcy5jZWxscyA9IHt9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJnZXRJbmRleFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRJbmRleChwb3MpIHtcbiAgICAgIHZhciB4SW5kZXggPSBNYXRoLmZsb29yKHBvcy54IC8gdGhpcy5jZWxsU2l6ZSk7XG4gICAgICB2YXIgeUluZGV4ID0gTWF0aC5mbG9vcihwb3MueSAvIHRoaXMuY2VsbFNpemUpO1xuICAgICAgcmV0dXJuIHlJbmRleCAqIHRoaXMuY29sdW1ucyArIHhJbmRleDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZChrZXksIHNpemUsIHBvcykge1xuICAgICAgdmFyIGNhbmRpZGF0ZSA9IG5ldyBMYWJlbENhbmRpZGF0ZShrZXksIHNpemUpO1xuICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleChwb3MpO1xuICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxzW2luZGV4XTtcbiAgICAgIGlmICghY2VsbCkge1xuICAgICAgICBjZWxsID0gW107XG4gICAgICAgIHRoaXMuY2VsbHNbaW5kZXhdID0gY2VsbDtcbiAgICAgIH1cbiAgICAgIGNlbGwucHVzaChjYW5kaWRhdGUpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJvcmdhbml6ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvcmdhbml6ZSgpIHtcbiAgICAgIGZvciAodmFyIGsgaW4gdGhpcy5jZWxscykge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbHNba107XG4gICAgICAgIGNlbGwuc29ydChMYWJlbENhbmRpZGF0ZS5jb21wYXJlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0TGFiZWxzVG9EaXNwbGF5XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldExhYmVsc1RvRGlzcGxheShyYXRpbywgZGVuc2l0eSkge1xuICAgICAgLy8gVE9ETzogd29yayBvbiB2aXNpYmxlIG5vZGVzIHRvIG9wdGltaXplPyBeIC0+IHRocmVzaG9sZCBvdXRzaWRlIHNvIHRoYXQgbWVtb2l6YXRpb24gd29ya3M/XG4gICAgICAvLyBUT0RPOiBhZGp1c3QgdGhyZXNob2xkIGxvd2VyLCBidXQgaW5jcmVhc2UgY2VsbHMgYSBiaXQ/XG4gICAgICAvLyBUT0RPOiBodW50IGZvciBnZW9tIGlzc3VlIGluIGRpc2d1aXNlXG4gICAgICAvLyBUT0RPOiBtZW1vaXplIHdoaWxlIHJhdGlvIGRvZXMgbm90IG1vdmUuIG1ldGhvZCB0byBmb3JjZSByZWNvbXB1dGVcbiAgICAgIHZhciBjZWxsQXJlYSA9IHRoaXMuY2VsbFNpemUgKiB0aGlzLmNlbGxTaXplO1xuICAgICAgdmFyIHNjYWxlZENlbGxBcmVhID0gY2VsbEFyZWEgLyByYXRpbyAvIHJhdGlvO1xuICAgICAgdmFyIHNjYWxlZERlbnNpdHkgPSBzY2FsZWRDZWxsQXJlYSAqIGRlbnNpdHkgLyBjZWxsQXJlYTtcbiAgICAgIHZhciBsYWJlbHNUb0Rpc3BsYXlQZXJDZWxsID0gTWF0aC5jZWlsKHNjYWxlZERlbnNpdHkpO1xuICAgICAgdmFyIGxhYmVscyA9IFtdO1xuICAgICAgZm9yICh2YXIgayBpbiB0aGlzLmNlbGxzKSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsc1trXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLm1pbihsYWJlbHNUb0Rpc3BsYXlQZXJDZWxsLCBjZWxsLmxlbmd0aCk7IGkrKykge1xuICAgICAgICAgIGxhYmVscy5wdXNoKGNlbGxbaV0ua2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGxhYmVscztcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIExhYmVsR3JpZDtcbn0oKTtcblxuLyoqXG4gKiBMYWJlbCBoZXVyaXN0aWMgc2VsZWN0aW5nIGVkZ2UgbGFiZWxzIHRvIGRpc3BsYXksIGJhc2VkIG9uIGRpc3BsYXllZCBub2RlXG4gKiBsYWJlbHNcbiAqXG4gKiBAcGFyYW0gIHtvYmplY3R9IHBhcmFtcyAgICAgICAgICAgICAgICAgLSBQYXJhbWV0ZXJzOlxuICogQHBhcmFtICB7U2V0fSAgICAgIGRpc3BsYXllZE5vZGVMYWJlbHMgIC0gQ3VycmVudGx5IGRpc3BsYXllZCBub2RlIGxhYmVscy5cbiAqIEBwYXJhbSAge1NldH0gICAgICBoaWdobGlnaHRlZE5vZGVzICAgICAtIEhpZ2hsaWdodGVkIG5vZGVzLlxuICogQHBhcmFtICB7R3JhcGh9ICAgIGdyYXBoICAgICAgICAgICAgICAgIC0gVGhlIHJlbmRlcmVkIGdyYXBoLlxuICogQHBhcmFtICB7c3RyaW5nfSAgIGhvdmVyZWROb2RlICAgICAgICAgIC0gSG92ZXJlZCBub2RlIChvcHRpb25hbClcbiAqIEByZXR1cm4ge0FycmF5fSAgICAgICAgICAgICAgICAgICAgICAgICAtIFRoZSBzZWxlY3RlZCBsYWJlbHMuXG4gKi9cbmZ1bmN0aW9uIGVkZ2VMYWJlbHNUb0Rpc3BsYXlGcm9tTm9kZXMocGFyYW1zKSB7XG4gIHZhciBncmFwaCA9IHBhcmFtcy5ncmFwaCxcbiAgICBob3ZlcmVkTm9kZSA9IHBhcmFtcy5ob3ZlcmVkTm9kZSxcbiAgICBoaWdobGlnaHRlZE5vZGVzID0gcGFyYW1zLmhpZ2hsaWdodGVkTm9kZXMsXG4gICAgZGlzcGxheWVkTm9kZUxhYmVscyA9IHBhcmFtcy5kaXNwbGF5ZWROb2RlTGFiZWxzO1xuICB2YXIgd29ydGh5RWRnZXMgPSBbXTtcblxuICAvLyBUT0RPOiB0aGUgY29kZSBiZWxvdyBjYW4gYmUgb3B0aW1pemVkIHVzaW5nICMuZm9yRWFjaCBhbmQgYmF0Y2hpbmcgdGhlIGNvZGUgcGVyIGFkalxuXG4gIC8vIFdlIHNob3VsZCBkaXNwbGF5IGFuIGVkZ2UncyBsYWJlbCBpZjpcbiAgLy8gICAtIEFueSBvZiBpdHMgZXh0cmVtaXRpZXMgaXMgaGlnaGxpZ2h0ZWQgb3IgaG92ZXJlZFxuICAvLyAgIC0gQm90aCBvZiBpdHMgZXh0cmVtaXRpZXMgaGFzIGl0cyBsYWJlbCBzaG93blxuICBncmFwaC5mb3JFYWNoRWRnZShmdW5jdGlvbiAoZWRnZSwgXywgc291cmNlLCB0YXJnZXQpIHtcbiAgICBpZiAoc291cmNlID09PSBob3ZlcmVkTm9kZSB8fCB0YXJnZXQgPT09IGhvdmVyZWROb2RlIHx8IGhpZ2hsaWdodGVkTm9kZXMuaGFzKHNvdXJjZSkgfHwgaGlnaGxpZ2h0ZWROb2Rlcy5oYXModGFyZ2V0KSB8fCBkaXNwbGF5ZWROb2RlTGFiZWxzLmhhcyhzb3VyY2UpICYmIGRpc3BsYXllZE5vZGVMYWJlbHMuaGFzKHRhcmdldCkpIHtcbiAgICAgIHdvcnRoeUVkZ2VzLnB1c2goZWRnZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHdvcnRoeUVkZ2VzO1xufVxuXG4vKipcbiAqIENvbnN0YW50cy5cbiAqL1xudmFyIFhfTEFCRUxfTUFSR0lOID0gMTUwO1xudmFyIFlfTEFCRUxfTUFSR0lOID0gNTA7XG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEltcG9ydGFudCBmdW5jdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5Tm9kZURlZmF1bHRzKHNldHRpbmdzLCBrZXksIGRhdGEpIHtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIFwieFwiKSB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBcInlcIikpIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBjb3VsZCBub3QgZmluZCBhIHZhbGlkIHBvc2l0aW9uICh4LCB5KSBmb3Igbm9kZSBcXFwiXCIuY29uY2F0KGtleSwgXCJcXFwiLiBBbGwgeW91ciBub2RlcyBtdXN0IGhhdmUgYSBudW1iZXIgXFxcInhcXFwiIGFuZCBcXFwieVxcXCIuIE1heWJlIHlvdXIgZm9yZ290IHRvIGFwcGx5IGEgbGF5b3V0IG9yIHlvdXIgXFxcIm5vZGVSZWR1Y2VyXFxcIiBpcyBub3QgcmV0dXJuaW5nIHRoZSBjb3JyZWN0IGRhdGE/XCIpKTtcbiAgaWYgKCFkYXRhLmNvbG9yKSBkYXRhLmNvbG9yID0gc2V0dGluZ3MuZGVmYXVsdE5vZGVDb2xvcjtcbiAgaWYgKCFkYXRhLmxhYmVsICYmIGRhdGEubGFiZWwgIT09IFwiXCIpIGRhdGEubGFiZWwgPSBudWxsO1xuICBpZiAoZGF0YS5sYWJlbCAhPT0gdW5kZWZpbmVkICYmIGRhdGEubGFiZWwgIT09IG51bGwpIGRhdGEubGFiZWwgPSBcIlwiICsgZGF0YS5sYWJlbDtlbHNlIGRhdGEubGFiZWwgPSBudWxsO1xuICBpZiAoIWRhdGEuc2l6ZSkgZGF0YS5zaXplID0gMjtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKGRhdGEsIFwiaGlkZGVuXCIpKSBkYXRhLmhpZGRlbiA9IGZhbHNlO1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgXCJoaWdobGlnaHRlZFwiKSkgZGF0YS5oaWdobGlnaHRlZCA9IGZhbHNlO1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgXCJmb3JjZUxhYmVsXCIpKSBkYXRhLmZvcmNlTGFiZWwgPSBmYWxzZTtcbiAgaWYgKCFkYXRhLnR5cGUgfHwgZGF0YS50eXBlID09PSBcIlwiKSBkYXRhLnR5cGUgPSBzZXR0aW5ncy5kZWZhdWx0Tm9kZVR5cGU7XG4gIGlmICghZGF0YS56SW5kZXgpIGRhdGEuekluZGV4ID0gMDtcbiAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBhcHBseUVkZ2VEZWZhdWx0cyhzZXR0aW5ncywgX2tleSwgZGF0YSkge1xuICBpZiAoIWRhdGEuY29sb3IpIGRhdGEuY29sb3IgPSBzZXR0aW5ncy5kZWZhdWx0RWRnZUNvbG9yO1xuICBpZiAoIWRhdGEubGFiZWwpIGRhdGEubGFiZWwgPSBcIlwiO1xuICBpZiAoIWRhdGEuc2l6ZSkgZGF0YS5zaXplID0gMC41O1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgXCJoaWRkZW5cIikpIGRhdGEuaGlkZGVuID0gZmFsc2U7XG4gIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLCBcImZvcmNlTGFiZWxcIikpIGRhdGEuZm9yY2VMYWJlbCA9IGZhbHNlO1xuICBpZiAoIWRhdGEudHlwZSB8fCBkYXRhLnR5cGUgPT09IFwiXCIpIGRhdGEudHlwZSA9IHNldHRpbmdzLmRlZmF1bHRFZGdlVHlwZTtcbiAgaWYgKCFkYXRhLnpJbmRleCkgZGF0YS56SW5kZXggPSAwO1xuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBNYWluIGNsYXNzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtHcmFwaH0gICAgICAgZ3JhcGggICAgIC0gR3JhcGggdG8gcmVuZGVyLlxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY29udGFpbmVyIC0gRE9NIGNvbnRhaW5lciBpbiB3aGljaCB0byByZW5kZXIuXG4gKiBAcGFyYW0ge29iamVjdH0gICAgICBzZXR0aW5ncyAgLSBPcHRpb25hbCBzZXR0aW5ncy5cbiAqL1xudmFyIFNpZ21hJDEgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9UeXBlZEV2ZW50RW1pdHRlcikge1xuICBfaW5oZXJpdHMoU2lnbWEsIF9UeXBlZEV2ZW50RW1pdHRlcik7XG4gIGZ1bmN0aW9uIFNpZ21hKGdyYXBoLCBjb250YWluZXIpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgdmFyIHNldHRpbmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2lnbWEpO1xuICAgIF90aGlzID0gX2NhbGxTdXBlcih0aGlzLCBTaWdtYSk7XG5cbiAgICAvLyBSZXNvbHZpbmcgc2V0dGluZ3NcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZWxlbWVudHNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjYW52YXNDb250ZXh0c1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIndlYkdMQ29udGV4dHNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJwaWNraW5nTGF5ZXJzXCIsIG5ldyBTZXQoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInRleHR1cmVzXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZnJhbWVCdWZmZXJzXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiYWN0aXZlTGlzdGVuZXJzXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwibGFiZWxHcmlkXCIsIG5ldyBMYWJlbEdyaWQoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm5vZGVEYXRhQ2FjaGVcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJlZGdlRGF0YUNhY2hlXCIsIHt9KTtcbiAgICAvLyBJbmRpY2VzIHRvIGtlZXAgdHJhY2sgb2YgdGhlIGluZGV4IG9mIHRoZSBpdGVtIGluc2lkZSBwcm9ncmFtc1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJub2RlUHJvZ3JhbUluZGV4XCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZWRnZVByb2dyYW1JbmRleFwiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcIm5vZGVzV2l0aEZvcmNlZExhYmVsc1wiLCBuZXcgU2V0KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJlZGdlc1dpdGhGb3JjZWRMYWJlbHNcIiwgbmV3IFNldCgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwibm9kZUV4dGVudFwiLCB7XG4gICAgICB4OiBbMCwgMV0sXG4gICAgICB5OiBbMCwgMV1cbiAgICB9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwibm9kZVpFeHRlbnRcIiwgW0luZmluaXR5LCAtSW5maW5pdHldKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZWRnZVpFeHRlbnRcIiwgW0luZmluaXR5LCAtSW5maW5pdHldKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwibWF0cml4XCIsIGlkZW50aXR5KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJpbnZNYXRyaXhcIiwgaWRlbnRpdHkoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNvcnJlY3Rpb25SYXRpb1wiLCAxKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiY3VzdG9tQkJveFwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwibm9ybWFsaXphdGlvbkZ1bmN0aW9uXCIsIGNyZWF0ZU5vcm1hbGl6YXRpb25GdW5jdGlvbih7XG4gICAgICB4OiBbMCwgMV0sXG4gICAgICB5OiBbMCwgMV1cbiAgICB9KSk7XG4gICAgLy8gQ2FjaGU6XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImdyYXBoVG9WaWV3cG9ydFJhdGlvXCIsIDEpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJpdGVtSURzSW5kZXhcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJub2RlSW5kaWNlc1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImVkZ2VJbmRpY2VzXCIsIHt9KTtcbiAgICAvLyBTdGFydGluZyBkaW1lbnNpb25zIGFuZCBwaXhlbCByYXRpb1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJ3aWR0aFwiLCAwKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiaGVpZ2h0XCIsIDApO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJwaXhlbFJhdGlvXCIsIGdldFBpeGVsUmF0aW8oKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInBpY2tpbmdEb3duU2l6aW5nUmF0aW9cIiwgMiAqIF90aGlzLnBpeGVsUmF0aW8pO1xuICAgIC8vIEdyYXBoIFN0YXRlXG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImRpc3BsYXllZE5vZGVMYWJlbHNcIiwgbmV3IFNldCgpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiZGlzcGxheWVkRWRnZUxhYmVsc1wiLCBuZXcgU2V0KCkpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJoaWdobGlnaHRlZE5vZGVzXCIsIG5ldyBTZXQoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImhvdmVyZWROb2RlXCIsIG51bGwpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJob3ZlcmVkRWRnZVwiLCBudWxsKTtcbiAgICAvLyBJbnRlcm5hbCBzdGF0ZXNcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwicmVuZGVyRnJhbWVcIiwgbnVsbCk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcInJlbmRlckhpZ2hsaWdodGVkTm9kZXNGcmFtZVwiLCBudWxsKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwibmVlZFRvUHJvY2Vzc1wiLCBmYWxzZSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImNoZWNrRWRnZXNFdmVudHNGcmFtZVwiLCBudWxsKTtcbiAgICAvLyBQcm9ncmFtc1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJub2RlUHJvZ3JhbXNcIiwge30pO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJub2RlSG92ZXJQcm9ncmFtc1wiLCB7fSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImVkZ2VQcm9ncmFtc1wiLCB7fSk7XG4gICAgX3RoaXMuc2V0dGluZ3MgPSByZXNvbHZlU2V0dGluZ3Moc2V0dGluZ3MpO1xuXG4gICAgLy8gVmFsaWRhdGluZ1xuICAgIHZhbGlkYXRlU2V0dGluZ3MoX3RoaXMuc2V0dGluZ3MpO1xuICAgIHZhbGlkYXRlR3JhcGgoZ3JhcGgpO1xuICAgIGlmICghKGNvbnRhaW5lciBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGNvbnRhaW5lciBzaG91bGQgYmUgYW4gaHRtbCBlbGVtZW50LlwiKTtcblxuICAgIC8vIFByb3BlcnRpZXNcbiAgICBfdGhpcy5ncmFwaCA9IGdyYXBoO1xuICAgIF90aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcblxuICAgIC8vIEluaXRpYWxpemluZyBjb250ZXh0c1xuICAgIF90aGlzLmNyZWF0ZVdlYkdMQ29udGV4dChcImVkZ2VzXCIsIHtcbiAgICAgIHBpY2tpbmc6IHNldHRpbmdzLmVuYWJsZUVkZ2VFdmVudHNcbiAgICB9KTtcbiAgICBfdGhpcy5jcmVhdGVDYW52YXNDb250ZXh0KFwiZWRnZUxhYmVsc1wiKTtcbiAgICBfdGhpcy5jcmVhdGVXZWJHTENvbnRleHQoXCJub2Rlc1wiLCB7XG4gICAgICBwaWNraW5nOiB0cnVlXG4gICAgfSk7XG4gICAgX3RoaXMuY3JlYXRlQ2FudmFzQ29udGV4dChcImxhYmVsc1wiKTtcbiAgICBfdGhpcy5jcmVhdGVDYW52YXNDb250ZXh0KFwiaG92ZXJzXCIpO1xuICAgIF90aGlzLmNyZWF0ZVdlYkdMQ29udGV4dChcImhvdmVyTm9kZXNcIik7XG4gICAgX3RoaXMuY3JlYXRlQ2FudmFzQ29udGV4dChcIm1vdXNlXCIpO1xuXG4gICAgLy8gSW5pdGlhbCByZXNpemVcbiAgICBfdGhpcy5yZXNpemUoKTtcblxuICAgIC8vIExvYWRpbmcgcHJvZ3JhbXNcbiAgICBmb3IgKHZhciB0eXBlIGluIF90aGlzLnNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3Nlcykge1xuICAgICAgdmFyIE5vZGVQcm9ncmFtQ2xhc3MgPSBfdGhpcy5zZXR0aW5ncy5ub2RlUHJvZ3JhbUNsYXNzZXNbdHlwZV07XG4gICAgICBfdGhpcy5ub2RlUHJvZ3JhbXNbdHlwZV0gPSBuZXcgTm9kZVByb2dyYW1DbGFzcyhfdGhpcy53ZWJHTENvbnRleHRzLm5vZGVzLCBfdGhpcy5mcmFtZUJ1ZmZlcnMubm9kZXMsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcbiAgICAgIHZhciBOb2RlSG92ZXJQcm9ncmFtID0gTm9kZVByb2dyYW1DbGFzcztcbiAgICAgIGlmICh0eXBlIGluIF90aGlzLnNldHRpbmdzLm5vZGVIb3ZlclByb2dyYW1DbGFzc2VzKSB7XG4gICAgICAgIE5vZGVIb3ZlclByb2dyYW0gPSBfdGhpcy5zZXR0aW5ncy5ub2RlSG92ZXJQcm9ncmFtQ2xhc3Nlc1t0eXBlXTtcbiAgICAgIH1cbiAgICAgIF90aGlzLm5vZGVIb3ZlclByb2dyYW1zW3R5cGVdID0gbmV3IE5vZGVIb3ZlclByb2dyYW0oX3RoaXMud2ViR0xDb250ZXh0cy5ob3Zlck5vZGVzLCBudWxsLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgfVxuICAgIGZvciAodmFyIF90eXBlIGluIF90aGlzLnNldHRpbmdzLmVkZ2VQcm9ncmFtQ2xhc3Nlcykge1xuICAgICAgdmFyIEVkZ2VQcm9ncmFtQ2xhc3MgPSBfdGhpcy5zZXR0aW5ncy5lZGdlUHJvZ3JhbUNsYXNzZXNbX3R5cGVdO1xuICAgICAgX3RoaXMuZWRnZVByb2dyYW1zW190eXBlXSA9IG5ldyBFZGdlUHJvZ3JhbUNsYXNzKF90aGlzLndlYkdMQ29udGV4dHMuZWRnZXMsIF90aGlzLmZyYW1lQnVmZmVycy5lZGdlcywgX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemluZyB0aGUgY2FtZXJhXG4gICAgX3RoaXMuY2FtZXJhID0gbmV3IENhbWVyYSgpO1xuXG4gICAgLy8gQmluZGluZyBjYW1lcmEgZXZlbnRzXG4gICAgX3RoaXMuYmluZENhbWVyYUhhbmRsZXJzKCk7XG5cbiAgICAvLyBJbml0aWFsaXppbmcgY2FwdG9yc1xuICAgIF90aGlzLm1vdXNlQ2FwdG9yID0gbmV3IE1vdXNlQ2FwdG9yKF90aGlzLmVsZW1lbnRzLm1vdXNlLCBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSk7XG4gICAgX3RoaXMudG91Y2hDYXB0b3IgPSBuZXcgVG91Y2hDYXB0b3IoX3RoaXMuZWxlbWVudHMubW91c2UsIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpKTtcblxuICAgIC8vIEJpbmRpbmcgZXZlbnQgaGFuZGxlcnNcbiAgICBfdGhpcy5iaW5kRXZlbnRIYW5kbGVycygpO1xuXG4gICAgLy8gQmluZGluZyBncmFwaCBoYW5kbGVyc1xuICAgIF90aGlzLmJpbmRHcmFwaEhhbmRsZXJzKCk7XG5cbiAgICAvLyBUcmlnZ2VyIGV2ZW50dWFsIHNldHRpbmdzLXJlbGF0ZWQgdGhpbmdzXG4gICAgX3RoaXMuaGFuZGxlU2V0dGluZ3NVcGRhdGUoKTtcblxuICAgIC8vIFByb2Nlc3NpbmcgZGF0YSBmb3IgdGhlIGZpcnN0IHRpbWUgJiByZW5kZXJcbiAgICBfdGhpcy5yZWZyZXNoKCk7XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgLyoqLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEludGVybmFsIG1ldGhvZHMuXG4gICAqKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICAvKipcbiAgICogSW50ZXJuYWwgZnVuY3Rpb24gdXNlZCB0byBjcmVhdGUgYSBjYW52YXMgZWxlbWVudC5cbiAgICogQHBhcmFtICB7c3RyaW5nfSBpZCAtIENvbnRleHQncyBpZC5cbiAgICogQHJldHVybiB7U2lnbWF9XG4gICAqL1xuICBfY3JlYXRlQ2xhc3MoU2lnbWEsIFt7XG4gICAga2V5OiBcImNyZWF0ZUNhbnZhc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVDYW52YXMoaWQpIHtcbiAgICAgIHZhciBjYW52YXMgPSBjcmVhdGVFbGVtZW50KFwiY2FudmFzXCIsIHtcbiAgICAgICAgcG9zaXRpb246IFwiYWJzb2x1dGVcIlxuICAgICAgfSwge1xuICAgICAgICBcImNsYXNzXCI6IFwic2lnbWEtXCIuY29uY2F0KGlkKVxuICAgICAgfSk7XG4gICAgICB0aGlzLmVsZW1lbnRzW2lkXSA9IGNhbnZhcztcbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgICByZXR1cm4gY2FudmFzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludGVybmFsIGZ1bmN0aW9uIHVzZWQgdG8gY3JlYXRlIGEgY2FudmFzIGNvbnRleHQgYW5kIGFkZCB0aGUgcmVsZXZhbnRcbiAgICAgKiBET00gZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGlkIC0gQ29udGV4dCdzIGlkLlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZUNhbnZhc0NvbnRleHRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY3JlYXRlQ2FudmFzQ29udGV4dChpZCkge1xuICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuY3JlYXRlQ2FudmFzKGlkKTtcbiAgICAgIHZhciBjb250ZXh0T3B0aW9ucyA9IHtcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgYW50aWFsaWFzOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dHNbaWRdID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCBjb250ZXh0T3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBmdW5jdGlvbiB1c2VkIHRvIGNyZWF0ZSBhIFdlYkdMIGNvbnRleHQgYW5kIGFkZCB0aGUgcmVsZXZhbnQgRE9NXG4gICAgICogZWxlbWVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9ICBpZCAgICAgIC0gQ29udGV4dCdzIGlkLlxuICAgICAqIEBwYXJhbSAge29iamVjdD99IG9wdGlvbnMgLSAjZ2V0Q29udGV4dCBwYXJhbXMgdG8gb3ZlcnJpZGUgKG9wdGlvbmFsKVxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImNyZWF0ZVdlYkdMQ29udGV4dFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjcmVhdGVXZWJHTENvbnRleHQoaWQsIG9wdGlvbnMpIHtcbiAgICAgIHZhciBjYW52YXMgPSB0aGlzLmNyZWF0ZUNhbnZhcyhpZCk7XG4gICAgICBpZiAob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5oaWRkZW4pIGNhbnZhcy5yZW1vdmUoKTtcbiAgICAgIHZhciBjb250ZXh0T3B0aW9ucyA9IF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgcHJlc2VydmVEcmF3aW5nQnVmZmVyOiBmYWxzZSxcbiAgICAgICAgYW50aWFsaWFzOiBmYWxzZVxuICAgICAgfSwgb3B0aW9ucyB8fCB7fSk7XG4gICAgICB2YXIgY29udGV4dDtcblxuICAgICAgLy8gRmlyc3Qgd2UgdHJ5IHdlYmdsMiBmb3IgYW4gZWFzeSBwZXJmb3JtYW5jZSBib29zdFxuICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2wyXCIsIGNvbnRleHRPcHRpb25zKTtcblxuICAgICAgLy8gRWxzZSB3ZSBmYWxsIGJhY2sgdG8gd2ViZ2xcbiAgICAgIGlmICghY29udGV4dCkgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwid2ViZ2xcIiwgY29udGV4dE9wdGlvbnMpO1xuXG4gICAgICAvLyBFZGdlLCBJIGFtIGxvb2tpbmcgcmlnaHQgYXQgeW91Li4uXG4gICAgICBpZiAoIWNvbnRleHQpIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcImV4cGVyaW1lbnRhbC13ZWJnbFwiLCBjb250ZXh0T3B0aW9ucyk7XG4gICAgICB2YXIgZ2wgPSBjb250ZXh0O1xuICAgICAgdGhpcy53ZWJHTENvbnRleHRzW2lkXSA9IGdsO1xuXG4gICAgICAvLyBCbGVuZGluZzpcbiAgICAgIGdsLmJsZW5kRnVuYyhnbC5PTkUsIGdsLk9ORV9NSU5VU19TUkNfQUxQSEEpO1xuXG4gICAgICAvLyBQcmVwYXJlIGZyYW1lIGJ1ZmZlciBmb3IgcGlja2luZyBsYXllcnM6XG4gICAgICBpZiAob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgJiYgb3B0aW9ucy5waWNraW5nKSB7XG4gICAgICAgIHRoaXMucGlja2luZ0xheWVycy5hZGQoaWQpO1xuICAgICAgICB2YXIgbmV3RnJhbWVCdWZmZXIgPSBnbC5jcmVhdGVGcmFtZWJ1ZmZlcigpO1xuICAgICAgICBpZiAoIW5ld0ZyYW1lQnVmZmVyKSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogY2Fubm90IGNyZWF0ZSBhIG5ldyBmcmFtZSBidWZmZXIgZm9yIGxheWVyIFwiLmNvbmNhdChpZCkpO1xuICAgICAgICB0aGlzLmZyYW1lQnVmZmVyc1tpZF0gPSBuZXdGcmFtZUJ1ZmZlcjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCAocmUpYmluZGluZyBXZWJHTCB0ZXh0dXJlIChmb3IgcGlja2luZykuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZXNldFdlYkdMVGV4dHVyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZXNldFdlYkdMVGV4dHVyZShpZCkge1xuICAgICAgdmFyIGdsID0gdGhpcy53ZWJHTENvbnRleHRzW2lkXTtcbiAgICAgIHZhciBmcmFtZUJ1ZmZlciA9IHRoaXMuZnJhbWVCdWZmZXJzW2lkXTtcbiAgICAgIHZhciBjdXJyZW50VGV4dHVyZSA9IHRoaXMudGV4dHVyZXNbaWRdO1xuICAgICAgaWYgKGN1cnJlbnRUZXh0dXJlKSBnbC5kZWxldGVUZXh0dXJlKGN1cnJlbnRUZXh0dXJlKTtcbiAgICAgIHZhciBwaWNraW5nVGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIGdsLmJpbmRGcmFtZWJ1ZmZlcihnbC5GUkFNRUJVRkZFUiwgZnJhbWVCdWZmZXIpO1xuICAgICAgZ2wuYmluZFRleHR1cmUoZ2wuVEVYVFVSRV8yRCwgcGlja2luZ1RleHR1cmUpO1xuICAgICAgZ2wudGV4SW1hZ2UyRChnbC5URVhUVVJFXzJELCAwLCBnbC5SR0JBLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgMCwgZ2wuUkdCQSwgZ2wuVU5TSUdORURfQllURSwgbnVsbCk7XG4gICAgICBnbC5mcmFtZWJ1ZmZlclRleHR1cmUyRChnbC5GUkFNRUJVRkZFUiwgZ2wuQ09MT1JfQVRUQUNITUVOVDAsIGdsLlRFWFRVUkVfMkQsIHBpY2tpbmdUZXh0dXJlLCAwKTtcbiAgICAgIHRoaXMudGV4dHVyZXNbaWRdID0gcGlja2luZ1RleHR1cmU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgYmluZGluZyBjYW1lcmEgaGFuZGxlcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJiaW5kQ2FtZXJhSGFuZGxlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZENhbWVyYUhhbmRsZXJzKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIF90aGlzMi5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuY2FtZXJhLm9uKFwidXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jYW1lcmEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVuYmluZGluZyBjYW1lcmEgaGFuZGxlcnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1bmJpbmRDYW1lcmFIYW5kbGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRDYW1lcmFIYW5kbGVycygpIHtcbiAgICAgIHRoaXMuY2FtZXJhLnJlbW92ZUxpc3RlbmVyKFwidXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jYW1lcmEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgcmV0dXJucyB0aGUgY2xvc2VzdCBub2RlIHRvIGEgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Tm9kZUF0UG9zaXRpb25cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9kZUF0UG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICAgIHZhciB4ID0gcG9zaXRpb24ueCxcbiAgICAgICAgeSA9IHBvc2l0aW9uLnk7XG4gICAgICB2YXIgY29sb3IgPSBnZXRQaXhlbENvbG9yKHRoaXMud2ViR0xDb250ZXh0cy5ub2RlcywgdGhpcy5mcmFtZUJ1ZmZlcnMubm9kZXMsIHgsIHksIHRoaXMucGl4ZWxSYXRpbywgdGhpcy5waWNraW5nRG93blNpemluZ1JhdGlvKTtcbiAgICAgIHZhciBpbmRleCA9IGNvbG9yVG9JbmRleC5hcHBseSh2b2lkIDAsIF90b0NvbnN1bWFibGVBcnJheShjb2xvcikpO1xuICAgICAgdmFyIGl0ZW1BdCA9IHRoaXMuaXRlbUlEc0luZGV4W2luZGV4XTtcbiAgICAgIHJldHVybiBpdGVtQXQgJiYgaXRlbUF0LnR5cGUgPT09IFwibm9kZVwiID8gaXRlbUF0LmlkIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgYmluZGluZyBldmVudCBoYW5kbGVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImJpbmRFdmVudEhhbmRsZXJzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGJpbmRFdmVudEhhbmRsZXJzKCkge1xuICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XG4gICAgICAvLyBIYW5kbGluZyB3aW5kb3cgcmVzaXplXG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVSZXNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIG5lZWQgdG8gY2FsbCBhIHJlZnJlc2ggdG8gcmVidWlsZCB0aGUgbGFiZWxncmlkXG4gICAgICAgIF90aGlzMy5zY2hlZHVsZVJlZnJlc2goKTtcbiAgICAgIH07XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVSZXNpemUpO1xuXG4gICAgICAvLyBIYW5kbGluZyBtb3VzZSBtb3ZlXG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVNb3ZlID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgdmFyIGJhc2VFdmVudCA9IHtcbiAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICBwcmV2ZW50U2lnbWFEZWZhdWx0OiBmdW5jdGlvbiBwcmV2ZW50U2lnbWFEZWZhdWx0KCkge1xuICAgICAgICAgICAgZS5wcmV2ZW50U2lnbWFEZWZhdWx0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgbm9kZVRvSG92ZXIgPSBfdGhpczMuZ2V0Tm9kZUF0UG9zaXRpb24oZSk7XG4gICAgICAgIGlmIChub2RlVG9Ib3ZlciAmJiBfdGhpczMuaG92ZXJlZE5vZGUgIT09IG5vZGVUb0hvdmVyICYmICFfdGhpczMubm9kZURhdGFDYWNoZVtub2RlVG9Ib3Zlcl0uaGlkZGVuKSB7XG4gICAgICAgICAgLy8gSGFuZGxpbmcgcGFzc2luZyBmcm9tIG9uZSBub2RlIHRvIHRoZSBvdGhlciBkaXJlY3RseVxuICAgICAgICAgIGlmIChfdGhpczMuaG92ZXJlZE5vZGUpIF90aGlzMy5lbWl0KFwibGVhdmVOb2RlXCIsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpLCB7fSwge1xuICAgICAgICAgICAgbm9kZTogX3RoaXMzLmhvdmVyZWROb2RlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIF90aGlzMy5ob3ZlcmVkTm9kZSA9IG5vZGVUb0hvdmVyO1xuICAgICAgICAgIF90aGlzMy5lbWl0KFwiZW50ZXJOb2RlXCIsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpLCB7fSwge1xuICAgICAgICAgICAgbm9kZTogbm9kZVRvSG92ZXJcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgX3RoaXMzLnNjaGVkdWxlSGlnaGxpZ2h0ZWROb2Rlc1JlbmRlcigpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENoZWNraW5nIGlmIHRoZSBob3ZlcmVkIG5vZGUgaXMgc3RpbGwgaG92ZXJlZFxuICAgICAgICBpZiAoX3RoaXMzLmhvdmVyZWROb2RlKSB7XG4gICAgICAgICAgaWYgKF90aGlzMy5nZXROb2RlQXRQb3NpdGlvbihlKSAhPT0gX3RoaXMzLmhvdmVyZWROb2RlKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IF90aGlzMy5ob3ZlcmVkTm9kZTtcbiAgICAgICAgICAgIF90aGlzMy5ob3ZlcmVkTm9kZSA9IG51bGw7XG4gICAgICAgICAgICBfdGhpczMuZW1pdChcImxlYXZlTm9kZVwiLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYmFzZUV2ZW50KSwge30sIHtcbiAgICAgICAgICAgICAgbm9kZTogbm9kZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgX3RoaXMzLnNjaGVkdWxlSGlnaGxpZ2h0ZWROb2Rlc1JlbmRlcigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMzLnNldHRpbmdzLmVuYWJsZUVkZ2VFdmVudHMpIHtcbiAgICAgICAgICB2YXIgZWRnZVRvSG92ZXIgPSBfdGhpczMuaG92ZXJlZE5vZGUgPyBudWxsIDogX3RoaXMzLmdldEVkZ2VBdFBvaW50KGJhc2VFdmVudC5ldmVudC54LCBiYXNlRXZlbnQuZXZlbnQueSk7XG4gICAgICAgICAgaWYgKGVkZ2VUb0hvdmVyICE9PSBfdGhpczMuaG92ZXJlZEVkZ2UpIHtcbiAgICAgICAgICAgIGlmIChfdGhpczMuaG92ZXJlZEVkZ2UpIF90aGlzMy5lbWl0KFwibGVhdmVFZGdlXCIsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpLCB7fSwge1xuICAgICAgICAgICAgICBlZGdlOiBfdGhpczMuaG92ZXJlZEVkZ2VcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIGlmIChlZGdlVG9Ib3ZlcikgX3RoaXMzLmVtaXQoXCJlbnRlckVkZ2VcIiwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGJhc2VFdmVudCksIHt9LCB7XG4gICAgICAgICAgICAgIGVkZ2U6IGVkZ2VUb0hvdmVyXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBfdGhpczMuaG92ZXJlZEVkZ2UgPSBlZGdlVG9Ib3ZlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIEhhbmRsaW5nIG1vdXNlIGxlYXZlIHN0YWdlOlxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlTGVhdmUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgYmFzZUV2ZW50ID0ge1xuICAgICAgICAgIGV2ZW50OiBlLFxuICAgICAgICAgIHByZXZlbnRTaWdtYURlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnRTaWdtYURlZmF1bHQoKSB7XG4gICAgICAgICAgICBlLnByZXZlbnRTaWdtYURlZmF1bHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChfdGhpczMuaG92ZXJlZE5vZGUpIHtcbiAgICAgICAgICBfdGhpczMuZW1pdChcImxlYXZlTm9kZVwiLCBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgYmFzZUV2ZW50KSwge30sIHtcbiAgICAgICAgICAgIG5vZGU6IF90aGlzMy5ob3ZlcmVkTm9kZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBfdGhpczMuc2NoZWR1bGVIaWdobGlnaHRlZE5vZGVzUmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF90aGlzMy5zZXR0aW5ncy5lbmFibGVFZGdlRXZlbnRzICYmIF90aGlzMy5ob3ZlcmVkRWRnZSkge1xuICAgICAgICAgIF90aGlzMy5lbWl0KFwibGVhdmVFZGdlXCIsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpLCB7fSwge1xuICAgICAgICAgICAgZWRnZTogX3RoaXMzLmhvdmVyZWRFZGdlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIF90aGlzMy5zY2hlZHVsZUhpZ2hsaWdodGVkTm9kZXNSZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpczMuZW1pdChcImxlYXZlU3RhZ2VcIiwgX29iamVjdFNwcmVhZDIoe30sIGJhc2VFdmVudCkpO1xuICAgICAgfTtcblxuICAgICAgLy8gSGFuZGxpbmcgbW91c2UgZW50ZXIgc3RhZ2U6XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVFbnRlciA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBiYXNlRXZlbnQgPSB7XG4gICAgICAgICAgZXZlbnQ6IGUsXG4gICAgICAgICAgcHJldmVudFNpZ21hRGVmYXVsdDogZnVuY3Rpb24gcHJldmVudFNpZ21hRGVmYXVsdCgpIHtcbiAgICAgICAgICAgIGUucHJldmVudFNpZ21hRGVmYXVsdCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMzLmVtaXQoXCJlbnRlclN0YWdlXCIsIF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEhhbmRsaW5nIGNsaWNrXG4gICAgICB2YXIgY3JlYXRlTW91c2VMaXN0ZW5lciA9IGZ1bmN0aW9uIGNyZWF0ZU1vdXNlTGlzdGVuZXIoZXZlbnRUeXBlKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIHZhciBiYXNlRXZlbnQgPSB7XG4gICAgICAgICAgICBldmVudDogZSxcbiAgICAgICAgICAgIHByZXZlbnRTaWdtYURlZmF1bHQ6IGZ1bmN0aW9uIHByZXZlbnRTaWdtYURlZmF1bHQoKSB7XG4gICAgICAgICAgICAgIGUucHJldmVudFNpZ21hRGVmYXVsdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIGlzRmFrZVNpZ21hTW91c2VFdmVudCA9IGUub3JpZ2luYWwuaXNGYWtlU2lnbWFNb3VzZUV2ZW50O1xuICAgICAgICAgIHZhciBub2RlQXRQb3NpdGlvbiA9IGlzRmFrZVNpZ21hTW91c2VFdmVudCA/IF90aGlzMy5nZXROb2RlQXRQb3NpdGlvbihlKSA6IF90aGlzMy5ob3ZlcmVkTm9kZTtcbiAgICAgICAgICBpZiAobm9kZUF0UG9zaXRpb24pIHJldHVybiBfdGhpczMuZW1pdChcIlwiLmNvbmNhdChldmVudFR5cGUsIFwiTm9kZVwiKSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIGJhc2VFdmVudCksIHt9LCB7XG4gICAgICAgICAgICBub2RlOiBub2RlQXRQb3NpdGlvblxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICBpZiAoX3RoaXMzLnNldHRpbmdzLmVuYWJsZUVkZ2VFdmVudHMpIHtcbiAgICAgICAgICAgIHZhciBlZGdlID0gX3RoaXMzLmdldEVkZ2VBdFBvaW50KGUueCwgZS55KTtcbiAgICAgICAgICAgIGlmIChlZGdlKSByZXR1cm4gX3RoaXMzLmVtaXQoXCJcIi5jb25jYXQoZXZlbnRUeXBlLCBcIkVkZ2VcIiksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBiYXNlRXZlbnQpLCB7fSwge1xuICAgICAgICAgICAgICBlZGdlOiBlZGdlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBfdGhpczMuZW1pdChcIlwiLmNvbmNhdChldmVudFR5cGUsIFwiU3RhZ2VcIiksIGJhc2VFdmVudCk7XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlQ2xpY2sgPSBjcmVhdGVNb3VzZUxpc3RlbmVyKFwiY2xpY2tcIik7XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVSaWdodENsaWNrID0gY3JlYXRlTW91c2VMaXN0ZW5lcihcInJpZ2h0Q2xpY2tcIik7XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVEb3VibGVDbGljayA9IGNyZWF0ZU1vdXNlTGlzdGVuZXIoXCJkb3VibGVDbGlja1wiKTtcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZVdoZWVsID0gY3JlYXRlTW91c2VMaXN0ZW5lcihcIndoZWVsXCIpO1xuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlRG93biA9IGNyZWF0ZU1vdXNlTGlzdGVuZXIoXCJkb3duXCIpO1xuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlVXAgPSBjcmVhdGVNb3VzZUxpc3RlbmVyKFwidXBcIik7XG4gICAgICB0aGlzLm1vdXNlQ2FwdG9yLm9uKFwibW91c2Vtb3ZlXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZU1vdmUpO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcImNsaWNrXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZUNsaWNrKTtcbiAgICAgIHRoaXMubW91c2VDYXB0b3Iub24oXCJyaWdodENsaWNrXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZVJpZ2h0Q2xpY2spO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcImRvdWJsZUNsaWNrXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZURvdWJsZUNsaWNrKTtcbiAgICAgIHRoaXMubW91c2VDYXB0b3Iub24oXCJ3aGVlbFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5oYW5kbGVXaGVlbCk7XG4gICAgICB0aGlzLm1vdXNlQ2FwdG9yLm9uKFwibW91c2Vkb3duXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmhhbmRsZURvd24pO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcIm1vdXNldXBcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlVXApO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcIm1vdXNlbGVhdmVcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlTGVhdmUpO1xuICAgICAgdGhpcy5tb3VzZUNhcHRvci5vbihcIm1vdXNlZW50ZXJcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlRW50ZXIpO1xuXG4gICAgICAvLyBUT0RPXG4gICAgICAvLyBEZWFsIHdpdGggVG91Y2ggY2FwdG9yIGV2ZW50c1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgYmluZGluZyBncmFwaCBoYW5kbGVyc1xuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYmluZEdyYXBoSGFuZGxlcnNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYmluZEdyYXBoSGFuZGxlcnMoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIHZhciBncmFwaCA9IHRoaXMuZ3JhcGg7XG4gICAgICB2YXIgTEFZT1VUX0lNUEFDVElOR19GSUVMRFMgPSBuZXcgU2V0KFtcInhcIiwgXCJ5XCIsIFwiekluZGV4XCIsIFwidHlwZVwiXSk7XG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5lYWNoTm9kZUF0dHJpYnV0ZXNVcGRhdGVkR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgX2UkaGludHM7XG4gICAgICAgIHZhciB1cGRhdGVkRmllbGRzID0gKF9lJGhpbnRzID0gZS5oaW50cykgPT09IG51bGwgfHwgX2UkaGludHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lJGhpbnRzLmF0dHJpYnV0ZXM7XG4gICAgICAgIC8vIHdlIHByb2Nlc3MgYWxsIG5vZGVzXG4gICAgICAgIF90aGlzNC5ncmFwaC5mb3JFYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczQudXBkYXRlTm9kZShub2RlKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gaWYgY29vcmQsIHR5cGUgb3IgekluZGV4IGhhdmUgY2hhbmdlZCwgd2UgbmVlZCB0byBzY2hlZHVsZSBhIHJlbmRlclxuICAgICAgICAvLyAoekluZGV4IGZvciB0aGUgcHJvZ3JhbUluZGV4KVxuICAgICAgICB2YXIgbGF5b3V0Q2hhbmdlZCA9ICF1cGRhdGVkRmllbGRzIHx8IHVwZGF0ZWRGaWVsZHMuc29tZShmdW5jdGlvbiAoZikge1xuICAgICAgICAgIHJldHVybiBMQVlPVVRfSU1QQUNUSU5HX0ZJRUxEUy5oYXMoZik7XG4gICAgICAgIH0pO1xuICAgICAgICBfdGhpczQucmVmcmVzaCh7XG4gICAgICAgICAgcGFydGlhbEdyYXBoOiB7XG4gICAgICAgICAgICBub2RlczogZ3JhcGgubm9kZXMoKVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2tpcEluZGV4YXRpb246ICFsYXlvdXRDaGFuZ2VkLFxuICAgICAgICAgIHNjaGVkdWxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmVhY2hFZGdlQXR0cmlidXRlc1VwZGF0ZWRHcmFwaFVwZGF0ZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHZhciBfZSRoaW50czI7XG4gICAgICAgIHZhciB1cGRhdGVkRmllbGRzID0gKF9lJGhpbnRzMiA9IGUuaGludHMpID09PSBudWxsIHx8IF9lJGhpbnRzMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UkaGludHMyLmF0dHJpYnV0ZXM7XG4gICAgICAgIC8vIHdlIHByb2Nlc3MgYWxsIGVkZ2VzXG4gICAgICAgIF90aGlzNC5ncmFwaC5mb3JFYWNoRWRnZShmdW5jdGlvbiAoZWRnZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczQudXBkYXRlRWRnZShlZGdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBsYXlvdXRDaGFuZ2VkID0gdXBkYXRlZEZpZWxkcyAmJiBbXCJ6SW5kZXhcIiwgXCJ0eXBlXCJdLnNvbWUoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlZEZpZWxkcyA9PT0gbnVsbCB8fCB1cGRhdGVkRmllbGRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1cGRhdGVkRmllbGRzLmluY2x1ZGVzKGYpO1xuICAgICAgICB9KTtcbiAgICAgICAgX3RoaXM0LnJlZnJlc2goe1xuICAgICAgICAgIHBhcnRpYWxHcmFwaDoge1xuICAgICAgICAgICAgZWRnZXM6IGdyYXBoLmVkZ2VzKClcbiAgICAgICAgICB9LFxuICAgICAgICAgIHNraXBJbmRleGF0aW9uOiAhbGF5b3V0Q2hhbmdlZCxcbiAgICAgICAgICBzY2hlZHVsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE9uIGFkZCBub2RlLCB3ZSBhZGQgdGhlIG5vZGUgaW4gaW5kaWNlcyBhbmQgdGhlbiBjYWxsIGZvciBhIHJlbmRlclxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuYWRkTm9kZUdyYXBoVXBkYXRlID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBwYXlsb2FkLmtleTtcbiAgICAgICAgLy8gd2UgcHJvY2VzcyB0aGUgbm9kZVxuICAgICAgICBfdGhpczQuYWRkTm9kZShub2RlKTtcbiAgICAgICAgLy8gc2NoZWR1bGUgYSByZW5kZXIgZm9yIHRoZSBub2RlXG4gICAgICAgIF90aGlzNC5yZWZyZXNoKHtcbiAgICAgICAgICBwYXJ0aWFsR3JhcGg6IHtcbiAgICAgICAgICAgIG5vZGVzOiBbbm9kZV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNraXBJbmRleGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICBzY2hlZHVsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE9uIHVwZGF0ZSBub2RlLCB3ZSB1cGRhdGUgaW5kaWNlcyBhbmQgdGhlbiBjYWxsIGZvciBhIHJlbmRlclxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMudXBkYXRlTm9kZUdyYXBoVXBkYXRlID0gZnVuY3Rpb24gKHBheWxvYWQpIHtcbiAgICAgICAgdmFyIG5vZGUgPSBwYXlsb2FkLmtleTtcbiAgICAgICAgLy8gc2NoZWR1bGUgYSByZW5kZXIgZm9yIHRoZSBub2RlXG4gICAgICAgIF90aGlzNC5yZWZyZXNoKHtcbiAgICAgICAgICBwYXJ0aWFsR3JhcGg6IHtcbiAgICAgICAgICAgIG5vZGVzOiBbbm9kZV1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHNraXBJbmRleGF0aW9uOiBmYWxzZSxcbiAgICAgICAgICBzY2hlZHVsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE9uIGRyb3Agbm9kZSwgd2UgcmVtb3ZlIHRoZSBub2RlIGZyb20gaW5kaWNlcyBhbmQgdGhlbiBjYWxsIGZvciBhIHJlZnJlc2hcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmRyb3BOb2RlR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAocGF5bG9hZCkge1xuICAgICAgICB2YXIgbm9kZSA9IHBheWxvYWQua2V5O1xuICAgICAgICAvLyB3ZSBwcm9jZXNzIHRoZSBub2RlXG4gICAgICAgIF90aGlzNC5yZW1vdmVOb2RlKG5vZGUpO1xuICAgICAgICAvLyBzY2hlZHVsZSBhIHJlbmRlciBmb3IgZXZlcnl0aGluZ1xuICAgICAgICBfdGhpczQucmVmcmVzaCh7XG4gICAgICAgICAgc2NoZWR1bGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBPbiBhZGQgZWRnZSwgd2UgcmVtb3ZlIHRoZSBlZGdlIGZyb20gaW5kaWNlcyBhbmQgdGhlbiBjYWxsIGZvciBhIHJlZnJlc2hcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmFkZEVkZ2VHcmFwaFVwZGF0ZSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBlZGdlID0gcGF5bG9hZC5rZXk7XG4gICAgICAgIC8vIHdlIHByb2Nlc3MgdGhlIGVkZ2VcbiAgICAgICAgX3RoaXM0LmFkZEVkZ2UoZWRnZSk7XG4gICAgICAgIC8vIHNjaGVkdWxlIGEgcmVuZGVyIGZvciB0aGUgZWRnZVxuICAgICAgICBfdGhpczQucmVmcmVzaCh7XG4gICAgICAgICAgcGFydGlhbEdyYXBoOiB7XG4gICAgICAgICAgICBlZGdlczogW2VkZ2VdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBzY2hlZHVsZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIC8vIE9uIHVwZGF0ZSBlZGdlLCB3ZSB1cGRhdGUgaW5kaWNlcyBhbmQgdGhlbiBjYWxsIGZvciBhIHJlZnJlc2hcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLnVwZGF0ZUVkZ2VHcmFwaFVwZGF0ZSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBlZGdlID0gcGF5bG9hZC5rZXk7XG4gICAgICAgIC8vIHNjaGVkdWxlIGEgcmVwYWludCBmb3IgdGhlIGVkZ2VcbiAgICAgICAgX3RoaXM0LnJlZnJlc2goe1xuICAgICAgICAgIHBhcnRpYWxHcmFwaDoge1xuICAgICAgICAgICAgZWRnZXM6IFtlZGdlXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgc2tpcEluZGV4YXRpb246IGZhbHNlLFxuICAgICAgICAgIHNjaGVkdWxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLy8gT24gZHJvcCBlZGdlLCB3ZSByZW1vdmUgdGhlIGVkZ2UgZnJvbSBpbmRpY2VzIGFuZCB0aGVuIGNhbGwgZm9yIGEgcmVmcmVzaFxuICAgICAgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZHJvcEVkZ2VHcmFwaFVwZGF0ZSA9IGZ1bmN0aW9uIChwYXlsb2FkKSB7XG4gICAgICAgIHZhciBlZGdlID0gcGF5bG9hZC5rZXk7XG4gICAgICAgIC8vIHdlIHByb2Nlc3MgdGhlIGVkZ2VcbiAgICAgICAgX3RoaXM0LnJlbW92ZUVkZ2UoZWRnZSk7XG4gICAgICAgIC8vIHNjaGVkdWxlIGEgcmVuZGVyIGZvciBhbGwgZWRnZXNcbiAgICAgICAgX3RoaXM0LnJlZnJlc2goe1xuICAgICAgICAgIHNjaGVkdWxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgLy8gT24gY2xlYXIgZWRnZXMsIHdlIGNsZWFyIHRoZSBlZGdlIGluZGljZXMgYW5kIHRoZW4gY2FsbCBmb3IgYSByZWZyZXNoXG4gICAgICB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jbGVhckVkZ2VzR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIHdlIGNsZWFyIHRoZSBlZGdlIGRhdGEgc3RydWN0dXJlc1xuICAgICAgICBfdGhpczQuY2xlYXJFZGdlU3RhdGUoKTtcbiAgICAgICAgX3RoaXM0LmNsZWFyRWRnZUluZGljZXMoKTtcbiAgICAgICAgLy8gc2NoZWR1bGUgYSByZW5kZXIgZm9yIGFsbCBlZGdlc1xuICAgICAgICBfdGhpczQucmVmcmVzaCh7XG4gICAgICAgICAgc2NoZWR1bGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICAvLyBPbiBncmFwaCBjbGVhciwgd2UgY2xlYXIgaW5kaWNlcyBhbmQgdGhlbiBjYWxsIGZvciBhIHJlZnJlc2hcbiAgICAgIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmNsZWFyR3JhcGhVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGNsZWFyIGdyYXBoIHN0YXRlXG4gICAgICAgIF90aGlzNC5jbGVhckVkZ2VTdGF0ZSgpO1xuICAgICAgICBfdGhpczQuY2xlYXJOb2RlU3RhdGUoKTtcblxuICAgICAgICAvLyBjbGVhciBncmFwaCBpbmRpY2VzXG4gICAgICAgIF90aGlzNC5jbGVhckVkZ2VJbmRpY2VzKCk7XG4gICAgICAgIF90aGlzNC5jbGVhck5vZGVJbmRpY2VzKCk7XG5cbiAgICAgICAgLy8gc2NoZWR1bGUgYSByZW5kZXIgZm9yIGFsbFxuICAgICAgICBfdGhpczQucmVmcmVzaCh7XG4gICAgICAgICAgc2NoZWR1bGU6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgZ3JhcGgub24oXCJub2RlQWRkZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuYWRkTm9kZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLm9uKFwibm9kZURyb3BwZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZHJvcE5vZGVHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5vbihcIm5vZGVBdHRyaWJ1dGVzVXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy51cGRhdGVOb2RlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgub24oXCJlYWNoTm9kZUF0dHJpYnV0ZXNVcGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmVhY2hOb2RlQXR0cmlidXRlc1VwZGF0ZWRHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5vbihcImVkZ2VBZGRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5hZGRFZGdlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgub24oXCJlZGdlRHJvcHBlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5kcm9wRWRnZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLm9uKFwiZWRnZUF0dHJpYnV0ZXNVcGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLnVwZGF0ZUVkZ2VHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5vbihcImVhY2hFZGdlQXR0cmlidXRlc1VwZGF0ZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZWFjaEVkZ2VBdHRyaWJ1dGVzVXBkYXRlZEdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLm9uKFwiZWRnZXNDbGVhcmVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmNsZWFyRWRnZXNHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5vbihcImNsZWFyZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuY2xlYXJHcmFwaFVwZGF0ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byB1bmJpbmQgaGFuZGxlcnMgZnJvbSB0aGUgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt1bmRlZmluZWR9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidW5iaW5kR3JhcGhIYW5kbGVyc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bmJpbmRHcmFwaEhhbmRsZXJzKCkge1xuICAgICAgdmFyIGdyYXBoID0gdGhpcy5ncmFwaDtcbiAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwibm9kZUFkZGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmFkZE5vZGVHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5yZW1vdmVMaXN0ZW5lcihcIm5vZGVEcm9wcGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmRyb3BOb2RlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJub2RlQXR0cmlidXRlc1VwZGF0ZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMudXBkYXRlTm9kZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwiZWFjaE5vZGVBdHRyaWJ1dGVzVXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5lYWNoTm9kZUF0dHJpYnV0ZXNVcGRhdGVkR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJlZGdlQWRkZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuYWRkRWRnZUdyYXBoVXBkYXRlKTtcbiAgICAgIGdyYXBoLnJlbW92ZUxpc3RlbmVyKFwiZWRnZURyb3BwZWRcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuZHJvcEVkZ2VHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5yZW1vdmVMaXN0ZW5lcihcImVkZ2VBdHRyaWJ1dGVzVXBkYXRlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy51cGRhdGVFZGdlR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJlYWNoRWRnZUF0dHJpYnV0ZXNVcGRhdGVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmVhY2hFZGdlQXR0cmlidXRlc1VwZGF0ZWRHcmFwaFVwZGF0ZSk7XG4gICAgICBncmFwaC5yZW1vdmVMaXN0ZW5lcihcImVkZ2VzQ2xlYXJlZFwiLCB0aGlzLmFjdGl2ZUxpc3RlbmVycy5jbGVhckVkZ2VzR3JhcGhVcGRhdGUpO1xuICAgICAgZ3JhcGgucmVtb3ZlTGlzdGVuZXIoXCJjbGVhcmVkXCIsIHRoaXMuYWN0aXZlTGlzdGVuZXJzLmNsZWFyR3JhcGhVcGRhdGUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCBsb29raW5nIGZvciBhbiBlZGdlIGNvbGxpZGluZyB3aXRoIGEgZ2l2ZW4gcG9pbnQgYXQgKHgsIHkpLiBSZXR1cm5zXG4gICAgICogdGhlIGtleSBvZiB0aGUgZWRnZSBpZiBhbnksIG9yIG51bGwgZWxzZS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRFZGdlQXRQb2ludFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRFZGdlQXRQb2ludCh4LCB5KSB7XG4gICAgICB2YXIgY29sb3IgPSBnZXRQaXhlbENvbG9yKHRoaXMud2ViR0xDb250ZXh0cy5lZGdlcywgdGhpcy5mcmFtZUJ1ZmZlcnMuZWRnZXMsIHgsIHksIHRoaXMucGl4ZWxSYXRpbywgdGhpcy5waWNraW5nRG93blNpemluZ1JhdGlvKTtcbiAgICAgIHZhciBpbmRleCA9IGNvbG9yVG9JbmRleC5hcHBseSh2b2lkIDAsIF90b0NvbnN1bWFibGVBcnJheShjb2xvcikpO1xuICAgICAgdmFyIGl0ZW1BdCA9IHRoaXMuaXRlbUlEc0luZGV4W2luZGV4XTtcbiAgICAgIHJldHVybiBpdGVtQXQgJiYgaXRlbUF0LnR5cGUgPT09IFwiZWRnZVwiID8gaXRlbUF0LmlkIDogbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBwcm9jZXNzIHRoZSB3aG9sZSBncmFwaCdzIGRhdGEuXG4gICAgICogIC0gZXh0ZW50XG4gICAgICogIC0gbm9ybWFsaXphdGlvbkZ1bmN0aW9uXG4gICAgICogIC0gY29tcHV0ZSBub2RlJ3MgY29vcmRpbmF0ZVxuICAgICAqICAtIGxhYmVsZ3JpZFxuICAgICAqICAtIHByb2dyYW0gZGF0YSBhbGxvY2F0aW9uXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicHJvY2Vzc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzKCkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG4gICAgICB2YXIgZ3JhcGggPSB0aGlzLmdyYXBoO1xuICAgICAgdmFyIHNldHRpbmdzID0gdGhpcy5zZXR0aW5ncztcbiAgICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zKCk7XG5cbiAgICAgIC8vXG4gICAgICAvLyBOT0RFU1xuICAgICAgLy9cbiAgICAgIHRoaXMubm9kZUV4dGVudCA9IGdyYXBoRXh0ZW50KHRoaXMuZ3JhcGgpO1xuICAgICAgdGhpcy5ub3JtYWxpemF0aW9uRnVuY3Rpb24gPSBjcmVhdGVOb3JtYWxpemF0aW9uRnVuY3Rpb24odGhpcy5jdXN0b21CQm94IHx8IHRoaXMubm9kZUV4dGVudCk7XG5cbiAgICAgIC8vIE5PVEU6IGl0IGlzIGltcG9ydGFudCB0byBjb21wdXRlIHRoaXMgbWF0cml4IGFmdGVyIGNvbXB1dGluZyB0aGUgbm9kZSdzIGV4dGVudFxuICAgICAgLy8gYmVjYXVzZSAjLmdldEdyYXBoRGltZW5zaW9ucyByZWxpZXMgb24gaXRcbiAgICAgIHZhciBudWxsQ2FtZXJhID0gbmV3IENhbWVyYSgpO1xuICAgICAgdmFyIG51bGxDYW1lcmFNYXRyaXggPSBtYXRyaXhGcm9tQ2FtZXJhKG51bGxDYW1lcmEuZ2V0U3RhdGUoKSwgZGltZW5zaW9ucywgdGhpcy5nZXRHcmFwaERpbWVuc2lvbnMoKSwgdGhpcy5nZXRTZXR0aW5nKFwic3RhZ2VQYWRkaW5nXCIpIHx8IDApO1xuICAgICAgLy8gUmVzZXR0aW5nIHRoZSBsYWJlbCBncmlkXG4gICAgICAvLyBUT0RPOiBpdCdzIHByb2JhYmx5IGJldHRlciB0byBkbyB0aGlzIGV4cGxpY2l0bHkgb3Igb24gcmVzaXplcyBmb3IgbGF5b3V0IGFuZCBhbmltc1xuICAgICAgdGhpcy5sYWJlbEdyaWQucmVzaXplQW5kQ2xlYXIoZGltZW5zaW9ucywgc2V0dGluZ3MubGFiZWxHcmlkQ2VsbFNpemUpO1xuICAgICAgdmFyIG5vZGVzUGVyUHJvZ3JhbXMgPSB7fTtcbiAgICAgIHZhciBub2RlSW5kaWNlcyA9IHt9O1xuICAgICAgdmFyIGVkZ2VJbmRpY2VzID0ge307XG4gICAgICB2YXIgaXRlbUlEc0luZGV4ID0ge307XG4gICAgICB2YXIgaW5jcklEID0gMTtcbiAgICAgIHZhciBub2RlcyA9IGdyYXBoLm5vZGVzKCk7XG5cbiAgICAgIC8vIERvIHNvbWUgaW5kZXhhdGlvbiBvbiB0aGUgd2hvbGUgZ3JhcGhcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBub2RlID0gbm9kZXNbaV07XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW25vZGVdO1xuXG4gICAgICAgIC8vIEdldCBpbml0aWFsIGNvb3JkaW5hdGVzXG4gICAgICAgIHZhciBhdHRycyA9IGdyYXBoLmdldE5vZGVBdHRyaWJ1dGVzKG5vZGUpO1xuICAgICAgICBkYXRhLnggPSBhdHRycy54O1xuICAgICAgICBkYXRhLnkgPSBhdHRycy55O1xuICAgICAgICB0aGlzLm5vcm1hbGl6YXRpb25GdW5jdGlvbi5hcHBseVRvKGRhdGEpO1xuXG4gICAgICAgIC8vIGxhYmVsZ3JpZFxuICAgICAgICBpZiAodHlwZW9mIGRhdGEubGFiZWwgPT09IFwic3RyaW5nXCIgJiYgIWRhdGEuaGlkZGVuKSB0aGlzLmxhYmVsR3JpZC5hZGQobm9kZSwgZGF0YS5zaXplLCB0aGlzLmZyYW1lZEdyYXBoVG9WaWV3cG9ydChkYXRhLCB7XG4gICAgICAgICAgbWF0cml4OiBudWxsQ2FtZXJhTWF0cml4XG4gICAgICAgIH0pKTtcblxuICAgICAgICAvLyB1cGRhdGUgY291bnQgcGVyIHByb2dyYW1cbiAgICAgICAgbm9kZXNQZXJQcm9ncmFtc1tkYXRhLnR5cGVdID0gKG5vZGVzUGVyUHJvZ3JhbXNbZGF0YS50eXBlXSB8fCAwKSArIDE7XG4gICAgICB9XG4gICAgICB0aGlzLmxhYmVsR3JpZC5vcmdhbml6ZSgpO1xuXG4gICAgICAvLyBBbGxvY2F0ZSBtZW1vcnkgdG8gcHJvZ3JhbXNcbiAgICAgIGZvciAodmFyIHR5cGUgaW4gdGhpcy5ub2RlUHJvZ3JhbXMpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMubm9kZVByb2dyYW1zLCB0eXBlKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBjb3VsZCBub3QgZmluZCBhIHN1aXRhYmxlIHByb2dyYW0gZm9yIG5vZGUgdHlwZSBcXFwiXCIuY29uY2F0KHR5cGUsIFwiXFxcIiFcIikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubm9kZVByb2dyYW1zW3R5cGVdLnJlYWxsb2NhdGUobm9kZXNQZXJQcm9ncmFtc1t0eXBlXSB8fCAwKTtcbiAgICAgICAgLy8gV2UgcmVzZXQgdGhhdCBjb3VudCBoZXJlLCBzbyB0aGF0IHdlIGNhbiByZXVzZSBpdCB3aGlsZSBjYWxsaW5nIHRoZSBQcm9ncmFtI3Byb2Nlc3MgbWV0aG9kczpcbiAgICAgICAgbm9kZXNQZXJQcm9ncmFtc1t0eXBlXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIC8vIE9yZGVyIG5vZGVzIGJ5IHpJbmRleCBiZWZvcmUgdG8gYWRkIHRoZW0gdG8gcHJvZ3JhbVxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuekluZGV4ICYmIHRoaXMubm9kZVpFeHRlbnRbMF0gIT09IHRoaXMubm9kZVpFeHRlbnRbMV0pIG5vZGVzID0gekluZGV4T3JkZXJpbmcodGhpcy5ub2RlWkV4dGVudCwgZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzNS5ub2RlRGF0YUNhY2hlW25vZGVdLnpJbmRleDtcbiAgICAgIH0sIG5vZGVzKTtcblxuICAgICAgLy8gQWRkIGRhdGEgdG8gcHJvZ3JhbXNcbiAgICAgIGZvciAodmFyIF9pID0gMCwgX2wgPSBub2Rlcy5sZW5ndGg7IF9pIDwgX2w7IF9pKyspIHtcbiAgICAgICAgdmFyIF9ub2RlID0gbm9kZXNbX2ldO1xuICAgICAgICBub2RlSW5kaWNlc1tfbm9kZV0gPSBpbmNySUQ7XG4gICAgICAgIGl0ZW1JRHNJbmRleFtub2RlSW5kaWNlc1tfbm9kZV1dID0ge1xuICAgICAgICAgIHR5cGU6IFwibm9kZVwiLFxuICAgICAgICAgIGlkOiBfbm9kZVxuICAgICAgICB9O1xuICAgICAgICBpbmNySUQrKztcbiAgICAgICAgdmFyIF9kYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW19ub2RlXTtcbiAgICAgICAgdGhpcy5hZGROb2RlVG9Qcm9ncmFtKF9ub2RlLCBub2RlSW5kaWNlc1tfbm9kZV0sIG5vZGVzUGVyUHJvZ3JhbXNbX2RhdGEudHlwZV0rKyk7XG4gICAgICB9XG5cbiAgICAgIC8vXG4gICAgICAvLyBFREdFU1xuICAgICAgLy9cblxuICAgICAgdmFyIGVkZ2VzUGVyUHJvZ3JhbXMgPSB7fTtcbiAgICAgIHZhciBlZGdlcyA9IGdyYXBoLmVkZ2VzKCk7XG5cbiAgICAgIC8vIEFsbG9jYXRlIG1lbW9yeSB0byBwcm9ncmFtc1xuICAgICAgZm9yICh2YXIgX2kyID0gMCwgX2wyID0gZWRnZXMubGVuZ3RoOyBfaTIgPCBfbDI7IF9pMisrKSB7XG4gICAgICAgIHZhciBlZGdlID0gZWRnZXNbX2kyXTtcbiAgICAgICAgdmFyIF9kYXRhMiA9IHRoaXMuZWRnZURhdGFDYWNoZVtlZGdlXTtcbiAgICAgICAgZWRnZXNQZXJQcm9ncmFtc1tfZGF0YTIudHlwZV0gPSAoZWRnZXNQZXJQcm9ncmFtc1tfZGF0YTIudHlwZV0gfHwgMCkgKyAxO1xuICAgICAgfVxuXG4gICAgICAvLyBPcmRlciBlZGdlcyBieSB6SW5kZXggYmVmb3JlIHRvIGFkZCB0aGVtIHRvIHByb2dyYW1cbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLnpJbmRleCAmJiB0aGlzLmVkZ2VaRXh0ZW50WzBdICE9PSB0aGlzLmVkZ2VaRXh0ZW50WzFdKSBlZGdlcyA9IHpJbmRleE9yZGVyaW5nKHRoaXMuZWRnZVpFeHRlbnQsIGZ1bmN0aW9uIChlZGdlKSB7XG4gICAgICAgIHJldHVybiBfdGhpczUuZWRnZURhdGFDYWNoZVtlZGdlXS56SW5kZXg7XG4gICAgICB9LCBlZGdlcyk7XG4gICAgICBmb3IgKHZhciBfdHlwZTIgaW4gdGhpcy5lZGdlUHJvZ3JhbXMpIHtcbiAgICAgICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMuZWRnZVByb2dyYW1zLCBfdHlwZTIpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGNvdWxkIG5vdCBmaW5kIGEgc3VpdGFibGUgcHJvZ3JhbSBmb3IgZWRnZSB0eXBlIFxcXCJcIi5jb25jYXQoX3R5cGUyLCBcIlxcXCIhXCIpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkZ2VQcm9ncmFtc1tfdHlwZTJdLnJlYWxsb2NhdGUoZWRnZXNQZXJQcm9ncmFtc1tfdHlwZTJdIHx8IDApO1xuICAgICAgICAvLyBXZSByZXNldCB0aGF0IGNvdW50IGhlcmUsIHNvIHRoYXQgd2UgY2FuIHJldXNlIGl0IHdoaWxlIGNhbGxpbmcgdGhlIFByb2dyYW0jcHJvY2VzcyBtZXRob2RzOlxuICAgICAgICBlZGdlc1BlclByb2dyYW1zW190eXBlMl0gPSAwO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgZGF0YSB0byBwcm9ncmFtc1xuICAgICAgZm9yICh2YXIgX2kzID0gMCwgX2wzID0gZWRnZXMubGVuZ3RoOyBfaTMgPCBfbDM7IF9pMysrKSB7XG4gICAgICAgIHZhciBfZWRnZSA9IGVkZ2VzW19pM107XG4gICAgICAgIGVkZ2VJbmRpY2VzW19lZGdlXSA9IGluY3JJRDtcbiAgICAgICAgaXRlbUlEc0luZGV4W2VkZ2VJbmRpY2VzW19lZGdlXV0gPSB7XG4gICAgICAgICAgdHlwZTogXCJlZGdlXCIsXG4gICAgICAgICAgaWQ6IF9lZGdlXG4gICAgICAgIH07XG4gICAgICAgIGluY3JJRCsrO1xuICAgICAgICB2YXIgX2RhdGEzID0gdGhpcy5lZGdlRGF0YUNhY2hlW19lZGdlXTtcbiAgICAgICAgdGhpcy5hZGRFZGdlVG9Qcm9ncmFtKF9lZGdlLCBlZGdlSW5kaWNlc1tfZWRnZV0sIGVkZ2VzUGVyUHJvZ3JhbXNbX2RhdGEzLnR5cGVdKyspO1xuICAgICAgfVxuICAgICAgdGhpcy5pdGVtSURzSW5kZXggPSBpdGVtSURzSW5kZXg7XG4gICAgICB0aGlzLm5vZGVJbmRpY2VzID0gbm9kZUluZGljZXM7XG4gICAgICB0aGlzLmVkZ2VJbmRpY2VzID0gZWRnZUluZGljZXM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdGhhdCBiYWNrcG9ydHMgcG90ZW50aWFsIHNldHRpbmdzIHVwZGF0ZXMgd2hlcmUgaXQncyBuZWVkZWQuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJoYW5kbGVTZXR0aW5nc1VwZGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBoYW5kbGVTZXR0aW5nc1VwZGF0ZSgpIHtcbiAgICAgIHRoaXMuY2FtZXJhLm1pblJhdGlvID0gdGhpcy5zZXR0aW5ncy5taW5DYW1lcmFSYXRpbztcbiAgICAgIHRoaXMuY2FtZXJhLm1heFJhdGlvID0gdGhpcy5zZXR0aW5ncy5tYXhDYW1lcmFSYXRpbztcbiAgICAgIHRoaXMuY2FtZXJhLnNldFN0YXRlKHRoaXMuY2FtZXJhLnZhbGlkYXRlU3RhdGUodGhpcy5jYW1lcmEuZ2V0U3RhdGUoKSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcmVuZGVyIGxhYmVscy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckxhYmVsc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJMYWJlbHMoKSB7XG4gICAgICBpZiAoIXRoaXMuc2V0dGluZ3MucmVuZGVyTGFiZWxzKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBjYW1lcmFTdGF0ZSA9IHRoaXMuY2FtZXJhLmdldFN0YXRlKCk7XG5cbiAgICAgIC8vIFNlbGVjdGluZyBsYWJlbHMgdG8gZHJhd1xuICAgICAgdmFyIGxhYmVsc1RvRGlzcGxheSA9IHRoaXMubGFiZWxHcmlkLmdldExhYmVsc1RvRGlzcGxheShjYW1lcmFTdGF0ZS5yYXRpbywgdGhpcy5zZXR0aW5ncy5sYWJlbERlbnNpdHkpO1xuICAgICAgZXh0ZW5kKGxhYmVsc1RvRGlzcGxheSwgdGhpcy5ub2Rlc1dpdGhGb3JjZWRMYWJlbHMpO1xuICAgICAgdGhpcy5kaXNwbGF5ZWROb2RlTGFiZWxzID0gbmV3IFNldCgpO1xuXG4gICAgICAvLyBEcmF3aW5nIGxhYmVsc1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLmNhbnZhc0NvbnRleHRzLmxhYmVscztcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbGFiZWxzVG9EaXNwbGF5Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgbm9kZSA9IGxhYmVsc1RvRGlzcGxheVtpXTtcbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLm5vZGVEYXRhQ2FjaGVbbm9kZV07XG5cbiAgICAgICAgLy8gSWYgdGhlIG5vZGUgd2FzIGFscmVhZHkgZHJhd24gKGxpa2UgaWYgaXQgaXMgZWxpZ2libGUgQU5EIGhhc1xuICAgICAgICAvLyBgZm9yY2VMYWJlbGApLCB3ZSBkb24ndCB3YW50IHRvIGRyYXcgaXQgYWdhaW5cbiAgICAgICAgLy8gTk9URTogd2UgY2FuIGRvIGJldHRlciBwcm9iYWJseVxuICAgICAgICBpZiAodGhpcy5kaXNwbGF5ZWROb2RlTGFiZWxzLmhhcyhub2RlKSkgY29udGludWU7XG5cbiAgICAgICAgLy8gSWYgdGhlIG5vZGUgaXMgaGlkZGVuLCB3ZSBkb24ndCBuZWVkIHRvIGRpc3BsYXkgaXRzIGxhYmVsIG9idmlvdXNseVxuICAgICAgICBpZiAoZGF0YS5oaWRkZW4pIGNvbnRpbnVlO1xuICAgICAgICB2YXIgX3RoaXMkZnJhbWVkR3JhcGhUb1ZpID0gdGhpcy5mcmFtZWRHcmFwaFRvVmlld3BvcnQoZGF0YSksXG4gICAgICAgICAgeCA9IF90aGlzJGZyYW1lZEdyYXBoVG9WaS54LFxuICAgICAgICAgIHkgPSBfdGhpcyRmcmFtZWRHcmFwaFRvVmkueTtcblxuICAgICAgICAvLyBOT1RFOiB3ZSBjYW4gY2FjaGUgdGhlIGxhYmVscyB3ZSBuZWVkIHRvIHJlbmRlciB1bnRpbCB0aGUgY2FtZXJhJ3MgcmF0aW8gY2hhbmdlc1xuICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuc2NhbGVTaXplKGRhdGEuc2l6ZSk7XG5cbiAgICAgICAgLy8gSXMgbm9kZSBiaWcgZW5vdWdoP1xuICAgICAgICBpZiAoIWRhdGEuZm9yY2VMYWJlbCAmJiBzaXplIDwgdGhpcy5zZXR0aW5ncy5sYWJlbFJlbmRlcmVkU2l6ZVRocmVzaG9sZCkgY29udGludWU7XG5cbiAgICAgICAgLy8gSXMgbm9kZSBhY3R1YWxseSBvbiBzY3JlZW4gKHdpdGggc29tZSBtYXJnaW4pXG4gICAgICAgIC8vIE5PVEU6IHdlIHVzZWQgdG8gcmVseSBvbiB0aGUgcXVhZHRyZWUgZm9yIHRoaXMsIGJ1dCB0aGUgY29vcmRpbmF0ZXNcbiAgICAgICAgLy8gY29udmVyc2lvbiBtYWtlIGl0IHVucmVsaWFibGUgYW5kIGF0IHRoYXQgcG9pbnQgd2UgYWxyZWFkeSBjb252ZXJ0ZWRcbiAgICAgICAgLy8gdG8gdmlld3BvcnQgY29vcmRpbmF0ZXMgYW5kIHNpbmNlIHRoZSBsYWJlbCBncmlkIGFscmVhZHkgY3VsbHMgdGhlXG4gICAgICAgIC8vIG51bWJlciBvZiBwb3RlbnRpYWwgbGFiZWxzIHRvIGRpc3BsYXkgdGhpcyBsb29rcyBsaWtlIGEgZ29vZFxuICAgICAgICAvLyBwZXJmb3JtYW5jZSBjb21wcm9taXNlLlxuICAgICAgICAvLyBOT1RFOiBsYWJlbEdyaWQuZ2V0TGFiZWxzVG9EaXNwbGF5IGNvdWxkIHByb2JhYmx5IG9wdGltaXplIGJ5IG5vdFxuICAgICAgICAvLyBjb25zaWRlcmluZyBjZWxscyBvYnZpb3VzbHkgb3V0c2lkZSBvZiB0aGUgcmFuZ2Ugb2YgdGhlIGN1cnJlbnRcbiAgICAgICAgLy8gdmlldyByZWN0YW5nbGUuXG4gICAgICAgIGlmICh4IDwgLVhfTEFCRUxfTUFSR0lOIHx8IHggPiB0aGlzLndpZHRoICsgWF9MQUJFTF9NQVJHSU4gfHwgeSA8IC1ZX0xBQkVMX01BUkdJTiB8fCB5ID4gdGhpcy5oZWlnaHQgKyBZX0xBQkVMX01BUkdJTikgY29udGludWU7XG5cbiAgICAgICAgLy8gQmVjYXVzZSBkaXNwbGF5ZWQgZWRnZSBsYWJlbHMgZGVwZW5kIGRpcmVjdGx5IG9uIGFjdHVhbGx5IHJlbmRlcmVkIG5vZGVcbiAgICAgICAgLy8gbGFiZWxzLCB3ZSBuZWVkIHRvIG9ubHkgYWRkIHRvIHRoaXMuZGlzcGxheWVkTm9kZUxhYmVscyBub2RlcyB3aG9zZSBsYWJlbFxuICAgICAgICAvLyBpcyByZW5kZXJlZC5cbiAgICAgICAgLy8gVGhpcyBtYWtlcyB0aGlzLmRpc3BsYXllZE5vZGVMYWJlbHMgZGVwZW5kIG9uIHZpZXdwb3J0LCB3aGljaCBtaWdodCBiZWNvbWVcbiAgICAgICAgLy8gYW4gaXNzdWUgb25jZSB3ZSBzdGFydCBtZW1vaXppbmcgZ2V0TGFiZWxzVG9EaXNwbGF5LlxuICAgICAgICB0aGlzLmRpc3BsYXllZE5vZGVMYWJlbHMuYWRkKG5vZGUpO1xuICAgICAgICB2YXIgZGVmYXVsdERyYXdOb2RlTGFiZWwgPSB0aGlzLnNldHRpbmdzLmRlZmF1bHREcmF3Tm9kZUxhYmVsO1xuICAgICAgICB2YXIgbm9kZVByb2dyYW0gPSB0aGlzLm5vZGVQcm9ncmFtc1tkYXRhLnR5cGVdO1xuICAgICAgICB2YXIgZHJhd0xhYmVsID0gKG5vZGVQcm9ncmFtID09PSBudWxsIHx8IG5vZGVQcm9ncmFtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlUHJvZ3JhbS5kcmF3TGFiZWwpIHx8IGRlZmF1bHREcmF3Tm9kZUxhYmVsO1xuICAgICAgICBkcmF3TGFiZWwoY29udGV4dCwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIGtleTogbm9kZVxuICAgICAgICB9LCBkYXRhKSwge30sIHtcbiAgICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgeTogeVxuICAgICAgICB9KSwgdGhpcy5zZXR0aW5ncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byByZW5kZXIgZWRnZSBsYWJlbHMsIGJhc2VkIG9uIHdoaWNoIG5vZGUgbGFiZWxzIHdlcmVcbiAgICAgKiByZW5kZXJlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbmRlckVkZ2VMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVuZGVyRWRnZUxhYmVscygpIHtcbiAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5yZW5kZXJFZGdlTGFiZWxzKSByZXR1cm4gdGhpcztcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jYW52YXNDb250ZXh0cy5lZGdlTGFiZWxzO1xuXG4gICAgICAvLyBDbGVhcmluZ1xuICAgICAgY29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgdmFyIGVkZ2VMYWJlbHNUb0Rpc3BsYXkgPSBlZGdlTGFiZWxzVG9EaXNwbGF5RnJvbU5vZGVzKHtcbiAgICAgICAgZ3JhcGg6IHRoaXMuZ3JhcGgsXG4gICAgICAgIGhvdmVyZWROb2RlOiB0aGlzLmhvdmVyZWROb2RlLFxuICAgICAgICBkaXNwbGF5ZWROb2RlTGFiZWxzOiB0aGlzLmRpc3BsYXllZE5vZGVMYWJlbHMsXG4gICAgICAgIGhpZ2hsaWdodGVkTm9kZXM6IHRoaXMuaGlnaGxpZ2h0ZWROb2Rlc1xuICAgICAgfSk7XG4gICAgICBleHRlbmQoZWRnZUxhYmVsc1RvRGlzcGxheSwgdGhpcy5lZGdlc1dpdGhGb3JjZWRMYWJlbHMpO1xuICAgICAgdmFyIGRpc3BsYXllZExhYmVscyA9IG5ldyBTZXQoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZWRnZUxhYmVsc1RvRGlzcGxheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGVkZ2UgPSBlZGdlTGFiZWxzVG9EaXNwbGF5W2ldLFxuICAgICAgICAgIGV4dHJlbWl0aWVzID0gdGhpcy5ncmFwaC5leHRyZW1pdGllcyhlZGdlKSxcbiAgICAgICAgICBzb3VyY2VEYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW2V4dHJlbWl0aWVzWzBdXSxcbiAgICAgICAgICB0YXJnZXREYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW2V4dHJlbWl0aWVzWzFdXSxcbiAgICAgICAgICBlZGdlRGF0YSA9IHRoaXMuZWRnZURhdGFDYWNoZVtlZGdlXTtcblxuICAgICAgICAvLyBJZiB0aGUgZWRnZSB3YXMgYWxyZWFkeSBkcmF3biAobGlrZSBpZiBpdCBpcyBlbGlnaWJsZSBBTkQgaGFzXG4gICAgICAgIC8vIGBmb3JjZUxhYmVsYCksIHdlIGRvbid0IHdhbnQgdG8gZHJhdyBpdCBhZ2FpblxuICAgICAgICBpZiAoZGlzcGxheWVkTGFiZWxzLmhhcyhlZGdlKSkgY29udGludWU7XG5cbiAgICAgICAgLy8gSWYgdGhlIGVkZ2UgaXMgaGlkZGVuIHdlIGRvbid0IG5lZWQgdG8gZGlzcGxheSBpdHMgbGFiZWxcbiAgICAgICAgLy8gTk9URTogdGhlIHRlc3Qgb24gc291cmNlRGF0YSAmIHRhcmdldERhdGEgaXMgcHJvYmFibHkgcGFyYW5vaWQgYXQgdGhpcyBwb2ludD9cbiAgICAgICAgaWYgKGVkZ2VEYXRhLmhpZGRlbiB8fCBzb3VyY2VEYXRhLmhpZGRlbiB8fCB0YXJnZXREYXRhLmhpZGRlbikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkZWZhdWx0RHJhd0VkZ2VMYWJlbCA9IHRoaXMuc2V0dGluZ3MuZGVmYXVsdERyYXdFZGdlTGFiZWw7XG4gICAgICAgIHZhciBlZGdlUHJvZ3JhbSA9IHRoaXMuZWRnZVByb2dyYW1zW2VkZ2VEYXRhLnR5cGVdO1xuICAgICAgICB2YXIgZHJhd0xhYmVsID0gKGVkZ2VQcm9ncmFtID09PSBudWxsIHx8IGVkZ2VQcm9ncmFtID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlZGdlUHJvZ3JhbS5kcmF3TGFiZWwpIHx8IGRlZmF1bHREcmF3RWRnZUxhYmVsO1xuICAgICAgICBkcmF3TGFiZWwoY29udGV4dCwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIGtleTogZWRnZVxuICAgICAgICB9LCBlZGdlRGF0YSksIHt9LCB7XG4gICAgICAgICAgc2l6ZTogdGhpcy5zY2FsZVNpemUoZWRnZURhdGEuc2l6ZSlcbiAgICAgICAgfSksIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBrZXk6IGV4dHJlbWl0aWVzWzBdXG4gICAgICAgIH0sIHNvdXJjZURhdGEpLCB0aGlzLmZyYW1lZEdyYXBoVG9WaWV3cG9ydChzb3VyY2VEYXRhKSksIHt9LCB7XG4gICAgICAgICAgc2l6ZTogdGhpcy5zY2FsZVNpemUoc291cmNlRGF0YS5zaXplKVxuICAgICAgICB9KSwgX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgIGtleTogZXh0cmVtaXRpZXNbMV1cbiAgICAgICAgfSwgdGFyZ2V0RGF0YSksIHRoaXMuZnJhbWVkR3JhcGhUb1ZpZXdwb3J0KHRhcmdldERhdGEpKSwge30sIHtcbiAgICAgICAgICBzaXplOiB0aGlzLnNjYWxlU2l6ZSh0YXJnZXREYXRhLnNpemUpXG4gICAgICAgIH0pLCB0aGlzLnNldHRpbmdzKTtcbiAgICAgICAgZGlzcGxheWVkTGFiZWxzLmFkZChlZGdlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGlzcGxheWVkRWRnZUxhYmVscyA9IGRpc3BsYXllZExhYmVscztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHJlbmRlciB0aGUgaGlnaGxpZ2h0ZWQgbm9kZXMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJyZW5kZXJIaWdobGlnaHRlZE5vZGVzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlckhpZ2hsaWdodGVkTm9kZXMoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcy5jYW52YXNDb250ZXh0cy5ob3ZlcnM7XG5cbiAgICAgIC8vIENsZWFyaW5nXG4gICAgICBjb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cbiAgICAgIC8vIFJlbmRlcmluZ1xuICAgICAgdmFyIHJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlcihub2RlKSB7XG4gICAgICAgIHZhciBkYXRhID0gX3RoaXM2Lm5vZGVEYXRhQ2FjaGVbbm9kZV07XG4gICAgICAgIHZhciBfdGhpczYkZnJhbWVkR3JhcGhUb1YgPSBfdGhpczYuZnJhbWVkR3JhcGhUb1ZpZXdwb3J0KGRhdGEpLFxuICAgICAgICAgIHggPSBfdGhpczYkZnJhbWVkR3JhcGhUb1YueCxcbiAgICAgICAgICB5ID0gX3RoaXM2JGZyYW1lZEdyYXBoVG9WLnk7XG4gICAgICAgIHZhciBzaXplID0gX3RoaXM2LnNjYWxlU2l6ZShkYXRhLnNpemUpO1xuICAgICAgICB2YXIgZGVmYXVsdERyYXdOb2RlSG92ZXIgPSBfdGhpczYuc2V0dGluZ3MuZGVmYXVsdERyYXdOb2RlSG92ZXI7XG4gICAgICAgIHZhciBub2RlUHJvZ3JhbSA9IF90aGlzNi5ub2RlUHJvZ3JhbXNbZGF0YS50eXBlXTtcbiAgICAgICAgdmFyIGRyYXdIb3ZlciA9IChub2RlUHJvZ3JhbSA9PT0gbnVsbCB8fCBub2RlUHJvZ3JhbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZVByb2dyYW0uZHJhd0hvdmVyKSB8fCBkZWZhdWx0RHJhd05vZGVIb3ZlcjtcbiAgICAgICAgZHJhd0hvdmVyKGNvbnRleHQsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgICAgICBrZXk6IG5vZGVcbiAgICAgICAgfSwgZGF0YSksIHt9LCB7XG4gICAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIHk6IHlcbiAgICAgICAgfSksIF90aGlzNi5zZXR0aW5ncyk7XG4gICAgICB9O1xuICAgICAgdmFyIG5vZGVzVG9SZW5kZXIgPSBbXTtcbiAgICAgIGlmICh0aGlzLmhvdmVyZWROb2RlICYmICF0aGlzLm5vZGVEYXRhQ2FjaGVbdGhpcy5ob3ZlcmVkTm9kZV0uaGlkZGVuKSB7XG4gICAgICAgIG5vZGVzVG9SZW5kZXIucHVzaCh0aGlzLmhvdmVyZWROb2RlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaGlnaGxpZ2h0ZWROb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIC8vIFRoZSBob3ZlcmVkIG5vZGUgaGFzIGFscmVhZHkgYmVlbiBoaWdobGlnaHRlZFxuICAgICAgICBpZiAobm9kZSAhPT0gX3RoaXM2LmhvdmVyZWROb2RlKSBub2Rlc1RvUmVuZGVyLnB1c2gobm9kZSk7XG4gICAgICB9KTtcblxuICAgICAgLy8gRHJhdyBsYWJlbHM6XG4gICAgICBub2Rlc1RvUmVuZGVyLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlcihub2RlKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBEcmF3IFdlYkdMIG5vZGVzIG9uIHRvcCBvZiB0aGUgbGFiZWxzOlxuICAgICAgdmFyIG5vZGVzUGVyUHJvZ3JhbXMgPSB7fTtcblxuICAgICAgLy8gMS4gQ291bnQgbm9kZXMgcGVyIHR5cGU6XG4gICAgICBub2Rlc1RvUmVuZGVyLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIHR5cGUgPSBfdGhpczYubm9kZURhdGFDYWNoZVtub2RlXS50eXBlO1xuICAgICAgICBub2Rlc1BlclByb2dyYW1zW3R5cGVdID0gKG5vZGVzUGVyUHJvZ3JhbXNbdHlwZV0gfHwgMCkgKyAxO1xuICAgICAgfSk7XG4gICAgICAvLyAyLiBBbGxvY2F0ZSBmb3IgZWFjaCB0eXBlIGZvciB0aGUgcHJvcGVyIG51bWJlciBvZiBub2Rlc1xuICAgICAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLm5vZGVIb3ZlclByb2dyYW1zKSB7XG4gICAgICAgIHRoaXMubm9kZUhvdmVyUHJvZ3JhbXNbdHlwZV0ucmVhbGxvY2F0ZShub2Rlc1BlclByb2dyYW1zW3R5cGVdIHx8IDApO1xuICAgICAgICAvLyBBbHNvIHJlc2V0IGNvdW50LCB0byB1c2Ugd2hlbiByZW5kZXJpbmc6XG4gICAgICAgIG5vZGVzUGVyUHJvZ3JhbXNbdHlwZV0gPSAwO1xuICAgICAgfVxuICAgICAgLy8gMy4gUHJvY2VzcyBhbGwgbm9kZXMgdG8gcmVuZGVyOlxuICAgICAgbm9kZXNUb1JlbmRlci5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBkYXRhID0gX3RoaXM2Lm5vZGVEYXRhQ2FjaGVbbm9kZV07XG4gICAgICAgIF90aGlzNi5ub2RlSG92ZXJQcm9ncmFtc1tkYXRhLnR5cGVdLnByb2Nlc3MoMCwgbm9kZXNQZXJQcm9ncmFtc1tkYXRhLnR5cGVdKyssIGRhdGEpO1xuICAgICAgfSk7XG4gICAgICAvLyA0LiBDbGVhciBob3ZlcmVkIG5vZGVzIGxheWVyOlxuICAgICAgdGhpcy53ZWJHTENvbnRleHRzLmhvdmVyTm9kZXMuY2xlYXIodGhpcy53ZWJHTENvbnRleHRzLmhvdmVyTm9kZXMuQ09MT1JfQlVGRkVSX0JJVCk7XG4gICAgICAvLyA1LiBSZW5kZXI6XG4gICAgICBmb3IgKHZhciBfdHlwZTMgaW4gdGhpcy5ub2RlSG92ZXJQcm9ncmFtcykge1xuICAgICAgICB2YXIgcHJvZ3JhbSA9IHRoaXMubm9kZUhvdmVyUHJvZ3JhbXNbX3R5cGUzXTtcbiAgICAgICAgcHJvZ3JhbS5yZW5kZXIoe1xuICAgICAgICAgIG1hdHJpeDogdGhpcy5tYXRyaXgsXG4gICAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgICBwaXhlbFJhdGlvOiB0aGlzLnBpeGVsUmF0aW8sXG4gICAgICAgICAgY2FtZXJhQW5nbGU6IHRoaXMuY2FtZXJhLmFuZ2xlLFxuICAgICAgICAgIHpvb21SYXRpbzogdGhpcy5jYW1lcmEucmF0aW8sXG4gICAgICAgICAgc2l6ZVJhdGlvOiAxIC8gdGhpcy5zY2FsZVNpemUoKSxcbiAgICAgICAgICBjb3JyZWN0aW9uUmF0aW86IHRoaXMuY29ycmVjdGlvblJhdGlvLFxuICAgICAgICAgIGRvd25TaXppbmdSYXRpbzogdGhpcy5waWNraW5nRG93blNpemluZ1JhdGlvXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHNjaGVkdWxlIGEgaG92ZXIgcmVuZGVyLlxuICAgICAqXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2NoZWR1bGVIaWdobGlnaHRlZE5vZGVzUmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjaGVkdWxlSGlnaGxpZ2h0ZWROb2Rlc1JlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczcgPSB0aGlzO1xuICAgICAgaWYgKHRoaXMucmVuZGVySGlnaGxpZ2h0ZWROb2Rlc0ZyYW1lIHx8IHRoaXMucmVuZGVyRnJhbWUpIHJldHVybjtcbiAgICAgIHRoaXMucmVuZGVySGlnaGxpZ2h0ZWROb2Rlc0ZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUmVzZXR0aW5nIHN0YXRlXG4gICAgICAgIF90aGlzNy5yZW5kZXJIaWdobGlnaHRlZE5vZGVzRnJhbWUgPSBudWxsO1xuXG4gICAgICAgIC8vIFJlbmRlcmluZ1xuICAgICAgICBfdGhpczcucmVuZGVySGlnaGxpZ2h0ZWROb2RlcygpO1xuICAgICAgICBfdGhpczcucmVuZGVyRWRnZUxhYmVscygpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gcmVuZGVyLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVuZGVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczggPSB0aGlzO1xuICAgICAgdGhpcy5lbWl0KFwiYmVmb3JlUmVuZGVyXCIpO1xuICAgICAgdmFyIGV4aXRSZW5kZXIgPSBmdW5jdGlvbiBleGl0UmVuZGVyKCkge1xuICAgICAgICBfdGhpczguZW1pdChcImFmdGVyUmVuZGVyXCIpO1xuICAgICAgICByZXR1cm4gX3RoaXM4O1xuICAgICAgfTtcblxuICAgICAgLy8gSWYgYSByZW5kZXIgd2FzIHNjaGVkdWxlZCwgd2UgY2FuY2VsIGl0XG4gICAgICBpZiAodGhpcy5yZW5kZXJGcmFtZSkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLnJlbmRlckZyYW1lKTtcbiAgICAgICAgdGhpcy5yZW5kZXJGcmFtZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpcnN0IHdlIG5lZWQgdG8gcmVzaXplXG4gICAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgICAvLyBEbyB3ZSBuZWVkIHRvIHJlcHJvY2VzcyBkYXRhP1xuICAgICAgaWYgKHRoaXMubmVlZFRvUHJvY2VzcykgdGhpcy5wcm9jZXNzKCk7XG4gICAgICB0aGlzLm5lZWRUb1Byb2Nlc3MgPSBmYWxzZTtcblxuICAgICAgLy8gQ2xlYXJpbmcgdGhlIGNhbnZhc2VzXG4gICAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIHRleHR1cmVzXG4gICAgICB0aGlzLnBpY2tpbmdMYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzOC5yZXNldFdlYkdMVGV4dHVyZShsYXllcik7XG4gICAgICB9KTtcblxuICAgICAgLy8gSWYgd2UgaGF2ZSBubyBub2RlcyB3ZSBjYW4gc3RvcCByaWdodCB0aGVyZVxuICAgICAgaWYgKCF0aGlzLmdyYXBoLm9yZGVyKSByZXR1cm4gZXhpdFJlbmRlcigpO1xuXG4gICAgICAvLyBUT0RPOiBpbXByb3ZlIHRoaXMgaGV1cmlzdGljIG9yIG1vdmUgdG8gdGhlIGNhcHRvciBpdHNlbGY/XG4gICAgICAvLyBUT0RPOiBkZWFsIHdpdGggdGhlIHRvdWNoIGNhcHRvciBoZXJlIGFzIHdlbGxcbiAgICAgIHZhciBtb3VzZUNhcHRvciA9IHRoaXMubW91c2VDYXB0b3I7XG4gICAgICB2YXIgbW92aW5nID0gdGhpcy5jYW1lcmEuaXNBbmltYXRlZCgpIHx8IG1vdXNlQ2FwdG9yLmlzTW92aW5nIHx8IG1vdXNlQ2FwdG9yLmRyYWdnZWRFdmVudHMgfHwgbW91c2VDYXB0b3IuY3VycmVudFdoZWVsRGlyZWN0aW9uO1xuXG4gICAgICAvLyBUaGVuIHdlIG5lZWQgdG8gZXh0cmFjdCBhIG1hdHJpeCBmcm9tIHRoZSBjYW1lcmFcbiAgICAgIHZhciBjYW1lcmFTdGF0ZSA9IHRoaXMuY2FtZXJhLmdldFN0YXRlKCk7XG4gICAgICB2YXIgdmlld3BvcnREaW1lbnNpb25zID0gdGhpcy5nZXREaW1lbnNpb25zKCk7XG4gICAgICB2YXIgZ3JhcGhEaW1lbnNpb25zID0gdGhpcy5nZXRHcmFwaERpbWVuc2lvbnMoKTtcbiAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5nZXRTZXR0aW5nKFwic3RhZ2VQYWRkaW5nXCIpIHx8IDA7XG4gICAgICB0aGlzLm1hdHJpeCA9IG1hdHJpeEZyb21DYW1lcmEoY2FtZXJhU3RhdGUsIHZpZXdwb3J0RGltZW5zaW9ucywgZ3JhcGhEaW1lbnNpb25zLCBwYWRkaW5nKTtcbiAgICAgIHRoaXMuaW52TWF0cml4ID0gbWF0cml4RnJvbUNhbWVyYShjYW1lcmFTdGF0ZSwgdmlld3BvcnREaW1lbnNpb25zLCBncmFwaERpbWVuc2lvbnMsIHBhZGRpbmcsIHRydWUpO1xuICAgICAgdGhpcy5jb3JyZWN0aW9uUmF0aW8gPSBnZXRNYXRyaXhJbXBhY3QodGhpcy5tYXRyaXgsIGNhbWVyYVN0YXRlLCB2aWV3cG9ydERpbWVuc2lvbnMpO1xuICAgICAgdGhpcy5ncmFwaFRvVmlld3BvcnRSYXRpbyA9IHRoaXMuZ2V0R3JhcGhUb1ZpZXdwb3J0UmF0aW8oKTtcblxuICAgICAgLy8gW2phY29teWFsXVxuICAgICAgLy8gVGhpcyBjb21tZW50IGlzIHJlbGF0ZWQgdG8gdGhlIG9uZSBhYm92ZSB0aGUgYGdldE1hdHJpeEltcGFjdGAgZGVmaW5pdGlvbjpcbiAgICAgIC8vIC0gYHRoaXMuY29ycmVjdGlvblJhdGlvYCBpcyBzb21laG93IG5vdCBjb21wbGV0ZWx5IGV4cGxhaW5lZFxuICAgICAgLy8gLSBgdGhpcy5ncmFwaFRvVmlld3BvcnRSYXRpb2AgaXMgdGhlIHJhdGlvIG9mIGEgZGlzdGFuY2UgaW4gdGhlIHZpZXdwb3J0IGRpdmlkZWQgYnkgdGhlIHNhbWUgZGlzdGFuY2UgaW4gdGhlXG4gICAgICAvLyAgIGdyYXBoXG4gICAgICAvLyAtIGB0aGlzLm5vcm1hbGl6YXRpb25GdW5jdGlvbi5yYXRpb2AgaXMgYmFzaWNhbGx5IGBNYXRoLm1heChncmFwaERYLCBncmFwaERZKWBcbiAgICAgIC8vIEFuZCBub3csIEkgb2JzZXJ2ZSB0aGF0IGlmIEkgbXVsdGlwbHkgdGhlc2UgdGhyZWUgcmF0aW9zLCBJIGhhdmUgc29tZXRoaW5nIGNvbnN0YW50LCB3aGljaCB2YWx1ZSByZW1haW5zIDIsIGV2ZW5cbiAgICAgIC8vIHdoZW4gSSBjaGFuZ2UgdGhlIGdyYXBoLCB0aGUgdmlld3BvcnQgb3IgdGhlIGNhbWVyYS4gSXQgbWlnaHQgYmUgdXNlZnVsIGxhdGVyIHNvIEkgcHJlZmVyIHRvIGxldCB0aGlzIGNvbW1lbnQ6XG4gICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLmdyYXBoVG9WaWV3cG9ydFJhdGlvICogdGhpcy5jb3JyZWN0aW9uUmF0aW8gKiB0aGlzLm5vcm1hbGl6YXRpb25GdW5jdGlvbi5yYXRpbyAqIDIpO1xuXG4gICAgICB2YXIgcGFyYW1zID0ge1xuICAgICAgICBtYXRyaXg6IHRoaXMubWF0cml4LFxuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgcGl4ZWxSYXRpbzogdGhpcy5waXhlbFJhdGlvLFxuICAgICAgICB6b29tUmF0aW86IHRoaXMuY2FtZXJhLnJhdGlvLFxuICAgICAgICBjYW1lcmFBbmdsZTogdGhpcy5jYW1lcmEuYW5nbGUsXG4gICAgICAgIHNpemVSYXRpbzogMSAvIHRoaXMuc2NhbGVTaXplKCksXG4gICAgICAgIGNvcnJlY3Rpb25SYXRpbzogdGhpcy5jb3JyZWN0aW9uUmF0aW8sXG4gICAgICAgIGRvd25TaXppbmdSYXRpbzogdGhpcy5waWNraW5nRG93blNpemluZ1JhdGlvXG4gICAgICB9O1xuXG4gICAgICAvLyBEcmF3aW5nIG5vZGVzXG4gICAgICBmb3IgKHZhciB0eXBlIGluIHRoaXMubm9kZVByb2dyYW1zKSB7XG4gICAgICAgIHZhciBwcm9ncmFtID0gdGhpcy5ub2RlUHJvZ3JhbXNbdHlwZV07XG4gICAgICAgIHByb2dyYW0ucmVuZGVyKHBhcmFtcyk7XG4gICAgICB9XG5cbiAgICAgIC8vIERyYXdpbmcgZWRnZXNcbiAgICAgIGlmICghdGhpcy5zZXR0aW5ncy5oaWRlRWRnZXNPbk1vdmUgfHwgIW1vdmluZykge1xuICAgICAgICBmb3IgKHZhciBfdHlwZTQgaW4gdGhpcy5lZGdlUHJvZ3JhbXMpIHtcbiAgICAgICAgICB2YXIgX3Byb2dyYW0gPSB0aGlzLmVkZ2VQcm9ncmFtc1tfdHlwZTRdO1xuICAgICAgICAgIF9wcm9ncmFtLnJlbmRlcihwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIERvIG5vdCBkaXNwbGF5IGxhYmVscyBvbiBtb3ZlIHBlciBzZXR0aW5nXG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy5oaWRlTGFiZWxzT25Nb3ZlICYmIG1vdmluZykgcmV0dXJuIGV4aXRSZW5kZXIoKTtcbiAgICAgIHRoaXMucmVuZGVyTGFiZWxzKCk7XG4gICAgICB0aGlzLnJlbmRlckVkZ2VMYWJlbHMoKTtcbiAgICAgIHRoaXMucmVuZGVySGlnaGxpZ2h0ZWROb2RlcygpO1xuICAgICAgcmV0dXJuIGV4aXRSZW5kZXIoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYSBub2RlIGluIHRoZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBub2RlJ3MgZ3JhcGhvbG9neSBJRFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkZE5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkTm9kZShrZXkpIHtcbiAgICAgIC8vIE5vZGUgZGlzcGxheSBkYXRhIHJlc29sdXRpb246XG4gICAgICAvLyAgMS4gRmlyc3Qgd2UgZ2V0IHRoZSBub2RlJ3MgYXR0cmlidXRlc1xuICAgICAgLy8gIDIuIFdlIG9wdGlvbmFsbHkgcmVkdWNlIHRoZW0gdXNpbmcgdGhlIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IHRoZSB1c2VyXG4gICAgICAvLyAgICAgTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSB0b3RhbCBvYmplY3QgYW5kIHdvbid0IGJlIG1lcmdlZFxuICAgICAgLy8gIDMuIFdlIGFwcGx5IG91ciBkZWZhdWx0cywgd2hpbGUgcnVubmluZyBzb21lIHZpdGFsIGNoZWNrc1xuICAgICAgLy8gIDQuIFdlIGFwcGx5IHRoZSBub3JtYWxpemF0aW9uIGZ1bmN0aW9uXG4gICAgICAvLyBXZSBzaGFsbG93IGNvcHkgbm9kZSBkYXRhIHRvIGF2b2lkIGRhbmdlcm91cyBiZWhhdmlvcnMgZnJvbSByZWR1Y2Vyc1xuICAgICAgdmFyIGF0dHIgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmdyYXBoLmdldE5vZGVBdHRyaWJ1dGVzKGtleSkpO1xuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Mubm9kZVJlZHVjZXIpIGF0dHIgPSB0aGlzLnNldHRpbmdzLm5vZGVSZWR1Y2VyKGtleSwgYXR0cik7XG4gICAgICB2YXIgZGF0YSA9IGFwcGx5Tm9kZURlZmF1bHRzKHRoaXMuc2V0dGluZ3MsIGtleSwgYXR0cik7XG4gICAgICB0aGlzLm5vZGVEYXRhQ2FjaGVba2V5XSA9IGRhdGE7XG5cbiAgICAgIC8vIExhYmVsOlxuICAgICAgLy8gV2UgZGVsZXRlIGFuZCBhZGQgaWYgbmVlZGVkIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBpcyBhbHNvIHVzZWQgZnJvbVxuICAgICAgLy8gdXBkYXRlXG4gICAgICB0aGlzLm5vZGVzV2l0aEZvcmNlZExhYmVsc1tcImRlbGV0ZVwiXShrZXkpO1xuICAgICAgaWYgKGRhdGEuZm9yY2VMYWJlbCAmJiAhZGF0YS5oaWRkZW4pIHRoaXMubm9kZXNXaXRoRm9yY2VkTGFiZWxzLmFkZChrZXkpO1xuXG4gICAgICAvLyBIaWdobGlnaHRlZDpcbiAgICAgIC8vIFdlIHJlbW92ZSBhbmQgcmUgYWRkIGlmIG5lZWRlZCBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gaXMgYWxzbyB1c2VkIGZyb21cbiAgICAgIC8vIHVwZGF0ZVxuICAgICAgdGhpcy5oaWdobGlnaHRlZE5vZGVzW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICBpZiAoZGF0YS5oaWdobGlnaHRlZCAmJiAhZGF0YS5oaWRkZW4pIHRoaXMuaGlnaGxpZ2h0ZWROb2Rlcy5hZGQoa2V5KTtcblxuICAgICAgLy8gekluZGV4XG4gICAgICBpZiAodGhpcy5zZXR0aW5ncy56SW5kZXgpIHtcbiAgICAgICAgaWYgKGRhdGEuekluZGV4IDwgdGhpcy5ub2RlWkV4dGVudFswXSkgdGhpcy5ub2RlWkV4dGVudFswXSA9IGRhdGEuekluZGV4O1xuICAgICAgICBpZiAoZGF0YS56SW5kZXggPiB0aGlzLm5vZGVaRXh0ZW50WzFdKSB0aGlzLm5vZGVaRXh0ZW50WzFdID0gZGF0YS56SW5kZXg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIGEgbm9kZSB0aGUgaW50ZXJuYWwgZGF0YSBzdHJ1Y3R1cmVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIGtleSBUaGUgbm9kZSdzIGdyYXBob2xvZ3kgSURcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJ1cGRhdGVOb2RlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVwZGF0ZU5vZGUoa2V5KSB7XG4gICAgICB0aGlzLmFkZE5vZGUoa2V5KTtcblxuICAgICAgLy8gUmUtYXBwbHkgbm9ybWFsaXphdGlvbiBvbiB0aGUgbm9kZVxuICAgICAgdmFyIGRhdGEgPSB0aGlzLm5vZGVEYXRhQ2FjaGVba2V5XTtcbiAgICAgIHRoaXMubm9ybWFsaXphdGlvbkZ1bmN0aW9uLmFwcGx5VG8oZGF0YSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGEgbm9kZSBmcm9tIHRoZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBub2RlJ3MgZ3JhcGhvbG9neSBJRFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInJlbW92ZU5vZGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlTm9kZShrZXkpIHtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIG5vZGUgY2FjaGVcbiAgICAgIGRlbGV0ZSB0aGlzLm5vZGVEYXRhQ2FjaGVba2V5XTtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIG5vZGUgcHJvZ3JhbSBpbmRleFxuICAgICAgZGVsZXRlIHRoaXMubm9kZVByb2dyYW1JbmRleFtrZXldO1xuICAgICAgLy8gUmVtb3ZlIGZyb20gaGlnbGlnaHRlZCBub2Rlc1xuICAgICAgdGhpcy5oaWdobGlnaHRlZE5vZGVzW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICAvLyBSZW1vdmUgZnJvbSBob3ZlcmVkXG4gICAgICBpZiAodGhpcy5ob3ZlcmVkTm9kZSA9PT0ga2V5KSB0aGlzLmhvdmVyZWROb2RlID0gbnVsbDtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIGZvcmNlZCBsYWJlbFxuICAgICAgdGhpcy5ub2Rlc1dpdGhGb3JjZWRMYWJlbHNbXCJkZWxldGVcIl0oa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gZWRnZSBpbnRvIHRoZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBlZGdlJ3MgZ3JhcGhvbG9neSBJRFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImFkZEVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gYWRkRWRnZShrZXkpIHtcbiAgICAgIC8vIEVkZ2UgZGlzcGxheSBkYXRhIHJlc29sdXRpb246XG4gICAgICAvLyAgMS4gRmlyc3Qgd2UgZ2V0IHRoZSBlZGdlJ3MgYXR0cmlidXRlc1xuICAgICAgLy8gIDIuIFdlIG9wdGlvbmFsbHkgcmVkdWNlIHRoZW0gdXNpbmcgdGhlIGZ1bmN0aW9uIHByb3ZpZGVkIGJ5IHRoZSB1c2VyXG4gICAgICAvLyAgMy4gTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gbXVzdCByZXR1cm4gYSB0b3RhbCBvYmplY3QgYW5kIHdvbid0IGJlIG1lcmdlZFxuICAgICAgLy8gIDQuIFdlIGFwcGx5IG91ciBkZWZhdWx0cywgd2hpbGUgcnVubmluZyBzb21lIHZpdGFsIGNoZWNrc1xuICAgICAgLy8gV2Ugc2hhbGxvdyBjb3B5IGVkZ2UgZGF0YSB0byBhdm9pZCBkYW5nZXJvdXMgYmVoYXZpb3JzIGZyb20gcmVkdWNlcnNcbiAgICAgIHZhciBhdHRyID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5ncmFwaC5nZXRFZGdlQXR0cmlidXRlcyhrZXkpKTtcbiAgICAgIGlmICh0aGlzLnNldHRpbmdzLmVkZ2VSZWR1Y2VyKSBhdHRyID0gdGhpcy5zZXR0aW5ncy5lZGdlUmVkdWNlcihrZXksIGF0dHIpO1xuICAgICAgdmFyIGRhdGEgPSBhcHBseUVkZ2VEZWZhdWx0cyh0aGlzLnNldHRpbmdzLCBrZXksIGF0dHIpO1xuICAgICAgdGhpcy5lZGdlRGF0YUNhY2hlW2tleV0gPSBkYXRhO1xuXG4gICAgICAvLyBGb3JjZWQgbGFiZWxcbiAgICAgIC8vIHdlIGZpbHRlciBhbmQgcmUgcHVzaCBpZiBuZWVkZWQgYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIGlzIGFsc28gdXNlZCBmcm9tXG4gICAgICAvLyB1cGRhdGVcbiAgICAgIHRoaXMuZWRnZXNXaXRoRm9yY2VkTGFiZWxzW1wiZGVsZXRlXCJdKGtleSk7XG4gICAgICBpZiAoZGF0YS5mb3JjZUxhYmVsICYmICFkYXRhLmhpZGRlbikgdGhpcy5lZGdlc1dpdGhGb3JjZWRMYWJlbHMuYWRkKGtleSk7XG5cbiAgICAgIC8vIENoZWNrIHpJbmRleFxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuekluZGV4KSB7XG4gICAgICAgIGlmIChkYXRhLnpJbmRleCA8IHRoaXMuZWRnZVpFeHRlbnRbMF0pIHRoaXMuZWRnZVpFeHRlbnRbMF0gPSBkYXRhLnpJbmRleDtcbiAgICAgICAgaWYgKGRhdGEuekluZGV4ID4gdGhpcy5lZGdlWkV4dGVudFsxXSkgdGhpcy5lZGdlWkV4dGVudFsxXSA9IGRhdGEuekluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBhbiBlZGdlIGluIHRoZSBpbnRlcm5hbCBkYXRhIHN0cnVjdHVyZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ga2V5IFRoZSBlZGdlJ3MgZ3JhcGhvbG9neSBJRFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInVwZGF0ZUVkZ2VcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlRWRnZShrZXkpIHtcbiAgICAgIHRoaXMuYWRkRWRnZShrZXkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbiBlZGdlIGZyb20gdGhlIGludGVybmFsIGRhdGEgc3RydWN0dXJlcy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGVkZ2UncyBncmFwaG9sb2d5IElEXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVtb3ZlRWRnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVFZGdlKGtleSkge1xuICAgICAgLy8gUmVtb3ZlIGZyb20gZWRnZSBjYWNoZVxuICAgICAgZGVsZXRlIHRoaXMuZWRnZURhdGFDYWNoZVtrZXldO1xuICAgICAgLy8gUmVtb3ZlIGZyb20gcHJvZ3JhbUlkIGluZGV4XG4gICAgICBkZWxldGUgdGhpcy5lZGdlUHJvZ3JhbUluZGV4W2tleV07XG4gICAgICAvLyBSZW1vdmUgZnJvbSBob3ZlcmVkXG4gICAgICBpZiAodGhpcy5ob3ZlcmVkRWRnZSA9PT0ga2V5KSB0aGlzLmhvdmVyZWRFZGdlID0gbnVsbDtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIGZvcmNlZCBsYWJlbFxuICAgICAgdGhpcy5lZGdlc1dpdGhGb3JjZWRMYWJlbHNbXCJkZWxldGVcIl0oa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgaW5kaWNlcyByZWxhdGVkIHRvIG5vZGVzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJOb2RlSW5kaWNlc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhck5vZGVJbmRpY2VzKCkge1xuICAgICAgLy8gTGFiZWxHcmlkICYgbm9kZUV4dGVudCBhcmUgb25seSBtYW5hZ2UvcG9wdWxhdGVkIGluIHRoZSBwcm9jZXNzIGZ1bmN0aW9uXG4gICAgICB0aGlzLmxhYmVsR3JpZCA9IG5ldyBMYWJlbEdyaWQoKTtcbiAgICAgIHRoaXMubm9kZUV4dGVudCA9IHtcbiAgICAgICAgeDogWzAsIDFdLFxuICAgICAgICB5OiBbMCwgMV1cbiAgICAgIH07XG4gICAgICB0aGlzLm5vZGVEYXRhQ2FjaGUgPSB7fTtcbiAgICAgIHRoaXMuZWRnZVByb2dyYW1JbmRleCA9IHt9O1xuICAgICAgdGhpcy5ub2Rlc1dpdGhGb3JjZWRMYWJlbHMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLm5vZGVaRXh0ZW50ID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBpbmRpY2VzIHJlbGF0ZWQgdG8gZWRnZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbGVhckVkZ2VJbmRpY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyRWRnZUluZGljZXMoKSB7XG4gICAgICB0aGlzLmVkZ2VEYXRhQ2FjaGUgPSB7fTtcbiAgICAgIHRoaXMuZWRnZVByb2dyYW1JbmRleCA9IHt9O1xuICAgICAgdGhpcy5lZGdlc1dpdGhGb3JjZWRMYWJlbHMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmVkZ2VaRXh0ZW50ID0gW0luZmluaXR5LCAtSW5maW5pdHldO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBpbmRpY2VzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJJbmRpY2VzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFySW5kaWNlcygpIHtcbiAgICAgIHRoaXMuY2xlYXJFZGdlSW5kaWNlcygpO1xuICAgICAgdGhpcy5jbGVhck5vZGVJbmRpY2VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYXIgYWxsIGdyYXBoIHN0YXRlIHJlbGF0ZWQgdG8gbm9kZXMuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbGVhck5vZGVTdGF0ZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjbGVhck5vZGVTdGF0ZSgpIHtcbiAgICAgIHRoaXMuZGlzcGxheWVkTm9kZUxhYmVscyA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuaGlnaGxpZ2h0ZWROb2RlcyA9IG5ldyBTZXQoKTtcbiAgICAgIHRoaXMuaG92ZXJlZE5vZGUgPSBudWxsO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENsZWFyIGFsbCBncmFwaCBzdGF0ZSByZWxhdGVkIHRvIGVkZ2VzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJFZGdlU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJFZGdlU3RhdGUoKSB7XG4gICAgICB0aGlzLmRpc3BsYXllZEVkZ2VMYWJlbHMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmhpZ2hsaWdodGVkTm9kZXMgPSBuZXcgU2V0KCk7XG4gICAgICB0aGlzLmhvdmVyZWRFZGdlID0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgZ3JhcGggc3RhdGUuXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJjbGVhclN0YXRlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyU3RhdGUoKSB7XG4gICAgICB0aGlzLmNsZWFyRWRnZVN0YXRlKCk7XG4gICAgICB0aGlzLmNsZWFyTm9kZVN0YXRlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBub2RlIGRhdGEgdG8gaXRzIHByb2dyYW0uXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0gbm9kZSBUaGUgbm9kZSdzIGdyYXBob2xvZ3kgSURcbiAgICAgKiBAcGFyYW0gZmluZ2VycHJpbnQgQSBmaW5nZXJwcmludCB1c2VkIHRvIGlkZW50aXR5IHRoZSBub2RlIHdpdGggcGlja2luZ1xuICAgICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgaW5kZXggd2hlcmUgdG8gcGxhY2UgdGhlIG5vZGUgaW4gdGhlIHByb2dyYW1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJhZGROb2RlVG9Qcm9ncmFtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGFkZE5vZGVUb1Byb2dyYW0obm9kZSwgZmluZ2VycHJpbnQsIHBvc2l0aW9uKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMubm9kZURhdGFDYWNoZVtub2RlXTtcbiAgICAgIHZhciBub2RlUHJvZ3JhbSA9IHRoaXMubm9kZVByb2dyYW1zW2RhdGEudHlwZV07XG4gICAgICBpZiAoIW5vZGVQcm9ncmFtKSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogY291bGQgbm90IGZpbmQgYSBzdWl0YWJsZSBwcm9ncmFtIGZvciBub2RlIHR5cGUgXFxcIlwiLmNvbmNhdChkYXRhLnR5cGUsIFwiXFxcIiFcIikpO1xuICAgICAgbm9kZVByb2dyYW0ucHJvY2VzcyhmaW5nZXJwcmludCwgcG9zaXRpb24sIGRhdGEpO1xuICAgICAgLy8gU2F2aW5nIHByb2dyYW0gaW5kZXhcbiAgICAgIHRoaXMubm9kZVByb2dyYW1JbmRleFtub2RlXSA9IHBvc2l0aW9uO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgZWRnZSBkYXRhIHRvIGl0cyBwcm9ncmFtLlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIGVkZ2UgVGhlIGVkZ2UncyBncmFwaG9sb2d5IElEXG4gICAgICogQHBhcmFtIGZpbmdlcnByaW50IEEgZmluZ2VycHJpbnQgdXNlZCB0byBpZGVudGl0eSB0aGUgZWRnZSB3aXRoIHBpY2tpbmdcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIGluZGV4IHdoZXJlIHRvIHBsYWNlIHRoZSBlZGdlIGluIHRoZSBwcm9ncmFtXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiYWRkRWRnZVRvUHJvZ3JhbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFZGdlVG9Qcm9ncmFtKGVkZ2UsIGZpbmdlcnByaW50LCBwb3NpdGlvbikge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLmVkZ2VEYXRhQ2FjaGVbZWRnZV07XG4gICAgICB2YXIgZWRnZVByb2dyYW0gPSB0aGlzLmVkZ2VQcm9ncmFtc1tkYXRhLnR5cGVdO1xuICAgICAgaWYgKCFlZGdlUHJvZ3JhbSkgdGhyb3cgbmV3IEVycm9yKFwiU2lnbWE6IGNvdWxkIG5vdCBmaW5kIGEgc3VpdGFibGUgcHJvZ3JhbSBmb3IgZWRnZSB0eXBlIFxcXCJcIi5jb25jYXQoZGF0YS50eXBlLCBcIlxcXCIhXCIpKTtcbiAgICAgIHZhciBleHRyZW1pdGllcyA9IHRoaXMuZ3JhcGguZXh0cmVtaXRpZXMoZWRnZSksXG4gICAgICAgIHNvdXJjZURhdGEgPSB0aGlzLm5vZGVEYXRhQ2FjaGVbZXh0cmVtaXRpZXNbMF1dLFxuICAgICAgICB0YXJnZXREYXRhID0gdGhpcy5ub2RlRGF0YUNhY2hlW2V4dHJlbWl0aWVzWzFdXTtcbiAgICAgIGVkZ2VQcm9ncmFtLnByb2Nlc3MoZmluZ2VycHJpbnQsIHBvc2l0aW9uLCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhLCBkYXRhKTtcbiAgICAgIC8vIFNhdmluZyBwcm9ncmFtIGluZGV4XG4gICAgICB0aGlzLmVkZ2VQcm9ncmFtSW5kZXhbZWRnZV0gPSBwb3NpdGlvbjtcbiAgICB9XG5cbiAgICAvKiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgKiBQdWJsaWMgQVBJLlxuICAgICAqKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAqL1xuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgcmVuZGVyZXIncyBjYW1lcmEuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtDYW1lcmF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FtZXJhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENhbWVyYSgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNhbWVyYTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2Qgc2V0dGluZyB0aGUgcmVuZGVyZXIncyBjYW1lcmEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtDYW1lcmF9IGNhbWVyYSAtIE5ldyBjYW1lcmEuXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q2FtZXJhXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldENhbWVyYShjYW1lcmEpIHtcbiAgICAgIHRoaXMudW5iaW5kQ2FtZXJhSGFuZGxlcnMoKTtcbiAgICAgIHRoaXMuY2FtZXJhID0gY2FtZXJhO1xuICAgICAgdGhpcy5iaW5kQ2FtZXJhSGFuZGxlcnMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtIVE1MRWxlbWVudH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRDb250YWluZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q29udGFpbmVyKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIHJlbmRlcmVyJ3MgZ3JhcGguXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtHcmFwaH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRHcmFwaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHcmFwaCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdyYXBoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHNldCB0aGUgcmVuZGVyZXIncyBncmFwaC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0dyYXBofVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNldEdyYXBoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldEdyYXBoKGdyYXBoKSB7XG4gICAgICBpZiAoZ3JhcGggPT09IHRoaXMuZ3JhcGgpIHJldHVybjtcblxuICAgICAgLy8gVW5iaW5kaW5nIGhhbmRsZXJzIG9uIHRoZSBjdXJyZW50IGdyYXBoXG4gICAgICB0aGlzLnVuYmluZEdyYXBoSGFuZGxlcnMoKTtcbiAgICAgIGlmICh0aGlzLmNoZWNrRWRnZXNFdmVudHNGcmFtZSAhPT0gbnVsbCkge1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZSh0aGlzLmNoZWNrRWRnZXNFdmVudHNGcmFtZSk7XG4gICAgICAgIHRoaXMuY2hlY2tFZGdlc0V2ZW50c0ZyYW1lID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgLy8gSW5zdGFsbGluZyBuZXcgZ3JhcGhcbiAgICAgIHRoaXMuZ3JhcGggPSBncmFwaDtcblxuICAgICAgLy8gQmluZGluZyBuZXcgaGFuZGxlcnNcbiAgICAgIHRoaXMuYmluZEdyYXBoSGFuZGxlcnMoKTtcblxuICAgICAgLy8gUmUtcmVuZGVyaW5nIG5vdyB0byBhdm9pZCBkaXNjcmVwYW5jaWVzIGZyb20gbm93IHRvIG5leHQgZnJhbWVcbiAgICAgIHRoaXMucmVmcmVzaCgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIG1vdXNlIGNhcHRvci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge01vdXNlQ2FwdG9yfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldE1vdXNlQ2FwdG9yXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldE1vdXNlQ2FwdG9yKCkge1xuICAgICAgcmV0dXJuIHRoaXMubW91c2VDYXB0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgdG91Y2ggY2FwdG9yLlxuICAgICAqXG4gICAgICogQHJldHVybiB7VG91Y2hDYXB0b3J9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VG91Y2hDYXB0b3JcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0VG91Y2hDYXB0b3IoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b3VjaENhcHRvcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBjdXJyZW50IHJlbmRlcmVyJ3MgZGltZW5zaW9ucy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge0RpbWVuc2lvbnN9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0RGltZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREaW1lbnNpb25zKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHRoaXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGhpcy5oZWlnaHRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgY3VycmVudCBncmFwaCdzIGRpbWVuc2lvbnMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtEaW1lbnNpb25zfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEdyYXBoRGltZW5zaW9uc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHcmFwaERpbWVuc2lvbnMoKSB7XG4gICAgICB2YXIgZXh0ZW50ID0gdGhpcy5jdXN0b21CQm94IHx8IHRoaXMubm9kZUV4dGVudDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBleHRlbnQueFsxXSAtIGV4dGVudC54WzBdIHx8IDEsXG4gICAgICAgIGhlaWdodDogZXh0ZW50LnlbMV0gLSBleHRlbnQueVswXSB8fCAxXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIGdldCBhbGwgdGhlIHNpZ21hIG5vZGUgYXR0cmlidXRlcy5cbiAgICAgKiBJdCdzIHVzZWZ1bGwgZm9yIGV4YW1wbGUgdG8gZ2V0IHRoZSBwb3NpdGlvbiBvZiBhIG5vZGVcbiAgICAgKiBhbmQgdG8gZ2V0IHZhbHVlcyB0aGF0IGFyZSBzZXQgYnkgdGhlIG5vZGVSZWR1Y2VyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleSAtIFRoZSBub2RlJ3Mga2V5LlxuICAgICAqIEByZXR1cm4ge05vZGVEaXNwbGF5RGF0YSB8IHVuZGVmaW5lZH0gQSBjb3B5IG9mIHRoZSBkZXNpcmVkIG5vZGUncyBhdHRyaWJ1dGUgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldE5vZGVEaXNwbGF5RGF0YVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXROb2RlRGlzcGxheURhdGEoa2V5KSB7XG4gICAgICB2YXIgbm9kZSA9IHRoaXMubm9kZURhdGFDYWNoZVtrZXldO1xuICAgICAgcmV0dXJuIG5vZGUgPyBPYmplY3QuYXNzaWduKHt9LCBub2RlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBnZXQgYWxsIHRoZSBzaWdtYSBlZGdlIGF0dHJpYnV0ZXMuXG4gICAgICogSXQncyB1c2VmdWwgZm9yIGV4YW1wbGUgdG8gZ2V0IHZhbHVlcyB0aGF0IGFyZSBzZXQgYnkgdGhlIGVkZ2VSZWR1Y2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBrZXkgLSBUaGUgZWRnZSdzIGtleS5cbiAgICAgKiBAcmV0dXJuIHtFZGdlRGlzcGxheURhdGEgfCB1bmRlZmluZWR9IEEgY29weSBvZiB0aGUgZGVzaXJlZCBlZGdlJ3MgYXR0cmlidXRlIG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRFZGdlRGlzcGxheURhdGFcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWRnZURpc3BsYXlEYXRhKGtleSkge1xuICAgICAgdmFyIGVkZ2UgPSB0aGlzLmVkZ2VEYXRhQ2FjaGVba2V5XTtcbiAgICAgIHJldHVybiBlZGdlID8gT2JqZWN0LmFzc2lnbih7fSwgZWRnZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gZ2V0IHRoZSBzZXQgb2YgY3VycmVudGx5IGRpc3BsYXllZCBub2RlIGxhYmVscy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NldDxzdHJpbmc+fSBBIHNldCBvZiBub2RlIGtleXMgd2hvc2UgbGFiZWwgaXMgZGlzcGxheWVkLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldE5vZGVEaXNwbGF5ZWRMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Tm9kZURpc3BsYXllZExhYmVscygpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KHRoaXMuZGlzcGxheWVkTm9kZUxhYmVscyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gZ2V0IHRoZSBzZXQgb2YgY3VycmVudGx5IGRpc3BsYXllZCBlZGdlIGxhYmVscy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NldDxzdHJpbmc+fSBBIHNldCBvZiBlZGdlIGtleXMgd2hvc2UgbGFiZWwgaXMgZGlzcGxheWVkLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEVkZ2VEaXNwbGF5ZWRMYWJlbHNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0RWRnZURpc3BsYXllZExhYmVscygpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KHRoaXMuZGlzcGxheWVkRWRnZUxhYmVscyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyBhIGNvcHkgb2YgdGhlIHNldHRpbmdzIGNvbGxlY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTZXR0aW5nc30gQSBjb3B5IG9mIHRoZSBzZXR0aW5ncyBjb2xsZWN0aW9uLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFNldHRpbmdzXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFNldHRpbmdzKCkge1xuICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQyKHt9LCB0aGlzLnNldHRpbmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgcmV0dXJuaW5nIHRoZSBjdXJyZW50IHZhbHVlIGZvciBhIGdpdmVuIHNldHRpbmcga2V5LlxuICAgICAqXG4gICAgICogQHBhcmFtICB7c3RyaW5nfSBrZXkgLSBUaGUgc2V0dGluZyBrZXkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm4ge2FueX0gVGhlIHZhbHVlIGF0dGFjaGVkIHRvIHRoaXMgc2V0dGluZyBrZXkgb3IgdW5kZWZpbmVkIGlmIG5vdCBmb3VuZFxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFNldHRpbmdcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0U2V0dGluZyhrZXkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldHRpbmdzW2tleV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHNldHRpbmcgdGhlIHZhbHVlIG9mIGEgZ2l2ZW4gc2V0dGluZyBrZXkuIE5vdGUgdGhhdCB0aGlzIHdpbGwgc2NoZWR1bGVcbiAgICAgKiBhIG5ldyByZW5kZXIgbmV4dCBmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30ga2V5IC0gVGhlIHNldHRpbmcga2V5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0gIHthbnl9ICAgIHZhbHVlIC0gVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzZXRTZXR0aW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNldFNldHRpbmcoa2V5LCB2YWx1ZSkge1xuICAgICAgdGhpcy5zZXR0aW5nc1trZXldID0gdmFsdWU7XG4gICAgICB2YWxpZGF0ZVNldHRpbmdzKHRoaXMuc2V0dGluZ3MpO1xuICAgICAgdGhpcy5oYW5kbGVTZXR0aW5nc1VwZGF0ZSgpO1xuICAgICAgdGhpcy5zY2hlZHVsZVJlZnJlc2goKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1cGRhdGluZyB0aGUgdmFsdWUgb2YgYSBnaXZlbiBzZXR0aW5nIGtleSB1c2luZyB0aGUgcHJvdmlkZWQgZnVuY3Rpb24uXG4gICAgICogTm90ZSB0aGF0IHRoaXMgd2lsbCBzY2hlZHVsZSBhIG5ldyByZW5kZXIgbmV4dCBmcmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSAge3N0cmluZ30gICBrZXkgICAgIC0gVGhlIHNldHRpbmcga2V5IHRvIHNldC5cbiAgICAgKiBAcGFyYW0gIHtmdW5jdGlvbn0gdXBkYXRlciAtIFRoZSB1cGRhdGUgZnVuY3Rpb24uXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidXBkYXRlU2V0dGluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1cGRhdGVTZXR0aW5nKGtleSwgdXBkYXRlcikge1xuICAgICAgdGhpcy5zZXR0aW5nc1trZXldID0gdXBkYXRlcih0aGlzLnNldHRpbmdzW2tleV0pO1xuICAgICAgdmFsaWRhdGVTZXR0aW5ncyh0aGlzLnNldHRpbmdzKTtcbiAgICAgIHRoaXMuaGFuZGxlU2V0dGluZ3NVcGRhdGUoKTtcbiAgICAgIHRoaXMuc2NoZWR1bGVSZWZyZXNoKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byByZXNpemUgdGhlIHJlbmRlcmVyLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVzaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICAgIHZhciBwcmV2aW91c1dpZHRoID0gdGhpcy53aWR0aCxcbiAgICAgICAgcHJldmlvdXNIZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLmNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gdGhpcy5jb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgdGhpcy5waXhlbFJhdGlvID0gZ2V0UGl4ZWxSYXRpbygpO1xuICAgICAgaWYgKHRoaXMud2lkdGggPT09IDApIHtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3MuYWxsb3dJbnZhbGlkQ29udGFpbmVyKSB0aGlzLndpZHRoID0gMTtlbHNlIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBDb250YWluZXIgaGFzIG5vIHdpZHRoLiBZb3UgY2FuIHNldCB0aGUgYWxsb3dJbnZhbGlkQ29udGFpbmVyIHNldHRpbmcgdG8gdHJ1ZSB0byBzdG9wIHNlZWluZyB0aGlzIGVycm9yLlwiKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmhlaWdodCA9PT0gMCkge1xuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncy5hbGxvd0ludmFsaWRDb250YWluZXIpIHRoaXMuaGVpZ2h0ID0gMTtlbHNlIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBDb250YWluZXIgaGFzIG5vIGhlaWdodC4gWW91IGNhbiBzZXQgdGhlIGFsbG93SW52YWxpZENvbnRhaW5lciBzZXR0aW5nIHRvIHRydWUgdG8gc3RvcCBzZWVpbmcgdGhpcyBlcnJvci5cIik7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIG5vdGhpbmcgaGFzIGNoYW5nZWQsIHdlIGNhbiBzdG9wIHJpZ2h0IGhlcmVcbiAgICAgIGlmIChwcmV2aW91c1dpZHRoID09PSB0aGlzLndpZHRoICYmIHByZXZpb3VzSGVpZ2h0ID09PSB0aGlzLmhlaWdodCkgcmV0dXJuIHRoaXM7XG4gICAgICB0aGlzLmVtaXQoXCJyZXNpemVcIik7XG5cbiAgICAgIC8vIFNpemluZyBkb20gZWxlbWVudHNcbiAgICAgIGZvciAodmFyIGlkIGluIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2lkXTtcbiAgICAgICAgZWxlbWVudC5zdHlsZS53aWR0aCA9IHRoaXMud2lkdGggKyBcInB4XCI7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gdGhpcy5oZWlnaHQgKyBcInB4XCI7XG4gICAgICB9XG5cbiAgICAgIC8vIFNpemluZyBjYW52YXMgY29udGV4dHNcbiAgICAgIGZvciAodmFyIF9pZCBpbiB0aGlzLmNhbnZhc0NvbnRleHRzKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbX2lkXS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvICsgXCJweFwiKTtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tfaWRdLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCB0aGlzLmhlaWdodCAqIHRoaXMucGl4ZWxSYXRpbyArIFwicHhcIik7XG4gICAgICAgIGlmICh0aGlzLnBpeGVsUmF0aW8gIT09IDEpIHRoaXMuY2FudmFzQ29udGV4dHNbX2lkXS5zY2FsZSh0aGlzLnBpeGVsUmF0aW8sIHRoaXMucGl4ZWxSYXRpbyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNpemluZyBXZWJHTCBjb250ZXh0c1xuICAgICAgZm9yICh2YXIgX2lkMiBpbiB0aGlzLndlYkdMQ29udGV4dHMpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tfaWQyXS5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCB0aGlzLndpZHRoICogdGhpcy5waXhlbFJhdGlvICsgXCJweFwiKTtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tfaWQyXS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgdGhpcy5oZWlnaHQgKiB0aGlzLnBpeGVsUmF0aW8gKyBcInB4XCIpO1xuICAgICAgICB2YXIgZ2wgPSB0aGlzLndlYkdMQ29udGV4dHNbX2lkMl07XG4gICAgICAgIGdsLnZpZXdwb3J0KDAsIDAsIHRoaXMud2lkdGggKiB0aGlzLnBpeGVsUmF0aW8sIHRoaXMuaGVpZ2h0ICogdGhpcy5waXhlbFJhdGlvKTtcblxuICAgICAgICAvLyBDbGVhciBwaWNraW5nIHRleHR1cmUgaWYgbmVlZGVkXG4gICAgICAgIGlmICh0aGlzLnBpY2tpbmdMYXllcnMuaGFzKF9pZDIpKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRUZXh0dXJlID0gdGhpcy50ZXh0dXJlc1tfaWQyXTtcbiAgICAgICAgICBpZiAoY3VycmVudFRleHR1cmUpIGdsLmRlbGV0ZVRleHR1cmUoY3VycmVudFRleHR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBjbGVhciBhbGwgdGhlIGNhbnZhc2VzLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLndlYkdMQ29udGV4dHMubm9kZXMuYmluZEZyYW1lYnVmZmVyKFdlYkdMUmVuZGVyaW5nQ29udGV4dC5GUkFNRUJVRkZFUiwgbnVsbCk7XG4gICAgICB0aGlzLndlYkdMQ29udGV4dHMubm9kZXMuY2xlYXIoV2ViR0xSZW5kZXJpbmdDb250ZXh0LkNPTE9SX0JVRkZFUl9CSVQpO1xuICAgICAgdGhpcy53ZWJHTENvbnRleHRzLmVkZ2VzLmJpbmRGcmFtZWJ1ZmZlcihXZWJHTFJlbmRlcmluZ0NvbnRleHQuRlJBTUVCVUZGRVIsIG51bGwpO1xuICAgICAgdGhpcy53ZWJHTENvbnRleHRzLmVkZ2VzLmNsZWFyKFdlYkdMUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgIHRoaXMud2ViR0xDb250ZXh0cy5ob3Zlck5vZGVzLmNsZWFyKFdlYkdMUmVuZGVyaW5nQ29udGV4dC5DT0xPUl9CVUZGRVJfQklUKTtcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dHMubGFiZWxzLmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHRzLmhvdmVycy5jbGVhclJlY3QoMCwgMCwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0cy5lZGdlTGFiZWxzLmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byByZWZyZXNoLCBpLmUuIGZvcmNlIHRoZSByZW5kZXJlciB0byByZXByb2Nlc3MgZ3JhcGhcbiAgICAgKiBkYXRhIGFuZCByZW5kZXIsIGJ1dCBrZWVwIHRoZSBzdGF0ZS5cbiAgICAgKiAtIGlmIGEgcGFydGlhbEdyYXBoIGlzIHByb3ZpZGVkLCB3ZSBvbmx5IHJlcHJvY2VzcyB0aG9zZSBub2RlcyAmIGVkZ2VzLlxuICAgICAqIC0gaWYgc2NoZWR1bGUgaXMgVFJVRSwgd2Ugc2NoZWR1bGUgYSByZW5kZXIgaW5zdGVhZCBvZiBzeW5jIHJlbmRlclxuICAgICAqIC0gaWYgc2tpcEluZGV4YXRpb24gaXMgVFJVRSwgdGhlbiBsYWJlbEdyaWQgJiBwcm9ncmFtIGluZGV4YXRpb24gYXJlIHNraXBwZWQgKGNhbiBiZSB1c2VkIGlmIHlvdSBoYXZlbid0IG1vZGlmeSB4LCB5LCB6SW5kZXggJiBzaXplKVxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwicmVmcmVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZWZyZXNoKG9wdHMpIHtcbiAgICAgIHZhciBfdGhpczkgPSB0aGlzO1xuICAgICAgdmFyIHNraXBJbmRleGF0aW9uID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5za2lwSW5kZXhhdGlvbikgIT09IHVuZGVmaW5lZCA/IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5za2lwSW5kZXhhdGlvbiA6IGZhbHNlO1xuICAgICAgdmFyIHNjaGVkdWxlID0gKG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5zY2hlZHVsZSkgIT09IHVuZGVmaW5lZCA/IG9wdHMuc2NoZWR1bGUgOiBmYWxzZTtcbiAgICAgIHZhciBmdWxsUmVmcmVzaCA9ICFvcHRzIHx8ICFvcHRzLnBhcnRpYWxHcmFwaDtcbiAgICAgIGlmIChmdWxsUmVmcmVzaCkge1xuICAgICAgICAvLyBSZS1pbmRleCBncmFwaCBkYXRhXG4gICAgICAgIHRoaXMuY2xlYXJFZGdlSW5kaWNlcygpO1xuICAgICAgICB0aGlzLmNsZWFyTm9kZUluZGljZXMoKTtcbiAgICAgICAgdGhpcy5ncmFwaC5mb3JFYWNoTm9kZShmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgIHJldHVybiBfdGhpczkuYWRkTm9kZShub2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZ3JhcGguZm9yRWFjaEVkZ2UoZnVuY3Rpb24gKGVkZ2UpIHtcbiAgICAgICAgICByZXR1cm4gX3RoaXM5LmFkZEVkZ2UoZWRnZSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIF9vcHRzJHBhcnRpYWxHcmFwaCwgX29wdHMkcGFydGlhbEdyYXBoMjtcbiAgICAgICAgdmFyIG5vZGVzID0gKChfb3B0cyRwYXJ0aWFsR3JhcGggPSBvcHRzLnBhcnRpYWxHcmFwaCkgPT09IG51bGwgfHwgX29wdHMkcGFydGlhbEdyYXBoID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0cyRwYXJ0aWFsR3JhcGgubm9kZXMpIHx8IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IChub2RlcyA9PT0gbnVsbCB8fCBub2RlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbm9kZXMubGVuZ3RoKSB8fCAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAvLyBSZWNvbXB1dGUgbm9kZSdzIGRhdGEgKGllLiBhcHBseSByZWR1Y2VyKVxuICAgICAgICAgIHRoaXMudXBkYXRlTm9kZShub2RlKTtcbiAgICAgICAgICAvLyBBZGQgbm9kZSB0byB0aGUgcHJvZ3JhbSBpZiBsYXlvdXQgaXMgdW5jaGFuZ2VkLlxuICAgICAgICAgIC8vIG90aGVyd2lzZSBpdCB3aWxsIGJlIGRvbmUgaW4gdGhlIHByb2Nlc3MgZnVuY3Rpb25cbiAgICAgICAgICBpZiAoc2tpcEluZGV4YXRpb24pIHtcbiAgICAgICAgICAgIHZhciBwcm9ncmFtSW5kZXggPSB0aGlzLm5vZGVQcm9ncmFtSW5kZXhbbm9kZV07XG4gICAgICAgICAgICBpZiAocHJvZ3JhbUluZGV4ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcihcIlNpZ21hOiBub2RlIFxcXCJcIi5jb25jYXQobm9kZSwgXCJcXFwiIGNhbid0IGJlIHJlcGFpbnRcIikpO1xuICAgICAgICAgICAgdGhpcy5hZGROb2RlVG9Qcm9ncmFtKG5vZGUsIHRoaXMubm9kZUluZGljZXNbbm9kZV0sIHByb2dyYW1JbmRleCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBlZGdlcyA9IChvcHRzID09PSBudWxsIHx8IG9wdHMgPT09IHZvaWQgMCB8fCAoX29wdHMkcGFydGlhbEdyYXBoMiA9IG9wdHMucGFydGlhbEdyYXBoKSA9PT0gbnVsbCB8fCBfb3B0cyRwYXJ0aWFsR3JhcGgyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0cyRwYXJ0aWFsR3JhcGgyLmVkZ2VzKSB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgX2k0ID0gMCwgX2w0ID0gZWRnZXMubGVuZ3RoOyBfaTQgPCBfbDQ7IF9pNCsrKSB7XG4gICAgICAgICAgdmFyIGVkZ2UgPSBlZGdlc1tfaTRdO1xuICAgICAgICAgIC8vIFJlY29tcHV0ZSBlZGdlJ3MgZGF0YSAoaWUuIGFwcGx5IHJlZHVjZXIpXG4gICAgICAgICAgdGhpcy51cGRhdGVFZGdlKGVkZ2UpO1xuICAgICAgICAgIC8vIEFkZCBlZGdlIHRvIHRoZSBwcm9ncmFtXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIGl0IHdpbGwgYmUgZG9uZSBpbiB0aGUgcHJvY2VzcyBmdW5jdGlvblxuICAgICAgICAgIGlmIChza2lwSW5kZXhhdGlvbikge1xuICAgICAgICAgICAgdmFyIF9wcm9ncmFtSW5kZXggPSB0aGlzLmVkZ2VQcm9ncmFtSW5kZXhbZWRnZV07XG4gICAgICAgICAgICBpZiAoX3Byb2dyYW1JbmRleCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJTaWdtYTogZWRnZSBcXFwiXCIuY29uY2F0KGVkZ2UsIFwiXFxcIiBjYW4ndCBiZSByZXBhaW50XCIpKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRWRnZVRvUHJvZ3JhbShlZGdlLCB0aGlzLmVkZ2VJbmRpY2VzW2VkZ2VdLCBfcHJvZ3JhbUluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gRG8gd2UgbmVlZCB0byBjYWxsIHRoZSBwcm9jZXNzIGZ1bmN0aW9uID9cbiAgICAgIGlmIChmdWxsUmVmcmVzaCB8fCAhc2tpcEluZGV4YXRpb24pIHRoaXMubmVlZFRvUHJvY2VzcyA9IHRydWU7XG4gICAgICBpZiAoc2NoZWR1bGUpIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtlbHNlIHRoaXMucmVuZGVyKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBzY2hlZHVsZSBhIHJlbmRlciBhdCB0aGUgbmV4dCBhdmFpbGFibGUgZnJhbWUuXG4gICAgICogVGhpcyBtZXRob2QgY2FuIGJlIHNhZmVseSBjYWxsZWQgb24gYSBzYW1lIGZyYW1lIGJlY2F1c2UgaXQgYmFzaWNhbGx5XG4gICAgICogZGVib3VuY2VzIHJlZnJlc2ggdG8gdGhlIG5leHQgZnJhbWUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTaWdtYX1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJzY2hlZHVsZVJlbmRlclwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2hlZHVsZVJlbmRlcigpIHtcbiAgICAgIHZhciBfdGhpczEwID0gdGhpcztcbiAgICAgIGlmICghdGhpcy5yZW5kZXJGcmFtZSkge1xuICAgICAgICB0aGlzLnJlbmRlckZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBfdGhpczEwLnJlbmRlcigpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHNjaGVkdWxlIGEgcmVmcmVzaCAoaS5lLiBmdWxseSByZXByb2Nlc3MgZ3JhcGggZGF0YSBhbmQgcmVuZGVyKVxuICAgICAqIGF0IHRoZSBuZXh0IGF2YWlsYWJsZSBmcmFtZS5cbiAgICAgKiBUaGlzIG1ldGhvZCBjYW4gYmUgc2FmZWx5IGNhbGxlZCBvbiBhIHNhbWUgZnJhbWUgYmVjYXVzZSBpdCBiYXNpY2FsbHlcbiAgICAgKiBkZWJvdW5jZXMgcmVmcmVzaCB0byB0aGUgbmV4dCBmcmFtZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NpZ21hfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcInNjaGVkdWxlUmVmcmVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzY2hlZHVsZVJlZnJlc2gob3B0cykge1xuICAgICAgcmV0dXJuIHRoaXMucmVmcmVzaChfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgb3B0cyksIHt9LCB7XG4gICAgICAgIHNjaGVkdWxlOiB0cnVlXG4gICAgICB9KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gKHVuKXpvb20sIHdoaWxlIHByZXNlcnZpbmcgdGhlIHBvc2l0aW9uIG9mIGEgdmlld3BvcnQgcG9pbnQuXG4gICAgICogVXNlZCBmb3IgaW5zdGFuY2UgdG8gem9vbSBcIm9uIHRoZSBtb3VzZSBjdXJzb3JcIi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2aWV3cG9ydFRhcmdldFxuICAgICAqIEBwYXJhbSBuZXdSYXRpb1xuICAgICAqIEByZXR1cm4ge0NhbWVyYVN0YXRlfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldFZpZXdwb3J0Wm9vbWVkU3RhdGVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Vmlld3BvcnRab29tZWRTdGF0ZSh2aWV3cG9ydFRhcmdldCwgbmV3UmF0aW8pIHtcbiAgICAgIHZhciBfdGhpcyRjYW1lcmEkZ2V0U3RhdGUgPSB0aGlzLmNhbWVyYS5nZXRTdGF0ZSgpLFxuICAgICAgICByYXRpbyA9IF90aGlzJGNhbWVyYSRnZXRTdGF0ZS5yYXRpbyxcbiAgICAgICAgYW5nbGUgPSBfdGhpcyRjYW1lcmEkZ2V0U3RhdGUuYW5nbGUsXG4gICAgICAgIHggPSBfdGhpcyRjYW1lcmEkZ2V0U3RhdGUueCxcbiAgICAgICAgeSA9IF90aGlzJGNhbWVyYSRnZXRTdGF0ZS55O1xuXG4gICAgICAvLyBUT0RPOiBoYW5kbGUgbWF4IHpvb21cbiAgICAgIHZhciByYXRpb0RpZmYgPSBuZXdSYXRpbyAvIHJhdGlvO1xuICAgICAgdmFyIGNlbnRlciA9IHtcbiAgICAgICAgeDogdGhpcy53aWR0aCAvIDIsXG4gICAgICAgIHk6IHRoaXMuaGVpZ2h0IC8gMlxuICAgICAgfTtcbiAgICAgIHZhciBncmFwaE1vdXNlUG9zaXRpb24gPSB0aGlzLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh2aWV3cG9ydFRhcmdldCk7XG4gICAgICB2YXIgZ3JhcGhDZW50ZXJQb3NpdGlvbiA9IHRoaXMudmlld3BvcnRUb0ZyYW1lZEdyYXBoKGNlbnRlcik7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhbmdsZTogYW5nbGUsXG4gICAgICAgIHg6IChncmFwaE1vdXNlUG9zaXRpb24ueCAtIGdyYXBoQ2VudGVyUG9zaXRpb24ueCkgKiAoMSAtIHJhdGlvRGlmZikgKyB4LFxuICAgICAgICB5OiAoZ3JhcGhNb3VzZVBvc2l0aW9uLnkgLSBncmFwaENlbnRlclBvc2l0aW9uLnkpICogKDEgLSByYXRpb0RpZmYpICsgeSxcbiAgICAgICAgcmF0aW86IG5ld1JhdGlvXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGFic3RyYWN0IHJlY3RhbmdsZSBjb250YWluaW5nIHRoZSBncmFwaCBhY2NvcmRpbmdcbiAgICAgKiB0byB0aGUgY2FtZXJhJ3Mgc3RhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIHZpZXcncyByZWN0YW5nbGUuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmlld1JlY3RhbmdsZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2aWV3UmVjdGFuZ2xlKCkge1xuICAgICAgLy8gVE9ETzogcmVkdWNlIHJlbGF0aXZlIG1hcmdpbj9cbiAgICAgIHZhciBtYXJnaW5YID0gMCAqIHRoaXMud2lkdGggLyA4LFxuICAgICAgICBtYXJnaW5ZID0gMCAqIHRoaXMuaGVpZ2h0IC8gODtcbiAgICAgIHZhciBwMSA9IHRoaXMudmlld3BvcnRUb0ZyYW1lZEdyYXBoKHtcbiAgICAgICAgICB4OiAwIC0gbWFyZ2luWCxcbiAgICAgICAgICB5OiAwIC0gbWFyZ2luWVxuICAgICAgICB9KSxcbiAgICAgICAgcDIgPSB0aGlzLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh7XG4gICAgICAgICAgeDogdGhpcy53aWR0aCArIG1hcmdpblgsXG4gICAgICAgICAgeTogMCAtIG1hcmdpbllcbiAgICAgICAgfSksXG4gICAgICAgIGggPSB0aGlzLnZpZXdwb3J0VG9GcmFtZWRHcmFwaCh7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiB0aGlzLmhlaWdodCArIG1hcmdpbllcbiAgICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4MTogcDEueCxcbiAgICAgICAgeTE6IHAxLnksXG4gICAgICAgIHgyOiBwMi54LFxuICAgICAgICB5MjogcDIueSxcbiAgICAgICAgaGVpZ2h0OiBwMi55IC0gaC55XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGNvb3JkaW5hdGVzIG9mIGEgcG9pbnQgZnJvbSB0aGUgZnJhbWVkIGdyYXBoIHN5c3RlbSB0byB0aGUgdmlld3BvcnQgc3lzdGVtLiBJdCBhbGxvd3NcbiAgICAgKiBvdmVycmlkaW5nIGFueXRoaW5nIHRoYXQgaXMgdXNlZCB0byBnZXQgdGhlIHRyYW5zbGF0aW9uIG1hdHJpeCwgb3IgZXZlbiB0aGUgbWF0cml4IGl0c2VsZi5cbiAgICAgKlxuICAgICAqIEJlIGNhcmVmdWwgaWYgb3ZlcnJpZGluZyBkaW1lbnNpb25zLCBwYWRkaW5nIG9yIGNhbWVyYVN0YXRlLCBhcyB0aGUgY29tcHV0YXRpb24gb2YgdGhlIG1hdHJpeCBpcyBub3QgdGhlIGxpZ2h0ZXN0XG4gICAgICogb2YgY29tcHV0YXRpb25zLlxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImZyYW1lZEdyYXBoVG9WaWV3cG9ydFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmcmFtZWRHcmFwaFRvVmlld3BvcnQoY29vcmRpbmF0ZXMpIHtcbiAgICAgIHZhciBvdmVycmlkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICB2YXIgcmVjb21wdXRlTWF0cml4ID0gISFvdmVycmlkZS5jYW1lcmFTdGF0ZSB8fCAhIW92ZXJyaWRlLnZpZXdwb3J0RGltZW5zaW9ucyB8fCAhIW92ZXJyaWRlLmdyYXBoRGltZW5zaW9ucztcbiAgICAgIHZhciBtYXRyaXggPSBvdmVycmlkZS5tYXRyaXggPyBvdmVycmlkZS5tYXRyaXggOiByZWNvbXB1dGVNYXRyaXggPyBtYXRyaXhGcm9tQ2FtZXJhKG92ZXJyaWRlLmNhbWVyYVN0YXRlIHx8IHRoaXMuY2FtZXJhLmdldFN0YXRlKCksIG92ZXJyaWRlLnZpZXdwb3J0RGltZW5zaW9ucyB8fCB0aGlzLmdldERpbWVuc2lvbnMoKSwgb3ZlcnJpZGUuZ3JhcGhEaW1lbnNpb25zIHx8IHRoaXMuZ2V0R3JhcGhEaW1lbnNpb25zKCksIG92ZXJyaWRlLnBhZGRpbmcgfHwgdGhpcy5nZXRTZXR0aW5nKFwic3RhZ2VQYWRkaW5nXCIpIHx8IDApIDogdGhpcy5tYXRyaXg7XG4gICAgICB2YXIgdmlld3BvcnRQb3MgPSBtdWx0aXBseVZlYzIobWF0cml4LCBjb29yZGluYXRlcyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiAoMSArIHZpZXdwb3J0UG9zLngpICogdGhpcy53aWR0aCAvIDIsXG4gICAgICAgIHk6ICgxIC0gdmlld3BvcnRQb3MueSkgKiB0aGlzLmhlaWdodCAvIDJcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgY29vcmRpbmF0ZXMgb2YgYSBwb2ludCBmcm9tIHRoZSB2aWV3cG9ydCBzeXN0ZW0gdG8gdGhlIGZyYW1lZCBncmFwaCBzeXN0ZW0uIEl0IGFsbG93c1xuICAgICAqIG92ZXJyaWRpbmcgYW55dGhpbmcgdGhhdCBpcyB1c2VkIHRvIGdldCB0aGUgdHJhbnNsYXRpb24gbWF0cml4LCBvciBldmVuIHRoZSBtYXRyaXggaXRzZWxmLlxuICAgICAqXG4gICAgICogQmUgY2FyZWZ1bCBpZiBvdmVycmlkaW5nIGRpbWVuc2lvbnMsIHBhZGRpbmcgb3IgY2FtZXJhU3RhdGUsIGFzIHRoZSBjb21wdXRhdGlvbiBvZiB0aGUgbWF0cml4IGlzIG5vdCB0aGUgbGlnaHRlc3RcbiAgICAgKiBvZiBjb21wdXRhdGlvbnMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmlld3BvcnRUb0ZyYW1lZEdyYXBoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZXdwb3J0VG9GcmFtZWRHcmFwaChjb29yZGluYXRlcykge1xuICAgICAgdmFyIG92ZXJyaWRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICAgIHZhciByZWNvbXB1dGVNYXRyaXggPSAhIW92ZXJyaWRlLmNhbWVyYVN0YXRlIHx8ICEhb3ZlcnJpZGUudmlld3BvcnREaW1lbnNpb25zIHx8ICFvdmVycmlkZS5ncmFwaERpbWVuc2lvbnM7XG4gICAgICB2YXIgaW52TWF0cml4ID0gb3ZlcnJpZGUubWF0cml4ID8gb3ZlcnJpZGUubWF0cml4IDogcmVjb21wdXRlTWF0cml4ID8gbWF0cml4RnJvbUNhbWVyYShvdmVycmlkZS5jYW1lcmFTdGF0ZSB8fCB0aGlzLmNhbWVyYS5nZXRTdGF0ZSgpLCBvdmVycmlkZS52aWV3cG9ydERpbWVuc2lvbnMgfHwgdGhpcy5nZXREaW1lbnNpb25zKCksIG92ZXJyaWRlLmdyYXBoRGltZW5zaW9ucyB8fCB0aGlzLmdldEdyYXBoRGltZW5zaW9ucygpLCBvdmVycmlkZS5wYWRkaW5nIHx8IHRoaXMuZ2V0U2V0dGluZyhcInN0YWdlUGFkZGluZ1wiKSB8fCAwLCB0cnVlKSA6IHRoaXMuaW52TWF0cml4O1xuICAgICAgdmFyIHJlcyA9IG11bHRpcGx5VmVjMihpbnZNYXRyaXgsIHtcbiAgICAgICAgeDogY29vcmRpbmF0ZXMueCAvIHRoaXMud2lkdGggKiAyIC0gMSxcbiAgICAgICAgeTogMSAtIGNvb3JkaW5hdGVzLnkgLyB0aGlzLmhlaWdodCAqIDJcbiAgICAgIH0pO1xuICAgICAgaWYgKGlzTmFOKHJlcy54KSkgcmVzLnggPSAwO1xuICAgICAgaWYgKGlzTmFOKHJlcy55KSkgcmVzLnkgPSAwO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byB0cmFuc2xhdGUgYSBwb2ludCdzIGNvb3JkaW5hdGVzIGZyb20gdGhlIHZpZXdwb3J0IHN5c3RlbSAocGl4ZWwgZGlzdGFuY2UgZnJvbSB0aGUgdG9wLWxlZnQgb2YgdGhlXG4gICAgICogc3RhZ2UpIHRvIHRoZSBncmFwaCBzeXN0ZW0gKHRoZSByZWZlcmVuY2Ugc3lzdGVtIG9mIGRhdGEgYXMgdGhleSBhcmUgaW4gdGhlIGdpdmVuIGdyYXBoIGluc3RhbmNlKS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFjY2VwdHMgYW4gb3B0aW9uYWwgY2FtZXJhIHdoaWNoIGNhbiBiZSB1c2VmdWwgaWYgeW91IG5lZWQgdG8gdHJhbnNsYXRlIGNvb3JkaW5hdGVzXG4gICAgICogYmFzZWQgb24gYSBkaWZmZXJlbnQgdmlldyB0aGFuIHRoZSBvbmUgYmVpbmcgY3VycmVudGx5IGJlaW5nIGRpc3BsYXllZCBvbiBzY3JlZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGVzfSAgICAgICAgICAgICAgICAgIHZpZXdwb3J0UG9pbnRcbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGVDb252ZXJzaW9uT3ZlcnJpZGV9IG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwidmlld3BvcnRUb0dyYXBoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHZpZXdwb3J0VG9HcmFwaCh2aWV3cG9ydFBvaW50KSB7XG4gICAgICB2YXIgb3ZlcnJpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgcmV0dXJuIHRoaXMubm9ybWFsaXphdGlvbkZ1bmN0aW9uLmludmVyc2UodGhpcy52aWV3cG9ydFRvRnJhbWVkR3JhcGgodmlld3BvcnRQb2ludCwgb3ZlcnJpZGUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byB0cmFuc2xhdGUgYSBwb2ludCdzIGNvb3JkaW5hdGVzIGZyb20gdGhlIGdyYXBoIHN5c3RlbSAodGhlIHJlZmVyZW5jZSBzeXN0ZW0gb2YgZGF0YSBhcyB0aGV5IGFyZSBpblxuICAgICAqIHRoZSBnaXZlbiBncmFwaCBpbnN0YW5jZSkgdG8gdGhlIHZpZXdwb3J0IHN5c3RlbSAocGl4ZWwgZGlzdGFuY2UgZnJvbSB0aGUgdG9wLWxlZnQgb2YgdGhlIHN0YWdlKS5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFjY2VwdHMgYW4gb3B0aW9uYWwgY2FtZXJhIHdoaWNoIGNhbiBiZSB1c2VmdWwgaWYgeW91IG5lZWQgdG8gdHJhbnNsYXRlIGNvb3JkaW5hdGVzXG4gICAgICogYmFzZWQgb24gYSBkaWZmZXJlbnQgdmlldyB0aGFuIHRoZSBvbmUgYmVpbmcgY3VycmVudGx5IGJlaW5nIGRpc3BsYXllZCBvbiBzY3JlZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGVzfSAgICAgICAgICAgICAgICAgIGdyYXBoUG9pbnRcbiAgICAgKiBAcGFyYW0ge0Nvb3JkaW5hdGVDb252ZXJzaW9uT3ZlcnJpZGV9IG92ZXJyaWRlXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ3JhcGhUb1ZpZXdwb3J0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdyYXBoVG9WaWV3cG9ydChncmFwaFBvaW50KSB7XG4gICAgICB2YXIgb3ZlcnJpZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgICAgcmV0dXJuIHRoaXMuZnJhbWVkR3JhcGhUb1ZpZXdwb3J0KHRoaXMubm9ybWFsaXphdGlvbkZ1bmN0aW9uKGdyYXBoUG9pbnQpLCBvdmVycmlkZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZGlzdGFuY2UgbXVsdGlwbGllciBiZXR3ZWVuIHRoZSBncmFwaCBzeXN0ZW0gYW5kIHRoZVxuICAgICAqIHZpZXdwb3J0IHN5c3RlbS5cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJnZXRHcmFwaFRvVmlld3BvcnRSYXRpb1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRHcmFwaFRvVmlld3BvcnRSYXRpbygpIHtcbiAgICAgIHZhciBncmFwaFAxID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgICAgdmFyIGdyYXBoUDIgPSB7XG4gICAgICAgIHg6IDEsXG4gICAgICAgIHk6IDFcbiAgICAgIH07XG4gICAgICB2YXIgZ3JhcGhEID0gTWF0aC5zcXJ0KE1hdGgucG93KGdyYXBoUDEueCAtIGdyYXBoUDIueCwgMikgKyBNYXRoLnBvdyhncmFwaFAxLnkgLSBncmFwaFAyLnksIDIpKTtcbiAgICAgIHZhciB2aWV3cG9ydFAxID0gdGhpcy5ncmFwaFRvVmlld3BvcnQoZ3JhcGhQMSk7XG4gICAgICB2YXIgdmlld3BvcnRQMiA9IHRoaXMuZ3JhcGhUb1ZpZXdwb3J0KGdyYXBoUDIpO1xuICAgICAgdmFyIHZpZXdwb3J0RCA9IE1hdGguc3FydChNYXRoLnBvdyh2aWV3cG9ydFAxLnggLSB2aWV3cG9ydFAyLngsIDIpICsgTWF0aC5wb3codmlld3BvcnRQMS55IC0gdmlld3BvcnRQMi55LCAyKSk7XG4gICAgICByZXR1cm4gdmlld3BvcnREIC8gZ3JhcGhEO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCByZXR1cm5pbmcgdGhlIGdyYXBoJ3MgYm91bmRpbmcgYm94LlxuICAgICAqXG4gICAgICogQHJldHVybiB7eyB4OiBFeHRlbnQsIHk6IEV4dGVudCB9fVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEJCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QkJveCgpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vZGVFeHRlbnQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHJldHVybmluZyB0aGUgZ3JhcGgncyBjdXN0b20gYm91bmRpbmcgYm94LCBpZiBhbnkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt7IHg6IEV4dGVudCwgeTogRXh0ZW50IH0gfCBudWxsfVxuICAgICAqL1xuICB9LCB7XG4gICAga2V5OiBcImdldEN1c3RvbUJCb3hcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q3VzdG9tQkJveCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmN1c3RvbUJCb3g7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIGdyYXBoJ3MgYm91bmRpbmcgYm94IHdpdGggYSBjdXN0b20gb25lLiBHaXZlIGBudWxsYCBhcyB0aGUgYXJndW1lbnQgdG8gc3RvcCBvdmVycmlkaW5nLlxuICAgICAqXG4gICAgICogQHJldHVybiB7U2lnbWF9XG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2V0Q3VzdG9tQkJveFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRDdXN0b21CQm94KGN1c3RvbUJCb3gpIHtcbiAgICAgIHRoaXMuY3VzdG9tQkJveCA9IGN1c3RvbUJCb3g7XG4gICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdXNlZCB0byBzaHV0IHRoZSBjb250YWluZXIgJiByZWxlYXNlIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgICAgKi9cbiAgfSwge1xuICAgIGtleTogXCJraWxsXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICAvLyBFbWl0dGluZyBcImtpbGxcIiBldmVudHMgc28gdGhhdCBwbHVnaW5zIGFuZCBzdWNoIGNhbiBjbGVhbnVwXG4gICAgICB0aGlzLmVtaXQoXCJraWxsXCIpO1xuXG4gICAgICAvLyBSZWxlYXNpbmcgZXZlbnRzXG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygpO1xuXG4gICAgICAvLyBSZWxlYXNpbmcgY2FtZXJhIGhhbmRsZXJzXG4gICAgICB0aGlzLnVuYmluZENhbWVyYUhhbmRsZXJzKCk7XG5cbiAgICAgIC8vIFJlbGVhc2luZyBET00gZXZlbnRzICYgY2FwdG9yc1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5hY3RpdmVMaXN0ZW5lcnMuaGFuZGxlUmVzaXplKTtcbiAgICAgIHRoaXMubW91c2VDYXB0b3Iua2lsbCgpO1xuICAgICAgdGhpcy50b3VjaENhcHRvci5raWxsKCk7XG5cbiAgICAgIC8vIFJlbGVhc2luZyBncmFwaCBoYW5kbGVyc1xuICAgICAgdGhpcy51bmJpbmRHcmFwaEhhbmRsZXJzKCk7XG5cbiAgICAgIC8vIFJlbGVhc2luZyBjYWNoZSAmIHN0YXRlXG4gICAgICB0aGlzLmNsZWFySW5kaWNlcygpO1xuICAgICAgdGhpcy5jbGVhclN0YXRlKCk7XG4gICAgICB0aGlzLm5vZGVEYXRhQ2FjaGUgPSB7fTtcbiAgICAgIHRoaXMuZWRnZURhdGFDYWNoZSA9IHt9O1xuICAgICAgdGhpcy5oaWdobGlnaHRlZE5vZGVzLmNsZWFyKCk7XG5cbiAgICAgIC8vIENsZWFyaW5nIGZyYW1lc1xuICAgICAgaWYgKHRoaXMucmVuZGVyRnJhbWUpIHtcbiAgICAgICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5yZW5kZXJGcmFtZSk7XG4gICAgICAgIHRoaXMucmVuZGVyRnJhbWUgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucmVuZGVySGlnaGxpZ2h0ZWROb2Rlc0ZyYW1lKSB7XG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMucmVuZGVySGlnaGxpZ2h0ZWROb2Rlc0ZyYW1lKTtcbiAgICAgICAgdGhpcy5yZW5kZXJIaWdobGlnaHRlZE5vZGVzRnJhbWUgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXN0cm95aW5nIFdlYkdMIGNvbnRleHRzXG4gICAgICBmb3IgKHZhciBpZCBpbiB0aGlzLndlYkdMQ29udGV4dHMpIHtcbiAgICAgICAgdmFyIF9jb250ZXh0JGdldEV4dGVuc2lvbjtcbiAgICAgICAgdmFyIGNvbnRleHQgPSB0aGlzLndlYkdMQ29udGV4dHNbaWRdO1xuICAgICAgICAoX2NvbnRleHQkZ2V0RXh0ZW5zaW9uID0gY29udGV4dC5nZXRFeHRlbnNpb24oXCJXRUJHTF9sb3NlX2NvbnRleHRcIikpID09PSBudWxsIHx8IF9jb250ZXh0JGdldEV4dGVuc2lvbiA9PT0gdm9pZCAwIHx8IF9jb250ZXh0JGdldEV4dGVuc2lvbi5sb3NlQ29udGV4dCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBEZXN0cm95aW5nIGNhbnZhc2VzXG4gICAgICB2YXIgY29udGFpbmVyID0gdGhpcy5jb250YWluZXI7XG4gICAgICB3aGlsZSAoY29udGFpbmVyLmZpcnN0Q2hpbGQpIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIuZmlyc3RDaGlsZCk7XG5cbiAgICAgIC8vIERlc3Ryb3lpbmcgcmVtYWluaW5nIGNvbGxlY3Rpb25zXG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHRzID0ge307XG4gICAgICB0aGlzLndlYkdMQ29udGV4dHMgPSB7fTtcbiAgICAgIHRoaXMuZWxlbWVudHMgPSB7fTtcblxuICAgICAgLy8gS2lsbCBwcm9ncmFtczpcbiAgICAgIGZvciAodmFyIHR5cGUgaW4gdGhpcy5ub2RlUHJvZ3JhbXMpIHtcbiAgICAgICAgdGhpcy5ub2RlUHJvZ3JhbXNbdHlwZV0ua2lsbCgpO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgX3R5cGU1IGluIHRoaXMubm9kZUhvdmVyUHJvZ3JhbXMpIHtcbiAgICAgICAgdGhpcy5ub2RlSG92ZXJQcm9ncmFtc1tfdHlwZTVdLmtpbGwoKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIF90eXBlNiBpbiB0aGlzLmVkZ2VQcm9ncmFtcykge1xuICAgICAgICB0aGlzLmVkZ2VQcm9ncmFtc1tfdHlwZTZdLmtpbGwoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubm9kZVByb2dyYW1zID0ge307XG4gICAgICB0aGlzLm5vZGVIb3ZlclByb2dyYW1zID0ge307XG4gICAgICB0aGlzLmVkZ2VQcm9ncmFtcyA9IHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIHRvIHNjYWxlIHRoZSBnaXZlbiBzaXplIGFjY29yZGluZyB0byB0aGUgY2FtZXJhJ3MgcmF0aW8sIGkuZS5cbiAgICAgKiB6b29taW5nIHN0YXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtICB7bnVtYmVyP30gc2l6ZSAtICAgICAgICBUaGUgc2l6ZSB0byBzY2FsZSAobm9kZSBzaXplLCBlZGdlIHRoaWNrbmVzcyBldGMuKS5cbiAgICAgKiBAcGFyYW0gIHtudW1iZXI/fSBjYW1lcmFSYXRpbyAtIEEgY2FtZXJhIHJhdGlvIChkZWZhdWx0cyB0byB0aGUgYWN0dWFsIGNhbWVyYSByYXRpbykuXG4gICAgICogQHJldHVybiB7bnVtYmVyfSAgICAgICAgICAgICAgLSBUaGUgc2NhbGVkIHNpemUuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwic2NhbGVTaXplXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjYWxlU2l6ZSgpIHtcbiAgICAgIHZhciBzaXplID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAxO1xuICAgICAgdmFyIGNhbWVyYVJhdGlvID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0aGlzLmNhbWVyYS5yYXRpbztcbiAgICAgIHJldHVybiBzaXplIC8gdGhpcy5zZXR0aW5ncy56b29tVG9TaXplUmF0aW9GdW5jdGlvbihjYW1lcmFSYXRpbykgKiAodGhpcy5nZXRTZXR0aW5nKFwiaXRlbVNpemVzUmVmZXJlbmNlXCIpID09PSBcInBvc2l0aW9uc1wiID8gY2FtZXJhUmF0aW8gKiB0aGlzLmdyYXBoVG9WaWV3cG9ydFJhdGlvIDogMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRoYXQgcmV0dXJucyB0aGUgY29sbGVjdGlvbiBvZiBhbGwgdXNlZCBjYW52YXNlcy5cbiAgICAgKiBBdCB0aGUgbW9tZW50LCB0aGUgaW5zdGFudGlhdGVkIGNhbnZhc2VzIGFyZSB0aGUgZm9sbG93aW5nLCBhbmQgaW4gdGhlXG4gICAgICogZm9sbG93aW5nIG9yZGVyIGluIHRoZSBET006XG4gICAgICogLSBgZWRnZXNgXG4gICAgICogLSBgbm9kZXNgXG4gICAgICogLSBgZWRnZUxhYmVsc2BcbiAgICAgKiAtIGBsYWJlbHNgXG4gICAgICogLSBgaG92ZXJzYFxuICAgICAqIC0gYGhvdmVyTm9kZXNgXG4gICAgICogLSBgbW91c2VgXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtQbGFpbk9iamVjdDxIVE1MQ2FudmFzRWxlbWVudD59IC0gVGhlIGNvbGxlY3Rpb24gb2YgY2FudmFzZXMuXG4gICAgICovXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0Q2FudmFzZXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0Q2FudmFzZXMoKSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZDIoe30sIHRoaXMuZWxlbWVudHMpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gU2lnbWE7XG59KFR5cGVkRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBTaWdtYS5qcyBMaWJyYXJ5IEVuZHBvaW50XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogVGhlIGxpYnJhcnkgZW5kcG9pbnQuXG4gKiBAbW9kdWxlXG4gKi9cbnZhciBTaWdtYSA9IFNpZ21hJDE7XG5cbmV4cG9ydCB7IENhbWVyYSwgTW91c2VDYXB0b3IsIFNpZ21hJDEgYXMgU2lnbWEsIFRvdWNoQ2FwdG9yLCBTaWdtYSBhcyBkZWZhdWx0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sigma/dist/sigma.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sigma/rendering/dist/sigma-rendering.esm.js":
/*!******************************************************************!*\
  !*** ./node_modules/sigma/rendering/dist/sigma-rendering.esm.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbstractEdgeProgram: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.i),\n/* harmony export */   AbstractNodeProgram: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   AbstractProgram: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   EdgeArrowHeadProgram: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   EdgeArrowProgram: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.E),\n/* harmony export */   EdgeClampedProgram: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   EdgeLineProgram: () => (/* binding */ EdgeLineProgram),\n/* harmony export */   EdgeProgram: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   EdgeRectangleProgram: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   EdgeTriangleProgram: () => (/* binding */ EdgeTriangleProgram),\n/* harmony export */   NodeCircleProgram: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.N),\n/* harmony export */   NodePointProgram: () => (/* binding */ NodePointProgram),\n/* harmony export */   NodeProgram: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   Program: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.P),\n/* harmony export */   createEdgeCompoundProgram: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   createNodeCompoundProgram: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   drawDiscNodeHover: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   drawDiscNodeLabel: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   drawStraightEdgeLabel: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   loadFragmentShader: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   loadProgram: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   loadVertexShader: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   numberToGLSLFloat: () => (/* reexport safe */ _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.q)\n/* harmony export */ });\n/* harmony import */ var _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/index-29acc883.esm.js */ \"(ssr)/./node_modules/sigma/dist/index-29acc883.esm.js\");\n/* harmony import */ var _dist_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/inherits-8fbdedb5.esm.js */ \"(ssr)/./node_modules/sigma/dist/inherits-8fbdedb5.esm.js\");\n/* harmony import */ var _dist_colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../dist/colors-2f6d17f0.esm.js */ \"(ssr)/./node_modules/sigma/dist/colors-2f6d17f0.esm.js\");\n\n\n\n\n\n// language=GLSL\nvar SHADER_SOURCE$5 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\n\\nconst float radius = 0.5;\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nvoid main(void) {\\n  vec2 m = gl_PointCoord - vec2(0.5, 0.5);\\n  float dist = radius - length(m);\\n\\n  // No antialiasing for picking mode:\\n  #ifdef PICKING_MODE\\n  if (dist > v_border)\\n    gl_FragColor = v_color;\\n  else\\n    gl_FragColor = transparent;\\n\\n  #else\\n  float t = 0.0;\\n  if (dist > v_border)\\n    t = 1.0;\\n  else if (dist > 0.0)\\n    t = dist / v_border;\\n\\n  gl_FragColor = mix(transparent, v_color, t);\\n  #endif\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$2 = SHADER_SOURCE$5;\n\n// language=GLSL\nvar SHADER_SOURCE$4 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_position;\\nattribute float a_size;\\n\\nuniform float u_sizeRatio;\\nuniform float u_pixelRatio;\\nuniform mat3 u_matrix;\\n\\nvarying vec4 v_color;\\nvarying float v_border;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  gl_Position = vec4(\\n    (u_matrix * vec3(a_position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  // Multiply the point size twice:\\n  //  - x SCALING_RATIO to correct the canvas scaling\\n  //  - x 2 to correct the formulae\\n  gl_PointSize = a_size / u_sizeRatio * u_pixelRatio * 2.0;\\n\\n  v_border = (0.5 / a_size) * u_sizeRatio;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$2 = SHADER_SOURCE$4;\n\nvar _WebGLRenderingContex$2 = WebGLRenderingContext,\n  UNSIGNED_BYTE$2 = _WebGLRenderingContex$2.UNSIGNED_BYTE,\n  FLOAT$2 = _WebGLRenderingContex$2.FLOAT;\nvar UNIFORMS$2 = [\"u_sizeRatio\", \"u_pixelRatio\", \"u_matrix\"];\nvar NodePointProgram = /*#__PURE__*/function (_NodeProgram) {\n  (0,_dist_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(NodePointProgram, _NodeProgram);\n  function NodePointProgram() {\n    (0,_dist_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(this, NodePointProgram);\n    return (0,_dist_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_1__.b)(this, NodePointProgram, arguments);\n  }\n  (0,_dist_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_1__.d)(NodePointProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 1,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$2,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$2,\n        METHOD: WebGLRenderingContext.POINTS,\n        UNIFORMS: UNIFORMS$2,\n        ATTRIBUTES: [{\n          name: \"a_position\",\n          size: 2,\n          type: FLOAT$2\n        }, {\n          name: \"a_size\",\n          size: 1,\n          type: FLOAT$2\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$2,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$2,\n          normalized: true\n        }]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(nodeIndex, startIndex, data) {\n      var array = this.array;\n      array[startIndex++] = data.x;\n      array[startIndex++] = data.y;\n      array[startIndex++] = data.size;\n      array[startIndex++] = (0,_dist_colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_2__.f)(data.color);\n      array[startIndex++] = nodeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(_ref, _ref2) {\n      var sizeRatio = _ref.sizeRatio,\n        pixelRatio = _ref.pixelRatio,\n        matrix = _ref.matrix;\n      var gl = _ref2.gl,\n        uniformLocations = _ref2.uniformLocations;\n      var u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_pixelRatio = uniformLocations.u_pixelRatio,\n        u_matrix = uniformLocations.u_matrix;\n      gl.uniform1f(u_pixelRatio, pixelRatio);\n      gl.uniform1f(u_sizeRatio, sizeRatio);\n      gl.uniformMatrix3fv(u_matrix, false, matrix);\n    }\n  }]);\n  return NodePointProgram;\n}(_dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.f);\n\n// language=GLSL\nvar SHADER_SOURCE$3 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\n\\nvoid main(void) {\\n  gl_FragColor = v_color;\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE$1 = SHADER_SOURCE$3;\n\n// language=GLSL\nvar SHADER_SOURCE$2 = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_position;\\n\\nuniform mat3 u_matrix;\\n\\nvarying vec4 v_color;\\n\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  // Scale from [[-1 1] [-1 1]] to the container:\\n  gl_Position = vec4(\\n    (u_matrix * vec3(a_position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$1 = SHADER_SOURCE$2;\n\nvar _WebGLRenderingContex$1 = WebGLRenderingContext,\n  UNSIGNED_BYTE$1 = _WebGLRenderingContex$1.UNSIGNED_BYTE,\n  FLOAT$1 = _WebGLRenderingContex$1.FLOAT;\nvar UNIFORMS$1 = [\"u_matrix\"];\nvar EdgeLineProgram = /*#__PURE__*/function (_EdgeProgram) {\n  (0,_dist_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(EdgeLineProgram, _EdgeProgram);\n  function EdgeLineProgram() {\n    (0,_dist_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(this, EdgeLineProgram);\n    return (0,_dist_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_1__.b)(this, EdgeLineProgram, arguments);\n  }\n  (0,_dist_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_1__.d)(EdgeLineProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 2,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$1,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE$1,\n        METHOD: WebGLRenderingContext.LINES,\n        UNIFORMS: UNIFORMS$1,\n        ATTRIBUTES: [{\n          name: \"a_position\",\n          size: 2,\n          type: FLOAT$1\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE$1,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE$1,\n          normalized: true\n        }]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var array = this.array;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = (0,_dist_colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_2__.f)(data.color);\n\n      // First point\n      array[startIndex++] = x1;\n      array[startIndex++] = y1;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n\n      // Second point\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_matrix = uniformLocations.u_matrix;\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n    }\n  }]);\n  return EdgeLineProgram;\n}(_dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.g);\n\n// language=GLSL\nvar SHADER_SOURCE$1 = /*glsl*/\"\\nprecision mediump float;\\n\\nvarying vec4 v_color;\\n\\nvoid main(void) {\\n  gl_FragColor = v_color;\\n}\\n\";\nvar FRAGMENT_SHADER_SOURCE = SHADER_SOURCE$1;\n\n// language=GLSL\nvar SHADER_SOURCE = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_normal;\\nattribute float a_normalCoef;\\nattribute vec2 a_positionStart;\\nattribute vec2 a_positionEnd;\\nattribute float a_positionCoef;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\n\\nconst float minThickness = 1.7;\\nconst float bias = 255.0 / 254.0;\\n\\nvoid main() {\\n  vec2 normal = a_normal * a_normalCoef;\\n  vec2 position = a_positionStart * (1.0 - a_positionCoef) + a_positionEnd * a_positionCoef;\\n\\n  // The only different here with edge.vert.glsl is that we need to handle null\\n  // input normal vector. Apart from that, you can read edge.vert.glsl more info\\n  // on how it works:\\n  float normalLength = length(normal);\\n  vec2 unitNormal = normal / normalLength;\\n  if (normalLength <= 0.0) unitNormal = normal;\\n  float pixelsThickness = max(normalLength, minThickness * u_sizeRatio);\\n  float webGLThickness = pixelsThickness * u_correctionRatio / u_sizeRatio;\\n\\n  gl_Position = vec4((u_matrix * vec3(position + unitNormal * webGLThickness, 1)).xy, 0, 1);\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE = SHADER_SOURCE;\n\nvar _WebGLRenderingContex = WebGLRenderingContext,\n  UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE,\n  FLOAT = _WebGLRenderingContex.FLOAT;\nvar UNIFORMS = [\"u_matrix\", \"u_sizeRatio\", \"u_correctionRatio\"];\nvar EdgeTriangleProgram = /*#__PURE__*/function (_EdgeProgram) {\n  (0,_dist_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(EdgeTriangleProgram, _EdgeProgram);\n  function EdgeTriangleProgram() {\n    (0,_dist_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(this, EdgeTriangleProgram);\n    return (0,_dist_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_1__.b)(this, EdgeTriangleProgram, arguments);\n  }\n  (0,_dist_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_1__.d)(EdgeTriangleProgram, [{\n    key: \"getDefinition\",\n    value: function getDefinition() {\n      return {\n        VERTICES: 3,\n        VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE,\n        FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,\n        METHOD: WebGLRenderingContext.TRIANGLES,\n        UNIFORMS: UNIFORMS,\n        ATTRIBUTES: [{\n          name: \"a_positionStart\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_positionEnd\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_normal\",\n          size: 2,\n          type: FLOAT\n        }, {\n          name: \"a_color\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }, {\n          name: \"a_id\",\n          size: 4,\n          type: UNSIGNED_BYTE,\n          normalized: true\n        }],\n        CONSTANT_ATTRIBUTES: [\n        // If 0, then position will be a_positionStart\n        // If 1, then position will be a_positionEnd\n        {\n          name: \"a_positionCoef\",\n          size: 1,\n          type: FLOAT\n        }, {\n          name: \"a_normalCoef\",\n          size: 1,\n          type: FLOAT\n        }],\n        CONSTANT_DATA: [[0, 1], [0, -1], [1, 0]]\n      };\n    }\n  }, {\n    key: \"processVisibleItem\",\n    value: function processVisibleItem(edgeIndex, startIndex, sourceData, targetData, data) {\n      var thickness = data.size || 1;\n      var x1 = sourceData.x;\n      var y1 = sourceData.y;\n      var x2 = targetData.x;\n      var y2 = targetData.y;\n      var color = (0,_dist_colors_2f6d17f0_esm_js__WEBPACK_IMPORTED_MODULE_2__.f)(data.color);\n\n      // Computing normals\n      var dx = x2 - x1;\n      var dy = y2 - y1;\n      var len = dx * dx + dy * dy;\n      var n1 = 0;\n      var n2 = 0;\n      if (len) {\n        len = 1 / Math.sqrt(len);\n        n1 = -dy * len * thickness;\n        n2 = dx * len * thickness;\n      }\n      var array = this.array;\n\n      // First point\n      array[startIndex++] = x1;\n      array[startIndex++] = y1;\n      array[startIndex++] = x2;\n      array[startIndex++] = y2;\n      array[startIndex++] = n1;\n      array[startIndex++] = n2;\n      array[startIndex++] = color;\n      array[startIndex++] = edgeIndex;\n    }\n  }, {\n    key: \"setUniforms\",\n    value: function setUniforms(params, _ref) {\n      var gl = _ref.gl,\n        uniformLocations = _ref.uniformLocations;\n      var u_matrix = uniformLocations.u_matrix,\n        u_sizeRatio = uniformLocations.u_sizeRatio,\n        u_correctionRatio = uniformLocations.u_correctionRatio;\n      gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n      gl.uniform1f(u_sizeRatio, params.sizeRatio);\n      gl.uniform1f(u_correctionRatio, params.correctionRatio);\n    }\n  }]);\n  return EdgeTriangleProgram;\n}(_dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.g);\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2lnbWEvcmVuZGVyaW5nL2Rpc3Qvc2lnbWEtcmVuZGVyaW5nLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFzRjtBQUM0YjtBQUNuWjtBQUMzRDs7QUFFcEU7QUFDQSx5REFBeUQseUJBQXlCLHlCQUF5Qiw2QkFBNkIsb0RBQW9ELHFCQUFxQiw0Q0FBNEMsb0NBQW9DLHNIQUFzSCx5Q0FBeUMsNkJBQTZCLHNDQUFzQyxrREFBa0Qsa0RBQWtELGFBQWE7QUFDcG5COztBQUVBO0FBQ0EscURBQXFELHlCQUF5Qiw0QkFBNEIseUJBQXlCLDhCQUE4Qiw2QkFBNkIsd0JBQXdCLHlCQUF5Qix5QkFBeUIscUNBQXFDLGlCQUFpQixzRkFBc0YsZ01BQWdNLDhDQUE4QyxnR0FBZ0csd0VBQXdFLGtDQUFrQyxHQUFHO0FBQy8wQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxpRUFBUztBQUNYO0FBQ0EsSUFBSSxpRUFBZTtBQUNuQixXQUFXLGlFQUFVO0FBQ3JCO0FBQ0EsRUFBRSxpRUFBWTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQVU7QUFDdEM7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQyxDQUFDLDBEQUFXOztBQUViO0FBQ0EseURBQXlELHlCQUF5QixxQkFBcUIsMkJBQTJCLEdBQUc7QUFDckk7O0FBRUE7QUFDQSxxREFBcUQseUJBQXlCLDRCQUE0QiwwQkFBMEIseUJBQXlCLHFDQUFxQyxpQkFBaUIseUlBQXlJLGdHQUFnRyx3RUFBd0Usa0NBQWtDLEdBQUc7QUFDemlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGlFQUFTO0FBQ1g7QUFDQSxJQUFJLGlFQUFlO0FBQ25CLFdBQVcsaUVBQVU7QUFDckI7QUFDQSxFQUFFLGlFQUFZO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0RBQVU7O0FBRTVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQyxDQUFDLDBEQUFXOztBQUViO0FBQ0EseURBQXlELHlCQUF5QixxQkFBcUIsMkJBQTJCLEdBQUc7QUFDckk7O0FBRUE7QUFDQSxtREFBbUQseUJBQXlCLDBCQUEwQiwrQkFBK0IsaUNBQWlDLCtCQUErQixpQ0FBaUMsMEJBQTBCLDRCQUE0QixrQ0FBa0MseUJBQXlCLG1DQUFtQyxtQ0FBbUMsaUJBQWlCLDBDQUEwQyw4RkFBOEYsb09BQW9PLDRDQUE0QyxpREFBaUQsMEVBQTBFLDZFQUE2RSxnR0FBZ0csZ0dBQWdHLHdFQUF3RSxrQ0FBa0MsR0FBRztBQUMzekM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsaUVBQVM7QUFDWDtBQUNBLElBQUksaUVBQWU7QUFDbkIsV0FBVyxpRUFBVTtBQUNyQjtBQUNBLEVBQUUsaUVBQVk7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLCtEQUFVOztBQUU1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUMsQ0FBQywwREFBVzs7QUFFcUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcG9uc2FydS8uL25vZGVfbW9kdWxlcy9zaWdtYS9yZW5kZXJpbmcvZGlzdC9zaWdtYS1yZW5kZXJpbmcuZXNtLmpzP2E0ZTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZiBhcyBOb2RlUHJvZ3JhbSwgZyBhcyBFZGdlUHJvZ3JhbSB9IGZyb20gJy4uLy4uL2Rpc3QvaW5kZXgtMjlhY2M4ODMuZXNtLmpzJztcbmV4cG9ydCB7IGkgYXMgQWJzdHJhY3RFZGdlUHJvZ3JhbSwgQSBhcyBBYnN0cmFjdE5vZGVQcm9ncmFtLCBrIGFzIEFic3RyYWN0UHJvZ3JhbSwgbCBhcyBFZGdlQXJyb3dIZWFkUHJvZ3JhbSwgRSBhcyBFZGdlQXJyb3dQcm9ncmFtLCBtIGFzIEVkZ2VDbGFtcGVkUHJvZ3JhbSwgZyBhcyBFZGdlUHJvZ3JhbSwgZSBhcyBFZGdlUmVjdGFuZ2xlUHJvZ3JhbSwgTiBhcyBOb2RlQ2lyY2xlUHJvZ3JhbSwgZiBhcyBOb2RlUHJvZ3JhbSwgUCBhcyBQcm9ncmFtLCBqIGFzIGNyZWF0ZUVkZ2VDb21wb3VuZFByb2dyYW0sIGggYXMgY3JlYXRlTm9kZUNvbXBvdW5kUHJvZ3JhbSwgYyBhcyBkcmF3RGlzY05vZGVIb3ZlciwgYiBhcyBkcmF3RGlzY05vZGVMYWJlbCwgZCBhcyBkcmF3U3RyYWlnaHRFZGdlTGFiZWwsIG8gYXMgbG9hZEZyYWdtZW50U2hhZGVyLCBwIGFzIGxvYWRQcm9ncmFtLCBuIGFzIGxvYWRWZXJ0ZXhTaGFkZXIsIHEgYXMgbnVtYmVyVG9HTFNMRmxvYXQgfSBmcm9tICcuLi8uLi9kaXN0L2luZGV4LTI5YWNjODgzLmVzbS5qcyc7XG5pbXBvcnQgeyBfIGFzIF9pbmhlcml0cywgYSBhcyBfY2xhc3NDYWxsQ2hlY2ssIGIgYXMgX2NhbGxTdXBlciwgZCBhcyBfY3JlYXRlQ2xhc3MgfSBmcm9tICcuLi8uLi9kaXN0L2luaGVyaXRzLThmYmRlZGI1LmVzbS5qcyc7XG5pbXBvcnQgeyBmIGFzIGZsb2F0Q29sb3IgfSBmcm9tICcuLi8uLi9kaXN0L2NvbG9ycy0yZjZkMTdmMC5lc20uanMnO1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSQ1ID0gLypnbHNsKi9cIlxcbnByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcbnZhcnlpbmcgZmxvYXQgdl9ib3JkZXI7XFxuXFxuY29uc3QgZmxvYXQgcmFkaXVzID0gMC41O1xcbmNvbnN0IHZlYzQgdHJhbnNwYXJlbnQgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIHZlYzIgbSA9IGdsX1BvaW50Q29vcmQgLSB2ZWMyKDAuNSwgMC41KTtcXG4gIGZsb2F0IGRpc3QgPSByYWRpdXMgLSBsZW5ndGgobSk7XFxuXFxuICAvLyBObyBhbnRpYWxpYXNpbmcgZm9yIHBpY2tpbmcgbW9kZTpcXG4gICNpZmRlZiBQSUNLSU5HX01PREVcXG4gIGlmIChkaXN0ID4gdl9ib3JkZXIpXFxuICAgIGdsX0ZyYWdDb2xvciA9IHZfY29sb3I7XFxuICBlbHNlXFxuICAgIGdsX0ZyYWdDb2xvciA9IHRyYW5zcGFyZW50O1xcblxcbiAgI2Vsc2VcXG4gIGZsb2F0IHQgPSAwLjA7XFxuICBpZiAoZGlzdCA+IHZfYm9yZGVyKVxcbiAgICB0ID0gMS4wO1xcbiAgZWxzZSBpZiAoZGlzdCA+IDAuMClcXG4gICAgdCA9IGRpc3QgLyB2X2JvcmRlcjtcXG5cXG4gIGdsX0ZyYWdDb2xvciA9IG1peCh0cmFuc3BhcmVudCwgdl9jb2xvciwgdCk7XFxuICAjZW5kaWZcXG59XFxuXCI7XG52YXIgRlJBR01FTlRfU0hBREVSX1NPVVJDRSQyID0gU0hBREVSX1NPVVJDRSQ1O1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSQ0ID0gLypnbHNsKi9cIlxcbmF0dHJpYnV0ZSB2ZWM0IGFfaWQ7XFxuYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3NpemU7XFxuXFxudW5pZm9ybSBmbG9hdCB1X3NpemVSYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfcGl4ZWxSYXRpbztcXG51bmlmb3JtIG1hdDMgdV9tYXRyaXg7XFxuXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyBmbG9hdCB2X2JvcmRlcjtcXG5cXG5jb25zdCBmbG9hdCBiaWFzID0gMjU1LjAgLyAyNTQuMDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICBnbF9Qb3NpdGlvbiA9IHZlYzQoXFxuICAgICh1X21hdHJpeCAqIHZlYzMoYV9wb3NpdGlvbiwgMSkpLnh5LFxcbiAgICAwLFxcbiAgICAxXFxuICApO1xcblxcbiAgLy8gTXVsdGlwbHkgdGhlIHBvaW50IHNpemUgdHdpY2U6XFxuICAvLyAgLSB4IFNDQUxJTkdfUkFUSU8gdG8gY29ycmVjdCB0aGUgY2FudmFzIHNjYWxpbmdcXG4gIC8vICAtIHggMiB0byBjb3JyZWN0IHRoZSBmb3JtdWxhZVxcbiAgZ2xfUG9pbnRTaXplID0gYV9zaXplIC8gdV9zaXplUmF0aW8gKiB1X3BpeGVsUmF0aW8gKiAyLjA7XFxuXFxuICB2X2JvcmRlciA9ICgwLjUgLyBhX3NpemUpICogdV9zaXplUmF0aW87XFxuXFxuICAjaWZkZWYgUElDS0lOR19NT0RFXFxuICAvLyBGb3IgcGlja2luZyBtb2RlLCB3ZSB1c2UgdGhlIElEIGFzIHRoZSBjb2xvcjpcXG4gIHZfY29sb3IgPSBhX2lkO1xcbiAgI2Vsc2VcXG4gIC8vIEZvciBub3JtYWwgbW9kZSwgd2UgdXNlIHRoZSBjb2xvcjpcXG4gIHZfY29sb3IgPSBhX2NvbG9yO1xcbiAgI2VuZGlmXFxuXFxuICB2X2NvbG9yLmEgKj0gYmlhcztcXG59XFxuXCI7XG52YXIgVkVSVEVYX1NIQURFUl9TT1VSQ0UkMiA9IFNIQURFUl9TT1VSQ0UkNDtcblxudmFyIF9XZWJHTFJlbmRlcmluZ0NvbnRleCQyID0gV2ViR0xSZW5kZXJpbmdDb250ZXh0LFxuICBVTlNJR05FRF9CWVRFJDIgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMi5VTlNJR05FRF9CWVRFLFxuICBGTE9BVCQyID0gX1dlYkdMUmVuZGVyaW5nQ29udGV4JDIuRkxPQVQ7XG52YXIgVU5JRk9STVMkMiA9IFtcInVfc2l6ZVJhdGlvXCIsIFwidV9waXhlbFJhdGlvXCIsIFwidV9tYXRyaXhcIl07XG52YXIgTm9kZVBvaW50UHJvZ3JhbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX05vZGVQcm9ncmFtKSB7XG4gIF9pbmhlcml0cyhOb2RlUG9pbnRQcm9ncmFtLCBfTm9kZVByb2dyYW0pO1xuICBmdW5jdGlvbiBOb2RlUG9pbnRQcm9ncmFtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBOb2RlUG9pbnRQcm9ncmFtKTtcbiAgICByZXR1cm4gX2NhbGxTdXBlcih0aGlzLCBOb2RlUG9pbnRQcm9ncmFtLCBhcmd1bWVudHMpO1xuICB9XG4gIF9jcmVhdGVDbGFzcyhOb2RlUG9pbnRQcm9ncmFtLCBbe1xuICAgIGtleTogXCJnZXREZWZpbml0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmluaXRpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBWRVJUSUNFUzogMSxcbiAgICAgICAgVkVSVEVYX1NIQURFUl9TT1VSQ0U6IFZFUlRFWF9TSEFERVJfU09VUkNFJDIsXG4gICAgICAgIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0U6IEZSQUdNRU5UX1NIQURFUl9TT1VSQ0UkMixcbiAgICAgICAgTUVUSE9EOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuUE9JTlRTLFxuICAgICAgICBVTklGT1JNUzogVU5JRk9STVMkMixcbiAgICAgICAgQVRUUklCVVRFUzogW3tcbiAgICAgICAgICBuYW1lOiBcImFfcG9zaXRpb25cIixcbiAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgIHR5cGU6IEZMT0FUJDJcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9zaXplXCIsXG4gICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICB0eXBlOiBGTE9BVCQyXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfY29sb3JcIixcbiAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgIHR5cGU6IFVOU0lHTkVEX0JZVEUkMixcbiAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfaWRcIixcbiAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgIHR5cGU6IFVOU0lHTkVEX0JZVEUkMixcbiAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXG4gICAgICAgIH1dXG4gICAgICB9O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJwcm9jZXNzVmlzaWJsZUl0ZW1cIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gcHJvY2Vzc1Zpc2libGVJdGVtKG5vZGVJbmRleCwgc3RhcnRJbmRleCwgZGF0YSkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBkYXRhLng7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gZGF0YS55O1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGRhdGEuc2l6ZTtcbiAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBmbG9hdENvbG9yKGRhdGEuY29sb3IpO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IG5vZGVJbmRleDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2V0VW5pZm9ybXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0VW5pZm9ybXMoX3JlZiwgX3JlZjIpIHtcbiAgICAgIHZhciBzaXplUmF0aW8gPSBfcmVmLnNpemVSYXRpbyxcbiAgICAgICAgcGl4ZWxSYXRpbyA9IF9yZWYucGl4ZWxSYXRpbyxcbiAgICAgICAgbWF0cml4ID0gX3JlZi5tYXRyaXg7XG4gICAgICB2YXIgZ2wgPSBfcmVmMi5nbCxcbiAgICAgICAgdW5pZm9ybUxvY2F0aW9ucyA9IF9yZWYyLnVuaWZvcm1Mb2NhdGlvbnM7XG4gICAgICB2YXIgdV9zaXplUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfc2l6ZVJhdGlvLFxuICAgICAgICB1X3BpeGVsUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfcGl4ZWxSYXRpbyxcbiAgICAgICAgdV9tYXRyaXggPSB1bmlmb3JtTG9jYXRpb25zLnVfbWF0cml4O1xuICAgICAgZ2wudW5pZm9ybTFmKHVfcGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG4gICAgICBnbC51bmlmb3JtMWYodV9zaXplUmF0aW8sIHNpemVSYXRpbyk7XG4gICAgICBnbC51bmlmb3JtTWF0cml4M2Z2KHVfbWF0cml4LCBmYWxzZSwgbWF0cml4KTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIE5vZGVQb2ludFByb2dyYW07XG59KE5vZGVQcm9ncmFtKTtcblxuLy8gbGFuZ3VhZ2U9R0xTTFxudmFyIFNIQURFUl9TT1VSQ0UkMyA9IC8qZ2xzbCovXCJcXG5wcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXG52b2lkIG1haW4odm9pZCkge1xcbiAgZ2xfRnJhZ0NvbG9yID0gdl9jb2xvcjtcXG59XFxuXCI7XG52YXIgRlJBR01FTlRfU0hBREVSX1NPVVJDRSQxID0gU0hBREVSX1NPVVJDRSQzO1xuXG4vLyBsYW5ndWFnZT1HTFNMXG52YXIgU0hBREVSX1NPVVJDRSQyID0gLypnbHNsKi9cIlxcbmF0dHJpYnV0ZSB2ZWM0IGFfaWQ7XFxuYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcblxcbnVuaWZvcm0gbWF0MyB1X21hdHJpeDtcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG5cXG5jb25zdCBmbG9hdCBiaWFzID0gMjU1LjAgLyAyNTQuMDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICAvLyBTY2FsZSBmcm9tIFtbLTEgMV0gWy0xIDFdXSB0byB0aGUgY29udGFpbmVyOlxcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KFxcbiAgICAodV9tYXRyaXggKiB2ZWMzKGFfcG9zaXRpb24sIDEpKS54eSxcXG4gICAgMCxcXG4gICAgMVxcbiAgKTtcXG5cXG4gICNpZmRlZiBQSUNLSU5HX01PREVcXG4gIC8vIEZvciBwaWNraW5nIG1vZGUsIHdlIHVzZSB0aGUgSUQgYXMgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfaWQ7XFxuICAjZWxzZVxcbiAgLy8gRm9yIG5vcm1hbCBtb2RlLCB3ZSB1c2UgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfY29sb3I7XFxuICAjZW5kaWZcXG5cXG4gIHZfY29sb3IuYSAqPSBiaWFzO1xcbn1cXG5cIjtcbnZhciBWRVJURVhfU0hBREVSX1NPVVJDRSQxID0gU0hBREVSX1NPVVJDRSQyO1xuXG52YXIgX1dlYkdMUmVuZGVyaW5nQ29udGV4JDEgPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQsXG4gIFVOU0lHTkVEX0JZVEUkMSA9IF9XZWJHTFJlbmRlcmluZ0NvbnRleCQxLlVOU0lHTkVEX0JZVEUsXG4gIEZMT0FUJDEgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXgkMS5GTE9BVDtcbnZhciBVTklGT1JNUyQxID0gW1widV9tYXRyaXhcIl07XG52YXIgRWRnZUxpbmVQcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRWRnZVByb2dyYW0pIHtcbiAgX2luaGVyaXRzKEVkZ2VMaW5lUHJvZ3JhbSwgX0VkZ2VQcm9ncmFtKTtcbiAgZnVuY3Rpb24gRWRnZUxpbmVQcm9ncmFtKCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFZGdlTGluZVByb2dyYW0pO1xuICAgIHJldHVybiBfY2FsbFN1cGVyKHRoaXMsIEVkZ2VMaW5lUHJvZ3JhbSwgYXJndW1lbnRzKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoRWRnZUxpbmVQcm9ncmFtLCBbe1xuICAgIGtleTogXCJnZXREZWZpbml0aW9uXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldERlZmluaXRpb24oKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBWRVJUSUNFUzogMixcbiAgICAgICAgVkVSVEVYX1NIQURFUl9TT1VSQ0U6IFZFUlRFWF9TSEFERVJfU09VUkNFJDEsXG4gICAgICAgIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0U6IEZSQUdNRU5UX1NIQURFUl9TT1VSQ0UkMSxcbiAgICAgICAgTUVUSE9EOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuTElORVMsXG4gICAgICAgIFVOSUZPUk1TOiBVTklGT1JNUyQxLFxuICAgICAgICBBVFRSSUJVVEVTOiBbe1xuICAgICAgICAgIG5hbWU6IFwiYV9wb3NpdGlvblwiLFxuICAgICAgICAgIHNpemU6IDIsXG4gICAgICAgICAgdHlwZTogRkxPQVQkMVxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX2NvbG9yXCIsXG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFJDEsXG4gICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX2lkXCIsXG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFJDEsXG4gICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICB9XVxuICAgICAgfTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwicHJvY2Vzc1Zpc2libGVJdGVtXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWaXNpYmxlSXRlbShlZGdlSW5kZXgsIHN0YXJ0SW5kZXgsIHNvdXJjZURhdGEsIHRhcmdldERhdGEsIGRhdGEpIHtcbiAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG4gICAgICB2YXIgeDEgPSBzb3VyY2VEYXRhLng7XG4gICAgICB2YXIgeTEgPSBzb3VyY2VEYXRhLnk7XG4gICAgICB2YXIgeDIgPSB0YXJnZXREYXRhLng7XG4gICAgICB2YXIgeTIgPSB0YXJnZXREYXRhLnk7XG4gICAgICB2YXIgY29sb3IgPSBmbG9hdENvbG9yKGRhdGEuY29sb3IpO1xuXG4gICAgICAvLyBGaXJzdCBwb2ludFxuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHgxO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IHkxO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGNvbG9yO1xuICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGVkZ2VJbmRleDtcblxuICAgICAgLy8gU2Vjb25kIHBvaW50XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0geDI7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0geTI7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gY29sb3I7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gZWRnZUluZGV4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRVbmlmb3Jtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVbmlmb3JtcyhwYXJhbXMsIF9yZWYpIHtcbiAgICAgIHZhciBnbCA9IF9yZWYuZ2wsXG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnMgPSBfcmVmLnVuaWZvcm1Mb2NhdGlvbnM7XG4gICAgICB2YXIgdV9tYXRyaXggPSB1bmlmb3JtTG9jYXRpb25zLnVfbWF0cml4O1xuICAgICAgZ2wudW5pZm9ybU1hdHJpeDNmdih1X21hdHJpeCwgZmFsc2UsIHBhcmFtcy5tYXRyaXgpO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRWRnZUxpbmVQcm9ncmFtO1xufShFZGdlUHJvZ3JhbSk7XG5cbi8vIGxhbmd1YWdlPUdMU0xcbnZhciBTSEFERVJfU09VUkNFJDEgPSAvKmdsc2wqL1wiXFxucHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XFxuXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxuXFxudm9pZCBtYWluKHZvaWQpIHtcXG4gIGdsX0ZyYWdDb2xvciA9IHZfY29sb3I7XFxufVxcblwiO1xudmFyIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0UgPSBTSEFERVJfU09VUkNFJDE7XG5cbi8vIGxhbmd1YWdlPUdMU0xcbnZhciBTSEFERVJfU09VUkNFID0gLypnbHNsKi9cIlxcbmF0dHJpYnV0ZSB2ZWM0IGFfaWQ7XFxuYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiBhX25vcm1hbDtcXG5hdHRyaWJ1dGUgZmxvYXQgYV9ub3JtYWxDb2VmO1xcbmF0dHJpYnV0ZSB2ZWMyIGFfcG9zaXRpb25TdGFydDtcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uRW5kO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3Bvc2l0aW9uQ29lZjtcXG5cXG51bmlmb3JtIG1hdDMgdV9tYXRyaXg7XFxudW5pZm9ybSBmbG9hdCB1X3NpemVSYXRpbztcXG51bmlmb3JtIGZsb2F0IHVfY29ycmVjdGlvblJhdGlvO1xcblxcbnZhcnlpbmcgdmVjNCB2X2NvbG9yO1xcblxcbmNvbnN0IGZsb2F0IG1pblRoaWNrbmVzcyA9IDEuNztcXG5jb25zdCBmbG9hdCBiaWFzID0gMjU1LjAgLyAyNTQuMDtcXG5cXG52b2lkIG1haW4oKSB7XFxuICB2ZWMyIG5vcm1hbCA9IGFfbm9ybWFsICogYV9ub3JtYWxDb2VmO1xcbiAgdmVjMiBwb3NpdGlvbiA9IGFfcG9zaXRpb25TdGFydCAqICgxLjAgLSBhX3Bvc2l0aW9uQ29lZikgKyBhX3Bvc2l0aW9uRW5kICogYV9wb3NpdGlvbkNvZWY7XFxuXFxuICAvLyBUaGUgb25seSBkaWZmZXJlbnQgaGVyZSB3aXRoIGVkZ2UudmVydC5nbHNsIGlzIHRoYXQgd2UgbmVlZCB0byBoYW5kbGUgbnVsbFxcbiAgLy8gaW5wdXQgbm9ybWFsIHZlY3Rvci4gQXBhcnQgZnJvbSB0aGF0LCB5b3UgY2FuIHJlYWQgZWRnZS52ZXJ0Lmdsc2wgbW9yZSBpbmZvXFxuICAvLyBvbiBob3cgaXQgd29ya3M6XFxuICBmbG9hdCBub3JtYWxMZW5ndGggPSBsZW5ndGgobm9ybWFsKTtcXG4gIHZlYzIgdW5pdE5vcm1hbCA9IG5vcm1hbCAvIG5vcm1hbExlbmd0aDtcXG4gIGlmIChub3JtYWxMZW5ndGggPD0gMC4wKSB1bml0Tm9ybWFsID0gbm9ybWFsO1xcbiAgZmxvYXQgcGl4ZWxzVGhpY2tuZXNzID0gbWF4KG5vcm1hbExlbmd0aCwgbWluVGhpY2tuZXNzICogdV9zaXplUmF0aW8pO1xcbiAgZmxvYXQgd2ViR0xUaGlja25lc3MgPSBwaXhlbHNUaGlja25lc3MgKiB1X2NvcnJlY3Rpb25SYXRpbyAvIHVfc2l6ZVJhdGlvO1xcblxcbiAgZ2xfUG9zaXRpb24gPSB2ZWM0KCh1X21hdHJpeCAqIHZlYzMocG9zaXRpb24gKyB1bml0Tm9ybWFsICogd2ViR0xUaGlja25lc3MsIDEpKS54eSwgMCwgMSk7XFxuXFxuICAjaWZkZWYgUElDS0lOR19NT0RFXFxuICAvLyBGb3IgcGlja2luZyBtb2RlLCB3ZSB1c2UgdGhlIElEIGFzIHRoZSBjb2xvcjpcXG4gIHZfY29sb3IgPSBhX2lkO1xcbiAgI2Vsc2VcXG4gIC8vIEZvciBub3JtYWwgbW9kZSwgd2UgdXNlIHRoZSBjb2xvcjpcXG4gIHZfY29sb3IgPSBhX2NvbG9yO1xcbiAgI2VuZGlmXFxuXFxuICB2X2NvbG9yLmEgKj0gYmlhcztcXG59XFxuXCI7XG52YXIgVkVSVEVYX1NIQURFUl9TT1VSQ0UgPSBTSEFERVJfU09VUkNFO1xuXG52YXIgX1dlYkdMUmVuZGVyaW5nQ29udGV4ID0gV2ViR0xSZW5kZXJpbmdDb250ZXh0LFxuICBVTlNJR05FRF9CWVRFID0gX1dlYkdMUmVuZGVyaW5nQ29udGV4LlVOU0lHTkVEX0JZVEUsXG4gIEZMT0FUID0gX1dlYkdMUmVuZGVyaW5nQ29udGV4LkZMT0FUO1xudmFyIFVOSUZPUk1TID0gW1widV9tYXRyaXhcIiwgXCJ1X3NpemVSYXRpb1wiLCBcInVfY29ycmVjdGlvblJhdGlvXCJdO1xudmFyIEVkZ2VUcmlhbmdsZVByb2dyYW0gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9FZGdlUHJvZ3JhbSkge1xuICBfaW5oZXJpdHMoRWRnZVRyaWFuZ2xlUHJvZ3JhbSwgX0VkZ2VQcm9ncmFtKTtcbiAgZnVuY3Rpb24gRWRnZVRyaWFuZ2xlUHJvZ3JhbSgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgRWRnZVRyaWFuZ2xlUHJvZ3JhbSk7XG4gICAgcmV0dXJuIF9jYWxsU3VwZXIodGhpcywgRWRnZVRyaWFuZ2xlUHJvZ3JhbSwgYXJndW1lbnRzKTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoRWRnZVRyaWFuZ2xlUHJvZ3JhbSwgW3tcbiAgICBrZXk6IFwiZ2V0RGVmaW5pdGlvblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZpbml0aW9uKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgVkVSVElDRVM6IDMsXG4gICAgICAgIFZFUlRFWF9TSEFERVJfU09VUkNFOiBWRVJURVhfU0hBREVSX1NPVVJDRSxcbiAgICAgICAgRlJBR01FTlRfU0hBREVSX1NPVVJDRTogRlJBR01FTlRfU0hBREVSX1NPVVJDRSxcbiAgICAgICAgTUVUSE9EOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLFxuICAgICAgICBVTklGT1JNUzogVU5JRk9STVMsXG4gICAgICAgIEFUVFJJQlVURVM6IFt7XG4gICAgICAgICAgbmFtZTogXCJhX3Bvc2l0aW9uU3RhcnRcIixcbiAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgIHR5cGU6IEZMT0FUXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfcG9zaXRpb25FbmRcIixcbiAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgIHR5cGU6IEZMT0FUXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfbm9ybWFsXCIsXG4gICAgICAgICAgc2l6ZTogMixcbiAgICAgICAgICB0eXBlOiBGTE9BVFxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogXCJhX2NvbG9yXCIsXG4gICAgICAgICAgc2l6ZTogNCxcbiAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFLFxuICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6IFwiYV9pZFwiLFxuICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgdHlwZTogVU5TSUdORURfQllURSxcbiAgICAgICAgICBub3JtYWxpemVkOiB0cnVlXG4gICAgICAgIH1dLFxuICAgICAgICBDT05TVEFOVF9BVFRSSUJVVEVTOiBbXG4gICAgICAgIC8vIElmIDAsIHRoZW4gcG9zaXRpb24gd2lsbCBiZSBhX3Bvc2l0aW9uU3RhcnRcbiAgICAgICAgLy8gSWYgMSwgdGhlbiBwb3NpdGlvbiB3aWxsIGJlIGFfcG9zaXRpb25FbmRcbiAgICAgICAge1xuICAgICAgICAgIG5hbWU6IFwiYV9wb3NpdGlvbkNvZWZcIixcbiAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgIHR5cGU6IEZMT0FUXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiBcImFfbm9ybWFsQ29lZlwiLFxuICAgICAgICAgIHNpemU6IDEsXG4gICAgICAgICAgdHlwZTogRkxPQVRcbiAgICAgICAgfV0sXG4gICAgICAgIENPTlNUQU5UX0RBVEE6IFtbMCwgMV0sIFswLCAtMV0sIFsxLCAwXV1cbiAgICAgIH07XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcInByb2Nlc3NWaXNpYmxlSXRlbVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwcm9jZXNzVmlzaWJsZUl0ZW0oZWRnZUluZGV4LCBzdGFydEluZGV4LCBzb3VyY2VEYXRhLCB0YXJnZXREYXRhLCBkYXRhKSB7XG4gICAgICB2YXIgdGhpY2tuZXNzID0gZGF0YS5zaXplIHx8IDE7XG4gICAgICB2YXIgeDEgPSBzb3VyY2VEYXRhLng7XG4gICAgICB2YXIgeTEgPSBzb3VyY2VEYXRhLnk7XG4gICAgICB2YXIgeDIgPSB0YXJnZXREYXRhLng7XG4gICAgICB2YXIgeTIgPSB0YXJnZXREYXRhLnk7XG4gICAgICB2YXIgY29sb3IgPSBmbG9hdENvbG9yKGRhdGEuY29sb3IpO1xuXG4gICAgICAvLyBDb21wdXRpbmcgbm9ybWFsc1xuICAgICAgdmFyIGR4ID0geDIgLSB4MTtcbiAgICAgIHZhciBkeSA9IHkyIC0geTE7XG4gICAgICB2YXIgbGVuID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgICB2YXIgbjEgPSAwO1xuICAgICAgdmFyIG4yID0gMDtcbiAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgbGVuID0gMSAvIE1hdGguc3FydChsZW4pO1xuICAgICAgICBuMSA9IC1keSAqIGxlbiAqIHRoaWNrbmVzcztcbiAgICAgICAgbjIgPSBkeCAqIGxlbiAqIHRoaWNrbmVzcztcbiAgICAgIH1cbiAgICAgIHZhciBhcnJheSA9IHRoaXMuYXJyYXk7XG5cbiAgICAgIC8vIEZpcnN0IHBvaW50XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0geDE7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0geTE7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0geDI7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0geTI7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gbjE7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gbjI7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gY29sb3I7XG4gICAgICBhcnJheVtzdGFydEluZGV4KytdID0gZWRnZUluZGV4O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzZXRVbmlmb3Jtc1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVbmlmb3JtcyhwYXJhbXMsIF9yZWYpIHtcbiAgICAgIHZhciBnbCA9IF9yZWYuZ2wsXG4gICAgICAgIHVuaWZvcm1Mb2NhdGlvbnMgPSBfcmVmLnVuaWZvcm1Mb2NhdGlvbnM7XG4gICAgICB2YXIgdV9tYXRyaXggPSB1bmlmb3JtTG9jYXRpb25zLnVfbWF0cml4LFxuICAgICAgICB1X3NpemVSYXRpbyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9zaXplUmF0aW8sXG4gICAgICAgIHVfY29ycmVjdGlvblJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X2NvcnJlY3Rpb25SYXRpbztcbiAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodV9tYXRyaXgsIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcbiAgICAgIGdsLnVuaWZvcm0xZih1X3NpemVSYXRpbywgcGFyYW1zLnNpemVSYXRpbyk7XG4gICAgICBnbC51bmlmb3JtMWYodV9jb3JyZWN0aW9uUmF0aW8sIHBhcmFtcy5jb3JyZWN0aW9uUmF0aW8pO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gRWRnZVRyaWFuZ2xlUHJvZ3JhbTtcbn0oRWRnZVByb2dyYW0pO1xuXG5leHBvcnQgeyBFZGdlTGluZVByb2dyYW0sIEVkZ2VUcmlhbmdsZVByb2dyYW0sIE5vZGVQb2ludFByb2dyYW0gfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sigma/rendering/dist/sigma-rendering.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sigma/settings/dist/sigma-settings.esm.js":
/*!****************************************************************!*\
  !*** ./node_modules/sigma/settings/dist/sigma-settings.esm.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEFAULT_EDGE_PROGRAM_CLASSES: () => (/* binding */ DEFAULT_EDGE_PROGRAM_CLASSES),\n/* harmony export */   DEFAULT_NODE_PROGRAM_CLASSES: () => (/* binding */ DEFAULT_NODE_PROGRAM_CLASSES),\n/* harmony export */   DEFAULT_SETTINGS: () => (/* binding */ DEFAULT_SETTINGS),\n/* harmony export */   resolveSettings: () => (/* binding */ resolveSettings),\n/* harmony export */   validateSettings: () => (/* binding */ validateSettings)\n/* harmony export */ });\n/* harmony import */ var _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../dist/index-29acc883.esm.js */ \"(ssr)/./node_modules/sigma/dist/index-29acc883.esm.js\");\n/* harmony import */ var _dist_data_31990a76_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/data-31990a76.esm.js */ \"(ssr)/./node_modules/sigma/dist/data-31990a76.esm.js\");\n\n\n\n\n\n/**\n * Sigma.js Settings\n * =================================\n *\n * The list of settings and some handy functions.\n * @module\n */\n\n/**\n * Sigma.js settings\n * =================================\n */\n\nvar DEFAULT_SETTINGS = {\n  // Performance\n  hideEdgesOnMove: false,\n  hideLabelsOnMove: false,\n  renderLabels: true,\n  renderEdgeLabels: false,\n  enableEdgeEvents: false,\n  // Component rendering\n  defaultNodeColor: \"#999\",\n  defaultNodeType: \"circle\",\n  defaultEdgeColor: \"#ccc\",\n  defaultEdgeType: \"line\",\n  labelFont: \"Arial\",\n  labelSize: 14,\n  labelWeight: \"normal\",\n  labelColor: {\n    color: \"#000\"\n  },\n  edgeLabelFont: \"Arial\",\n  edgeLabelSize: 14,\n  edgeLabelWeight: \"normal\",\n  edgeLabelColor: {\n    attribute: \"color\"\n  },\n  stagePadding: 30,\n  zoomToSizeRatioFunction: Math.sqrt,\n  itemSizesReference: \"screen\",\n  defaultDrawEdgeLabel: _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.d,\n  defaultDrawNodeLabel: _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.b,\n  defaultDrawNodeHover: _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.c,\n  // Labels\n  labelDensity: 1,\n  labelGridCellSize: 100,\n  labelRenderedSizeThreshold: 6,\n  // Reducers\n  nodeReducer: null,\n  edgeReducer: null,\n  // Features\n  zIndex: false,\n  minCameraRatio: null,\n  maxCameraRatio: null,\n  // Lifecycle\n  allowInvalidContainer: false,\n  // Program classes\n  nodeProgramClasses: {},\n  nodeHoverProgramClasses: {},\n  edgeProgramClasses: {}\n};\nvar DEFAULT_NODE_PROGRAM_CLASSES = {\n  circle: _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.N\n};\nvar DEFAULT_EDGE_PROGRAM_CLASSES = {\n  arrow: _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.E,\n  line: _dist_index_29acc883_esm_js__WEBPACK_IMPORTED_MODULE_0__.e\n};\nfunction validateSettings(settings) {\n  if (typeof settings.labelDensity !== \"number\" || settings.labelDensity < 0) {\n    throw new Error(\"Settings: invalid `labelDensity`. Expecting a positive number.\");\n  }\n  var minCameraRatio = settings.minCameraRatio,\n    maxCameraRatio = settings.maxCameraRatio;\n  if (typeof minCameraRatio === \"number\" && typeof maxCameraRatio === \"number\" && maxCameraRatio < minCameraRatio) {\n    throw new Error(\"Settings: invalid camera ratio boundaries. Expecting `maxCameraRatio` to be greater than `minCameraRatio`.\");\n  }\n}\nfunction resolveSettings(settings) {\n  var resolvedSettings = (0,_dist_data_31990a76_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)({}, DEFAULT_SETTINGS, settings);\n  resolvedSettings.nodeProgramClasses = (0,_dist_data_31990a76_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)({}, DEFAULT_NODE_PROGRAM_CLASSES, resolvedSettings.nodeProgramClasses);\n  resolvedSettings.edgeProgramClasses = (0,_dist_data_31990a76_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)({}, DEFAULT_EDGE_PROGRAM_CLASSES, resolvedSettings.edgeProgramClasses);\n  return resolvedSettings;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2lnbWEvc2V0dGluZ3MvZGlzdC9zaWdtYS1zZXR0aW5ncy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF3TTtBQUMxSTtBQUNqQjtBQUNGOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDBEQUFxQjtBQUM3Qyx3QkFBd0IsMERBQWlCO0FBQ3pDLHdCQUF3QiwwREFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0EsVUFBVSwwREFBaUI7QUFDM0I7QUFDQTtBQUNBLFNBQVMsMERBQWdCO0FBQ3pCLFFBQVEsMERBQW9CO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qiw2REFBTSxHQUFHO0FBQ2xDLHdDQUF3Qyw2REFBTSxHQUFHO0FBQ2pELHdDQUF3Qyw2REFBTSxHQUFHO0FBQ2pEO0FBQ0E7O0FBRTJIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BvbnNhcnUvLi9ub2RlX21vZHVsZXMvc2lnbWEvc2V0dGluZ3MvZGlzdC9zaWdtYS1zZXR0aW5ncy5lc20uanM/MWM3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBkIGFzIGRyYXdTdHJhaWdodEVkZ2VMYWJlbCwgYiBhcyBkcmF3RGlzY05vZGVMYWJlbCwgYyBhcyBkcmF3RGlzY05vZGVIb3ZlciwgTiBhcyBOb2RlQ2lyY2xlUHJvZ3JhbSwgRSBhcyBFZGdlQXJyb3dQcm9ncmFtLCBlIGFzIEVkZ2VSZWN0YW5nbGVQcm9ncmFtIH0gZnJvbSAnLi4vLi4vZGlzdC9pbmRleC0yOWFjYzg4My5lc20uanMnO1xuaW1wb3J0IHsgYSBhcyBhc3NpZ24gfSBmcm9tICcuLi8uLi9kaXN0L2RhdGEtMzE5OTBhNzYuZXNtLmpzJztcbmltcG9ydCAnLi4vLi4vZGlzdC9pbmhlcml0cy04ZmJkZWRiNS5lc20uanMnO1xuaW1wb3J0ICcuLi8uLi9kaXN0L2NvbG9ycy0yZjZkMTdmMC5lc20uanMnO1xuXG4vKipcbiAqIFNpZ21hLmpzIFNldHRpbmdzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBUaGUgbGlzdCBvZiBzZXR0aW5ncyBhbmQgc29tZSBoYW5keSBmdW5jdGlvbnMuXG4gKiBAbW9kdWxlXG4gKi9cblxuLyoqXG4gKiBTaWdtYS5qcyBzZXR0aW5nc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxudmFyIERFRkFVTFRfU0VUVElOR1MgPSB7XG4gIC8vIFBlcmZvcm1hbmNlXG4gIGhpZGVFZGdlc09uTW92ZTogZmFsc2UsXG4gIGhpZGVMYWJlbHNPbk1vdmU6IGZhbHNlLFxuICByZW5kZXJMYWJlbHM6IHRydWUsXG4gIHJlbmRlckVkZ2VMYWJlbHM6IGZhbHNlLFxuICBlbmFibGVFZGdlRXZlbnRzOiBmYWxzZSxcbiAgLy8gQ29tcG9uZW50IHJlbmRlcmluZ1xuICBkZWZhdWx0Tm9kZUNvbG9yOiBcIiM5OTlcIixcbiAgZGVmYXVsdE5vZGVUeXBlOiBcImNpcmNsZVwiLFxuICBkZWZhdWx0RWRnZUNvbG9yOiBcIiNjY2NcIixcbiAgZGVmYXVsdEVkZ2VUeXBlOiBcImxpbmVcIixcbiAgbGFiZWxGb250OiBcIkFyaWFsXCIsXG4gIGxhYmVsU2l6ZTogMTQsXG4gIGxhYmVsV2VpZ2h0OiBcIm5vcm1hbFwiLFxuICBsYWJlbENvbG9yOiB7XG4gICAgY29sb3I6IFwiIzAwMFwiXG4gIH0sXG4gIGVkZ2VMYWJlbEZvbnQ6IFwiQXJpYWxcIixcbiAgZWRnZUxhYmVsU2l6ZTogMTQsXG4gIGVkZ2VMYWJlbFdlaWdodDogXCJub3JtYWxcIixcbiAgZWRnZUxhYmVsQ29sb3I6IHtcbiAgICBhdHRyaWJ1dGU6IFwiY29sb3JcIlxuICB9LFxuICBzdGFnZVBhZGRpbmc6IDMwLFxuICB6b29tVG9TaXplUmF0aW9GdW5jdGlvbjogTWF0aC5zcXJ0LFxuICBpdGVtU2l6ZXNSZWZlcmVuY2U6IFwic2NyZWVuXCIsXG4gIGRlZmF1bHREcmF3RWRnZUxhYmVsOiBkcmF3U3RyYWlnaHRFZGdlTGFiZWwsXG4gIGRlZmF1bHREcmF3Tm9kZUxhYmVsOiBkcmF3RGlzY05vZGVMYWJlbCxcbiAgZGVmYXVsdERyYXdOb2RlSG92ZXI6IGRyYXdEaXNjTm9kZUhvdmVyLFxuICAvLyBMYWJlbHNcbiAgbGFiZWxEZW5zaXR5OiAxLFxuICBsYWJlbEdyaWRDZWxsU2l6ZTogMTAwLFxuICBsYWJlbFJlbmRlcmVkU2l6ZVRocmVzaG9sZDogNixcbiAgLy8gUmVkdWNlcnNcbiAgbm9kZVJlZHVjZXI6IG51bGwsXG4gIGVkZ2VSZWR1Y2VyOiBudWxsLFxuICAvLyBGZWF0dXJlc1xuICB6SW5kZXg6IGZhbHNlLFxuICBtaW5DYW1lcmFSYXRpbzogbnVsbCxcbiAgbWF4Q2FtZXJhUmF0aW86IG51bGwsXG4gIC8vIExpZmVjeWNsZVxuICBhbGxvd0ludmFsaWRDb250YWluZXI6IGZhbHNlLFxuICAvLyBQcm9ncmFtIGNsYXNzZXNcbiAgbm9kZVByb2dyYW1DbGFzc2VzOiB7fSxcbiAgbm9kZUhvdmVyUHJvZ3JhbUNsYXNzZXM6IHt9LFxuICBlZGdlUHJvZ3JhbUNsYXNzZXM6IHt9XG59O1xudmFyIERFRkFVTFRfTk9ERV9QUk9HUkFNX0NMQVNTRVMgPSB7XG4gIGNpcmNsZTogTm9kZUNpcmNsZVByb2dyYW1cbn07XG52YXIgREVGQVVMVF9FREdFX1BST0dSQU1fQ0xBU1NFUyA9IHtcbiAgYXJyb3c6IEVkZ2VBcnJvd1Byb2dyYW0sXG4gIGxpbmU6IEVkZ2VSZWN0YW5nbGVQcm9ncmFtXG59O1xuZnVuY3Rpb24gdmFsaWRhdGVTZXR0aW5ncyhzZXR0aW5ncykge1xuICBpZiAodHlwZW9mIHNldHRpbmdzLmxhYmVsRGVuc2l0eSAhPT0gXCJudW1iZXJcIiB8fCBzZXR0aW5ncy5sYWJlbERlbnNpdHkgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiU2V0dGluZ3M6IGludmFsaWQgYGxhYmVsRGVuc2l0eWAuIEV4cGVjdGluZyBhIHBvc2l0aXZlIG51bWJlci5cIik7XG4gIH1cbiAgdmFyIG1pbkNhbWVyYVJhdGlvID0gc2V0dGluZ3MubWluQ2FtZXJhUmF0aW8sXG4gICAgbWF4Q2FtZXJhUmF0aW8gPSBzZXR0aW5ncy5tYXhDYW1lcmFSYXRpbztcbiAgaWYgKHR5cGVvZiBtaW5DYW1lcmFSYXRpbyA9PT0gXCJudW1iZXJcIiAmJiB0eXBlb2YgbWF4Q2FtZXJhUmF0aW8gPT09IFwibnVtYmVyXCIgJiYgbWF4Q2FtZXJhUmF0aW8gPCBtaW5DYW1lcmFSYXRpbykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNldHRpbmdzOiBpbnZhbGlkIGNhbWVyYSByYXRpbyBib3VuZGFyaWVzLiBFeHBlY3RpbmcgYG1heENhbWVyYVJhdGlvYCB0byBiZSBncmVhdGVyIHRoYW4gYG1pbkNhbWVyYVJhdGlvYC5cIik7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVTZXR0aW5ncyhzZXR0aW5ncykge1xuICB2YXIgcmVzb2x2ZWRTZXR0aW5ncyA9IGFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgc2V0dGluZ3MpO1xuICByZXNvbHZlZFNldHRpbmdzLm5vZGVQcm9ncmFtQ2xhc3NlcyA9IGFzc2lnbih7fSwgREVGQVVMVF9OT0RFX1BST0dSQU1fQ0xBU1NFUywgcmVzb2x2ZWRTZXR0aW5ncy5ub2RlUHJvZ3JhbUNsYXNzZXMpO1xuICByZXNvbHZlZFNldHRpbmdzLmVkZ2VQcm9ncmFtQ2xhc3NlcyA9IGFzc2lnbih7fSwgREVGQVVMVF9FREdFX1BST0dSQU1fQ0xBU1NFUywgcmVzb2x2ZWRTZXR0aW5ncy5lZGdlUHJvZ3JhbUNsYXNzZXMpO1xuICByZXR1cm4gcmVzb2x2ZWRTZXR0aW5ncztcbn1cblxuZXhwb3J0IHsgREVGQVVMVF9FREdFX1BST0dSQU1fQ0xBU1NFUywgREVGQVVMVF9OT0RFX1BST0dSQU1fQ0xBU1NFUywgREVGQVVMVF9TRVRUSU5HUywgcmVzb2x2ZVNldHRpbmdzLCB2YWxpZGF0ZVNldHRpbmdzIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sigma/settings/dist/sigma-settings.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/sigma/types/dist/sigma-types.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/sigma/types/dist/sigma-types.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TypedEventEmitter: () => (/* binding */ TypedEventEmitter)\n/* harmony export */ });\n/* harmony import */ var _dist_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../dist/inherits-8fbdedb5.esm.js */ \"(ssr)/./node_modules/sigma/dist/inherits-8fbdedb5.esm.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n\n\n\n/**\n * Util type to represent maps of typed elements, but implemented with\n * JavaScript objects.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * Returns a type similar to T, but with the K set of properties of the type\n * T *required*, and the rest optional.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n/**\n * Custom event emitter types.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nvar TypedEventEmitter = /*#__PURE__*/function (_ref) {\n  (0,_dist_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_1__._)(TypedEventEmitter, _ref);\n  function TypedEventEmitter() {\n    var _this;\n    (0,_dist_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_1__.a)(this, TypedEventEmitter);\n    _this = (0,_dist_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_1__.b)(this, TypedEventEmitter);\n    _this.rawEmitter = (0,_dist_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_1__.c)(_this);\n    return _this;\n  }\n  return (0,_dist_inherits_8fbdedb5_esm_js__WEBPACK_IMPORTED_MODULE_1__.d)(TypedEventEmitter);\n}(events__WEBPACK_IMPORTED_MODULE_0__.EventEmitter);\n\n/**\n * Event types.\n */\n\n/**\n * Export various other types:\n */\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2lnbWEvdHlwZXMvZGlzdC9zaWdtYS10eXBlcy5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE0SjtBQUN0SDs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxpRUFBUztBQUNYO0FBQ0E7QUFDQSxJQUFJLGlFQUFlO0FBQ25CLFlBQVksaUVBQVU7QUFDdEIsdUJBQXVCLGlFQUFzQjtBQUM3QztBQUNBO0FBQ0EsU0FBUyxpRUFBWTtBQUNyQixDQUFDLENBQUMsZ0RBQVk7O0FBRWQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcG9uc2FydS8uL25vZGVfbW9kdWxlcy9zaWdtYS90eXBlcy9kaXN0L3NpZ21hLXR5cGVzLmVzbS5qcz82MDJjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF8gYXMgX2luaGVyaXRzLCBhIGFzIF9jbGFzc0NhbGxDaGVjaywgYiBhcyBfY2FsbFN1cGVyLCBjIGFzIF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQsIGQgYXMgX2NyZWF0ZUNsYXNzIH0gZnJvbSAnLi4vLi4vZGlzdC9pbmhlcml0cy04ZmJkZWRiNS5lc20uanMnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcblxuLyoqXG4gKiBVdGlsIHR5cGUgdG8gcmVwcmVzZW50IG1hcHMgb2YgdHlwZWQgZWxlbWVudHMsIGJ1dCBpbXBsZW1lbnRlZCB3aXRoXG4gKiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbi8qKlxuICogUmV0dXJucyBhIHR5cGUgc2ltaWxhciB0byBULCBidXQgd2l0aCB0aGUgSyBzZXQgb2YgcHJvcGVydGllcyBvZiB0aGUgdHlwZVxuICogVCAqcmVxdWlyZWQqLCBhbmQgdGhlIHJlc3Qgb3B0aW9uYWwuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbi8qKlxuICogQ3VzdG9tIGV2ZW50IGVtaXR0ZXIgdHlwZXMuXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5cbnZhciBUeXBlZEV2ZW50RW1pdHRlciA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoX3JlZikge1xuICBfaW5oZXJpdHMoVHlwZWRFdmVudEVtaXR0ZXIsIF9yZWYpO1xuICBmdW5jdGlvbiBUeXBlZEV2ZW50RW1pdHRlcigpIHtcbiAgICB2YXIgX3RoaXM7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFR5cGVkRXZlbnRFbWl0dGVyKTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgVHlwZWRFdmVudEVtaXR0ZXIpO1xuICAgIF90aGlzLnJhd0VtaXR0ZXIgPSBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKTtcbiAgICByZXR1cm4gX3RoaXM7XG4gIH1cbiAgcmV0dXJuIF9jcmVhdGVDbGFzcyhUeXBlZEV2ZW50RW1pdHRlcik7XG59KEV2ZW50RW1pdHRlcik7XG5cbi8qKlxuICogRXZlbnQgdHlwZXMuXG4gKi9cblxuLyoqXG4gKiBFeHBvcnQgdmFyaW91cyBvdGhlciB0eXBlczpcbiAqL1xuXG5leHBvcnQgeyBUeXBlZEV2ZW50RW1pdHRlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/sigma/types/dist/sigma-types.esm.js\n");

/***/ })

};
;