"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@sigma";
exports.ids = ["vendor-chunks/@sigma"];
exports.modules = {

/***/ "(ssr)/./node_modules/@sigma/node-image/dist/sigma-node-image.esm.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@sigma/node-image/dist/sigma-node-image.esm.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NodeImageProgram: () => (/* binding */ NodeImageProgram),\n/* harmony export */   NodePictogramProgram: () => (/* binding */ NodePictogramProgram),\n/* harmony export */   createNodeImageProgram: () => (/* binding */ getNodeImageProgram)\n/* harmony export */ });\n/* harmony import */ var sigma_rendering__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! sigma/rendering */ \"(ssr)/./node_modules/sigma/rendering/dist/sigma-rendering.esm.js\");\n/* harmony import */ var sigma_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! sigma/utils */ \"(ssr)/./node_modules/sigma/utils/dist/sigma-utils.esm.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\n\nfunction toPropertyKey(t) {\n  var i = toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _isNativeReflectConstruct() {\n  try {\n    var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n  } catch (t) {}\n  return (_isNativeReflectConstruct = function () {\n    return !!t;\n  })();\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (typeof call === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return _assertThisInitialized(self);\n}\n\nfunction _callSuper(t, o, e) {\n  return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));\n}\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = _getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}\n\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    _get = Reflect.get.bind();\n  } else {\n    _get = function _get(target, property, receiver) {\n      var base = _superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    };\n  }\n  return _get.apply(this, arguments);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) _setPrototypeOf(subClass, superClass);\n}\n\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\n\n// language=GLSL\nvar SHADER_SOURCE = /*glsl*/\"\\nprecision highp float;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_diffVector;\\nvarying float v_radius;\\nvarying vec4 v_texture;\\n\\nuniform sampler2D u_atlas;\\nuniform float u_correctionRatio;\\nuniform float u_cameraAngle;\\nuniform float u_percentagePadding;\\nuniform bool u_colorizeImages;\\nuniform bool u_keepWithinCircle;\\n\\nconst vec4 transparent = vec4(0.0, 0.0, 0.0, 0.0);\\n\\nconst float radius = 0.5;\\n\\nvoid main(void) {\\n  float border = 2.0 * u_correctionRatio;\\n  float dist = length(v_diffVector);\\n  vec4 color = gl_FragColor;\\n\\n  float c = cos(-u_cameraAngle);\\n  float s = sin(-u_cameraAngle);\\n  vec2 diffVector = mat2(c, s, -s, c) * (v_diffVector);\\n\\n  // No antialiasing for picking mode:\\n  #ifdef PICKING_MODE\\n  border = 0.0;\\n  color = v_color;\\n\\n  #else\\n  // First case: No image to display\\n  if (v_texture.w <= 0.0) {\\n    if (!u_colorizeImages) {\\n      color = v_color;\\n    }\\n  }\\n\\n  // Second case: Image loaded into the texture\\n  else {\\n    float paddingRatio = 1.0 + 2.0 * u_percentagePadding;\\n    float coef = u_keepWithinCircle ? 1.0 : \".concat(Math.SQRT2, \";\\n    vec2 coordinateInTexture = diffVector * vec2(paddingRatio, -paddingRatio) / v_radius / 2.0 * coef + vec2(0.5, 0.5);\\n    vec4 texel = texture2D(u_atlas, (v_texture.xy + coordinateInTexture * v_texture.zw), -1.0);\\n\\n    // Colorize all visible image pixels:\\n    if (u_colorizeImages) {\\n      color = mix(gl_FragColor, v_color, texel.a);\\n    }\\n\\n    // Colorize background pixels, keep image pixel colors:\\n    else {\\n      color = vec4(mix(v_color, texel, texel.a).rgb, max(texel.a, v_color.a));\\n    }\\n\\n    // Erase pixels \\\"in the padding\\\":\\n    if (abs(diffVector.x) > v_radius / paddingRatio || abs(diffVector.y) > v_radius / paddingRatio) {\\n      color = u_colorizeImages ? gl_FragColor : v_color;\\n    }\\n  }\\n  #endif\\n\\n  // Crop in a circle when u_keepWithinCircle is truthy:\\n  if (u_keepWithinCircle) {\\n    if (dist < v_radius - border) {\\n      gl_FragColor = color;\\n    } else if (dist < v_radius) {\\n      gl_FragColor = mix(transparent, color, (v_radius - dist) / border);\\n    }\\n  }\\n\\n  // Crop in a square else:\\n  else {\\n    float squareHalfSize = v_radius * \").concat(Math.SQRT1_2 * Math.cos(Math.PI / 12), \";\\n    if (abs(diffVector.x) > squareHalfSize || abs(diffVector.y) > squareHalfSize) {\\n      gl_FragColor = transparent;\\n    } else {\\n      gl_FragColor = color;\\n    }\\n  }\\n}\\n\");\nvar FRAGMENT_SHADER_SOURCE = SHADER_SOURCE;\n\n// language=GLSL\nvar VERTEX_SHADER_SOURCE = /*glsl*/\"\\nattribute vec4 a_id;\\nattribute vec4 a_color;\\nattribute vec2 a_position;\\nattribute float a_size;\\nattribute float a_angle;\\nattribute vec4 a_texture;\\n\\nuniform mat3 u_matrix;\\nuniform float u_sizeRatio;\\nuniform float u_correctionRatio;\\n\\nvarying vec4 v_color;\\nvarying vec2 v_diffVector;\\nvarying float v_radius;\\nvarying vec4 v_texture;\\n\\nconst float bias = 255.0 / 254.0;\\nconst float marginRatio = 1.05;\\n\\nvoid main() {\\n  float size = a_size * u_correctionRatio / u_sizeRatio * 4.0;\\n  vec2 diffVector = size * vec2(cos(a_angle), sin(a_angle));\\n  vec2 position = a_position + diffVector * marginRatio;\\n  gl_Position = vec4(\\n    (u_matrix * vec3(position, 1)).xy,\\n    0,\\n    1\\n  );\\n\\n  v_diffVector = diffVector;\\n  v_radius = size / 2.0 / marginRatio;\\n\\n  #ifdef PICKING_MODE\\n  // For picking mode, we use the ID as the color:\\n  v_color = a_id;\\n  #else\\n  // For normal mode, we use the color:\\n  v_color = a_color;\\n\\n  // Pass the texture coordinates:\\n  v_texture = a_texture;\\n  #endif\\n\\n  v_color.a *= bias;\\n}\\n\";\nvar VERTEX_SHADER_SOURCE$1 = VERTEX_SHADER_SOURCE;\n\nfunction _regeneratorRuntime() {\n  _regeneratorRuntime = function () {\n    return e;\n  };\n  var t,\n    e = {},\n    r = Object.prototype,\n    n = r.hasOwnProperty,\n    o = Object.defineProperty || function (t, e, r) {\n      t[e] = r.value;\n    },\n    i = \"function\" == typeof Symbol ? Symbol : {},\n    a = i.iterator || \"@@iterator\",\n    c = i.asyncIterator || \"@@asyncIterator\",\n    u = i.toStringTag || \"@@toStringTag\";\n  function define(t, e, r) {\n    return Object.defineProperty(t, e, {\n      value: r,\n      enumerable: !0,\n      configurable: !0,\n      writable: !0\n    }), t[e];\n  }\n  try {\n    define({}, \"\");\n  } catch (t) {\n    define = function (t, e, r) {\n      return t[e] = r;\n    };\n  }\n  function wrap(t, e, r, n) {\n    var i = e && e.prototype instanceof Generator ? e : Generator,\n      a = Object.create(i.prototype),\n      c = new Context(n || []);\n    return o(a, \"_invoke\", {\n      value: makeInvokeMethod(t, r, c)\n    }), a;\n  }\n  function tryCatch(t, e, r) {\n    try {\n      return {\n        type: \"normal\",\n        arg: t.call(e, r)\n      };\n    } catch (t) {\n      return {\n        type: \"throw\",\n        arg: t\n      };\n    }\n  }\n  e.wrap = wrap;\n  var h = \"suspendedStart\",\n    l = \"suspendedYield\",\n    f = \"executing\",\n    s = \"completed\",\n    y = {};\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n  var p = {};\n  define(p, a, function () {\n    return this;\n  });\n  var d = Object.getPrototypeOf,\n    v = d && d(d(values([])));\n  v && v !== r && n.call(v, a) && (p = v);\n  var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);\n  function defineIteratorMethods(t) {\n    [\"next\", \"throw\", \"return\"].forEach(function (e) {\n      define(t, e, function (t) {\n        return this._invoke(e, t);\n      });\n    });\n  }\n  function AsyncIterator(t, e) {\n    function invoke(r, o, i, a) {\n      var c = tryCatch(t[r], t, o);\n      if (\"throw\" !== c.type) {\n        var u = c.arg,\n          h = u.value;\n        return h && \"object\" == typeof h && n.call(h, \"__await\") ? e.resolve(h.__await).then(function (t) {\n          invoke(\"next\", t, i, a);\n        }, function (t) {\n          invoke(\"throw\", t, i, a);\n        }) : e.resolve(h).then(function (t) {\n          u.value = t, i(u);\n        }, function (t) {\n          return invoke(\"throw\", t, i, a);\n        });\n      }\n      a(c.arg);\n    }\n    var r;\n    o(this, \"_invoke\", {\n      value: function (t, n) {\n        function callInvokeWithMethodAndArg() {\n          return new e(function (e, r) {\n            invoke(t, n, e, r);\n          });\n        }\n        return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();\n      }\n    });\n  }\n  function makeInvokeMethod(e, r, n) {\n    var o = h;\n    return function (i, a) {\n      if (o === f) throw new Error(\"Generator is already running\");\n      if (o === s) {\n        if (\"throw\" === i) throw a;\n        return {\n          value: t,\n          done: !0\n        };\n      }\n      for (n.method = i, n.arg = a;;) {\n        var c = n.delegate;\n        if (c) {\n          var u = maybeInvokeDelegate(c, n);\n          if (u) {\n            if (u === y) continue;\n            return u;\n          }\n        }\n        if (\"next\" === n.method) n.sent = n._sent = n.arg;else if (\"throw\" === n.method) {\n          if (o === h) throw o = s, n.arg;\n          n.dispatchException(n.arg);\n        } else \"return\" === n.method && n.abrupt(\"return\", n.arg);\n        o = f;\n        var p = tryCatch(e, r, n);\n        if (\"normal\" === p.type) {\n          if (o = n.done ? s : l, p.arg === y) continue;\n          return {\n            value: p.arg,\n            done: n.done\n          };\n        }\n        \"throw\" === p.type && (o = s, n.method = \"throw\", n.arg = p.arg);\n      }\n    };\n  }\n  function maybeInvokeDelegate(e, r) {\n    var n = r.method,\n      o = e.iterator[n];\n    if (o === t) return r.delegate = null, \"throw\" === n && e.iterator.return && (r.method = \"return\", r.arg = t, maybeInvokeDelegate(e, r), \"throw\" === r.method) || \"return\" !== n && (r.method = \"throw\", r.arg = new TypeError(\"The iterator does not provide a '\" + n + \"' method\")), y;\n    var i = tryCatch(o, e.iterator, r.arg);\n    if (\"throw\" === i.type) return r.method = \"throw\", r.arg = i.arg, r.delegate = null, y;\n    var a = i.arg;\n    return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, \"return\" !== r.method && (r.method = \"next\", r.arg = t), r.delegate = null, y) : a : (r.method = \"throw\", r.arg = new TypeError(\"iterator result is not an object\"), r.delegate = null, y);\n  }\n  function pushTryEntry(t) {\n    var e = {\n      tryLoc: t[0]\n    };\n    1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);\n  }\n  function resetTryEntry(t) {\n    var e = t.completion || {};\n    e.type = \"normal\", delete e.arg, t.completion = e;\n  }\n  function Context(t) {\n    this.tryEntries = [{\n      tryLoc: \"root\"\n    }], t.forEach(pushTryEntry, this), this.reset(!0);\n  }\n  function values(e) {\n    if (e || \"\" === e) {\n      var r = e[a];\n      if (r) return r.call(e);\n      if (\"function\" == typeof e.next) return e;\n      if (!isNaN(e.length)) {\n        var o = -1,\n          i = function next() {\n            for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next;\n            return next.value = t, next.done = !0, next;\n          };\n        return i.next = i;\n      }\n    }\n    throw new TypeError(typeof e + \" is not iterable\");\n  }\n  return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, \"constructor\", {\n    value: GeneratorFunctionPrototype,\n    configurable: !0\n  }), o(GeneratorFunctionPrototype, \"constructor\", {\n    value: GeneratorFunction,\n    configurable: !0\n  }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, \"GeneratorFunction\"), e.isGeneratorFunction = function (t) {\n    var e = \"function\" == typeof t && t.constructor;\n    return !!e && (e === GeneratorFunction || \"GeneratorFunction\" === (e.displayName || e.name));\n  }, e.mark = function (t) {\n    return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, \"GeneratorFunction\")), t.prototype = Object.create(g), t;\n  }, e.awrap = function (t) {\n    return {\n      __await: t\n    };\n  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {\n    return this;\n  }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {\n    void 0 === i && (i = Promise);\n    var a = new AsyncIterator(wrap(t, r, n, o), i);\n    return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {\n      return t.done ? t.value : a.next();\n    });\n  }, defineIteratorMethods(g), define(g, u, \"Generator\"), define(g, a, function () {\n    return this;\n  }), define(g, \"toString\", function () {\n    return \"[object Generator]\";\n  }), e.keys = function (t) {\n    var e = Object(t),\n      r = [];\n    for (var n in e) r.push(n);\n    return r.reverse(), function next() {\n      for (; r.length;) {\n        var t = r.pop();\n        if (t in e) return next.value = t, next.done = !1, next;\n      }\n      return next.done = !0, next;\n    };\n  }, e.values = values, Context.prototype = {\n    constructor: Context,\n    reset: function (e) {\n      if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) \"t\" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);\n    },\n    stop: function () {\n      this.done = !0;\n      var t = this.tryEntries[0].completion;\n      if (\"throw\" === t.type) throw t.arg;\n      return this.rval;\n    },\n    dispatchException: function (e) {\n      if (this.done) throw e;\n      var r = this;\n      function handle(n, o) {\n        return a.type = \"throw\", a.arg = e, r.next = n, o && (r.method = \"next\", r.arg = t), !!o;\n      }\n      for (var o = this.tryEntries.length - 1; o >= 0; --o) {\n        var i = this.tryEntries[o],\n          a = i.completion;\n        if (\"root\" === i.tryLoc) return handle(\"end\");\n        if (i.tryLoc <= this.prev) {\n          var c = n.call(i, \"catchLoc\"),\n            u = n.call(i, \"finallyLoc\");\n          if (c && u) {\n            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);\n            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);\n          } else if (c) {\n            if (this.prev < i.catchLoc) return handle(i.catchLoc, !0);\n          } else {\n            if (!u) throw new Error(\"try statement without catch or finally\");\n            if (this.prev < i.finallyLoc) return handle(i.finallyLoc);\n          }\n        }\n      }\n    },\n    abrupt: function (t, e) {\n      for (var r = this.tryEntries.length - 1; r >= 0; --r) {\n        var o = this.tryEntries[r];\n        if (o.tryLoc <= this.prev && n.call(o, \"finallyLoc\") && this.prev < o.finallyLoc) {\n          var i = o;\n          break;\n        }\n      }\n      i && (\"break\" === t || \"continue\" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);\n      var a = i ? i.completion : {};\n      return a.type = t, a.arg = e, i ? (this.method = \"next\", this.next = i.finallyLoc, y) : this.complete(a);\n    },\n    complete: function (t, e) {\n      if (\"throw\" === t.type) throw t.arg;\n      return \"break\" === t.type || \"continue\" === t.type ? this.next = t.arg : \"return\" === t.type ? (this.rval = this.arg = t.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === t.type && e && (this.next = e), y;\n    },\n    finish: function (t) {\n      for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n        var r = this.tryEntries[e];\n        if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;\n      }\n    },\n    catch: function (t) {\n      for (var e = this.tryEntries.length - 1; e >= 0; --e) {\n        var r = this.tryEntries[e];\n        if (r.tryLoc === t) {\n          var n = r.completion;\n          if (\"throw\" === n.type) {\n            var o = n.arg;\n            resetTryEntry(r);\n          }\n          return o;\n        }\n      }\n      throw new Error(\"illegal catch attempt\");\n    },\n    delegateYield: function (e, r, n) {\n      return this.delegate = {\n        iterator: values(e),\n        resultName: r,\n        nextLoc: n\n      }, \"next\" === this.method && (this.arg = t), y;\n    }\n  }, e;\n}\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n      args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n      _next(undefined);\n    });\n  };\n}\n\n/**\n * Useful types:\n * *************\n */\n\nvar DEFAULT_TEXTURE_MANAGER_OPTIONS = {\n  size: {\n    mode: \"max\",\n    value: 512\n  },\n  objectFit: \"cover\",\n  correctCentering: false\n};\nvar DEBOUNCE_TIMEOUT = 100;\n\n// This margin helps avoiding images collisions in the texture:\nvar MARGIN_IN_TEXTURE = 1;\n\n/**\n * Helpers:\n * ********\n */\n/**\n * This helper loads an image at a given URL, and returns an HTMLImageElement\n * with it displayed once it's properly loaded, within a promise.\n */\nfunction loadRasterImage(imageSource) {\n  return new Promise(function (resolve, reject) {\n    var image = new Image();\n    image.addEventListener(\"load\", function () {\n      resolve(image);\n    }, {\n      once: true\n    });\n    image.addEventListener(\"error\", function (e) {\n      reject(e.error);\n    }, {\n      once: true\n    });\n\n    // Load image:\n    image.setAttribute(\"crossOrigin\", \"\");\n    image.src = imageSource;\n  });\n}\n\n/**\n * This helper loads an SVG image at a given URL, adjusts its size to a given\n * size, and returns an HTMLImageElement with it displayed once it's properly\n * loaded, within a promise.\n */\nfunction loadSVGImage(_x) {\n  return _loadSVGImage.apply(this, arguments);\n}\n\n/**\n * This helper loads an image using the proper function.\n */\nfunction _loadSVGImage() {\n  _loadSVGImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(imageSource) {\n    var _ref,\n      size,\n      resp,\n      svgString,\n      svg,\n      root,\n      originalWidth,\n      originalHeight,\n      correctedSvgString,\n      blob,\n      url,\n      res,\n      _args2 = arguments;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          _ref = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {}, size = _ref.size;\n          _context2.next = 3;\n          return fetch(imageSource);\n        case 3:\n          resp = _context2.sent;\n          _context2.next = 6;\n          return resp.text();\n        case 6:\n          svgString = _context2.sent;\n          svg = new DOMParser().parseFromString(svgString, \"image/svg+xml\");\n          root = svg.documentElement;\n          originalWidth = root.getAttribute(\"width\");\n          originalHeight = root.getAttribute(\"height\");\n          if (!(!originalWidth || !originalHeight)) {\n            _context2.next = 13;\n            break;\n          }\n          throw new Error(\"loadSVGImage: cannot use `size` if target SVG has no definite dimensions.\");\n        case 13:\n          if (typeof size === \"number\") {\n            root.setAttribute(\"width\", \"\" + size);\n            root.setAttribute(\"height\", \"\" + size);\n          }\n\n          // NOTE: since Google Material last changes to their icon viewBox, this\n          // code is no longer necessary (hopefully it does not break something else...)\n          // root.setAttribute(\"viewBox\", `0 0 ${originalWidth} ${originalHeight}`);\n          correctedSvgString = new XMLSerializer().serializeToString(svg);\n          blob = new Blob([correctedSvgString], {\n            type: \"image/svg+xml\"\n          });\n          url = URL.createObjectURL(blob);\n          res = loadRasterImage(url);\n          res[\"finally\"](function () {\n            return URL.revokeObjectURL(url);\n          });\n          return _context2.abrupt(\"return\", res);\n        case 20:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2);\n  }));\n  return _loadSVGImage.apply(this, arguments);\n}\nfunction loadImage(_x2) {\n  return _loadImage.apply(this, arguments);\n}\n\n/**\n * This helper computes exact coordinates to draw an image onto a texture.\n */\nfunction _loadImage() {\n  _loadImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(imageSource) {\n    var _imageSource$split$0$;\n    var _ref2,\n      size,\n      isSVG,\n      image,\n      _args3 = arguments;\n    return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n      while (1) switch (_context3.prev = _context3.next) {\n        case 0:\n          _ref2 = _args3.length > 1 && _args3[1] !== undefined ? _args3[1] : {}, size = _ref2.size;\n          isSVG = ((_imageSource$split$0$ = imageSource.split(/[#?]/)[0].split(\".\").pop()) === null || _imageSource$split$0$ === void 0 ? void 0 : _imageSource$split$0$.trim().toLowerCase()) === \"svg\";\n          if (!(isSVG && size)) {\n            _context3.next = 16;\n            break;\n          }\n          _context3.prev = 3;\n          _context3.next = 6;\n          return loadSVGImage(imageSource, {\n            size: size\n          });\n        case 6:\n          image = _context3.sent;\n          _context3.next = 14;\n          break;\n        case 9:\n          _context3.prev = 9;\n          _context3.t0 = _context3[\"catch\"](3);\n          _context3.next = 13;\n          return loadRasterImage(imageSource);\n        case 13:\n          image = _context3.sent;\n        case 14:\n          _context3.next = 19;\n          break;\n        case 16:\n          _context3.next = 18;\n          return loadRasterImage(imageSource);\n        case 18:\n          image = _context3.sent;\n        case 19:\n          return _context3.abrupt(\"return\", image);\n        case 20:\n        case \"end\":\n          return _context3.stop();\n      }\n    }, _callee3, null, [[3, 9]]);\n  }));\n  return _loadImage.apply(this, arguments);\n}\nfunction refineImage(image, corrector, _ref3) {\n  var objectFit = _ref3.objectFit,\n    size = _ref3.size,\n    correctCentering = _ref3.correctCentering;\n  var sourceSize = objectFit === \"contain\" ? Math.max(image.width, image.height) : Math.min(image.width, image.height);\n  var destinationSize = size.mode === \"auto\" ? sourceSize : size.mode === \"force\" ? size.value : Math.min(size.value, sourceSize);\n  var sourceX = (image.width - sourceSize) / 2;\n  var sourceY = (image.height - sourceSize) / 2;\n  if (correctCentering) {\n    var correction = corrector.getCorrectionOffset(image, sourceSize);\n    sourceX = correction.x;\n    sourceY = correction.y;\n  }\n  return {\n    sourceX: sourceX,\n    sourceY: sourceY,\n    sourceSize: sourceSize,\n    destinationSize: destinationSize\n  };\n}\n\n/**\n * This helper takes a collection of image states and a context, draw all the\n * images in the context, and returns an atlas to get where each image is drawn\n * on the texture.\n */\nfunction drawTexture(ctx, images) {\n  var MAX_CANVAS_WIDTH = 3072;\n  var TARGET_FILL_PERCENTAGE = 0.6;\n\n  // 1. Sort images by height, decreasingly:\n  var imagesArray = [];\n  var totalArea = 0;\n  var maxItemWidth = 0;\n  for (var key in images) {\n    var imageState = images[key];\n    if (imageState.status !== \"ready\") continue;\n    maxItemWidth = Math.max(maxItemWidth, imageState.destinationSize);\n    totalArea += Math.pow(imageState.destinationSize, 2);\n    imagesArray.push(_objectSpread2({\n      key: key\n    }, imageState));\n  }\n  imagesArray.sort(function (a, b) {\n    return a.destinationSize > b.destinationSize ? -1 : 1;\n  });\n\n  // 2. Predict canvas width:\n  var predictedTotalArea = totalArea / TARGET_FILL_PERCENTAGE;\n  var predictedWidth = Math.min(Math.max(Math.sqrt(predictedTotalArea), maxItemWidth), MAX_CANVAS_WIDTH);\n\n  // 3. Refine images coordinates:\n  var refinedImagesArray = [];\n  var x = 0;\n  var y = 0;\n  var currentRowHeight = 0;\n  var maxRowWidth = 0;\n  var atlas = {};\n  for (var i = 0, l = imagesArray.length; i < l; i++) {\n    var _imagesArray$i = imagesArray[i],\n      _key = _imagesArray$i.key,\n      image = _imagesArray$i.image,\n      sourceSize = _imagesArray$i.sourceSize,\n      sourceX = _imagesArray$i.sourceX,\n      sourceY = _imagesArray$i.sourceY,\n      destinationSize = _imagesArray$i.destinationSize;\n    var destinationSizeWithMargin = destinationSize + MARGIN_IN_TEXTURE;\n    if (x + destinationSizeWithMargin > predictedWidth) {\n      maxRowWidth = Math.max(maxRowWidth, x);\n      x = 0;\n      y += currentRowHeight;\n      currentRowHeight = destinationSizeWithMargin;\n    }\n    refinedImagesArray.push({\n      key: _key,\n      image: image,\n      sourceX: sourceX,\n      sourceY: sourceY,\n      sourceSize: sourceSize,\n      destinationX: x,\n      destinationY: y,\n      destinationSize: destinationSize\n    });\n    atlas[_key] = {\n      x: x,\n      y: y,\n      size: destinationSize\n    };\n    x += destinationSizeWithMargin;\n    currentRowHeight = Math.max(currentRowHeight, destinationSizeWithMargin);\n  }\n\n  // 4. Crop texture to final best dimensions:\n  maxRowWidth = Math.max(maxRowWidth, x);\n  var canvas = ctx.canvas;\n  canvas.width = maxRowWidth;\n  canvas.height = y + currentRowHeight;\n\n  // 5. Fill texture:\n  for (var _i = 0, _l = refinedImagesArray.length; _i < _l; _i++) {\n    var _refinedImagesArray$_ = refinedImagesArray[_i],\n      _image = _refinedImagesArray$_.image,\n      _sourceSize = _refinedImagesArray$_.sourceSize,\n      _sourceX = _refinedImagesArray$_.sourceX,\n      _sourceY = _refinedImagesArray$_.sourceY,\n      _destinationSize = _refinedImagesArray$_.destinationSize,\n      destinationX = _refinedImagesArray$_.destinationX,\n      destinationY = _refinedImagesArray$_.destinationY;\n    ctx.drawImage(_image, _sourceX, _sourceY, _sourceSize, _sourceSize, destinationX, destinationY, _destinationSize, _destinationSize);\n  }\n  return atlas;\n}\n\n/**\n * This class helps to \"correct\" the centering of an SVG pictogram by finding\n * the \"true\" visually correct center through the barycenter of the pictogram's\n * alpha layer in x and y dimension.\n */\nvar PictogramCenteringCorrector = /*#__PURE__*/function () {\n  function PictogramCenteringCorrector() {\n    _classCallCheck(this, PictogramCenteringCorrector);\n    this.canvas = document.createElement(\"canvas\");\n    this.context = this.canvas.getContext(\"2d\", {\n      willReadFrequently: true\n    });\n  }\n  _createClass(PictogramCenteringCorrector, [{\n    key: \"getCorrectionOffset\",\n    value: function getCorrectionOffset(image, size) {\n      this.canvas.width = size;\n      this.canvas.height = size;\n      this.context.clearRect(0, 0, size, size);\n      this.context.drawImage(image, 0, 0, size, size);\n      var data = this.context.getImageData(0, 0, size, size).data;\n      var alpha = new Uint8ClampedArray(data.length / 4);\n      for (var i = 0; i < data.length; i++) {\n        alpha[i] = data[i * 4 + 3];\n      }\n      var sumX = 0;\n      var sumY = 0;\n      var total = 0;\n      for (var y = 0; y < size; y++) {\n        for (var x = 0; x < size; x++) {\n          var a = alpha[y * size + x];\n          total += a;\n          sumX += a * x;\n          sumY += a * y;\n        }\n      }\n      var barycenterX = sumX / total;\n      var barycenterY = sumY / total;\n      return {\n        x: barycenterX - size / 2,\n        y: barycenterY - size / 2\n      };\n    }\n  }]);\n  return PictogramCenteringCorrector;\n}();\nvar TextureManager = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(TextureManager, _EventEmitter);\n  function TextureManager() {\n    var _this;\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classCallCheck(this, TextureManager);\n    _this = _callSuper(this, TextureManager);\n    _defineProperty(_assertThisInitialized(_this), \"canvas\", document.createElement(\"canvas\"));\n    _defineProperty(_assertThisInitialized(_this), \"ctx\", _this.canvas.getContext(\"2d\", {\n      willReadFrequently: true\n    }));\n    _defineProperty(_assertThisInitialized(_this), \"corrector\", new PictogramCenteringCorrector());\n    _defineProperty(_assertThisInitialized(_this), \"imageStates\", {});\n    _defineProperty(_assertThisInitialized(_this), \"texture\", _this.ctx.getImageData(0, 0, 1, 1));\n    _defineProperty(_assertThisInitialized(_this), \"atlas\", {});\n    _this.options = _objectSpread2(_objectSpread2({}, DEFAULT_TEXTURE_MANAGER_OPTIONS), options);\n    return _this;\n  }\n  _createClass(TextureManager, [{\n    key: \"scheduleGenerateTexture\",\n    value: function scheduleGenerateTexture() {\n      var _this2 = this;\n      if (typeof this.frameId === \"number\") return;\n      this.frameId = window.setTimeout(function () {\n        _this2.generateTexture();\n        _this2.frameId = undefined;\n      }, DEBOUNCE_TIMEOUT);\n    }\n  }, {\n    key: \"generateTexture\",\n    value: function generateTexture() {\n      this.atlas = drawTexture(this.ctx, this.imageStates);\n      this.texture = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);\n      this.emit(TextureManager.NEW_TEXTURE_EVENT, {\n        atlas: this.atlas,\n        texture: this.texture\n      });\n    }\n\n    // PUBLIC API:\n  }, {\n    key: \"registerImage\",\n    value: function () {\n      var _registerImage = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(source) {\n        var size, image;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!this.imageStates[source]) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\");\n            case 2:\n              this.imageStates[source] = {\n                status: \"loading\"\n              };\n              _context.prev = 3;\n              size = this.options.size;\n              _context.next = 7;\n              return loadImage(source, {\n                size: size.mode === \"force\" ? size.value : undefined\n              });\n            case 7:\n              image = _context.sent;\n              this.imageStates[source] = _objectSpread2({\n                status: \"ready\",\n                image: image\n              }, refineImage(image, this.corrector, this.options));\n              this.scheduleGenerateTexture();\n              _context.next = 15;\n              break;\n            case 12:\n              _context.prev = 12;\n              _context.t0 = _context[\"catch\"](3);\n              this.imageStates[source] = {\n                status: \"error\"\n              };\n            case 15:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[3, 12]]);\n      }));\n      function registerImage(_x3) {\n        return _registerImage.apply(this, arguments);\n      }\n      return registerImage;\n    }()\n  }, {\n    key: \"getAtlas\",\n    value: function getAtlas() {\n      return this.atlas;\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture() {\n      return this.texture;\n    }\n  }]);\n  return TextureManager;\n}(events__WEBPACK_IMPORTED_MODULE_2__.EventEmitter);\n_defineProperty(TextureManager, \"NEW_TEXTURE_EVENT\", \"newTexture\");\n\nvar _excluded = [\"drawHover\", \"drawLabel\", \"drawingMode\", \"keepWithinCircle\", \"padding\", \"colorAttribute\"];\nvar _WebGLRenderingContex = WebGLRenderingContext,\n  UNSIGNED_BYTE = _WebGLRenderingContex.UNSIGNED_BYTE,\n  FLOAT = _WebGLRenderingContex.FLOAT;\nvar DEFAULT_CREATE_NODE_IMAGE_OPTIONS = _objectSpread2(_objectSpread2({}, DEFAULT_TEXTURE_MANAGER_OPTIONS), {}, {\n  drawingMode: \"background\",\n  keepWithinCircle: true,\n  drawLabel: undefined,\n  drawHover: undefined,\n  padding: 0,\n  colorAttribute: \"color\"\n});\nvar UNIFORMS = [\"u_sizeRatio\", \"u_correctionRatio\", \"u_cameraAngle\", \"u_percentagePadding\", \"u_matrix\", \"u_colorizeImages\", \"u_keepWithinCircle\", \"u_atlas\"];\n\n/**\n * To share the texture between the program instances of the graph and the\n * hovered nodes (to prevent some flickering, mostly), this program must be\n * \"built\" for each sigma instance:\n */\nfunction getNodeImageProgram(options) {\n  var _NodeImageProgram;\n  var _DEFAULT_CREATE_NODE_ = _objectSpread2(_objectSpread2(_objectSpread2({}, DEFAULT_CREATE_NODE_IMAGE_OPTIONS), options || {}), {}, {\n      drawLabel: undefined,\n      drawHover: undefined\n    }),\n    drawHover = _DEFAULT_CREATE_NODE_.drawHover,\n    drawLabel = _DEFAULT_CREATE_NODE_.drawLabel,\n    drawingMode = _DEFAULT_CREATE_NODE_.drawingMode,\n    keepWithinCircle = _DEFAULT_CREATE_NODE_.keepWithinCircle,\n    padding = _DEFAULT_CREATE_NODE_.padding,\n    colorAttribute = _DEFAULT_CREATE_NODE_.colorAttribute,\n    textureManagerOptions = _objectWithoutProperties(_DEFAULT_CREATE_NODE_, _excluded);\n\n  /**\n   * This texture manager is shared between all instances of this exact class,\n   * returned by this call to getNodeProgramImage. This means that remounting\n   * the sigma instance will not reload the images and regenerate the texture.\n   */\n  var textureManager = new TextureManager(textureManagerOptions);\n  return _NodeImageProgram = /*#__PURE__*/function (_NodeProgram) {\n    _inherits(NodeImageProgram, _NodeProgram);\n    function NodeImageProgram(gl, pickingBuffer, renderer) {\n      var _this;\n      _classCallCheck(this, NodeImageProgram);\n      _this = _callSuper(this, NodeImageProgram, [gl, pickingBuffer, renderer]);\n      _this.textureManagerCallback = function () {\n        if (!_assertThisInitialized(_this)) return;\n        if (_this.bindTexture) {\n          _this.atlas = textureManager.getAtlas();\n          _this.textureImage = textureManager.getTexture();\n          _this.bindTexture();\n          if (_this.latestRenderParams) _this.render(_this.latestRenderParams);\n        }\n        if (renderer && renderer.refresh) renderer.refresh();\n      };\n      textureManager.on(TextureManager.NEW_TEXTURE_EVENT, _this.textureManagerCallback);\n      _this.atlas = textureManager.getAtlas();\n      _this.textureImage = textureManager.getTexture();\n      _this.texture = gl.createTexture();\n      _this.bindTexture();\n      return _this;\n    }\n    _createClass(NodeImageProgram, [{\n      key: \"getDefinition\",\n      value: function getDefinition() {\n        return {\n          VERTICES: 3,\n          VERTEX_SHADER_SOURCE: VERTEX_SHADER_SOURCE$1,\n          FRAGMENT_SHADER_SOURCE: FRAGMENT_SHADER_SOURCE,\n          METHOD: WebGLRenderingContext.TRIANGLES,\n          UNIFORMS: UNIFORMS,\n          ATTRIBUTES: [{\n            name: \"a_position\",\n            size: 2,\n            type: FLOAT\n          }, {\n            name: \"a_size\",\n            size: 1,\n            type: FLOAT\n          }, {\n            name: \"a_color\",\n            size: 4,\n            type: UNSIGNED_BYTE,\n            normalized: true\n          }, {\n            name: \"a_id\",\n            size: 4,\n            type: UNSIGNED_BYTE,\n            normalized: true\n          }, {\n            name: \"a_texture\",\n            size: 4,\n            type: FLOAT\n          }],\n          CONSTANT_ATTRIBUTES: [{\n            name: \"a_angle\",\n            size: 1,\n            type: FLOAT\n          }],\n          CONSTANT_DATA: [[NodeImageProgram.ANGLE_1], [NodeImageProgram.ANGLE_2], [NodeImageProgram.ANGLE_3]]\n        };\n      }\n    }, {\n      key: \"kill\",\n      value: function kill() {\n        textureManager.off(TextureManager.NEW_TEXTURE_EVENT, this.textureManagerCallback);\n      }\n    }, {\n      key: \"bindTexture\",\n      value: function bindTexture() {\n        var gl = this.normalProgram.gl;\n        gl.bindTexture(gl.TEXTURE_2D, this.texture);\n        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.textureImage);\n        gl.generateMipmap(gl.TEXTURE_2D);\n      }\n    }, {\n      key: \"renderProgram\",\n      value: function renderProgram(params, programInfo) {\n        if (!programInfo.isPicking) {\n          // Rebind texture (since it's been just unbound by picking):\n          var gl = programInfo.gl;\n          gl.bindTexture(gl.TEXTURE_2D, this.texture);\n        }\n        _get(_getPrototypeOf(NodeImageProgram.prototype), \"renderProgram\", this).call(this, params, programInfo);\n      }\n    }, {\n      key: \"processVisibleItem\",\n      value: function processVisibleItem(nodeIndex, startIndex, data) {\n        var array = this.array;\n        var color = (0,sigma_utils__WEBPACK_IMPORTED_MODULE_1__.floatColor)(data[colorAttribute]);\n        var imageSource = data.image;\n        var imagePosition = imageSource ? this.atlas[imageSource] : undefined;\n        if (typeof imageSource === \"string\" && !imagePosition) textureManager.registerImage(imageSource);\n        array[startIndex++] = data.x;\n        array[startIndex++] = data.y;\n        array[startIndex++] = data.size;\n        array[startIndex++] = color;\n        array[startIndex++] = nodeIndex;\n\n        // Reference texture:\n        if (imagePosition) {\n          var _this$textureImage = this.textureImage,\n            width = _this$textureImage.width,\n            height = _this$textureImage.height;\n          array[startIndex++] = imagePosition.x / width;\n          array[startIndex++] = imagePosition.y / height;\n          array[startIndex++] = imagePosition.size / width;\n          array[startIndex++] = imagePosition.size / height;\n        } else {\n          array[startIndex++] = 0;\n          array[startIndex++] = 0;\n          array[startIndex++] = 0;\n          array[startIndex++] = 0;\n        }\n      }\n    }, {\n      key: \"setUniforms\",\n      value: function setUniforms(params, _ref) {\n        var gl = _ref.gl,\n          uniformLocations = _ref.uniformLocations;\n        var u_sizeRatio = uniformLocations.u_sizeRatio,\n          u_correctionRatio = uniformLocations.u_correctionRatio,\n          u_matrix = uniformLocations.u_matrix,\n          u_atlas = uniformLocations.u_atlas,\n          u_colorizeImages = uniformLocations.u_colorizeImages,\n          u_keepWithinCircle = uniformLocations.u_keepWithinCircle,\n          u_cameraAngle = uniformLocations.u_cameraAngle,\n          u_percentagePadding = uniformLocations.u_percentagePadding;\n        this.latestRenderParams = params;\n        gl.uniform1f(u_correctionRatio, params.correctionRatio);\n        gl.uniform1f(u_sizeRatio, keepWithinCircle ? params.sizeRatio : params.sizeRatio / Math.SQRT2);\n        gl.uniform1f(u_cameraAngle, params.cameraAngle);\n        gl.uniform1f(u_percentagePadding, padding);\n        gl.uniformMatrix3fv(u_matrix, false, params.matrix);\n        gl.uniform1i(u_atlas, 0);\n        gl.uniform1i(u_colorizeImages, drawingMode === \"color\" ? 1 : 0);\n        gl.uniform1i(u_keepWithinCircle, keepWithinCircle ? 1 : 0);\n      }\n    }]);\n    return NodeImageProgram;\n  }(sigma_rendering__WEBPACK_IMPORTED_MODULE_0__.NodeProgram), _defineProperty(_NodeImageProgram, \"ANGLE_1\", 0), _defineProperty(_NodeImageProgram, \"ANGLE_2\", 2 * Math.PI / 3), _defineProperty(_NodeImageProgram, \"ANGLE_3\", 4 * Math.PI / 3), _defineProperty(_NodeImageProgram, \"drawLabel\", drawLabel), _defineProperty(_NodeImageProgram, \"drawHover\", drawHover), _NodeImageProgram;\n}\n\nvar NodeImageProgram = getNodeImageProgram();\nvar NodePictogramProgram = getNodeImageProgram({\n  keepWithinCircle: false,\n  size: {\n    mode: \"force\",\n    value: 256\n  },\n  drawingMode: \"color\",\n  correctCentering: true\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHNpZ21hL25vZGUtaW1hZ2UvZGlzdC9zaWdtYS1ub2RlLWltYWdlLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQThDO0FBQ0w7QUFDSDs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5RkFBeUY7QUFDekYsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNkJBQTZCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNCQUFzQjtBQUN4QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EscURBQXFELHlCQUF5Qiw0QkFBNEIseUJBQXlCLHlCQUF5Qiw4QkFBOEIsa0NBQWtDLDhCQUE4QixvQ0FBb0MsZ0NBQWdDLGtDQUFrQyxzREFBc0QsNkJBQTZCLHFCQUFxQiwyQ0FBMkMsc0NBQXNDLDhCQUE4QixvQ0FBb0Msa0NBQWtDLHlEQUF5RCxrRkFBa0Ysb0JBQW9CLDhFQUE4RSw4QkFBOEIsd0JBQXdCLE9BQU8sS0FBSyw2REFBNkQsMkRBQTJELHFFQUFxRSx5SEFBeUgsaUdBQWlHLDBFQUEwRSxvREFBb0QsT0FBTywyRUFBMkUsZ0ZBQWdGLE9BQU8sa0pBQWtKLDBEQUEwRCxPQUFPLEtBQUssbUdBQW1HLHFDQUFxQyw2QkFBNkIsUUFBUSwyQkFBMkIsMkVBQTJFLE9BQU8sS0FBSyx5Q0FBeUMsMkZBQTJGLHFGQUFxRixtQ0FBbUMsUUFBUSxNQUFNLDZCQUE2QixPQUFPLEtBQUssR0FBRztBQUN2NUU7O0FBRUE7QUFDQSwwREFBMEQseUJBQXlCLDRCQUE0Qix5QkFBeUIsMEJBQTBCLDJCQUEyQiwwQkFBMEIsNEJBQTRCLGtDQUFrQyx5QkFBeUIsNEJBQTRCLHlCQUF5Qix5QkFBeUIscUNBQXFDLGlDQUFpQyxpQkFBaUIsZ0VBQWdFLDhEQUE4RCwwREFBMEQsb0ZBQW9GLGdDQUFnQyx3Q0FBd0MsZ0dBQWdHLHdFQUF3RSxnRUFBZ0Usa0NBQWtDLEdBQUc7QUFDcGpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBYTtBQUNiLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixlQUFlO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsK0NBQStDLFFBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RTtBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlELGVBQWUsRUFBRSxlQUFlO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEMsd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQSw4REFBOEQ7QUFDOUQsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDLENBQUMsZ0RBQVk7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxzQ0FBc0M7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLG1EQUFtRCxLQUFLO0FBQ3JJO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdURBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRyxDQUFDLHdEQUFXO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOztBQUVnRyIsInNvdXJjZXMiOlsid2VicGFjazovL3Nwb25zYXJ1Ly4vbm9kZV9tb2R1bGVzL0BzaWdtYS9ub2RlLWltYWdlL2Rpc3Qvc2lnbWEtbm9kZS1pbWFnZS5lc20uanM/MDM4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOb2RlUHJvZ3JhbSB9IGZyb20gJ3NpZ21hL3JlbmRlcmluZyc7XG5pbXBvcnQgeyBmbG9hdENvbG9yIH0gZnJvbSAnc2lnbWEvdXRpbHMnO1xuaW1wb3J0IHsgRXZlbnRFbWl0dGVyIH0gZnJvbSAnZXZlbnRzJztcblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxuZnVuY3Rpb24gdG9QcmltaXRpdmUodCwgcikge1xuICBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdCB8fCAhdCkgcmV0dXJuIHQ7XG4gIHZhciBlID0gdFtTeW1ib2wudG9QcmltaXRpdmVdO1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgdmFyIGkgPSBlLmNhbGwodCwgciB8fCBcImRlZmF1bHRcIik7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIGkpIHJldHVybiBpO1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJAQHRvUHJpbWl0aXZlIG11c3QgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlLlwiKTtcbiAgfVxuICByZXR1cm4gKFwic3RyaW5nXCIgPT09IHIgPyBTdHJpbmcgOiBOdW1iZXIpKHQpO1xufVxuXG5mdW5jdGlvbiB0b1Byb3BlcnR5S2V5KHQpIHtcbiAgdmFyIGkgPSB0b1ByaW1pdGl2ZSh0LCBcInN0cmluZ1wiKTtcbiAgcmV0dXJuIFwic3ltYm9sXCIgPT0gdHlwZW9mIGkgPyBpIDogU3RyaW5nKGkpO1xufVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCB0b1Byb3BlcnR5S2V5KGRlc2NyaXB0b3Iua2V5KSwgZGVzY3JpcHRvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KENvbnN0cnVjdG9yLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gQ29uc3RydWN0b3I7XG59XG5cbmZ1bmN0aW9uIF9nZXRQcm90b3R5cGVPZihvKSB7XG4gIF9nZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5nZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfZ2V0UHJvdG90eXBlT2Yobykge1xuICAgIHJldHVybiBvLl9fcHJvdG9fXyB8fCBPYmplY3QuZ2V0UHJvdG90eXBlT2Yobyk7XG4gIH07XG4gIHJldHVybiBfZ2V0UHJvdG90eXBlT2Yobyk7XG59XG5cbmZ1bmN0aW9uIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSB7XG4gIHRyeSB7XG4gICAgdmFyIHQgPSAhQm9vbGVhbi5wcm90b3R5cGUudmFsdWVPZi5jYWxsKFJlZmxlY3QuY29uc3RydWN0KEJvb2xlYW4sIFtdLCBmdW5jdGlvbiAoKSB7fSkpO1xuICB9IGNhdGNoICh0KSB7fVxuICByZXR1cm4gKF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICEhdDtcbiAgfSkoKTtcbn1cblxuZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gIGlmIChzZWxmID09PSB2b2lkIDApIHtcbiAgICB0aHJvdyBuZXcgUmVmZXJlbmNlRXJyb3IoXCJ0aGlzIGhhc24ndCBiZWVuIGluaXRpYWxpc2VkIC0gc3VwZXIoKSBoYXNuJ3QgYmVlbiBjYWxsZWRcIik7XG4gIH1cbiAgcmV0dXJuIHNlbGY7XG59XG5cbmZ1bmN0aW9uIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHNlbGYsIGNhbGwpIHtcbiAgaWYgKGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpKSB7XG4gICAgcmV0dXJuIGNhbGw7XG4gIH0gZWxzZSBpZiAoY2FsbCAhPT0gdm9pZCAwKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkRlcml2ZWQgY29uc3RydWN0b3JzIG1heSBvbmx5IHJldHVybiBvYmplY3Qgb3IgdW5kZWZpbmVkXCIpO1xuICB9XG4gIHJldHVybiBfYXNzZXJ0VGhpc0luaXRpYWxpemVkKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBfY2FsbFN1cGVyKHQsIG8sIGUpIHtcbiAgcmV0dXJuIG8gPSBfZ2V0UHJvdG90eXBlT2YobyksIF9wb3NzaWJsZUNvbnN0cnVjdG9yUmV0dXJuKHQsIF9pc05hdGl2ZVJlZmxlY3RDb25zdHJ1Y3QoKSA/IFJlZmxlY3QuY29uc3RydWN0KG8sIGUgfHwgW10sIF9nZXRQcm90b3R5cGVPZih0KS5jb25zdHJ1Y3RvcikgOiBvLmFwcGx5KHQsIGUpKTtcbn1cblxuZnVuY3Rpb24gX3N1cGVyUHJvcEJhc2Uob2JqZWN0LCBwcm9wZXJ0eSkge1xuICB3aGlsZSAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSkge1xuICAgIG9iamVjdCA9IF9nZXRQcm90b3R5cGVPZihvYmplY3QpO1xuICAgIGlmIChvYmplY3QgPT09IG51bGwpIGJyZWFrO1xuICB9XG4gIHJldHVybiBvYmplY3Q7XG59XG5cbmZ1bmN0aW9uIF9nZXQoKSB7XG4gIGlmICh0eXBlb2YgUmVmbGVjdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBSZWZsZWN0LmdldCkge1xuICAgIF9nZXQgPSBSZWZsZWN0LmdldC5iaW5kKCk7XG4gIH0gZWxzZSB7XG4gICAgX2dldCA9IGZ1bmN0aW9uIF9nZXQodGFyZ2V0LCBwcm9wZXJ0eSwgcmVjZWl2ZXIpIHtcbiAgICAgIHZhciBiYXNlID0gX3N1cGVyUHJvcEJhc2UodGFyZ2V0LCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoIWJhc2UpIHJldHVybjtcbiAgICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihiYXNlLCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoZGVzYy5nZXQpIHtcbiAgICAgICAgcmV0dXJuIGRlc2MuZ2V0LmNhbGwoYXJndW1lbnRzLmxlbmd0aCA8IDMgPyB0YXJnZXQgOiByZWNlaXZlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVzYy52YWx1ZTtcbiAgICB9O1xuICB9XG4gIHJldHVybiBfZ2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XG4gIF9zZXRQcm90b3R5cGVPZiA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiA/IE9iamVjdC5zZXRQcm90b3R5cGVPZi5iaW5kKCkgOiBmdW5jdGlvbiBfc2V0UHJvdG90eXBlT2YobywgcCkge1xuICAgIG8uX19wcm90b19fID0gcDtcbiAgICByZXR1cm4gbztcbiAgfTtcbiAgcmV0dXJuIF9zZXRQcm90b3R5cGVPZihvLCBwKTtcbn1cblxuZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3VwZXIgZXhwcmVzc2lvbiBtdXN0IGVpdGhlciBiZSBudWxsIG9yIGEgZnVuY3Rpb25cIik7XG4gIH1cbiAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgY29uc3RydWN0b3I6IHtcbiAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcInByb3RvdHlwZVwiLCB7XG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICBpZiAoc3VwZXJDbGFzcykgX3NldFByb3RvdHlwZU9mKHN1YkNsYXNzLCBzdXBlckNsYXNzKTtcbn1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBrZXkgPSB0b1Byb3BlcnR5S2V5KGtleSk7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG4gIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgaWYgKHNvdXJjZSA9PSBudWxsKSByZXR1cm4ge307XG4gIHZhciB0YXJnZXQgPSB7fTtcbiAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICB2YXIga2V5LCBpO1xuICBmb3IgKGkgPSAwOyBpIDwgc291cmNlS2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IHNvdXJjZUtleXNbaV07XG4gICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgdmFyIHNvdXJjZVN5bWJvbEtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHNvdXJjZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIG93bktleXMoZSwgcikge1xuICB2YXIgdCA9IE9iamVjdC5rZXlzKGUpO1xuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHZhciBvID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhlKTtcbiAgICByICYmIChvID0gby5maWx0ZXIoZnVuY3Rpb24gKHIpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIHIpLmVudW1lcmFibGU7XG4gICAgfSkpLCB0LnB1c2guYXBwbHkodCwgbyk7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkMihlKSB7XG4gIGZvciAodmFyIHIgPSAxOyByIDwgYXJndW1lbnRzLmxlbmd0aDsgcisrKSB7XG4gICAgdmFyIHQgPSBudWxsICE9IGFyZ3VtZW50c1tyXSA/IGFyZ3VtZW50c1tyXSA6IHt9O1xuICAgIHIgJSAyID8gb3duS2V5cyhPYmplY3QodCksICEwKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBfZGVmaW5lUHJvcGVydHkoZSwgciwgdFtyXSk7XG4gICAgfSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHQpKSA6IG93bktleXMoT2JqZWN0KHQpKS5mb3JFYWNoKGZ1bmN0aW9uIChyKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZSwgciwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0LCByKSk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5cbi8vIGxhbmd1YWdlPUdMU0xcbnZhciBTSEFERVJfU09VUkNFID0gLypnbHNsKi9cIlxcbnByZWNpc2lvbiBoaWdocCBmbG9hdDtcXG5cXG52YXJ5aW5nIHZlYzQgdl9jb2xvcjtcXG52YXJ5aW5nIHZlYzIgdl9kaWZmVmVjdG9yO1xcbnZhcnlpbmcgZmxvYXQgdl9yYWRpdXM7XFxudmFyeWluZyB2ZWM0IHZfdGV4dHVyZTtcXG5cXG51bmlmb3JtIHNhbXBsZXIyRCB1X2F0bGFzO1xcbnVuaWZvcm0gZmxvYXQgdV9jb3JyZWN0aW9uUmF0aW87XFxudW5pZm9ybSBmbG9hdCB1X2NhbWVyYUFuZ2xlO1xcbnVuaWZvcm0gZmxvYXQgdV9wZXJjZW50YWdlUGFkZGluZztcXG51bmlmb3JtIGJvb2wgdV9jb2xvcml6ZUltYWdlcztcXG51bmlmb3JtIGJvb2wgdV9rZWVwV2l0aGluQ2lyY2xlO1xcblxcbmNvbnN0IHZlYzQgdHJhbnNwYXJlbnQgPSB2ZWM0KDAuMCwgMC4wLCAwLjAsIDAuMCk7XFxuXFxuY29uc3QgZmxvYXQgcmFkaXVzID0gMC41O1xcblxcbnZvaWQgbWFpbih2b2lkKSB7XFxuICBmbG9hdCBib3JkZXIgPSAyLjAgKiB1X2NvcnJlY3Rpb25SYXRpbztcXG4gIGZsb2F0IGRpc3QgPSBsZW5ndGgodl9kaWZmVmVjdG9yKTtcXG4gIHZlYzQgY29sb3IgPSBnbF9GcmFnQ29sb3I7XFxuXFxuICBmbG9hdCBjID0gY29zKC11X2NhbWVyYUFuZ2xlKTtcXG4gIGZsb2F0IHMgPSBzaW4oLXVfY2FtZXJhQW5nbGUpO1xcbiAgdmVjMiBkaWZmVmVjdG9yID0gbWF0MihjLCBzLCAtcywgYykgKiAodl9kaWZmVmVjdG9yKTtcXG5cXG4gIC8vIE5vIGFudGlhbGlhc2luZyBmb3IgcGlja2luZyBtb2RlOlxcbiAgI2lmZGVmIFBJQ0tJTkdfTU9ERVxcbiAgYm9yZGVyID0gMC4wO1xcbiAgY29sb3IgPSB2X2NvbG9yO1xcblxcbiAgI2Vsc2VcXG4gIC8vIEZpcnN0IGNhc2U6IE5vIGltYWdlIHRvIGRpc3BsYXlcXG4gIGlmICh2X3RleHR1cmUudyA8PSAwLjApIHtcXG4gICAgaWYgKCF1X2NvbG9yaXplSW1hZ2VzKSB7XFxuICAgICAgY29sb3IgPSB2X2NvbG9yO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBTZWNvbmQgY2FzZTogSW1hZ2UgbG9hZGVkIGludG8gdGhlIHRleHR1cmVcXG4gIGVsc2Uge1xcbiAgICBmbG9hdCBwYWRkaW5nUmF0aW8gPSAxLjAgKyAyLjAgKiB1X3BlcmNlbnRhZ2VQYWRkaW5nO1xcbiAgICBmbG9hdCBjb2VmID0gdV9rZWVwV2l0aGluQ2lyY2xlID8gMS4wIDogXCIuY29uY2F0KE1hdGguU1FSVDIsIFwiO1xcbiAgICB2ZWMyIGNvb3JkaW5hdGVJblRleHR1cmUgPSBkaWZmVmVjdG9yICogdmVjMihwYWRkaW5nUmF0aW8sIC1wYWRkaW5nUmF0aW8pIC8gdl9yYWRpdXMgLyAyLjAgKiBjb2VmICsgdmVjMigwLjUsIDAuNSk7XFxuICAgIHZlYzQgdGV4ZWwgPSB0ZXh0dXJlMkQodV9hdGxhcywgKHZfdGV4dHVyZS54eSArIGNvb3JkaW5hdGVJblRleHR1cmUgKiB2X3RleHR1cmUuencpLCAtMS4wKTtcXG5cXG4gICAgLy8gQ29sb3JpemUgYWxsIHZpc2libGUgaW1hZ2UgcGl4ZWxzOlxcbiAgICBpZiAodV9jb2xvcml6ZUltYWdlcykge1xcbiAgICAgIGNvbG9yID0gbWl4KGdsX0ZyYWdDb2xvciwgdl9jb2xvciwgdGV4ZWwuYSk7XFxuICAgIH1cXG5cXG4gICAgLy8gQ29sb3JpemUgYmFja2dyb3VuZCBwaXhlbHMsIGtlZXAgaW1hZ2UgcGl4ZWwgY29sb3JzOlxcbiAgICBlbHNlIHtcXG4gICAgICBjb2xvciA9IHZlYzQobWl4KHZfY29sb3IsIHRleGVsLCB0ZXhlbC5hKS5yZ2IsIG1heCh0ZXhlbC5hLCB2X2NvbG9yLmEpKTtcXG4gICAgfVxcblxcbiAgICAvLyBFcmFzZSBwaXhlbHMgXFxcImluIHRoZSBwYWRkaW5nXFxcIjpcXG4gICAgaWYgKGFicyhkaWZmVmVjdG9yLngpID4gdl9yYWRpdXMgLyBwYWRkaW5nUmF0aW8gfHwgYWJzKGRpZmZWZWN0b3IueSkgPiB2X3JhZGl1cyAvIHBhZGRpbmdSYXRpbykge1xcbiAgICAgIGNvbG9yID0gdV9jb2xvcml6ZUltYWdlcyA/IGdsX0ZyYWdDb2xvciA6IHZfY29sb3I7XFxuICAgIH1cXG4gIH1cXG4gICNlbmRpZlxcblxcbiAgLy8gQ3JvcCBpbiBhIGNpcmNsZSB3aGVuIHVfa2VlcFdpdGhpbkNpcmNsZSBpcyB0cnV0aHk6XFxuICBpZiAodV9rZWVwV2l0aGluQ2lyY2xlKSB7XFxuICAgIGlmIChkaXN0IDwgdl9yYWRpdXMgLSBib3JkZXIpIHtcXG4gICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcXG4gICAgfSBlbHNlIGlmIChkaXN0IDwgdl9yYWRpdXMpIHtcXG4gICAgICBnbF9GcmFnQ29sb3IgPSBtaXgodHJhbnNwYXJlbnQsIGNvbG9yLCAodl9yYWRpdXMgLSBkaXN0KSAvIGJvcmRlcik7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIENyb3AgaW4gYSBzcXVhcmUgZWxzZTpcXG4gIGVsc2Uge1xcbiAgICBmbG9hdCBzcXVhcmVIYWxmU2l6ZSA9IHZfcmFkaXVzICogXCIpLmNvbmNhdChNYXRoLlNRUlQxXzIgKiBNYXRoLmNvcyhNYXRoLlBJIC8gMTIpLCBcIjtcXG4gICAgaWYgKGFicyhkaWZmVmVjdG9yLngpID4gc3F1YXJlSGFsZlNpemUgfHwgYWJzKGRpZmZWZWN0b3IueSkgPiBzcXVhcmVIYWxmU2l6ZSkge1xcbiAgICAgIGdsX0ZyYWdDb2xvciA9IHRyYW5zcGFyZW50O1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGdsX0ZyYWdDb2xvciA9IGNvbG9yO1xcbiAgICB9XFxuICB9XFxufVxcblwiKTtcbnZhciBGUkFHTUVOVF9TSEFERVJfU09VUkNFID0gU0hBREVSX1NPVVJDRTtcblxuLy8gbGFuZ3VhZ2U9R0xTTFxudmFyIFZFUlRFWF9TSEFERVJfU09VUkNFID0gLypnbHNsKi9cIlxcbmF0dHJpYnV0ZSB2ZWM0IGFfaWQ7XFxuYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcXG5hdHRyaWJ1dGUgdmVjMiBhX3Bvc2l0aW9uO1xcbmF0dHJpYnV0ZSBmbG9hdCBhX3NpemU7XFxuYXR0cmlidXRlIGZsb2F0IGFfYW5nbGU7XFxuYXR0cmlidXRlIHZlYzQgYV90ZXh0dXJlO1xcblxcbnVuaWZvcm0gbWF0MyB1X21hdHJpeDtcXG51bmlmb3JtIGZsb2F0IHVfc2l6ZVJhdGlvO1xcbnVuaWZvcm0gZmxvYXQgdV9jb3JyZWN0aW9uUmF0aW87XFxuXFxudmFyeWluZyB2ZWM0IHZfY29sb3I7XFxudmFyeWluZyB2ZWMyIHZfZGlmZlZlY3RvcjtcXG52YXJ5aW5nIGZsb2F0IHZfcmFkaXVzO1xcbnZhcnlpbmcgdmVjNCB2X3RleHR1cmU7XFxuXFxuY29uc3QgZmxvYXQgYmlhcyA9IDI1NS4wIC8gMjU0LjA7XFxuY29uc3QgZmxvYXQgbWFyZ2luUmF0aW8gPSAxLjA1O1xcblxcbnZvaWQgbWFpbigpIHtcXG4gIGZsb2F0IHNpemUgPSBhX3NpemUgKiB1X2NvcnJlY3Rpb25SYXRpbyAvIHVfc2l6ZVJhdGlvICogNC4wO1xcbiAgdmVjMiBkaWZmVmVjdG9yID0gc2l6ZSAqIHZlYzIoY29zKGFfYW5nbGUpLCBzaW4oYV9hbmdsZSkpO1xcbiAgdmVjMiBwb3NpdGlvbiA9IGFfcG9zaXRpb24gKyBkaWZmVmVjdG9yICogbWFyZ2luUmF0aW87XFxuICBnbF9Qb3NpdGlvbiA9IHZlYzQoXFxuICAgICh1X21hdHJpeCAqIHZlYzMocG9zaXRpb24sIDEpKS54eSxcXG4gICAgMCxcXG4gICAgMVxcbiAgKTtcXG5cXG4gIHZfZGlmZlZlY3RvciA9IGRpZmZWZWN0b3I7XFxuICB2X3JhZGl1cyA9IHNpemUgLyAyLjAgLyBtYXJnaW5SYXRpbztcXG5cXG4gICNpZmRlZiBQSUNLSU5HX01PREVcXG4gIC8vIEZvciBwaWNraW5nIG1vZGUsIHdlIHVzZSB0aGUgSUQgYXMgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfaWQ7XFxuICAjZWxzZVxcbiAgLy8gRm9yIG5vcm1hbCBtb2RlLCB3ZSB1c2UgdGhlIGNvbG9yOlxcbiAgdl9jb2xvciA9IGFfY29sb3I7XFxuXFxuICAvLyBQYXNzIHRoZSB0ZXh0dXJlIGNvb3JkaW5hdGVzOlxcbiAgdl90ZXh0dXJlID0gYV90ZXh0dXJlO1xcbiAgI2VuZGlmXFxuXFxuICB2X2NvbG9yLmEgKj0gYmlhcztcXG59XFxuXCI7XG52YXIgVkVSVEVYX1NIQURFUl9TT1VSQ0UkMSA9IFZFUlRFWF9TSEFERVJfU09VUkNFO1xuXG5mdW5jdGlvbiBfcmVnZW5lcmF0b3JSdW50aW1lKCkge1xuICBfcmVnZW5lcmF0b3JSdW50aW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBlO1xuICB9O1xuICB2YXIgdCxcbiAgICBlID0ge30sXG4gICAgciA9IE9iamVjdC5wcm90b3R5cGUsXG4gICAgbiA9IHIuaGFzT3duUHJvcGVydHksXG4gICAgbyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbiAodCwgZSwgcikge1xuICAgICAgdFtlXSA9IHIudmFsdWU7XG4gICAgfSxcbiAgICBpID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgPyBTeW1ib2wgOiB7fSxcbiAgICBhID0gaS5pdGVyYXRvciB8fCBcIkBAaXRlcmF0b3JcIixcbiAgICBjID0gaS5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCIsXG4gICAgdSA9IGkudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG4gIGZ1bmN0aW9uIGRlZmluZSh0LCBlLCByKSB7XG4gICAgcmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBlLCB7XG4gICAgICB2YWx1ZTogcixcbiAgICAgIGVudW1lcmFibGU6ICEwLFxuICAgICAgY29uZmlndXJhYmxlOiAhMCxcbiAgICAgIHdyaXRhYmxlOiAhMFxuICAgIH0pLCB0W2VdO1xuICB9XG4gIHRyeSB7XG4gICAgZGVmaW5lKHt9LCBcIlwiKTtcbiAgfSBjYXRjaCAodCkge1xuICAgIGRlZmluZSA9IGZ1bmN0aW9uICh0LCBlLCByKSB7XG4gICAgICByZXR1cm4gdFtlXSA9IHI7XG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiB3cmFwKHQsIGUsIHIsIG4pIHtcbiAgICB2YXIgaSA9IGUgJiYgZS5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IgPyBlIDogR2VuZXJhdG9yLFxuICAgICAgYSA9IE9iamVjdC5jcmVhdGUoaS5wcm90b3R5cGUpLFxuICAgICAgYyA9IG5ldyBDb250ZXh0KG4gfHwgW10pO1xuICAgIHJldHVybiBvKGEsIFwiX2ludm9rZVwiLCB7XG4gICAgICB2YWx1ZTogbWFrZUludm9rZU1ldGhvZCh0LCByLCBjKVxuICAgIH0pLCBhO1xuICB9XG4gIGZ1bmN0aW9uIHRyeUNhdGNoKHQsIGUsIHIpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJub3JtYWxcIixcbiAgICAgICAgYXJnOiB0LmNhbGwoZSwgcilcbiAgICAgIH07XG4gICAgfSBjYXRjaCAodCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJ0aHJvd1wiLFxuICAgICAgICBhcmc6IHRcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGUud3JhcCA9IHdyYXA7XG4gIHZhciBoID0gXCJzdXNwZW5kZWRTdGFydFwiLFxuICAgIGwgPSBcInN1c3BlbmRlZFlpZWxkXCIsXG4gICAgZiA9IFwiZXhlY3V0aW5nXCIsXG4gICAgcyA9IFwiY29tcGxldGVkXCIsXG4gICAgeSA9IHt9O1xuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cbiAgdmFyIHAgPSB7fTtcbiAgZGVmaW5lKHAsIGEsIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSk7XG4gIHZhciBkID0gT2JqZWN0LmdldFByb3RvdHlwZU9mLFxuICAgIHYgPSBkICYmIGQoZCh2YWx1ZXMoW10pKSk7XG4gIHYgJiYgdiAhPT0gciAmJiBuLmNhbGwodiwgYSkgJiYgKHAgPSB2KTtcbiAgdmFyIGcgPSBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5wcm90b3R5cGUgPSBHZW5lcmF0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShwKTtcbiAgZnVuY3Rpb24gZGVmaW5lSXRlcmF0b3JNZXRob2RzKHQpIHtcbiAgICBbXCJuZXh0XCIsIFwidGhyb3dcIiwgXCJyZXR1cm5cIl0uZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgZGVmaW5lKHQsIGUsIGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbnZva2UoZSwgdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBBc3luY0l0ZXJhdG9yKHQsIGUpIHtcbiAgICBmdW5jdGlvbiBpbnZva2UociwgbywgaSwgYSkge1xuICAgICAgdmFyIGMgPSB0cnlDYXRjaCh0W3JdLCB0LCBvKTtcbiAgICAgIGlmIChcInRocm93XCIgIT09IGMudHlwZSkge1xuICAgICAgICB2YXIgdSA9IGMuYXJnLFxuICAgICAgICAgIGggPSB1LnZhbHVlO1xuICAgICAgICByZXR1cm4gaCAmJiBcIm9iamVjdFwiID09IHR5cGVvZiBoICYmIG4uY2FsbChoLCBcIl9fYXdhaXRcIikgPyBlLnJlc29sdmUoaC5fX2F3YWl0KS50aGVuKGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB0LCBpLCBhKTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICBpbnZva2UoXCJ0aHJvd1wiLCB0LCBpLCBhKTtcbiAgICAgICAgfSkgOiBlLnJlc29sdmUoaCkudGhlbihmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHUudmFsdWUgPSB0LCBpKHUpO1xuICAgICAgICB9LCBmdW5jdGlvbiAodCkge1xuICAgICAgICAgIHJldHVybiBpbnZva2UoXCJ0aHJvd1wiLCB0LCBpLCBhKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBhKGMuYXJnKTtcbiAgICB9XG4gICAgdmFyIHI7XG4gICAgbyh0aGlzLCBcIl9pbnZva2VcIiwge1xuICAgICAgdmFsdWU6IGZ1bmN0aW9uICh0LCBuKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgZShmdW5jdGlvbiAoZSwgcikge1xuICAgICAgICAgICAgaW52b2tlKHQsIG4sIGUsIHIpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByID0gciA/IHIudGhlbihjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZywgY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcpIDogY2FsbEludm9rZVdpdGhNZXRob2RBbmRBcmcoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBtYWtlSW52b2tlTWV0aG9kKGUsIHIsIG4pIHtcbiAgICB2YXIgbyA9IGg7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpLCBhKSB7XG4gICAgICBpZiAobyA9PT0gZikgdGhyb3cgbmV3IEVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgcnVubmluZ1wiKTtcbiAgICAgIGlmIChvID09PSBzKSB7XG4gICAgICAgIGlmIChcInRocm93XCIgPT09IGkpIHRocm93IGE7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdmFsdWU6IHQsXG4gICAgICAgICAgZG9uZTogITBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZvciAobi5tZXRob2QgPSBpLCBuLmFyZyA9IGE7Oykge1xuICAgICAgICB2YXIgYyA9IG4uZGVsZWdhdGU7XG4gICAgICAgIGlmIChjKSB7XG4gICAgICAgICAgdmFyIHUgPSBtYXliZUludm9rZURlbGVnYXRlKGMsIG4pO1xuICAgICAgICAgIGlmICh1KSB7XG4gICAgICAgICAgICBpZiAodSA9PT0geSkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gdTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFwibmV4dFwiID09PSBuLm1ldGhvZCkgbi5zZW50ID0gbi5fc2VudCA9IG4uYXJnO2Vsc2UgaWYgKFwidGhyb3dcIiA9PT0gbi5tZXRob2QpIHtcbiAgICAgICAgICBpZiAobyA9PT0gaCkgdGhyb3cgbyA9IHMsIG4uYXJnO1xuICAgICAgICAgIG4uZGlzcGF0Y2hFeGNlcHRpb24obi5hcmcpO1xuICAgICAgICB9IGVsc2UgXCJyZXR1cm5cIiA9PT0gbi5tZXRob2QgJiYgbi5hYnJ1cHQoXCJyZXR1cm5cIiwgbi5hcmcpO1xuICAgICAgICBvID0gZjtcbiAgICAgICAgdmFyIHAgPSB0cnlDYXRjaChlLCByLCBuKTtcbiAgICAgICAgaWYgKFwibm9ybWFsXCIgPT09IHAudHlwZSkge1xuICAgICAgICAgIGlmIChvID0gbi5kb25lID8gcyA6IGwsIHAuYXJnID09PSB5KSBjb250aW51ZTtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWU6IHAuYXJnLFxuICAgICAgICAgICAgZG9uZTogbi5kb25lXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBcInRocm93XCIgPT09IHAudHlwZSAmJiAobyA9IHMsIG4ubWV0aG9kID0gXCJ0aHJvd1wiLCBuLmFyZyA9IHAuYXJnKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIG1heWJlSW52b2tlRGVsZWdhdGUoZSwgcikge1xuICAgIHZhciBuID0gci5tZXRob2QsXG4gICAgICBvID0gZS5pdGVyYXRvcltuXTtcbiAgICBpZiAobyA9PT0gdCkgcmV0dXJuIHIuZGVsZWdhdGUgPSBudWxsLCBcInRocm93XCIgPT09IG4gJiYgZS5pdGVyYXRvci5yZXR1cm4gJiYgKHIubWV0aG9kID0gXCJyZXR1cm5cIiwgci5hcmcgPSB0LCBtYXliZUludm9rZURlbGVnYXRlKGUsIHIpLCBcInRocm93XCIgPT09IHIubWV0aG9kKSB8fCBcInJldHVyblwiICE9PSBuICYmIChyLm1ldGhvZCA9IFwidGhyb3dcIiwgci5hcmcgPSBuZXcgVHlwZUVycm9yKFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAnXCIgKyBuICsgXCInIG1ldGhvZFwiKSksIHk7XG4gICAgdmFyIGkgPSB0cnlDYXRjaChvLCBlLml0ZXJhdG9yLCByLmFyZyk7XG4gICAgaWYgKFwidGhyb3dcIiA9PT0gaS50eXBlKSByZXR1cm4gci5tZXRob2QgPSBcInRocm93XCIsIHIuYXJnID0gaS5hcmcsIHIuZGVsZWdhdGUgPSBudWxsLCB5O1xuICAgIHZhciBhID0gaS5hcmc7XG4gICAgcmV0dXJuIGEgPyBhLmRvbmUgPyAocltlLnJlc3VsdE5hbWVdID0gYS52YWx1ZSwgci5uZXh0ID0gZS5uZXh0TG9jLCBcInJldHVyblwiICE9PSByLm1ldGhvZCAmJiAoci5tZXRob2QgPSBcIm5leHRcIiwgci5hcmcgPSB0KSwgci5kZWxlZ2F0ZSA9IG51bGwsIHkpIDogYSA6IChyLm1ldGhvZCA9IFwidGhyb3dcIiwgci5hcmcgPSBuZXcgVHlwZUVycm9yKFwiaXRlcmF0b3IgcmVzdWx0IGlzIG5vdCBhbiBvYmplY3RcIiksIHIuZGVsZWdhdGUgPSBudWxsLCB5KTtcbiAgfVxuICBmdW5jdGlvbiBwdXNoVHJ5RW50cnkodCkge1xuICAgIHZhciBlID0ge1xuICAgICAgdHJ5TG9jOiB0WzBdXG4gICAgfTtcbiAgICAxIGluIHQgJiYgKGUuY2F0Y2hMb2MgPSB0WzFdKSwgMiBpbiB0ICYmIChlLmZpbmFsbHlMb2MgPSB0WzJdLCBlLmFmdGVyTG9jID0gdFszXSksIHRoaXMudHJ5RW50cmllcy5wdXNoKGUpO1xuICB9XG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkodCkge1xuICAgIHZhciBlID0gdC5jb21wbGV0aW9uIHx8IHt9O1xuICAgIGUudHlwZSA9IFwibm9ybWFsXCIsIGRlbGV0ZSBlLmFyZywgdC5jb21wbGV0aW9uID0gZTtcbiAgfVxuICBmdW5jdGlvbiBDb250ZXh0KHQpIHtcbiAgICB0aGlzLnRyeUVudHJpZXMgPSBbe1xuICAgICAgdHJ5TG9jOiBcInJvb3RcIlxuICAgIH1dLCB0LmZvckVhY2gocHVzaFRyeUVudHJ5LCB0aGlzKSwgdGhpcy5yZXNldCghMCk7XG4gIH1cbiAgZnVuY3Rpb24gdmFsdWVzKGUpIHtcbiAgICBpZiAoZSB8fCBcIlwiID09PSBlKSB7XG4gICAgICB2YXIgciA9IGVbYV07XG4gICAgICBpZiAocikgcmV0dXJuIHIuY2FsbChlKTtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGUubmV4dCkgcmV0dXJuIGU7XG4gICAgICBpZiAoIWlzTmFOKGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgbyA9IC0xLFxuICAgICAgICAgIGkgPSBmdW5jdGlvbiBuZXh0KCkge1xuICAgICAgICAgICAgZm9yICg7ICsrbyA8IGUubGVuZ3RoOykgaWYgKG4uY2FsbChlLCBvKSkgcmV0dXJuIG5leHQudmFsdWUgPSBlW29dLCBuZXh0LmRvbmUgPSAhMSwgbmV4dDtcbiAgICAgICAgICAgIHJldHVybiBuZXh0LnZhbHVlID0gdCwgbmV4dC5kb25lID0gITAsIG5leHQ7XG4gICAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGkubmV4dCA9IGk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IodHlwZW9mIGUgKyBcIiBpcyBub3QgaXRlcmFibGVcIik7XG4gIH1cbiAgcmV0dXJuIEdlbmVyYXRvckZ1bmN0aW9uLnByb3RvdHlwZSA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBvKGcsIFwiY29uc3RydWN0b3JcIiwge1xuICAgIHZhbHVlOiBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICBjb25maWd1cmFibGU6ICEwXG4gIH0pLCBvKEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLCBcImNvbnN0cnVjdG9yXCIsIHtcbiAgICB2YWx1ZTogR2VuZXJhdG9yRnVuY3Rpb24sXG4gICAgY29uZmlndXJhYmxlOiAhMFxuICB9KSwgR2VuZXJhdG9yRnVuY3Rpb24uZGlzcGxheU5hbWUgPSBkZWZpbmUoR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIHUsIFwiR2VuZXJhdG9yRnVuY3Rpb25cIiksIGUuaXNHZW5lcmF0b3JGdW5jdGlvbiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIGUgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHQgJiYgdC5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gISFlICYmIChlID09PSBHZW5lcmF0b3JGdW5jdGlvbiB8fCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIgPT09IChlLmRpc3BsYXlOYW1lIHx8IGUubmFtZSkpO1xuICB9LCBlLm1hcmsgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YodCwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpIDogKHQuX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUsIGRlZmluZSh0LCB1LCBcIkdlbmVyYXRvckZ1bmN0aW9uXCIpKSwgdC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKGcpLCB0O1xuICB9LCBlLmF3cmFwID0gZnVuY3Rpb24gKHQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgX19hd2FpdDogdFxuICAgIH07XG4gIH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSksIGRlZmluZShBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSwgYywgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgZS5Bc3luY0l0ZXJhdG9yID0gQXN5bmNJdGVyYXRvciwgZS5hc3luYyA9IGZ1bmN0aW9uICh0LCByLCBuLCBvLCBpKSB7XG4gICAgdm9pZCAwID09PSBpICYmIChpID0gUHJvbWlzZSk7XG4gICAgdmFyIGEgPSBuZXcgQXN5bmNJdGVyYXRvcih3cmFwKHQsIHIsIG4sIG8pLCBpKTtcbiAgICByZXR1cm4gZS5pc0dlbmVyYXRvckZ1bmN0aW9uKHIpID8gYSA6IGEubmV4dCgpLnRoZW4oZnVuY3Rpb24gKHQpIHtcbiAgICAgIHJldHVybiB0LmRvbmUgPyB0LnZhbHVlIDogYS5uZXh0KCk7XG4gICAgfSk7XG4gIH0sIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhnKSwgZGVmaW5lKGcsIHUsIFwiR2VuZXJhdG9yXCIpLCBkZWZpbmUoZywgYSwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9KSwgZGVmaW5lKGcsIFwidG9TdHJpbmdcIiwgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBcIltvYmplY3QgR2VuZXJhdG9yXVwiO1xuICB9KSwgZS5rZXlzID0gZnVuY3Rpb24gKHQpIHtcbiAgICB2YXIgZSA9IE9iamVjdCh0KSxcbiAgICAgIHIgPSBbXTtcbiAgICBmb3IgKHZhciBuIGluIGUpIHIucHVzaChuKTtcbiAgICByZXR1cm4gci5yZXZlcnNlKCksIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgICBmb3IgKDsgci5sZW5ndGg7KSB7XG4gICAgICAgIHZhciB0ID0gci5wb3AoKTtcbiAgICAgICAgaWYgKHQgaW4gZSkgcmV0dXJuIG5leHQudmFsdWUgPSB0LCBuZXh0LmRvbmUgPSAhMSwgbmV4dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBuZXh0LmRvbmUgPSAhMCwgbmV4dDtcbiAgICB9O1xuICB9LCBlLnZhbHVlcyA9IHZhbHVlcywgQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENvbnRleHQsXG4gICAgcmVzZXQ6IGZ1bmN0aW9uIChlKSB7XG4gICAgICBpZiAodGhpcy5wcmV2ID0gMCwgdGhpcy5uZXh0ID0gMCwgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHQsIHRoaXMuZG9uZSA9ICExLCB0aGlzLmRlbGVnYXRlID0gbnVsbCwgdGhpcy5tZXRob2QgPSBcIm5leHRcIiwgdGhpcy5hcmcgPSB0LCB0aGlzLnRyeUVudHJpZXMuZm9yRWFjaChyZXNldFRyeUVudHJ5KSwgIWUpIGZvciAodmFyIHIgaW4gdGhpcykgXCJ0XCIgPT09IHIuY2hhckF0KDApICYmIG4uY2FsbCh0aGlzLCByKSAmJiAhaXNOYU4oK3Iuc2xpY2UoMSkpICYmICh0aGlzW3JdID0gdCk7XG4gICAgfSxcbiAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLmRvbmUgPSAhMDtcbiAgICAgIHZhciB0ID0gdGhpcy50cnlFbnRyaWVzWzBdLmNvbXBsZXRpb247XG4gICAgICBpZiAoXCJ0aHJvd1wiID09PSB0LnR5cGUpIHRocm93IHQuYXJnO1xuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuICAgIGRpc3BhdGNoRXhjZXB0aW9uOiBmdW5jdGlvbiAoZSkge1xuICAgICAgaWYgKHRoaXMuZG9uZSkgdGhyb3cgZTtcbiAgICAgIHZhciByID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShuLCBvKSB7XG4gICAgICAgIHJldHVybiBhLnR5cGUgPSBcInRocm93XCIsIGEuYXJnID0gZSwgci5uZXh0ID0gbiwgbyAmJiAoci5tZXRob2QgPSBcIm5leHRcIiwgci5hcmcgPSB0KSwgISFvO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgbyA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBvID49IDA7IC0tbykge1xuICAgICAgICB2YXIgaSA9IHRoaXMudHJ5RW50cmllc1tvXSxcbiAgICAgICAgICBhID0gaS5jb21wbGV0aW9uO1xuICAgICAgICBpZiAoXCJyb290XCIgPT09IGkudHJ5TG9jKSByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICBpZiAoaS50cnlMb2MgPD0gdGhpcy5wcmV2KSB7XG4gICAgICAgICAgdmFyIGMgPSBuLmNhbGwoaSwgXCJjYXRjaExvY1wiKSxcbiAgICAgICAgICAgIHUgPSBuLmNhbGwoaSwgXCJmaW5hbGx5TG9jXCIpO1xuICAgICAgICAgIGlmIChjICYmIHUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBpLmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGkuY2F0Y2hMb2MsICEwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBpLmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoaS5maW5hbGx5TG9jKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBpLmNhdGNoTG9jKSByZXR1cm4gaGFuZGxlKGkuY2F0Y2hMb2MsICEwKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKCF1KSB0aHJvdyBuZXcgRXJyb3IoXCJ0cnkgc3RhdGVtZW50IHdpdGhvdXQgY2F0Y2ggb3IgZmluYWxseVwiKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBpLmZpbmFsbHlMb2MpIHJldHVybiBoYW5kbGUoaS5maW5hbGx5TG9jKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFicnVwdDogZnVuY3Rpb24gKHQsIGUpIHtcbiAgICAgIGZvciAodmFyIHIgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgciA+PSAwOyAtLXIpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLnRyeUVudHJpZXNbcl07XG4gICAgICAgIGlmIChvLnRyeUxvYyA8PSB0aGlzLnByZXYgJiYgbi5jYWxsKG8sIFwiZmluYWxseUxvY1wiKSAmJiB0aGlzLnByZXYgPCBvLmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgaSA9IG87XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGkgJiYgKFwiYnJlYWtcIiA9PT0gdCB8fCBcImNvbnRpbnVlXCIgPT09IHQpICYmIGkudHJ5TG9jIDw9IGUgJiYgZSA8PSBpLmZpbmFsbHlMb2MgJiYgKGkgPSBudWxsKTtcbiAgICAgIHZhciBhID0gaSA/IGkuY29tcGxldGlvbiA6IHt9O1xuICAgICAgcmV0dXJuIGEudHlwZSA9IHQsIGEuYXJnID0gZSwgaSA/ICh0aGlzLm1ldGhvZCA9IFwibmV4dFwiLCB0aGlzLm5leHQgPSBpLmZpbmFsbHlMb2MsIHkpIDogdGhpcy5jb21wbGV0ZShhKTtcbiAgICB9LFxuICAgIGNvbXBsZXRlOiBmdW5jdGlvbiAodCwgZSkge1xuICAgICAgaWYgKFwidGhyb3dcIiA9PT0gdC50eXBlKSB0aHJvdyB0LmFyZztcbiAgICAgIHJldHVybiBcImJyZWFrXCIgPT09IHQudHlwZSB8fCBcImNvbnRpbnVlXCIgPT09IHQudHlwZSA/IHRoaXMubmV4dCA9IHQuYXJnIDogXCJyZXR1cm5cIiA9PT0gdC50eXBlID8gKHRoaXMucnZhbCA9IHRoaXMuYXJnID0gdC5hcmcsIHRoaXMubWV0aG9kID0gXCJyZXR1cm5cIiwgdGhpcy5uZXh0ID0gXCJlbmRcIikgOiBcIm5vcm1hbFwiID09PSB0LnR5cGUgJiYgZSAmJiAodGhpcy5uZXh0ID0gZSksIHk7XG4gICAgfSxcbiAgICBmaW5pc2g6IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGUgPj0gMDsgLS1lKSB7XG4gICAgICAgIHZhciByID0gdGhpcy50cnlFbnRyaWVzW2VdO1xuICAgICAgICBpZiAoci5maW5hbGx5TG9jID09PSB0KSByZXR1cm4gdGhpcy5jb21wbGV0ZShyLmNvbXBsZXRpb24sIHIuYWZ0ZXJMb2MpLCByZXNldFRyeUVudHJ5KHIpLCB5O1xuICAgICAgfVxuICAgIH0sXG4gICAgY2F0Y2g6IGZ1bmN0aW9uICh0KSB7XG4gICAgICBmb3IgKHZhciBlID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGUgPj0gMDsgLS1lKSB7XG4gICAgICAgIHZhciByID0gdGhpcy50cnlFbnRyaWVzW2VdO1xuICAgICAgICBpZiAoci50cnlMb2MgPT09IHQpIHtcbiAgICAgICAgICB2YXIgbiA9IHIuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAoXCJ0aHJvd1wiID09PSBuLnR5cGUpIHtcbiAgICAgICAgICAgIHZhciBvID0gbi5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KHIpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCBjYXRjaCBhdHRlbXB0XCIpO1xuICAgIH0sXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24gKGUsIHIsIG4pIHtcbiAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlID0ge1xuICAgICAgICBpdGVyYXRvcjogdmFsdWVzKGUpLFxuICAgICAgICByZXN1bHROYW1lOiByLFxuICAgICAgICBuZXh0TG9jOiBuXG4gICAgICB9LCBcIm5leHRcIiA9PT0gdGhpcy5tZXRob2QgJiYgKHRoaXMuYXJnID0gdCksIHk7XG4gICAgfVxuICB9LCBlO1xufVxuXG5mdW5jdGlvbiBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIGtleSwgYXJnKSB7XG4gIHRyeSB7XG4gICAgdmFyIGluZm8gPSBnZW5ba2V5XShhcmcpO1xuICAgIHZhciB2YWx1ZSA9IGluZm8udmFsdWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmVqZWN0KGVycm9yKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuZnVuY3Rpb24gX2FzeW5jVG9HZW5lcmF0b3IoZm4pIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsXG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZ2VuID0gZm4uYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBfdGhyb3coZXJyKSB7XG4gICAgICAgIGFzeW5jR2VuZXJhdG9yU3RlcChnZW4sIHJlc29sdmUsIHJlamVjdCwgX25leHQsIF90aHJvdywgXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuICAgICAgX25leHQodW5kZWZpbmVkKTtcbiAgICB9KTtcbiAgfTtcbn1cblxuLyoqXG4gKiBVc2VmdWwgdHlwZXM6XG4gKiAqKioqKioqKioqKioqXG4gKi9cblxudmFyIERFRkFVTFRfVEVYVFVSRV9NQU5BR0VSX09QVElPTlMgPSB7XG4gIHNpemU6IHtcbiAgICBtb2RlOiBcIm1heFwiLFxuICAgIHZhbHVlOiA1MTJcbiAgfSxcbiAgb2JqZWN0Rml0OiBcImNvdmVyXCIsXG4gIGNvcnJlY3RDZW50ZXJpbmc6IGZhbHNlXG59O1xudmFyIERFQk9VTkNFX1RJTUVPVVQgPSAxMDA7XG5cbi8vIFRoaXMgbWFyZ2luIGhlbHBzIGF2b2lkaW5nIGltYWdlcyBjb2xsaXNpb25zIGluIHRoZSB0ZXh0dXJlOlxudmFyIE1BUkdJTl9JTl9URVhUVVJFID0gMTtcblxuLyoqXG4gKiBIZWxwZXJzOlxuICogKioqKioqKipcbiAqL1xuLyoqXG4gKiBUaGlzIGhlbHBlciBsb2FkcyBhbiBpbWFnZSBhdCBhIGdpdmVuIFVSTCwgYW5kIHJldHVybnMgYW4gSFRNTEltYWdlRWxlbWVudFxuICogd2l0aCBpdCBkaXNwbGF5ZWQgb25jZSBpdCdzIHByb3Blcmx5IGxvYWRlZCwgd2l0aGluIGEgcHJvbWlzZS5cbiAqL1xuZnVuY3Rpb24gbG9hZFJhc3RlckltYWdlKGltYWdlU291cmNlKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgdmFyIGltYWdlID0gbmV3IEltYWdlKCk7XG4gICAgaW1hZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgcmVzb2x2ZShpbWFnZSk7XG4gICAgfSwge1xuICAgICAgb25jZTogdHJ1ZVxuICAgIH0pO1xuICAgIGltYWdlLmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBmdW5jdGlvbiAoZSkge1xuICAgICAgcmVqZWN0KGUuZXJyb3IpO1xuICAgIH0sIHtcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcblxuICAgIC8vIExvYWQgaW1hZ2U6XG4gICAgaW1hZ2Uuc2V0QXR0cmlidXRlKFwiY3Jvc3NPcmlnaW5cIiwgXCJcIik7XG4gICAgaW1hZ2Uuc3JjID0gaW1hZ2VTb3VyY2U7XG4gIH0pO1xufVxuXG4vKipcbiAqIFRoaXMgaGVscGVyIGxvYWRzIGFuIFNWRyBpbWFnZSBhdCBhIGdpdmVuIFVSTCwgYWRqdXN0cyBpdHMgc2l6ZSB0byBhIGdpdmVuXG4gKiBzaXplLCBhbmQgcmV0dXJucyBhbiBIVE1MSW1hZ2VFbGVtZW50IHdpdGggaXQgZGlzcGxheWVkIG9uY2UgaXQncyBwcm9wZXJseVxuICogbG9hZGVkLCB3aXRoaW4gYSBwcm9taXNlLlxuICovXG5mdW5jdGlvbiBsb2FkU1ZHSW1hZ2UoX3gpIHtcbiAgcmV0dXJuIF9sb2FkU1ZHSW1hZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBUaGlzIGhlbHBlciBsb2FkcyBhbiBpbWFnZSB1c2luZyB0aGUgcHJvcGVyIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBfbG9hZFNWR0ltYWdlKCkge1xuICBfbG9hZFNWR0ltYWdlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMihpbWFnZVNvdXJjZSkge1xuICAgIHZhciBfcmVmLFxuICAgICAgc2l6ZSxcbiAgICAgIHJlc3AsXG4gICAgICBzdmdTdHJpbmcsXG4gICAgICBzdmcsXG4gICAgICByb290LFxuICAgICAgb3JpZ2luYWxXaWR0aCxcbiAgICAgIG9yaWdpbmFsSGVpZ2h0LFxuICAgICAgY29ycmVjdGVkU3ZnU3RyaW5nLFxuICAgICAgYmxvYixcbiAgICAgIHVybCxcbiAgICAgIHJlcyxcbiAgICAgIF9hcmdzMiA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gX3JlZ2VuZXJhdG9yUnVudGltZSgpLndyYXAoZnVuY3Rpb24gX2NhbGxlZTIkKF9jb250ZXh0Mikge1xuICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQyLnByZXYgPSBfY29udGV4dDIubmV4dCkge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgX3JlZiA9IF9hcmdzMi5sZW5ndGggPiAxICYmIF9hcmdzMlsxXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3MyWzFdIDoge30sIHNpemUgPSBfcmVmLnNpemU7XG4gICAgICAgICAgX2NvbnRleHQyLm5leHQgPSAzO1xuICAgICAgICAgIHJldHVybiBmZXRjaChpbWFnZVNvdXJjZSk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICByZXNwID0gX2NvbnRleHQyLnNlbnQ7XG4gICAgICAgICAgX2NvbnRleHQyLm5leHQgPSA2O1xuICAgICAgICAgIHJldHVybiByZXNwLnRleHQoKTtcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHN2Z1N0cmluZyA9IF9jb250ZXh0Mi5zZW50O1xuICAgICAgICAgIHN2ZyA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoc3ZnU3RyaW5nLCBcImltYWdlL3N2Zyt4bWxcIik7XG4gICAgICAgICAgcm9vdCA9IHN2Zy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgICAgb3JpZ2luYWxXaWR0aCA9IHJvb3QuZ2V0QXR0cmlidXRlKFwid2lkdGhcIik7XG4gICAgICAgICAgb3JpZ2luYWxIZWlnaHQgPSByb290LmdldEF0dHJpYnV0ZShcImhlaWdodFwiKTtcbiAgICAgICAgICBpZiAoISghb3JpZ2luYWxXaWR0aCB8fCAhb3JpZ2luYWxIZWlnaHQpKSB7XG4gICAgICAgICAgICBfY29udGV4dDIubmV4dCA9IDEzO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImxvYWRTVkdJbWFnZTogY2Fubm90IHVzZSBgc2l6ZWAgaWYgdGFyZ2V0IFNWRyBoYXMgbm8gZGVmaW5pdGUgZGltZW5zaW9ucy5cIik7XG4gICAgICAgIGNhc2UgMTM6XG4gICAgICAgICAgaWYgKHR5cGVvZiBzaXplID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByb290LnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIFwiXCIgKyBzaXplKTtcbiAgICAgICAgICAgIHJvb3Quc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIFwiXCIgKyBzaXplKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBOT1RFOiBzaW5jZSBHb29nbGUgTWF0ZXJpYWwgbGFzdCBjaGFuZ2VzIHRvIHRoZWlyIGljb24gdmlld0JveCwgdGhpc1xuICAgICAgICAgIC8vIGNvZGUgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSAoaG9wZWZ1bGx5IGl0IGRvZXMgbm90IGJyZWFrIHNvbWV0aGluZyBlbHNlLi4uKVxuICAgICAgICAgIC8vIHJvb3Quc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCBgMCAwICR7b3JpZ2luYWxXaWR0aH0gJHtvcmlnaW5hbEhlaWdodH1gKTtcbiAgICAgICAgICBjb3JyZWN0ZWRTdmdTdHJpbmcgPSBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHN2Zyk7XG4gICAgICAgICAgYmxvYiA9IG5ldyBCbG9iKFtjb3JyZWN0ZWRTdmdTdHJpbmddLCB7XG4gICAgICAgICAgICB0eXBlOiBcImltYWdlL3N2Zyt4bWxcIlxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHVybCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgICAgcmVzID0gbG9hZFJhc3RlckltYWdlKHVybCk7XG4gICAgICAgICAgcmVzW1wiZmluYWxseVwiXShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gVVJMLnJldm9rZU9iamVjdFVSTCh1cmwpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybiBfY29udGV4dDIuYWJydXB0KFwicmV0dXJuXCIsIHJlcyk7XG4gICAgICAgIGNhc2UgMjA6XG4gICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICByZXR1cm4gX2NvbnRleHQyLnN0b3AoKTtcbiAgICAgIH1cbiAgICB9LCBfY2FsbGVlMik7XG4gIH0pKTtcbiAgcmV0dXJuIF9sb2FkU1ZHSW1hZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIGxvYWRJbWFnZShfeDIpIHtcbiAgcmV0dXJuIF9sb2FkSW1hZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuLyoqXG4gKiBUaGlzIGhlbHBlciBjb21wdXRlcyBleGFjdCBjb29yZGluYXRlcyB0byBkcmF3IGFuIGltYWdlIG9udG8gYSB0ZXh0dXJlLlxuICovXG5mdW5jdGlvbiBfbG9hZEltYWdlKCkge1xuICBfbG9hZEltYWdlID0gX2FzeW5jVG9HZW5lcmF0b3IoIC8qI19fUFVSRV9fKi9fcmVnZW5lcmF0b3JSdW50aW1lKCkubWFyayhmdW5jdGlvbiBfY2FsbGVlMyhpbWFnZVNvdXJjZSkge1xuICAgIHZhciBfaW1hZ2VTb3VyY2Ukc3BsaXQkMCQ7XG4gICAgdmFyIF9yZWYyLFxuICAgICAgc2l6ZSxcbiAgICAgIGlzU1ZHLFxuICAgICAgaW1hZ2UsXG4gICAgICBfYXJnczMgPSBhcmd1bWVudHM7XG4gICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUzJChfY29udGV4dDMpIHtcbiAgICAgIHdoaWxlICgxKSBzd2l0Y2ggKF9jb250ZXh0My5wcmV2ID0gX2NvbnRleHQzLm5leHQpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIF9yZWYyID0gX2FyZ3MzLmxlbmd0aCA+IDEgJiYgX2FyZ3MzWzFdICE9PSB1bmRlZmluZWQgPyBfYXJnczNbMV0gOiB7fSwgc2l6ZSA9IF9yZWYyLnNpemU7XG4gICAgICAgICAgaXNTVkcgPSAoKF9pbWFnZVNvdXJjZSRzcGxpdCQwJCA9IGltYWdlU291cmNlLnNwbGl0KC9bIz9dLylbMF0uc3BsaXQoXCIuXCIpLnBvcCgpKSA9PT0gbnVsbCB8fCBfaW1hZ2VTb3VyY2Ukc3BsaXQkMCQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9pbWFnZVNvdXJjZSRzcGxpdCQwJC50cmltKCkudG9Mb3dlckNhc2UoKSkgPT09IFwic3ZnXCI7XG4gICAgICAgICAgaWYgKCEoaXNTVkcgJiYgc2l6ZSkpIHtcbiAgICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgX2NvbnRleHQzLnByZXYgPSAzO1xuICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gNjtcbiAgICAgICAgICByZXR1cm4gbG9hZFNWR0ltYWdlKGltYWdlU291cmNlLCB7XG4gICAgICAgICAgICBzaXplOiBzaXplXG4gICAgICAgICAgfSk7XG4gICAgICAgIGNhc2UgNjpcbiAgICAgICAgICBpbWFnZSA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgOTpcbiAgICAgICAgICBfY29udGV4dDMucHJldiA9IDk7XG4gICAgICAgICAgX2NvbnRleHQzLnQwID0gX2NvbnRleHQzW1wiY2F0Y2hcIl0oMyk7XG4gICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxMztcbiAgICAgICAgICByZXR1cm4gbG9hZFJhc3RlckltYWdlKGltYWdlU291cmNlKTtcbiAgICAgICAgY2FzZSAxMzpcbiAgICAgICAgICBpbWFnZSA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICBjYXNlIDE0OlxuICAgICAgICAgIF9jb250ZXh0My5uZXh0ID0gMTk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTY6XG4gICAgICAgICAgX2NvbnRleHQzLm5leHQgPSAxODtcbiAgICAgICAgICByZXR1cm4gbG9hZFJhc3RlckltYWdlKGltYWdlU291cmNlKTtcbiAgICAgICAgY2FzZSAxODpcbiAgICAgICAgICBpbWFnZSA9IF9jb250ZXh0My5zZW50O1xuICAgICAgICBjYXNlIDE5OlxuICAgICAgICAgIHJldHVybiBfY29udGV4dDMuYWJydXB0KFwicmV0dXJuXCIsIGltYWdlKTtcbiAgICAgICAgY2FzZSAyMDpcbiAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgIHJldHVybiBfY29udGV4dDMuc3RvcCgpO1xuICAgICAgfVxuICAgIH0sIF9jYWxsZWUzLCBudWxsLCBbWzMsIDldXSk7XG4gIH0pKTtcbiAgcmV0dXJuIF9sb2FkSW1hZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cbmZ1bmN0aW9uIHJlZmluZUltYWdlKGltYWdlLCBjb3JyZWN0b3IsIF9yZWYzKSB7XG4gIHZhciBvYmplY3RGaXQgPSBfcmVmMy5vYmplY3RGaXQsXG4gICAgc2l6ZSA9IF9yZWYzLnNpemUsXG4gICAgY29ycmVjdENlbnRlcmluZyA9IF9yZWYzLmNvcnJlY3RDZW50ZXJpbmc7XG4gIHZhciBzb3VyY2VTaXplID0gb2JqZWN0Rml0ID09PSBcImNvbnRhaW5cIiA/IE1hdGgubWF4KGltYWdlLndpZHRoLCBpbWFnZS5oZWlnaHQpIDogTWF0aC5taW4oaW1hZ2Uud2lkdGgsIGltYWdlLmhlaWdodCk7XG4gIHZhciBkZXN0aW5hdGlvblNpemUgPSBzaXplLm1vZGUgPT09IFwiYXV0b1wiID8gc291cmNlU2l6ZSA6IHNpemUubW9kZSA9PT0gXCJmb3JjZVwiID8gc2l6ZS52YWx1ZSA6IE1hdGgubWluKHNpemUudmFsdWUsIHNvdXJjZVNpemUpO1xuICB2YXIgc291cmNlWCA9IChpbWFnZS53aWR0aCAtIHNvdXJjZVNpemUpIC8gMjtcbiAgdmFyIHNvdXJjZVkgPSAoaW1hZ2UuaGVpZ2h0IC0gc291cmNlU2l6ZSkgLyAyO1xuICBpZiAoY29ycmVjdENlbnRlcmluZykge1xuICAgIHZhciBjb3JyZWN0aW9uID0gY29ycmVjdG9yLmdldENvcnJlY3Rpb25PZmZzZXQoaW1hZ2UsIHNvdXJjZVNpemUpO1xuICAgIHNvdXJjZVggPSBjb3JyZWN0aW9uLng7XG4gICAgc291cmNlWSA9IGNvcnJlY3Rpb24ueTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHNvdXJjZVg6IHNvdXJjZVgsXG4gICAgc291cmNlWTogc291cmNlWSxcbiAgICBzb3VyY2VTaXplOiBzb3VyY2VTaXplLFxuICAgIGRlc3RpbmF0aW9uU2l6ZTogZGVzdGluYXRpb25TaXplXG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBoZWxwZXIgdGFrZXMgYSBjb2xsZWN0aW9uIG9mIGltYWdlIHN0YXRlcyBhbmQgYSBjb250ZXh0LCBkcmF3IGFsbCB0aGVcbiAqIGltYWdlcyBpbiB0aGUgY29udGV4dCwgYW5kIHJldHVybnMgYW4gYXRsYXMgdG8gZ2V0IHdoZXJlIGVhY2ggaW1hZ2UgaXMgZHJhd25cbiAqIG9uIHRoZSB0ZXh0dXJlLlxuICovXG5mdW5jdGlvbiBkcmF3VGV4dHVyZShjdHgsIGltYWdlcykge1xuICB2YXIgTUFYX0NBTlZBU19XSURUSCA9IDMwNzI7XG4gIHZhciBUQVJHRVRfRklMTF9QRVJDRU5UQUdFID0gMC42O1xuXG4gIC8vIDEuIFNvcnQgaW1hZ2VzIGJ5IGhlaWdodCwgZGVjcmVhc2luZ2x5OlxuICB2YXIgaW1hZ2VzQXJyYXkgPSBbXTtcbiAgdmFyIHRvdGFsQXJlYSA9IDA7XG4gIHZhciBtYXhJdGVtV2lkdGggPSAwO1xuICBmb3IgKHZhciBrZXkgaW4gaW1hZ2VzKSB7XG4gICAgdmFyIGltYWdlU3RhdGUgPSBpbWFnZXNba2V5XTtcbiAgICBpZiAoaW1hZ2VTdGF0ZS5zdGF0dXMgIT09IFwicmVhZHlcIikgY29udGludWU7XG4gICAgbWF4SXRlbVdpZHRoID0gTWF0aC5tYXgobWF4SXRlbVdpZHRoLCBpbWFnZVN0YXRlLmRlc3RpbmF0aW9uU2l6ZSk7XG4gICAgdG90YWxBcmVhICs9IE1hdGgucG93KGltYWdlU3RhdGUuZGVzdGluYXRpb25TaXplLCAyKTtcbiAgICBpbWFnZXNBcnJheS5wdXNoKF9vYmplY3RTcHJlYWQyKHtcbiAgICAgIGtleToga2V5XG4gICAgfSwgaW1hZ2VTdGF0ZSkpO1xuICB9XG4gIGltYWdlc0FycmF5LnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYS5kZXN0aW5hdGlvblNpemUgPiBiLmRlc3RpbmF0aW9uU2l6ZSA/IC0xIDogMTtcbiAgfSk7XG5cbiAgLy8gMi4gUHJlZGljdCBjYW52YXMgd2lkdGg6XG4gIHZhciBwcmVkaWN0ZWRUb3RhbEFyZWEgPSB0b3RhbEFyZWEgLyBUQVJHRVRfRklMTF9QRVJDRU5UQUdFO1xuICB2YXIgcHJlZGljdGVkV2lkdGggPSBNYXRoLm1pbihNYXRoLm1heChNYXRoLnNxcnQocHJlZGljdGVkVG90YWxBcmVhKSwgbWF4SXRlbVdpZHRoKSwgTUFYX0NBTlZBU19XSURUSCk7XG5cbiAgLy8gMy4gUmVmaW5lIGltYWdlcyBjb29yZGluYXRlczpcbiAgdmFyIHJlZmluZWRJbWFnZXNBcnJheSA9IFtdO1xuICB2YXIgeCA9IDA7XG4gIHZhciB5ID0gMDtcbiAgdmFyIGN1cnJlbnRSb3dIZWlnaHQgPSAwO1xuICB2YXIgbWF4Um93V2lkdGggPSAwO1xuICB2YXIgYXRsYXMgPSB7fTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBpbWFnZXNBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICB2YXIgX2ltYWdlc0FycmF5JGkgPSBpbWFnZXNBcnJheVtpXSxcbiAgICAgIF9rZXkgPSBfaW1hZ2VzQXJyYXkkaS5rZXksXG4gICAgICBpbWFnZSA9IF9pbWFnZXNBcnJheSRpLmltYWdlLFxuICAgICAgc291cmNlU2l6ZSA9IF9pbWFnZXNBcnJheSRpLnNvdXJjZVNpemUsXG4gICAgICBzb3VyY2VYID0gX2ltYWdlc0FycmF5JGkuc291cmNlWCxcbiAgICAgIHNvdXJjZVkgPSBfaW1hZ2VzQXJyYXkkaS5zb3VyY2VZLFxuICAgICAgZGVzdGluYXRpb25TaXplID0gX2ltYWdlc0FycmF5JGkuZGVzdGluYXRpb25TaXplO1xuICAgIHZhciBkZXN0aW5hdGlvblNpemVXaXRoTWFyZ2luID0gZGVzdGluYXRpb25TaXplICsgTUFSR0lOX0lOX1RFWFRVUkU7XG4gICAgaWYgKHggKyBkZXN0aW5hdGlvblNpemVXaXRoTWFyZ2luID4gcHJlZGljdGVkV2lkdGgpIHtcbiAgICAgIG1heFJvd1dpZHRoID0gTWF0aC5tYXgobWF4Um93V2lkdGgsIHgpO1xuICAgICAgeCA9IDA7XG4gICAgICB5ICs9IGN1cnJlbnRSb3dIZWlnaHQ7XG4gICAgICBjdXJyZW50Um93SGVpZ2h0ID0gZGVzdGluYXRpb25TaXplV2l0aE1hcmdpbjtcbiAgICB9XG4gICAgcmVmaW5lZEltYWdlc0FycmF5LnB1c2goe1xuICAgICAga2V5OiBfa2V5LFxuICAgICAgaW1hZ2U6IGltYWdlLFxuICAgICAgc291cmNlWDogc291cmNlWCxcbiAgICAgIHNvdXJjZVk6IHNvdXJjZVksXG4gICAgICBzb3VyY2VTaXplOiBzb3VyY2VTaXplLFxuICAgICAgZGVzdGluYXRpb25YOiB4LFxuICAgICAgZGVzdGluYXRpb25ZOiB5LFxuICAgICAgZGVzdGluYXRpb25TaXplOiBkZXN0aW5hdGlvblNpemVcbiAgICB9KTtcbiAgICBhdGxhc1tfa2V5XSA9IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5LFxuICAgICAgc2l6ZTogZGVzdGluYXRpb25TaXplXG4gICAgfTtcbiAgICB4ICs9IGRlc3RpbmF0aW9uU2l6ZVdpdGhNYXJnaW47XG4gICAgY3VycmVudFJvd0hlaWdodCA9IE1hdGgubWF4KGN1cnJlbnRSb3dIZWlnaHQsIGRlc3RpbmF0aW9uU2l6ZVdpdGhNYXJnaW4pO1xuICB9XG5cbiAgLy8gNC4gQ3JvcCB0ZXh0dXJlIHRvIGZpbmFsIGJlc3QgZGltZW5zaW9uczpcbiAgbWF4Um93V2lkdGggPSBNYXRoLm1heChtYXhSb3dXaWR0aCwgeCk7XG4gIHZhciBjYW52YXMgPSBjdHguY2FudmFzO1xuICBjYW52YXMud2lkdGggPSBtYXhSb3dXaWR0aDtcbiAgY2FudmFzLmhlaWdodCA9IHkgKyBjdXJyZW50Um93SGVpZ2h0O1xuXG4gIC8vIDUuIEZpbGwgdGV4dHVyZTpcbiAgZm9yICh2YXIgX2kgPSAwLCBfbCA9IHJlZmluZWRJbWFnZXNBcnJheS5sZW5ndGg7IF9pIDwgX2w7IF9pKyspIHtcbiAgICB2YXIgX3JlZmluZWRJbWFnZXNBcnJheSRfID0gcmVmaW5lZEltYWdlc0FycmF5W19pXSxcbiAgICAgIF9pbWFnZSA9IF9yZWZpbmVkSW1hZ2VzQXJyYXkkXy5pbWFnZSxcbiAgICAgIF9zb3VyY2VTaXplID0gX3JlZmluZWRJbWFnZXNBcnJheSRfLnNvdXJjZVNpemUsXG4gICAgICBfc291cmNlWCA9IF9yZWZpbmVkSW1hZ2VzQXJyYXkkXy5zb3VyY2VYLFxuICAgICAgX3NvdXJjZVkgPSBfcmVmaW5lZEltYWdlc0FycmF5JF8uc291cmNlWSxcbiAgICAgIF9kZXN0aW5hdGlvblNpemUgPSBfcmVmaW5lZEltYWdlc0FycmF5JF8uZGVzdGluYXRpb25TaXplLFxuICAgICAgZGVzdGluYXRpb25YID0gX3JlZmluZWRJbWFnZXNBcnJheSRfLmRlc3RpbmF0aW9uWCxcbiAgICAgIGRlc3RpbmF0aW9uWSA9IF9yZWZpbmVkSW1hZ2VzQXJyYXkkXy5kZXN0aW5hdGlvblk7XG4gICAgY3R4LmRyYXdJbWFnZShfaW1hZ2UsIF9zb3VyY2VYLCBfc291cmNlWSwgX3NvdXJjZVNpemUsIF9zb3VyY2VTaXplLCBkZXN0aW5hdGlvblgsIGRlc3RpbmF0aW9uWSwgX2Rlc3RpbmF0aW9uU2l6ZSwgX2Rlc3RpbmF0aW9uU2l6ZSk7XG4gIH1cbiAgcmV0dXJuIGF0bGFzO1xufVxuXG4vKipcbiAqIFRoaXMgY2xhc3MgaGVscHMgdG8gXCJjb3JyZWN0XCIgdGhlIGNlbnRlcmluZyBvZiBhbiBTVkcgcGljdG9ncmFtIGJ5IGZpbmRpbmdcbiAqIHRoZSBcInRydWVcIiB2aXN1YWxseSBjb3JyZWN0IGNlbnRlciB0aHJvdWdoIHRoZSBiYXJ5Y2VudGVyIG9mIHRoZSBwaWN0b2dyYW0nc1xuICogYWxwaGEgbGF5ZXIgaW4geCBhbmQgeSBkaW1lbnNpb24uXG4gKi9cbnZhciBQaWN0b2dyYW1DZW50ZXJpbmdDb3JyZWN0b3IgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQaWN0b2dyYW1DZW50ZXJpbmdDb3JyZWN0b3IoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFBpY3RvZ3JhbUNlbnRlcmluZ0NvcnJlY3Rvcik7XG4gICAgdGhpcy5jYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIHRoaXMuY29udGV4dCA9IHRoaXMuY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICB3aWxsUmVhZEZyZXF1ZW50bHk6IHRydWVcbiAgICB9KTtcbiAgfVxuICBfY3JlYXRlQ2xhc3MoUGljdG9ncmFtQ2VudGVyaW5nQ29ycmVjdG9yLCBbe1xuICAgIGtleTogXCJnZXRDb3JyZWN0aW9uT2Zmc2V0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldENvcnJlY3Rpb25PZmZzZXQoaW1hZ2UsIHNpemUpIHtcbiAgICAgIHRoaXMuY2FudmFzLndpZHRoID0gc2l6ZTtcbiAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IHNpemU7XG4gICAgICB0aGlzLmNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIHNpemUsIHNpemUpO1xuICAgICAgdGhpcy5jb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgc2l6ZSwgc2l6ZSk7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuY29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCwgc2l6ZSwgc2l6ZSkuZGF0YTtcbiAgICAgIHZhciBhbHBoYSA9IG5ldyBVaW50OENsYW1wZWRBcnJheShkYXRhLmxlbmd0aCAvIDQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFscGhhW2ldID0gZGF0YVtpICogNCArIDNdO1xuICAgICAgfVxuICAgICAgdmFyIHN1bVggPSAwO1xuICAgICAgdmFyIHN1bVkgPSAwO1xuICAgICAgdmFyIHRvdGFsID0gMDtcbiAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgc2l6ZTsgeSsrKSB7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgc2l6ZTsgeCsrKSB7XG4gICAgICAgICAgdmFyIGEgPSBhbHBoYVt5ICogc2l6ZSArIHhdO1xuICAgICAgICAgIHRvdGFsICs9IGE7XG4gICAgICAgICAgc3VtWCArPSBhICogeDtcbiAgICAgICAgICBzdW1ZICs9IGEgKiB5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB2YXIgYmFyeWNlbnRlclggPSBzdW1YIC8gdG90YWw7XG4gICAgICB2YXIgYmFyeWNlbnRlclkgPSBzdW1ZIC8gdG90YWw7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB4OiBiYXJ5Y2VudGVyWCAtIHNpemUgLyAyLFxuICAgICAgICB5OiBiYXJ5Y2VudGVyWSAtIHNpemUgLyAyXG4gICAgICB9O1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gUGljdG9ncmFtQ2VudGVyaW5nQ29ycmVjdG9yO1xufSgpO1xudmFyIFRleHR1cmVNYW5hZ2VyID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnRFbWl0dGVyKSB7XG4gIF9pbmhlcml0cyhUZXh0dXJlTWFuYWdlciwgX0V2ZW50RW1pdHRlcik7XG4gIGZ1bmN0aW9uIFRleHR1cmVNYW5hZ2VyKCkge1xuICAgIHZhciBfdGhpcztcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRleHR1cmVNYW5hZ2VyKTtcbiAgICBfdGhpcyA9IF9jYWxsU3VwZXIodGhpcywgVGV4dHVyZU1hbmFnZXIpO1xuICAgIF9kZWZpbmVQcm9wZXJ0eShfYXNzZXJ0VGhpc0luaXRpYWxpemVkKF90aGlzKSwgXCJjYW52YXNcIiwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImN0eFwiLCBfdGhpcy5jYW52YXMuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgIHdpbGxSZWFkRnJlcXVlbnRseTogdHJ1ZVxuICAgIH0pKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiY29ycmVjdG9yXCIsIG5ldyBQaWN0b2dyYW1DZW50ZXJpbmdDb3JyZWN0b3IoKSk7XG4gICAgX2RlZmluZVByb3BlcnR5KF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBcImltYWdlU3RhdGVzXCIsIHt9KTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwidGV4dHVyZVwiLCBfdGhpcy5jdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpKTtcbiAgICBfZGVmaW5lUHJvcGVydHkoX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcyksIFwiYXRsYXNcIiwge30pO1xuICAgIF90aGlzLm9wdGlvbnMgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgREVGQVVMVF9URVhUVVJFX01BTkFHRVJfT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgIHJldHVybiBfdGhpcztcbiAgfVxuICBfY3JlYXRlQ2xhc3MoVGV4dHVyZU1hbmFnZXIsIFt7XG4gICAga2V5OiBcInNjaGVkdWxlR2VuZXJhdGVUZXh0dXJlXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNjaGVkdWxlR2VuZXJhdGVUZXh0dXJlKCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuZnJhbWVJZCA9PT0gXCJudW1iZXJcIikgcmV0dXJuO1xuICAgICAgdGhpcy5mcmFtZUlkID0gd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICBfdGhpczIuZ2VuZXJhdGVUZXh0dXJlKCk7XG4gICAgICAgIF90aGlzMi5mcmFtZUlkID0gdW5kZWZpbmVkO1xuICAgICAgfSwgREVCT1VOQ0VfVElNRU9VVCk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImdlbmVyYXRlVGV4dHVyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZW5lcmF0ZVRleHR1cmUoKSB7XG4gICAgICB0aGlzLmF0bGFzID0gZHJhd1RleHR1cmUodGhpcy5jdHgsIHRoaXMuaW1hZ2VTdGF0ZXMpO1xuICAgICAgdGhpcy50ZXh0dXJlID0gdGhpcy5jdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgICAgdGhpcy5lbWl0KFRleHR1cmVNYW5hZ2VyLk5FV19URVhUVVJFX0VWRU5ULCB7XG4gICAgICAgIGF0bGFzOiB0aGlzLmF0bGFzLFxuICAgICAgICB0ZXh0dXJlOiB0aGlzLnRleHR1cmVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIFBVQkxJQyBBUEk6XG4gIH0sIHtcbiAgICBrZXk6IFwicmVnaXN0ZXJJbWFnZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3JlZ2lzdGVySW1hZ2UgPSBfYXN5bmNUb0dlbmVyYXRvciggLyojX19QVVJFX18qL19yZWdlbmVyYXRvclJ1bnRpbWUoKS5tYXJrKGZ1bmN0aW9uIF9jYWxsZWUoc291cmNlKSB7XG4gICAgICAgIHZhciBzaXplLCBpbWFnZTtcbiAgICAgICAgcmV0dXJuIF9yZWdlbmVyYXRvclJ1bnRpbWUoKS53cmFwKGZ1bmN0aW9uIF9jYWxsZWUkKF9jb250ZXh0KSB7XG4gICAgICAgICAgd2hpbGUgKDEpIHN3aXRjaCAoX2NvbnRleHQucHJldiA9IF9jb250ZXh0Lm5leHQpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgaWYgKCF0aGlzLmltYWdlU3RhdGVzW3NvdXJjZV0pIHtcbiAgICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuYWJydXB0KFwicmV0dXJuXCIpO1xuICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICB0aGlzLmltYWdlU3RhdGVzW3NvdXJjZV0gPSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzOiBcImxvYWRpbmdcIlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMztcbiAgICAgICAgICAgICAgc2l6ZSA9IHRoaXMub3B0aW9ucy5zaXplO1xuICAgICAgICAgICAgICBfY29udGV4dC5uZXh0ID0gNztcbiAgICAgICAgICAgICAgcmV0dXJuIGxvYWRJbWFnZShzb3VyY2UsIHtcbiAgICAgICAgICAgICAgICBzaXplOiBzaXplLm1vZGUgPT09IFwiZm9yY2VcIiA/IHNpemUudmFsdWUgOiB1bmRlZmluZWRcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgICAgIGltYWdlID0gX2NvbnRleHQuc2VudDtcbiAgICAgICAgICAgICAgdGhpcy5pbWFnZVN0YXRlc1tzb3VyY2VdID0gX29iamVjdFNwcmVhZDIoe1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJyZWFkeVwiLFxuICAgICAgICAgICAgICAgIGltYWdlOiBpbWFnZVxuICAgICAgICAgICAgICB9LCByZWZpbmVJbWFnZShpbWFnZSwgdGhpcy5jb3JyZWN0b3IsIHRoaXMub3B0aW9ucykpO1xuICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlR2VuZXJhdGVUZXh0dXJlKCk7XG4gICAgICAgICAgICAgIF9jb250ZXh0Lm5leHQgPSAxNTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgICAgICBfY29udGV4dC5wcmV2ID0gMTI7XG4gICAgICAgICAgICAgIF9jb250ZXh0LnQwID0gX2NvbnRleHRbXCJjYXRjaFwiXSgzKTtcbiAgICAgICAgICAgICAgdGhpcy5pbWFnZVN0YXRlc1tzb3VyY2VdID0ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogXCJlcnJvclwiXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIDE1OlxuICAgICAgICAgICAgY2FzZSBcImVuZFwiOlxuICAgICAgICAgICAgICByZXR1cm4gX2NvbnRleHQuc3RvcCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgX2NhbGxlZSwgdGhpcywgW1szLCAxMl1dKTtcbiAgICAgIH0pKTtcbiAgICAgIGZ1bmN0aW9uIHJlZ2lzdGVySW1hZ2UoX3gzKSB7XG4gICAgICAgIHJldHVybiBfcmVnaXN0ZXJJbWFnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlZ2lzdGVySW1hZ2U7XG4gICAgfSgpXG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0QXRsYXNcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0QXRsYXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5hdGxhcztcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZ2V0VGV4dHVyZVwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRUZXh0dXJlKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGV4dHVyZTtcbiAgICB9XG4gIH1dKTtcbiAgcmV0dXJuIFRleHR1cmVNYW5hZ2VyO1xufShFdmVudEVtaXR0ZXIpO1xuX2RlZmluZVByb3BlcnR5KFRleHR1cmVNYW5hZ2VyLCBcIk5FV19URVhUVVJFX0VWRU5UXCIsIFwibmV3VGV4dHVyZVwiKTtcblxudmFyIF9leGNsdWRlZCA9IFtcImRyYXdIb3ZlclwiLCBcImRyYXdMYWJlbFwiLCBcImRyYXdpbmdNb2RlXCIsIFwia2VlcFdpdGhpbkNpcmNsZVwiLCBcInBhZGRpbmdcIiwgXCJjb2xvckF0dHJpYnV0ZVwiXTtcbnZhciBfV2ViR0xSZW5kZXJpbmdDb250ZXggPSBXZWJHTFJlbmRlcmluZ0NvbnRleHQsXG4gIFVOU0lHTkVEX0JZVEUgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXguVU5TSUdORURfQllURSxcbiAgRkxPQVQgPSBfV2ViR0xSZW5kZXJpbmdDb250ZXguRkxPQVQ7XG52YXIgREVGQVVMVF9DUkVBVEVfTk9ERV9JTUFHRV9PUFRJT05TID0gX29iamVjdFNwcmVhZDIoX29iamVjdFNwcmVhZDIoe30sIERFRkFVTFRfVEVYVFVSRV9NQU5BR0VSX09QVElPTlMpLCB7fSwge1xuICBkcmF3aW5nTW9kZTogXCJiYWNrZ3JvdW5kXCIsXG4gIGtlZXBXaXRoaW5DaXJjbGU6IHRydWUsXG4gIGRyYXdMYWJlbDogdW5kZWZpbmVkLFxuICBkcmF3SG92ZXI6IHVuZGVmaW5lZCxcbiAgcGFkZGluZzogMCxcbiAgY29sb3JBdHRyaWJ1dGU6IFwiY29sb3JcIlxufSk7XG52YXIgVU5JRk9STVMgPSBbXCJ1X3NpemVSYXRpb1wiLCBcInVfY29ycmVjdGlvblJhdGlvXCIsIFwidV9jYW1lcmFBbmdsZVwiLCBcInVfcGVyY2VudGFnZVBhZGRpbmdcIiwgXCJ1X21hdHJpeFwiLCBcInVfY29sb3JpemVJbWFnZXNcIiwgXCJ1X2tlZXBXaXRoaW5DaXJjbGVcIiwgXCJ1X2F0bGFzXCJdO1xuXG4vKipcbiAqIFRvIHNoYXJlIHRoZSB0ZXh0dXJlIGJldHdlZW4gdGhlIHByb2dyYW0gaW5zdGFuY2VzIG9mIHRoZSBncmFwaCBhbmQgdGhlXG4gKiBob3ZlcmVkIG5vZGVzICh0byBwcmV2ZW50IHNvbWUgZmxpY2tlcmluZywgbW9zdGx5KSwgdGhpcyBwcm9ncmFtIG11c3QgYmVcbiAqIFwiYnVpbHRcIiBmb3IgZWFjaCBzaWdtYSBpbnN0YW5jZTpcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUltYWdlUHJvZ3JhbShvcHRpb25zKSB7XG4gIHZhciBfTm9kZUltYWdlUHJvZ3JhbTtcbiAgdmFyIF9ERUZBVUxUX0NSRUFURV9OT0RFXyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBERUZBVUxUX0NSRUFURV9OT0RFX0lNQUdFX09QVElPTlMpLCBvcHRpb25zIHx8IHt9KSwge30sIHtcbiAgICAgIGRyYXdMYWJlbDogdW5kZWZpbmVkLFxuICAgICAgZHJhd0hvdmVyOiB1bmRlZmluZWRcbiAgICB9KSxcbiAgICBkcmF3SG92ZXIgPSBfREVGQVVMVF9DUkVBVEVfTk9ERV8uZHJhd0hvdmVyLFxuICAgIGRyYXdMYWJlbCA9IF9ERUZBVUxUX0NSRUFURV9OT0RFXy5kcmF3TGFiZWwsXG4gICAgZHJhd2luZ01vZGUgPSBfREVGQVVMVF9DUkVBVEVfTk9ERV8uZHJhd2luZ01vZGUsXG4gICAga2VlcFdpdGhpbkNpcmNsZSA9IF9ERUZBVUxUX0NSRUFURV9OT0RFXy5rZWVwV2l0aGluQ2lyY2xlLFxuICAgIHBhZGRpbmcgPSBfREVGQVVMVF9DUkVBVEVfTk9ERV8ucGFkZGluZyxcbiAgICBjb2xvckF0dHJpYnV0ZSA9IF9ERUZBVUxUX0NSRUFURV9OT0RFXy5jb2xvckF0dHJpYnV0ZSxcbiAgICB0ZXh0dXJlTWFuYWdlck9wdGlvbnMgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMoX0RFRkFVTFRfQ1JFQVRFX05PREVfLCBfZXhjbHVkZWQpO1xuXG4gIC8qKlxuICAgKiBUaGlzIHRleHR1cmUgbWFuYWdlciBpcyBzaGFyZWQgYmV0d2VlbiBhbGwgaW5zdGFuY2VzIG9mIHRoaXMgZXhhY3QgY2xhc3MsXG4gICAqIHJldHVybmVkIGJ5IHRoaXMgY2FsbCB0byBnZXROb2RlUHJvZ3JhbUltYWdlLiBUaGlzIG1lYW5zIHRoYXQgcmVtb3VudGluZ1xuICAgKiB0aGUgc2lnbWEgaW5zdGFuY2Ugd2lsbCBub3QgcmVsb2FkIHRoZSBpbWFnZXMgYW5kIHJlZ2VuZXJhdGUgdGhlIHRleHR1cmUuXG4gICAqL1xuICB2YXIgdGV4dHVyZU1hbmFnZXIgPSBuZXcgVGV4dHVyZU1hbmFnZXIodGV4dHVyZU1hbmFnZXJPcHRpb25zKTtcbiAgcmV0dXJuIF9Ob2RlSW1hZ2VQcm9ncmFtID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfTm9kZVByb2dyYW0pIHtcbiAgICBfaW5oZXJpdHMoTm9kZUltYWdlUHJvZ3JhbSwgX05vZGVQcm9ncmFtKTtcbiAgICBmdW5jdGlvbiBOb2RlSW1hZ2VQcm9ncmFtKGdsLCBwaWNraW5nQnVmZmVyLCByZW5kZXJlcikge1xuICAgICAgdmFyIF90aGlzO1xuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE5vZGVJbWFnZVByb2dyYW0pO1xuICAgICAgX3RoaXMgPSBfY2FsbFN1cGVyKHRoaXMsIE5vZGVJbWFnZVByb2dyYW0sIFtnbCwgcGlja2luZ0J1ZmZlciwgcmVuZGVyZXJdKTtcbiAgICAgIF90aGlzLnRleHR1cmVNYW5hZ2VyQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghX2Fzc2VydFRoaXNJbml0aWFsaXplZChfdGhpcykpIHJldHVybjtcbiAgICAgICAgaWYgKF90aGlzLmJpbmRUZXh0dXJlKSB7XG4gICAgICAgICAgX3RoaXMuYXRsYXMgPSB0ZXh0dXJlTWFuYWdlci5nZXRBdGxhcygpO1xuICAgICAgICAgIF90aGlzLnRleHR1cmVJbWFnZSA9IHRleHR1cmVNYW5hZ2VyLmdldFRleHR1cmUoKTtcbiAgICAgICAgICBfdGhpcy5iaW5kVGV4dHVyZSgpO1xuICAgICAgICAgIGlmIChfdGhpcy5sYXRlc3RSZW5kZXJQYXJhbXMpIF90aGlzLnJlbmRlcihfdGhpcy5sYXRlc3RSZW5kZXJQYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW5kZXJlciAmJiByZW5kZXJlci5yZWZyZXNoKSByZW5kZXJlci5yZWZyZXNoKCk7XG4gICAgICB9O1xuICAgICAgdGV4dHVyZU1hbmFnZXIub24oVGV4dHVyZU1hbmFnZXIuTkVXX1RFWFRVUkVfRVZFTlQsIF90aGlzLnRleHR1cmVNYW5hZ2VyQ2FsbGJhY2spO1xuICAgICAgX3RoaXMuYXRsYXMgPSB0ZXh0dXJlTWFuYWdlci5nZXRBdGxhcygpO1xuICAgICAgX3RoaXMudGV4dHVyZUltYWdlID0gdGV4dHVyZU1hbmFnZXIuZ2V0VGV4dHVyZSgpO1xuICAgICAgX3RoaXMudGV4dHVyZSA9IGdsLmNyZWF0ZVRleHR1cmUoKTtcbiAgICAgIF90aGlzLmJpbmRUZXh0dXJlKCk7XG4gICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIF9jcmVhdGVDbGFzcyhOb2RlSW1hZ2VQcm9ncmFtLCBbe1xuICAgICAga2V5OiBcImdldERlZmluaXRpb25cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBnZXREZWZpbml0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIFZFUlRJQ0VTOiAzLFxuICAgICAgICAgIFZFUlRFWF9TSEFERVJfU09VUkNFOiBWRVJURVhfU0hBREVSX1NPVVJDRSQxLFxuICAgICAgICAgIEZSQUdNRU5UX1NIQURFUl9TT1VSQ0U6IEZSQUdNRU5UX1NIQURFUl9TT1VSQ0UsXG4gICAgICAgICAgTUVUSE9EOiBXZWJHTFJlbmRlcmluZ0NvbnRleHQuVFJJQU5HTEVTLFxuICAgICAgICAgIFVOSUZPUk1TOiBVTklGT1JNUyxcbiAgICAgICAgICBBVFRSSUJVVEVTOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJhX3Bvc2l0aW9uXCIsXG4gICAgICAgICAgICBzaXplOiAyLFxuICAgICAgICAgICAgdHlwZTogRkxPQVRcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfc2l6ZVwiLFxuICAgICAgICAgICAgc2l6ZTogMSxcbiAgICAgICAgICAgIHR5cGU6IEZMT0FUXG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgbmFtZTogXCJhX2NvbG9yXCIsXG4gICAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgICAgdHlwZTogVU5TSUdORURfQllURSxcbiAgICAgICAgICAgIG5vcm1hbGl6ZWQ6IHRydWVcbiAgICAgICAgICB9LCB7XG4gICAgICAgICAgICBuYW1lOiBcImFfaWRcIixcbiAgICAgICAgICAgIHNpemU6IDQsXG4gICAgICAgICAgICB0eXBlOiBVTlNJR05FRF9CWVRFLFxuICAgICAgICAgICAgbm9ybWFsaXplZDogdHJ1ZVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG5hbWU6IFwiYV90ZXh0dXJlXCIsXG4gICAgICAgICAgICBzaXplOiA0LFxuICAgICAgICAgICAgdHlwZTogRkxPQVRcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBDT05TVEFOVF9BVFRSSUJVVEVTOiBbe1xuICAgICAgICAgICAgbmFtZTogXCJhX2FuZ2xlXCIsXG4gICAgICAgICAgICBzaXplOiAxLFxuICAgICAgICAgICAgdHlwZTogRkxPQVRcbiAgICAgICAgICB9XSxcbiAgICAgICAgICBDT05TVEFOVF9EQVRBOiBbW05vZGVJbWFnZVByb2dyYW0uQU5HTEVfMV0sIFtOb2RlSW1hZ2VQcm9ncmFtLkFOR0xFXzJdLCBbTm9kZUltYWdlUHJvZ3JhbS5BTkdMRV8zXV1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwia2lsbFwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGtpbGwoKSB7XG4gICAgICAgIHRleHR1cmVNYW5hZ2VyLm9mZihUZXh0dXJlTWFuYWdlci5ORVdfVEVYVFVSRV9FVkVOVCwgdGhpcy50ZXh0dXJlTWFuYWdlckNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwiYmluZFRleHR1cmVcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBiaW5kVGV4dHVyZSgpIHtcbiAgICAgICAgdmFyIGdsID0gdGhpcy5ub3JtYWxQcm9ncmFtLmdsO1xuICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgICAgICBnbC50ZXhJbWFnZTJEKGdsLlRFWFRVUkVfMkQsIDAsIGdsLlJHQkEsIGdsLlJHQkEsIGdsLlVOU0lHTkVEX0JZVEUsIHRoaXMudGV4dHVyZUltYWdlKTtcbiAgICAgICAgZ2wuZ2VuZXJhdGVNaXBtYXAoZ2wuVEVYVFVSRV8yRCk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInJlbmRlclByb2dyYW1cIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW5kZXJQcm9ncmFtKHBhcmFtcywgcHJvZ3JhbUluZm8pIHtcbiAgICAgICAgaWYgKCFwcm9ncmFtSW5mby5pc1BpY2tpbmcpIHtcbiAgICAgICAgICAvLyBSZWJpbmQgdGV4dHVyZSAoc2luY2UgaXQncyBiZWVuIGp1c3QgdW5ib3VuZCBieSBwaWNraW5nKTpcbiAgICAgICAgICB2YXIgZ2wgPSBwcm9ncmFtSW5mby5nbDtcbiAgICAgICAgICBnbC5iaW5kVGV4dHVyZShnbC5URVhUVVJFXzJELCB0aGlzLnRleHR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIF9nZXQoX2dldFByb3RvdHlwZU9mKE5vZGVJbWFnZVByb2dyYW0ucHJvdG90eXBlKSwgXCJyZW5kZXJQcm9ncmFtXCIsIHRoaXMpLmNhbGwodGhpcywgcGFyYW1zLCBwcm9ncmFtSW5mbyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAga2V5OiBcInByb2Nlc3NWaXNpYmxlSXRlbVwiLFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHByb2Nlc3NWaXNpYmxlSXRlbShub2RlSW5kZXgsIHN0YXJ0SW5kZXgsIGRhdGEpIHtcbiAgICAgICAgdmFyIGFycmF5ID0gdGhpcy5hcnJheTtcbiAgICAgICAgdmFyIGNvbG9yID0gZmxvYXRDb2xvcihkYXRhW2NvbG9yQXR0cmlidXRlXSk7XG4gICAgICAgIHZhciBpbWFnZVNvdXJjZSA9IGRhdGEuaW1hZ2U7XG4gICAgICAgIHZhciBpbWFnZVBvc2l0aW9uID0gaW1hZ2VTb3VyY2UgPyB0aGlzLmF0bGFzW2ltYWdlU291cmNlXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHR5cGVvZiBpbWFnZVNvdXJjZSA9PT0gXCJzdHJpbmdcIiAmJiAhaW1hZ2VQb3NpdGlvbikgdGV4dHVyZU1hbmFnZXIucmVnaXN0ZXJJbWFnZShpbWFnZVNvdXJjZSk7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBkYXRhLng7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBkYXRhLnk7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBkYXRhLnNpemU7XG4gICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBjb2xvcjtcbiAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IG5vZGVJbmRleDtcblxuICAgICAgICAvLyBSZWZlcmVuY2UgdGV4dHVyZTpcbiAgICAgICAgaWYgKGltYWdlUG9zaXRpb24pIHtcbiAgICAgICAgICB2YXIgX3RoaXMkdGV4dHVyZUltYWdlID0gdGhpcy50ZXh0dXJlSW1hZ2UsXG4gICAgICAgICAgICB3aWR0aCA9IF90aGlzJHRleHR1cmVJbWFnZS53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IF90aGlzJHRleHR1cmVJbWFnZS5oZWlnaHQ7XG4gICAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGltYWdlUG9zaXRpb24ueCAvIHdpZHRoO1xuICAgICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBpbWFnZVBvc2l0aW9uLnkgLyBoZWlnaHQ7XG4gICAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IGltYWdlUG9zaXRpb24uc2l6ZSAvIHdpZHRoO1xuICAgICAgICAgIGFycmF5W3N0YXJ0SW5kZXgrK10gPSBpbWFnZVBvc2l0aW9uLnNpemUgLyBoZWlnaHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IDA7XG4gICAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IDA7XG4gICAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IDA7XG4gICAgICAgICAgYXJyYXlbc3RhcnRJbmRleCsrXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICBrZXk6IFwic2V0VW5pZm9ybXNcIixcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZXRVbmlmb3JtcyhwYXJhbXMsIF9yZWYpIHtcbiAgICAgICAgdmFyIGdsID0gX3JlZi5nbCxcbiAgICAgICAgICB1bmlmb3JtTG9jYXRpb25zID0gX3JlZi51bmlmb3JtTG9jYXRpb25zO1xuICAgICAgICB2YXIgdV9zaXplUmF0aW8gPSB1bmlmb3JtTG9jYXRpb25zLnVfc2l6ZVJhdGlvLFxuICAgICAgICAgIHVfY29ycmVjdGlvblJhdGlvID0gdW5pZm9ybUxvY2F0aW9ucy51X2NvcnJlY3Rpb25SYXRpbyxcbiAgICAgICAgICB1X21hdHJpeCA9IHVuaWZvcm1Mb2NhdGlvbnMudV9tYXRyaXgsXG4gICAgICAgICAgdV9hdGxhcyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9hdGxhcyxcbiAgICAgICAgICB1X2NvbG9yaXplSW1hZ2VzID0gdW5pZm9ybUxvY2F0aW9ucy51X2NvbG9yaXplSW1hZ2VzLFxuICAgICAgICAgIHVfa2VlcFdpdGhpbkNpcmNsZSA9IHVuaWZvcm1Mb2NhdGlvbnMudV9rZWVwV2l0aGluQ2lyY2xlLFxuICAgICAgICAgIHVfY2FtZXJhQW5nbGUgPSB1bmlmb3JtTG9jYXRpb25zLnVfY2FtZXJhQW5nbGUsXG4gICAgICAgICAgdV9wZXJjZW50YWdlUGFkZGluZyA9IHVuaWZvcm1Mb2NhdGlvbnMudV9wZXJjZW50YWdlUGFkZGluZztcbiAgICAgICAgdGhpcy5sYXRlc3RSZW5kZXJQYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X2NvcnJlY3Rpb25SYXRpbywgcGFyYW1zLmNvcnJlY3Rpb25SYXRpbyk7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X3NpemVSYXRpbywga2VlcFdpdGhpbkNpcmNsZSA/IHBhcmFtcy5zaXplUmF0aW8gOiBwYXJhbXMuc2l6ZVJhdGlvIC8gTWF0aC5TUVJUMik7XG4gICAgICAgIGdsLnVuaWZvcm0xZih1X2NhbWVyYUFuZ2xlLCBwYXJhbXMuY2FtZXJhQW5nbGUpO1xuICAgICAgICBnbC51bmlmb3JtMWYodV9wZXJjZW50YWdlUGFkZGluZywgcGFkZGluZyk7XG4gICAgICAgIGdsLnVuaWZvcm1NYXRyaXgzZnYodV9tYXRyaXgsIGZhbHNlLCBwYXJhbXMubWF0cml4KTtcbiAgICAgICAgZ2wudW5pZm9ybTFpKHVfYXRsYXMsIDApO1xuICAgICAgICBnbC51bmlmb3JtMWkodV9jb2xvcml6ZUltYWdlcywgZHJhd2luZ01vZGUgPT09IFwiY29sb3JcIiA/IDEgOiAwKTtcbiAgICAgICAgZ2wudW5pZm9ybTFpKHVfa2VlcFdpdGhpbkNpcmNsZSwga2VlcFdpdGhpbkNpcmNsZSA/IDEgOiAwKTtcbiAgICAgIH1cbiAgICB9XSk7XG4gICAgcmV0dXJuIE5vZGVJbWFnZVByb2dyYW07XG4gIH0oTm9kZVByb2dyYW0pLCBfZGVmaW5lUHJvcGVydHkoX05vZGVJbWFnZVByb2dyYW0sIFwiQU5HTEVfMVwiLCAwKSwgX2RlZmluZVByb3BlcnR5KF9Ob2RlSW1hZ2VQcm9ncmFtLCBcIkFOR0xFXzJcIiwgMiAqIE1hdGguUEkgLyAzKSwgX2RlZmluZVByb3BlcnR5KF9Ob2RlSW1hZ2VQcm9ncmFtLCBcIkFOR0xFXzNcIiwgNCAqIE1hdGguUEkgLyAzKSwgX2RlZmluZVByb3BlcnR5KF9Ob2RlSW1hZ2VQcm9ncmFtLCBcImRyYXdMYWJlbFwiLCBkcmF3TGFiZWwpLCBfZGVmaW5lUHJvcGVydHkoX05vZGVJbWFnZVByb2dyYW0sIFwiZHJhd0hvdmVyXCIsIGRyYXdIb3ZlciksIF9Ob2RlSW1hZ2VQcm9ncmFtO1xufVxuXG52YXIgTm9kZUltYWdlUHJvZ3JhbSA9IGdldE5vZGVJbWFnZVByb2dyYW0oKTtcbnZhciBOb2RlUGljdG9ncmFtUHJvZ3JhbSA9IGdldE5vZGVJbWFnZVByb2dyYW0oe1xuICBrZWVwV2l0aGluQ2lyY2xlOiBmYWxzZSxcbiAgc2l6ZToge1xuICAgIG1vZGU6IFwiZm9yY2VcIixcbiAgICB2YWx1ZTogMjU2XG4gIH0sXG4gIGRyYXdpbmdNb2RlOiBcImNvbG9yXCIsXG4gIGNvcnJlY3RDZW50ZXJpbmc6IHRydWVcbn0pO1xuXG5leHBvcnQgeyBOb2RlSW1hZ2VQcm9ncmFtLCBOb2RlUGljdG9ncmFtUHJvZ3JhbSwgZ2V0Tm9kZUltYWdlUHJvZ3JhbSBhcyBjcmVhdGVOb2RlSW1hZ2VQcm9ncmFtIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@sigma/node-image/dist/sigma-node-image.esm.js\n");

/***/ })

};
;