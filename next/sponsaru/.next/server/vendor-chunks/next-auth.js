"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/next-auth";
exports.ids = ["vendor-chunks/next-auth"];
exports.modules = {

/***/ "(ssr)/./node_modules/next-auth/lib/client.js":
/*!**********************************************!*\
  !*** ./node_modules/next-auth/lib/client.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ClientSessionError: () => (/* binding */ ClientSessionError),\n/* harmony export */   apiBaseUrl: () => (/* binding */ apiBaseUrl),\n/* harmony export */   fetchData: () => (/* binding */ fetchData),\n/* harmony export */   now: () => (/* binding */ now),\n/* harmony export */   parseUrl: () => (/* binding */ parseUrl),\n/* harmony export */   useOnline: () => (/* binding */ useOnline)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _auth_core_errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @auth/core/errors */ \"(ssr)/./node_modules/@auth/core/errors.js\");\n/* __next_internal_client_entry_do_not_use__ ClientSessionError,fetchData,apiBaseUrl,useOnline,now,parseUrl auto */ \n\n/** @todo */ class ClientFetchError extends _auth_core_errors__WEBPACK_IMPORTED_MODULE_1__.AuthError {\n}\n/** @todo */ class ClientSessionError extends _auth_core_errors__WEBPACK_IMPORTED_MODULE_1__.AuthError {\n}\n// ------------------------ Internal ------------------------\n/**\n * If passed 'appContext' via getInitialProps() in _app.js\n * then get the req object from ctx and use that for the\n * req value to allow `fetchData` to\n * work seemlessly in getInitialProps() on server side\n * pages *and* in _app.js.\n * @internal\n */ async function fetchData(path, __NEXTAUTH, logger, req = {}) {\n    const url = `${apiBaseUrl(__NEXTAUTH)}/${path}`;\n    try {\n        const options = {\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...req?.headers?.cookie ? {\n                    cookie: req.headers.cookie\n                } : {}\n            }\n        };\n        if (req?.body) {\n            options.body = JSON.stringify(req.body);\n            options.method = \"POST\";\n        }\n        const res = await fetch(url, options);\n        const data = await res.json();\n        if (!res.ok) throw data;\n        return data;\n    } catch (error) {\n        logger.error(new ClientFetchError(error.message, error));\n        return null;\n    }\n}\n/** @internal */ function apiBaseUrl(__NEXTAUTH) {\n    if (true) {\n        // Return absolute path when called server side\n        return `${__NEXTAUTH.baseUrlServer}${__NEXTAUTH.basePathServer}`;\n    }\n    // Return relative path when called client side\n    return __NEXTAUTH.basePath;\n}\n/** @internal  */ function useOnline() {\n    const [isOnline, setIsOnline] = react__WEBPACK_IMPORTED_MODULE_0__.useState(typeof navigator !== \"undefined\" ? navigator.onLine : false);\n    const setOnline = ()=>setIsOnline(true);\n    const setOffline = ()=>setIsOnline(false);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        window.addEventListener(\"online\", setOnline);\n        window.addEventListener(\"offline\", setOffline);\n        return ()=>{\n            window.removeEventListener(\"online\", setOnline);\n            window.removeEventListener(\"offline\", setOffline);\n        };\n    }, []);\n    return isOnline;\n}\n/**\n * Returns the number of seconds elapsed since January 1, 1970 00:00:00 UTC.\n * @internal\n */ function now() {\n    return Math.floor(Date.now() / 1000);\n}\n/**\n * Returns an `URL` like object to make requests/redirects from server-side\n * @internal\n */ function parseUrl(url) {\n    const defaultUrl = new URL(\"http://localhost:3000/api/auth\");\n    if (url && !url.startsWith(\"http\")) {\n        url = `https://${url}`;\n    }\n    const _url = new URL(url || defaultUrl);\n    const path = (_url.pathname === \"/\" ? defaultUrl.pathname : _url.pathname)// Remove trailing slash\n    .replace(/\\/$/, \"\");\n    const base = `${_url.origin}${path}`;\n    return {\n        origin: _url.origin,\n        host: _url.host,\n        path,\n        base,\n        toString: ()=>base\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbmV4dC1hdXRoL2xpYi9jbGllbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7b0hBQytCO0FBQ2U7QUFDOUMsVUFBVSxHQUNWLE1BQU1FLHlCQUF5QkQsd0RBQVNBO0FBQ3hDO0FBQ0EsVUFBVSxHQUNILE1BQU1FLDJCQUEyQkYsd0RBQVNBO0FBQ2pEO0FBQ0EsNkRBQTZEO0FBQzdEOzs7Ozs7O0NBT0MsR0FDTSxlQUFlRyxVQUFVQyxJQUFJLEVBQUVDLFVBQVUsRUFBRUMsTUFBTSxFQUFFQyxNQUFNLENBQUMsQ0FBQztJQUM5RCxNQUFNQyxNQUFNLENBQUMsRUFBRUMsV0FBV0osWUFBWSxDQUFDLEVBQUVELEtBQUssQ0FBQztJQUMvQyxJQUFJO1FBQ0EsTUFBTU0sVUFBVTtZQUNaQyxTQUFTO2dCQUNMLGdCQUFnQjtnQkFDaEIsR0FBSUosS0FBS0ksU0FBU0MsU0FBUztvQkFBRUEsUUFBUUwsSUFBSUksT0FBTyxDQUFDQyxNQUFNO2dCQUFDLElBQUksQ0FBQyxDQUFDO1lBQ2xFO1FBQ0o7UUFDQSxJQUFJTCxLQUFLTSxNQUFNO1lBQ1hILFFBQVFHLElBQUksR0FBR0MsS0FBS0MsU0FBUyxDQUFDUixJQUFJTSxJQUFJO1lBQ3RDSCxRQUFRTSxNQUFNLEdBQUc7UUFDckI7UUFDQSxNQUFNQyxNQUFNLE1BQU1DLE1BQU1WLEtBQUtFO1FBQzdCLE1BQU1TLE9BQU8sTUFBTUYsSUFBSUcsSUFBSTtRQUMzQixJQUFJLENBQUNILElBQUlJLEVBQUUsRUFDUCxNQUFNRjtRQUNWLE9BQU9BO0lBQ1gsRUFDQSxPQUFPRyxPQUFPO1FBQ1ZoQixPQUFPZ0IsS0FBSyxDQUFDLElBQUlyQixpQkFBaUJxQixNQUFNQyxPQUFPLEVBQUVEO1FBQ2pELE9BQU87SUFDWDtBQUNKO0FBQ0EsY0FBYyxHQUNQLFNBQVNiLFdBQVdKLFVBQVU7SUFDakMsSUFBSSxJQUE2QixFQUFFO1FBQy9CLCtDQUErQztRQUMvQyxPQUFPLENBQUMsRUFBRUEsV0FBV21CLGFBQWEsQ0FBQyxFQUFFbkIsV0FBV29CLGNBQWMsQ0FBQyxDQUFDO0lBQ3BFO0lBQ0EsK0NBQStDO0lBQy9DLE9BQU9wQixXQUFXcUIsUUFBUTtBQUM5QjtBQUNBLGVBQWUsR0FDUixTQUFTQztJQUNaLE1BQU0sQ0FBQ0MsVUFBVUMsWUFBWSxHQUFHOUIsMkNBQWMsQ0FBQyxPQUFPZ0MsY0FBYyxjQUFjQSxVQUFVQyxNQUFNLEdBQUc7SUFDckcsTUFBTUMsWUFBWSxJQUFNSixZQUFZO0lBQ3BDLE1BQU1LLGFBQWEsSUFBTUwsWUFBWTtJQUNyQzlCLDRDQUFlLENBQUM7UUFDWnFDLE9BQU9DLGdCQUFnQixDQUFDLFVBQVVKO1FBQ2xDRyxPQUFPQyxnQkFBZ0IsQ0FBQyxXQUFXSDtRQUNuQyxPQUFPO1lBQ0hFLE9BQU9FLG1CQUFtQixDQUFDLFVBQVVMO1lBQ3JDRyxPQUFPRSxtQkFBbUIsQ0FBQyxXQUFXSjtRQUMxQztJQUNKLEdBQUcsRUFBRTtJQUNMLE9BQU9OO0FBQ1g7QUFDQTs7O0NBR0MsR0FDTSxTQUFTVztJQUNaLE9BQU9DLEtBQUtDLEtBQUssQ0FBQ0MsS0FBS0gsR0FBRyxLQUFLO0FBQ25DO0FBQ0E7OztDQUdDLEdBQ00sU0FBU0ksU0FBU25DLEdBQUc7SUFDeEIsTUFBTW9DLGFBQWEsSUFBSUMsSUFBSTtJQUMzQixJQUFJckMsT0FBTyxDQUFDQSxJQUFJc0MsVUFBVSxDQUFDLFNBQVM7UUFDaEN0QyxNQUFNLENBQUMsUUFBUSxFQUFFQSxJQUFJLENBQUM7SUFDMUI7SUFDQSxNQUFNdUMsT0FBTyxJQUFJRixJQUFJckMsT0FBT29DO0lBQzVCLE1BQU14QyxPQUFPLENBQUMyQyxLQUFLQyxRQUFRLEtBQUssTUFBTUosV0FBV0ksUUFBUSxHQUFHRCxLQUFLQyxRQUFRLENBQ3JFLHdCQUF3QjtLQUN2QkMsT0FBTyxDQUFDLE9BQU87SUFDcEIsTUFBTUMsT0FBTyxDQUFDLEVBQUVILEtBQUtJLE1BQU0sQ0FBQyxFQUFFL0MsS0FBSyxDQUFDO0lBQ3BDLE9BQU87UUFDSCtDLFFBQVFKLEtBQUtJLE1BQU07UUFDbkJDLE1BQU1MLEtBQUtLLElBQUk7UUFDZmhEO1FBQ0E4QztRQUNBRyxVQUFVLElBQU1IO0lBQ3BCO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcG9uc2FydS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvbGliL2NsaWVudC5qcz80NDY4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgeyBBdXRoRXJyb3IgfSBmcm9tIFwiQGF1dGgvY29yZS9lcnJvcnNcIjtcbi8qKiBAdG9kbyAqL1xuY2xhc3MgQ2xpZW50RmV0Y2hFcnJvciBleHRlbmRzIEF1dGhFcnJvciB7XG59XG4vKiogQHRvZG8gKi9cbmV4cG9ydCBjbGFzcyBDbGllbnRTZXNzaW9uRXJyb3IgZXh0ZW5kcyBBdXRoRXJyb3Ige1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIEludGVybmFsIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLyoqXG4gKiBJZiBwYXNzZWQgJ2FwcENvbnRleHQnIHZpYSBnZXRJbml0aWFsUHJvcHMoKSBpbiBfYXBwLmpzXG4gKiB0aGVuIGdldCB0aGUgcmVxIG9iamVjdCBmcm9tIGN0eCBhbmQgdXNlIHRoYXQgZm9yIHRoZVxuICogcmVxIHZhbHVlIHRvIGFsbG93IGBmZXRjaERhdGFgIHRvXG4gKiB3b3JrIHNlZW1sZXNzbHkgaW4gZ2V0SW5pdGlhbFByb3BzKCkgb24gc2VydmVyIHNpZGVcbiAqIHBhZ2VzICphbmQqIGluIF9hcHAuanMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGZldGNoRGF0YShwYXRoLCBfX05FWFRBVVRILCBsb2dnZXIsIHJlcSA9IHt9KSB7XG4gICAgY29uc3QgdXJsID0gYCR7YXBpQmFzZVVybChfX05FWFRBVVRIKX0vJHtwYXRofWA7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAuLi4ocmVxPy5oZWFkZXJzPy5jb29raWUgPyB7IGNvb2tpZTogcmVxLmhlYWRlcnMuY29va2llIH0gOiB7fSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICBpZiAocmVxPy5ib2R5KSB7XG4gICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShyZXEuYm9keSk7XG4gICAgICAgICAgICBvcHRpb25zLm1ldGhvZCA9IFwiUE9TVFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKHVybCwgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuICAgICAgICBpZiAoIXJlcy5vaylcbiAgICAgICAgICAgIHRocm93IGRhdGE7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgbG9nZ2VyLmVycm9yKG5ldyBDbGllbnRGZXRjaEVycm9yKGVycm9yLm1lc3NhZ2UsIGVycm9yKSk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmV4cG9ydCBmdW5jdGlvbiBhcGlCYXNlVXJsKF9fTkVYVEFVVEgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvLyBSZXR1cm4gYWJzb2x1dGUgcGF0aCB3aGVuIGNhbGxlZCBzZXJ2ZXIgc2lkZVxuICAgICAgICByZXR1cm4gYCR7X19ORVhUQVVUSC5iYXNlVXJsU2VydmVyfSR7X19ORVhUQVVUSC5iYXNlUGF0aFNlcnZlcn1gO1xuICAgIH1cbiAgICAvLyBSZXR1cm4gcmVsYXRpdmUgcGF0aCB3aGVuIGNhbGxlZCBjbGllbnQgc2lkZVxuICAgIHJldHVybiBfX05FWFRBVVRILmJhc2VQYXRoO1xufVxuLyoqIEBpbnRlcm5hbCAgKi9cbmV4cG9ydCBmdW5jdGlvbiB1c2VPbmxpbmUoKSB7XG4gICAgY29uc3QgW2lzT25saW5lLCBzZXRJc09ubGluZV0gPSBSZWFjdC51c2VTdGF0ZSh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiID8gbmF2aWdhdG9yLm9uTGluZSA6IGZhbHNlKTtcbiAgICBjb25zdCBzZXRPbmxpbmUgPSAoKSA9PiBzZXRJc09ubGluZSh0cnVlKTtcbiAgICBjb25zdCBzZXRPZmZsaW5lID0gKCkgPT4gc2V0SXNPbmxpbmUoZmFsc2UpO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib25saW5lXCIsIHNldE9ubGluZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwib2ZmbGluZVwiLCBzZXRPZmZsaW5lKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwib25saW5lXCIsIHNldE9ubGluZSk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9mZmxpbmVcIiwgc2V0T2ZmbGluZSk7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBpc09ubGluZTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgZWxhcHNlZCBzaW5jZSBKYW51YXJ5IDEsIDE5NzAgMDA6MDA6MDAgVVRDLlxuICogQGludGVybmFsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3coKSB7XG4gICAgcmV0dXJuIE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIGBVUkxgIGxpa2Ugb2JqZWN0IHRvIG1ha2UgcmVxdWVzdHMvcmVkaXJlY3RzIGZyb20gc2VydmVyLXNpZGVcbiAqIEBpbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VVcmwodXJsKSB7XG4gICAgY29uc3QgZGVmYXVsdFVybCA9IG5ldyBVUkwoXCJodHRwOi8vbG9jYWxob3N0OjMwMDAvYXBpL2F1dGhcIik7XG4gICAgaWYgKHVybCAmJiAhdXJsLnN0YXJ0c1dpdGgoXCJodHRwXCIpKSB7XG4gICAgICAgIHVybCA9IGBodHRwczovLyR7dXJsfWA7XG4gICAgfVxuICAgIGNvbnN0IF91cmwgPSBuZXcgVVJMKHVybCB8fCBkZWZhdWx0VXJsKTtcbiAgICBjb25zdCBwYXRoID0gKF91cmwucGF0aG5hbWUgPT09IFwiL1wiID8gZGVmYXVsdFVybC5wYXRobmFtZSA6IF91cmwucGF0aG5hbWUpXG4gICAgICAgIC8vIFJlbW92ZSB0cmFpbGluZyBzbGFzaFxuICAgICAgICAucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xuICAgIGNvbnN0IGJhc2UgPSBgJHtfdXJsLm9yaWdpbn0ke3BhdGh9YDtcbiAgICByZXR1cm4ge1xuICAgICAgICBvcmlnaW46IF91cmwub3JpZ2luLFxuICAgICAgICBob3N0OiBfdXJsLmhvc3QsXG4gICAgICAgIHBhdGgsXG4gICAgICAgIGJhc2UsXG4gICAgICAgIHRvU3RyaW5nOiAoKSA9PiBiYXNlLFxuICAgIH07XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJBdXRoRXJyb3IiLCJDbGllbnRGZXRjaEVycm9yIiwiQ2xpZW50U2Vzc2lvbkVycm9yIiwiZmV0Y2hEYXRhIiwicGF0aCIsIl9fTkVYVEFVVEgiLCJsb2dnZXIiLCJyZXEiLCJ1cmwiLCJhcGlCYXNlVXJsIiwib3B0aW9ucyIsImhlYWRlcnMiLCJjb29raWUiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsIm1ldGhvZCIsInJlcyIsImZldGNoIiwiZGF0YSIsImpzb24iLCJvayIsImVycm9yIiwibWVzc2FnZSIsImJhc2VVcmxTZXJ2ZXIiLCJiYXNlUGF0aFNlcnZlciIsImJhc2VQYXRoIiwidXNlT25saW5lIiwiaXNPbmxpbmUiLCJzZXRJc09ubGluZSIsInVzZVN0YXRlIiwibmF2aWdhdG9yIiwib25MaW5lIiwic2V0T25saW5lIiwic2V0T2ZmbGluZSIsInVzZUVmZmVjdCIsIndpbmRvdyIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibm93IiwiTWF0aCIsImZsb29yIiwiRGF0ZSIsInBhcnNlVXJsIiwiZGVmYXVsdFVybCIsIlVSTCIsInN0YXJ0c1dpdGgiLCJfdXJsIiwicGF0aG5hbWUiLCJyZXBsYWNlIiwiYmFzZSIsIm9yaWdpbiIsImhvc3QiLCJ0b1N0cmluZyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next-auth/lib/client.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/next-auth/react.js":
/*!*****************************************!*\
  !*** ./node_modules/next-auth/react.js ***!
  \*****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SessionContext: () => (/* binding */ SessionContext),\n/* harmony export */   SessionProvider: () => (/* binding */ SessionProvider),\n/* harmony export */   __NEXTAUTH: () => (/* binding */ __NEXTAUTH),\n/* harmony export */   getCsrfToken: () => (/* binding */ getCsrfToken),\n/* harmony export */   getProviders: () => (/* binding */ getProviders),\n/* harmony export */   getSession: () => (/* binding */ getSession),\n/* harmony export */   signIn: () => (/* binding */ signIn),\n/* harmony export */   signOut: () => (/* binding */ signOut),\n/* harmony export */   useSession: () => (/* binding */ useSession)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var _lib_client_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/client.js */ \"(ssr)/./node_modules/next-auth/lib/client.js\");\n/**\n *\n * NextAuth.js methods and components that work in [Client components](https://nextjs.org/docs/app/building-your-application/rendering/client-components) and the [Pages Router](https://nextjs.org/docs/pages).\n *\n * For use in [Server Actions](https://nextjs.org/docs/app/api-reference/functions/server-actions), check out [these methods](https://authjs.dev/guides/upgrade-to-v5#methods)\n *\n * @module react\n */ /* __next_internal_client_entry_do_not_use__ __NEXTAUTH,SessionContext,useSession,getSession,getCsrfToken,getProviders,signIn,signOut,SessionProvider auto */ \n\n\n// This behaviour mirrors the default behaviour for getting the site name that\n// happens server side in server/index.js\n// 1. An empty value is legitimate when the code is being invoked client side as\n//    relative URLs are valid in that context and so defaults to empty.\n// 2. When invoked server side the value is picked up from an environment\n//    variable and defaults to 'http://localhost:3000'.\nconst __NEXTAUTH = {\n    baseUrl: (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.parseUrl)(process.env.NEXTAUTH_URL ?? process.env.VERCEL_URL).origin,\n    basePath: (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.parseUrl)(process.env.NEXTAUTH_URL).path,\n    baseUrlServer: (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.parseUrl)(process.env.NEXTAUTH_URL_INTERNAL ?? process.env.NEXTAUTH_URL ?? process.env.VERCEL_URL).origin,\n    basePathServer: (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.parseUrl)(process.env.NEXTAUTH_URL_INTERNAL ?? process.env.NEXTAUTH_URL).path,\n    _lastSync: 0,\n    _session: undefined,\n    _getSession: ()=>{}\n};\nlet broadcastChannel = null;\nfunction broadcast() {\n    if (typeof BroadcastChannel === \"undefined\") {\n        return {\n            postMessage: ()=>{},\n            addEventListener: ()=>{},\n            removeEventListener: ()=>{}\n        };\n    }\n    if (broadcastChannel === null) {\n        broadcastChannel = new BroadcastChannel(\"next-auth\");\n    }\n    return broadcastChannel;\n}\n// TODO:\nconst logger = {\n    debug: console.debug,\n    error: console.error,\n    warn: console.warn\n};\nconst SessionContext = react__WEBPACK_IMPORTED_MODULE_1__.createContext?.(undefined);\n/**\n * React Hook that gives you access to the logged in user's session data and lets you modify it.\n *\n * :::info\n * You will likely not need `useSession` if you are using the [Next.js App Router (`app/`)](https://nextjs.org/blog/next-13-4#nextjs-app-router).\n * :::\n */ function useSession(options) {\n    if (!SessionContext) {\n        throw new Error(\"React Context is unavailable in Server Components\");\n    }\n    // @ts-expect-error Satisfy TS if branch on line below\n    const value = react__WEBPACK_IMPORTED_MODULE_1__.useContext(SessionContext);\n    if (!value && \"development\" !== \"production\") {\n        throw new Error(\"[next-auth]: `useSession` must be wrapped in a <SessionProvider />\");\n    }\n    const { required, onUnauthenticated } = options ?? {};\n    const requiredAndNotLoading = required && value.status === \"unauthenticated\";\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        if (requiredAndNotLoading) {\n            const url = `${__NEXTAUTH.basePath}/signin?${new URLSearchParams({\n                error: \"SessionRequired\",\n                callbackUrl: window.location.href\n            })}`;\n            if (onUnauthenticated) onUnauthenticated();\n            else window.location.href = url;\n        }\n    }, [\n        requiredAndNotLoading,\n        onUnauthenticated\n    ]);\n    if (requiredAndNotLoading) {\n        return {\n            data: value.data,\n            update: value.update,\n            status: \"loading\"\n        };\n    }\n    return value;\n}\nasync function getSession(params) {\n    const session = await (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.fetchData)(\"session\", __NEXTAUTH, logger, params);\n    if (params?.broadcast ?? true) {\n        broadcast().postMessage({\n            event: \"session\",\n            data: {\n                trigger: \"getSession\"\n            }\n        });\n    }\n    return session;\n}\n/**\n * Returns the current Cross-Site Request Forgery Token (CSRF Token)\n * required to make requests that changes state. (e.g. signing in or out, or updating the session).\n *\n * [CSRF Prevention: Double Submit Cookie](https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie)\n */ async function getCsrfToken() {\n    const response = await (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.fetchData)(\"csrf\", __NEXTAUTH, logger);\n    return response?.csrfToken ?? \"\";\n}\n/**\n * Returns a client-safe configuration object of the currently\n * available providers.\n */ async function getProviders() {\n    return (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.fetchData)(\"providers\", __NEXTAUTH, logger);\n}\n/**\n * Initiate a signin flow or send the user to the signin page listing all possible providers.\n * Handles CSRF protection.\n */ async function signIn(provider, options, authorizationParams) {\n    const { callbackUrl = window.location.href, redirect = true } = options ?? {};\n    const baseUrl = (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.apiBaseUrl)(__NEXTAUTH);\n    const providers = await getProviders();\n    if (!providers) {\n        window.location.href = `${baseUrl}/error`;\n        return;\n    }\n    if (!provider || !(provider in providers)) {\n        window.location.href = `${baseUrl}/signin?${new URLSearchParams({\n            callbackUrl\n        })}`;\n        return;\n    }\n    const isCredentials = providers[provider].type === \"credentials\";\n    const isEmail = providers[provider].type === \"email\";\n    const isSupportingReturn = isCredentials || isEmail;\n    const signInUrl = `${baseUrl}/${isCredentials ? \"callback\" : \"signin\"}/${provider}`;\n    const csrfToken = await getCsrfToken();\n    const res = await fetch(`${signInUrl}?${new URLSearchParams(authorizationParams)}`, {\n        method: \"post\",\n        headers: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"X-Auth-Return-Redirect\": \"1\"\n        },\n        // @ts-expect-error\n        body: new URLSearchParams({\n            ...options,\n            csrfToken,\n            callbackUrl\n        })\n    });\n    const data = await res.json();\n    // TODO: Do not redirect for Credentials and Email providers by default in next major\n    if (redirect || !isSupportingReturn) {\n        const url = data.url ?? callbackUrl;\n        window.location.href = url;\n        // If url contains a hash, the browser does not reload the page. We reload manually\n        if (url.includes(\"#\")) window.location.reload();\n        return;\n    }\n    const error = new URL(data.url).searchParams.get(\"error\");\n    if (res.ok) {\n        await __NEXTAUTH._getSession({\n            event: \"storage\"\n        });\n    }\n    return {\n        error,\n        status: res.status,\n        ok: res.ok,\n        url: error ? null : data.url\n    };\n}\n/**\n * Initiate a signout, by destroying the current session.\n * Handles CSRF protection.\n */ async function signOut(options) {\n    const { callbackUrl = window.location.href } = options ?? {};\n    const baseUrl = (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.apiBaseUrl)(__NEXTAUTH);\n    const csrfToken = await getCsrfToken();\n    const res = await fetch(`${baseUrl}/signout`, {\n        method: \"post\",\n        headers: {\n            \"Content-Type\": \"application/x-www-form-urlencoded\",\n            \"X-Auth-Return-Redirect\": \"1\"\n        },\n        body: new URLSearchParams({\n            csrfToken,\n            callbackUrl\n        })\n    });\n    const data = await res.json();\n    broadcast().postMessage({\n        event: \"session\",\n        data: {\n            trigger: \"signout\"\n        }\n    });\n    if (options?.redirect ?? true) {\n        const url = data.url ?? callbackUrl;\n        window.location.href = url;\n        // If url contains a hash, the browser does not reload the page. We reload manually\n        if (url.includes(\"#\")) window.location.reload();\n        // @ts-expect-error\n        return;\n    }\n    await __NEXTAUTH._getSession({\n        event: \"storage\"\n    });\n    return data;\n}\n/**\n * [React Context](https://react.dev/learn/passing-data-deeply-with-context) provider to wrap the app (`pages/`) to make session data available anywhere.\n *\n * When used, the session state is automatically synchronized across all open tabs/windows and they are all updated whenever they gain or lose focus\n * or the state changes (e.g. a user signs in or out) when {@link SessionProviderProps.refetchOnWindowFocus} is `true`.\n *\n * :::info\n * You will likely not need `SessionProvider` if you are using the [Next.js App Router (`app/`)](https://nextjs.org/blog/next-13-4#nextjs-app-router).\n * :::\n */ function SessionProvider(props) {\n    if (!SessionContext) {\n        throw new Error(\"React Context is unavailable in Server Components\");\n    }\n    const { children, basePath, refetchInterval, refetchWhenOffline } = props;\n    if (basePath) __NEXTAUTH.basePath = basePath;\n    /**\n     * If session was `null`, there was an attempt to fetch it,\n     * but it failed, but we still treat it as a valid initial value.\n     */ const hasInitialSession = props.session !== undefined;\n    /** If session was passed, initialize as already synced */ __NEXTAUTH._lastSync = hasInitialSession ? (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.now)() : 0;\n    const [session, setSession] = react__WEBPACK_IMPORTED_MODULE_1__.useState(()=>{\n        if (hasInitialSession) __NEXTAUTH._session = props.session;\n        return props.session;\n    });\n    /** If session was passed, initialize as not loading */ const [loading, setLoading] = react__WEBPACK_IMPORTED_MODULE_1__.useState(!hasInitialSession);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        __NEXTAUTH._getSession = async ({ event } = {})=>{\n            try {\n                const storageEvent = event === \"storage\";\n                // We should always update if we don't have a client session yet\n                // or if there are events from other tabs/windows\n                if (storageEvent || __NEXTAUTH._session === undefined) {\n                    __NEXTAUTH._lastSync = (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.now)();\n                    __NEXTAUTH._session = await getSession({\n                        broadcast: !storageEvent\n                    });\n                    setSession(__NEXTAUTH._session);\n                    return;\n                }\n                if (// If there is no time defined for when a session should be considered\n                // stale, then it's okay to use the value we have until an event is\n                // triggered which updates it\n                !event || // If the client doesn't have a session then we don't need to call\n                // the server to check if it does (if they have signed in via another\n                // tab or window that will come through as a \"stroage\" event\n                // event anyway)\n                __NEXTAUTH._session === null || // Bail out early if the client session is not stale yet\n                (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.now)() < __NEXTAUTH._lastSync) {\n                    return;\n                }\n                // An event or session staleness occurred, update the client session.\n                __NEXTAUTH._lastSync = (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.now)();\n                __NEXTAUTH._session = await getSession();\n                setSession(__NEXTAUTH._session);\n            } catch (error) {\n                logger.error(new _lib_client_js__WEBPACK_IMPORTED_MODULE_2__.ClientSessionError(error.message, error));\n            } finally{\n                setLoading(false);\n            }\n        };\n        __NEXTAUTH._getSession();\n        return ()=>{\n            __NEXTAUTH._lastSync = 0;\n            __NEXTAUTH._session = undefined;\n            __NEXTAUTH._getSession = ()=>{};\n        };\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        const handle = ()=>__NEXTAUTH._getSession({\n                event: \"storage\"\n            });\n        // Listen for storage events and update session if event fired from\n        // another window (but suppress firing another event to avoid a loop)\n        // Fetch new session data but tell it to not to fire another event to\n        // avoid an infinite loop.\n        // Note: We could pass session data through and do something like\n        // `setData(message.data)` but that can cause problems depending\n        // on how the session object is being used in the client; it is\n        // more robust to have each window/tab fetch it's own copy of the\n        // session object rather than share it across instances.\n        broadcast().addEventListener(\"message\", handle);\n        return ()=>broadcast().removeEventListener(\"message\", handle);\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        const { refetchOnWindowFocus = true } = props;\n        // Listen for when the page is visible, if the user switches tabs\n        // and makes our tab visible again, re-fetch the session, but only if\n        // this feature is not disabled.\n        const visibilityHandler = ()=>{\n            if (refetchOnWindowFocus && document.visibilityState === \"visible\") __NEXTAUTH._getSession({\n                event: \"visibilitychange\"\n            });\n        };\n        document.addEventListener(\"visibilitychange\", visibilityHandler, false);\n        return ()=>document.removeEventListener(\"visibilitychange\", visibilityHandler, false);\n    }, [\n        props.refetchOnWindowFocus\n    ]);\n    const isOnline = (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.useOnline)();\n    // TODO: Flip this behavior in next major version\n    const shouldRefetch = refetchWhenOffline !== false || isOnline;\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        if (refetchInterval && shouldRefetch) {\n            const refetchIntervalTimer = setInterval(()=>{\n                if (__NEXTAUTH._session) {\n                    __NEXTAUTH._getSession({\n                        event: \"poll\"\n                    });\n                }\n            }, refetchInterval * 1000);\n            return ()=>clearInterval(refetchIntervalTimer);\n        }\n    }, [\n        refetchInterval,\n        shouldRefetch\n    ]);\n    const value = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>({\n            data: session,\n            status: loading ? \"loading\" : session ? \"authenticated\" : \"unauthenticated\",\n            async update (data) {\n                if (loading || !session) return;\n                setLoading(true);\n                const newSession = await (0,_lib_client_js__WEBPACK_IMPORTED_MODULE_2__.fetchData)(\"session\", __NEXTAUTH, logger, typeof data === \"undefined\" ? undefined : {\n                    body: {\n                        csrfToken: await getCsrfToken(),\n                        data\n                    }\n                });\n                setLoading(false);\n                if (newSession) {\n                    setSession(newSession);\n                    broadcast().postMessage({\n                        event: \"session\",\n                        data: {\n                            trigger: \"getSession\"\n                        }\n                    });\n                }\n                return newSession;\n            }\n        }), [\n        session,\n        loading\n    ]);\n    return(// @ts-expect-error\n    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SessionContext.Provider, {\n        value: value,\n        children: children\n    }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFPO29CQUFPO2dCQUMzQztZQUNKLEdBQUdnQyxrQkFBa0I7WUFDckIsT0FBTyxJQUFNa0IsY0FBY0Y7UUFDL0I7SUFDSixHQUFHO1FBQUNoQjtRQUFpQmU7S0FBYztJQUNuQyxNQUFNakUsUUFBUXZDLDBDQUFhLENBQUMsSUFBTztZQUMvQm9ELE1BQU1JO1lBQ05aLFFBQVFrRCxVQUNGLFlBQ0F0QyxVQUNJLGtCQUNBO1lBQ1YsTUFBTUgsUUFBT0QsSUFBSTtnQkFDYixJQUFJMEMsV0FBVyxDQUFDdEMsU0FDWjtnQkFDSnVDLFdBQVc7Z0JBQ1gsTUFBTWMsYUFBYSxNQUFNMUcseURBQVNBLENBQUMsV0FBV0ksWUFBWXNCLFFBQVEsT0FBT3VCLFNBQVMsY0FDNUUvQixZQUNBO29CQUFFd0QsTUFBTTt3QkFBRWhCLFdBQVcsTUFBTUY7d0JBQWdCUDtvQkFBSztnQkFBRTtnQkFDeEQyQyxXQUFXO2dCQUNYLElBQUljLFlBQVk7b0JBQ1pqQixXQUFXaUI7b0JBQ1hyRixZQUFZRSxXQUFXLENBQUM7d0JBQ3BCK0IsT0FBTzt3QkFDUEwsTUFBTTs0QkFBRU0sU0FBUzt3QkFBYTtvQkFDbEM7Z0JBQ0o7Z0JBQ0EsT0FBT21EO1lBQ1g7UUFDSixJQUFJO1FBQUNyRDtRQUFTc0M7S0FBUTtJQUN0QixPQUNBLG1CQUFtQjtJQUNuQi9GLHNEQUFJQSxDQUFDbUMsZUFBZTRFLFFBQVEsRUFBRTtRQUFFdkUsT0FBT0E7UUFBT2lELFVBQVVBO0lBQVM7QUFDckUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcG9uc2FydS8uL25vZGVfbW9kdWxlcy9uZXh0LWF1dGgvcmVhY3QuanM/Mjg1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqXG4gKiBOZXh0QXV0aC5qcyBtZXRob2RzIGFuZCBjb21wb25lbnRzIHRoYXQgd29yayBpbiBbQ2xpZW50IGNvbXBvbmVudHNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9idWlsZGluZy15b3VyLWFwcGxpY2F0aW9uL3JlbmRlcmluZy9jbGllbnQtY29tcG9uZW50cykgYW5kIHRoZSBbUGFnZXMgUm91dGVyXShodHRwczovL25leHRqcy5vcmcvZG9jcy9wYWdlcykuXG4gKlxuICogRm9yIHVzZSBpbiBbU2VydmVyIEFjdGlvbnNdKGh0dHBzOi8vbmV4dGpzLm9yZy9kb2NzL2FwcC9hcGktcmVmZXJlbmNlL2Z1bmN0aW9ucy9zZXJ2ZXItYWN0aW9ucyksIGNoZWNrIG91dCBbdGhlc2UgbWV0aG9kc10oaHR0cHM6Ly9hdXRoanMuZGV2L2d1aWRlcy91cGdyYWRlLXRvLXY1I21ldGhvZHMpXG4gKlxuICogQG1vZHVsZSByZWFjdFxuICovXG5cInVzZSBjbGllbnRcIjtcbmltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGFwaUJhc2VVcmwsIENsaWVudFNlc3Npb25FcnJvciwgZmV0Y2hEYXRhLCBub3csIHBhcnNlVXJsLCB1c2VPbmxpbmUsIH0gZnJvbSBcIi4vbGliL2NsaWVudC5qc1wiO1xuLy8gVGhpcyBiZWhhdmlvdXIgbWlycm9ycyB0aGUgZGVmYXVsdCBiZWhhdmlvdXIgZm9yIGdldHRpbmcgdGhlIHNpdGUgbmFtZSB0aGF0XG4vLyBoYXBwZW5zIHNlcnZlciBzaWRlIGluIHNlcnZlci9pbmRleC5qc1xuLy8gMS4gQW4gZW1wdHkgdmFsdWUgaXMgbGVnaXRpbWF0ZSB3aGVuIHRoZSBjb2RlIGlzIGJlaW5nIGludm9rZWQgY2xpZW50IHNpZGUgYXNcbi8vICAgIHJlbGF0aXZlIFVSTHMgYXJlIHZhbGlkIGluIHRoYXQgY29udGV4dCBhbmQgc28gZGVmYXVsdHMgdG8gZW1wdHkuXG4vLyAyLiBXaGVuIGludm9rZWQgc2VydmVyIHNpZGUgdGhlIHZhbHVlIGlzIHBpY2tlZCB1cCBmcm9tIGFuIGVudmlyb25tZW50XG4vLyAgICB2YXJpYWJsZSBhbmQgZGVmYXVsdHMgdG8gJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMCcuXG5leHBvcnQgY29uc3QgX19ORVhUQVVUSCA9IHtcbiAgICBiYXNlVXJsOiBwYXJzZVVybChwcm9jZXNzLmVudi5ORVhUQVVUSF9VUkwgPz8gcHJvY2Vzcy5lbnYuVkVSQ0VMX1VSTCkub3JpZ2luLFxuICAgIGJhc2VQYXRoOiBwYXJzZVVybChwcm9jZXNzLmVudi5ORVhUQVVUSF9VUkwpLnBhdGgsXG4gICAgYmFzZVVybFNlcnZlcjogcGFyc2VVcmwocHJvY2Vzcy5lbnYuTkVYVEFVVEhfVVJMX0lOVEVSTkFMID8/XG4gICAgICAgIHByb2Nlc3MuZW52Lk5FWFRBVVRIX1VSTCA/P1xuICAgICAgICBwcm9jZXNzLmVudi5WRVJDRUxfVVJMKS5vcmlnaW4sXG4gICAgYmFzZVBhdGhTZXJ2ZXI6IHBhcnNlVXJsKHByb2Nlc3MuZW52Lk5FWFRBVVRIX1VSTF9JTlRFUk5BTCA/PyBwcm9jZXNzLmVudi5ORVhUQVVUSF9VUkwpLnBhdGgsXG4gICAgX2xhc3RTeW5jOiAwLFxuICAgIF9zZXNzaW9uOiB1bmRlZmluZWQsXG4gICAgX2dldFNlc3Npb246ICgpID0+IHsgfSxcbn07XG5sZXQgYnJvYWRjYXN0Q2hhbm5lbCA9IG51bGw7XG5mdW5jdGlvbiBicm9hZGNhc3QoKSB7XG4gICAgaWYgKHR5cGVvZiBCcm9hZGNhc3RDaGFubmVsID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwb3N0TWVzc2FnZTogKCkgPT4geyB9LFxuICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcjogKCkgPT4geyB9LFxuICAgICAgICAgICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcjogKCkgPT4geyB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoYnJvYWRjYXN0Q2hhbm5lbCA9PT0gbnVsbCkge1xuICAgICAgICBicm9hZGNhc3RDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoXCJuZXh0LWF1dGhcIik7XG4gICAgfVxuICAgIHJldHVybiBicm9hZGNhc3RDaGFubmVsO1xufVxuLy8gVE9ETzpcbmNvbnN0IGxvZ2dlciA9IHtcbiAgICBkZWJ1ZzogY29uc29sZS5kZWJ1ZyxcbiAgICBlcnJvcjogY29uc29sZS5lcnJvcixcbiAgICB3YXJuOiBjb25zb2xlLndhcm4sXG59O1xuZXhwb3J0IGNvbnN0IFNlc3Npb25Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dD8uKHVuZGVmaW5lZCk7XG4vKipcbiAqIFJlYWN0IEhvb2sgdGhhdCBnaXZlcyB5b3UgYWNjZXNzIHRvIHRoZSBsb2dnZWQgaW4gdXNlcidzIHNlc3Npb24gZGF0YSBhbmQgbGV0cyB5b3UgbW9kaWZ5IGl0LlxuICpcbiAqIDo6OmluZm9cbiAqIFlvdSB3aWxsIGxpa2VseSBub3QgbmVlZCBgdXNlU2Vzc2lvbmAgaWYgeW91IGFyZSB1c2luZyB0aGUgW05leHQuanMgQXBwIFJvdXRlciAoYGFwcC9gKV0oaHR0cHM6Ly9uZXh0anMub3JnL2Jsb2cvbmV4dC0xMy00I25leHRqcy1hcHAtcm91dGVyKS5cbiAqIDo6OlxuICovXG5leHBvcnQgZnVuY3Rpb24gdXNlU2Vzc2lvbihvcHRpb25zKSB7XG4gICAgaWYgKCFTZXNzaW9uQ29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWFjdCBDb250ZXh0IGlzIHVuYXZhaWxhYmxlIGluIFNlcnZlciBDb21wb25lbnRzXCIpO1xuICAgIH1cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIFNhdGlzZnkgVFMgaWYgYnJhbmNoIG9uIGxpbmUgYmVsb3dcbiAgICBjb25zdCB2YWx1ZSA9IFJlYWN0LnVzZUNvbnRleHQoU2Vzc2lvbkNvbnRleHQpO1xuICAgIGlmICghdmFsdWUgJiYgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIltuZXh0LWF1dGhdOiBgdXNlU2Vzc2lvbmAgbXVzdCBiZSB3cmFwcGVkIGluIGEgPFNlc3Npb25Qcm92aWRlciAvPlwiKTtcbiAgICB9XG4gICAgY29uc3QgeyByZXF1aXJlZCwgb25VbmF1dGhlbnRpY2F0ZWQgfSA9IG9wdGlvbnMgPz8ge307XG4gICAgY29uc3QgcmVxdWlyZWRBbmROb3RMb2FkaW5nID0gcmVxdWlyZWQgJiYgdmFsdWUuc3RhdHVzID09PSBcInVuYXV0aGVudGljYXRlZFwiO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChyZXF1aXJlZEFuZE5vdExvYWRpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGAke19fTkVYVEFVVEguYmFzZVBhdGh9L3NpZ25pbj8ke25ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgICAgIGVycm9yOiBcIlNlc3Npb25SZXF1aXJlZFwiLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrVXJsOiB3aW5kb3cubG9jYXRpb24uaHJlZixcbiAgICAgICAgICAgIH0pfWA7XG4gICAgICAgICAgICBpZiAob25VbmF1dGhlbnRpY2F0ZWQpXG4gICAgICAgICAgICAgICAgb25VbmF1dGhlbnRpY2F0ZWQoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgfVxuICAgIH0sIFtyZXF1aXJlZEFuZE5vdExvYWRpbmcsIG9uVW5hdXRoZW50aWNhdGVkXSk7XG4gICAgaWYgKHJlcXVpcmVkQW5kTm90TG9hZGluZykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZGF0YTogdmFsdWUuZGF0YSxcbiAgICAgICAgICAgIHVwZGF0ZTogdmFsdWUudXBkYXRlLFxuICAgICAgICAgICAgc3RhdHVzOiBcImxvYWRpbmdcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldFNlc3Npb24ocGFyYW1zKSB7XG4gICAgY29uc3Qgc2Vzc2lvbiA9IGF3YWl0IGZldGNoRGF0YShcInNlc3Npb25cIiwgX19ORVhUQVVUSCwgbG9nZ2VyLCBwYXJhbXMpO1xuICAgIGlmIChwYXJhbXM/LmJyb2FkY2FzdCA/PyB0cnVlKSB7XG4gICAgICAgIGJyb2FkY2FzdCgpLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIGV2ZW50OiBcInNlc3Npb25cIixcbiAgICAgICAgICAgIGRhdGE6IHsgdHJpZ2dlcjogXCJnZXRTZXNzaW9uXCIgfSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBzZXNzaW9uO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IENyb3NzLVNpdGUgUmVxdWVzdCBGb3JnZXJ5IFRva2VuIChDU1JGIFRva2VuKVxuICogcmVxdWlyZWQgdG8gbWFrZSByZXF1ZXN0cyB0aGF0IGNoYW5nZXMgc3RhdGUuIChlLmcuIHNpZ25pbmcgaW4gb3Igb3V0LCBvciB1cGRhdGluZyB0aGUgc2Vzc2lvbikuXG4gKlxuICogW0NTUkYgUHJldmVudGlvbjogRG91YmxlIFN1Ym1pdCBDb29raWVdKGh0dHBzOi8vY2hlYXRzaGVldHNlcmllcy5vd2FzcC5vcmcvY2hlYXRzaGVldHMvQ3Jvc3MtU2l0ZV9SZXF1ZXN0X0ZvcmdlcnlfUHJldmVudGlvbl9DaGVhdF9TaGVldC5odG1sI2RvdWJsZS1zdWJtaXQtY29va2llKVxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q3NyZlRva2VuKCkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hEYXRhKFwiY3NyZlwiLCBfX05FWFRBVVRILCBsb2dnZXIpO1xuICAgIHJldHVybiByZXNwb25zZT8uY3NyZlRva2VuID8/IFwiXCI7XG59XG4vKipcbiAqIFJldHVybnMgYSBjbGllbnQtc2FmZSBjb25maWd1cmF0aW9uIG9iamVjdCBvZiB0aGUgY3VycmVudGx5XG4gKiBhdmFpbGFibGUgcHJvdmlkZXJzLlxuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvdmlkZXJzKCkge1xuICAgIHJldHVybiBmZXRjaERhdGEoXCJwcm92aWRlcnNcIiwgX19ORVhUQVVUSCwgbG9nZ2VyKTtcbn1cbi8qKlxuICogSW5pdGlhdGUgYSBzaWduaW4gZmxvdyBvciBzZW5kIHRoZSB1c2VyIHRvIHRoZSBzaWduaW4gcGFnZSBsaXN0aW5nIGFsbCBwb3NzaWJsZSBwcm92aWRlcnMuXG4gKiBIYW5kbGVzIENTUkYgcHJvdGVjdGlvbi5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25Jbihwcm92aWRlciwgb3B0aW9ucywgYXV0aG9yaXphdGlvblBhcmFtcykge1xuICAgIGNvbnN0IHsgY2FsbGJhY2tVcmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZiwgcmVkaXJlY3QgPSB0cnVlIH0gPSBvcHRpb25zID8/IHt9O1xuICAgIGNvbnN0IGJhc2VVcmwgPSBhcGlCYXNlVXJsKF9fTkVYVEFVVEgpO1xuICAgIGNvbnN0IHByb3ZpZGVycyA9IGF3YWl0IGdldFByb3ZpZGVycygpO1xuICAgIGlmICghcHJvdmlkZXJzKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYCR7YmFzZVVybH0vZXJyb3JgO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghcHJvdmlkZXIgfHwgIShwcm92aWRlciBpbiBwcm92aWRlcnMpKSB7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gYCR7YmFzZVVybH0vc2lnbmluPyR7bmV3IFVSTFNlYXJjaFBhcmFtcyh7XG4gICAgICAgICAgICBjYWxsYmFja1VybCxcbiAgICAgICAgfSl9YDtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpc0NyZWRlbnRpYWxzID0gcHJvdmlkZXJzW3Byb3ZpZGVyXS50eXBlID09PSBcImNyZWRlbnRpYWxzXCI7XG4gICAgY29uc3QgaXNFbWFpbCA9IHByb3ZpZGVyc1twcm92aWRlcl0udHlwZSA9PT0gXCJlbWFpbFwiO1xuICAgIGNvbnN0IGlzU3VwcG9ydGluZ1JldHVybiA9IGlzQ3JlZGVudGlhbHMgfHwgaXNFbWFpbDtcbiAgICBjb25zdCBzaWduSW5VcmwgPSBgJHtiYXNlVXJsfS8ke2lzQ3JlZGVudGlhbHMgPyBcImNhbGxiYWNrXCIgOiBcInNpZ25pblwifS8ke3Byb3ZpZGVyfWA7XG4gICAgY29uc3QgY3NyZlRva2VuID0gYXdhaXQgZ2V0Q3NyZlRva2VuKCk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7c2lnbkluVXJsfT8ke25ldyBVUkxTZWFyY2hQYXJhbXMoYXV0aG9yaXphdGlvblBhcmFtcyl9YCwge1xuICAgICAgICBtZXRob2Q6IFwicG9zdFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICAgICAgICAgICAgXCJYLUF1dGgtUmV0dXJuLVJlZGlyZWN0XCI6IFwiMVwiLFxuICAgICAgICB9LFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGJvZHk6IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGNzcmZUb2tlbixcbiAgICAgICAgICAgIGNhbGxiYWNrVXJsLFxuICAgICAgICB9KSxcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICAvLyBUT0RPOiBEbyBub3QgcmVkaXJlY3QgZm9yIENyZWRlbnRpYWxzIGFuZCBFbWFpbCBwcm92aWRlcnMgYnkgZGVmYXVsdCBpbiBuZXh0IG1ham9yXG4gICAgaWYgKHJlZGlyZWN0IHx8ICFpc1N1cHBvcnRpbmdSZXR1cm4pIHtcbiAgICAgICAgY29uc3QgdXJsID0gZGF0YS51cmwgPz8gY2FsbGJhY2tVcmw7XG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsO1xuICAgICAgICAvLyBJZiB1cmwgY29udGFpbnMgYSBoYXNoLCB0aGUgYnJvd3NlciBkb2VzIG5vdCByZWxvYWQgdGhlIHBhZ2UuIFdlIHJlbG9hZCBtYW51YWxseVxuICAgICAgICBpZiAodXJsLmluY2x1ZGVzKFwiI1wiKSlcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBlcnJvciA9IG5ldyBVUkwoZGF0YS51cmwpLnNlYXJjaFBhcmFtcy5nZXQoXCJlcnJvclwiKTtcbiAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgIGF3YWl0IF9fTkVYVEFVVEguX2dldFNlc3Npb24oeyBldmVudDogXCJzdG9yYWdlXCIgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVycm9yLFxuICAgICAgICBzdGF0dXM6IHJlcy5zdGF0dXMsXG4gICAgICAgIG9rOiByZXMub2ssXG4gICAgICAgIHVybDogZXJyb3IgPyBudWxsIDogZGF0YS51cmwsXG4gICAgfTtcbn1cbi8qKlxuICogSW5pdGlhdGUgYSBzaWdub3V0LCBieSBkZXN0cm95aW5nIHRoZSBjdXJyZW50IHNlc3Npb24uXG4gKiBIYW5kbGVzIENTUkYgcHJvdGVjdGlvbi5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHNpZ25PdXQob3B0aW9ucykge1xuICAgIGNvbnN0IHsgY2FsbGJhY2tVcmwgPSB3aW5kb3cubG9jYXRpb24uaHJlZiB9ID0gb3B0aW9ucyA/PyB7fTtcbiAgICBjb25zdCBiYXNlVXJsID0gYXBpQmFzZVVybChfX05FWFRBVVRIKTtcbiAgICBjb25zdCBjc3JmVG9rZW4gPSBhd2FpdCBnZXRDc3JmVG9rZW4oKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChgJHtiYXNlVXJsfS9zaWdub3V0YCwge1xuICAgICAgICBtZXRob2Q6IFwicG9zdFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiLFxuICAgICAgICAgICAgXCJYLUF1dGgtUmV0dXJuLVJlZGlyZWN0XCI6IFwiMVwiLFxuICAgICAgICB9LFxuICAgICAgICBib2R5OiBuZXcgVVJMU2VhcmNoUGFyYW1zKHsgY3NyZlRva2VuLCBjYWxsYmFja1VybCB9KSxcbiAgICB9KTtcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcbiAgICBicm9hZGNhc3QoKS5wb3N0TWVzc2FnZSh7IGV2ZW50OiBcInNlc3Npb25cIiwgZGF0YTogeyB0cmlnZ2VyOiBcInNpZ25vdXRcIiB9IH0pO1xuICAgIGlmIChvcHRpb25zPy5yZWRpcmVjdCA/PyB0cnVlKSB7XG4gICAgICAgIGNvbnN0IHVybCA9IGRhdGEudXJsID8/IGNhbGxiYWNrVXJsO1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVybDtcbiAgICAgICAgLy8gSWYgdXJsIGNvbnRhaW5zIGEgaGFzaCwgdGhlIGJyb3dzZXIgZG9lcyBub3QgcmVsb2FkIHRoZSBwYWdlLiBXZSByZWxvYWQgbWFudWFsbHlcbiAgICAgICAgaWYgKHVybC5pbmNsdWRlcyhcIiNcIikpXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhd2FpdCBfX05FWFRBVVRILl9nZXRTZXNzaW9uKHsgZXZlbnQ6IFwic3RvcmFnZVwiIH0pO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBbUmVhY3QgQ29udGV4dF0oaHR0cHM6Ly9yZWFjdC5kZXYvbGVhcm4vcGFzc2luZy1kYXRhLWRlZXBseS13aXRoLWNvbnRleHQpIHByb3ZpZGVyIHRvIHdyYXAgdGhlIGFwcCAoYHBhZ2VzL2ApIHRvIG1ha2Ugc2Vzc2lvbiBkYXRhIGF2YWlsYWJsZSBhbnl3aGVyZS5cbiAqXG4gKiBXaGVuIHVzZWQsIHRoZSBzZXNzaW9uIHN0YXRlIGlzIGF1dG9tYXRpY2FsbHkgc3luY2hyb25pemVkIGFjcm9zcyBhbGwgb3BlbiB0YWJzL3dpbmRvd3MgYW5kIHRoZXkgYXJlIGFsbCB1cGRhdGVkIHdoZW5ldmVyIHRoZXkgZ2FpbiBvciBsb3NlIGZvY3VzXG4gKiBvciB0aGUgc3RhdGUgY2hhbmdlcyAoZS5nLiBhIHVzZXIgc2lnbnMgaW4gb3Igb3V0KSB3aGVuIHtAbGluayBTZXNzaW9uUHJvdmlkZXJQcm9wcy5yZWZldGNoT25XaW5kb3dGb2N1c30gaXMgYHRydWVgLlxuICpcbiAqIDo6OmluZm9cbiAqIFlvdSB3aWxsIGxpa2VseSBub3QgbmVlZCBgU2Vzc2lvblByb3ZpZGVyYCBpZiB5b3UgYXJlIHVzaW5nIHRoZSBbTmV4dC5qcyBBcHAgUm91dGVyIChgYXBwL2ApXShodHRwczovL25leHRqcy5vcmcvYmxvZy9uZXh0LTEzLTQjbmV4dGpzLWFwcC1yb3V0ZXIpLlxuICogOjo6XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBTZXNzaW9uUHJvdmlkZXIocHJvcHMpIHtcbiAgICBpZiAoIVNlc3Npb25Db250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlJlYWN0IENvbnRleHQgaXMgdW5hdmFpbGFibGUgaW4gU2VydmVyIENvbXBvbmVudHNcIik7XG4gICAgfVxuICAgIGNvbnN0IHsgY2hpbGRyZW4sIGJhc2VQYXRoLCByZWZldGNoSW50ZXJ2YWwsIHJlZmV0Y2hXaGVuT2ZmbGluZSB9ID0gcHJvcHM7XG4gICAgaWYgKGJhc2VQYXRoKVxuICAgICAgICBfX05FWFRBVVRILmJhc2VQYXRoID0gYmFzZVBhdGg7XG4gICAgLyoqXG4gICAgICogSWYgc2Vzc2lvbiB3YXMgYG51bGxgLCB0aGVyZSB3YXMgYW4gYXR0ZW1wdCB0byBmZXRjaCBpdCxcbiAgICAgKiBidXQgaXQgZmFpbGVkLCBidXQgd2Ugc3RpbGwgdHJlYXQgaXQgYXMgYSB2YWxpZCBpbml0aWFsIHZhbHVlLlxuICAgICAqL1xuICAgIGNvbnN0IGhhc0luaXRpYWxTZXNzaW9uID0gcHJvcHMuc2Vzc2lvbiAhPT0gdW5kZWZpbmVkO1xuICAgIC8qKiBJZiBzZXNzaW9uIHdhcyBwYXNzZWQsIGluaXRpYWxpemUgYXMgYWxyZWFkeSBzeW5jZWQgKi9cbiAgICBfX05FWFRBVVRILl9sYXN0U3luYyA9IGhhc0luaXRpYWxTZXNzaW9uID8gbm93KCkgOiAwO1xuICAgIGNvbnN0IFtzZXNzaW9uLCBzZXRTZXNzaW9uXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHtcbiAgICAgICAgaWYgKGhhc0luaXRpYWxTZXNzaW9uKVxuICAgICAgICAgICAgX19ORVhUQVVUSC5fc2Vzc2lvbiA9IHByb3BzLnNlc3Npb247XG4gICAgICAgIHJldHVybiBwcm9wcy5zZXNzaW9uO1xuICAgIH0pO1xuICAgIC8qKiBJZiBzZXNzaW9uIHdhcyBwYXNzZWQsIGluaXRpYWxpemUgYXMgbm90IGxvYWRpbmcgKi9cbiAgICBjb25zdCBbbG9hZGluZywgc2V0TG9hZGluZ10gPSBSZWFjdC51c2VTdGF0ZSghaGFzSW5pdGlhbFNlc3Npb24pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIF9fTkVYVEFVVEguX2dldFNlc3Npb24gPSBhc3luYyAoeyBldmVudCB9ID0ge30pID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RvcmFnZUV2ZW50ID0gZXZlbnQgPT09IFwic3RvcmFnZVwiO1xuICAgICAgICAgICAgICAgIC8vIFdlIHNob3VsZCBhbHdheXMgdXBkYXRlIGlmIHdlIGRvbid0IGhhdmUgYSBjbGllbnQgc2Vzc2lvbiB5ZXRcbiAgICAgICAgICAgICAgICAvLyBvciBpZiB0aGVyZSBhcmUgZXZlbnRzIGZyb20gb3RoZXIgdGFicy93aW5kb3dzXG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2VFdmVudCB8fCBfX05FWFRBVVRILl9zZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgX19ORVhUQVVUSC5fbGFzdFN5bmMgPSBub3coKTtcbiAgICAgICAgICAgICAgICAgICAgX19ORVhUQVVUSC5fc2Vzc2lvbiA9IGF3YWl0IGdldFNlc3Npb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0OiAhc3RvcmFnZUV2ZW50LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgc2V0U2Vzc2lvbihfX05FWFRBVVRILl9zZXNzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUgaXMgbm8gdGltZSBkZWZpbmVkIGZvciB3aGVuIGEgc2Vzc2lvbiBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgICAgICAgICAgICAgIC8vIHN0YWxlLCB0aGVuIGl0J3Mgb2theSB0byB1c2UgdGhlIHZhbHVlIHdlIGhhdmUgdW50aWwgYW4gZXZlbnQgaXNcbiAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyZWQgd2hpY2ggdXBkYXRlcyBpdFxuICAgICAgICAgICAgICAgICFldmVudCB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgY2xpZW50IGRvZXNuJ3QgaGF2ZSBhIHNlc3Npb24gdGhlbiB3ZSBkb24ndCBuZWVkIHRvIGNhbGxcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHNlcnZlciB0byBjaGVjayBpZiBpdCBkb2VzIChpZiB0aGV5IGhhdmUgc2lnbmVkIGluIHZpYSBhbm90aGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHRhYiBvciB3aW5kb3cgdGhhdCB3aWxsIGNvbWUgdGhyb3VnaCBhcyBhIFwic3Ryb2FnZVwiIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIC8vIGV2ZW50IGFueXdheSlcbiAgICAgICAgICAgICAgICAgICAgX19ORVhUQVVUSC5fc2Vzc2lvbiA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBCYWlsIG91dCBlYXJseSBpZiB0aGUgY2xpZW50IHNlc3Npb24gaXMgbm90IHN0YWxlIHlldFxuICAgICAgICAgICAgICAgICAgICBub3coKSA8IF9fTkVYVEFVVEguX2xhc3RTeW5jKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQW4gZXZlbnQgb3Igc2Vzc2lvbiBzdGFsZW5lc3Mgb2NjdXJyZWQsIHVwZGF0ZSB0aGUgY2xpZW50IHNlc3Npb24uXG4gICAgICAgICAgICAgICAgX19ORVhUQVVUSC5fbGFzdFN5bmMgPSBub3coKTtcbiAgICAgICAgICAgICAgICBfX05FWFRBVVRILl9zZXNzaW9uID0gYXdhaXQgZ2V0U2Vzc2lvbigpO1xuICAgICAgICAgICAgICAgIHNldFNlc3Npb24oX19ORVhUQVVUSC5fc2Vzc2lvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IobmV3IENsaWVudFNlc3Npb25FcnJvcihlcnJvci5tZXNzYWdlLCBlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIF9fTkVYVEFVVEguX2dldFNlc3Npb24oKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIF9fTkVYVEFVVEguX2xhc3RTeW5jID0gMDtcbiAgICAgICAgICAgIF9fTkVYVEFVVEguX3Nlc3Npb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBfX05FWFRBVVRILl9nZXRTZXNzaW9uID0gKCkgPT4geyB9O1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGUgPSAoKSA9PiBfX05FWFRBVVRILl9nZXRTZXNzaW9uKHsgZXZlbnQ6IFwic3RvcmFnZVwiIH0pO1xuICAgICAgICAvLyBMaXN0ZW4gZm9yIHN0b3JhZ2UgZXZlbnRzIGFuZCB1cGRhdGUgc2Vzc2lvbiBpZiBldmVudCBmaXJlZCBmcm9tXG4gICAgICAgIC8vIGFub3RoZXIgd2luZG93IChidXQgc3VwcHJlc3MgZmlyaW5nIGFub3RoZXIgZXZlbnQgdG8gYXZvaWQgYSBsb29wKVxuICAgICAgICAvLyBGZXRjaCBuZXcgc2Vzc2lvbiBkYXRhIGJ1dCB0ZWxsIGl0IHRvIG5vdCB0byBmaXJlIGFub3RoZXIgZXZlbnQgdG9cbiAgICAgICAgLy8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcC5cbiAgICAgICAgLy8gTm90ZTogV2UgY291bGQgcGFzcyBzZXNzaW9uIGRhdGEgdGhyb3VnaCBhbmQgZG8gc29tZXRoaW5nIGxpa2VcbiAgICAgICAgLy8gYHNldERhdGEobWVzc2FnZS5kYXRhKWAgYnV0IHRoYXQgY2FuIGNhdXNlIHByb2JsZW1zIGRlcGVuZGluZ1xuICAgICAgICAvLyBvbiBob3cgdGhlIHNlc3Npb24gb2JqZWN0IGlzIGJlaW5nIHVzZWQgaW4gdGhlIGNsaWVudDsgaXQgaXNcbiAgICAgICAgLy8gbW9yZSByb2J1c3QgdG8gaGF2ZSBlYWNoIHdpbmRvdy90YWIgZmV0Y2ggaXQncyBvd24gY29weSBvZiB0aGVcbiAgICAgICAgLy8gc2Vzc2lvbiBvYmplY3QgcmF0aGVyIHRoYW4gc2hhcmUgaXQgYWNyb3NzIGluc3RhbmNlcy5cbiAgICAgICAgYnJvYWRjYXN0KCkuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgaGFuZGxlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGJyb2FkY2FzdCgpLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIGhhbmRsZSk7XG4gICAgfSwgW10pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcmVmZXRjaE9uV2luZG93Rm9jdXMgPSB0cnVlIH0gPSBwcm9wcztcbiAgICAgICAgLy8gTGlzdGVuIGZvciB3aGVuIHRoZSBwYWdlIGlzIHZpc2libGUsIGlmIHRoZSB1c2VyIHN3aXRjaGVzIHRhYnNcbiAgICAgICAgLy8gYW5kIG1ha2VzIG91ciB0YWIgdmlzaWJsZSBhZ2FpbiwgcmUtZmV0Y2ggdGhlIHNlc3Npb24sIGJ1dCBvbmx5IGlmXG4gICAgICAgIC8vIHRoaXMgZmVhdHVyZSBpcyBub3QgZGlzYWJsZWQuXG4gICAgICAgIGNvbnN0IHZpc2liaWxpdHlIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHJlZmV0Y2hPbldpbmRvd0ZvY3VzICYmIGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gXCJ2aXNpYmxlXCIpXG4gICAgICAgICAgICAgICAgX19ORVhUQVVUSC5fZ2V0U2Vzc2lvbih7IGV2ZW50OiBcInZpc2liaWxpdHljaGFuZ2VcIiB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgdmlzaWJpbGl0eUhhbmRsZXIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJ2aXNpYmlsaXR5Y2hhbmdlXCIsIHZpc2liaWxpdHlIYW5kbGVyLCBmYWxzZSk7XG4gICAgfSwgW3Byb3BzLnJlZmV0Y2hPbldpbmRvd0ZvY3VzXSk7XG4gICAgY29uc3QgaXNPbmxpbmUgPSB1c2VPbmxpbmUoKTtcbiAgICAvLyBUT0RPOiBGbGlwIHRoaXMgYmVoYXZpb3IgaW4gbmV4dCBtYWpvciB2ZXJzaW9uXG4gICAgY29uc3Qgc2hvdWxkUmVmZXRjaCA9IHJlZmV0Y2hXaGVuT2ZmbGluZSAhPT0gZmFsc2UgfHwgaXNPbmxpbmU7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHJlZmV0Y2hJbnRlcnZhbCAmJiBzaG91bGRSZWZldGNoKSB7XG4gICAgICAgICAgICBjb25zdCByZWZldGNoSW50ZXJ2YWxUaW1lciA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoX19ORVhUQVVUSC5fc2Vzc2lvbikge1xuICAgICAgICAgICAgICAgICAgICBfX05FWFRBVVRILl9nZXRTZXNzaW9uKHsgZXZlbnQ6IFwicG9sbFwiIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHJlZmV0Y2hJbnRlcnZhbCAqIDEwMDApO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IGNsZWFySW50ZXJ2YWwocmVmZXRjaEludGVydmFsVGltZXIpO1xuICAgICAgICB9XG4gICAgfSwgW3JlZmV0Y2hJbnRlcnZhbCwgc2hvdWxkUmVmZXRjaF0pO1xuICAgIGNvbnN0IHZhbHVlID0gUmVhY3QudXNlTWVtbygoKSA9PiAoe1xuICAgICAgICBkYXRhOiBzZXNzaW9uLFxuICAgICAgICBzdGF0dXM6IGxvYWRpbmdcbiAgICAgICAgICAgID8gXCJsb2FkaW5nXCJcbiAgICAgICAgICAgIDogc2Vzc2lvblxuICAgICAgICAgICAgICAgID8gXCJhdXRoZW50aWNhdGVkXCJcbiAgICAgICAgICAgICAgICA6IFwidW5hdXRoZW50aWNhdGVkXCIsXG4gICAgICAgIGFzeW5jIHVwZGF0ZShkYXRhKSB7XG4gICAgICAgICAgICBpZiAobG9hZGluZyB8fCAhc2Vzc2lvbilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgICAgICAgICAgY29uc3QgbmV3U2Vzc2lvbiA9IGF3YWl0IGZldGNoRGF0YShcInNlc3Npb25cIiwgX19ORVhUQVVUSCwgbG9nZ2VyLCB0eXBlb2YgZGF0YSA9PT0gXCJ1bmRlZmluZWRcIlxuICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgOiB7IGJvZHk6IHsgY3NyZlRva2VuOiBhd2FpdCBnZXRDc3JmVG9rZW4oKSwgZGF0YSB9IH0pO1xuICAgICAgICAgICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gICAgICAgICAgICBpZiAobmV3U2Vzc2lvbikge1xuICAgICAgICAgICAgICAgIHNldFNlc3Npb24obmV3U2Vzc2lvbik7XG4gICAgICAgICAgICAgICAgYnJvYWRjYXN0KCkucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICBldmVudDogXCJzZXNzaW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHsgdHJpZ2dlcjogXCJnZXRTZXNzaW9uXCIgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdTZXNzaW9uO1xuICAgICAgICB9LFxuICAgIH0pLCBbc2Vzc2lvbiwgbG9hZGluZ10pO1xuICAgIHJldHVybiAoXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgIF9qc3goU2Vzc2lvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHZhbHVlLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuIl0sIm5hbWVzIjpbImpzeCIsIl9qc3giLCJSZWFjdCIsImFwaUJhc2VVcmwiLCJDbGllbnRTZXNzaW9uRXJyb3IiLCJmZXRjaERhdGEiLCJub3ciLCJwYXJzZVVybCIsInVzZU9ubGluZSIsIl9fTkVYVEFVVEgiLCJiYXNlVXJsIiwicHJvY2VzcyIsImVudiIsIk5FWFRBVVRIX1VSTCIsIlZFUkNFTF9VUkwiLCJvcmlnaW4iLCJiYXNlUGF0aCIsInBhdGgiLCJiYXNlVXJsU2VydmVyIiwiTkVYVEFVVEhfVVJMX0lOVEVSTkFMIiwiYmFzZVBhdGhTZXJ2ZXIiLCJfbGFzdFN5bmMiLCJfc2Vzc2lvbiIsInVuZGVmaW5lZCIsIl9nZXRTZXNzaW9uIiwiYnJvYWRjYXN0Q2hhbm5lbCIsImJyb2FkY2FzdCIsIkJyb2FkY2FzdENoYW5uZWwiLCJwb3N0TWVzc2FnZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwibG9nZ2VyIiwiZGVidWciLCJjb25zb2xlIiwiZXJyb3IiLCJ3YXJuIiwiU2Vzc2lvbkNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlU2Vzc2lvbiIsIm9wdGlvbnMiLCJFcnJvciIsInZhbHVlIiwidXNlQ29udGV4dCIsInJlcXVpcmVkIiwib25VbmF1dGhlbnRpY2F0ZWQiLCJyZXF1aXJlZEFuZE5vdExvYWRpbmciLCJzdGF0dXMiLCJ1c2VFZmZlY3QiLCJ1cmwiLCJVUkxTZWFyY2hQYXJhbXMiLCJjYWxsYmFja1VybCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsImRhdGEiLCJ1cGRhdGUiLCJnZXRTZXNzaW9uIiwicGFyYW1zIiwic2Vzc2lvbiIsImV2ZW50IiwidHJpZ2dlciIsImdldENzcmZUb2tlbiIsInJlc3BvbnNlIiwiY3NyZlRva2VuIiwiZ2V0UHJvdmlkZXJzIiwic2lnbkluIiwicHJvdmlkZXIiLCJhdXRob3JpemF0aW9uUGFyYW1zIiwicmVkaXJlY3QiLCJwcm92aWRlcnMiLCJpc0NyZWRlbnRpYWxzIiwidHlwZSIsImlzRW1haWwiLCJpc1N1cHBvcnRpbmdSZXR1cm4iLCJzaWduSW5VcmwiLCJyZXMiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwianNvbiIsImluY2x1ZGVzIiwicmVsb2FkIiwiVVJMIiwic2VhcmNoUGFyYW1zIiwiZ2V0Iiwib2siLCJzaWduT3V0IiwiU2Vzc2lvblByb3ZpZGVyIiwicHJvcHMiLCJjaGlsZHJlbiIsInJlZmV0Y2hJbnRlcnZhbCIsInJlZmV0Y2hXaGVuT2ZmbGluZSIsImhhc0luaXRpYWxTZXNzaW9uIiwic2V0U2Vzc2lvbiIsInVzZVN0YXRlIiwibG9hZGluZyIsInNldExvYWRpbmciLCJzdG9yYWdlRXZlbnQiLCJtZXNzYWdlIiwiaGFuZGxlIiwicmVmZXRjaE9uV2luZG93Rm9jdXMiLCJ2aXNpYmlsaXR5SGFuZGxlciIsImRvY3VtZW50IiwidmlzaWJpbGl0eVN0YXRlIiwiaXNPbmxpbmUiLCJzaG91bGRSZWZldGNoIiwicmVmZXRjaEludGVydmFsVGltZXIiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJ1c2VNZW1vIiwibmV3U2Vzc2lvbiIsIlByb3ZpZGVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/next-auth/react.js\n");

/***/ })

};
;