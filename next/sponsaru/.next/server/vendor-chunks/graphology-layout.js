/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/graphology-layout";
exports.ids = ["vendor-chunks/graphology-layout"];
exports.modules = {

/***/ "(ssr)/./node_modules/graphology-layout/circlepack.js":
/*!******************************************************!*\
  !*** ./node_modules/graphology-layout/circlepack.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Graphology CirclePack Layout\n * =============================\n *\n * Circlepack layout from d3-hierarchy/gephi.\n */\nvar resolveDefaults = __webpack_require__(/*! graphology-utils/defaults */ \"(ssr)/./node_modules/graphology-utils/defaults.js\");\nvar isGraph = __webpack_require__(/*! graphology-utils/is-graph */ \"(ssr)/./node_modules/graphology-utils/is-graph.js\");\nvar shuffle = __webpack_require__(/*! pandemonium/shuffle-in-place */ \"(ssr)/./node_modules/pandemonium/shuffle-in-place.js\");\n\n/**\n * Default options.\n */\nvar DEFAULTS = {\n  attributes: {\n    x: 'x',\n    y: 'y'\n  },\n  center: 0,\n  hierarchyAttributes: [],\n  rng: Math.random,\n  scale: 1\n};\n\n/**\n * Helpers.\n */\nfunction CircleWrap(id, x, y, r, circleWrap) {\n  this.wrappedCircle = circleWrap || null; //hacky d3 reference thing\n\n  this.children = {};\n  this.countChildren = 0;\n  this.id = id || null;\n  this.next = null;\n  this.previous = null;\n\n  this.x = x || null;\n  this.y = y || null;\n  if (circleWrap) this.r = 1010101;\n  // for debugging purposes - should not be used in this case\n  else this.r = r || 999;\n}\n\nCircleWrap.prototype.hasChildren = function () {\n  return this.countChildren > 0;\n};\n\nCircleWrap.prototype.addChild = function (id, child) {\n  this.children[id] = child;\n  ++this.countChildren;\n};\n\nCircleWrap.prototype.getChild = function (id) {\n  if (!this.children.hasOwnProperty(id)) {\n    var circleWrap = new CircleWrap();\n    this.children[id] = circleWrap;\n    ++this.countChildren;\n  }\n  return this.children[id];\n};\n\nCircleWrap.prototype.applyPositionToChildren = function () {\n  if (this.hasChildren()) {\n    var root = this; // using 'this' in Object.keys.forEach seems a bad idea\n    for (var key in root.children) {\n      var child = root.children[key];\n      child.x += root.x;\n      child.y += root.y;\n      child.applyPositionToChildren();\n    }\n  }\n};\n\nfunction setNode(/*Graph*/ graph, /*CircleWrap*/ parentCircle, /*Map*/ posMap) {\n  for (var key in parentCircle.children) {\n    var circle = parentCircle.children[key];\n    if (circle.hasChildren()) {\n      setNode(graph, circle, posMap);\n    } else {\n      posMap[circle.id] = {x: circle.x, y: circle.y};\n    }\n  }\n}\n\nfunction enclosesNot(/*CircleWrap*/ a, /*CircleWrap*/ b) {\n  var dr = a.r - b.r;\n  var dx = b.x - a.x;\n  var dy = b.y - a.y;\n  return dr < 0 || dr * dr < dx * dx + dy * dy;\n}\n\nfunction enclosesWeak(/*CircleWrap*/ a, /*CircleWrap*/ b) {\n  var dr = a.r - b.r + 1e-6;\n  var dx = b.x - a.x;\n  var dy = b.y - a.y;\n  return dr > 0 && dr * dr > dx * dx + dy * dy;\n}\n\nfunction enclosesWeakAll(/*CircleWrap*/ a, /*Array<CircleWrap>*/ B) {\n  for (var i = 0; i < B.length; ++i) {\n    if (!enclosesWeak(a, B[i])) {\n      return false;\n    }\n  }\n  return true;\n}\n\nfunction encloseBasis1(/*CircleWrap*/ a) {\n  return new CircleWrap(null, a.x, a.y, a.r);\n}\n\nfunction encloseBasis2(/*CircleWrap*/ a, /*CircleWrap*/ b) {\n  var x1 = a.x,\n    y1 = a.y,\n    r1 = a.r,\n    x2 = b.x,\n    y2 = b.y,\n    r2 = b.r,\n    x21 = x2 - x1,\n    y21 = y2 - y1,\n    r21 = r2 - r1,\n    l = Math.sqrt(x21 * x21 + y21 * y21);\n  return new CircleWrap(\n    null,\n    (x1 + x2 + (x21 / l) * r21) / 2,\n    (y1 + y2 + (y21 / l) * r21) / 2,\n    (l + r1 + r2) / 2\n  );\n}\n\nfunction encloseBasis3(/*CircleWrap*/ a, /*CircleWrap*/ b, /*CircleWrap*/ c) {\n  var x1 = a.x,\n    y1 = a.y,\n    r1 = a.r,\n    x2 = b.x,\n    y2 = b.y,\n    r2 = b.r,\n    x3 = c.x,\n    y3 = c.y,\n    r3 = c.r,\n    a2 = x1 - x2,\n    a3 = x1 - x3,\n    b2 = y1 - y2,\n    b3 = y1 - y3,\n    c2 = r2 - r1,\n    c3 = r3 - r1,\n    d1 = x1 * x1 + y1 * y1 - r1 * r1,\n    d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,\n    d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,\n    ab = a3 * b2 - a2 * b3,\n    xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,\n    xb = (b3 * c2 - b2 * c3) / ab,\n    ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,\n    yb = (a2 * c3 - a3 * c2) / ab,\n    A = xb * xb + yb * yb - 1,\n    B = 2 * (r1 + xa * xb + ya * yb),\n    C = xa * xa + ya * ya - r1 * r1,\n    r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);\n  return new CircleWrap(null, x1 + xa + xb * r, y1 + ya + yb * r, r);\n}\n\nfunction encloseBasis(/*Array<CircleWrap>*/ B) {\n  switch (B.length) {\n    case 1:\n      return encloseBasis1(B[0]);\n    case 2:\n      return encloseBasis2(B[0], B[1]);\n    case 3:\n      return encloseBasis3(B[0], B[1], B[2]);\n    default:\n      throw new Error(\n        'graphology-layout/circlepack: Invalid basis length ' + B.length\n      );\n  }\n}\n\nfunction extendBasis(/*Array<CircleWrap>*/ B, /*CircleWrap*/ p) {\n  var i, j;\n\n  if (enclosesWeakAll(p, B)) return [p];\n\n  // If we get here then B must have at least one element.\n  for (i = 0; i < B.length; ++i) {\n    if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) {\n      return [B[i], p];\n    }\n  }\n\n  // If we get here then B must have at least two elements.\n  for (i = 0; i < B.length - 1; ++i) {\n    for (j = i + 1; j < B.length; ++j) {\n      if (\n        enclosesNot(encloseBasis2(B[i], B[j]), p) &&\n        enclosesNot(encloseBasis2(B[i], p), B[j]) &&\n        enclosesNot(encloseBasis2(B[j], p), B[i]) &&\n        enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)\n      ) {\n        return [B[i], B[j], p];\n      }\n    }\n  }\n\n  // If we get here then something is very wrong.\n  throw new Error('graphology-layout/circlepack: extendBasis failure !');\n}\n\nfunction score(/*CircleWrap*/ node) {\n  var a = node.wrappedCircle;\n  var b = node.next.wrappedCircle;\n  var ab = a.r + b.r;\n  var dx = (a.x * b.r + b.x * a.r) / ab;\n  var dy = (a.y * b.r + b.y * a.r) / ab;\n  return dx * dx + dy * dy;\n}\n\nfunction enclose(circles, shuffleFunc) {\n  var i = 0;\n  var circlesLoc = circles.slice();\n\n  var n = circles.length;\n  var B = [];\n  var p;\n  var e;\n  shuffleFunc(circlesLoc);\n  while (i < n) {\n    p = circlesLoc[i];\n    if (e && enclosesWeak(e, p)) {\n      ++i;\n    } else {\n      B = extendBasis(B, p);\n      e = encloseBasis(B);\n      i = 0;\n    }\n  }\n  return e;\n}\n\nfunction place(/*CircleWrap*/ b, /*CircleWrap*/ a, /*CircleWrap*/ c) {\n  var dx = b.x - a.x,\n    x,\n    a2,\n    dy = b.y - a.y,\n    y,\n    b2,\n    d2 = dx * dx + dy * dy;\n  if (d2) {\n    a2 = a.r + c.r;\n    a2 *= a2;\n    b2 = b.r + c.r;\n    b2 *= b2;\n    if (a2 > b2) {\n      x = (d2 + b2 - a2) / (2 * d2);\n      y = Math.sqrt(Math.max(0, b2 / d2 - x * x));\n      c.x = b.x - x * dx - y * dy;\n      c.y = b.y - x * dy + y * dx;\n    } else {\n      x = (d2 + a2 - b2) / (2 * d2);\n      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));\n      c.x = a.x + x * dx - y * dy;\n      c.y = a.y + x * dy + y * dx;\n    }\n  } else {\n    c.x = a.x + c.r;\n    c.y = a.y;\n  }\n}\n\nfunction intersects(/*CircleWrap*/ a, /*CircleWrap*/ b) {\n  var dr = a.r + b.r - 1e-6,\n    dx = b.x - a.x,\n    dy = b.y - a.y;\n  return dr > 0 && dr * dr > dx * dx + dy * dy;\n}\n\nfunction packEnclose(/*Array<CircleWrap>*/ circles, shuffleFunc) {\n  var n = circles.length;\n  if (n === 0) return 0;\n\n  var a, b, c, aa, ca, i, j, k, sj, sk;\n\n  // Place the first circle.\n  a = circles[0];\n  a.x = 0;\n  a.y = 0;\n  if (n <= 1) return a.r;\n\n  // Place the second circle.\n  b = circles[1];\n  a.x = -b.r;\n  b.x = a.r;\n  b.y = 0;\n  if (n <= 2) return a.r + b.r;\n\n  // Place the third circle.\n  c = circles[2];\n  place(b, a, c);\n\n  // Initialize the front-chain using the first three circles a, b and c.\n  a = new CircleWrap(null, null, null, null, a);\n  b = new CircleWrap(null, null, null, null, b);\n  c = new CircleWrap(null, null, null, null, c);\n  a.next = c.previous = b;\n  b.next = a.previous = c;\n  c.next = b.previous = a;\n\n  // Attempt to place each remaining circle…\n  pack: for (i = 3; i < n; ++i) {\n    c = circles[i];\n    place(a.wrappedCircle, b.wrappedCircle, c);\n    c = new CircleWrap(null, null, null, null, c);\n\n    // Find the closest intersecting circle on the front-chain, if any.\n    // “Closeness” is determined by linear distance along the front-chain.\n    // “Ahead” or “behind” is likewise determined by linear distance.\n    j = b.next;\n    k = a.previous;\n    sj = b.wrappedCircle.r;\n    sk = a.wrappedCircle.r;\n    do {\n      if (sj <= sk) {\n        if (intersects(j.wrappedCircle, c.wrappedCircle)) {\n          b = j;\n          a.next = b;\n          b.previous = a;\n          --i;\n          continue pack;\n        }\n        sj += j.wrappedCircle.r;\n        j = j.next;\n      } else {\n        if (intersects(k.wrappedCircle, c.wrappedCircle)) {\n          a = k;\n          a.next = b;\n          b.previous = a;\n          --i;\n          continue pack;\n        }\n        sk += k.wrappedCircle.r;\n        k = k.previous;\n      }\n    } while (j !== k.next);\n\n    // Success! Insert the new circle c between a and b.\n    c.previous = a;\n    c.next = b;\n    a.next = b.previous = b = c;\n\n    // Compute the new closest circle pair to the centroid.\n    aa = score(a);\n    while ((c = c.next) !== b) {\n      if ((ca = score(c)) < aa) {\n        a = c;\n        aa = ca;\n      }\n    }\n    b = a.next;\n  }\n\n  // Compute the enclosing circle of the front chain.\n  a = [b.wrappedCircle];\n  c = b;\n  var safety = 10000;\n  while ((c = c.next) !== b) {\n    if (--safety === 0) {\n      break;\n    }\n    a.push(c.wrappedCircle);\n  }\n  c = enclose(a, shuffleFunc);\n\n  // Translate the circles to put the enclosing circle around the origin.\n  for (i = 0; i < n; ++i) {\n    a = circles[i];\n    a.x -= c.x;\n    a.y -= c.y;\n  }\n  return c.r;\n}\n\nfunction packHierarchy(/*CircleWrap*/ parentCircle, shuffleFunc) {\n  var r = 0;\n  if (parentCircle.hasChildren()) {\n    //pack the children first because the radius is determined by how the children get packed (recursive)\n    for (var key in parentCircle.children) {\n      var circle = parentCircle.children[key];\n      if (circle.hasChildren()) {\n        circle.r = packHierarchy(circle, shuffleFunc);\n      }\n    }\n    //now that each circle has a radius set by its children, pack the circles at this level\n    r = packEnclose(Object.values(parentCircle.children), shuffleFunc);\n  }\n  return r;\n}\n\nfunction packHierarchyAndShift(/*CircleWrap*/ parentCircle, shuffleFunc) {\n  packHierarchy(parentCircle, shuffleFunc);\n  for (var key in parentCircle.children) {\n    var circle = parentCircle.children[key];\n    circle.applyPositionToChildren();\n  }\n}\n\n/**\n * Abstract function running the layout.\n *\n * @param  {Graph}    graph                   - Target  graph.\n * @param  {object}   [options]               - Options:\n * @param  {object}     [attributes]          - Attributes names to map.\n * @param  {number}     [center]              - Center of the layout.\n * @param  {string[]}   [hierarchyAttributes] - List of attributes used for the layout in decreasing order.\n * @param  {function}   [rng]                 - Custom RNG function to be used.\n * @param  {number}     [scale]               - Scale of the layout.\n * @return {object}                           - The positions by node.\n */\nfunction genericCirclePackLayout(assign, graph, options) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-layout/circlepack: the given graph is not a valid graphology instance.'\n    );\n\n  options = resolveDefaults(options, DEFAULTS);\n\n  var posMap = {},\n    positions = {},\n    nodes = graph.nodes(),\n    center = options.center,\n    hierarchyAttributes = options.hierarchyAttributes,\n    shuffleFunc = shuffle.createShuffleInPlace(options.rng),\n    scale = options.scale;\n\n  var container = new CircleWrap();\n\n  graph.forEachNode(function (key, attributes) {\n    var r = attributes.size ? attributes.size : 1;\n    var newCircleWrap = new CircleWrap(key, null, null, r);\n    var parentContainer = container;\n\n    hierarchyAttributes.forEach(function (v) {\n      var attr = attributes[v];\n      parentContainer = parentContainer.getChild(attr);\n    });\n\n    parentContainer.addChild(key, newCircleWrap);\n  });\n  packHierarchyAndShift(container, shuffleFunc);\n  setNode(graph, container, posMap);\n  var l = nodes.length,\n    x,\n    y,\n    i;\n  for (i = 0; i < l; i++) {\n    var node = nodes[i];\n\n    x = center + scale * posMap[node].x;\n    y = center + scale * posMap[node].y;\n\n    positions[node] = {\n      x: x,\n      y: y\n    };\n\n    if (assign) {\n      graph.setNodeAttribute(node, options.attributes.x, x);\n      graph.setNodeAttribute(node, options.attributes.y, y);\n    }\n  }\n  return positions;\n}\n\nvar circlePackLayout = genericCirclePackLayout.bind(null, false);\ncirclePackLayout.assign = genericCirclePackLayout.bind(null, true);\n\nmodule.exports = circlePackLayout;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQvY2lyY2xlcGFjay5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxvRkFBMkI7QUFDekQsY0FBYyxtQkFBTyxDQUFDLG9GQUEyQjtBQUNqRCxjQUFjLG1CQUFPLENBQUMsMEZBQThCOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxrQkFBa0I7QUFDaEMsb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksWUFBWTtBQUN4QixZQUFZLFlBQVk7QUFDeEIsWUFBWSxZQUFZO0FBQ3hCLFlBQVksWUFBWTtBQUN4QixZQUFZLFlBQVk7QUFDeEIsWUFBWSxrQ0FBa0M7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGlCQUFpQjtBQUNqQixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcG9uc2FydS8uL25vZGVfbW9kdWxlcy9ncmFwaG9sb2d5LWxheW91dC9jaXJjbGVwYWNrLmpzP2QwM2IiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHcmFwaG9sb2d5IENpcmNsZVBhY2sgTGF5b3V0XG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIENpcmNsZXBhY2sgbGF5b3V0IGZyb20gZDMtaGllcmFyY2h5L2dlcGhpLlxuICovXG52YXIgcmVzb2x2ZURlZmF1bHRzID0gcmVxdWlyZSgnZ3JhcGhvbG9neS11dGlscy9kZWZhdWx0cycpO1xudmFyIGlzR3JhcGggPSByZXF1aXJlKCdncmFwaG9sb2d5LXV0aWxzL2lzLWdyYXBoJyk7XG52YXIgc2h1ZmZsZSA9IHJlcXVpcmUoJ3BhbmRlbW9uaXVtL3NodWZmbGUtaW4tcGxhY2UnKTtcblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMuXG4gKi9cbnZhciBERUZBVUxUUyA9IHtcbiAgYXR0cmlidXRlczoge1xuICAgIHg6ICd4JyxcbiAgICB5OiAneSdcbiAgfSxcbiAgY2VudGVyOiAwLFxuICBoaWVyYXJjaHlBdHRyaWJ1dGVzOiBbXSxcbiAgcm5nOiBNYXRoLnJhbmRvbSxcbiAgc2NhbGU6IDFcbn07XG5cbi8qKlxuICogSGVscGVycy5cbiAqL1xuZnVuY3Rpb24gQ2lyY2xlV3JhcChpZCwgeCwgeSwgciwgY2lyY2xlV3JhcCkge1xuICB0aGlzLndyYXBwZWRDaXJjbGUgPSBjaXJjbGVXcmFwIHx8IG51bGw7IC8vaGFja3kgZDMgcmVmZXJlbmNlIHRoaW5nXG5cbiAgdGhpcy5jaGlsZHJlbiA9IHt9O1xuICB0aGlzLmNvdW50Q2hpbGRyZW4gPSAwO1xuICB0aGlzLmlkID0gaWQgfHwgbnVsbDtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5wcmV2aW91cyA9IG51bGw7XG5cbiAgdGhpcy54ID0geCB8fCBudWxsO1xuICB0aGlzLnkgPSB5IHx8IG51bGw7XG4gIGlmIChjaXJjbGVXcmFwKSB0aGlzLnIgPSAxMDEwMTAxO1xuICAvLyBmb3IgZGVidWdnaW5nIHB1cnBvc2VzIC0gc2hvdWxkIG5vdCBiZSB1c2VkIGluIHRoaXMgY2FzZVxuICBlbHNlIHRoaXMuciA9IHIgfHwgOTk5O1xufVxuXG5DaXJjbGVXcmFwLnByb3RvdHlwZS5oYXNDaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuY291bnRDaGlsZHJlbiA+IDA7XG59O1xuXG5DaXJjbGVXcmFwLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIChpZCwgY2hpbGQpIHtcbiAgdGhpcy5jaGlsZHJlbltpZF0gPSBjaGlsZDtcbiAgKyt0aGlzLmNvdW50Q2hpbGRyZW47XG59O1xuXG5DaXJjbGVXcmFwLnByb3RvdHlwZS5nZXRDaGlsZCA9IGZ1bmN0aW9uIChpZCkge1xuICBpZiAoIXRoaXMuY2hpbGRyZW4uaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgdmFyIGNpcmNsZVdyYXAgPSBuZXcgQ2lyY2xlV3JhcCgpO1xuICAgIHRoaXMuY2hpbGRyZW5baWRdID0gY2lyY2xlV3JhcDtcbiAgICArK3RoaXMuY291bnRDaGlsZHJlbjtcbiAgfVxuICByZXR1cm4gdGhpcy5jaGlsZHJlbltpZF07XG59O1xuXG5DaXJjbGVXcmFwLnByb3RvdHlwZS5hcHBseVBvc2l0aW9uVG9DaGlsZHJlbiA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKHRoaXMuaGFzQ2hpbGRyZW4oKSkge1xuICAgIHZhciByb290ID0gdGhpczsgLy8gdXNpbmcgJ3RoaXMnIGluIE9iamVjdC5rZXlzLmZvckVhY2ggc2VlbXMgYSBiYWQgaWRlYVxuICAgIGZvciAodmFyIGtleSBpbiByb290LmNoaWxkcmVuKSB7XG4gICAgICB2YXIgY2hpbGQgPSByb290LmNoaWxkcmVuW2tleV07XG4gICAgICBjaGlsZC54ICs9IHJvb3QueDtcbiAgICAgIGNoaWxkLnkgKz0gcm9vdC55O1xuICAgICAgY2hpbGQuYXBwbHlQb3NpdGlvblRvQ2hpbGRyZW4oKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNldE5vZGUoLypHcmFwaCovIGdyYXBoLCAvKkNpcmNsZVdyYXAqLyBwYXJlbnRDaXJjbGUsIC8qTWFwKi8gcG9zTWFwKSB7XG4gIGZvciAodmFyIGtleSBpbiBwYXJlbnRDaXJjbGUuY2hpbGRyZW4pIHtcbiAgICB2YXIgY2lyY2xlID0gcGFyZW50Q2lyY2xlLmNoaWxkcmVuW2tleV07XG4gICAgaWYgKGNpcmNsZS5oYXNDaGlsZHJlbigpKSB7XG4gICAgICBzZXROb2RlKGdyYXBoLCBjaXJjbGUsIHBvc01hcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc01hcFtjaXJjbGUuaWRdID0ge3g6IGNpcmNsZS54LCB5OiBjaXJjbGUueX07XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGVuY2xvc2VzTm90KC8qQ2lyY2xlV3JhcCovIGEsIC8qQ2lyY2xlV3JhcCovIGIpIHtcbiAgdmFyIGRyID0gYS5yIC0gYi5yO1xuICB2YXIgZHggPSBiLnggLSBhLng7XG4gIHZhciBkeSA9IGIueSAtIGEueTtcbiAgcmV0dXJuIGRyIDwgMCB8fCBkciAqIGRyIDwgZHggKiBkeCArIGR5ICogZHk7XG59XG5cbmZ1bmN0aW9uIGVuY2xvc2VzV2VhaygvKkNpcmNsZVdyYXAqLyBhLCAvKkNpcmNsZVdyYXAqLyBiKSB7XG4gIHZhciBkciA9IGEuciAtIGIuciArIDFlLTY7XG4gIHZhciBkeCA9IGIueCAtIGEueDtcbiAgdmFyIGR5ID0gYi55IC0gYS55O1xuICByZXR1cm4gZHIgPiAwICYmIGRyICogZHIgPiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZXNXZWFrQWxsKC8qQ2lyY2xlV3JhcCovIGEsIC8qQXJyYXk8Q2lyY2xlV3JhcD4qLyBCKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQi5sZW5ndGg7ICsraSkge1xuICAgIGlmICghZW5jbG9zZXNXZWFrKGEsIEJbaV0pKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMxKC8qQ2lyY2xlV3JhcCovIGEpIHtcbiAgcmV0dXJuIG5ldyBDaXJjbGVXcmFwKG51bGwsIGEueCwgYS55LCBhLnIpO1xufVxuXG5mdW5jdGlvbiBlbmNsb3NlQmFzaXMyKC8qQ2lyY2xlV3JhcCovIGEsIC8qQ2lyY2xlV3JhcCovIGIpIHtcbiAgdmFyIHgxID0gYS54LFxuICAgIHkxID0gYS55LFxuICAgIHIxID0gYS5yLFxuICAgIHgyID0gYi54LFxuICAgIHkyID0gYi55LFxuICAgIHIyID0gYi5yLFxuICAgIHgyMSA9IHgyIC0geDEsXG4gICAgeTIxID0geTIgLSB5MSxcbiAgICByMjEgPSByMiAtIHIxLFxuICAgIGwgPSBNYXRoLnNxcnQoeDIxICogeDIxICsgeTIxICogeTIxKTtcbiAgcmV0dXJuIG5ldyBDaXJjbGVXcmFwKFxuICAgIG51bGwsXG4gICAgKHgxICsgeDIgKyAoeDIxIC8gbCkgKiByMjEpIC8gMixcbiAgICAoeTEgKyB5MiArICh5MjEgLyBsKSAqIHIyMSkgLyAyLFxuICAgIChsICsgcjEgKyByMikgLyAyXG4gICk7XG59XG5cbmZ1bmN0aW9uIGVuY2xvc2VCYXNpczMoLypDaXJjbGVXcmFwKi8gYSwgLypDaXJjbGVXcmFwKi8gYiwgLypDaXJjbGVXcmFwKi8gYykge1xuICB2YXIgeDEgPSBhLngsXG4gICAgeTEgPSBhLnksXG4gICAgcjEgPSBhLnIsXG4gICAgeDIgPSBiLngsXG4gICAgeTIgPSBiLnksXG4gICAgcjIgPSBiLnIsXG4gICAgeDMgPSBjLngsXG4gICAgeTMgPSBjLnksXG4gICAgcjMgPSBjLnIsXG4gICAgYTIgPSB4MSAtIHgyLFxuICAgIGEzID0geDEgLSB4MyxcbiAgICBiMiA9IHkxIC0geTIsXG4gICAgYjMgPSB5MSAtIHkzLFxuICAgIGMyID0gcjIgLSByMSxcbiAgICBjMyA9IHIzIC0gcjEsXG4gICAgZDEgPSB4MSAqIHgxICsgeTEgKiB5MSAtIHIxICogcjEsXG4gICAgZDIgPSBkMSAtIHgyICogeDIgLSB5MiAqIHkyICsgcjIgKiByMixcbiAgICBkMyA9IGQxIC0geDMgKiB4MyAtIHkzICogeTMgKyByMyAqIHIzLFxuICAgIGFiID0gYTMgKiBiMiAtIGEyICogYjMsXG4gICAgeGEgPSAoYjIgKiBkMyAtIGIzICogZDIpIC8gKGFiICogMikgLSB4MSxcbiAgICB4YiA9IChiMyAqIGMyIC0gYjIgKiBjMykgLyBhYixcbiAgICB5YSA9IChhMyAqIGQyIC0gYTIgKiBkMykgLyAoYWIgKiAyKSAtIHkxLFxuICAgIHliID0gKGEyICogYzMgLSBhMyAqIGMyKSAvIGFiLFxuICAgIEEgPSB4YiAqIHhiICsgeWIgKiB5YiAtIDEsXG4gICAgQiA9IDIgKiAocjEgKyB4YSAqIHhiICsgeWEgKiB5YiksXG4gICAgQyA9IHhhICogeGEgKyB5YSAqIHlhIC0gcjEgKiByMSxcbiAgICByID0gLShBID8gKEIgKyBNYXRoLnNxcnQoQiAqIEIgLSA0ICogQSAqIEMpKSAvICgyICogQSkgOiBDIC8gQik7XG4gIHJldHVybiBuZXcgQ2lyY2xlV3JhcChudWxsLCB4MSArIHhhICsgeGIgKiByLCB5MSArIHlhICsgeWIgKiByLCByKTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZUJhc2lzKC8qQXJyYXk8Q2lyY2xlV3JhcD4qLyBCKSB7XG4gIHN3aXRjaCAoQi5sZW5ndGgpIHtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gZW5jbG9zZUJhc2lzMShCWzBdKTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gZW5jbG9zZUJhc2lzMihCWzBdLCBCWzFdKTtcbiAgICBjYXNlIDM6XG4gICAgICByZXR1cm4gZW5jbG9zZUJhc2lzMyhCWzBdLCBCWzFdLCBCWzJdKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnZ3JhcGhvbG9neS1sYXlvdXQvY2lyY2xlcGFjazogSW52YWxpZCBiYXNpcyBsZW5ndGggJyArIEIubGVuZ3RoXG4gICAgICApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV4dGVuZEJhc2lzKC8qQXJyYXk8Q2lyY2xlV3JhcD4qLyBCLCAvKkNpcmNsZVdyYXAqLyBwKSB7XG4gIHZhciBpLCBqO1xuXG4gIGlmIChlbmNsb3Nlc1dlYWtBbGwocCwgQikpIHJldHVybiBbcF07XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgdGhlbiBCIG11c3QgaGF2ZSBhdCBsZWFzdCBvbmUgZWxlbWVudC5cbiAgZm9yIChpID0gMDsgaSA8IEIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoZW5jbG9zZXNOb3QocCwgQltpXSkgJiYgZW5jbG9zZXNXZWFrQWxsKGVuY2xvc2VCYXNpczIoQltpXSwgcCksIEIpKSB7XG4gICAgICByZXR1cm4gW0JbaV0sIHBdO1xuICAgIH1cbiAgfVxuXG4gIC8vIElmIHdlIGdldCBoZXJlIHRoZW4gQiBtdXN0IGhhdmUgYXQgbGVhc3QgdHdvIGVsZW1lbnRzLlxuICBmb3IgKGkgPSAwOyBpIDwgQi5sZW5ndGggLSAxOyArK2kpIHtcbiAgICBmb3IgKGogPSBpICsgMTsgaiA8IEIubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmIChcbiAgICAgICAgZW5jbG9zZXNOb3QoZW5jbG9zZUJhc2lzMihCW2ldLCBCW2pdKSwgcCkgJiZcbiAgICAgICAgZW5jbG9zZXNOb3QoZW5jbG9zZUJhc2lzMihCW2ldLCBwKSwgQltqXSkgJiZcbiAgICAgICAgZW5jbG9zZXNOb3QoZW5jbG9zZUJhc2lzMihCW2pdLCBwKSwgQltpXSkgJiZcbiAgICAgICAgZW5jbG9zZXNXZWFrQWxsKGVuY2xvc2VCYXNpczMoQltpXSwgQltqXSwgcCksIEIpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIFtCW2ldLCBCW2pdLCBwXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBJZiB3ZSBnZXQgaGVyZSB0aGVuIHNvbWV0aGluZyBpcyB2ZXJ5IHdyb25nLlxuICB0aHJvdyBuZXcgRXJyb3IoJ2dyYXBob2xvZ3ktbGF5b3V0L2NpcmNsZXBhY2s6IGV4dGVuZEJhc2lzIGZhaWx1cmUgIScpO1xufVxuXG5mdW5jdGlvbiBzY29yZSgvKkNpcmNsZVdyYXAqLyBub2RlKSB7XG4gIHZhciBhID0gbm9kZS53cmFwcGVkQ2lyY2xlO1xuICB2YXIgYiA9IG5vZGUubmV4dC53cmFwcGVkQ2lyY2xlO1xuICB2YXIgYWIgPSBhLnIgKyBiLnI7XG4gIHZhciBkeCA9IChhLnggKiBiLnIgKyBiLnggKiBhLnIpIC8gYWI7XG4gIHZhciBkeSA9IChhLnkgKiBiLnIgKyBiLnkgKiBhLnIpIC8gYWI7XG4gIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gZW5jbG9zZShjaXJjbGVzLCBzaHVmZmxlRnVuYykge1xuICB2YXIgaSA9IDA7XG4gIHZhciBjaXJjbGVzTG9jID0gY2lyY2xlcy5zbGljZSgpO1xuXG4gIHZhciBuID0gY2lyY2xlcy5sZW5ndGg7XG4gIHZhciBCID0gW107XG4gIHZhciBwO1xuICB2YXIgZTtcbiAgc2h1ZmZsZUZ1bmMoY2lyY2xlc0xvYyk7XG4gIHdoaWxlIChpIDwgbikge1xuICAgIHAgPSBjaXJjbGVzTG9jW2ldO1xuICAgIGlmIChlICYmIGVuY2xvc2VzV2VhayhlLCBwKSkge1xuICAgICAgKytpO1xuICAgIH0gZWxzZSB7XG4gICAgICBCID0gZXh0ZW5kQmFzaXMoQiwgcCk7XG4gICAgICBlID0gZW5jbG9zZUJhc2lzKEIpO1xuICAgICAgaSA9IDA7XG4gICAgfVxuICB9XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBwbGFjZSgvKkNpcmNsZVdyYXAqLyBiLCAvKkNpcmNsZVdyYXAqLyBhLCAvKkNpcmNsZVdyYXAqLyBjKSB7XG4gIHZhciBkeCA9IGIueCAtIGEueCxcbiAgICB4LFxuICAgIGEyLFxuICAgIGR5ID0gYi55IC0gYS55LFxuICAgIHksXG4gICAgYjIsXG4gICAgZDIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgaWYgKGQyKSB7XG4gICAgYTIgPSBhLnIgKyBjLnI7XG4gICAgYTIgKj0gYTI7XG4gICAgYjIgPSBiLnIgKyBjLnI7XG4gICAgYjIgKj0gYjI7XG4gICAgaWYgKGEyID4gYjIpIHtcbiAgICAgIHggPSAoZDIgKyBiMiAtIGEyKSAvICgyICogZDIpO1xuICAgICAgeSA9IE1hdGguc3FydChNYXRoLm1heCgwLCBiMiAvIGQyIC0geCAqIHgpKTtcbiAgICAgIGMueCA9IGIueCAtIHggKiBkeCAtIHkgKiBkeTtcbiAgICAgIGMueSA9IGIueSAtIHggKiBkeSArIHkgKiBkeDtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IChkMiArIGEyIC0gYjIpIC8gKDIgKiBkMik7XG4gICAgICB5ID0gTWF0aC5zcXJ0KE1hdGgubWF4KDAsIGEyIC8gZDIgLSB4ICogeCkpO1xuICAgICAgYy54ID0gYS54ICsgeCAqIGR4IC0geSAqIGR5O1xuICAgICAgYy55ID0gYS55ICsgeCAqIGR5ICsgeSAqIGR4O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjLnggPSBhLnggKyBjLnI7XG4gICAgYy55ID0gYS55O1xuICB9XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdHMoLypDaXJjbGVXcmFwKi8gYSwgLypDaXJjbGVXcmFwKi8gYikge1xuICB2YXIgZHIgPSBhLnIgKyBiLnIgLSAxZS02LFxuICAgIGR4ID0gYi54IC0gYS54LFxuICAgIGR5ID0gYi55IC0gYS55O1xuICByZXR1cm4gZHIgPiAwICYmIGRyICogZHIgPiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuZnVuY3Rpb24gcGFja0VuY2xvc2UoLypBcnJheTxDaXJjbGVXcmFwPiovIGNpcmNsZXMsIHNodWZmbGVGdW5jKSB7XG4gIHZhciBuID0gY2lyY2xlcy5sZW5ndGg7XG4gIGlmIChuID09PSAwKSByZXR1cm4gMDtcblxuICB2YXIgYSwgYiwgYywgYWEsIGNhLCBpLCBqLCBrLCBzaiwgc2s7XG5cbiAgLy8gUGxhY2UgdGhlIGZpcnN0IGNpcmNsZS5cbiAgYSA9IGNpcmNsZXNbMF07XG4gIGEueCA9IDA7XG4gIGEueSA9IDA7XG4gIGlmIChuIDw9IDEpIHJldHVybiBhLnI7XG5cbiAgLy8gUGxhY2UgdGhlIHNlY29uZCBjaXJjbGUuXG4gIGIgPSBjaXJjbGVzWzFdO1xuICBhLnggPSAtYi5yO1xuICBiLnggPSBhLnI7XG4gIGIueSA9IDA7XG4gIGlmIChuIDw9IDIpIHJldHVybiBhLnIgKyBiLnI7XG5cbiAgLy8gUGxhY2UgdGhlIHRoaXJkIGNpcmNsZS5cbiAgYyA9IGNpcmNsZXNbMl07XG4gIHBsYWNlKGIsIGEsIGMpO1xuXG4gIC8vIEluaXRpYWxpemUgdGhlIGZyb250LWNoYWluIHVzaW5nIHRoZSBmaXJzdCB0aHJlZSBjaXJjbGVzIGEsIGIgYW5kIGMuXG4gIGEgPSBuZXcgQ2lyY2xlV3JhcChudWxsLCBudWxsLCBudWxsLCBudWxsLCBhKTtcbiAgYiA9IG5ldyBDaXJjbGVXcmFwKG51bGwsIG51bGwsIG51bGwsIG51bGwsIGIpO1xuICBjID0gbmV3IENpcmNsZVdyYXAobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgYyk7XG4gIGEubmV4dCA9IGMucHJldmlvdXMgPSBiO1xuICBiLm5leHQgPSBhLnByZXZpb3VzID0gYztcbiAgYy5uZXh0ID0gYi5wcmV2aW91cyA9IGE7XG5cbiAgLy8gQXR0ZW1wdCB0byBwbGFjZSBlYWNoIHJlbWFpbmluZyBjaXJjbGXigKZcbiAgcGFjazogZm9yIChpID0gMzsgaSA8IG47ICsraSkge1xuICAgIGMgPSBjaXJjbGVzW2ldO1xuICAgIHBsYWNlKGEud3JhcHBlZENpcmNsZSwgYi53cmFwcGVkQ2lyY2xlLCBjKTtcbiAgICBjID0gbmV3IENpcmNsZVdyYXAobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgYyk7XG5cbiAgICAvLyBGaW5kIHRoZSBjbG9zZXN0IGludGVyc2VjdGluZyBjaXJjbGUgb24gdGhlIGZyb250LWNoYWluLCBpZiBhbnkuXG4gICAgLy8g4oCcQ2xvc2VuZXNz4oCdIGlzIGRldGVybWluZWQgYnkgbGluZWFyIGRpc3RhbmNlIGFsb25nIHRoZSBmcm9udC1jaGFpbi5cbiAgICAvLyDigJxBaGVhZOKAnSBvciDigJxiZWhpbmTigJ0gaXMgbGlrZXdpc2UgZGV0ZXJtaW5lZCBieSBsaW5lYXIgZGlzdGFuY2UuXG4gICAgaiA9IGIubmV4dDtcbiAgICBrID0gYS5wcmV2aW91cztcbiAgICBzaiA9IGIud3JhcHBlZENpcmNsZS5yO1xuICAgIHNrID0gYS53cmFwcGVkQ2lyY2xlLnI7XG4gICAgZG8ge1xuICAgICAgaWYgKHNqIDw9IHNrKSB7XG4gICAgICAgIGlmIChpbnRlcnNlY3RzKGoud3JhcHBlZENpcmNsZSwgYy53cmFwcGVkQ2lyY2xlKSkge1xuICAgICAgICAgIGIgPSBqO1xuICAgICAgICAgIGEubmV4dCA9IGI7XG4gICAgICAgICAgYi5wcmV2aW91cyA9IGE7XG4gICAgICAgICAgLS1pO1xuICAgICAgICAgIGNvbnRpbnVlIHBhY2s7XG4gICAgICAgIH1cbiAgICAgICAgc2ogKz0gai53cmFwcGVkQ2lyY2xlLnI7XG4gICAgICAgIGogPSBqLm5leHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaW50ZXJzZWN0cyhrLndyYXBwZWRDaXJjbGUsIGMud3JhcHBlZENpcmNsZSkpIHtcbiAgICAgICAgICBhID0gaztcbiAgICAgICAgICBhLm5leHQgPSBiO1xuICAgICAgICAgIGIucHJldmlvdXMgPSBhO1xuICAgICAgICAgIC0taTtcbiAgICAgICAgICBjb250aW51ZSBwYWNrO1xuICAgICAgICB9XG4gICAgICAgIHNrICs9IGsud3JhcHBlZENpcmNsZS5yO1xuICAgICAgICBrID0gay5wcmV2aW91cztcbiAgICAgIH1cbiAgICB9IHdoaWxlIChqICE9PSBrLm5leHQpO1xuXG4gICAgLy8gU3VjY2VzcyEgSW5zZXJ0IHRoZSBuZXcgY2lyY2xlIGMgYmV0d2VlbiBhIGFuZCBiLlxuICAgIGMucHJldmlvdXMgPSBhO1xuICAgIGMubmV4dCA9IGI7XG4gICAgYS5uZXh0ID0gYi5wcmV2aW91cyA9IGIgPSBjO1xuXG4gICAgLy8gQ29tcHV0ZSB0aGUgbmV3IGNsb3Nlc3QgY2lyY2xlIHBhaXIgdG8gdGhlIGNlbnRyb2lkLlxuICAgIGFhID0gc2NvcmUoYSk7XG4gICAgd2hpbGUgKChjID0gYy5uZXh0KSAhPT0gYikge1xuICAgICAgaWYgKChjYSA9IHNjb3JlKGMpKSA8IGFhKSB7XG4gICAgICAgIGEgPSBjO1xuICAgICAgICBhYSA9IGNhO1xuICAgICAgfVxuICAgIH1cbiAgICBiID0gYS5uZXh0O1xuICB9XG5cbiAgLy8gQ29tcHV0ZSB0aGUgZW5jbG9zaW5nIGNpcmNsZSBvZiB0aGUgZnJvbnQgY2hhaW4uXG4gIGEgPSBbYi53cmFwcGVkQ2lyY2xlXTtcbiAgYyA9IGI7XG4gIHZhciBzYWZldHkgPSAxMDAwMDtcbiAgd2hpbGUgKChjID0gYy5uZXh0KSAhPT0gYikge1xuICAgIGlmICgtLXNhZmV0eSA9PT0gMCkge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGEucHVzaChjLndyYXBwZWRDaXJjbGUpO1xuICB9XG4gIGMgPSBlbmNsb3NlKGEsIHNodWZmbGVGdW5jKTtcblxuICAvLyBUcmFuc2xhdGUgdGhlIGNpcmNsZXMgdG8gcHV0IHRoZSBlbmNsb3NpbmcgY2lyY2xlIGFyb3VuZCB0aGUgb3JpZ2luLlxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgYSA9IGNpcmNsZXNbaV07XG4gICAgYS54IC09IGMueDtcbiAgICBhLnkgLT0gYy55O1xuICB9XG4gIHJldHVybiBjLnI7XG59XG5cbmZ1bmN0aW9uIHBhY2tIaWVyYXJjaHkoLypDaXJjbGVXcmFwKi8gcGFyZW50Q2lyY2xlLCBzaHVmZmxlRnVuYykge1xuICB2YXIgciA9IDA7XG4gIGlmIChwYXJlbnRDaXJjbGUuaGFzQ2hpbGRyZW4oKSkge1xuICAgIC8vcGFjayB0aGUgY2hpbGRyZW4gZmlyc3QgYmVjYXVzZSB0aGUgcmFkaXVzIGlzIGRldGVybWluZWQgYnkgaG93IHRoZSBjaGlsZHJlbiBnZXQgcGFja2VkIChyZWN1cnNpdmUpXG4gICAgZm9yICh2YXIga2V5IGluIHBhcmVudENpcmNsZS5jaGlsZHJlbikge1xuICAgICAgdmFyIGNpcmNsZSA9IHBhcmVudENpcmNsZS5jaGlsZHJlbltrZXldO1xuICAgICAgaWYgKGNpcmNsZS5oYXNDaGlsZHJlbigpKSB7XG4gICAgICAgIGNpcmNsZS5yID0gcGFja0hpZXJhcmNoeShjaXJjbGUsIHNodWZmbGVGdW5jKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy9ub3cgdGhhdCBlYWNoIGNpcmNsZSBoYXMgYSByYWRpdXMgc2V0IGJ5IGl0cyBjaGlsZHJlbiwgcGFjayB0aGUgY2lyY2xlcyBhdCB0aGlzIGxldmVsXG4gICAgciA9IHBhY2tFbmNsb3NlKE9iamVjdC52YWx1ZXMocGFyZW50Q2lyY2xlLmNoaWxkcmVuKSwgc2h1ZmZsZUZ1bmMpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBwYWNrSGllcmFyY2h5QW5kU2hpZnQoLypDaXJjbGVXcmFwKi8gcGFyZW50Q2lyY2xlLCBzaHVmZmxlRnVuYykge1xuICBwYWNrSGllcmFyY2h5KHBhcmVudENpcmNsZSwgc2h1ZmZsZUZ1bmMpO1xuICBmb3IgKHZhciBrZXkgaW4gcGFyZW50Q2lyY2xlLmNoaWxkcmVuKSB7XG4gICAgdmFyIGNpcmNsZSA9IHBhcmVudENpcmNsZS5jaGlsZHJlbltrZXldO1xuICAgIGNpcmNsZS5hcHBseVBvc2l0aW9uVG9DaGlsZHJlbigpO1xuICB9XG59XG5cbi8qKlxuICogQWJzdHJhY3QgZnVuY3Rpb24gcnVubmluZyB0aGUgbGF5b3V0LlxuICpcbiAqIEBwYXJhbSAge0dyYXBofSAgICBncmFwaCAgICAgICAgICAgICAgICAgICAtIFRhcmdldCAgZ3JhcGguXG4gKiBAcGFyYW0gIHtvYmplY3R9ICAgW29wdGlvbnNdICAgICAgICAgICAgICAgLSBPcHRpb25zOlxuICogQHBhcmFtICB7b2JqZWN0fSAgICAgW2F0dHJpYnV0ZXNdICAgICAgICAgIC0gQXR0cmlidXRlcyBuYW1lcyB0byBtYXAuXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgICBbY2VudGVyXSAgICAgICAgICAgICAgLSBDZW50ZXIgb2YgdGhlIGxheW91dC5cbiAqIEBwYXJhbSAge3N0cmluZ1tdfSAgIFtoaWVyYXJjaHlBdHRyaWJ1dGVzXSAtIExpc3Qgb2YgYXR0cmlidXRlcyB1c2VkIGZvciB0aGUgbGF5b3V0IGluIGRlY3JlYXNpbmcgb3JkZXIuXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gICBbcm5nXSAgICAgICAgICAgICAgICAgLSBDdXN0b20gUk5HIGZ1bmN0aW9uIHRvIGJlIHVzZWQuXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgICBbc2NhbGVdICAgICAgICAgICAgICAgLSBTY2FsZSBvZiB0aGUgbGF5b3V0LlxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gVGhlIHBvc2l0aW9ucyBieSBub2RlLlxuICovXG5mdW5jdGlvbiBnZW5lcmljQ2lyY2xlUGFja0xheW91dChhc3NpZ24sIGdyYXBoLCBvcHRpb25zKSB7XG4gIGlmICghaXNHcmFwaChncmFwaCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2dyYXBob2xvZ3ktbGF5b3V0L2NpcmNsZXBhY2s6IHRoZSBnaXZlbiBncmFwaCBpcyBub3QgYSB2YWxpZCBncmFwaG9sb2d5IGluc3RhbmNlLidcbiAgICApO1xuXG4gIG9wdGlvbnMgPSByZXNvbHZlRGVmYXVsdHMob3B0aW9ucywgREVGQVVMVFMpO1xuXG4gIHZhciBwb3NNYXAgPSB7fSxcbiAgICBwb3NpdGlvbnMgPSB7fSxcbiAgICBub2RlcyA9IGdyYXBoLm5vZGVzKCksXG4gICAgY2VudGVyID0gb3B0aW9ucy5jZW50ZXIsXG4gICAgaGllcmFyY2h5QXR0cmlidXRlcyA9IG9wdGlvbnMuaGllcmFyY2h5QXR0cmlidXRlcyxcbiAgICBzaHVmZmxlRnVuYyA9IHNodWZmbGUuY3JlYXRlU2h1ZmZsZUluUGxhY2Uob3B0aW9ucy5ybmcpLFxuICAgIHNjYWxlID0gb3B0aW9ucy5zY2FsZTtcblxuICB2YXIgY29udGFpbmVyID0gbmV3IENpcmNsZVdyYXAoKTtcblxuICBncmFwaC5mb3JFYWNoTm9kZShmdW5jdGlvbiAoa2V5LCBhdHRyaWJ1dGVzKSB7XG4gICAgdmFyIHIgPSBhdHRyaWJ1dGVzLnNpemUgPyBhdHRyaWJ1dGVzLnNpemUgOiAxO1xuICAgIHZhciBuZXdDaXJjbGVXcmFwID0gbmV3IENpcmNsZVdyYXAoa2V5LCBudWxsLCBudWxsLCByKTtcbiAgICB2YXIgcGFyZW50Q29udGFpbmVyID0gY29udGFpbmVyO1xuXG4gICAgaGllcmFyY2h5QXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgICB2YXIgYXR0ciA9IGF0dHJpYnV0ZXNbdl07XG4gICAgICBwYXJlbnRDb250YWluZXIgPSBwYXJlbnRDb250YWluZXIuZ2V0Q2hpbGQoYXR0cik7XG4gICAgfSk7XG5cbiAgICBwYXJlbnRDb250YWluZXIuYWRkQ2hpbGQoa2V5LCBuZXdDaXJjbGVXcmFwKTtcbiAgfSk7XG4gIHBhY2tIaWVyYXJjaHlBbmRTaGlmdChjb250YWluZXIsIHNodWZmbGVGdW5jKTtcbiAgc2V0Tm9kZShncmFwaCwgY29udGFpbmVyLCBwb3NNYXApO1xuICB2YXIgbCA9IG5vZGVzLmxlbmd0aCxcbiAgICB4LFxuICAgIHksXG4gICAgaTtcbiAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgIHZhciBub2RlID0gbm9kZXNbaV07XG5cbiAgICB4ID0gY2VudGVyICsgc2NhbGUgKiBwb3NNYXBbbm9kZV0ueDtcbiAgICB5ID0gY2VudGVyICsgc2NhbGUgKiBwb3NNYXBbbm9kZV0ueTtcblxuICAgIHBvc2l0aW9uc1tub2RlXSA9IHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfTtcblxuICAgIGlmIChhc3NpZ24pIHtcbiAgICAgIGdyYXBoLnNldE5vZGVBdHRyaWJ1dGUobm9kZSwgb3B0aW9ucy5hdHRyaWJ1dGVzLngsIHgpO1xuICAgICAgZ3JhcGguc2V0Tm9kZUF0dHJpYnV0ZShub2RlLCBvcHRpb25zLmF0dHJpYnV0ZXMueSwgeSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwb3NpdGlvbnM7XG59XG5cbnZhciBjaXJjbGVQYWNrTGF5b3V0ID0gZ2VuZXJpY0NpcmNsZVBhY2tMYXlvdXQuYmluZChudWxsLCBmYWxzZSk7XG5jaXJjbGVQYWNrTGF5b3V0LmFzc2lnbiA9IGdlbmVyaWNDaXJjbGVQYWNrTGF5b3V0LmJpbmQobnVsbCwgdHJ1ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gY2lyY2xlUGFja0xheW91dDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-layout/circlepack.js\n");

/***/ })

};
;