/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/graphology-generators";
exports.ids = ["vendor-chunks/graphology-generators"];
exports.modules = {

/***/ "(ssr)/./node_modules/graphology-generators/random/clusters.js":
/*!***************************************************************!*\
  !*** ./node_modules/graphology-generators/random/clusters.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Graphology Random Clusters Graph Generator\n * ===========================================\n *\n * Function generating a graph containing the desired number of nodes & edges\n * and organized in the desired number of clusters.\n *\n * [Author]:\n * Alexis Jacomy\n */\nvar isGraphConstructor = __webpack_require__(/*! graphology-utils/is-graph-constructor */ \"(ssr)/./node_modules/graphology-utils/is-graph-constructor.js\");\n\n/**\n * Generates a random graph with clusters.\n *\n * @param  {Class}    GraphClass    - The Graph Class to instantiate.\n * @param  {object}   options       - Options:\n * @param  {number}     clusterDensity - Probability that an edge will link two\n *                                       nodes of the same cluster.\n * @param  {number}     order          - Number of nodes.\n * @param  {number}     size           - Number of edges.\n * @param  {number}     clusters       - Number of clusters.\n * @param  {function}   rng            - Custom RNG function.\n * @return {Graph}\n */\nmodule.exports = function (GraphClass, options) {\n  if (!isGraphConstructor(GraphClass))\n    throw new Error(\n      'graphology-generators/random/clusters: invalid Graph constructor.'\n    );\n\n  options = options || {};\n\n  var clusterDensity =\n      'clusterDensity' in options ? options.clusterDensity : 0.5,\n    rng = options.rng || Math.random,\n    N = options.order,\n    E = options.size,\n    C = options.clusters;\n\n  if (\n    typeof clusterDensity !== 'number' ||\n    clusterDensity > 1 ||\n    clusterDensity < 0\n  )\n    throw new Error(\n      'graphology-generators/random/clusters: `clusterDensity` option should be a number between 0 and 1.'\n    );\n\n  if (typeof rng !== 'function')\n    throw new Error(\n      'graphology-generators/random/clusters: `rng` option should be a function.'\n    );\n\n  if (typeof N !== 'number' || N <= 0)\n    throw new Error(\n      'graphology-generators/random/clusters: `order` option should be a positive number.'\n    );\n\n  if (typeof E !== 'number' || E <= 0)\n    throw new Error(\n      'graphology-generators/random/clusters: `size` option should be a positive number.'\n    );\n\n  if (typeof C !== 'number' || C <= 0)\n    throw new Error(\n      'graphology-generators/random/clusters: `clusters` option should be a positive number.'\n    );\n\n  // Creating graph\n  var graph = new GraphClass();\n\n  // Adding nodes\n  if (!N) return graph;\n\n  // Initializing clusters\n  var clusters = new Array(C),\n    cluster,\n    nodes,\n    i;\n\n  for (i = 0; i < C; i++) clusters[i] = [];\n\n  for (i = 0; i < N; i++) {\n    cluster = (rng() * C) | 0;\n    graph.addNode(i, {cluster: cluster});\n    clusters[cluster].push(i);\n  }\n\n  // Adding edges\n  if (!E) return graph;\n\n  var source, target, l;\n\n  for (i = 0; i < E; i++) {\n    // Adding a link between two random nodes\n    if (rng() < 1 - clusterDensity) {\n      source = (rng() * N) | 0;\n\n      do {\n        target = (rng() * N) | 0;\n      } while (source === target);\n    }\n\n    // Adding a link between two nodes from the same cluster\n    else {\n      cluster = (rng() * C) | 0;\n      nodes = clusters[cluster];\n      l = nodes.length;\n\n      if (!l || l < 2) {\n        // TODO: in those case we may have fewer edges than required\n        // TODO: check where E is over full clusterDensity\n        continue;\n      }\n\n      source = nodes[(rng() * l) | 0];\n\n      do {\n        target = nodes[(rng() * l) | 0];\n      } while (source === target);\n    }\n\n    if (!graph.multi) graph.mergeEdge(source, target);\n    else graph.addEdge(source, target);\n  }\n\n  return graph;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1nZW5lcmF0b3JzL3JhbmRvbS9jbHVzdGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixtQkFBTyxDQUFDLDRHQUF1Qzs7QUFFeEU7QUFDQTtBQUNBO0FBQ0EsWUFBWSxVQUFVO0FBQ3RCLFlBQVksVUFBVTtBQUN0QixZQUFZLFlBQVk7QUFDeEI7QUFDQSxZQUFZLFlBQVk7QUFDeEIsWUFBWSxZQUFZO0FBQ3hCLFlBQVksWUFBWTtBQUN4QixZQUFZLFlBQVk7QUFDeEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLE9BQU87O0FBRXJCLGNBQWMsT0FBTztBQUNyQjtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Nwb25zYXJ1Ly4vbm9kZV9tb2R1bGVzL2dyYXBob2xvZ3ktZ2VuZXJhdG9ycy9yYW5kb20vY2x1c3RlcnMuanM/NTdmMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEdyYXBob2xvZ3kgUmFuZG9tIENsdXN0ZXJzIEdyYXBoIEdlbmVyYXRvclxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIEZ1bmN0aW9uIGdlbmVyYXRpbmcgYSBncmFwaCBjb250YWluaW5nIHRoZSBkZXNpcmVkIG51bWJlciBvZiBub2RlcyAmIGVkZ2VzXG4gKiBhbmQgb3JnYW5pemVkIGluIHRoZSBkZXNpcmVkIG51bWJlciBvZiBjbHVzdGVycy5cbiAqXG4gKiBbQXV0aG9yXTpcbiAqIEFsZXhpcyBKYWNvbXlcbiAqL1xudmFyIGlzR3JhcGhDb25zdHJ1Y3RvciA9IHJlcXVpcmUoJ2dyYXBob2xvZ3ktdXRpbHMvaXMtZ3JhcGgtY29uc3RydWN0b3InKTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gZ3JhcGggd2l0aCBjbHVzdGVycy5cbiAqXG4gKiBAcGFyYW0gIHtDbGFzc30gICAgR3JhcGhDbGFzcyAgICAtIFRoZSBHcmFwaCBDbGFzcyB0byBpbnN0YW50aWF0ZS5cbiAqIEBwYXJhbSAge29iamVjdH0gICBvcHRpb25zICAgICAgIC0gT3B0aW9uczpcbiAqIEBwYXJhbSAge251bWJlcn0gICAgIGNsdXN0ZXJEZW5zaXR5IC0gUHJvYmFiaWxpdHkgdGhhdCBhbiBlZGdlIHdpbGwgbGluayB0d29cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXMgb2YgdGhlIHNhbWUgY2x1c3Rlci5cbiAqIEBwYXJhbSAge251bWJlcn0gICAgIG9yZGVyICAgICAgICAgIC0gTnVtYmVyIG9mIG5vZGVzLlxuICogQHBhcmFtICB7bnVtYmVyfSAgICAgc2l6ZSAgICAgICAgICAgLSBOdW1iZXIgb2YgZWRnZXMuXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgICBjbHVzdGVycyAgICAgICAtIE51bWJlciBvZiBjbHVzdGVycy5cbiAqIEBwYXJhbSAge2Z1bmN0aW9ufSAgIHJuZyAgICAgICAgICAgIC0gQ3VzdG9tIFJORyBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0dyYXBofVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChHcmFwaENsYXNzLCBvcHRpb25zKSB7XG4gIGlmICghaXNHcmFwaENvbnN0cnVjdG9yKEdyYXBoQ2xhc3MpKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdncmFwaG9sb2d5LWdlbmVyYXRvcnMvcmFuZG9tL2NsdXN0ZXJzOiBpbnZhbGlkIEdyYXBoIGNvbnN0cnVjdG9yLidcbiAgICApO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIHZhciBjbHVzdGVyRGVuc2l0eSA9XG4gICAgICAnY2x1c3RlckRlbnNpdHknIGluIG9wdGlvbnMgPyBvcHRpb25zLmNsdXN0ZXJEZW5zaXR5IDogMC41LFxuICAgIHJuZyA9IG9wdGlvbnMucm5nIHx8IE1hdGgucmFuZG9tLFxuICAgIE4gPSBvcHRpb25zLm9yZGVyLFxuICAgIEUgPSBvcHRpb25zLnNpemUsXG4gICAgQyA9IG9wdGlvbnMuY2x1c3RlcnM7XG5cbiAgaWYgKFxuICAgIHR5cGVvZiBjbHVzdGVyRGVuc2l0eSAhPT0gJ251bWJlcicgfHxcbiAgICBjbHVzdGVyRGVuc2l0eSA+IDEgfHxcbiAgICBjbHVzdGVyRGVuc2l0eSA8IDBcbiAgKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdncmFwaG9sb2d5LWdlbmVyYXRvcnMvcmFuZG9tL2NsdXN0ZXJzOiBgY2x1c3RlckRlbnNpdHlgIG9wdGlvbiBzaG91bGQgYmUgYSBudW1iZXIgYmV0d2VlbiAwIGFuZCAxLidcbiAgICApO1xuXG4gIGlmICh0eXBlb2Ygcm5nICE9PSAnZnVuY3Rpb24nKVxuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdncmFwaG9sb2d5LWdlbmVyYXRvcnMvcmFuZG9tL2NsdXN0ZXJzOiBgcm5nYCBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24uJ1xuICAgICk7XG5cbiAgaWYgKHR5cGVvZiBOICE9PSAnbnVtYmVyJyB8fCBOIDw9IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2dyYXBob2xvZ3ktZ2VuZXJhdG9ycy9yYW5kb20vY2x1c3RlcnM6IGBvcmRlcmAgb3B0aW9uIHNob3VsZCBiZSBhIHBvc2l0aXZlIG51bWJlci4nXG4gICAgKTtcblxuICBpZiAodHlwZW9mIEUgIT09ICdudW1iZXInIHx8IEUgPD0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnZ3JhcGhvbG9neS1nZW5lcmF0b3JzL3JhbmRvbS9jbHVzdGVyczogYHNpemVgIG9wdGlvbiBzaG91bGQgYmUgYSBwb3NpdGl2ZSBudW1iZXIuJ1xuICAgICk7XG5cbiAgaWYgKHR5cGVvZiBDICE9PSAnbnVtYmVyJyB8fCBDIDw9IDApXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2dyYXBob2xvZ3ktZ2VuZXJhdG9ycy9yYW5kb20vY2x1c3RlcnM6IGBjbHVzdGVyc2Agb3B0aW9uIHNob3VsZCBiZSBhIHBvc2l0aXZlIG51bWJlci4nXG4gICAgKTtcblxuICAvLyBDcmVhdGluZyBncmFwaFxuICB2YXIgZ3JhcGggPSBuZXcgR3JhcGhDbGFzcygpO1xuXG4gIC8vIEFkZGluZyBub2Rlc1xuICBpZiAoIU4pIHJldHVybiBncmFwaDtcblxuICAvLyBJbml0aWFsaXppbmcgY2x1c3RlcnNcbiAgdmFyIGNsdXN0ZXJzID0gbmV3IEFycmF5KEMpLFxuICAgIGNsdXN0ZXIsXG4gICAgbm9kZXMsXG4gICAgaTtcblxuICBmb3IgKGkgPSAwOyBpIDwgQzsgaSsrKSBjbHVzdGVyc1tpXSA9IFtdO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICBjbHVzdGVyID0gKHJuZygpICogQykgfCAwO1xuICAgIGdyYXBoLmFkZE5vZGUoaSwge2NsdXN0ZXI6IGNsdXN0ZXJ9KTtcbiAgICBjbHVzdGVyc1tjbHVzdGVyXS5wdXNoKGkpO1xuICB9XG5cbiAgLy8gQWRkaW5nIGVkZ2VzXG4gIGlmICghRSkgcmV0dXJuIGdyYXBoO1xuXG4gIHZhciBzb3VyY2UsIHRhcmdldCwgbDtcblxuICBmb3IgKGkgPSAwOyBpIDwgRTsgaSsrKSB7XG4gICAgLy8gQWRkaW5nIGEgbGluayBiZXR3ZWVuIHR3byByYW5kb20gbm9kZXNcbiAgICBpZiAocm5nKCkgPCAxIC0gY2x1c3RlckRlbnNpdHkpIHtcbiAgICAgIHNvdXJjZSA9IChybmcoKSAqIE4pIHwgMDtcblxuICAgICAgZG8ge1xuICAgICAgICB0YXJnZXQgPSAocm5nKCkgKiBOKSB8IDA7XG4gICAgICB9IHdoaWxlIChzb3VyY2UgPT09IHRhcmdldCk7XG4gICAgfVxuXG4gICAgLy8gQWRkaW5nIGEgbGluayBiZXR3ZWVuIHR3byBub2RlcyBmcm9tIHRoZSBzYW1lIGNsdXN0ZXJcbiAgICBlbHNlIHtcbiAgICAgIGNsdXN0ZXIgPSAocm5nKCkgKiBDKSB8IDA7XG4gICAgICBub2RlcyA9IGNsdXN0ZXJzW2NsdXN0ZXJdO1xuICAgICAgbCA9IG5vZGVzLmxlbmd0aDtcblxuICAgICAgaWYgKCFsIHx8IGwgPCAyKSB7XG4gICAgICAgIC8vIFRPRE86IGluIHRob3NlIGNhc2Ugd2UgbWF5IGhhdmUgZmV3ZXIgZWRnZXMgdGhhbiByZXF1aXJlZFxuICAgICAgICAvLyBUT0RPOiBjaGVjayB3aGVyZSBFIGlzIG92ZXIgZnVsbCBjbHVzdGVyRGVuc2l0eVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgc291cmNlID0gbm9kZXNbKHJuZygpICogbCkgfCAwXTtcblxuICAgICAgZG8ge1xuICAgICAgICB0YXJnZXQgPSBub2Rlc1socm5nKCkgKiBsKSB8IDBdO1xuICAgICAgfSB3aGlsZSAoc291cmNlID09PSB0YXJnZXQpO1xuICAgIH1cblxuICAgIGlmICghZ3JhcGgubXVsdGkpIGdyYXBoLm1lcmdlRWRnZShzb3VyY2UsIHRhcmdldCk7XG4gICAgZWxzZSBncmFwaC5hZGRFZGdlKHNvdXJjZSwgdGFyZ2V0KTtcbiAgfVxuXG4gIHJldHVybiBncmFwaDtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-generators/random/clusters.js\n");

/***/ })

};
;