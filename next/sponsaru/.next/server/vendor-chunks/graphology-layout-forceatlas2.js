/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/graphology-layout-forceatlas2";
exports.ids = ["vendor-chunks/graphology-layout-forceatlas2"];
exports.modules = {

/***/ "(ssr)/./node_modules/graphology-layout-forceatlas2/defaults.js":
/*!****************************************************************!*\
  !*** ./node_modules/graphology-layout-forceatlas2/defaults.js ***!
  \****************************************************************/
/***/ ((module) => {

eval("/**\n * Graphology ForceAtlas2 Layout Default Settings\n * ===============================================\n */\nmodule.exports = {\n  linLogMode: false,\n  outboundAttractionDistribution: false,\n  adjustSizes: false,\n  edgeWeightInfluence: 1,\n  scalingRatio: 1,\n  strongGravityMode: false,\n  gravity: 1,\n  slowDown: 1,\n  barnesHutOptimize: false,\n  barnesHutTheta: 0.5\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQtZm9yY2VhdGxhczIvZGVmYXVsdHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zcG9uc2FydS8uL25vZGVfbW9kdWxlcy9ncmFwaG9sb2d5LWxheW91dC1mb3JjZWF0bGFzMi9kZWZhdWx0cy5qcz9kYmVjIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR3JhcGhvbG9neSBGb3JjZUF0bGFzMiBMYXlvdXQgRGVmYXVsdCBTZXR0aW5nc1xuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGxpbkxvZ01vZGU6IGZhbHNlLFxuICBvdXRib3VuZEF0dHJhY3Rpb25EaXN0cmlidXRpb246IGZhbHNlLFxuICBhZGp1c3RTaXplczogZmFsc2UsXG4gIGVkZ2VXZWlnaHRJbmZsdWVuY2U6IDEsXG4gIHNjYWxpbmdSYXRpbzogMSxcbiAgc3Ryb25nR3Jhdml0eU1vZGU6IGZhbHNlLFxuICBncmF2aXR5OiAxLFxuICBzbG93RG93bjogMSxcbiAgYmFybmVzSHV0T3B0aW1pemU6IGZhbHNlLFxuICBiYXJuZXNIdXRUaGV0YTogMC41XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-layout-forceatlas2/defaults.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/graphology-layout-forceatlas2/helpers.js":
/*!***************************************************************!*\
  !*** ./node_modules/graphology-layout-forceatlas2/helpers.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * Graphology ForceAtlas2 Helpers\n * ===============================\n *\n * Miscellaneous helper functions.\n */\n\n/**\n * Constants.\n */\nvar PPN = 10;\nvar PPE = 3;\n\n/**\n * Very simple Object.assign-like function.\n *\n * @param  {object} target       - First object.\n * @param  {object} [...objects] - Objects to merge.\n * @return {object}\n */\nexports.assign = function (target) {\n  target = target || {};\n\n  var objects = Array.prototype.slice.call(arguments).slice(1),\n    i,\n    k,\n    l;\n\n  for (i = 0, l = objects.length; i < l; i++) {\n    if (!objects[i]) continue;\n\n    for (k in objects[i]) target[k] = objects[i][k];\n  }\n\n  return target;\n};\n\n/**\n * Function used to validate the given settings.\n *\n * @param  {object}      settings - Settings to validate.\n * @return {object|null}\n */\nexports.validateSettings = function (settings) {\n  if ('linLogMode' in settings && typeof settings.linLogMode !== 'boolean')\n    return {message: 'the `linLogMode` setting should be a boolean.'};\n\n  if (\n    'outboundAttractionDistribution' in settings &&\n    typeof settings.outboundAttractionDistribution !== 'boolean'\n  )\n    return {\n      message:\n        'the `outboundAttractionDistribution` setting should be a boolean.'\n    };\n\n  if ('adjustSizes' in settings && typeof settings.adjustSizes !== 'boolean')\n    return {message: 'the `adjustSizes` setting should be a boolean.'};\n\n  if (\n    'edgeWeightInfluence' in settings &&\n    typeof settings.edgeWeightInfluence !== 'number'\n  )\n    return {\n      message: 'the `edgeWeightInfluence` setting should be a number.'\n    };\n\n  if (\n    'scalingRatio' in settings &&\n    !(typeof settings.scalingRatio === 'number' && settings.scalingRatio >= 0)\n  )\n    return {message: 'the `scalingRatio` setting should be a number >= 0.'};\n\n  if (\n    'strongGravityMode' in settings &&\n    typeof settings.strongGravityMode !== 'boolean'\n  )\n    return {message: 'the `strongGravityMode` setting should be a boolean.'};\n\n  if (\n    'gravity' in settings &&\n    !(typeof settings.gravity === 'number' && settings.gravity >= 0)\n  )\n    return {message: 'the `gravity` setting should be a number >= 0.'};\n\n  if (\n    'slowDown' in settings &&\n    !(typeof settings.slowDown === 'number' || settings.slowDown >= 0)\n  )\n    return {message: 'the `slowDown` setting should be a number >= 0.'};\n\n  if (\n    'barnesHutOptimize' in settings &&\n    typeof settings.barnesHutOptimize !== 'boolean'\n  )\n    return {message: 'the `barnesHutOptimize` setting should be a boolean.'};\n\n  if (\n    'barnesHutTheta' in settings &&\n    !(\n      typeof settings.barnesHutTheta === 'number' &&\n      settings.barnesHutTheta >= 0\n    )\n  )\n    return {message: 'the `barnesHutTheta` setting should be a number >= 0.'};\n\n  return null;\n};\n\n/**\n * Function generating a flat matrix for both nodes & edges of the given graph.\n *\n * @param  {Graph}    graph         - Target graph.\n * @param  {function} getEdgeWeight - Edge weight getter function.\n * @return {object}                 - Both matrices.\n */\nexports.graphToByteArrays = function (graph, getEdgeWeight) {\n  var order = graph.order;\n  var size = graph.size;\n  var index = {};\n  var j;\n\n  // NOTE: float32 could lead to issues if edge array needs to index large\n  // number of nodes.\n  var NodeMatrix = new Float32Array(order * PPN);\n  var EdgeMatrix = new Float32Array(size * PPE);\n\n  // Iterate through nodes\n  j = 0;\n  graph.forEachNode(function (node, attr) {\n    // Node index\n    index[node] = j;\n\n    // Populating byte array\n    NodeMatrix[j] = attr.x;\n    NodeMatrix[j + 1] = attr.y;\n    NodeMatrix[j + 2] = 0; // dx\n    NodeMatrix[j + 3] = 0; // dy\n    NodeMatrix[j + 4] = 0; // old_dx\n    NodeMatrix[j + 5] = 0; // old_dy\n    NodeMatrix[j + 6] = 1; // mass\n    NodeMatrix[j + 7] = 1; // convergence\n    NodeMatrix[j + 8] = attr.size || 1;\n    NodeMatrix[j + 9] = attr.fixed ? 1 : 0;\n    j += PPN;\n  });\n\n  // Iterate through edges\n  j = 0;\n  graph.forEachEdge(function (edge, attr, source, target, sa, ta, u) {\n    var sj = index[source];\n    var tj = index[target];\n\n    var weight = getEdgeWeight(edge, attr, source, target, sa, ta, u);\n\n    // Incrementing mass to be a node's weighted degree\n    NodeMatrix[sj + 6] += weight;\n    NodeMatrix[tj + 6] += weight;\n\n    // Populating byte array\n    EdgeMatrix[j] = sj;\n    EdgeMatrix[j + 1] = tj;\n    EdgeMatrix[j + 2] = weight;\n    j += PPE;\n  });\n\n  return {\n    nodes: NodeMatrix,\n    edges: EdgeMatrix\n  };\n};\n\n/**\n * Function applying the layout back to the graph.\n *\n * @param {Graph}         graph         - Target graph.\n * @param {Float32Array}  NodeMatrix    - Node matrix.\n * @param {function|null} outputReducer - A node reducer.\n */\nexports.assignLayoutChanges = function (graph, NodeMatrix, outputReducer) {\n  var i = 0;\n\n  graph.updateEachNodeAttributes(function (node, attr) {\n    attr.x = NodeMatrix[i];\n    attr.y = NodeMatrix[i + 1];\n\n    i += PPN;\n\n    return outputReducer ? outputReducer(node, attr) : attr;\n  });\n};\n\n/**\n * Function reading the positions (only) from the graph, to write them in the matrix.\n *\n * @param {Graph}        graph      - Target graph.\n * @param {Float32Array} NodeMatrix - Node matrix.\n */\nexports.readGraphPositions = function (graph, NodeMatrix) {\n  var i = 0;\n\n  graph.forEachNode(function (node, attr) {\n    NodeMatrix[i] = attr.x;\n    NodeMatrix[i + 1] = attr.y;\n\n    i += PPN;\n  });\n};\n\n/**\n * Function collecting the layout positions.\n *\n * @param  {Graph}         graph         - Target graph.\n * @param  {Float32Array}  NodeMatrix    - Node matrix.\n * @param  {function|null} outputReducer - A nodes reducer.\n * @return {object}                      - Map to node positions.\n */\nexports.collectLayoutChanges = function (graph, NodeMatrix, outputReducer) {\n  var nodes = graph.nodes(),\n    positions = {};\n\n  for (var i = 0, j = 0, l = NodeMatrix.length; i < l; i += PPN) {\n    if (outputReducer) {\n      var newAttr = Object.assign({}, graph.getNodeAttributes(nodes[j]));\n      newAttr.x = NodeMatrix[i];\n      newAttr.y = NodeMatrix[i + 1];\n      newAttr = outputReducer(nodes[j], newAttr);\n      positions[nodes[j]] = {\n        x: newAttr.x,\n        y: newAttr.y\n      };\n    } else {\n      positions[nodes[j]] = {\n        x: NodeMatrix[i],\n        y: NodeMatrix[i + 1]\n      };\n    }\n\n    j++;\n  }\n\n  return positions;\n};\n\n/**\n * Function returning a web worker from the given function.\n *\n * @param  {function}  fn - Function for the worker.\n * @return {DOMString}\n */\nexports.createWorker = function createWorker(fn) {\n  var xURL = window.URL || window.webkitURL;\n  var code = fn.toString();\n  var objectUrl = xURL.createObjectURL(\n    new Blob(['(' + code + ').call(this);'], {type: 'text/javascript'})\n  );\n  var worker = new Worker(objectUrl);\n  xURL.revokeObjectURL(objectUrl);\n\n  return worker;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQtZm9yY2VhdGxhczIvaGVscGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVk7QUFDWjtBQUNBLGNBQWM7QUFDZDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQ0FBa0MsT0FBTztBQUN6Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxhQUFhO0FBQ3pCLFlBQVk7QUFDWjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7O0FBRVo7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFVBQVU7QUFDdEIsWUFBWSxVQUFVO0FBQ3RCLFlBQVksd0JBQXdCO0FBQ3BDO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0IsMkJBQTJCO0FBQzNCLDJCQUEyQjtBQUMzQiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCO0FBQ0EsMkJBQTJCO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxjQUFjO0FBQ3pCO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0IsWUFBWSxlQUFlO0FBQzNCLFlBQVksZUFBZTtBQUMzQixZQUFZLDZCQUE2QjtBQUN6QztBQUNBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QixZQUFZO0FBQ1o7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUssd0JBQXdCO0FBQ3RFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BvbnNhcnUvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQtZm9yY2VhdGxhczIvaGVscGVycy5qcz85NTg0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogR3JhcGhvbG9neSBGb3JjZUF0bGFzMiBIZWxwZXJzXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogTWlzY2VsbGFuZW91cyBoZWxwZXIgZnVuY3Rpb25zLlxuICovXG5cbi8qKlxuICogQ29uc3RhbnRzLlxuICovXG52YXIgUFBOID0gMTA7XG52YXIgUFBFID0gMztcblxuLyoqXG4gKiBWZXJ5IHNpbXBsZSBPYmplY3QuYXNzaWduLWxpa2UgZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtICB7b2JqZWN0fSB0YXJnZXQgICAgICAgLSBGaXJzdCBvYmplY3QuXG4gKiBAcGFyYW0gIHtvYmplY3R9IFsuLi5vYmplY3RzXSAtIE9iamVjdHMgdG8gbWVyZ2UuXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKi9cbmV4cG9ydHMuYXNzaWduID0gZnVuY3Rpb24gKHRhcmdldCkge1xuICB0YXJnZXQgPSB0YXJnZXQgfHwge307XG5cbiAgdmFyIG9iamVjdHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLnNsaWNlKDEpLFxuICAgIGksXG4gICAgayxcbiAgICBsO1xuXG4gIGZvciAoaSA9IDAsIGwgPSBvYmplY3RzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICghb2JqZWN0c1tpXSkgY29udGludWU7XG5cbiAgICBmb3IgKGsgaW4gb2JqZWN0c1tpXSkgdGFyZ2V0W2tdID0gb2JqZWN0c1tpXVtrXTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIHVzZWQgdG8gdmFsaWRhdGUgdGhlIGdpdmVuIHNldHRpbmdzLlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gICAgICBzZXR0aW5ncyAtIFNldHRpbmdzIHRvIHZhbGlkYXRlLlxuICogQHJldHVybiB7b2JqZWN0fG51bGx9XG4gKi9cbmV4cG9ydHMudmFsaWRhdGVTZXR0aW5ncyA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xuICBpZiAoJ2xpbkxvZ01vZGUnIGluIHNldHRpbmdzICYmIHR5cGVvZiBzZXR0aW5ncy5saW5Mb2dNb2RlICE9PSAnYm9vbGVhbicpXG4gICAgcmV0dXJuIHttZXNzYWdlOiAndGhlIGBsaW5Mb2dNb2RlYCBzZXR0aW5nIHNob3VsZCBiZSBhIGJvb2xlYW4uJ307XG5cbiAgaWYgKFxuICAgICdvdXRib3VuZEF0dHJhY3Rpb25EaXN0cmlidXRpb24nIGluIHNldHRpbmdzICYmXG4gICAgdHlwZW9mIHNldHRpbmdzLm91dGJvdW5kQXR0cmFjdGlvbkRpc3RyaWJ1dGlvbiAhPT0gJ2Jvb2xlYW4nXG4gIClcbiAgICByZXR1cm4ge1xuICAgICAgbWVzc2FnZTpcbiAgICAgICAgJ3RoZSBgb3V0Ym91bmRBdHRyYWN0aW9uRGlzdHJpYnV0aW9uYCBzZXR0aW5nIHNob3VsZCBiZSBhIGJvb2xlYW4uJ1xuICAgIH07XG5cbiAgaWYgKCdhZGp1c3RTaXplcycgaW4gc2V0dGluZ3MgJiYgdHlwZW9mIHNldHRpbmdzLmFkanVzdFNpemVzICE9PSAnYm9vbGVhbicpXG4gICAgcmV0dXJuIHttZXNzYWdlOiAndGhlIGBhZGp1c3RTaXplc2Agc2V0dGluZyBzaG91bGQgYmUgYSBib29sZWFuLid9O1xuXG4gIGlmIChcbiAgICAnZWRnZVdlaWdodEluZmx1ZW5jZScgaW4gc2V0dGluZ3MgJiZcbiAgICB0eXBlb2Ygc2V0dGluZ3MuZWRnZVdlaWdodEluZmx1ZW5jZSAhPT0gJ251bWJlcidcbiAgKVxuICAgIHJldHVybiB7XG4gICAgICBtZXNzYWdlOiAndGhlIGBlZGdlV2VpZ2h0SW5mbHVlbmNlYCBzZXR0aW5nIHNob3VsZCBiZSBhIG51bWJlci4nXG4gICAgfTtcblxuICBpZiAoXG4gICAgJ3NjYWxpbmdSYXRpbycgaW4gc2V0dGluZ3MgJiZcbiAgICAhKHR5cGVvZiBzZXR0aW5ncy5zY2FsaW5nUmF0aW8gPT09ICdudW1iZXInICYmIHNldHRpbmdzLnNjYWxpbmdSYXRpbyA+PSAwKVxuICApXG4gICAgcmV0dXJuIHttZXNzYWdlOiAndGhlIGBzY2FsaW5nUmF0aW9gIHNldHRpbmcgc2hvdWxkIGJlIGEgbnVtYmVyID49IDAuJ307XG5cbiAgaWYgKFxuICAgICdzdHJvbmdHcmF2aXR5TW9kZScgaW4gc2V0dGluZ3MgJiZcbiAgICB0eXBlb2Ygc2V0dGluZ3Muc3Ryb25nR3Jhdml0eU1vZGUgIT09ICdib29sZWFuJ1xuICApXG4gICAgcmV0dXJuIHttZXNzYWdlOiAndGhlIGBzdHJvbmdHcmF2aXR5TW9kZWAgc2V0dGluZyBzaG91bGQgYmUgYSBib29sZWFuLid9O1xuXG4gIGlmIChcbiAgICAnZ3Jhdml0eScgaW4gc2V0dGluZ3MgJiZcbiAgICAhKHR5cGVvZiBzZXR0aW5ncy5ncmF2aXR5ID09PSAnbnVtYmVyJyAmJiBzZXR0aW5ncy5ncmF2aXR5ID49IDApXG4gIClcbiAgICByZXR1cm4ge21lc3NhZ2U6ICd0aGUgYGdyYXZpdHlgIHNldHRpbmcgc2hvdWxkIGJlIGEgbnVtYmVyID49IDAuJ307XG5cbiAgaWYgKFxuICAgICdzbG93RG93bicgaW4gc2V0dGluZ3MgJiZcbiAgICAhKHR5cGVvZiBzZXR0aW5ncy5zbG93RG93biA9PT0gJ251bWJlcicgfHwgc2V0dGluZ3Muc2xvd0Rvd24gPj0gMClcbiAgKVxuICAgIHJldHVybiB7bWVzc2FnZTogJ3RoZSBgc2xvd0Rvd25gIHNldHRpbmcgc2hvdWxkIGJlIGEgbnVtYmVyID49IDAuJ307XG5cbiAgaWYgKFxuICAgICdiYXJuZXNIdXRPcHRpbWl6ZScgaW4gc2V0dGluZ3MgJiZcbiAgICB0eXBlb2Ygc2V0dGluZ3MuYmFybmVzSHV0T3B0aW1pemUgIT09ICdib29sZWFuJ1xuICApXG4gICAgcmV0dXJuIHttZXNzYWdlOiAndGhlIGBiYXJuZXNIdXRPcHRpbWl6ZWAgc2V0dGluZyBzaG91bGQgYmUgYSBib29sZWFuLid9O1xuXG4gIGlmIChcbiAgICAnYmFybmVzSHV0VGhldGEnIGluIHNldHRpbmdzICYmXG4gICAgIShcbiAgICAgIHR5cGVvZiBzZXR0aW5ncy5iYXJuZXNIdXRUaGV0YSA9PT0gJ251bWJlcicgJiZcbiAgICAgIHNldHRpbmdzLmJhcm5lc0h1dFRoZXRhID49IDBcbiAgICApXG4gIClcbiAgICByZXR1cm4ge21lc3NhZ2U6ICd0aGUgYGJhcm5lc0h1dFRoZXRhYCBzZXR0aW5nIHNob3VsZCBiZSBhIG51bWJlciA+PSAwLid9O1xuXG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqXG4gKiBGdW5jdGlvbiBnZW5lcmF0aW5nIGEgZmxhdCBtYXRyaXggZm9yIGJvdGggbm9kZXMgJiBlZGdlcyBvZiB0aGUgZ2l2ZW4gZ3JhcGguXG4gKlxuICogQHBhcmFtICB7R3JhcGh9ICAgIGdyYXBoICAgICAgICAgLSBUYXJnZXQgZ3JhcGguXG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gZ2V0RWRnZVdlaWdodCAtIEVkZ2Ugd2VpZ2h0IGdldHRlciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gICAgICAgICAgICAgICAgIC0gQm90aCBtYXRyaWNlcy5cbiAqL1xuZXhwb3J0cy5ncmFwaFRvQnl0ZUFycmF5cyA9IGZ1bmN0aW9uIChncmFwaCwgZ2V0RWRnZVdlaWdodCkge1xuICB2YXIgb3JkZXIgPSBncmFwaC5vcmRlcjtcbiAgdmFyIHNpemUgPSBncmFwaC5zaXplO1xuICB2YXIgaW5kZXggPSB7fTtcbiAgdmFyIGo7XG5cbiAgLy8gTk9URTogZmxvYXQzMiBjb3VsZCBsZWFkIHRvIGlzc3VlcyBpZiBlZGdlIGFycmF5IG5lZWRzIHRvIGluZGV4IGxhcmdlXG4gIC8vIG51bWJlciBvZiBub2Rlcy5cbiAgdmFyIE5vZGVNYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KG9yZGVyICogUFBOKTtcbiAgdmFyIEVkZ2VNYXRyaXggPSBuZXcgRmxvYXQzMkFycmF5KHNpemUgKiBQUEUpO1xuXG4gIC8vIEl0ZXJhdGUgdGhyb3VnaCBub2Rlc1xuICBqID0gMDtcbiAgZ3JhcGguZm9yRWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgICAvLyBOb2RlIGluZGV4XG4gICAgaW5kZXhbbm9kZV0gPSBqO1xuXG4gICAgLy8gUG9wdWxhdGluZyBieXRlIGFycmF5XG4gICAgTm9kZU1hdHJpeFtqXSA9IGF0dHIueDtcbiAgICBOb2RlTWF0cml4W2ogKyAxXSA9IGF0dHIueTtcbiAgICBOb2RlTWF0cml4W2ogKyAyXSA9IDA7IC8vIGR4XG4gICAgTm9kZU1hdHJpeFtqICsgM10gPSAwOyAvLyBkeVxuICAgIE5vZGVNYXRyaXhbaiArIDRdID0gMDsgLy8gb2xkX2R4XG4gICAgTm9kZU1hdHJpeFtqICsgNV0gPSAwOyAvLyBvbGRfZHlcbiAgICBOb2RlTWF0cml4W2ogKyA2XSA9IDE7IC8vIG1hc3NcbiAgICBOb2RlTWF0cml4W2ogKyA3XSA9IDE7IC8vIGNvbnZlcmdlbmNlXG4gICAgTm9kZU1hdHJpeFtqICsgOF0gPSBhdHRyLnNpemUgfHwgMTtcbiAgICBOb2RlTWF0cml4W2ogKyA5XSA9IGF0dHIuZml4ZWQgPyAxIDogMDtcbiAgICBqICs9IFBQTjtcbiAgfSk7XG5cbiAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVkZ2VzXG4gIGogPSAwO1xuICBncmFwaC5mb3JFYWNoRWRnZShmdW5jdGlvbiAoZWRnZSwgYXR0ciwgc291cmNlLCB0YXJnZXQsIHNhLCB0YSwgdSkge1xuICAgIHZhciBzaiA9IGluZGV4W3NvdXJjZV07XG4gICAgdmFyIHRqID0gaW5kZXhbdGFyZ2V0XTtcblxuICAgIHZhciB3ZWlnaHQgPSBnZXRFZGdlV2VpZ2h0KGVkZ2UsIGF0dHIsIHNvdXJjZSwgdGFyZ2V0LCBzYSwgdGEsIHUpO1xuXG4gICAgLy8gSW5jcmVtZW50aW5nIG1hc3MgdG8gYmUgYSBub2RlJ3Mgd2VpZ2h0ZWQgZGVncmVlXG4gICAgTm9kZU1hdHJpeFtzaiArIDZdICs9IHdlaWdodDtcbiAgICBOb2RlTWF0cml4W3RqICsgNl0gKz0gd2VpZ2h0O1xuXG4gICAgLy8gUG9wdWxhdGluZyBieXRlIGFycmF5XG4gICAgRWRnZU1hdHJpeFtqXSA9IHNqO1xuICAgIEVkZ2VNYXRyaXhbaiArIDFdID0gdGo7XG4gICAgRWRnZU1hdHJpeFtqICsgMl0gPSB3ZWlnaHQ7XG4gICAgaiArPSBQUEU7XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgbm9kZXM6IE5vZGVNYXRyaXgsXG4gICAgZWRnZXM6IEVkZ2VNYXRyaXhcbiAgfTtcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gYXBwbHlpbmcgdGhlIGxheW91dCBiYWNrIHRvIHRoZSBncmFwaC5cbiAqXG4gKiBAcGFyYW0ge0dyYXBofSAgICAgICAgIGdyYXBoICAgICAgICAgLSBUYXJnZXQgZ3JhcGguXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gIE5vZGVNYXRyaXggICAgLSBOb2RlIG1hdHJpeC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb258bnVsbH0gb3V0cHV0UmVkdWNlciAtIEEgbm9kZSByZWR1Y2VyLlxuICovXG5leHBvcnRzLmFzc2lnbkxheW91dENoYW5nZXMgPSBmdW5jdGlvbiAoZ3JhcGgsIE5vZGVNYXRyaXgsIG91dHB1dFJlZHVjZXIpIHtcbiAgdmFyIGkgPSAwO1xuXG4gIGdyYXBoLnVwZGF0ZUVhY2hOb2RlQXR0cmlidXRlcyhmdW5jdGlvbiAobm9kZSwgYXR0cikge1xuICAgIGF0dHIueCA9IE5vZGVNYXRyaXhbaV07XG4gICAgYXR0ci55ID0gTm9kZU1hdHJpeFtpICsgMV07XG5cbiAgICBpICs9IFBQTjtcblxuICAgIHJldHVybiBvdXRwdXRSZWR1Y2VyID8gb3V0cHV0UmVkdWNlcihub2RlLCBhdHRyKSA6IGF0dHI7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBGdW5jdGlvbiByZWFkaW5nIHRoZSBwb3NpdGlvbnMgKG9ubHkpIGZyb20gdGhlIGdyYXBoLCB0byB3cml0ZSB0aGVtIGluIHRoZSBtYXRyaXguXG4gKlxuICogQHBhcmFtIHtHcmFwaH0gICAgICAgIGdyYXBoICAgICAgLSBUYXJnZXQgZ3JhcGguXG4gKiBAcGFyYW0ge0Zsb2F0MzJBcnJheX0gTm9kZU1hdHJpeCAtIE5vZGUgbWF0cml4LlxuICovXG5leHBvcnRzLnJlYWRHcmFwaFBvc2l0aW9ucyA9IGZ1bmN0aW9uIChncmFwaCwgTm9kZU1hdHJpeCkge1xuICB2YXIgaSA9IDA7XG5cbiAgZ3JhcGguZm9yRWFjaE5vZGUoZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgICBOb2RlTWF0cml4W2ldID0gYXR0ci54O1xuICAgIE5vZGVNYXRyaXhbaSArIDFdID0gYXR0ci55O1xuXG4gICAgaSArPSBQUE47XG4gIH0pO1xufTtcblxuLyoqXG4gKiBGdW5jdGlvbiBjb2xsZWN0aW5nIHRoZSBsYXlvdXQgcG9zaXRpb25zLlxuICpcbiAqIEBwYXJhbSAge0dyYXBofSAgICAgICAgIGdyYXBoICAgICAgICAgLSBUYXJnZXQgZ3JhcGguXG4gKiBAcGFyYW0gIHtGbG9hdDMyQXJyYXl9ICBOb2RlTWF0cml4ICAgIC0gTm9kZSBtYXRyaXguXG4gKiBAcGFyYW0gIHtmdW5jdGlvbnxudWxsfSBvdXRwdXRSZWR1Y2VyIC0gQSBub2RlcyByZWR1Y2VyLlxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICAgICAgICAtIE1hcCB0byBub2RlIHBvc2l0aW9ucy5cbiAqL1xuZXhwb3J0cy5jb2xsZWN0TGF5b3V0Q2hhbmdlcyA9IGZ1bmN0aW9uIChncmFwaCwgTm9kZU1hdHJpeCwgb3V0cHV0UmVkdWNlcikge1xuICB2YXIgbm9kZXMgPSBncmFwaC5ub2RlcygpLFxuICAgIHBvc2l0aW9ucyA9IHt9O1xuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gMCwgbCA9IE5vZGVNYXRyaXgubGVuZ3RoOyBpIDwgbDsgaSArPSBQUE4pIHtcbiAgICBpZiAob3V0cHV0UmVkdWNlcikge1xuICAgICAgdmFyIG5ld0F0dHIgPSBPYmplY3QuYXNzaWduKHt9LCBncmFwaC5nZXROb2RlQXR0cmlidXRlcyhub2Rlc1tqXSkpO1xuICAgICAgbmV3QXR0ci54ID0gTm9kZU1hdHJpeFtpXTtcbiAgICAgIG5ld0F0dHIueSA9IE5vZGVNYXRyaXhbaSArIDFdO1xuICAgICAgbmV3QXR0ciA9IG91dHB1dFJlZHVjZXIobm9kZXNbal0sIG5ld0F0dHIpO1xuICAgICAgcG9zaXRpb25zW25vZGVzW2pdXSA9IHtcbiAgICAgICAgeDogbmV3QXR0ci54LFxuICAgICAgICB5OiBuZXdBdHRyLnlcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvc2l0aW9uc1tub2Rlc1tqXV0gPSB7XG4gICAgICAgIHg6IE5vZGVNYXRyaXhbaV0sXG4gICAgICAgIHk6IE5vZGVNYXRyaXhbaSArIDFdXG4gICAgICB9O1xuICAgIH1cblxuICAgIGorKztcbiAgfVxuXG4gIHJldHVybiBwb3NpdGlvbnM7XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIHJldHVybmluZyBhIHdlYiB3b3JrZXIgZnJvbSB0aGUgZ2l2ZW4gZnVuY3Rpb24uXG4gKlxuICogQHBhcmFtICB7ZnVuY3Rpb259ICBmbiAtIEZ1bmN0aW9uIGZvciB0aGUgd29ya2VyLlxuICogQHJldHVybiB7RE9NU3RyaW5nfVxuICovXG5leHBvcnRzLmNyZWF0ZVdvcmtlciA9IGZ1bmN0aW9uIGNyZWF0ZVdvcmtlcihmbikge1xuICB2YXIgeFVSTCA9IHdpbmRvdy5VUkwgfHwgd2luZG93LndlYmtpdFVSTDtcbiAgdmFyIGNvZGUgPSBmbi50b1N0cmluZygpO1xuICB2YXIgb2JqZWN0VXJsID0geFVSTC5jcmVhdGVPYmplY3RVUkwoXG4gICAgbmV3IEJsb2IoWycoJyArIGNvZGUgKyAnKS5jYWxsKHRoaXMpOyddLCB7dHlwZTogJ3RleHQvamF2YXNjcmlwdCd9KVxuICApO1xuICB2YXIgd29ya2VyID0gbmV3IFdvcmtlcihvYmplY3RVcmwpO1xuICB4VVJMLnJldm9rZU9iamVjdFVSTChvYmplY3RVcmwpO1xuXG4gIHJldHVybiB3b3JrZXI7XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-layout-forceatlas2/helpers.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/graphology-layout-forceatlas2/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/graphology-layout-forceatlas2/index.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Graphology ForceAtlas2 Layout\n * ==============================\n *\n * Library endpoint.\n */\nvar isGraph = __webpack_require__(/*! graphology-utils/is-graph */ \"(ssr)/./node_modules/graphology-utils/is-graph.js\");\nvar createEdgeWeightGetter =\n  (__webpack_require__(/*! graphology-utils/getters */ \"(ssr)/./node_modules/graphology-utils/getters.js\").createEdgeWeightGetter);\nvar iterate = __webpack_require__(/*! ./iterate.js */ \"(ssr)/./node_modules/graphology-layout-forceatlas2/iterate.js\");\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/graphology-layout-forceatlas2/helpers.js\");\n\nvar DEFAULT_SETTINGS = __webpack_require__(/*! ./defaults.js */ \"(ssr)/./node_modules/graphology-layout-forceatlas2/defaults.js\");\n\n/**\n * Asbtract function used to run a certain number of iterations.\n *\n * @param  {boolean}       assign          - Whether to assign positions.\n * @param  {Graph}         graph           - Target graph.\n * @param  {object|number} params          - If number, params.iterations, else:\n * @param  {function}        getWeight     - Edge weight getter function.\n * @param  {number}          iterations    - Number of iterations.\n * @param  {function|null}   outputReducer - A node reducer\n * @param  {object}          [settings]    - Settings.\n * @return {object|undefined}\n */\nfunction abstractSynchronousLayout(assign, graph, params) {\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-layout-forceatlas2: the given graph is not a valid graphology instance.'\n    );\n\n  if (typeof params === 'number') params = {iterations: params};\n\n  var iterations = params.iterations;\n\n  if (typeof iterations !== 'number')\n    throw new Error(\n      'graphology-layout-forceatlas2: invalid number of iterations.'\n    );\n\n  if (iterations <= 0)\n    throw new Error(\n      'graphology-layout-forceatlas2: you should provide a positive number of iterations.'\n    );\n\n  var getEdgeWeight = createEdgeWeightGetter(\n    'getEdgeWeight' in params ? params.getEdgeWeight : 'weight'\n  ).fromEntry;\n\n  var outputReducer =\n    typeof params.outputReducer === 'function' ? params.outputReducer : null;\n\n  // Validating settings\n  var settings = helpers.assign({}, DEFAULT_SETTINGS, params.settings);\n  var validationError = helpers.validateSettings(settings);\n\n  if (validationError)\n    throw new Error(\n      'graphology-layout-forceatlas2: ' + validationError.message\n    );\n\n  // Building matrices\n  var matrices = helpers.graphToByteArrays(graph, getEdgeWeight);\n\n  var i;\n\n  // Iterating\n  for (i = 0; i < iterations; i++)\n    iterate(settings, matrices.nodes, matrices.edges);\n\n  // Applying\n  if (assign) {\n    helpers.assignLayoutChanges(graph, matrices.nodes, outputReducer);\n    return;\n  }\n\n  return helpers.collectLayoutChanges(graph, matrices.nodes);\n}\n\n/**\n * Function returning sane layout settings for the given graph.\n *\n * @param  {Graph|number} graph - Target graph or graph order.\n * @return {object}\n */\nfunction inferSettings(graph) {\n  var order = typeof graph === 'number' ? graph : graph.order;\n\n  return {\n    barnesHutOptimize: order > 2000,\n    strongGravityMode: true,\n    gravity: 0.05,\n    scalingRatio: 10,\n    slowDown: 1 + Math.log(order)\n  };\n}\n\n/**\n * Exporting.\n */\nvar synchronousLayout = abstractSynchronousLayout.bind(null, false);\nsynchronousLayout.assign = abstractSynchronousLayout.bind(null, true);\nsynchronousLayout.inferSettings = inferSettings;\n\nmodule.exports = synchronousLayout;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQtZm9yY2VhdGxhczIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLG9GQUEyQjtBQUNqRDtBQUNBLEVBQUUsZ0lBQTBEO0FBQzVELGNBQWMsbUJBQU8sQ0FBQyxtRkFBYztBQUNwQyxjQUFjLG1CQUFPLENBQUMsbUZBQWM7O0FBRXBDLHVCQUF1QixtQkFBTyxDQUFDLHFGQUFlOztBQUU5QztBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0IsWUFBWSxlQUFlO0FBQzNCLFlBQVksZUFBZTtBQUMzQixZQUFZLGlCQUFpQjtBQUM3QixZQUFZLGlCQUFpQjtBQUM3QixZQUFZLGlCQUFpQjtBQUM3QixZQUFZLGlCQUFpQjtBQUM3QixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0M7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWMsZ0JBQWdCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Nwb25zYXJ1Ly4vbm9kZV9tb2R1bGVzL2dyYXBob2xvZ3ktbGF5b3V0LWZvcmNlYXRsYXMyL2luZGV4LmpzPzE2Y2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHcmFwaG9sb2d5IEZvcmNlQXRsYXMyIExheW91dFxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKlxuICogTGlicmFyeSBlbmRwb2ludC5cbiAqL1xudmFyIGlzR3JhcGggPSByZXF1aXJlKCdncmFwaG9sb2d5LXV0aWxzL2lzLWdyYXBoJyk7XG52YXIgY3JlYXRlRWRnZVdlaWdodEdldHRlciA9XG4gIHJlcXVpcmUoJ2dyYXBob2xvZ3ktdXRpbHMvZ2V0dGVycycpLmNyZWF0ZUVkZ2VXZWlnaHRHZXR0ZXI7XG52YXIgaXRlcmF0ZSA9IHJlcXVpcmUoJy4vaXRlcmF0ZS5qcycpO1xudmFyIGhlbHBlcnMgPSByZXF1aXJlKCcuL2hlbHBlcnMuanMnKTtcblxudmFyIERFRkFVTFRfU0VUVElOR1MgPSByZXF1aXJlKCcuL2RlZmF1bHRzLmpzJyk7XG5cbi8qKlxuICogQXNidHJhY3QgZnVuY3Rpb24gdXNlZCB0byBydW4gYSBjZXJ0YWluIG51bWJlciBvZiBpdGVyYXRpb25zLlxuICpcbiAqIEBwYXJhbSAge2Jvb2xlYW59ICAgICAgIGFzc2lnbiAgICAgICAgICAtIFdoZXRoZXIgdG8gYXNzaWduIHBvc2l0aW9ucy5cbiAqIEBwYXJhbSAge0dyYXBofSAgICAgICAgIGdyYXBoICAgICAgICAgICAtIFRhcmdldCBncmFwaC5cbiAqIEBwYXJhbSAge29iamVjdHxudW1iZXJ9IHBhcmFtcyAgICAgICAgICAtIElmIG51bWJlciwgcGFyYW1zLml0ZXJhdGlvbnMsIGVsc2U6XG4gKiBAcGFyYW0gIHtmdW5jdGlvbn0gICAgICAgIGdldFdlaWdodCAgICAgLSBFZGdlIHdlaWdodCBnZXR0ZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0gIHtudW1iZXJ9ICAgICAgICAgIGl0ZXJhdGlvbnMgICAgLSBOdW1iZXIgb2YgaXRlcmF0aW9ucy5cbiAqIEBwYXJhbSAge2Z1bmN0aW9ufG51bGx9ICAgb3V0cHV0UmVkdWNlciAtIEEgbm9kZSByZWR1Y2VyXG4gKiBAcGFyYW0gIHtvYmplY3R9ICAgICAgICAgIFtzZXR0aW5nc10gICAgLSBTZXR0aW5ncy5cbiAqIEByZXR1cm4ge29iamVjdHx1bmRlZmluZWR9XG4gKi9cbmZ1bmN0aW9uIGFic3RyYWN0U3luY2hyb25vdXNMYXlvdXQoYXNzaWduLCBncmFwaCwgcGFyYW1zKSB7XG4gIGlmICghaXNHcmFwaChncmFwaCkpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2dyYXBob2xvZ3ktbGF5b3V0LWZvcmNlYXRsYXMyOiB0aGUgZ2l2ZW4gZ3JhcGggaXMgbm90IGEgdmFsaWQgZ3JhcGhvbG9neSBpbnN0YW5jZS4nXG4gICAgKTtcblxuICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ251bWJlcicpIHBhcmFtcyA9IHtpdGVyYXRpb25zOiBwYXJhbXN9O1xuXG4gIHZhciBpdGVyYXRpb25zID0gcGFyYW1zLml0ZXJhdGlvbnM7XG5cbiAgaWYgKHR5cGVvZiBpdGVyYXRpb25zICE9PSAnbnVtYmVyJylcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnZ3JhcGhvbG9neS1sYXlvdXQtZm9yY2VhdGxhczI6IGludmFsaWQgbnVtYmVyIG9mIGl0ZXJhdGlvbnMuJ1xuICAgICk7XG5cbiAgaWYgKGl0ZXJhdGlvbnMgPD0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnZ3JhcGhvbG9neS1sYXlvdXQtZm9yY2VhdGxhczI6IHlvdSBzaG91bGQgcHJvdmlkZSBhIHBvc2l0aXZlIG51bWJlciBvZiBpdGVyYXRpb25zLidcbiAgICApO1xuXG4gIHZhciBnZXRFZGdlV2VpZ2h0ID0gY3JlYXRlRWRnZVdlaWdodEdldHRlcihcbiAgICAnZ2V0RWRnZVdlaWdodCcgaW4gcGFyYW1zID8gcGFyYW1zLmdldEVkZ2VXZWlnaHQgOiAnd2VpZ2h0J1xuICApLmZyb21FbnRyeTtcblxuICB2YXIgb3V0cHV0UmVkdWNlciA9XG4gICAgdHlwZW9mIHBhcmFtcy5vdXRwdXRSZWR1Y2VyID09PSAnZnVuY3Rpb24nID8gcGFyYW1zLm91dHB1dFJlZHVjZXIgOiBudWxsO1xuXG4gIC8vIFZhbGlkYXRpbmcgc2V0dGluZ3NcbiAgdmFyIHNldHRpbmdzID0gaGVscGVycy5hc3NpZ24oe30sIERFRkFVTFRfU0VUVElOR1MsIHBhcmFtcy5zZXR0aW5ncyk7XG4gIHZhciB2YWxpZGF0aW9uRXJyb3IgPSBoZWxwZXJzLnZhbGlkYXRlU2V0dGluZ3Moc2V0dGluZ3MpO1xuXG4gIGlmICh2YWxpZGF0aW9uRXJyb3IpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2dyYXBob2xvZ3ktbGF5b3V0LWZvcmNlYXRsYXMyOiAnICsgdmFsaWRhdGlvbkVycm9yLm1lc3NhZ2VcbiAgICApO1xuXG4gIC8vIEJ1aWxkaW5nIG1hdHJpY2VzXG4gIHZhciBtYXRyaWNlcyA9IGhlbHBlcnMuZ3JhcGhUb0J5dGVBcnJheXMoZ3JhcGgsIGdldEVkZ2VXZWlnaHQpO1xuXG4gIHZhciBpO1xuXG4gIC8vIEl0ZXJhdGluZ1xuICBmb3IgKGkgPSAwOyBpIDwgaXRlcmF0aW9uczsgaSsrKVxuICAgIGl0ZXJhdGUoc2V0dGluZ3MsIG1hdHJpY2VzLm5vZGVzLCBtYXRyaWNlcy5lZGdlcyk7XG5cbiAgLy8gQXBwbHlpbmdcbiAgaWYgKGFzc2lnbikge1xuICAgIGhlbHBlcnMuYXNzaWduTGF5b3V0Q2hhbmdlcyhncmFwaCwgbWF0cmljZXMubm9kZXMsIG91dHB1dFJlZHVjZXIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHJldHVybiBoZWxwZXJzLmNvbGxlY3RMYXlvdXRDaGFuZ2VzKGdyYXBoLCBtYXRyaWNlcy5ub2Rlcyk7XG59XG5cbi8qKlxuICogRnVuY3Rpb24gcmV0dXJuaW5nIHNhbmUgbGF5b3V0IHNldHRpbmdzIGZvciB0aGUgZ2l2ZW4gZ3JhcGguXG4gKlxuICogQHBhcmFtICB7R3JhcGh8bnVtYmVyfSBncmFwaCAtIFRhcmdldCBncmFwaCBvciBncmFwaCBvcmRlci5cbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gaW5mZXJTZXR0aW5ncyhncmFwaCkge1xuICB2YXIgb3JkZXIgPSB0eXBlb2YgZ3JhcGggPT09ICdudW1iZXInID8gZ3JhcGggOiBncmFwaC5vcmRlcjtcblxuICByZXR1cm4ge1xuICAgIGJhcm5lc0h1dE9wdGltaXplOiBvcmRlciA+IDIwMDAsXG4gICAgc3Ryb25nR3Jhdml0eU1vZGU6IHRydWUsXG4gICAgZ3Jhdml0eTogMC4wNSxcbiAgICBzY2FsaW5nUmF0aW86IDEwLFxuICAgIHNsb3dEb3duOiAxICsgTWF0aC5sb2cob3JkZXIpXG4gIH07XG59XG5cbi8qKlxuICogRXhwb3J0aW5nLlxuICovXG52YXIgc3luY2hyb25vdXNMYXlvdXQgPSBhYnN0cmFjdFN5bmNocm9ub3VzTGF5b3V0LmJpbmQobnVsbCwgZmFsc2UpO1xuc3luY2hyb25vdXNMYXlvdXQuYXNzaWduID0gYWJzdHJhY3RTeW5jaHJvbm91c0xheW91dC5iaW5kKG51bGwsIHRydWUpO1xuc3luY2hyb25vdXNMYXlvdXQuaW5mZXJTZXR0aW5ncyA9IGluZmVyU2V0dGluZ3M7XG5cbm1vZHVsZS5leHBvcnRzID0gc3luY2hyb25vdXNMYXlvdXQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-layout-forceatlas2/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/graphology-layout-forceatlas2/iterate.js":
/*!***************************************************************!*\
  !*** ./node_modules/graphology-layout-forceatlas2/iterate.js ***!
  \***************************************************************/
/***/ ((module) => {

eval("/* eslint no-constant-condition: 0 */\n/**\n * Graphology ForceAtlas2 Iteration\n * =================================\n *\n * Function used to perform a single iteration of the algorithm.\n */\n\n/**\n * Matrices properties accessors.\n */\nvar NODE_X = 0;\nvar NODE_Y = 1;\nvar NODE_DX = 2;\nvar NODE_DY = 3;\nvar NODE_OLD_DX = 4;\nvar NODE_OLD_DY = 5;\nvar NODE_MASS = 6;\nvar NODE_CONVERGENCE = 7;\nvar NODE_SIZE = 8;\nvar NODE_FIXED = 9;\n\nvar EDGE_SOURCE = 0;\nvar EDGE_TARGET = 1;\nvar EDGE_WEIGHT = 2;\n\nvar REGION_NODE = 0;\nvar REGION_CENTER_X = 1;\nvar REGION_CENTER_Y = 2;\nvar REGION_SIZE = 3;\nvar REGION_NEXT_SIBLING = 4;\nvar REGION_FIRST_CHILD = 5;\nvar REGION_MASS = 6;\nvar REGION_MASS_CENTER_X = 7;\nvar REGION_MASS_CENTER_Y = 8;\n\nvar SUBDIVISION_ATTEMPTS = 3;\n\n/**\n * Constants.\n */\nvar PPN = 10;\nvar PPE = 3;\nvar PPR = 9;\n\nvar MAX_FORCE = 10;\n\n/**\n * Function used to perform a single interation of the algorithm.\n *\n * @param  {object}       options    - Layout options.\n * @param  {Float32Array} NodeMatrix - Node data.\n * @param  {Float32Array} EdgeMatrix - Edge data.\n * @return {object}                  - Some metadata.\n */\nmodule.exports = function iterate(options, NodeMatrix, EdgeMatrix) {\n  // Initializing variables\n  var l, r, n, n1, n2, rn, e, w, g, s;\n\n  var order = NodeMatrix.length,\n    size = EdgeMatrix.length;\n\n  var adjustSizes = options.adjustSizes;\n\n  var thetaSquared = options.barnesHutTheta * options.barnesHutTheta;\n\n  var outboundAttCompensation, coefficient, xDist, yDist, ewc, distance, factor;\n\n  var RegionMatrix = [];\n\n  // 1) Initializing layout data\n  //-----------------------------\n\n  // Resetting positions & computing max values\n  for (n = 0; n < order; n += PPN) {\n    NodeMatrix[n + NODE_OLD_DX] = NodeMatrix[n + NODE_DX];\n    NodeMatrix[n + NODE_OLD_DY] = NodeMatrix[n + NODE_DY];\n    NodeMatrix[n + NODE_DX] = 0;\n    NodeMatrix[n + NODE_DY] = 0;\n  }\n\n  // If outbound attraction distribution, compensate\n  if (options.outboundAttractionDistribution) {\n    outboundAttCompensation = 0;\n    for (n = 0; n < order; n += PPN) {\n      outboundAttCompensation += NodeMatrix[n + NODE_MASS];\n    }\n\n    outboundAttCompensation /= order / PPN;\n  }\n\n  // 1.bis) Barnes-Hut computation\n  //------------------------------\n\n  if (options.barnesHutOptimize) {\n    // Setting up\n    var minX = Infinity,\n      maxX = -Infinity,\n      minY = Infinity,\n      maxY = -Infinity,\n      q,\n      q2,\n      subdivisionAttempts;\n\n    // Computing min and max values\n    for (n = 0; n < order; n += PPN) {\n      minX = Math.min(minX, NodeMatrix[n + NODE_X]);\n      maxX = Math.max(maxX, NodeMatrix[n + NODE_X]);\n      minY = Math.min(minY, NodeMatrix[n + NODE_Y]);\n      maxY = Math.max(maxY, NodeMatrix[n + NODE_Y]);\n    }\n\n    // squarify bounds, it's a quadtree\n    var dx = maxX - minX,\n      dy = maxY - minY;\n    if (dx > dy) {\n      minY -= (dx - dy) / 2;\n      maxY = minY + dx;\n    } else {\n      minX -= (dy - dx) / 2;\n      maxX = minX + dy;\n    }\n\n    // Build the Barnes Hut root region\n    RegionMatrix[0 + REGION_NODE] = -1;\n    RegionMatrix[0 + REGION_CENTER_X] = (minX + maxX) / 2;\n    RegionMatrix[0 + REGION_CENTER_Y] = (minY + maxY) / 2;\n    RegionMatrix[0 + REGION_SIZE] = Math.max(maxX - minX, maxY - minY);\n    RegionMatrix[0 + REGION_NEXT_SIBLING] = -1;\n    RegionMatrix[0 + REGION_FIRST_CHILD] = -1;\n    RegionMatrix[0 + REGION_MASS] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_X] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_Y] = 0;\n\n    // Add each node in the tree\n    l = 1;\n    for (n = 0; n < order; n += PPN) {\n      // Current region, starting with root\n      r = 0;\n      subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n\n      while (true) {\n        // Are there sub-regions?\n\n        // We look at first child index\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n          // There are sub-regions\n\n          // We just iterate to find a \"leaf\" of the tree\n          // that is an empty region or a region with a single node\n          // (see next case)\n\n          // Find the quadrant of n\n          if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n              // Top Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD];\n            } else {\n              // Bottom Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n            }\n          } else {\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n              // Top Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n            } else {\n              // Bottom Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n            }\n          }\n\n          // Update center of mass and mass (we only do it for non-leave regions)\n          RegionMatrix[r + REGION_MASS_CENTER_X] =\n            (RegionMatrix[r + REGION_MASS_CENTER_X] *\n              RegionMatrix[r + REGION_MASS] +\n              NodeMatrix[n + NODE_X] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS_CENTER_Y] =\n            (RegionMatrix[r + REGION_MASS_CENTER_Y] *\n              RegionMatrix[r + REGION_MASS] +\n              NodeMatrix[n + NODE_Y] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS] += NodeMatrix[n + NODE_MASS];\n\n          // Iterate on the right quadrant\n          r = q;\n          continue;\n        } else {\n          // There are no sub-regions: we are in a \"leaf\"\n\n          // Is there a node in this leave?\n          if (RegionMatrix[r + REGION_NODE] < 0) {\n            // There is no node in region:\n            // we record node n and go on\n            RegionMatrix[r + REGION_NODE] = n;\n            break;\n          } else {\n            // There is a node in this region\n\n            // We will need to create sub-regions, stick the two\n            // nodes (the old one r[0] and the new one n) in two\n            // subregions. If they fall in the same quadrant,\n            // we will iterate.\n\n            // Create sub-regions\n            RegionMatrix[r + REGION_FIRST_CHILD] = l * PPR;\n            w = RegionMatrix[r + REGION_SIZE] / 2; // new size (half)\n\n            // NOTE: we use screen coordinates\n            // from Top Left to Bottom Right\n\n            // Top Left sub-region\n            g = RegionMatrix[r + REGION_FIRST_CHILD];\n\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Left sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Top Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] =\n              RegionMatrix[r + REGION_NEXT_SIBLING];\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            l += 4;\n\n            // Now the goal is to find two different sub-regions\n            // for the two nodes: the one previously recorded (r[0])\n            // and the one we want to add (n)\n\n            // Find the quadrant of the old node\n            if (\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X] <\n              RegionMatrix[r + REGION_CENTER_X]\n            ) {\n              if (\n                NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] <\n                RegionMatrix[r + REGION_CENTER_Y]\n              ) {\n                // Top Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD];\n              } else {\n                // Bottom Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            } else {\n              if (\n                NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] <\n                RegionMatrix[r + REGION_CENTER_Y]\n              ) {\n                // Top Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              } else {\n                // Bottom Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            // We remove r[0] from the region r, add its mass to r and record it in q\n            RegionMatrix[r + REGION_MASS] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_MASS];\n            RegionMatrix[r + REGION_MASS_CENTER_X] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X];\n            RegionMatrix[r + REGION_MASS_CENTER_Y] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y];\n\n            RegionMatrix[q + REGION_NODE] = RegionMatrix[r + REGION_NODE];\n            RegionMatrix[r + REGION_NODE] = -1;\n\n            // Find the quadrant of n\n            if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n                // Top Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD];\n              } else {\n                // Bottom Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            } else {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n                // Top Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              } else {\n                // Bottom Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            if (q === q2) {\n              // If both nodes are in the same quadrant,\n              // we have to try it again on this quadrant\n              if (subdivisionAttempts--) {\n                r = q;\n                continue; // while\n              } else {\n                // we are out of precision here, and we cannot subdivide anymore\n                // but we have to break the loop anyway\n                subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n                break; // while\n              }\n            }\n\n            // If both quadrants are different, we record n\n            // in its quadrant\n            RegionMatrix[q2 + REGION_NODE] = n;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  // 2) Repulsion\n  //--------------\n  // NOTES: adjustSizes = antiCollision & scalingRatio = coefficient\n\n  if (options.barnesHutOptimize) {\n    coefficient = options.scalingRatio;\n\n    // Applying repulsion through regions\n    for (n = 0; n < order; n += PPN) {\n      // Computing leaf quad nodes iteration\n\n      r = 0; // Starting with root region\n      while (true) {\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n          // The region has sub-regions\n\n          // We run the Barnes Hut test to see if we are at the right distance\n          distance =\n            Math.pow(\n              NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X],\n              2\n            ) +\n            Math.pow(\n              NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y],\n              2\n            );\n\n          s = RegionMatrix[r + REGION_SIZE];\n\n          if ((4 * s * s) / distance < thetaSquared) {\n            // We treat the region as a single body, and we repulse\n\n            xDist =\n              NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X];\n            yDist =\n              NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y];\n\n            if (adjustSizes === true) {\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              } else if (distance < 0) {\n                factor =\n                  (-coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            } else {\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n\n            // When this is done, we iterate. We have to look at the next sibling.\n            r = RegionMatrix[r + REGION_NEXT_SIBLING];\n            if (r < 0) break; // No next sibling: we have finished the tree\n\n            continue;\n          } else {\n            // The region is too close and we have to look at sub-regions\n            r = RegionMatrix[r + REGION_FIRST_CHILD];\n            continue;\n          }\n        } else {\n          // The region has no sub-region\n          // If there is a node r[0] and it is not n, then repulse\n          rn = RegionMatrix[r + REGION_NODE];\n\n          if (rn >= 0 && rn !== n) {\n            xDist = NodeMatrix[n + NODE_X] - NodeMatrix[rn + NODE_X];\n            yDist = NodeMatrix[n + NODE_Y] - NodeMatrix[rn + NODE_Y];\n\n            distance = xDist * xDist + yDist * yDist;\n\n            if (adjustSizes === true) {\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              } else if (distance < 0) {\n                factor =\n                  (-coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            } else {\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n          }\n\n          // When this is done, we iterate. We have to look at the next sibling.\n          r = RegionMatrix[r + REGION_NEXT_SIBLING];\n\n          if (r < 0) break; // No next sibling: we have finished the tree\n\n          continue;\n        }\n      }\n    }\n  } else {\n    coefficient = options.scalingRatio;\n\n    // Square iteration\n    for (n1 = 0; n1 < order; n1 += PPN) {\n      for (n2 = 0; n2 < n1; n2 += PPN) {\n        // Common to both methods\n        xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n        yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n        if (adjustSizes === true) {\n          //-- Anticollision Linear Repulsion\n          distance =\n            Math.sqrt(xDist * xDist + yDist * yDist) -\n            NodeMatrix[n1 + NODE_SIZE] -\n            NodeMatrix[n2 + NODE_SIZE];\n\n          if (distance > 0) {\n            factor =\n              (coefficient *\n                NodeMatrix[n1 + NODE_MASS] *\n                NodeMatrix[n2 + NODE_MASS]) /\n              distance /\n              distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          } else if (distance < 0) {\n            factor =\n              100 *\n              coefficient *\n              NodeMatrix[n1 + NODE_MASS] *\n              NodeMatrix[n2 + NODE_MASS];\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        } else {\n          //-- Linear Repulsion\n          distance = Math.sqrt(xDist * xDist + yDist * yDist);\n\n          if (distance > 0) {\n            factor =\n              (coefficient *\n                NodeMatrix[n1 + NODE_MASS] *\n                NodeMatrix[n2 + NODE_MASS]) /\n              distance /\n              distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        }\n      }\n    }\n  }\n\n  // 3) Gravity\n  //------------\n  g = options.gravity / options.scalingRatio;\n  coefficient = options.scalingRatio;\n  for (n = 0; n < order; n += PPN) {\n    factor = 0;\n\n    // Common to both methods\n    xDist = NodeMatrix[n + NODE_X];\n    yDist = NodeMatrix[n + NODE_Y];\n    distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n\n    if (options.strongGravityMode) {\n      //-- Strong gravity\n      if (distance > 0) factor = coefficient * NodeMatrix[n + NODE_MASS] * g;\n    } else {\n      //-- Linear Anti-collision Repulsion n\n      if (distance > 0)\n        factor = (coefficient * NodeMatrix[n + NODE_MASS] * g) / distance;\n    }\n\n    // Updating node's dx and dy\n    NodeMatrix[n + NODE_DX] -= xDist * factor;\n    NodeMatrix[n + NODE_DY] -= yDist * factor;\n  }\n\n  // 4) Attraction\n  //---------------\n  coefficient =\n    1 * (options.outboundAttractionDistribution ? outboundAttCompensation : 1);\n\n  // TODO: simplify distance\n  // TODO: coefficient is always used as -c --> optimize?\n  for (e = 0; e < size; e += PPE) {\n    n1 = EdgeMatrix[e + EDGE_SOURCE];\n    n2 = EdgeMatrix[e + EDGE_TARGET];\n    w = EdgeMatrix[e + EDGE_WEIGHT];\n\n    // Edge weight influence\n    ewc = Math.pow(w, options.edgeWeightInfluence);\n\n    // Common measures\n    xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n    yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n    // Applying attraction to nodes\n    if (adjustSizes === true) {\n      distance =\n        Math.sqrt(xDist * xDist + yDist * yDist) -\n        NodeMatrix[n1 + NODE_SIZE] -\n        NodeMatrix[n2 + NODE_SIZE];\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n          //-- LinLog Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor =\n              (-coefficient * ewc * Math.log(1 + distance)) /\n              distance /\n              NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- LinLog Anti-collision Attraction\n          if (distance > 0) {\n            factor = (-coefficient * ewc * Math.log(1 + distance)) / distance;\n          }\n        }\n      } else {\n        if (options.outboundAttractionDistribution) {\n          //-- Linear Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor = (-coefficient * ewc) / NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- Linear Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc;\n          }\n        }\n      }\n    } else {\n      distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n          //-- LinLog Degree Distributed Attraction\n          if (distance > 0) {\n            factor =\n              (-coefficient * ewc * Math.log(1 + distance)) /\n              distance /\n              NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- LinLog Attraction\n          if (distance > 0)\n            factor = (-coefficient * ewc * Math.log(1 + distance)) / distance;\n        }\n      } else {\n        if (options.outboundAttractionDistribution) {\n          //-- Linear Attraction Mass Distributed\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = (-coefficient * ewc) / NodeMatrix[n1 + NODE_MASS];\n        } else {\n          //-- Linear Attraction\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = -coefficient * ewc;\n        }\n      }\n    }\n\n    // Updating nodes' dx and dy\n    // TODO: if condition or factor = 1?\n    if (distance > 0) {\n      // Updating nodes' dx and dy\n      NodeMatrix[n1 + NODE_DX] += xDist * factor;\n      NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n      NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n      NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n    }\n  }\n\n  // 5) Apply Forces\n  //-----------------\n  var force, swinging, traction, nodespeed, newX, newY;\n\n  // MATH: sqrt and square distances\n  if (adjustSizes === true) {\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n        force = Math.sqrt(\n          Math.pow(NodeMatrix[n + NODE_DX], 2) +\n            Math.pow(NodeMatrix[n + NODE_DY], 2)\n        );\n\n        if (force > MAX_FORCE) {\n          NodeMatrix[n + NODE_DX] =\n            (NodeMatrix[n + NODE_DX] * MAX_FORCE) / force;\n          NodeMatrix[n + NODE_DY] =\n            (NodeMatrix[n + NODE_DY] * MAX_FORCE) / force;\n        }\n\n        swinging =\n          NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction =\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n          ) / 2;\n\n        nodespeed = (0.1 * Math.log(1 + traction)) / (1 + Math.sqrt(swinging));\n\n        // Updating node's positon\n        newX =\n          NodeMatrix[n + NODE_X] +\n          NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY =\n          NodeMatrix[n + NODE_Y] +\n          NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  } else {\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n        swinging =\n          NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction =\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n          ) / 2;\n\n        nodespeed =\n          (NodeMatrix[n + NODE_CONVERGENCE] * Math.log(1 + traction)) /\n          (1 + Math.sqrt(swinging));\n\n        // Updating node convergence\n        NodeMatrix[n + NODE_CONVERGENCE] = Math.min(\n          1,\n          Math.sqrt(\n            (nodespeed *\n              (Math.pow(NodeMatrix[n + NODE_DX], 2) +\n                Math.pow(NodeMatrix[n + NODE_DY], 2))) /\n              (1 + Math.sqrt(swinging))\n          )\n        );\n\n        // Updating node's positon\n        newX =\n          NodeMatrix[n + NODE_X] +\n          NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY =\n          NodeMatrix[n + NODE_Y] +\n          NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  }\n\n  // We return the information about the layout (no need to return the matrices)\n  return {};\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQtZm9yY2VhdGxhczIvaXRlcmF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxjQUFjO0FBQzFCLFlBQVksY0FBYztBQUMxQixZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QixtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3Nwb25zYXJ1Ly4vbm9kZV9tb2R1bGVzL2dyYXBob2xvZ3ktbGF5b3V0LWZvcmNlYXRsYXMyL2l0ZXJhdGUuanM/ZWVjZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQgbm8tY29uc3RhbnQtY29uZGl0aW9uOiAwICovXG4vKipcbiAqIEdyYXBob2xvZ3kgRm9yY2VBdGxhczIgSXRlcmF0aW9uXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIHBlcmZvcm0gYSBzaW5nbGUgaXRlcmF0aW9uIG9mIHRoZSBhbGdvcml0aG0uXG4gKi9cblxuLyoqXG4gKiBNYXRyaWNlcyBwcm9wZXJ0aWVzIGFjY2Vzc29ycy5cbiAqL1xudmFyIE5PREVfWCA9IDA7XG52YXIgTk9ERV9ZID0gMTtcbnZhciBOT0RFX0RYID0gMjtcbnZhciBOT0RFX0RZID0gMztcbnZhciBOT0RFX09MRF9EWCA9IDQ7XG52YXIgTk9ERV9PTERfRFkgPSA1O1xudmFyIE5PREVfTUFTUyA9IDY7XG52YXIgTk9ERV9DT05WRVJHRU5DRSA9IDc7XG52YXIgTk9ERV9TSVpFID0gODtcbnZhciBOT0RFX0ZJWEVEID0gOTtcblxudmFyIEVER0VfU09VUkNFID0gMDtcbnZhciBFREdFX1RBUkdFVCA9IDE7XG52YXIgRURHRV9XRUlHSFQgPSAyO1xuXG52YXIgUkVHSU9OX05PREUgPSAwO1xudmFyIFJFR0lPTl9DRU5URVJfWCA9IDE7XG52YXIgUkVHSU9OX0NFTlRFUl9ZID0gMjtcbnZhciBSRUdJT05fU0laRSA9IDM7XG52YXIgUkVHSU9OX05FWFRfU0lCTElORyA9IDQ7XG52YXIgUkVHSU9OX0ZJUlNUX0NISUxEID0gNTtcbnZhciBSRUdJT05fTUFTUyA9IDY7XG52YXIgUkVHSU9OX01BU1NfQ0VOVEVSX1ggPSA3O1xudmFyIFJFR0lPTl9NQVNTX0NFTlRFUl9ZID0gODtcblxudmFyIFNVQkRJVklTSU9OX0FUVEVNUFRTID0gMztcblxuLyoqXG4gKiBDb25zdGFudHMuXG4gKi9cbnZhciBQUE4gPSAxMDtcbnZhciBQUEUgPSAzO1xudmFyIFBQUiA9IDk7XG5cbnZhciBNQVhfRk9SQ0UgPSAxMDtcblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIHBlcmZvcm0gYSBzaW5nbGUgaW50ZXJhdGlvbiBvZiB0aGUgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gICAgICAgb3B0aW9ucyAgICAtIExheW91dCBvcHRpb25zLlxuICogQHBhcmFtICB7RmxvYXQzMkFycmF5fSBOb2RlTWF0cml4IC0gTm9kZSBkYXRhLlxuICogQHBhcmFtICB7RmxvYXQzMkFycmF5fSBFZGdlTWF0cml4IC0gRWRnZSBkYXRhLlxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICAgIC0gU29tZSBtZXRhZGF0YS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpdGVyYXRlKG9wdGlvbnMsIE5vZGVNYXRyaXgsIEVkZ2VNYXRyaXgpIHtcbiAgLy8gSW5pdGlhbGl6aW5nIHZhcmlhYmxlc1xuICB2YXIgbCwgciwgbiwgbjEsIG4yLCBybiwgZSwgdywgZywgcztcblxuICB2YXIgb3JkZXIgPSBOb2RlTWF0cml4Lmxlbmd0aCxcbiAgICBzaXplID0gRWRnZU1hdHJpeC5sZW5ndGg7XG5cbiAgdmFyIGFkanVzdFNpemVzID0gb3B0aW9ucy5hZGp1c3RTaXplcztcblxuICB2YXIgdGhldGFTcXVhcmVkID0gb3B0aW9ucy5iYXJuZXNIdXRUaGV0YSAqIG9wdGlvbnMuYmFybmVzSHV0VGhldGE7XG5cbiAgdmFyIG91dGJvdW5kQXR0Q29tcGVuc2F0aW9uLCBjb2VmZmljaWVudCwgeERpc3QsIHlEaXN0LCBld2MsIGRpc3RhbmNlLCBmYWN0b3I7XG5cbiAgdmFyIFJlZ2lvbk1hdHJpeCA9IFtdO1xuXG4gIC8vIDEpIEluaXRpYWxpemluZyBsYXlvdXQgZGF0YVxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUmVzZXR0aW5nIHBvc2l0aW9ucyAmIGNvbXB1dGluZyBtYXggdmFsdWVzXG4gIGZvciAobiA9IDA7IG4gPCBvcmRlcjsgbiArPSBQUE4pIHtcbiAgICBOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWF0gPSBOb2RlTWF0cml4W24gKyBOT0RFX0RYXTtcbiAgICBOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWV0gPSBOb2RlTWF0cml4W24gKyBOT0RFX0RZXTtcbiAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RYXSA9IDA7XG4gICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0gPSAwO1xuICB9XG5cbiAgLy8gSWYgb3V0Ym91bmQgYXR0cmFjdGlvbiBkaXN0cmlidXRpb24sIGNvbXBlbnNhdGVcbiAgaWYgKG9wdGlvbnMub3V0Ym91bmRBdHRyYWN0aW9uRGlzdHJpYnV0aW9uKSB7XG4gICAgb3V0Ym91bmRBdHRDb21wZW5zYXRpb24gPSAwO1xuICAgIGZvciAobiA9IDA7IG4gPCBvcmRlcjsgbiArPSBQUE4pIHtcbiAgICAgIG91dGJvdW5kQXR0Q29tcGVuc2F0aW9uICs9IE5vZGVNYXRyaXhbbiArIE5PREVfTUFTU107XG4gICAgfVxuXG4gICAgb3V0Ym91bmRBdHRDb21wZW5zYXRpb24gLz0gb3JkZXIgLyBQUE47XG4gIH1cblxuICAvLyAxLmJpcykgQmFybmVzLUh1dCBjb21wdXRhdGlvblxuICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGlmIChvcHRpb25zLmJhcm5lc0h1dE9wdGltaXplKSB7XG4gICAgLy8gU2V0dGluZyB1cFxuICAgIHZhciBtaW5YID0gSW5maW5pdHksXG4gICAgICBtYXhYID0gLUluZmluaXR5LFxuICAgICAgbWluWSA9IEluZmluaXR5LFxuICAgICAgbWF4WSA9IC1JbmZpbml0eSxcbiAgICAgIHEsXG4gICAgICBxMixcbiAgICAgIHN1YmRpdmlzaW9uQXR0ZW1wdHM7XG5cbiAgICAvLyBDb21wdXRpbmcgbWluIGFuZCBtYXggdmFsdWVzXG4gICAgZm9yIChuID0gMDsgbiA8IG9yZGVyOyBuICs9IFBQTikge1xuICAgICAgbWluWCA9IE1hdGgubWluKG1pblgsIE5vZGVNYXRyaXhbbiArIE5PREVfWF0pO1xuICAgICAgbWF4WCA9IE1hdGgubWF4KG1heFgsIE5vZGVNYXRyaXhbbiArIE5PREVfWF0pO1xuICAgICAgbWluWSA9IE1hdGgubWluKG1pblksIE5vZGVNYXRyaXhbbiArIE5PREVfWV0pO1xuICAgICAgbWF4WSA9IE1hdGgubWF4KG1heFksIE5vZGVNYXRyaXhbbiArIE5PREVfWV0pO1xuICAgIH1cblxuICAgIC8vIHNxdWFyaWZ5IGJvdW5kcywgaXQncyBhIHF1YWR0cmVlXG4gICAgdmFyIGR4ID0gbWF4WCAtIG1pblgsXG4gICAgICBkeSA9IG1heFkgLSBtaW5ZO1xuICAgIGlmIChkeCA+IGR5KSB7XG4gICAgICBtaW5ZIC09IChkeCAtIGR5KSAvIDI7XG4gICAgICBtYXhZID0gbWluWSArIGR4O1xuICAgIH0gZWxzZSB7XG4gICAgICBtaW5YIC09IChkeSAtIGR4KSAvIDI7XG4gICAgICBtYXhYID0gbWluWCArIGR5O1xuICAgIH1cblxuICAgIC8vIEJ1aWxkIHRoZSBCYXJuZXMgSHV0IHJvb3QgcmVnaW9uXG4gICAgUmVnaW9uTWF0cml4WzAgKyBSRUdJT05fTk9ERV0gPSAtMTtcbiAgICBSZWdpb25NYXRyaXhbMCArIFJFR0lPTl9DRU5URVJfWF0gPSAobWluWCArIG1heFgpIC8gMjtcbiAgICBSZWdpb25NYXRyaXhbMCArIFJFR0lPTl9DRU5URVJfWV0gPSAobWluWSArIG1heFkpIC8gMjtcbiAgICBSZWdpb25NYXRyaXhbMCArIFJFR0lPTl9TSVpFXSA9IE1hdGgubWF4KG1heFggLSBtaW5YLCBtYXhZIC0gbWluWSk7XG4gICAgUmVnaW9uTWF0cml4WzAgKyBSRUdJT05fTkVYVF9TSUJMSU5HXSA9IC0xO1xuICAgIFJlZ2lvbk1hdHJpeFswICsgUkVHSU9OX0ZJUlNUX0NISUxEXSA9IC0xO1xuICAgIFJlZ2lvbk1hdHJpeFswICsgUkVHSU9OX01BU1NdID0gMDtcbiAgICBSZWdpb25NYXRyaXhbMCArIFJFR0lPTl9NQVNTX0NFTlRFUl9YXSA9IDA7XG4gICAgUmVnaW9uTWF0cml4WzAgKyBSRUdJT05fTUFTU19DRU5URVJfWV0gPSAwO1xuXG4gICAgLy8gQWRkIGVhY2ggbm9kZSBpbiB0aGUgdHJlZVxuICAgIGwgPSAxO1xuICAgIGZvciAobiA9IDA7IG4gPCBvcmRlcjsgbiArPSBQUE4pIHtcbiAgICAgIC8vIEN1cnJlbnQgcmVnaW9uLCBzdGFydGluZyB3aXRoIHJvb3RcbiAgICAgIHIgPSAwO1xuICAgICAgc3ViZGl2aXNpb25BdHRlbXB0cyA9IFNVQkRJVklTSU9OX0FUVEVNUFRTO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAvLyBBcmUgdGhlcmUgc3ViLXJlZ2lvbnM/XG5cbiAgICAgICAgLy8gV2UgbG9vayBhdCBmaXJzdCBjaGlsZCBpbmRleFxuICAgICAgICBpZiAoUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fRklSU1RfQ0hJTERdID49IDApIHtcbiAgICAgICAgICAvLyBUaGVyZSBhcmUgc3ViLXJlZ2lvbnNcblxuICAgICAgICAgIC8vIFdlIGp1c3QgaXRlcmF0ZSB0byBmaW5kIGEgXCJsZWFmXCIgb2YgdGhlIHRyZWVcbiAgICAgICAgICAvLyB0aGF0IGlzIGFuIGVtcHR5IHJlZ2lvbiBvciBhIHJlZ2lvbiB3aXRoIGEgc2luZ2xlIG5vZGVcbiAgICAgICAgICAvLyAoc2VlIG5leHQgY2FzZSlcblxuICAgICAgICAgIC8vIEZpbmQgdGhlIHF1YWRyYW50IG9mIG5cbiAgICAgICAgICBpZiAoTm9kZU1hdHJpeFtuICsgTk9ERV9YXSA8IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9YXSkge1xuICAgICAgICAgICAgaWYgKE5vZGVNYXRyaXhbbiArIE5PREVfWV0gPCBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9DRU5URVJfWV0pIHtcbiAgICAgICAgICAgICAgLy8gVG9wIExlZnQgcXVhcnRlclxuICAgICAgICAgICAgICBxID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fRklSU1RfQ0hJTERdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gQm90dG9tIExlZnQgcXVhcnRlclxuICAgICAgICAgICAgICBxID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fRklSU1RfQ0hJTERdICsgUFBSO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoTm9kZU1hdHJpeFtuICsgTk9ERV9ZXSA8IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9ZXSkge1xuICAgICAgICAgICAgICAvLyBUb3AgUmlnaHQgcXVhcnRlclxuICAgICAgICAgICAgICBxID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fRklSU1RfQ0hJTERdICsgUFBSICogMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEJvdHRvbSBSaWdodCBxdWFydGVyXG4gICAgICAgICAgICAgIHEgPSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9GSVJTVF9DSElMRF0gKyBQUFIgKiAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVwZGF0ZSBjZW50ZXIgb2YgbWFzcyBhbmQgbWFzcyAod2Ugb25seSBkbyBpdCBmb3Igbm9uLWxlYXZlIHJlZ2lvbnMpXG4gICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU19DRU5URVJfWF0gPVxuICAgICAgICAgICAgKFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NfQ0VOVEVSX1hdICpcbiAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU10gK1xuICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX1hdICogTm9kZU1hdHJpeFtuICsgTk9ERV9NQVNTXSkgL1xuICAgICAgICAgICAgKFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NdICsgTm9kZU1hdHJpeFtuICsgTk9ERV9NQVNTXSk7XG5cbiAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9NQVNTX0NFTlRFUl9ZXSA9XG4gICAgICAgICAgICAoUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU19DRU5URVJfWV0gKlxuICAgICAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9NQVNTXSArXG4gICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfWV0gKiBOb2RlTWF0cml4W24gKyBOT0RFX01BU1NdKSAvXG4gICAgICAgICAgICAoUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU10gKyBOb2RlTWF0cml4W24gKyBOT0RFX01BU1NdKTtcblxuICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NdICs9IE5vZGVNYXRyaXhbbiArIE5PREVfTUFTU107XG5cbiAgICAgICAgICAvLyBJdGVyYXRlIG9uIHRoZSByaWdodCBxdWFkcmFudFxuICAgICAgICAgIHIgPSBxO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZXJlIGFyZSBubyBzdWItcmVnaW9uczogd2UgYXJlIGluIGEgXCJsZWFmXCJcblxuICAgICAgICAgIC8vIElzIHRoZXJlIGEgbm9kZSBpbiB0aGlzIGxlYXZlP1xuICAgICAgICAgIGlmIChSZWdpb25NYXRyaXhbciArIFJFR0lPTl9OT0RFXSA8IDApIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGlzIG5vIG5vZGUgaW4gcmVnaW9uOlxuICAgICAgICAgICAgLy8gd2UgcmVjb3JkIG5vZGUgbiBhbmQgZ28gb25cbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX05PREVdID0gbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBhIG5vZGUgaW4gdGhpcyByZWdpb25cblxuICAgICAgICAgICAgLy8gV2Ugd2lsbCBuZWVkIHRvIGNyZWF0ZSBzdWItcmVnaW9ucywgc3RpY2sgdGhlIHR3b1xuICAgICAgICAgICAgLy8gbm9kZXMgKHRoZSBvbGQgb25lIHJbMF0gYW5kIHRoZSBuZXcgb25lIG4pIGluIHR3b1xuICAgICAgICAgICAgLy8gc3VicmVnaW9ucy4gSWYgdGhleSBmYWxsIGluIHRoZSBzYW1lIHF1YWRyYW50LFxuICAgICAgICAgICAgLy8gd2Ugd2lsbCBpdGVyYXRlLlxuXG4gICAgICAgICAgICAvLyBDcmVhdGUgc3ViLXJlZ2lvbnNcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0ZJUlNUX0NISUxEXSA9IGwgKiBQUFI7XG4gICAgICAgICAgICB3ID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fU0laRV0gLyAyOyAvLyBuZXcgc2l6ZSAoaGFsZilcblxuICAgICAgICAgICAgLy8gTk9URTogd2UgdXNlIHNjcmVlbiBjb29yZGluYXRlc1xuICAgICAgICAgICAgLy8gZnJvbSBUb3AgTGVmdCB0byBCb3R0b20gUmlnaHRcblxuICAgICAgICAgICAgLy8gVG9wIExlZnQgc3ViLXJlZ2lvblxuICAgICAgICAgICAgZyA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0ZJUlNUX0NISUxEXTtcblxuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTk9ERV0gPSAtMTtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX0NFTlRFUl9YXSA9XG4gICAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9YXSAtIHc7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9DRU5URVJfWV0gPVxuICAgICAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9DRU5URVJfWV0gLSB3O1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fU0laRV0gPSB3O1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTkVYVF9TSUJMSU5HXSA9IGcgKyBQUFI7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9GSVJTVF9DSElMRF0gPSAtMTtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX01BU1NdID0gMDtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX01BU1NfQ0VOVEVSX1hdID0gMDtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX01BU1NfQ0VOVEVSX1ldID0gMDtcblxuICAgICAgICAgICAgLy8gQm90dG9tIExlZnQgc3ViLXJlZ2lvblxuICAgICAgICAgICAgZyArPSBQUFI7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9OT0RFXSA9IC0xO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fQ0VOVEVSX1hdID1cbiAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fQ0VOVEVSX1hdIC0gdztcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX0NFTlRFUl9ZXSA9XG4gICAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9ZXSArIHc7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9TSVpFXSA9IHc7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9ORVhUX1NJQkxJTkddID0gZyArIFBQUjtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX0ZJUlNUX0NISUxEXSA9IC0xO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTUFTU10gPSAwO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTUFTU19DRU5URVJfWF0gPSAwO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTUFTU19DRU5URVJfWV0gPSAwO1xuXG4gICAgICAgICAgICAvLyBUb3AgUmlnaHQgc3ViLXJlZ2lvblxuICAgICAgICAgICAgZyArPSBQUFI7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9OT0RFXSA9IC0xO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fQ0VOVEVSX1hdID1cbiAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fQ0VOVEVSX1hdICsgdztcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX0NFTlRFUl9ZXSA9XG4gICAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9ZXSAtIHc7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9TSVpFXSA9IHc7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9ORVhUX1NJQkxJTkddID0gZyArIFBQUjtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX0ZJUlNUX0NISUxEXSA9IC0xO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTUFTU10gPSAwO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTUFTU19DRU5URVJfWF0gPSAwO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTUFTU19DRU5URVJfWV0gPSAwO1xuXG4gICAgICAgICAgICAvLyBCb3R0b20gUmlnaHQgc3ViLXJlZ2lvblxuICAgICAgICAgICAgZyArPSBQUFI7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9OT0RFXSA9IC0xO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fQ0VOVEVSX1hdID1cbiAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fQ0VOVEVSX1hdICsgdztcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX0NFTlRFUl9ZXSA9XG4gICAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9ZXSArIHc7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9TSVpFXSA9IHc7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9ORVhUX1NJQkxJTkddID1cbiAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTkVYVF9TSUJMSU5HXTtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX0ZJUlNUX0NISUxEXSA9IC0xO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTUFTU10gPSAwO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTUFTU19DRU5URVJfWF0gPSAwO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTUFTU19DRU5URVJfWV0gPSAwO1xuXG4gICAgICAgICAgICBsICs9IDQ7XG5cbiAgICAgICAgICAgIC8vIE5vdyB0aGUgZ29hbCBpcyB0byBmaW5kIHR3byBkaWZmZXJlbnQgc3ViLXJlZ2lvbnNcbiAgICAgICAgICAgIC8vIGZvciB0aGUgdHdvIG5vZGVzOiB0aGUgb25lIHByZXZpb3VzbHkgcmVjb3JkZWQgKHJbMF0pXG4gICAgICAgICAgICAvLyBhbmQgdGhlIG9uZSB3ZSB3YW50IHRvIGFkZCAobilcblxuICAgICAgICAgICAgLy8gRmluZCB0aGUgcXVhZHJhbnQgb2YgdGhlIG9sZCBub2RlXG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgIE5vZGVNYXRyaXhbUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTk9ERV0gKyBOT0RFX1hdIDxcbiAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fQ0VOVEVSX1hdXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTk9ERV0gKyBOT0RFX1ldIDxcbiAgICAgICAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9DRU5URVJfWV1cbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9wIExlZnQgcXVhcnRlclxuICAgICAgICAgICAgICAgIHEgPSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9GSVJTVF9DSElMRF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm90dG9tIExlZnQgcXVhcnRlclxuICAgICAgICAgICAgICAgIHEgPSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9GSVJTVF9DSElMRF0gKyBQUFI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBOb2RlTWF0cml4W1JlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX05PREVdICsgTk9ERV9ZXSA8XG4gICAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fQ0VOVEVSX1ldXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIFRvcCBSaWdodCBxdWFydGVyXG4gICAgICAgICAgICAgICAgcSA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0ZJUlNUX0NISUxEXSArIFBQUiAqIDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm90dG9tIFJpZ2h0IHF1YXJ0ZXJcbiAgICAgICAgICAgICAgICBxID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fRklSU1RfQ0hJTERdICsgUFBSICogMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXZSByZW1vdmUgclswXSBmcm9tIHRoZSByZWdpb24gciwgYWRkIGl0cyBtYXNzIHRvIHIgYW5kIHJlY29yZCBpdCBpbiBxXG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9NQVNTXSA9XG4gICAgICAgICAgICAgIE5vZGVNYXRyaXhbUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTk9ERV0gKyBOT0RFX01BU1NdO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU19DRU5URVJfWF0gPVxuICAgICAgICAgICAgICBOb2RlTWF0cml4W1JlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX05PREVdICsgTk9ERV9YXTtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NfQ0VOVEVSX1ldID1cbiAgICAgICAgICAgICAgTm9kZU1hdHJpeFtSZWdpb25NYXRyaXhbciArIFJFR0lPTl9OT0RFXSArIE5PREVfWV07XG5cbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtxICsgUkVHSU9OX05PREVdID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTk9ERV07XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9OT0RFXSA9IC0xO1xuXG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBxdWFkcmFudCBvZiBuXG4gICAgICAgICAgICBpZiAoTm9kZU1hdHJpeFtuICsgTk9ERV9YXSA8IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9YXSkge1xuICAgICAgICAgICAgICBpZiAoTm9kZU1hdHJpeFtuICsgTk9ERV9ZXSA8IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9ZXSkge1xuICAgICAgICAgICAgICAgIC8vIFRvcCBMZWZ0IHF1YXJ0ZXJcbiAgICAgICAgICAgICAgICBxMiA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0ZJUlNUX0NISUxEXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCb3R0b20gTGVmdCBxdWFydGVyXG4gICAgICAgICAgICAgICAgcTIgPSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9GSVJTVF9DSElMRF0gKyBQUFI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGlmIChOb2RlTWF0cml4W24gKyBOT0RFX1ldIDwgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fQ0VOVEVSX1ldKSB7XG4gICAgICAgICAgICAgICAgLy8gVG9wIFJpZ2h0IHF1YXJ0ZXJcbiAgICAgICAgICAgICAgICBxMiA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0ZJUlNUX0NISUxEXSArIFBQUiAqIDI7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm90dG9tIFJpZ2h0IHF1YXJ0ZXJcbiAgICAgICAgICAgICAgICBxMiA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0ZJUlNUX0NISUxEXSArIFBQUiAqIDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHEgPT09IHEyKSB7XG4gICAgICAgICAgICAgIC8vIElmIGJvdGggbm9kZXMgYXJlIGluIHRoZSBzYW1lIHF1YWRyYW50LFxuICAgICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIHRyeSBpdCBhZ2FpbiBvbiB0aGlzIHF1YWRyYW50XG4gICAgICAgICAgICAgIGlmIChzdWJkaXZpc2lvbkF0dGVtcHRzLS0pIHtcbiAgICAgICAgICAgICAgICByID0gcTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gd2hpbGVcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyB3ZSBhcmUgb3V0IG9mIHByZWNpc2lvbiBoZXJlLCBhbmQgd2UgY2Fubm90IHN1YmRpdmlkZSBhbnltb3JlXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgdG8gYnJlYWsgdGhlIGxvb3AgYW55d2F5XG4gICAgICAgICAgICAgICAgc3ViZGl2aXNpb25BdHRlbXB0cyA9IFNVQkRJVklTSU9OX0FUVEVNUFRTO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyB3aGlsZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIGJvdGggcXVhZHJhbnRzIGFyZSBkaWZmZXJlbnQsIHdlIHJlY29yZCBuXG4gICAgICAgICAgICAvLyBpbiBpdHMgcXVhZHJhbnRcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtxMiArIFJFR0lPTl9OT0RFXSA9IG47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAyKSBSZXB1bHNpb25cbiAgLy8tLS0tLS0tLS0tLS0tLVxuICAvLyBOT1RFUzogYWRqdXN0U2l6ZXMgPSBhbnRpQ29sbGlzaW9uICYgc2NhbGluZ1JhdGlvID0gY29lZmZpY2llbnRcblxuICBpZiAob3B0aW9ucy5iYXJuZXNIdXRPcHRpbWl6ZSkge1xuICAgIGNvZWZmaWNpZW50ID0gb3B0aW9ucy5zY2FsaW5nUmF0aW87XG5cbiAgICAvLyBBcHBseWluZyByZXB1bHNpb24gdGhyb3VnaCByZWdpb25zXG4gICAgZm9yIChuID0gMDsgbiA8IG9yZGVyOyBuICs9IFBQTikge1xuICAgICAgLy8gQ29tcHV0aW5nIGxlYWYgcXVhZCBub2RlcyBpdGVyYXRpb25cblxuICAgICAgciA9IDA7IC8vIFN0YXJ0aW5nIHdpdGggcm9vdCByZWdpb25cbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGlmIChSZWdpb25NYXRyaXhbciArIFJFR0lPTl9GSVJTVF9DSElMRF0gPj0gMCkge1xuICAgICAgICAgIC8vIFRoZSByZWdpb24gaGFzIHN1Yi1yZWdpb25zXG5cbiAgICAgICAgICAvLyBXZSBydW4gdGhlIEJhcm5lcyBIdXQgdGVzdCB0byBzZWUgaWYgd2UgYXJlIGF0IHRoZSByaWdodCBkaXN0YW5jZVxuICAgICAgICAgIGRpc3RhbmNlID1cbiAgICAgICAgICAgIE1hdGgucG93KFxuICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX1hdIC0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU19DRU5URVJfWF0sXG4gICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICkgK1xuICAgICAgICAgICAgTWF0aC5wb3coXG4gICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfWV0gLSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9NQVNTX0NFTlRFUl9ZXSxcbiAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgIHMgPSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9TSVpFXTtcblxuICAgICAgICAgIGlmICgoNCAqIHMgKiBzKSAvIGRpc3RhbmNlIDwgdGhldGFTcXVhcmVkKSB7XG4gICAgICAgICAgICAvLyBXZSB0cmVhdCB0aGUgcmVnaW9uIGFzIGEgc2luZ2xlIGJvZHksIGFuZCB3ZSByZXB1bHNlXG5cbiAgICAgICAgICAgIHhEaXN0ID1cbiAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9YXSAtIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NfQ0VOVEVSX1hdO1xuICAgICAgICAgICAgeURpc3QgPVxuICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX1ldIC0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU19DRU5URVJfWV07XG5cbiAgICAgICAgICAgIGlmIChhZGp1c3RTaXplcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAvLy0tIExpbmVhciBBbnRpLWNvbGxpc2lvbiBSZXB1bHNpb25cbiAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIGZhY3RvciA9XG4gICAgICAgICAgICAgICAgICAoY29lZmZpY2llbnQgKlxuICAgICAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX01BU1NdICpcbiAgICAgICAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU10pIC9cbiAgICAgICAgICAgICAgICAgIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWF0gKz0geERpc3QgKiBmYWN0b3I7XG4gICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0gKz0geURpc3QgKiBmYWN0b3I7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yID1cbiAgICAgICAgICAgICAgICAgICgtY29lZmZpY2llbnQgKlxuICAgICAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX01BU1NdICpcbiAgICAgICAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU10pIC9cbiAgICAgICAgICAgICAgICAgIE1hdGguc3FydChkaXN0YW5jZSk7XG5cbiAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RYXSArPSB4RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RZXSArPSB5RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8tLSBMaW5lYXIgUmVwdWxzaW9uXG4gICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICBmYWN0b3IgPVxuICAgICAgICAgICAgICAgICAgKGNvZWZmaWNpZW50ICpcbiAgICAgICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9NQVNTXSAqXG4gICAgICAgICAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NdKSAvXG4gICAgICAgICAgICAgICAgICBkaXN0YW5jZTtcblxuICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdICs9IHhEaXN0ICogZmFjdG9yO1xuICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFldICs9IHlEaXN0ICogZmFjdG9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdoZW4gdGhpcyBpcyBkb25lLCB3ZSBpdGVyYXRlLiBXZSBoYXZlIHRvIGxvb2sgYXQgdGhlIG5leHQgc2libGluZy5cbiAgICAgICAgICAgIHIgPSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9ORVhUX1NJQkxJTkddO1xuICAgICAgICAgICAgaWYgKHIgPCAwKSBicmVhazsgLy8gTm8gbmV4dCBzaWJsaW5nOiB3ZSBoYXZlIGZpbmlzaGVkIHRoZSB0cmVlXG5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgcmVnaW9uIGlzIHRvbyBjbG9zZSBhbmQgd2UgaGF2ZSB0byBsb29rIGF0IHN1Yi1yZWdpb25zXG4gICAgICAgICAgICByID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fRklSU1RfQ0hJTERdO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoZSByZWdpb24gaGFzIG5vIHN1Yi1yZWdpb25cbiAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBhIG5vZGUgclswXSBhbmQgaXQgaXMgbm90IG4sIHRoZW4gcmVwdWxzZVxuICAgICAgICAgIHJuID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTk9ERV07XG5cbiAgICAgICAgICBpZiAocm4gPj0gMCAmJiBybiAhPT0gbikge1xuICAgICAgICAgICAgeERpc3QgPSBOb2RlTWF0cml4W24gKyBOT0RFX1hdIC0gTm9kZU1hdHJpeFtybiArIE5PREVfWF07XG4gICAgICAgICAgICB5RGlzdCA9IE5vZGVNYXRyaXhbbiArIE5PREVfWV0gLSBOb2RlTWF0cml4W3JuICsgTk9ERV9ZXTtcblxuICAgICAgICAgICAgZGlzdGFuY2UgPSB4RGlzdCAqIHhEaXN0ICsgeURpc3QgKiB5RGlzdDtcblxuICAgICAgICAgICAgaWYgKGFkanVzdFNpemVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIC8vLS0gTGluZWFyIEFudGktY29sbGlzaW9uIFJlcHVsc2lvblxuICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yID1cbiAgICAgICAgICAgICAgICAgIChjb2VmZmljaWVudCAqXG4gICAgICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfTUFTU10gKlxuICAgICAgICAgICAgICAgICAgICBOb2RlTWF0cml4W3JuICsgTk9ERV9NQVNTXSkgL1xuICAgICAgICAgICAgICAgICAgZGlzdGFuY2U7XG5cbiAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RYXSArPSB4RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RZXSArPSB5RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChkaXN0YW5jZSA8IDApIHtcbiAgICAgICAgICAgICAgICBmYWN0b3IgPVxuICAgICAgICAgICAgICAgICAgKC1jb2VmZmljaWVudCAqXG4gICAgICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfTUFTU10gKlxuICAgICAgICAgICAgICAgICAgICBOb2RlTWF0cml4W3JuICsgTk9ERV9NQVNTXSkgL1xuICAgICAgICAgICAgICAgICAgTWF0aC5zcXJ0KGRpc3RhbmNlKTtcblxuICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdICs9IHhEaXN0ICogZmFjdG9yO1xuICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFldICs9IHlEaXN0ICogZmFjdG9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLy0tIExpbmVhciBSZXB1bHNpb25cbiAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIGZhY3RvciA9XG4gICAgICAgICAgICAgICAgICAoY29lZmZpY2llbnQgKlxuICAgICAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX01BU1NdICpcbiAgICAgICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtybiArIE5PREVfTUFTU10pIC9cbiAgICAgICAgICAgICAgICAgIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWF0gKz0geERpc3QgKiBmYWN0b3I7XG4gICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0gKz0geURpc3QgKiBmYWN0b3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBXaGVuIHRoaXMgaXMgZG9uZSwgd2UgaXRlcmF0ZS4gV2UgaGF2ZSB0byBsb29rIGF0IHRoZSBuZXh0IHNpYmxpbmcuXG4gICAgICAgICAgciA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX05FWFRfU0lCTElOR107XG5cbiAgICAgICAgICBpZiAociA8IDApIGJyZWFrOyAvLyBObyBuZXh0IHNpYmxpbmc6IHdlIGhhdmUgZmluaXNoZWQgdGhlIHRyZWVcblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvZWZmaWNpZW50ID0gb3B0aW9ucy5zY2FsaW5nUmF0aW87XG5cbiAgICAvLyBTcXVhcmUgaXRlcmF0aW9uXG4gICAgZm9yIChuMSA9IDA7IG4xIDwgb3JkZXI7IG4xICs9IFBQTikge1xuICAgICAgZm9yIChuMiA9IDA7IG4yIDwgbjE7IG4yICs9IFBQTikge1xuICAgICAgICAvLyBDb21tb24gdG8gYm90aCBtZXRob2RzXG4gICAgICAgIHhEaXN0ID0gTm9kZU1hdHJpeFtuMSArIE5PREVfWF0gLSBOb2RlTWF0cml4W24yICsgTk9ERV9YXTtcbiAgICAgICAgeURpc3QgPSBOb2RlTWF0cml4W24xICsgTk9ERV9ZXSAtIE5vZGVNYXRyaXhbbjIgKyBOT0RFX1ldO1xuXG4gICAgICAgIGlmIChhZGp1c3RTaXplcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vLS0gQW50aWNvbGxpc2lvbiBMaW5lYXIgUmVwdWxzaW9uXG4gICAgICAgICAgZGlzdGFuY2UgPVxuICAgICAgICAgICAgTWF0aC5zcXJ0KHhEaXN0ICogeERpc3QgKyB5RGlzdCAqIHlEaXN0KSAtXG4gICAgICAgICAgICBOb2RlTWF0cml4W24xICsgTk9ERV9TSVpFXSAtXG4gICAgICAgICAgICBOb2RlTWF0cml4W24yICsgTk9ERV9TSVpFXTtcblxuICAgICAgICAgIGlmIChkaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgIGZhY3RvciA9XG4gICAgICAgICAgICAgIChjb2VmZmljaWVudCAqXG4gICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuMSArIE5PREVfTUFTU10gKlxuICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbjIgKyBOT0RFX01BU1NdKSAvXG4gICAgICAgICAgICAgIGRpc3RhbmNlIC9cbiAgICAgICAgICAgICAgZGlzdGFuY2U7XG5cbiAgICAgICAgICAgIC8vIFVwZGF0aW5nIG5vZGVzJyBkeCBhbmQgZHlcbiAgICAgICAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX0RYXSArPSB4RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX0RZXSArPSB5RGlzdCAqIGZhY3RvcjtcblxuICAgICAgICAgICAgTm9kZU1hdHJpeFtuMiArIE5PREVfRFhdIC09IHhEaXN0ICogZmFjdG9yO1xuICAgICAgICAgICAgTm9kZU1hdHJpeFtuMiArIE5PREVfRFldIC09IHlEaXN0ICogZmFjdG9yO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPCAwKSB7XG4gICAgICAgICAgICBmYWN0b3IgPVxuICAgICAgICAgICAgICAxMDAgKlxuICAgICAgICAgICAgICBjb2VmZmljaWVudCAqXG4gICAgICAgICAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX01BU1NdICpcbiAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuMiArIE5PREVfTUFTU107XG5cbiAgICAgICAgICAgIC8vIFVwZGF0aW5nIG5vZGVzJyBkeCBhbmQgZHlcbiAgICAgICAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX0RYXSArPSB4RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX0RZXSArPSB5RGlzdCAqIGZhY3RvcjtcblxuICAgICAgICAgICAgTm9kZU1hdHJpeFtuMiArIE5PREVfRFhdIC09IHhEaXN0ICogZmFjdG9yO1xuICAgICAgICAgICAgTm9kZU1hdHJpeFtuMiArIE5PREVfRFldIC09IHlEaXN0ICogZmFjdG9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLy0tIExpbmVhciBSZXB1bHNpb25cbiAgICAgICAgICBkaXN0YW5jZSA9IE1hdGguc3FydCh4RGlzdCAqIHhEaXN0ICsgeURpc3QgKiB5RGlzdCk7XG5cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICBmYWN0b3IgPVxuICAgICAgICAgICAgICAoY29lZmZpY2llbnQgKlxuICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX01BU1NdICpcbiAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24yICsgTk9ERV9NQVNTXSkgL1xuICAgICAgICAgICAgICBkaXN0YW5jZSAvXG4gICAgICAgICAgICAgIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGluZyBub2RlcycgZHggYW5kIGR5XG4gICAgICAgICAgICBOb2RlTWF0cml4W24xICsgTk9ERV9EWF0gKz0geERpc3QgKiBmYWN0b3I7XG4gICAgICAgICAgICBOb2RlTWF0cml4W24xICsgTk9ERV9EWV0gKz0geURpc3QgKiBmYWN0b3I7XG5cbiAgICAgICAgICAgIE5vZGVNYXRyaXhbbjIgKyBOT0RFX0RYXSAtPSB4RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgIE5vZGVNYXRyaXhbbjIgKyBOT0RFX0RZXSAtPSB5RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyAzKSBHcmF2aXR5XG4gIC8vLS0tLS0tLS0tLS0tXG4gIGcgPSBvcHRpb25zLmdyYXZpdHkgLyBvcHRpb25zLnNjYWxpbmdSYXRpbztcbiAgY29lZmZpY2llbnQgPSBvcHRpb25zLnNjYWxpbmdSYXRpbztcbiAgZm9yIChuID0gMDsgbiA8IG9yZGVyOyBuICs9IFBQTikge1xuICAgIGZhY3RvciA9IDA7XG5cbiAgICAvLyBDb21tb24gdG8gYm90aCBtZXRob2RzXG4gICAgeERpc3QgPSBOb2RlTWF0cml4W24gKyBOT0RFX1hdO1xuICAgIHlEaXN0ID0gTm9kZU1hdHJpeFtuICsgTk9ERV9ZXTtcbiAgICBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh4RGlzdCwgMikgKyBNYXRoLnBvdyh5RGlzdCwgMikpO1xuXG4gICAgaWYgKG9wdGlvbnMuc3Ryb25nR3Jhdml0eU1vZGUpIHtcbiAgICAgIC8vLS0gU3Ryb25nIGdyYXZpdHlcbiAgICAgIGlmIChkaXN0YW5jZSA+IDApIGZhY3RvciA9IGNvZWZmaWNpZW50ICogTm9kZU1hdHJpeFtuICsgTk9ERV9NQVNTXSAqIGc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vLS0gTGluZWFyIEFudGktY29sbGlzaW9uIFJlcHVsc2lvbiBuXG4gICAgICBpZiAoZGlzdGFuY2UgPiAwKVxuICAgICAgICBmYWN0b3IgPSAoY29lZmZpY2llbnQgKiBOb2RlTWF0cml4W24gKyBOT0RFX01BU1NdICogZykgLyBkaXN0YW5jZTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGluZyBub2RlJ3MgZHggYW5kIGR5XG4gICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWF0gLT0geERpc3QgKiBmYWN0b3I7XG4gICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0gLT0geURpc3QgKiBmYWN0b3I7XG4gIH1cblxuICAvLyA0KSBBdHRyYWN0aW9uXG4gIC8vLS0tLS0tLS0tLS0tLS0tXG4gIGNvZWZmaWNpZW50ID1cbiAgICAxICogKG9wdGlvbnMub3V0Ym91bmRBdHRyYWN0aW9uRGlzdHJpYnV0aW9uID8gb3V0Ym91bmRBdHRDb21wZW5zYXRpb24gOiAxKTtcblxuICAvLyBUT0RPOiBzaW1wbGlmeSBkaXN0YW5jZVxuICAvLyBUT0RPOiBjb2VmZmljaWVudCBpcyBhbHdheXMgdXNlZCBhcyAtYyAtLT4gb3B0aW1pemU/XG4gIGZvciAoZSA9IDA7IGUgPCBzaXplOyBlICs9IFBQRSkge1xuICAgIG4xID0gRWRnZU1hdHJpeFtlICsgRURHRV9TT1VSQ0VdO1xuICAgIG4yID0gRWRnZU1hdHJpeFtlICsgRURHRV9UQVJHRVRdO1xuICAgIHcgPSBFZGdlTWF0cml4W2UgKyBFREdFX1dFSUdIVF07XG5cbiAgICAvLyBFZGdlIHdlaWdodCBpbmZsdWVuY2VcbiAgICBld2MgPSBNYXRoLnBvdyh3LCBvcHRpb25zLmVkZ2VXZWlnaHRJbmZsdWVuY2UpO1xuXG4gICAgLy8gQ29tbW9uIG1lYXN1cmVzXG4gICAgeERpc3QgPSBOb2RlTWF0cml4W24xICsgTk9ERV9YXSAtIE5vZGVNYXRyaXhbbjIgKyBOT0RFX1hdO1xuICAgIHlEaXN0ID0gTm9kZU1hdHJpeFtuMSArIE5PREVfWV0gLSBOb2RlTWF0cml4W24yICsgTk9ERV9ZXTtcblxuICAgIC8vIEFwcGx5aW5nIGF0dHJhY3Rpb24gdG8gbm9kZXNcbiAgICBpZiAoYWRqdXN0U2l6ZXMgPT09IHRydWUpIHtcbiAgICAgIGRpc3RhbmNlID1cbiAgICAgICAgTWF0aC5zcXJ0KHhEaXN0ICogeERpc3QgKyB5RGlzdCAqIHlEaXN0KSAtXG4gICAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX1NJWkVdIC1cbiAgICAgICAgTm9kZU1hdHJpeFtuMiArIE5PREVfU0laRV07XG5cbiAgICAgIGlmIChvcHRpb25zLmxpbkxvZ01vZGUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0Ym91bmRBdHRyYWN0aW9uRGlzdHJpYnV0aW9uKSB7XG4gICAgICAgICAgLy8tLSBMaW5Mb2cgRGVncmVlIERpc3RyaWJ1dGVkIEFudGktY29sbGlzaW9uIEF0dHJhY3Rpb25cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICBmYWN0b3IgPVxuICAgICAgICAgICAgICAoLWNvZWZmaWNpZW50ICogZXdjICogTWF0aC5sb2coMSArIGRpc3RhbmNlKSkgL1xuICAgICAgICAgICAgICBkaXN0YW5jZSAvXG4gICAgICAgICAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX01BU1NdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLy0tIExpbkxvZyBBbnRpLWNvbGxpc2lvbiBBdHRyYWN0aW9uXG4gICAgICAgICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgZmFjdG9yID0gKC1jb2VmZmljaWVudCAqIGV3YyAqIE1hdGgubG9nKDEgKyBkaXN0YW5jZSkpIC8gZGlzdGFuY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRib3VuZEF0dHJhY3Rpb25EaXN0cmlidXRpb24pIHtcbiAgICAgICAgICAvLy0tIExpbmVhciBEZWdyZWUgRGlzdHJpYnV0ZWQgQW50aS1jb2xsaXNpb24gQXR0cmFjdGlvblxuICAgICAgICAgIGlmIChkaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgIGZhY3RvciA9ICgtY29lZmZpY2llbnQgKiBld2MpIC8gTm9kZU1hdHJpeFtuMSArIE5PREVfTUFTU107XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vLS0gTGluZWFyIEFudGktY29sbGlzaW9uIEF0dHJhY3Rpb25cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICBmYWN0b3IgPSAtY29lZmZpY2llbnQgKiBld2M7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc3RhbmNlID0gTWF0aC5zcXJ0KE1hdGgucG93KHhEaXN0LCAyKSArIE1hdGgucG93KHlEaXN0LCAyKSk7XG5cbiAgICAgIGlmIChvcHRpb25zLmxpbkxvZ01vZGUpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0Ym91bmRBdHRyYWN0aW9uRGlzdHJpYnV0aW9uKSB7XG4gICAgICAgICAgLy8tLSBMaW5Mb2cgRGVncmVlIERpc3RyaWJ1dGVkIEF0dHJhY3Rpb25cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICBmYWN0b3IgPVxuICAgICAgICAgICAgICAoLWNvZWZmaWNpZW50ICogZXdjICogTWF0aC5sb2coMSArIGRpc3RhbmNlKSkgL1xuICAgICAgICAgICAgICBkaXN0YW5jZSAvXG4gICAgICAgICAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX01BU1NdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLy0tIExpbkxvZyBBdHRyYWN0aW9uXG4gICAgICAgICAgaWYgKGRpc3RhbmNlID4gMClcbiAgICAgICAgICAgIGZhY3RvciA9ICgtY29lZmZpY2llbnQgKiBld2MgKiBNYXRoLmxvZygxICsgZGlzdGFuY2UpKSAvIGRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAob3B0aW9ucy5vdXRib3VuZEF0dHJhY3Rpb25EaXN0cmlidXRpb24pIHtcbiAgICAgICAgICAvLy0tIExpbmVhciBBdHRyYWN0aW9uIE1hc3MgRGlzdHJpYnV0ZWRcbiAgICAgICAgICAvLyBOT1RFOiBEaXN0YW5jZSBpcyBzZXQgdG8gMSB0byBvdmVycmlkZSBuZXh0IGNvbmRpdGlvblxuICAgICAgICAgIGRpc3RhbmNlID0gMTtcbiAgICAgICAgICBmYWN0b3IgPSAoLWNvZWZmaWNpZW50ICogZXdjKSAvIE5vZGVNYXRyaXhbbjEgKyBOT0RFX01BU1NdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vLS0gTGluZWFyIEF0dHJhY3Rpb25cbiAgICAgICAgICAvLyBOT1RFOiBEaXN0YW5jZSBpcyBzZXQgdG8gMSB0byBvdmVycmlkZSBuZXh0IGNvbmRpdGlvblxuICAgICAgICAgIGRpc3RhbmNlID0gMTtcbiAgICAgICAgICBmYWN0b3IgPSAtY29lZmZpY2llbnQgKiBld2M7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVcGRhdGluZyBub2RlcycgZHggYW5kIGR5XG4gICAgLy8gVE9ETzogaWYgY29uZGl0aW9uIG9yIGZhY3RvciA9IDE/XG4gICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgLy8gVXBkYXRpbmcgbm9kZXMnIGR4IGFuZCBkeVxuICAgICAgTm9kZU1hdHJpeFtuMSArIE5PREVfRFhdICs9IHhEaXN0ICogZmFjdG9yO1xuICAgICAgTm9kZU1hdHJpeFtuMSArIE5PREVfRFldICs9IHlEaXN0ICogZmFjdG9yO1xuXG4gICAgICBOb2RlTWF0cml4W24yICsgTk9ERV9EWF0gLT0geERpc3QgKiBmYWN0b3I7XG4gICAgICBOb2RlTWF0cml4W24yICsgTk9ERV9EWV0gLT0geURpc3QgKiBmYWN0b3I7XG4gICAgfVxuICB9XG5cbiAgLy8gNSkgQXBwbHkgRm9yY2VzXG4gIC8vLS0tLS0tLS0tLS0tLS0tLS1cbiAgdmFyIGZvcmNlLCBzd2luZ2luZywgdHJhY3Rpb24sIG5vZGVzcGVlZCwgbmV3WCwgbmV3WTtcblxuICAvLyBNQVRIOiBzcXJ0IGFuZCBzcXVhcmUgZGlzdGFuY2VzXG4gIGlmIChhZGp1c3RTaXplcyA9PT0gdHJ1ZSkge1xuICAgIGZvciAobiA9IDA7IG4gPCBvcmRlcjsgbiArPSBQUE4pIHtcbiAgICAgIGlmIChOb2RlTWF0cml4W24gKyBOT0RFX0ZJWEVEXSAhPT0gMSkge1xuICAgICAgICBmb3JjZSA9IE1hdGguc3FydChcbiAgICAgICAgICBNYXRoLnBvdyhOb2RlTWF0cml4W24gKyBOT0RFX0RYXSwgMikgK1xuICAgICAgICAgICAgTWF0aC5wb3coTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0sIDIpXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKGZvcmNlID4gTUFYX0ZPUkNFKSB7XG4gICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWF0gPVxuICAgICAgICAgICAgKE5vZGVNYXRyaXhbbiArIE5PREVfRFhdICogTUFYX0ZPUkNFKSAvIGZvcmNlO1xuICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFldID1cbiAgICAgICAgICAgIChOb2RlTWF0cml4W24gKyBOT0RFX0RZXSAqIE1BWF9GT1JDRSkgLyBmb3JjZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN3aW5naW5nID1cbiAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX01BU1NdICpcbiAgICAgICAgICBNYXRoLnNxcnQoXG4gICAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFhdIC0gTm9kZU1hdHJpeFtuICsgTk9ERV9EWF0pICpcbiAgICAgICAgICAgICAgKE5vZGVNYXRyaXhbbiArIE5PREVfT0xEX0RYXSAtIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdKSArXG4gICAgICAgICAgICAgIChOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWV0gLSBOb2RlTWF0cml4W24gKyBOT0RFX0RZXSkgKlxuICAgICAgICAgICAgICAgIChOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWV0gLSBOb2RlTWF0cml4W24gKyBOT0RFX0RZXSlcbiAgICAgICAgICApO1xuXG4gICAgICAgIHRyYWN0aW9uID1cbiAgICAgICAgICBNYXRoLnNxcnQoXG4gICAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFhdICsgTm9kZU1hdHJpeFtuICsgTk9ERV9EWF0pICpcbiAgICAgICAgICAgICAgKE5vZGVNYXRyaXhbbiArIE5PREVfT0xEX0RYXSArIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdKSArXG4gICAgICAgICAgICAgIChOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWV0gKyBOb2RlTWF0cml4W24gKyBOT0RFX0RZXSkgKlxuICAgICAgICAgICAgICAgIChOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWV0gKyBOb2RlTWF0cml4W24gKyBOT0RFX0RZXSlcbiAgICAgICAgICApIC8gMjtcblxuICAgICAgICBub2Rlc3BlZWQgPSAoMC4xICogTWF0aC5sb2coMSArIHRyYWN0aW9uKSkgLyAoMSArIE1hdGguc3FydChzd2luZ2luZykpO1xuXG4gICAgICAgIC8vIFVwZGF0aW5nIG5vZGUncyBwb3NpdG9uXG4gICAgICAgIG5ld1ggPVxuICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfWF0gK1xuICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdICogKG5vZGVzcGVlZCAvIG9wdGlvbnMuc2xvd0Rvd24pO1xuICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX1hdID0gbmV3WDtcblxuICAgICAgICBuZXdZID1cbiAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX1ldICtcbiAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RZXSAqIChub2Rlc3BlZWQgLyBvcHRpb25zLnNsb3dEb3duKTtcbiAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9ZXSA9IG5ld1k7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobiA9IDA7IG4gPCBvcmRlcjsgbiArPSBQUE4pIHtcbiAgICAgIGlmIChOb2RlTWF0cml4W24gKyBOT0RFX0ZJWEVEXSAhPT0gMSkge1xuICAgICAgICBzd2luZ2luZyA9XG4gICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9NQVNTXSAqXG4gICAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgICAgKE5vZGVNYXRyaXhbbiArIE5PREVfT0xEX0RYXSAtIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdKSAqXG4gICAgICAgICAgICAgIChOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWF0gLSBOb2RlTWF0cml4W24gKyBOT0RFX0RYXSkgK1xuICAgICAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFldIC0gTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0pICpcbiAgICAgICAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFldIC0gTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0pXG4gICAgICAgICAgKTtcblxuICAgICAgICB0cmFjdGlvbiA9XG4gICAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgICAgKE5vZGVNYXRyaXhbbiArIE5PREVfT0xEX0RYXSArIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdKSAqXG4gICAgICAgICAgICAgIChOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWF0gKyBOb2RlTWF0cml4W24gKyBOT0RFX0RYXSkgK1xuICAgICAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFldICsgTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0pICpcbiAgICAgICAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFldICsgTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0pXG4gICAgICAgICAgKSAvIDI7XG5cbiAgICAgICAgbm9kZXNwZWVkID1cbiAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9DT05WRVJHRU5DRV0gKiBNYXRoLmxvZygxICsgdHJhY3Rpb24pKSAvXG4gICAgICAgICAgKDEgKyBNYXRoLnNxcnQoc3dpbmdpbmcpKTtcblxuICAgICAgICAvLyBVcGRhdGluZyBub2RlIGNvbnZlcmdlbmNlXG4gICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfQ09OVkVSR0VOQ0VdID0gTWF0aC5taW4oXG4gICAgICAgICAgMSxcbiAgICAgICAgICBNYXRoLnNxcnQoXG4gICAgICAgICAgICAobm9kZXNwZWVkICpcbiAgICAgICAgICAgICAgKE1hdGgucG93KE5vZGVNYXRyaXhbbiArIE5PREVfRFhdLCAyKSArXG4gICAgICAgICAgICAgICAgTWF0aC5wb3coTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0sIDIpKSkgL1xuICAgICAgICAgICAgICAoMSArIE1hdGguc3FydChzd2luZ2luZykpXG4gICAgICAgICAgKVxuICAgICAgICApO1xuXG4gICAgICAgIC8vIFVwZGF0aW5nIG5vZGUncyBwb3NpdG9uXG4gICAgICAgIG5ld1ggPVxuICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfWF0gK1xuICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdICogKG5vZGVzcGVlZCAvIG9wdGlvbnMuc2xvd0Rvd24pO1xuICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX1hdID0gbmV3WDtcblxuICAgICAgICBuZXdZID1cbiAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX1ldICtcbiAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RZXSAqIChub2Rlc3BlZWQgLyBvcHRpb25zLnNsb3dEb3duKTtcbiAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9ZXSA9IG5ld1k7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gV2UgcmV0dXJuIHRoZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgbGF5b3V0IChubyBuZWVkIHRvIHJldHVybiB0aGUgbWF0cmljZXMpXG4gIHJldHVybiB7fTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-layout-forceatlas2/iterate.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/graphology-layout-forceatlas2/webworker.js":
/*!*****************************************************************!*\
  !*** ./node_modules/graphology-layout-forceatlas2/webworker.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("/**\n * Graphology ForceAtlas2 Layout Webworker\n * ========================================\n *\n * Web worker able to run the layout in a separate thread.\n */\nmodule.exports = function worker() {\n  var NODES, EDGES;\n\n  var moduleShim = {};\n\n  (function () {\n    /* eslint no-constant-condition: 0 */\n/**\n * Graphology ForceAtlas2 Iteration\n * =================================\n *\n * Function used to perform a single iteration of the algorithm.\n */\n\n/**\n * Matrices properties accessors.\n */\nvar NODE_X = 0;\nvar NODE_Y = 1;\nvar NODE_DX = 2;\nvar NODE_DY = 3;\nvar NODE_OLD_DX = 4;\nvar NODE_OLD_DY = 5;\nvar NODE_MASS = 6;\nvar NODE_CONVERGENCE = 7;\nvar NODE_SIZE = 8;\nvar NODE_FIXED = 9;\n\nvar EDGE_SOURCE = 0;\nvar EDGE_TARGET = 1;\nvar EDGE_WEIGHT = 2;\n\nvar REGION_NODE = 0;\nvar REGION_CENTER_X = 1;\nvar REGION_CENTER_Y = 2;\nvar REGION_SIZE = 3;\nvar REGION_NEXT_SIBLING = 4;\nvar REGION_FIRST_CHILD = 5;\nvar REGION_MASS = 6;\nvar REGION_MASS_CENTER_X = 7;\nvar REGION_MASS_CENTER_Y = 8;\n\nvar SUBDIVISION_ATTEMPTS = 3;\n\n/**\n * Constants.\n */\nvar PPN = 10;\nvar PPE = 3;\nvar PPR = 9;\n\nvar MAX_FORCE = 10;\n\n/**\n * Function used to perform a single interation of the algorithm.\n *\n * @param  {object}       options    - Layout options.\n * @param  {Float32Array} NodeMatrix - Node data.\n * @param  {Float32Array} EdgeMatrix - Edge data.\n * @return {object}                  - Some metadata.\n */\nmoduleShim.exports = function iterate(options, NodeMatrix, EdgeMatrix) {\n  // Initializing variables\n  var l, r, n, n1, n2, rn, e, w, g, s;\n\n  var order = NodeMatrix.length,\n    size = EdgeMatrix.length;\n\n  var adjustSizes = options.adjustSizes;\n\n  var thetaSquared = options.barnesHutTheta * options.barnesHutTheta;\n\n  var outboundAttCompensation, coefficient, xDist, yDist, ewc, distance, factor;\n\n  var RegionMatrix = [];\n\n  // 1) Initializing layout data\n  //-----------------------------\n\n  // Resetting positions & computing max values\n  for (n = 0; n < order; n += PPN) {\n    NodeMatrix[n + NODE_OLD_DX] = NodeMatrix[n + NODE_DX];\n    NodeMatrix[n + NODE_OLD_DY] = NodeMatrix[n + NODE_DY];\n    NodeMatrix[n + NODE_DX] = 0;\n    NodeMatrix[n + NODE_DY] = 0;\n  }\n\n  // If outbound attraction distribution, compensate\n  if (options.outboundAttractionDistribution) {\n    outboundAttCompensation = 0;\n    for (n = 0; n < order; n += PPN) {\n      outboundAttCompensation += NodeMatrix[n + NODE_MASS];\n    }\n\n    outboundAttCompensation /= order / PPN;\n  }\n\n  // 1.bis) Barnes-Hut computation\n  //------------------------------\n\n  if (options.barnesHutOptimize) {\n    // Setting up\n    var minX = Infinity,\n      maxX = -Infinity,\n      minY = Infinity,\n      maxY = -Infinity,\n      q,\n      q2,\n      subdivisionAttempts;\n\n    // Computing min and max values\n    for (n = 0; n < order; n += PPN) {\n      minX = Math.min(minX, NodeMatrix[n + NODE_X]);\n      maxX = Math.max(maxX, NodeMatrix[n + NODE_X]);\n      minY = Math.min(minY, NodeMatrix[n + NODE_Y]);\n      maxY = Math.max(maxY, NodeMatrix[n + NODE_Y]);\n    }\n\n    // squarify bounds, it's a quadtree\n    var dx = maxX - minX,\n      dy = maxY - minY;\n    if (dx > dy) {\n      minY -= (dx - dy) / 2;\n      maxY = minY + dx;\n    } else {\n      minX -= (dy - dx) / 2;\n      maxX = minX + dy;\n    }\n\n    // Build the Barnes Hut root region\n    RegionMatrix[0 + REGION_NODE] = -1;\n    RegionMatrix[0 + REGION_CENTER_X] = (minX + maxX) / 2;\n    RegionMatrix[0 + REGION_CENTER_Y] = (minY + maxY) / 2;\n    RegionMatrix[0 + REGION_SIZE] = Math.max(maxX - minX, maxY - minY);\n    RegionMatrix[0 + REGION_NEXT_SIBLING] = -1;\n    RegionMatrix[0 + REGION_FIRST_CHILD] = -1;\n    RegionMatrix[0 + REGION_MASS] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_X] = 0;\n    RegionMatrix[0 + REGION_MASS_CENTER_Y] = 0;\n\n    // Add each node in the tree\n    l = 1;\n    for (n = 0; n < order; n += PPN) {\n      // Current region, starting with root\n      r = 0;\n      subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n\n      while (true) {\n        // Are there sub-regions?\n\n        // We look at first child index\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n          // There are sub-regions\n\n          // We just iterate to find a \"leaf\" of the tree\n          // that is an empty region or a region with a single node\n          // (see next case)\n\n          // Find the quadrant of n\n          if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n              // Top Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD];\n            } else {\n              // Bottom Left quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n            }\n          } else {\n            if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n              // Top Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n            } else {\n              // Bottom Right quarter\n              q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n            }\n          }\n\n          // Update center of mass and mass (we only do it for non-leave regions)\n          RegionMatrix[r + REGION_MASS_CENTER_X] =\n            (RegionMatrix[r + REGION_MASS_CENTER_X] *\n              RegionMatrix[r + REGION_MASS] +\n              NodeMatrix[n + NODE_X] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS_CENTER_Y] =\n            (RegionMatrix[r + REGION_MASS_CENTER_Y] *\n              RegionMatrix[r + REGION_MASS] +\n              NodeMatrix[n + NODE_Y] * NodeMatrix[n + NODE_MASS]) /\n            (RegionMatrix[r + REGION_MASS] + NodeMatrix[n + NODE_MASS]);\n\n          RegionMatrix[r + REGION_MASS] += NodeMatrix[n + NODE_MASS];\n\n          // Iterate on the right quadrant\n          r = q;\n          continue;\n        } else {\n          // There are no sub-regions: we are in a \"leaf\"\n\n          // Is there a node in this leave?\n          if (RegionMatrix[r + REGION_NODE] < 0) {\n            // There is no node in region:\n            // we record node n and go on\n            RegionMatrix[r + REGION_NODE] = n;\n            break;\n          } else {\n            // There is a node in this region\n\n            // We will need to create sub-regions, stick the two\n            // nodes (the old one r[0] and the new one n) in two\n            // subregions. If they fall in the same quadrant,\n            // we will iterate.\n\n            // Create sub-regions\n            RegionMatrix[r + REGION_FIRST_CHILD] = l * PPR;\n            w = RegionMatrix[r + REGION_SIZE] / 2; // new size (half)\n\n            // NOTE: we use screen coordinates\n            // from Top Left to Bottom Right\n\n            // Top Left sub-region\n            g = RegionMatrix[r + REGION_FIRST_CHILD];\n\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Left sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] - w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Top Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] - w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] = g + PPR;\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            // Bottom Right sub-region\n            g += PPR;\n            RegionMatrix[g + REGION_NODE] = -1;\n            RegionMatrix[g + REGION_CENTER_X] =\n              RegionMatrix[r + REGION_CENTER_X] + w;\n            RegionMatrix[g + REGION_CENTER_Y] =\n              RegionMatrix[r + REGION_CENTER_Y] + w;\n            RegionMatrix[g + REGION_SIZE] = w;\n            RegionMatrix[g + REGION_NEXT_SIBLING] =\n              RegionMatrix[r + REGION_NEXT_SIBLING];\n            RegionMatrix[g + REGION_FIRST_CHILD] = -1;\n            RegionMatrix[g + REGION_MASS] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_X] = 0;\n            RegionMatrix[g + REGION_MASS_CENTER_Y] = 0;\n\n            l += 4;\n\n            // Now the goal is to find two different sub-regions\n            // for the two nodes: the one previously recorded (r[0])\n            // and the one we want to add (n)\n\n            // Find the quadrant of the old node\n            if (\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X] <\n              RegionMatrix[r + REGION_CENTER_X]\n            ) {\n              if (\n                NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] <\n                RegionMatrix[r + REGION_CENTER_Y]\n              ) {\n                // Top Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD];\n              } else {\n                // Bottom Left quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            } else {\n              if (\n                NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y] <\n                RegionMatrix[r + REGION_CENTER_Y]\n              ) {\n                // Top Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              } else {\n                // Bottom Right quarter\n                q = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            // We remove r[0] from the region r, add its mass to r and record it in q\n            RegionMatrix[r + REGION_MASS] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_MASS];\n            RegionMatrix[r + REGION_MASS_CENTER_X] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_X];\n            RegionMatrix[r + REGION_MASS_CENTER_Y] =\n              NodeMatrix[RegionMatrix[r + REGION_NODE] + NODE_Y];\n\n            RegionMatrix[q + REGION_NODE] = RegionMatrix[r + REGION_NODE];\n            RegionMatrix[r + REGION_NODE] = -1;\n\n            // Find the quadrant of n\n            if (NodeMatrix[n + NODE_X] < RegionMatrix[r + REGION_CENTER_X]) {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n                // Top Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD];\n              } else {\n                // Bottom Left quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR;\n              }\n            } else {\n              if (NodeMatrix[n + NODE_Y] < RegionMatrix[r + REGION_CENTER_Y]) {\n                // Top Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 2;\n              } else {\n                // Bottom Right quarter\n                q2 = RegionMatrix[r + REGION_FIRST_CHILD] + PPR * 3;\n              }\n            }\n\n            if (q === q2) {\n              // If both nodes are in the same quadrant,\n              // we have to try it again on this quadrant\n              if (subdivisionAttempts--) {\n                r = q;\n                continue; // while\n              } else {\n                // we are out of precision here, and we cannot subdivide anymore\n                // but we have to break the loop anyway\n                subdivisionAttempts = SUBDIVISION_ATTEMPTS;\n                break; // while\n              }\n            }\n\n            // If both quadrants are different, we record n\n            // in its quadrant\n            RegionMatrix[q2 + REGION_NODE] = n;\n            break;\n          }\n        }\n      }\n    }\n  }\n\n  // 2) Repulsion\n  //--------------\n  // NOTES: adjustSizes = antiCollision & scalingRatio = coefficient\n\n  if (options.barnesHutOptimize) {\n    coefficient = options.scalingRatio;\n\n    // Applying repulsion through regions\n    for (n = 0; n < order; n += PPN) {\n      // Computing leaf quad nodes iteration\n\n      r = 0; // Starting with root region\n      while (true) {\n        if (RegionMatrix[r + REGION_FIRST_CHILD] >= 0) {\n          // The region has sub-regions\n\n          // We run the Barnes Hut test to see if we are at the right distance\n          distance =\n            Math.pow(\n              NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X],\n              2\n            ) +\n            Math.pow(\n              NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y],\n              2\n            );\n\n          s = RegionMatrix[r + REGION_SIZE];\n\n          if ((4 * s * s) / distance < thetaSquared) {\n            // We treat the region as a single body, and we repulse\n\n            xDist =\n              NodeMatrix[n + NODE_X] - RegionMatrix[r + REGION_MASS_CENTER_X];\n            yDist =\n              NodeMatrix[n + NODE_Y] - RegionMatrix[r + REGION_MASS_CENTER_Y];\n\n            if (adjustSizes === true) {\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              } else if (distance < 0) {\n                factor =\n                  (-coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            } else {\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    RegionMatrix[r + REGION_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n\n            // When this is done, we iterate. We have to look at the next sibling.\n            r = RegionMatrix[r + REGION_NEXT_SIBLING];\n            if (r < 0) break; // No next sibling: we have finished the tree\n\n            continue;\n          } else {\n            // The region is too close and we have to look at sub-regions\n            r = RegionMatrix[r + REGION_FIRST_CHILD];\n            continue;\n          }\n        } else {\n          // The region has no sub-region\n          // If there is a node r[0] and it is not n, then repulse\n          rn = RegionMatrix[r + REGION_NODE];\n\n          if (rn >= 0 && rn !== n) {\n            xDist = NodeMatrix[n + NODE_X] - NodeMatrix[rn + NODE_X];\n            yDist = NodeMatrix[n + NODE_Y] - NodeMatrix[rn + NODE_Y];\n\n            distance = xDist * xDist + yDist * yDist;\n\n            if (adjustSizes === true) {\n              //-- Linear Anti-collision Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              } else if (distance < 0) {\n                factor =\n                  (-coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  Math.sqrt(distance);\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            } else {\n              //-- Linear Repulsion\n              if (distance > 0) {\n                factor =\n                  (coefficient *\n                    NodeMatrix[n + NODE_MASS] *\n                    NodeMatrix[rn + NODE_MASS]) /\n                  distance;\n\n                NodeMatrix[n + NODE_DX] += xDist * factor;\n                NodeMatrix[n + NODE_DY] += yDist * factor;\n              }\n            }\n          }\n\n          // When this is done, we iterate. We have to look at the next sibling.\n          r = RegionMatrix[r + REGION_NEXT_SIBLING];\n\n          if (r < 0) break; // No next sibling: we have finished the tree\n\n          continue;\n        }\n      }\n    }\n  } else {\n    coefficient = options.scalingRatio;\n\n    // Square iteration\n    for (n1 = 0; n1 < order; n1 += PPN) {\n      for (n2 = 0; n2 < n1; n2 += PPN) {\n        // Common to both methods\n        xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n        yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n        if (adjustSizes === true) {\n          //-- Anticollision Linear Repulsion\n          distance =\n            Math.sqrt(xDist * xDist + yDist * yDist) -\n            NodeMatrix[n1 + NODE_SIZE] -\n            NodeMatrix[n2 + NODE_SIZE];\n\n          if (distance > 0) {\n            factor =\n              (coefficient *\n                NodeMatrix[n1 + NODE_MASS] *\n                NodeMatrix[n2 + NODE_MASS]) /\n              distance /\n              distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          } else if (distance < 0) {\n            factor =\n              100 *\n              coefficient *\n              NodeMatrix[n1 + NODE_MASS] *\n              NodeMatrix[n2 + NODE_MASS];\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        } else {\n          //-- Linear Repulsion\n          distance = Math.sqrt(xDist * xDist + yDist * yDist);\n\n          if (distance > 0) {\n            factor =\n              (coefficient *\n                NodeMatrix[n1 + NODE_MASS] *\n                NodeMatrix[n2 + NODE_MASS]) /\n              distance /\n              distance;\n\n            // Updating nodes' dx and dy\n            NodeMatrix[n1 + NODE_DX] += xDist * factor;\n            NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n            NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n            NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n          }\n        }\n      }\n    }\n  }\n\n  // 3) Gravity\n  //------------\n  g = options.gravity / options.scalingRatio;\n  coefficient = options.scalingRatio;\n  for (n = 0; n < order; n += PPN) {\n    factor = 0;\n\n    // Common to both methods\n    xDist = NodeMatrix[n + NODE_X];\n    yDist = NodeMatrix[n + NODE_Y];\n    distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n\n    if (options.strongGravityMode) {\n      //-- Strong gravity\n      if (distance > 0) factor = coefficient * NodeMatrix[n + NODE_MASS] * g;\n    } else {\n      //-- Linear Anti-collision Repulsion n\n      if (distance > 0)\n        factor = (coefficient * NodeMatrix[n + NODE_MASS] * g) / distance;\n    }\n\n    // Updating node's dx and dy\n    NodeMatrix[n + NODE_DX] -= xDist * factor;\n    NodeMatrix[n + NODE_DY] -= yDist * factor;\n  }\n\n  // 4) Attraction\n  //---------------\n  coefficient =\n    1 * (options.outboundAttractionDistribution ? outboundAttCompensation : 1);\n\n  // TODO: simplify distance\n  // TODO: coefficient is always used as -c --> optimize?\n  for (e = 0; e < size; e += PPE) {\n    n1 = EdgeMatrix[e + EDGE_SOURCE];\n    n2 = EdgeMatrix[e + EDGE_TARGET];\n    w = EdgeMatrix[e + EDGE_WEIGHT];\n\n    // Edge weight influence\n    ewc = Math.pow(w, options.edgeWeightInfluence);\n\n    // Common measures\n    xDist = NodeMatrix[n1 + NODE_X] - NodeMatrix[n2 + NODE_X];\n    yDist = NodeMatrix[n1 + NODE_Y] - NodeMatrix[n2 + NODE_Y];\n\n    // Applying attraction to nodes\n    if (adjustSizes === true) {\n      distance =\n        Math.sqrt(xDist * xDist + yDist * yDist) -\n        NodeMatrix[n1 + NODE_SIZE] -\n        NodeMatrix[n2 + NODE_SIZE];\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n          //-- LinLog Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor =\n              (-coefficient * ewc * Math.log(1 + distance)) /\n              distance /\n              NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- LinLog Anti-collision Attraction\n          if (distance > 0) {\n            factor = (-coefficient * ewc * Math.log(1 + distance)) / distance;\n          }\n        }\n      } else {\n        if (options.outboundAttractionDistribution) {\n          //-- Linear Degree Distributed Anti-collision Attraction\n          if (distance > 0) {\n            factor = (-coefficient * ewc) / NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- Linear Anti-collision Attraction\n          if (distance > 0) {\n            factor = -coefficient * ewc;\n          }\n        }\n      }\n    } else {\n      distance = Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));\n\n      if (options.linLogMode) {\n        if (options.outboundAttractionDistribution) {\n          //-- LinLog Degree Distributed Attraction\n          if (distance > 0) {\n            factor =\n              (-coefficient * ewc * Math.log(1 + distance)) /\n              distance /\n              NodeMatrix[n1 + NODE_MASS];\n          }\n        } else {\n          //-- LinLog Attraction\n          if (distance > 0)\n            factor = (-coefficient * ewc * Math.log(1 + distance)) / distance;\n        }\n      } else {\n        if (options.outboundAttractionDistribution) {\n          //-- Linear Attraction Mass Distributed\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = (-coefficient * ewc) / NodeMatrix[n1 + NODE_MASS];\n        } else {\n          //-- Linear Attraction\n          // NOTE: Distance is set to 1 to override next condition\n          distance = 1;\n          factor = -coefficient * ewc;\n        }\n      }\n    }\n\n    // Updating nodes' dx and dy\n    // TODO: if condition or factor = 1?\n    if (distance > 0) {\n      // Updating nodes' dx and dy\n      NodeMatrix[n1 + NODE_DX] += xDist * factor;\n      NodeMatrix[n1 + NODE_DY] += yDist * factor;\n\n      NodeMatrix[n2 + NODE_DX] -= xDist * factor;\n      NodeMatrix[n2 + NODE_DY] -= yDist * factor;\n    }\n  }\n\n  // 5) Apply Forces\n  //-----------------\n  var force, swinging, traction, nodespeed, newX, newY;\n\n  // MATH: sqrt and square distances\n  if (adjustSizes === true) {\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n        force = Math.sqrt(\n          Math.pow(NodeMatrix[n + NODE_DX], 2) +\n            Math.pow(NodeMatrix[n + NODE_DY], 2)\n        );\n\n        if (force > MAX_FORCE) {\n          NodeMatrix[n + NODE_DX] =\n            (NodeMatrix[n + NODE_DX] * MAX_FORCE) / force;\n          NodeMatrix[n + NODE_DY] =\n            (NodeMatrix[n + NODE_DY] * MAX_FORCE) / force;\n        }\n\n        swinging =\n          NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction =\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n          ) / 2;\n\n        nodespeed = (0.1 * Math.log(1 + traction)) / (1 + Math.sqrt(swinging));\n\n        // Updating node's positon\n        newX =\n          NodeMatrix[n + NODE_X] +\n          NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY =\n          NodeMatrix[n + NODE_Y] +\n          NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  } else {\n    for (n = 0; n < order; n += PPN) {\n      if (NodeMatrix[n + NODE_FIXED] !== 1) {\n        swinging =\n          NodeMatrix[n + NODE_MASS] *\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] - NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] - NodeMatrix[n + NODE_DY])\n          );\n\n        traction =\n          Math.sqrt(\n            (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) *\n              (NodeMatrix[n + NODE_OLD_DX] + NodeMatrix[n + NODE_DX]) +\n              (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY]) *\n                (NodeMatrix[n + NODE_OLD_DY] + NodeMatrix[n + NODE_DY])\n          ) / 2;\n\n        nodespeed =\n          (NodeMatrix[n + NODE_CONVERGENCE] * Math.log(1 + traction)) /\n          (1 + Math.sqrt(swinging));\n\n        // Updating node convergence\n        NodeMatrix[n + NODE_CONVERGENCE] = Math.min(\n          1,\n          Math.sqrt(\n            (nodespeed *\n              (Math.pow(NodeMatrix[n + NODE_DX], 2) +\n                Math.pow(NodeMatrix[n + NODE_DY], 2))) /\n              (1 + Math.sqrt(swinging))\n          )\n        );\n\n        // Updating node's positon\n        newX =\n          NodeMatrix[n + NODE_X] +\n          NodeMatrix[n + NODE_DX] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_X] = newX;\n\n        newY =\n          NodeMatrix[n + NODE_Y] +\n          NodeMatrix[n + NODE_DY] * (nodespeed / options.slowDown);\n        NodeMatrix[n + NODE_Y] = newY;\n      }\n    }\n  }\n\n  // We return the information about the layout (no need to return the matrices)\n  return {};\n};\n\n  })();\n\n  var iterate = moduleShim.exports;\n\n  self.addEventListener('message', function (event) {\n    var data = event.data;\n\n    NODES = new Float32Array(data.nodes);\n\n    if (data.edges) EDGES = new Float32Array(data.edges);\n\n    // Running the iteration\n    iterate(data.settings, NODES, EDGES);\n\n    // Sending result to supervisor\n    self.postMessage(\n      {\n        nodes: NODES.buffer\n      },\n      [NODES.buffer]\n    );\n  });\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQtZm9yY2VhdGxhczIvd2Vid29ya2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxjQUFjO0FBQzFCLFlBQVksY0FBYztBQUMxQixZQUFZLHlCQUF5QjtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCOztBQUVBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxpQkFBaUIsWUFBWTtBQUM3QixtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsV0FBVztBQUN6Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWMsVUFBVTtBQUN4QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osZ0JBQWdCLFdBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHOztBQUVIOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BvbnNhcnUvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQtZm9yY2VhdGxhczIvd2Vid29ya2VyLmpzPzBhZDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHcmFwaG9sb2d5IEZvcmNlQXRsYXMyIExheW91dCBXZWJ3b3JrZXJcbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBXZWIgd29ya2VyIGFibGUgdG8gcnVuIHRoZSBsYXlvdXQgaW4gYSBzZXBhcmF0ZSB0aHJlYWQuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd29ya2VyKCkge1xuICB2YXIgTk9ERVMsIEVER0VTO1xuXG4gIHZhciBtb2R1bGVTaGltID0ge307XG5cbiAgKGZ1bmN0aW9uICgpIHtcbiAgICAvKiBlc2xpbnQgbm8tY29uc3RhbnQtY29uZGl0aW9uOiAwICovXG4vKipcbiAqIEdyYXBob2xvZ3kgRm9yY2VBdGxhczIgSXRlcmF0aW9uXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIHBlcmZvcm0gYSBzaW5nbGUgaXRlcmF0aW9uIG9mIHRoZSBhbGdvcml0aG0uXG4gKi9cblxuLyoqXG4gKiBNYXRyaWNlcyBwcm9wZXJ0aWVzIGFjY2Vzc29ycy5cbiAqL1xudmFyIE5PREVfWCA9IDA7XG52YXIgTk9ERV9ZID0gMTtcbnZhciBOT0RFX0RYID0gMjtcbnZhciBOT0RFX0RZID0gMztcbnZhciBOT0RFX09MRF9EWCA9IDQ7XG52YXIgTk9ERV9PTERfRFkgPSA1O1xudmFyIE5PREVfTUFTUyA9IDY7XG52YXIgTk9ERV9DT05WRVJHRU5DRSA9IDc7XG52YXIgTk9ERV9TSVpFID0gODtcbnZhciBOT0RFX0ZJWEVEID0gOTtcblxudmFyIEVER0VfU09VUkNFID0gMDtcbnZhciBFREdFX1RBUkdFVCA9IDE7XG52YXIgRURHRV9XRUlHSFQgPSAyO1xuXG52YXIgUkVHSU9OX05PREUgPSAwO1xudmFyIFJFR0lPTl9DRU5URVJfWCA9IDE7XG52YXIgUkVHSU9OX0NFTlRFUl9ZID0gMjtcbnZhciBSRUdJT05fU0laRSA9IDM7XG52YXIgUkVHSU9OX05FWFRfU0lCTElORyA9IDQ7XG52YXIgUkVHSU9OX0ZJUlNUX0NISUxEID0gNTtcbnZhciBSRUdJT05fTUFTUyA9IDY7XG52YXIgUkVHSU9OX01BU1NfQ0VOVEVSX1ggPSA3O1xudmFyIFJFR0lPTl9NQVNTX0NFTlRFUl9ZID0gODtcblxudmFyIFNVQkRJVklTSU9OX0FUVEVNUFRTID0gMztcblxuLyoqXG4gKiBDb25zdGFudHMuXG4gKi9cbnZhciBQUE4gPSAxMDtcbnZhciBQUEUgPSAzO1xudmFyIFBQUiA9IDk7XG5cbnZhciBNQVhfRk9SQ0UgPSAxMDtcblxuLyoqXG4gKiBGdW5jdGlvbiB1c2VkIHRvIHBlcmZvcm0gYSBzaW5nbGUgaW50ZXJhdGlvbiBvZiB0aGUgYWxnb3JpdGhtLlxuICpcbiAqIEBwYXJhbSAge29iamVjdH0gICAgICAgb3B0aW9ucyAgICAtIExheW91dCBvcHRpb25zLlxuICogQHBhcmFtICB7RmxvYXQzMkFycmF5fSBOb2RlTWF0cml4IC0gTm9kZSBkYXRhLlxuICogQHBhcmFtICB7RmxvYXQzMkFycmF5fSBFZGdlTWF0cml4IC0gRWRnZSBkYXRhLlxuICogQHJldHVybiB7b2JqZWN0fSAgICAgICAgICAgICAgICAgIC0gU29tZSBtZXRhZGF0YS5cbiAqL1xubW9kdWxlU2hpbS5leHBvcnRzID0gZnVuY3Rpb24gaXRlcmF0ZShvcHRpb25zLCBOb2RlTWF0cml4LCBFZGdlTWF0cml4KSB7XG4gIC8vIEluaXRpYWxpemluZyB2YXJpYWJsZXNcbiAgdmFyIGwsIHIsIG4sIG4xLCBuMiwgcm4sIGUsIHcsIGcsIHM7XG5cbiAgdmFyIG9yZGVyID0gTm9kZU1hdHJpeC5sZW5ndGgsXG4gICAgc2l6ZSA9IEVkZ2VNYXRyaXgubGVuZ3RoO1xuXG4gIHZhciBhZGp1c3RTaXplcyA9IG9wdGlvbnMuYWRqdXN0U2l6ZXM7XG5cbiAgdmFyIHRoZXRhU3F1YXJlZCA9IG9wdGlvbnMuYmFybmVzSHV0VGhldGEgKiBvcHRpb25zLmJhcm5lc0h1dFRoZXRhO1xuXG4gIHZhciBvdXRib3VuZEF0dENvbXBlbnNhdGlvbiwgY29lZmZpY2llbnQsIHhEaXN0LCB5RGlzdCwgZXdjLCBkaXN0YW5jZSwgZmFjdG9yO1xuXG4gIHZhciBSZWdpb25NYXRyaXggPSBbXTtcblxuICAvLyAxKSBJbml0aWFsaXppbmcgbGF5b3V0IGRhdGFcbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFJlc2V0dGluZyBwb3NpdGlvbnMgJiBjb21wdXRpbmcgbWF4IHZhbHVlc1xuICBmb3IgKG4gPSAwOyBuIDwgb3JkZXI7IG4gKz0gUFBOKSB7XG4gICAgTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFhdID0gTm9kZU1hdHJpeFtuICsgTk9ERV9EWF07XG4gICAgTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFldID0gTm9kZU1hdHJpeFtuICsgTk9ERV9EWV07XG4gICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWF0gPSAwO1xuICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFldID0gMDtcbiAgfVxuXG4gIC8vIElmIG91dGJvdW5kIGF0dHJhY3Rpb24gZGlzdHJpYnV0aW9uLCBjb21wZW5zYXRlXG4gIGlmIChvcHRpb25zLm91dGJvdW5kQXR0cmFjdGlvbkRpc3RyaWJ1dGlvbikge1xuICAgIG91dGJvdW5kQXR0Q29tcGVuc2F0aW9uID0gMDtcbiAgICBmb3IgKG4gPSAwOyBuIDwgb3JkZXI7IG4gKz0gUFBOKSB7XG4gICAgICBvdXRib3VuZEF0dENvbXBlbnNhdGlvbiArPSBOb2RlTWF0cml4W24gKyBOT0RFX01BU1NdO1xuICAgIH1cblxuICAgIG91dGJvdW5kQXR0Q29tcGVuc2F0aW9uIC89IG9yZGVyIC8gUFBOO1xuICB9XG5cbiAgLy8gMS5iaXMpIEJhcm5lcy1IdXQgY29tcHV0YXRpb25cbiAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICBpZiAob3B0aW9ucy5iYXJuZXNIdXRPcHRpbWl6ZSkge1xuICAgIC8vIFNldHRpbmcgdXBcbiAgICB2YXIgbWluWCA9IEluZmluaXR5LFxuICAgICAgbWF4WCA9IC1JbmZpbml0eSxcbiAgICAgIG1pblkgPSBJbmZpbml0eSxcbiAgICAgIG1heFkgPSAtSW5maW5pdHksXG4gICAgICBxLFxuICAgICAgcTIsXG4gICAgICBzdWJkaXZpc2lvbkF0dGVtcHRzO1xuXG4gICAgLy8gQ29tcHV0aW5nIG1pbiBhbmQgbWF4IHZhbHVlc1xuICAgIGZvciAobiA9IDA7IG4gPCBvcmRlcjsgbiArPSBQUE4pIHtcbiAgICAgIG1pblggPSBNYXRoLm1pbihtaW5YLCBOb2RlTWF0cml4W24gKyBOT0RFX1hdKTtcbiAgICAgIG1heFggPSBNYXRoLm1heChtYXhYLCBOb2RlTWF0cml4W24gKyBOT0RFX1hdKTtcbiAgICAgIG1pblkgPSBNYXRoLm1pbihtaW5ZLCBOb2RlTWF0cml4W24gKyBOT0RFX1ldKTtcbiAgICAgIG1heFkgPSBNYXRoLm1heChtYXhZLCBOb2RlTWF0cml4W24gKyBOT0RFX1ldKTtcbiAgICB9XG5cbiAgICAvLyBzcXVhcmlmeSBib3VuZHMsIGl0J3MgYSBxdWFkdHJlZVxuICAgIHZhciBkeCA9IG1heFggLSBtaW5YLFxuICAgICAgZHkgPSBtYXhZIC0gbWluWTtcbiAgICBpZiAoZHggPiBkeSkge1xuICAgICAgbWluWSAtPSAoZHggLSBkeSkgLyAyO1xuICAgICAgbWF4WSA9IG1pblkgKyBkeDtcbiAgICB9IGVsc2Uge1xuICAgICAgbWluWCAtPSAoZHkgLSBkeCkgLyAyO1xuICAgICAgbWF4WCA9IG1pblggKyBkeTtcbiAgICB9XG5cbiAgICAvLyBCdWlsZCB0aGUgQmFybmVzIEh1dCByb290IHJlZ2lvblxuICAgIFJlZ2lvbk1hdHJpeFswICsgUkVHSU9OX05PREVdID0gLTE7XG4gICAgUmVnaW9uTWF0cml4WzAgKyBSRUdJT05fQ0VOVEVSX1hdID0gKG1pblggKyBtYXhYKSAvIDI7XG4gICAgUmVnaW9uTWF0cml4WzAgKyBSRUdJT05fQ0VOVEVSX1ldID0gKG1pblkgKyBtYXhZKSAvIDI7XG4gICAgUmVnaW9uTWF0cml4WzAgKyBSRUdJT05fU0laRV0gPSBNYXRoLm1heChtYXhYIC0gbWluWCwgbWF4WSAtIG1pblkpO1xuICAgIFJlZ2lvbk1hdHJpeFswICsgUkVHSU9OX05FWFRfU0lCTElOR10gPSAtMTtcbiAgICBSZWdpb25NYXRyaXhbMCArIFJFR0lPTl9GSVJTVF9DSElMRF0gPSAtMTtcbiAgICBSZWdpb25NYXRyaXhbMCArIFJFR0lPTl9NQVNTXSA9IDA7XG4gICAgUmVnaW9uTWF0cml4WzAgKyBSRUdJT05fTUFTU19DRU5URVJfWF0gPSAwO1xuICAgIFJlZ2lvbk1hdHJpeFswICsgUkVHSU9OX01BU1NfQ0VOVEVSX1ldID0gMDtcblxuICAgIC8vIEFkZCBlYWNoIG5vZGUgaW4gdGhlIHRyZWVcbiAgICBsID0gMTtcbiAgICBmb3IgKG4gPSAwOyBuIDwgb3JkZXI7IG4gKz0gUFBOKSB7XG4gICAgICAvLyBDdXJyZW50IHJlZ2lvbiwgc3RhcnRpbmcgd2l0aCByb290XG4gICAgICByID0gMDtcbiAgICAgIHN1YmRpdmlzaW9uQXR0ZW1wdHMgPSBTVUJESVZJU0lPTl9BVFRFTVBUUztcblxuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgLy8gQXJlIHRoZXJlIHN1Yi1yZWdpb25zP1xuXG4gICAgICAgIC8vIFdlIGxvb2sgYXQgZmlyc3QgY2hpbGQgaW5kZXhcbiAgICAgICAgaWYgKFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0ZJUlNUX0NISUxEXSA+PSAwKSB7XG4gICAgICAgICAgLy8gVGhlcmUgYXJlIHN1Yi1yZWdpb25zXG5cbiAgICAgICAgICAvLyBXZSBqdXN0IGl0ZXJhdGUgdG8gZmluZCBhIFwibGVhZlwiIG9mIHRoZSB0cmVlXG4gICAgICAgICAgLy8gdGhhdCBpcyBhbiBlbXB0eSByZWdpb24gb3IgYSByZWdpb24gd2l0aCBhIHNpbmdsZSBub2RlXG4gICAgICAgICAgLy8gKHNlZSBuZXh0IGNhc2UpXG5cbiAgICAgICAgICAvLyBGaW5kIHRoZSBxdWFkcmFudCBvZiBuXG4gICAgICAgICAgaWYgKE5vZGVNYXRyaXhbbiArIE5PREVfWF0gPCBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9DRU5URVJfWF0pIHtcbiAgICAgICAgICAgIGlmIChOb2RlTWF0cml4W24gKyBOT0RFX1ldIDwgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fQ0VOVEVSX1ldKSB7XG4gICAgICAgICAgICAgIC8vIFRvcCBMZWZ0IHF1YXJ0ZXJcbiAgICAgICAgICAgICAgcSA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0ZJUlNUX0NISUxEXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIEJvdHRvbSBMZWZ0IHF1YXJ0ZXJcbiAgICAgICAgICAgICAgcSA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0ZJUlNUX0NISUxEXSArIFBQUjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKE5vZGVNYXRyaXhbbiArIE5PREVfWV0gPCBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9DRU5URVJfWV0pIHtcbiAgICAgICAgICAgICAgLy8gVG9wIFJpZ2h0IHF1YXJ0ZXJcbiAgICAgICAgICAgICAgcSA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0ZJUlNUX0NISUxEXSArIFBQUiAqIDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBCb3R0b20gUmlnaHQgcXVhcnRlclxuICAgICAgICAgICAgICBxID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fRklSU1RfQ0hJTERdICsgUFBSICogMztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBVcGRhdGUgY2VudGVyIG9mIG1hc3MgYW5kIG1hc3MgKHdlIG9ubHkgZG8gaXQgZm9yIG5vbi1sZWF2ZSByZWdpb25zKVxuICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NfQ0VOVEVSX1hdID1cbiAgICAgICAgICAgIChSZWdpb25NYXRyaXhbciArIFJFR0lPTl9NQVNTX0NFTlRFUl9YXSAqXG4gICAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NdICtcbiAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9YXSAqIE5vZGVNYXRyaXhbbiArIE5PREVfTUFTU10pIC9cbiAgICAgICAgICAgIChSZWdpb25NYXRyaXhbciArIFJFR0lPTl9NQVNTXSArIE5vZGVNYXRyaXhbbiArIE5PREVfTUFTU10pO1xuXG4gICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU19DRU5URVJfWV0gPVxuICAgICAgICAgICAgKFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NfQ0VOVEVSX1ldICpcbiAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU10gK1xuICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX1ldICogTm9kZU1hdHJpeFtuICsgTk9ERV9NQVNTXSkgL1xuICAgICAgICAgICAgKFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NdICsgTm9kZU1hdHJpeFtuICsgTk9ERV9NQVNTXSk7XG5cbiAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9NQVNTXSArPSBOb2RlTWF0cml4W24gKyBOT0RFX01BU1NdO1xuXG4gICAgICAgICAgLy8gSXRlcmF0ZSBvbiB0aGUgcmlnaHQgcXVhZHJhbnRcbiAgICAgICAgICByID0gcTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGVyZSBhcmUgbm8gc3ViLXJlZ2lvbnM6IHdlIGFyZSBpbiBhIFwibGVhZlwiXG5cbiAgICAgICAgICAvLyBJcyB0aGVyZSBhIG5vZGUgaW4gdGhpcyBsZWF2ZT9cbiAgICAgICAgICBpZiAoUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTk9ERV0gPCAwKSB7XG4gICAgICAgICAgICAvLyBUaGVyZSBpcyBubyBub2RlIGluIHJlZ2lvbjpcbiAgICAgICAgICAgIC8vIHdlIHJlY29yZCBub2RlIG4gYW5kIGdvIG9uXG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9OT0RFXSA9IG47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSBub2RlIGluIHRoaXMgcmVnaW9uXG5cbiAgICAgICAgICAgIC8vIFdlIHdpbGwgbmVlZCB0byBjcmVhdGUgc3ViLXJlZ2lvbnMsIHN0aWNrIHRoZSB0d29cbiAgICAgICAgICAgIC8vIG5vZGVzICh0aGUgb2xkIG9uZSByWzBdIGFuZCB0aGUgbmV3IG9uZSBuKSBpbiB0d29cbiAgICAgICAgICAgIC8vIHN1YnJlZ2lvbnMuIElmIHRoZXkgZmFsbCBpbiB0aGUgc2FtZSBxdWFkcmFudCxcbiAgICAgICAgICAgIC8vIHdlIHdpbGwgaXRlcmF0ZS5cblxuICAgICAgICAgICAgLy8gQ3JlYXRlIHN1Yi1yZWdpb25zXG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9GSVJTVF9DSElMRF0gPSBsICogUFBSO1xuICAgICAgICAgICAgdyA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX1NJWkVdIC8gMjsgLy8gbmV3IHNpemUgKGhhbGYpXG5cbiAgICAgICAgICAgIC8vIE5PVEU6IHdlIHVzZSBzY3JlZW4gY29vcmRpbmF0ZXNcbiAgICAgICAgICAgIC8vIGZyb20gVG9wIExlZnQgdG8gQm90dG9tIFJpZ2h0XG5cbiAgICAgICAgICAgIC8vIFRvcCBMZWZ0IHN1Yi1yZWdpb25cbiAgICAgICAgICAgIGcgPSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9GSVJTVF9DSElMRF07XG5cbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX05PREVdID0gLTE7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9DRU5URVJfWF0gPVxuICAgICAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9DRU5URVJfWF0gLSB3O1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fQ0VOVEVSX1ldID1cbiAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fQ0VOVEVSX1ldIC0gdztcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX1NJWkVdID0gdztcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX05FWFRfU0lCTElOR10gPSBnICsgUFBSO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fRklSU1RfQ0hJTERdID0gLTE7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9NQVNTXSA9IDA7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9NQVNTX0NFTlRFUl9YXSA9IDA7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9NQVNTX0NFTlRFUl9ZXSA9IDA7XG5cbiAgICAgICAgICAgIC8vIEJvdHRvbSBMZWZ0IHN1Yi1yZWdpb25cbiAgICAgICAgICAgIGcgKz0gUFBSO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTk9ERV0gPSAtMTtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX0NFTlRFUl9YXSA9XG4gICAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9YXSAtIHc7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9DRU5URVJfWV0gPVxuICAgICAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9DRU5URVJfWV0gKyB3O1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fU0laRV0gPSB3O1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTkVYVF9TSUJMSU5HXSA9IGcgKyBQUFI7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9GSVJTVF9DSElMRF0gPSAtMTtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX01BU1NdID0gMDtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX01BU1NfQ0VOVEVSX1hdID0gMDtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX01BU1NfQ0VOVEVSX1ldID0gMDtcblxuICAgICAgICAgICAgLy8gVG9wIFJpZ2h0IHN1Yi1yZWdpb25cbiAgICAgICAgICAgIGcgKz0gUFBSO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTk9ERV0gPSAtMTtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX0NFTlRFUl9YXSA9XG4gICAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9YXSArIHc7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9DRU5URVJfWV0gPVxuICAgICAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9DRU5URVJfWV0gLSB3O1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fU0laRV0gPSB3O1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTkVYVF9TSUJMSU5HXSA9IGcgKyBQUFI7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9GSVJTVF9DSElMRF0gPSAtMTtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX01BU1NdID0gMDtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX01BU1NfQ0VOVEVSX1hdID0gMDtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX01BU1NfQ0VOVEVSX1ldID0gMDtcblxuICAgICAgICAgICAgLy8gQm90dG9tIFJpZ2h0IHN1Yi1yZWdpb25cbiAgICAgICAgICAgIGcgKz0gUFBSO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTk9ERV0gPSAtMTtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX0NFTlRFUl9YXSA9XG4gICAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9YXSArIHc7XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9DRU5URVJfWV0gPVxuICAgICAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9DRU5URVJfWV0gKyB3O1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fU0laRV0gPSB3O1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W2cgKyBSRUdJT05fTkVYVF9TSUJMSU5HXSA9XG4gICAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX05FWFRfU0lCTElOR107XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbZyArIFJFR0lPTl9GSVJTVF9DSElMRF0gPSAtMTtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX01BU1NdID0gMDtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX01BU1NfQ0VOVEVSX1hdID0gMDtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtnICsgUkVHSU9OX01BU1NfQ0VOVEVSX1ldID0gMDtcblxuICAgICAgICAgICAgbCArPSA0O1xuXG4gICAgICAgICAgICAvLyBOb3cgdGhlIGdvYWwgaXMgdG8gZmluZCB0d28gZGlmZmVyZW50IHN1Yi1yZWdpb25zXG4gICAgICAgICAgICAvLyBmb3IgdGhlIHR3byBub2RlczogdGhlIG9uZSBwcmV2aW91c2x5IHJlY29yZGVkIChyWzBdKVxuICAgICAgICAgICAgLy8gYW5kIHRoZSBvbmUgd2Ugd2FudCB0byBhZGQgKG4pXG5cbiAgICAgICAgICAgIC8vIEZpbmQgdGhlIHF1YWRyYW50IG9mIHRoZSBvbGQgbm9kZVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBOb2RlTWF0cml4W1JlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX05PREVdICsgTk9ERV9YXSA8XG4gICAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9YXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBOb2RlTWF0cml4W1JlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX05PREVdICsgTk9ERV9ZXSA8XG4gICAgICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fQ0VOVEVSX1ldXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIC8vIFRvcCBMZWZ0IHF1YXJ0ZXJcbiAgICAgICAgICAgICAgICBxID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fRklSU1RfQ0hJTERdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEJvdHRvbSBMZWZ0IHF1YXJ0ZXJcbiAgICAgICAgICAgICAgICBxID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fRklSU1RfQ0hJTERdICsgUFBSO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtSZWdpb25NYXRyaXhbciArIFJFR0lPTl9OT0RFXSArIE5PREVfWV0gPFxuICAgICAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9ZXVxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvLyBUb3AgUmlnaHQgcXVhcnRlclxuICAgICAgICAgICAgICAgIHEgPSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9GSVJTVF9DSElMRF0gKyBQUFIgKiAyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEJvdHRvbSBSaWdodCBxdWFydGVyXG4gICAgICAgICAgICAgICAgcSA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0ZJUlNUX0NISUxEXSArIFBQUiAqIDM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gV2UgcmVtb3ZlIHJbMF0gZnJvbSB0aGUgcmVnaW9uIHIsIGFkZCBpdHMgbWFzcyB0byByIGFuZCByZWNvcmQgaXQgaW4gcVxuICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU10gPVxuICAgICAgICAgICAgICBOb2RlTWF0cml4W1JlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX05PREVdICsgTk9ERV9NQVNTXTtcbiAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NfQ0VOVEVSX1hdID1cbiAgICAgICAgICAgICAgTm9kZU1hdHJpeFtSZWdpb25NYXRyaXhbciArIFJFR0lPTl9OT0RFXSArIE5PREVfWF07XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9NQVNTX0NFTlRFUl9ZXSA9XG4gICAgICAgICAgICAgIE5vZGVNYXRyaXhbUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTk9ERV0gKyBOT0RFX1ldO1xuXG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbcSArIFJFR0lPTl9OT0RFXSA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX05PREVdO1xuICAgICAgICAgICAgUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTk9ERV0gPSAtMTtcblxuICAgICAgICAgICAgLy8gRmluZCB0aGUgcXVhZHJhbnQgb2YgblxuICAgICAgICAgICAgaWYgKE5vZGVNYXRyaXhbbiArIE5PREVfWF0gPCBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9DRU5URVJfWF0pIHtcbiAgICAgICAgICAgICAgaWYgKE5vZGVNYXRyaXhbbiArIE5PREVfWV0gPCBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9DRU5URVJfWV0pIHtcbiAgICAgICAgICAgICAgICAvLyBUb3AgTGVmdCBxdWFydGVyXG4gICAgICAgICAgICAgICAgcTIgPSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9GSVJTVF9DSElMRF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQm90dG9tIExlZnQgcXVhcnRlclxuICAgICAgICAgICAgICAgIHEyID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fRklSU1RfQ0hJTERdICsgUFBSO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAoTm9kZU1hdHJpeFtuICsgTk9ERV9ZXSA8IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0NFTlRFUl9ZXSkge1xuICAgICAgICAgICAgICAgIC8vIFRvcCBSaWdodCBxdWFydGVyXG4gICAgICAgICAgICAgICAgcTIgPSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9GSVJTVF9DSElMRF0gKyBQUFIgKiAyO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEJvdHRvbSBSaWdodCBxdWFydGVyXG4gICAgICAgICAgICAgICAgcTIgPSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9GSVJTVF9DSElMRF0gKyBQUFIgKiAzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChxID09PSBxMikge1xuICAgICAgICAgICAgICAvLyBJZiBib3RoIG5vZGVzIGFyZSBpbiB0aGUgc2FtZSBxdWFkcmFudCxcbiAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byB0cnkgaXQgYWdhaW4gb24gdGhpcyBxdWFkcmFudFxuICAgICAgICAgICAgICBpZiAoc3ViZGl2aXNpb25BdHRlbXB0cy0tKSB7XG4gICAgICAgICAgICAgICAgciA9IHE7XG4gICAgICAgICAgICAgICAgY29udGludWU7IC8vIHdoaWxlXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgYXJlIG91dCBvZiBwcmVjaXNpb24gaGVyZSwgYW5kIHdlIGNhbm5vdCBzdWJkaXZpZGUgYW55bW9yZVxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIHRvIGJyZWFrIHRoZSBsb29wIGFueXdheVxuICAgICAgICAgICAgICAgIHN1YmRpdmlzaW9uQXR0ZW1wdHMgPSBTVUJESVZJU0lPTl9BVFRFTVBUUztcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gd2hpbGVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBib3RoIHF1YWRyYW50cyBhcmUgZGlmZmVyZW50LCB3ZSByZWNvcmQgblxuICAgICAgICAgICAgLy8gaW4gaXRzIHF1YWRyYW50XG4gICAgICAgICAgICBSZWdpb25NYXRyaXhbcTIgKyBSRUdJT05fTk9ERV0gPSBuO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gMikgUmVwdWxzaW9uXG4gIC8vLS0tLS0tLS0tLS0tLS1cbiAgLy8gTk9URVM6IGFkanVzdFNpemVzID0gYW50aUNvbGxpc2lvbiAmIHNjYWxpbmdSYXRpbyA9IGNvZWZmaWNpZW50XG5cbiAgaWYgKG9wdGlvbnMuYmFybmVzSHV0T3B0aW1pemUpIHtcbiAgICBjb2VmZmljaWVudCA9IG9wdGlvbnMuc2NhbGluZ1JhdGlvO1xuXG4gICAgLy8gQXBwbHlpbmcgcmVwdWxzaW9uIHRocm91Z2ggcmVnaW9uc1xuICAgIGZvciAobiA9IDA7IG4gPCBvcmRlcjsgbiArPSBQUE4pIHtcbiAgICAgIC8vIENvbXB1dGluZyBsZWFmIHF1YWQgbm9kZXMgaXRlcmF0aW9uXG5cbiAgICAgIHIgPSAwOyAvLyBTdGFydGluZyB3aXRoIHJvb3QgcmVnaW9uXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBpZiAoUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fRklSU1RfQ0hJTERdID49IDApIHtcbiAgICAgICAgICAvLyBUaGUgcmVnaW9uIGhhcyBzdWItcmVnaW9uc1xuXG4gICAgICAgICAgLy8gV2UgcnVuIHRoZSBCYXJuZXMgSHV0IHRlc3QgdG8gc2VlIGlmIHdlIGFyZSBhdCB0aGUgcmlnaHQgZGlzdGFuY2VcbiAgICAgICAgICBkaXN0YW5jZSA9XG4gICAgICAgICAgICBNYXRoLnBvdyhcbiAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9YXSAtIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NfQ0VOVEVSX1hdLFxuICAgICAgICAgICAgICAyXG4gICAgICAgICAgICApICtcbiAgICAgICAgICAgIE1hdGgucG93KFxuICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX1ldIC0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTUFTU19DRU5URVJfWV0sXG4gICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICBzID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fU0laRV07XG5cbiAgICAgICAgICBpZiAoKDQgKiBzICogcykgLyBkaXN0YW5jZSA8IHRoZXRhU3F1YXJlZCkge1xuICAgICAgICAgICAgLy8gV2UgdHJlYXQgdGhlIHJlZ2lvbiBhcyBhIHNpbmdsZSBib2R5LCBhbmQgd2UgcmVwdWxzZVxuXG4gICAgICAgICAgICB4RGlzdCA9XG4gICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfWF0gLSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9NQVNTX0NFTlRFUl9YXTtcbiAgICAgICAgICAgIHlEaXN0ID1cbiAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9ZXSAtIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NfQ0VOVEVSX1ldO1xuXG4gICAgICAgICAgICBpZiAoYWRqdXN0U2l6ZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgLy8tLSBMaW5lYXIgQW50aS1jb2xsaXNpb24gUmVwdWxzaW9uXG4gICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICBmYWN0b3IgPVxuICAgICAgICAgICAgICAgICAgKGNvZWZmaWNpZW50ICpcbiAgICAgICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9NQVNTXSAqXG4gICAgICAgICAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NdKSAvXG4gICAgICAgICAgICAgICAgICBkaXN0YW5jZTtcblxuICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdICs9IHhEaXN0ICogZmFjdG9yO1xuICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFldICs9IHlEaXN0ICogZmFjdG9yO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRpc3RhbmNlIDwgMCkge1xuICAgICAgICAgICAgICAgIGZhY3RvciA9XG4gICAgICAgICAgICAgICAgICAoLWNvZWZmaWNpZW50ICpcbiAgICAgICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9NQVNTXSAqXG4gICAgICAgICAgICAgICAgICAgIFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX01BU1NdKSAvXG4gICAgICAgICAgICAgICAgICBNYXRoLnNxcnQoZGlzdGFuY2UpO1xuXG4gICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWF0gKz0geERpc3QgKiBmYWN0b3I7XG4gICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0gKz0geURpc3QgKiBmYWN0b3I7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vLS0gTGluZWFyIFJlcHVsc2lvblxuICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yID1cbiAgICAgICAgICAgICAgICAgIChjb2VmZmljaWVudCAqXG4gICAgICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfTUFTU10gKlxuICAgICAgICAgICAgICAgICAgICBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9NQVNTXSkgL1xuICAgICAgICAgICAgICAgICAgZGlzdGFuY2U7XG5cbiAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RYXSArPSB4RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RZXSArPSB5RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBXaGVuIHRoaXMgaXMgZG9uZSwgd2UgaXRlcmF0ZS4gV2UgaGF2ZSB0byBsb29rIGF0IHRoZSBuZXh0IHNpYmxpbmcuXG4gICAgICAgICAgICByID0gUmVnaW9uTWF0cml4W3IgKyBSRUdJT05fTkVYVF9TSUJMSU5HXTtcbiAgICAgICAgICAgIGlmIChyIDwgMCkgYnJlYWs7IC8vIE5vIG5leHQgc2libGluZzogd2UgaGF2ZSBmaW5pc2hlZCB0aGUgdHJlZVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlIHJlZ2lvbiBpcyB0b28gY2xvc2UgYW5kIHdlIGhhdmUgdG8gbG9vayBhdCBzdWItcmVnaW9uc1xuICAgICAgICAgICAgciA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX0ZJUlNUX0NISUxEXTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGUgcmVnaW9uIGhhcyBubyBzdWItcmVnaW9uXG4gICAgICAgICAgLy8gSWYgdGhlcmUgaXMgYSBub2RlIHJbMF0gYW5kIGl0IGlzIG5vdCBuLCB0aGVuIHJlcHVsc2VcbiAgICAgICAgICBybiA9IFJlZ2lvbk1hdHJpeFtyICsgUkVHSU9OX05PREVdO1xuXG4gICAgICAgICAgaWYgKHJuID49IDAgJiYgcm4gIT09IG4pIHtcbiAgICAgICAgICAgIHhEaXN0ID0gTm9kZU1hdHJpeFtuICsgTk9ERV9YXSAtIE5vZGVNYXRyaXhbcm4gKyBOT0RFX1hdO1xuICAgICAgICAgICAgeURpc3QgPSBOb2RlTWF0cml4W24gKyBOT0RFX1ldIC0gTm9kZU1hdHJpeFtybiArIE5PREVfWV07XG5cbiAgICAgICAgICAgIGRpc3RhbmNlID0geERpc3QgKiB4RGlzdCArIHlEaXN0ICogeURpc3Q7XG5cbiAgICAgICAgICAgIGlmIChhZGp1c3RTaXplcyA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAvLy0tIExpbmVhciBBbnRpLWNvbGxpc2lvbiBSZXB1bHNpb25cbiAgICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgICAgIGZhY3RvciA9XG4gICAgICAgICAgICAgICAgICAoY29lZmZpY2llbnQgKlxuICAgICAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX01BU1NdICpcbiAgICAgICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtybiArIE5PREVfTUFTU10pIC9cbiAgICAgICAgICAgICAgICAgIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWF0gKz0geERpc3QgKiBmYWN0b3I7XG4gICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0gKz0geURpc3QgKiBmYWN0b3I7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoZGlzdGFuY2UgPCAwKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yID1cbiAgICAgICAgICAgICAgICAgICgtY29lZmZpY2llbnQgKlxuICAgICAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX01BU1NdICpcbiAgICAgICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtybiArIE5PREVfTUFTU10pIC9cbiAgICAgICAgICAgICAgICAgIE1hdGguc3FydChkaXN0YW5jZSk7XG5cbiAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RYXSArPSB4RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RZXSArPSB5RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8tLSBMaW5lYXIgUmVwdWxzaW9uXG4gICAgICAgICAgICAgIGlmIChkaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgICAgICBmYWN0b3IgPVxuICAgICAgICAgICAgICAgICAgKGNvZWZmaWNpZW50ICpcbiAgICAgICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9NQVNTXSAqXG4gICAgICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbcm4gKyBOT0RFX01BU1NdKSAvXG4gICAgICAgICAgICAgICAgICBkaXN0YW5jZTtcblxuICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdICs9IHhEaXN0ICogZmFjdG9yO1xuICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFldICs9IHlEaXN0ICogZmFjdG9yO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gV2hlbiB0aGlzIGlzIGRvbmUsIHdlIGl0ZXJhdGUuIFdlIGhhdmUgdG8gbG9vayBhdCB0aGUgbmV4dCBzaWJsaW5nLlxuICAgICAgICAgIHIgPSBSZWdpb25NYXRyaXhbciArIFJFR0lPTl9ORVhUX1NJQkxJTkddO1xuXG4gICAgICAgICAgaWYgKHIgPCAwKSBicmVhazsgLy8gTm8gbmV4dCBzaWJsaW5nOiB3ZSBoYXZlIGZpbmlzaGVkIHRoZSB0cmVlXG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb2VmZmljaWVudCA9IG9wdGlvbnMuc2NhbGluZ1JhdGlvO1xuXG4gICAgLy8gU3F1YXJlIGl0ZXJhdGlvblxuICAgIGZvciAobjEgPSAwOyBuMSA8IG9yZGVyOyBuMSArPSBQUE4pIHtcbiAgICAgIGZvciAobjIgPSAwOyBuMiA8IG4xOyBuMiArPSBQUE4pIHtcbiAgICAgICAgLy8gQ29tbW9uIHRvIGJvdGggbWV0aG9kc1xuICAgICAgICB4RGlzdCA9IE5vZGVNYXRyaXhbbjEgKyBOT0RFX1hdIC0gTm9kZU1hdHJpeFtuMiArIE5PREVfWF07XG4gICAgICAgIHlEaXN0ID0gTm9kZU1hdHJpeFtuMSArIE5PREVfWV0gLSBOb2RlTWF0cml4W24yICsgTk9ERV9ZXTtcblxuICAgICAgICBpZiAoYWRqdXN0U2l6ZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAvLy0tIEFudGljb2xsaXNpb24gTGluZWFyIFJlcHVsc2lvblxuICAgICAgICAgIGRpc3RhbmNlID1cbiAgICAgICAgICAgIE1hdGguc3FydCh4RGlzdCAqIHhEaXN0ICsgeURpc3QgKiB5RGlzdCkgLVxuICAgICAgICAgICAgTm9kZU1hdHJpeFtuMSArIE5PREVfU0laRV0gLVxuICAgICAgICAgICAgTm9kZU1hdHJpeFtuMiArIE5PREVfU0laRV07XG5cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICBmYWN0b3IgPVxuICAgICAgICAgICAgICAoY29lZmZpY2llbnQgKlxuICAgICAgICAgICAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX01BU1NdICpcbiAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24yICsgTk9ERV9NQVNTXSkgL1xuICAgICAgICAgICAgICBkaXN0YW5jZSAvXG4gICAgICAgICAgICAgIGRpc3RhbmNlO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGluZyBub2RlcycgZHggYW5kIGR5XG4gICAgICAgICAgICBOb2RlTWF0cml4W24xICsgTk9ERV9EWF0gKz0geERpc3QgKiBmYWN0b3I7XG4gICAgICAgICAgICBOb2RlTWF0cml4W24xICsgTk9ERV9EWV0gKz0geURpc3QgKiBmYWN0b3I7XG5cbiAgICAgICAgICAgIE5vZGVNYXRyaXhbbjIgKyBOT0RFX0RYXSAtPSB4RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgIE5vZGVNYXRyaXhbbjIgKyBOT0RFX0RZXSAtPSB5RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpc3RhbmNlIDwgMCkge1xuICAgICAgICAgICAgZmFjdG9yID1cbiAgICAgICAgICAgICAgMTAwICpcbiAgICAgICAgICAgICAgY29lZmZpY2llbnQgKlxuICAgICAgICAgICAgICBOb2RlTWF0cml4W24xICsgTk9ERV9NQVNTXSAqXG4gICAgICAgICAgICAgIE5vZGVNYXRyaXhbbjIgKyBOT0RFX01BU1NdO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGluZyBub2RlcycgZHggYW5kIGR5XG4gICAgICAgICAgICBOb2RlTWF0cml4W24xICsgTk9ERV9EWF0gKz0geERpc3QgKiBmYWN0b3I7XG4gICAgICAgICAgICBOb2RlTWF0cml4W24xICsgTk9ERV9EWV0gKz0geURpc3QgKiBmYWN0b3I7XG5cbiAgICAgICAgICAgIE5vZGVNYXRyaXhbbjIgKyBOT0RFX0RYXSAtPSB4RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICAgIE5vZGVNYXRyaXhbbjIgKyBOT0RFX0RZXSAtPSB5RGlzdCAqIGZhY3RvcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8tLSBMaW5lYXIgUmVwdWxzaW9uXG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoeERpc3QgKiB4RGlzdCArIHlEaXN0ICogeURpc3QpO1xuXG4gICAgICAgICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgZmFjdG9yID1cbiAgICAgICAgICAgICAgKGNvZWZmaWNpZW50ICpcbiAgICAgICAgICAgICAgICBOb2RlTWF0cml4W24xICsgTk9ERV9NQVNTXSAqXG4gICAgICAgICAgICAgICAgTm9kZU1hdHJpeFtuMiArIE5PREVfTUFTU10pIC9cbiAgICAgICAgICAgICAgZGlzdGFuY2UgL1xuICAgICAgICAgICAgICBkaXN0YW5jZTtcblxuICAgICAgICAgICAgLy8gVXBkYXRpbmcgbm9kZXMnIGR4IGFuZCBkeVxuICAgICAgICAgICAgTm9kZU1hdHJpeFtuMSArIE5PREVfRFhdICs9IHhEaXN0ICogZmFjdG9yO1xuICAgICAgICAgICAgTm9kZU1hdHJpeFtuMSArIE5PREVfRFldICs9IHlEaXN0ICogZmFjdG9yO1xuXG4gICAgICAgICAgICBOb2RlTWF0cml4W24yICsgTk9ERV9EWF0gLT0geERpc3QgKiBmYWN0b3I7XG4gICAgICAgICAgICBOb2RlTWF0cml4W24yICsgTk9ERV9EWV0gLT0geURpc3QgKiBmYWN0b3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gMykgR3Jhdml0eVxuICAvLy0tLS0tLS0tLS0tLVxuICBnID0gb3B0aW9ucy5ncmF2aXR5IC8gb3B0aW9ucy5zY2FsaW5nUmF0aW87XG4gIGNvZWZmaWNpZW50ID0gb3B0aW9ucy5zY2FsaW5nUmF0aW87XG4gIGZvciAobiA9IDA7IG4gPCBvcmRlcjsgbiArPSBQUE4pIHtcbiAgICBmYWN0b3IgPSAwO1xuXG4gICAgLy8gQ29tbW9uIHRvIGJvdGggbWV0aG9kc1xuICAgIHhEaXN0ID0gTm9kZU1hdHJpeFtuICsgTk9ERV9YXTtcbiAgICB5RGlzdCA9IE5vZGVNYXRyaXhbbiArIE5PREVfWV07XG4gICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coeERpc3QsIDIpICsgTWF0aC5wb3coeURpc3QsIDIpKTtcblxuICAgIGlmIChvcHRpb25zLnN0cm9uZ0dyYXZpdHlNb2RlKSB7XG4gICAgICAvLy0tIFN0cm9uZyBncmF2aXR5XG4gICAgICBpZiAoZGlzdGFuY2UgPiAwKSBmYWN0b3IgPSBjb2VmZmljaWVudCAqIE5vZGVNYXRyaXhbbiArIE5PREVfTUFTU10gKiBnO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLy0tIExpbmVhciBBbnRpLWNvbGxpc2lvbiBSZXB1bHNpb24gblxuICAgICAgaWYgKGRpc3RhbmNlID4gMClcbiAgICAgICAgZmFjdG9yID0gKGNvZWZmaWNpZW50ICogTm9kZU1hdHJpeFtuICsgTk9ERV9NQVNTXSAqIGcpIC8gZGlzdGFuY2U7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRpbmcgbm9kZSdzIGR4IGFuZCBkeVxuICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdIC09IHhEaXN0ICogZmFjdG9yO1xuICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFldIC09IHlEaXN0ICogZmFjdG9yO1xuICB9XG5cbiAgLy8gNCkgQXR0cmFjdGlvblxuICAvLy0tLS0tLS0tLS0tLS0tLVxuICBjb2VmZmljaWVudCA9XG4gICAgMSAqIChvcHRpb25zLm91dGJvdW5kQXR0cmFjdGlvbkRpc3RyaWJ1dGlvbiA/IG91dGJvdW5kQXR0Q29tcGVuc2F0aW9uIDogMSk7XG5cbiAgLy8gVE9ETzogc2ltcGxpZnkgZGlzdGFuY2VcbiAgLy8gVE9ETzogY29lZmZpY2llbnQgaXMgYWx3YXlzIHVzZWQgYXMgLWMgLS0+IG9wdGltaXplP1xuICBmb3IgKGUgPSAwOyBlIDwgc2l6ZTsgZSArPSBQUEUpIHtcbiAgICBuMSA9IEVkZ2VNYXRyaXhbZSArIEVER0VfU09VUkNFXTtcbiAgICBuMiA9IEVkZ2VNYXRyaXhbZSArIEVER0VfVEFSR0VUXTtcbiAgICB3ID0gRWRnZU1hdHJpeFtlICsgRURHRV9XRUlHSFRdO1xuXG4gICAgLy8gRWRnZSB3ZWlnaHQgaW5mbHVlbmNlXG4gICAgZXdjID0gTWF0aC5wb3codywgb3B0aW9ucy5lZGdlV2VpZ2h0SW5mbHVlbmNlKTtcblxuICAgIC8vIENvbW1vbiBtZWFzdXJlc1xuICAgIHhEaXN0ID0gTm9kZU1hdHJpeFtuMSArIE5PREVfWF0gLSBOb2RlTWF0cml4W24yICsgTk9ERV9YXTtcbiAgICB5RGlzdCA9IE5vZGVNYXRyaXhbbjEgKyBOT0RFX1ldIC0gTm9kZU1hdHJpeFtuMiArIE5PREVfWV07XG5cbiAgICAvLyBBcHBseWluZyBhdHRyYWN0aW9uIHRvIG5vZGVzXG4gICAgaWYgKGFkanVzdFNpemVzID09PSB0cnVlKSB7XG4gICAgICBkaXN0YW5jZSA9XG4gICAgICAgIE1hdGguc3FydCh4RGlzdCAqIHhEaXN0ICsgeURpc3QgKiB5RGlzdCkgLVxuICAgICAgICBOb2RlTWF0cml4W24xICsgTk9ERV9TSVpFXSAtXG4gICAgICAgIE5vZGVNYXRyaXhbbjIgKyBOT0RFX1NJWkVdO1xuXG4gICAgICBpZiAob3B0aW9ucy5saW5Mb2dNb2RlKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dGJvdW5kQXR0cmFjdGlvbkRpc3RyaWJ1dGlvbikge1xuICAgICAgICAgIC8vLS0gTGluTG9nIERlZ3JlZSBEaXN0cmlidXRlZCBBbnRpLWNvbGxpc2lvbiBBdHRyYWN0aW9uXG4gICAgICAgICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgZmFjdG9yID1cbiAgICAgICAgICAgICAgKC1jb2VmZmljaWVudCAqIGV3YyAqIE1hdGgubG9nKDEgKyBkaXN0YW5jZSkpIC9cbiAgICAgICAgICAgICAgZGlzdGFuY2UgL1xuICAgICAgICAgICAgICBOb2RlTWF0cml4W24xICsgTk9ERV9NQVNTXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8tLSBMaW5Mb2cgQW50aS1jb2xsaXNpb24gQXR0cmFjdGlvblxuICAgICAgICAgIGlmIChkaXN0YW5jZSA+IDApIHtcbiAgICAgICAgICAgIGZhY3RvciA9ICgtY29lZmZpY2llbnQgKiBld2MgKiBNYXRoLmxvZygxICsgZGlzdGFuY2UpKSAvIGRpc3RhbmNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0Ym91bmRBdHRyYWN0aW9uRGlzdHJpYnV0aW9uKSB7XG4gICAgICAgICAgLy8tLSBMaW5lYXIgRGVncmVlIERpc3RyaWJ1dGVkIEFudGktY29sbGlzaW9uIEF0dHJhY3Rpb25cbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICBmYWN0b3IgPSAoLWNvZWZmaWNpZW50ICogZXdjKSAvIE5vZGVNYXRyaXhbbjEgKyBOT0RFX01BU1NdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLy0tIExpbmVhciBBbnRpLWNvbGxpc2lvbiBBdHRyYWN0aW9uXG4gICAgICAgICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgZmFjdG9yID0gLWNvZWZmaWNpZW50ICogZXdjO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh4RGlzdCwgMikgKyBNYXRoLnBvdyh5RGlzdCwgMikpO1xuXG4gICAgICBpZiAob3B0aW9ucy5saW5Mb2dNb2RlKSB7XG4gICAgICAgIGlmIChvcHRpb25zLm91dGJvdW5kQXR0cmFjdGlvbkRpc3RyaWJ1dGlvbikge1xuICAgICAgICAgIC8vLS0gTGluTG9nIERlZ3JlZSBEaXN0cmlidXRlZCBBdHRyYWN0aW9uXG4gICAgICAgICAgaWYgKGRpc3RhbmNlID4gMCkge1xuICAgICAgICAgICAgZmFjdG9yID1cbiAgICAgICAgICAgICAgKC1jb2VmZmljaWVudCAqIGV3YyAqIE1hdGgubG9nKDEgKyBkaXN0YW5jZSkpIC9cbiAgICAgICAgICAgICAgZGlzdGFuY2UgL1xuICAgICAgICAgICAgICBOb2RlTWF0cml4W24xICsgTk9ERV9NQVNTXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8tLSBMaW5Mb2cgQXR0cmFjdGlvblxuICAgICAgICAgIGlmIChkaXN0YW5jZSA+IDApXG4gICAgICAgICAgICBmYWN0b3IgPSAoLWNvZWZmaWNpZW50ICogZXdjICogTWF0aC5sb2coMSArIGRpc3RhbmNlKSkgLyBkaXN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdGlvbnMub3V0Ym91bmRBdHRyYWN0aW9uRGlzdHJpYnV0aW9uKSB7XG4gICAgICAgICAgLy8tLSBMaW5lYXIgQXR0cmFjdGlvbiBNYXNzIERpc3RyaWJ1dGVkXG4gICAgICAgICAgLy8gTk9URTogRGlzdGFuY2UgaXMgc2V0IHRvIDEgdG8gb3ZlcnJpZGUgbmV4dCBjb25kaXRpb25cbiAgICAgICAgICBkaXN0YW5jZSA9IDE7XG4gICAgICAgICAgZmFjdG9yID0gKC1jb2VmZmljaWVudCAqIGV3YykgLyBOb2RlTWF0cml4W24xICsgTk9ERV9NQVNTXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLy0tIExpbmVhciBBdHRyYWN0aW9uXG4gICAgICAgICAgLy8gTk9URTogRGlzdGFuY2UgaXMgc2V0IHRvIDEgdG8gb3ZlcnJpZGUgbmV4dCBjb25kaXRpb25cbiAgICAgICAgICBkaXN0YW5jZSA9IDE7XG4gICAgICAgICAgZmFjdG9yID0gLWNvZWZmaWNpZW50ICogZXdjO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRpbmcgbm9kZXMnIGR4IGFuZCBkeVxuICAgIC8vIFRPRE86IGlmIGNvbmRpdGlvbiBvciBmYWN0b3IgPSAxP1xuICAgIGlmIChkaXN0YW5jZSA+IDApIHtcbiAgICAgIC8vIFVwZGF0aW5nIG5vZGVzJyBkeCBhbmQgZHlcbiAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX0RYXSArPSB4RGlzdCAqIGZhY3RvcjtcbiAgICAgIE5vZGVNYXRyaXhbbjEgKyBOT0RFX0RZXSArPSB5RGlzdCAqIGZhY3RvcjtcblxuICAgICAgTm9kZU1hdHJpeFtuMiArIE5PREVfRFhdIC09IHhEaXN0ICogZmFjdG9yO1xuICAgICAgTm9kZU1hdHJpeFtuMiArIE5PREVfRFldIC09IHlEaXN0ICogZmFjdG9yO1xuICAgIH1cbiAgfVxuXG4gIC8vIDUpIEFwcGx5IEZvcmNlc1xuICAvLy0tLS0tLS0tLS0tLS0tLS0tXG4gIHZhciBmb3JjZSwgc3dpbmdpbmcsIHRyYWN0aW9uLCBub2Rlc3BlZWQsIG5ld1gsIG5ld1k7XG5cbiAgLy8gTUFUSDogc3FydCBhbmQgc3F1YXJlIGRpc3RhbmNlc1xuICBpZiAoYWRqdXN0U2l6ZXMgPT09IHRydWUpIHtcbiAgICBmb3IgKG4gPSAwOyBuIDwgb3JkZXI7IG4gKz0gUFBOKSB7XG4gICAgICBpZiAoTm9kZU1hdHJpeFtuICsgTk9ERV9GSVhFRF0gIT09IDEpIHtcbiAgICAgICAgZm9yY2UgPSBNYXRoLnNxcnQoXG4gICAgICAgICAgTWF0aC5wb3coTm9kZU1hdHJpeFtuICsgTk9ERV9EWF0sIDIpICtcbiAgICAgICAgICAgIE1hdGgucG93KE5vZGVNYXRyaXhbbiArIE5PREVfRFldLCAyKVxuICAgICAgICApO1xuXG4gICAgICAgIGlmIChmb3JjZSA+IE1BWF9GT1JDRSkge1xuICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdID1cbiAgICAgICAgICAgIChOb2RlTWF0cml4W24gKyBOT0RFX0RYXSAqIE1BWF9GT1JDRSkgLyBmb3JjZTtcbiAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RZXSA9XG4gICAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0gKiBNQVhfRk9SQ0UpIC8gZm9yY2U7XG4gICAgICAgIH1cblxuICAgICAgICBzd2luZ2luZyA9XG4gICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9NQVNTXSAqXG4gICAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgICAgKE5vZGVNYXRyaXhbbiArIE5PREVfT0xEX0RYXSAtIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdKSAqXG4gICAgICAgICAgICAgIChOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWF0gLSBOb2RlTWF0cml4W24gKyBOT0RFX0RYXSkgK1xuICAgICAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFldIC0gTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0pICpcbiAgICAgICAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFldIC0gTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0pXG4gICAgICAgICAgKTtcblxuICAgICAgICB0cmFjdGlvbiA9XG4gICAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgICAgKE5vZGVNYXRyaXhbbiArIE5PREVfT0xEX0RYXSArIE5vZGVNYXRyaXhbbiArIE5PREVfRFhdKSAqXG4gICAgICAgICAgICAgIChOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWF0gKyBOb2RlTWF0cml4W24gKyBOT0RFX0RYXSkgK1xuICAgICAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFldICsgTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0pICpcbiAgICAgICAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFldICsgTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0pXG4gICAgICAgICAgKSAvIDI7XG5cbiAgICAgICAgbm9kZXNwZWVkID0gKDAuMSAqIE1hdGgubG9nKDEgKyB0cmFjdGlvbikpIC8gKDEgKyBNYXRoLnNxcnQoc3dpbmdpbmcpKTtcblxuICAgICAgICAvLyBVcGRhdGluZyBub2RlJ3MgcG9zaXRvblxuICAgICAgICBuZXdYID1cbiAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX1hdICtcbiAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RYXSAqIChub2Rlc3BlZWQgLyBvcHRpb25zLnNsb3dEb3duKTtcbiAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9YXSA9IG5ld1g7XG5cbiAgICAgICAgbmV3WSA9XG4gICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9ZXSArXG4gICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0gKiAobm9kZXNwZWVkIC8gb3B0aW9ucy5zbG93RG93bik7XG4gICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfWV0gPSBuZXdZO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKG4gPSAwOyBuIDwgb3JkZXI7IG4gKz0gUFBOKSB7XG4gICAgICBpZiAoTm9kZU1hdHJpeFtuICsgTk9ERV9GSVhFRF0gIT09IDEpIHtcbiAgICAgICAgc3dpbmdpbmcgPVxuICAgICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfTUFTU10gKlxuICAgICAgICAgIE1hdGguc3FydChcbiAgICAgICAgICAgIChOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWF0gLSBOb2RlTWF0cml4W24gKyBOT0RFX0RYXSkgKlxuICAgICAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFhdIC0gTm9kZU1hdHJpeFtuICsgTk9ERV9EWF0pICtcbiAgICAgICAgICAgICAgKE5vZGVNYXRyaXhbbiArIE5PREVfT0xEX0RZXSAtIE5vZGVNYXRyaXhbbiArIE5PREVfRFldKSAqXG4gICAgICAgICAgICAgICAgKE5vZGVNYXRyaXhbbiArIE5PREVfT0xEX0RZXSAtIE5vZGVNYXRyaXhbbiArIE5PREVfRFldKVxuICAgICAgICAgICk7XG5cbiAgICAgICAgdHJhY3Rpb24gPVxuICAgICAgICAgIE1hdGguc3FydChcbiAgICAgICAgICAgIChOb2RlTWF0cml4W24gKyBOT0RFX09MRF9EWF0gKyBOb2RlTWF0cml4W24gKyBOT0RFX0RYXSkgKlxuICAgICAgICAgICAgICAoTm9kZU1hdHJpeFtuICsgTk9ERV9PTERfRFhdICsgTm9kZU1hdHJpeFtuICsgTk9ERV9EWF0pICtcbiAgICAgICAgICAgICAgKE5vZGVNYXRyaXhbbiArIE5PREVfT0xEX0RZXSArIE5vZGVNYXRyaXhbbiArIE5PREVfRFldKSAqXG4gICAgICAgICAgICAgICAgKE5vZGVNYXRyaXhbbiArIE5PREVfT0xEX0RZXSArIE5vZGVNYXRyaXhbbiArIE5PREVfRFldKVxuICAgICAgICAgICkgLyAyO1xuXG4gICAgICAgIG5vZGVzcGVlZCA9XG4gICAgICAgICAgKE5vZGVNYXRyaXhbbiArIE5PREVfQ09OVkVSR0VOQ0VdICogTWF0aC5sb2coMSArIHRyYWN0aW9uKSkgL1xuICAgICAgICAgICgxICsgTWF0aC5zcXJ0KHN3aW5naW5nKSk7XG5cbiAgICAgICAgLy8gVXBkYXRpbmcgbm9kZSBjb252ZXJnZW5jZVxuICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0NPTlZFUkdFTkNFXSA9IE1hdGgubWluKFxuICAgICAgICAgIDEsXG4gICAgICAgICAgTWF0aC5zcXJ0KFxuICAgICAgICAgICAgKG5vZGVzcGVlZCAqXG4gICAgICAgICAgICAgIChNYXRoLnBvdyhOb2RlTWF0cml4W24gKyBOT0RFX0RYXSwgMikgK1xuICAgICAgICAgICAgICAgIE1hdGgucG93KE5vZGVNYXRyaXhbbiArIE5PREVfRFldLCAyKSkpIC9cbiAgICAgICAgICAgICAgKDEgKyBNYXRoLnNxcnQoc3dpbmdpbmcpKVxuICAgICAgICAgIClcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBVcGRhdGluZyBub2RlJ3MgcG9zaXRvblxuICAgICAgICBuZXdYID1cbiAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX1hdICtcbiAgICAgICAgICBOb2RlTWF0cml4W24gKyBOT0RFX0RYXSAqIChub2Rlc3BlZWQgLyBvcHRpb25zLnNsb3dEb3duKTtcbiAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9YXSA9IG5ld1g7XG5cbiAgICAgICAgbmV3WSA9XG4gICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9ZXSArXG4gICAgICAgICAgTm9kZU1hdHJpeFtuICsgTk9ERV9EWV0gKiAobm9kZXNwZWVkIC8gb3B0aW9ucy5zbG93RG93bik7XG4gICAgICAgIE5vZGVNYXRyaXhbbiArIE5PREVfWV0gPSBuZXdZO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFdlIHJldHVybiB0aGUgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGxheW91dCAobm8gbmVlZCB0byByZXR1cm4gdGhlIG1hdHJpY2VzKVxuICByZXR1cm4ge307XG59O1xuXG4gIH0pKCk7XG5cbiAgdmFyIGl0ZXJhdGUgPSBtb2R1bGVTaGltLmV4cG9ydHM7XG5cbiAgc2VsZi5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuXG4gICAgTk9ERVMgPSBuZXcgRmxvYXQzMkFycmF5KGRhdGEubm9kZXMpO1xuXG4gICAgaWYgKGRhdGEuZWRnZXMpIEVER0VTID0gbmV3IEZsb2F0MzJBcnJheShkYXRhLmVkZ2VzKTtcblxuICAgIC8vIFJ1bm5pbmcgdGhlIGl0ZXJhdGlvblxuICAgIGl0ZXJhdGUoZGF0YS5zZXR0aW5ncywgTk9ERVMsIEVER0VTKTtcblxuICAgIC8vIFNlbmRpbmcgcmVzdWx0IHRvIHN1cGVydmlzb3JcbiAgICBzZWxmLnBvc3RNZXNzYWdlKFxuICAgICAge1xuICAgICAgICBub2RlczogTk9ERVMuYnVmZmVyXG4gICAgICB9LFxuICAgICAgW05PREVTLmJ1ZmZlcl1cbiAgICApO1xuICB9KTtcbn07XG5cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-layout-forceatlas2/webworker.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/graphology-layout-forceatlas2/worker.js":
/*!**************************************************************!*\
  !*** ./node_modules/graphology-layout-forceatlas2/worker.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * Graphology ForceAtlas2 Layout Supervisor\n * =========================================\n *\n * Supervisor class able to spawn a web worker to run the FA2 layout in a\n * separate thread not to block UI with heavy synchronous computations.\n */\nvar workerFunction = __webpack_require__(/*! ./webworker.js */ \"(ssr)/./node_modules/graphology-layout-forceatlas2/webworker.js\");\nvar isGraph = __webpack_require__(/*! graphology-utils/is-graph */ \"(ssr)/./node_modules/graphology-utils/is-graph.js\");\nvar createEdgeWeightGetter =\n  (__webpack_require__(/*! graphology-utils/getters */ \"(ssr)/./node_modules/graphology-utils/getters.js\").createEdgeWeightGetter);\nvar helpers = __webpack_require__(/*! ./helpers.js */ \"(ssr)/./node_modules/graphology-layout-forceatlas2/helpers.js\");\n\nvar DEFAULT_SETTINGS = __webpack_require__(/*! ./defaults.js */ \"(ssr)/./node_modules/graphology-layout-forceatlas2/defaults.js\");\n\n/**\n * Class representing a FA2 layout run by a webworker.\n *\n * @constructor\n * @param  {Graph}         graph        - Target graph.\n * @param  {object|number} params       - Parameters:\n * @param  {object}          [settings] - Settings.\n */\nfunction FA2LayoutSupervisor(graph, params) {\n  params = params || {};\n\n  // Validation\n  if (!isGraph(graph))\n    throw new Error(\n      'graphology-layout-forceatlas2/worker: the given graph is not a valid graphology instance.'\n    );\n\n  var getEdgeWeight = createEdgeWeightGetter(\n    'getEdgeWeight' in params ? params.getEdgeWeight : 'weight'\n  ).fromEntry;\n\n  // Validating settings\n  var settings = helpers.assign({}, DEFAULT_SETTINGS, params.settings);\n  var validationError = helpers.validateSettings(settings);\n\n  if (validationError)\n    throw new Error(\n      'graphology-layout-forceatlas2/worker: ' + validationError.message\n    );\n\n  // Properties\n  this.worker = null;\n  this.graph = graph;\n  this.settings = settings;\n  this.getEdgeWeight = getEdgeWeight;\n  this.matrices = null;\n  this.running = false;\n  this.killed = false;\n  this.outputReducer =\n    typeof params.outputReducer === 'function' ? params.outputReducer : null;\n\n  // Binding listeners\n  this.handleMessage = this.handleMessage.bind(this);\n\n  var respawnFrame = undefined;\n  var self = this;\n\n  this.handleGraphUpdate = function () {\n    if (self.worker) self.worker.terminate();\n\n    if (respawnFrame) clearTimeout(respawnFrame);\n\n    respawnFrame = setTimeout(function () {\n      respawnFrame = undefined;\n      self.spawnWorker();\n    }, 0);\n  };\n\n  graph.on('nodeAdded', this.handleGraphUpdate);\n  graph.on('edgeAdded', this.handleGraphUpdate);\n  graph.on('nodeDropped', this.handleGraphUpdate);\n  graph.on('edgeDropped', this.handleGraphUpdate);\n\n  // Spawning worker\n  this.spawnWorker();\n}\n\nFA2LayoutSupervisor.prototype.isRunning = function () {\n  return this.running;\n};\n\n/**\n * Internal method used to spawn the web worker.\n */\nFA2LayoutSupervisor.prototype.spawnWorker = function () {\n  if (this.worker) this.worker.terminate();\n\n  this.worker = helpers.createWorker(workerFunction);\n  this.worker.addEventListener('message', this.handleMessage);\n\n  if (this.running) {\n    this.running = false;\n    this.start();\n  }\n};\n\n/**\n * Internal method used to handle the worker's messages.\n *\n * @param {object} event - Event to handle.\n */\nFA2LayoutSupervisor.prototype.handleMessage = function (event) {\n  if (!this.running) return;\n\n  var matrix = new Float32Array(event.data.nodes);\n\n  helpers.assignLayoutChanges(this.graph, matrix, this.outputReducer);\n  if (this.outputReducer) helpers.readGraphPositions(this.graph, matrix);\n  this.matrices.nodes = matrix;\n\n  // Looping\n  this.askForIterations();\n};\n\n/**\n * Internal method used to ask for iterations from the worker.\n *\n * @param  {boolean} withEdges - Should we send edges along?\n * @return {FA2LayoutSupervisor}\n */\nFA2LayoutSupervisor.prototype.askForIterations = function (withEdges) {\n  var matrices = this.matrices;\n\n  var payload = {\n    settings: this.settings,\n    nodes: matrices.nodes.buffer\n  };\n\n  var buffers = [matrices.nodes.buffer];\n\n  if (withEdges) {\n    payload.edges = matrices.edges.buffer;\n    buffers.push(matrices.edges.buffer);\n  }\n\n  this.worker.postMessage(payload, buffers);\n\n  return this;\n};\n\n/**\n * Method used to start the layout.\n *\n * @return {FA2LayoutSupervisor}\n */\nFA2LayoutSupervisor.prototype.start = function () {\n  if (this.killed)\n    throw new Error(\n      'graphology-layout-forceatlas2/worker.start: layout was killed.'\n    );\n\n  if (this.running) return this;\n\n  // Building matrices\n  this.matrices = helpers.graphToByteArrays(this.graph, this.getEdgeWeight);\n\n  this.running = true;\n  this.askForIterations(true);\n\n  return this;\n};\n\n/**\n * Method used to stop the layout.\n *\n * @return {FA2LayoutSupervisor}\n */\nFA2LayoutSupervisor.prototype.stop = function () {\n  this.running = false;\n\n  return this;\n};\n\n/**\n * Method used to kill the layout.\n *\n * @return {FA2LayoutSupervisor}\n */\nFA2LayoutSupervisor.prototype.kill = function () {\n  if (this.killed) return this;\n\n  this.running = false;\n  this.killed = true;\n\n  // Clearing memory\n  this.matrices = null;\n\n  // Terminating worker\n  this.worker.terminate();\n\n  // Unbinding listeners\n  this.graph.removeListener('nodeAdded', this.handleGraphUpdate);\n  this.graph.removeListener('edgeAdded', this.handleGraphUpdate);\n  this.graph.removeListener('nodeDropped', this.handleGraphUpdate);\n  this.graph.removeListener('edgeDropped', this.handleGraphUpdate);\n};\n\n/**\n * Exporting.\n */\nmodule.exports = FA2LayoutSupervisor;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQtZm9yY2VhdGxhczIvd29ya2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1CQUFPLENBQUMsdUZBQWdCO0FBQzdDLGNBQWMsbUJBQU8sQ0FBQyxvRkFBMkI7QUFDakQ7QUFDQSxFQUFFLGdJQUEwRDtBQUM1RCxjQUFjLG1CQUFPLENBQUMsbUZBQWM7O0FBRXBDLHVCQUF1QixtQkFBTyxDQUFDLHFGQUFlOztBQUU5QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLGVBQWU7QUFDM0IsWUFBWSxpQkFBaUI7QUFDN0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3BvbnNhcnUvLi9ub2RlX21vZHVsZXMvZ3JhcGhvbG9neS1sYXlvdXQtZm9yY2VhdGxhczIvd29ya2VyLmpzPzg3MjEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBHcmFwaG9sb2d5IEZvcmNlQXRsYXMyIExheW91dCBTdXBlcnZpc29yXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICpcbiAqIFN1cGVydmlzb3IgY2xhc3MgYWJsZSB0byBzcGF3biBhIHdlYiB3b3JrZXIgdG8gcnVuIHRoZSBGQTIgbGF5b3V0IGluIGFcbiAqIHNlcGFyYXRlIHRocmVhZCBub3QgdG8gYmxvY2sgVUkgd2l0aCBoZWF2eSBzeW5jaHJvbm91cyBjb21wdXRhdGlvbnMuXG4gKi9cbnZhciB3b3JrZXJGdW5jdGlvbiA9IHJlcXVpcmUoJy4vd2Vid29ya2VyLmpzJyk7XG52YXIgaXNHcmFwaCA9IHJlcXVpcmUoJ2dyYXBob2xvZ3ktdXRpbHMvaXMtZ3JhcGgnKTtcbnZhciBjcmVhdGVFZGdlV2VpZ2h0R2V0dGVyID1cbiAgcmVxdWlyZSgnZ3JhcGhvbG9neS11dGlscy9nZXR0ZXJzJykuY3JlYXRlRWRnZVdlaWdodEdldHRlcjtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgnLi9oZWxwZXJzLmpzJyk7XG5cbnZhciBERUZBVUxUX1NFVFRJTkdTID0gcmVxdWlyZSgnLi9kZWZhdWx0cy5qcycpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIEZBMiBsYXlvdXQgcnVuIGJ5IGEgd2Vid29ya2VyLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtICB7R3JhcGh9ICAgICAgICAgZ3JhcGggICAgICAgIC0gVGFyZ2V0IGdyYXBoLlxuICogQHBhcmFtICB7b2JqZWN0fG51bWJlcn0gcGFyYW1zICAgICAgIC0gUGFyYW1ldGVyczpcbiAqIEBwYXJhbSAge29iamVjdH0gICAgICAgICAgW3NldHRpbmdzXSAtIFNldHRpbmdzLlxuICovXG5mdW5jdGlvbiBGQTJMYXlvdXRTdXBlcnZpc29yKGdyYXBoLCBwYXJhbXMpIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuXG4gIC8vIFZhbGlkYXRpb25cbiAgaWYgKCFpc0dyYXBoKGdyYXBoKSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnZ3JhcGhvbG9neS1sYXlvdXQtZm9yY2VhdGxhczIvd29ya2VyOiB0aGUgZ2l2ZW4gZ3JhcGggaXMgbm90IGEgdmFsaWQgZ3JhcGhvbG9neSBpbnN0YW5jZS4nXG4gICAgKTtcblxuICB2YXIgZ2V0RWRnZVdlaWdodCA9IGNyZWF0ZUVkZ2VXZWlnaHRHZXR0ZXIoXG4gICAgJ2dldEVkZ2VXZWlnaHQnIGluIHBhcmFtcyA/IHBhcmFtcy5nZXRFZGdlV2VpZ2h0IDogJ3dlaWdodCdcbiAgKS5mcm9tRW50cnk7XG5cbiAgLy8gVmFsaWRhdGluZyBzZXR0aW5nc1xuICB2YXIgc2V0dGluZ3MgPSBoZWxwZXJzLmFzc2lnbih7fSwgREVGQVVMVF9TRVRUSU5HUywgcGFyYW1zLnNldHRpbmdzKTtcbiAgdmFyIHZhbGlkYXRpb25FcnJvciA9IGhlbHBlcnMudmFsaWRhdGVTZXR0aW5ncyhzZXR0aW5ncyk7XG5cbiAgaWYgKHZhbGlkYXRpb25FcnJvcilcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnZ3JhcGhvbG9neS1sYXlvdXQtZm9yY2VhdGxhczIvd29ya2VyOiAnICsgdmFsaWRhdGlvbkVycm9yLm1lc3NhZ2VcbiAgICApO1xuXG4gIC8vIFByb3BlcnRpZXNcbiAgdGhpcy53b3JrZXIgPSBudWxsO1xuICB0aGlzLmdyYXBoID0gZ3JhcGg7XG4gIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgdGhpcy5nZXRFZGdlV2VpZ2h0ID0gZ2V0RWRnZVdlaWdodDtcbiAgdGhpcy5tYXRyaWNlcyA9IG51bGw7XG4gIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICB0aGlzLmtpbGxlZCA9IGZhbHNlO1xuICB0aGlzLm91dHB1dFJlZHVjZXIgPVxuICAgIHR5cGVvZiBwYXJhbXMub3V0cHV0UmVkdWNlciA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmFtcy5vdXRwdXRSZWR1Y2VyIDogbnVsbDtcblxuICAvLyBCaW5kaW5nIGxpc3RlbmVyc1xuICB0aGlzLmhhbmRsZU1lc3NhZ2UgPSB0aGlzLmhhbmRsZU1lc3NhZ2UuYmluZCh0aGlzKTtcblxuICB2YXIgcmVzcGF3bkZyYW1lID0gdW5kZWZpbmVkO1xuICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgdGhpcy5oYW5kbGVHcmFwaFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoc2VsZi53b3JrZXIpIHNlbGYud29ya2VyLnRlcm1pbmF0ZSgpO1xuXG4gICAgaWYgKHJlc3Bhd25GcmFtZSkgY2xlYXJUaW1lb3V0KHJlc3Bhd25GcmFtZSk7XG5cbiAgICByZXNwYXduRnJhbWUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHJlc3Bhd25GcmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgIHNlbGYuc3Bhd25Xb3JrZXIoKTtcbiAgICB9LCAwKTtcbiAgfTtcblxuICBncmFwaC5vbignbm9kZUFkZGVkJywgdGhpcy5oYW5kbGVHcmFwaFVwZGF0ZSk7XG4gIGdyYXBoLm9uKCdlZGdlQWRkZWQnLCB0aGlzLmhhbmRsZUdyYXBoVXBkYXRlKTtcbiAgZ3JhcGgub24oJ25vZGVEcm9wcGVkJywgdGhpcy5oYW5kbGVHcmFwaFVwZGF0ZSk7XG4gIGdyYXBoLm9uKCdlZGdlRHJvcHBlZCcsIHRoaXMuaGFuZGxlR3JhcGhVcGRhdGUpO1xuXG4gIC8vIFNwYXduaW5nIHdvcmtlclxuICB0aGlzLnNwYXduV29ya2VyKCk7XG59XG5cbkZBMkxheW91dFN1cGVydmlzb3IucHJvdG90eXBlLmlzUnVubmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMucnVubmluZztcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgbWV0aG9kIHVzZWQgdG8gc3Bhd24gdGhlIHdlYiB3b3JrZXIuXG4gKi9cbkZBMkxheW91dFN1cGVydmlzb3IucHJvdG90eXBlLnNwYXduV29ya2VyID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy53b3JrZXIpIHRoaXMud29ya2VyLnRlcm1pbmF0ZSgpO1xuXG4gIHRoaXMud29ya2VyID0gaGVscGVycy5jcmVhdGVXb3JrZXIod29ya2VyRnVuY3Rpb24pO1xuICB0aGlzLndvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgdGhpcy5oYW5kbGVNZXNzYWdlKTtcblxuICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydCgpO1xuICB9XG59O1xuXG4vKipcbiAqIEludGVybmFsIG1ldGhvZCB1c2VkIHRvIGhhbmRsZSB0aGUgd29ya2VyJ3MgbWVzc2FnZXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IC0gRXZlbnQgdG8gaGFuZGxlLlxuICovXG5GQTJMYXlvdXRTdXBlcnZpc29yLnByb3RvdHlwZS5oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gIGlmICghdGhpcy5ydW5uaW5nKSByZXR1cm47XG5cbiAgdmFyIG1hdHJpeCA9IG5ldyBGbG9hdDMyQXJyYXkoZXZlbnQuZGF0YS5ub2Rlcyk7XG5cbiAgaGVscGVycy5hc3NpZ25MYXlvdXRDaGFuZ2VzKHRoaXMuZ3JhcGgsIG1hdHJpeCwgdGhpcy5vdXRwdXRSZWR1Y2VyKTtcbiAgaWYgKHRoaXMub3V0cHV0UmVkdWNlcikgaGVscGVycy5yZWFkR3JhcGhQb3NpdGlvbnModGhpcy5ncmFwaCwgbWF0cml4KTtcbiAgdGhpcy5tYXRyaWNlcy5ub2RlcyA9IG1hdHJpeDtcblxuICAvLyBMb29waW5nXG4gIHRoaXMuYXNrRm9ySXRlcmF0aW9ucygpO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBtZXRob2QgdXNlZCB0byBhc2sgZm9yIGl0ZXJhdGlvbnMgZnJvbSB0aGUgd29ya2VyLlxuICpcbiAqIEBwYXJhbSAge2Jvb2xlYW59IHdpdGhFZGdlcyAtIFNob3VsZCB3ZSBzZW5kIGVkZ2VzIGFsb25nP1xuICogQHJldHVybiB7RkEyTGF5b3V0U3VwZXJ2aXNvcn1cbiAqL1xuRkEyTGF5b3V0U3VwZXJ2aXNvci5wcm90b3R5cGUuYXNrRm9ySXRlcmF0aW9ucyA9IGZ1bmN0aW9uICh3aXRoRWRnZXMpIHtcbiAgdmFyIG1hdHJpY2VzID0gdGhpcy5tYXRyaWNlcztcblxuICB2YXIgcGF5bG9hZCA9IHtcbiAgICBzZXR0aW5nczogdGhpcy5zZXR0aW5ncyxcbiAgICBub2RlczogbWF0cmljZXMubm9kZXMuYnVmZmVyXG4gIH07XG5cbiAgdmFyIGJ1ZmZlcnMgPSBbbWF0cmljZXMubm9kZXMuYnVmZmVyXTtcblxuICBpZiAod2l0aEVkZ2VzKSB7XG4gICAgcGF5bG9hZC5lZGdlcyA9IG1hdHJpY2VzLmVkZ2VzLmJ1ZmZlcjtcbiAgICBidWZmZXJzLnB1c2gobWF0cmljZXMuZWRnZXMuYnVmZmVyKTtcbiAgfVxuXG4gIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKHBheWxvYWQsIGJ1ZmZlcnMpO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdXNlZCB0byBzdGFydCB0aGUgbGF5b3V0LlxuICpcbiAqIEByZXR1cm4ge0ZBMkxheW91dFN1cGVydmlzb3J9XG4gKi9cbkZBMkxheW91dFN1cGVydmlzb3IucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5raWxsZWQpXG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ2dyYXBob2xvZ3ktbGF5b3V0LWZvcmNlYXRsYXMyL3dvcmtlci5zdGFydDogbGF5b3V0IHdhcyBraWxsZWQuJ1xuICAgICk7XG5cbiAgaWYgKHRoaXMucnVubmluZykgcmV0dXJuIHRoaXM7XG5cbiAgLy8gQnVpbGRpbmcgbWF0cmljZXNcbiAgdGhpcy5tYXRyaWNlcyA9IGhlbHBlcnMuZ3JhcGhUb0J5dGVBcnJheXModGhpcy5ncmFwaCwgdGhpcy5nZXRFZGdlV2VpZ2h0KTtcblxuICB0aGlzLnJ1bm5pbmcgPSB0cnVlO1xuICB0aGlzLmFza0Zvckl0ZXJhdGlvbnModHJ1ZSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB1c2VkIHRvIHN0b3AgdGhlIGxheW91dC5cbiAqXG4gKiBAcmV0dXJuIHtGQTJMYXlvdXRTdXBlcnZpc29yfVxuICovXG5GQTJMYXlvdXRTdXBlcnZpc29yLnByb3RvdHlwZS5zdG9wID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWV0aG9kIHVzZWQgdG8ga2lsbCB0aGUgbGF5b3V0LlxuICpcbiAqIEByZXR1cm4ge0ZBMkxheW91dFN1cGVydmlzb3J9XG4gKi9cbkZBMkxheW91dFN1cGVydmlzb3IucHJvdG90eXBlLmtpbGwgPSBmdW5jdGlvbiAoKSB7XG4gIGlmICh0aGlzLmtpbGxlZCkgcmV0dXJuIHRoaXM7XG5cbiAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gIHRoaXMua2lsbGVkID0gdHJ1ZTtcblxuICAvLyBDbGVhcmluZyBtZW1vcnlcbiAgdGhpcy5tYXRyaWNlcyA9IG51bGw7XG5cbiAgLy8gVGVybWluYXRpbmcgd29ya2VyXG4gIHRoaXMud29ya2VyLnRlcm1pbmF0ZSgpO1xuXG4gIC8vIFVuYmluZGluZyBsaXN0ZW5lcnNcbiAgdGhpcy5ncmFwaC5yZW1vdmVMaXN0ZW5lcignbm9kZUFkZGVkJywgdGhpcy5oYW5kbGVHcmFwaFVwZGF0ZSk7XG4gIHRoaXMuZ3JhcGgucmVtb3ZlTGlzdGVuZXIoJ2VkZ2VBZGRlZCcsIHRoaXMuaGFuZGxlR3JhcGhVcGRhdGUpO1xuICB0aGlzLmdyYXBoLnJlbW92ZUxpc3RlbmVyKCdub2RlRHJvcHBlZCcsIHRoaXMuaGFuZGxlR3JhcGhVcGRhdGUpO1xuICB0aGlzLmdyYXBoLnJlbW92ZUxpc3RlbmVyKCdlZGdlRHJvcHBlZCcsIHRoaXMuaGFuZGxlR3JhcGhVcGRhdGUpO1xufTtcblxuLyoqXG4gKiBFeHBvcnRpbmcuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gRkEyTGF5b3V0U3VwZXJ2aXNvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/graphology-layout-forceatlas2/worker.js\n");

/***/ })

};
;