"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-kapsule";
exports.ids = ["vendor-chunks/react-kapsule"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-kapsule/dist/react-kapsule.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/react-kapsule/dist/react-kapsule.mjs ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ index)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jerrypick__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jerrypick */ \"(ssr)/./node_modules/jerrypick/dist/jerrypick.mjs\");\n/* harmony import */ var fromentries__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fromentries */ \"(ssr)/./node_modules/fromentries/index.js\");\n\n\n\n\nfunction _iterableToArrayLimit(arr, i) {\n  var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n  if (null != _i) {\n    var _s,\n      _e,\n      _x,\n      _r,\n      _arr = [],\n      _n = !0,\n      _d = !1;\n    try {\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\n        if (Object(_i) !== _i) return;\n        _n = !1;\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n    } catch (err) {\n      _d = !0, _e = err;\n    } finally {\n      try {\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n    return _arr;\n  }\n}\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction index (kapsuleComponent, comboParam) {\n  var _ref = _typeof(comboParam) === 'object' ? comboParam : {\n      // support old schema for backwards compatibility\n      wrapperElementType: comboParam,\n      methodNames: (arguments.length <= 2 ? undefined : arguments[2]) || undefined,\n      initPropNames: (arguments.length <= 3 ? undefined : arguments[3]) || undefined\n    },\n    _ref$wrapperElementTy = _ref.wrapperElementType,\n    wrapperElementType = _ref$wrapperElementTy === void 0 ? 'div' : _ref$wrapperElementTy,\n    _ref$nodeMapper = _ref.nodeMapper,\n    nodeMapper = _ref$nodeMapper === void 0 ? function (node) {\n      return node;\n    } : _ref$nodeMapper,\n    _ref$methodNames = _ref.methodNames,\n    methodNames = _ref$methodNames === void 0 ? [] : _ref$methodNames,\n    _ref$initPropNames = _ref.initPropNames,\n    initPropNames = _ref$initPropNames === void 0 ? [] : _ref$initPropNames;\n  return /*#__PURE__*/(0,react__WEBPACK_IMPORTED_MODULE_0__.forwardRef)(function (props, ref) {\n    var domEl = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    var _useState = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)({}),\n      _useState2 = _slicedToArray(_useState, 2),\n      prevProps = _useState2[0],\n      setPrevProps = _useState2[1];\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(function () {\n      return setPrevProps(props);\n    }); // remember previous props\n\n    // instantiate the inner kapsule component with the defined initPropNames\n    var comp = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(function () {\n      var configOptions = fromentries__WEBPACK_IMPORTED_MODULE_2__(initPropNames.filter(function (p) {\n        return props.hasOwnProperty(p);\n      }).map(function (prop) {\n        return [prop, props[prop]];\n      }));\n      return kapsuleComponent(configOptions);\n    }, []);\n    useEffectOnce(function () {\n      comp(nodeMapper(domEl.current)); // mount kapsule synchronously on this element ref, optionally mapped into an object that the kapsule understands\n    }, react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect);\n    useEffectOnce(function () {\n      // invoke destructor on unmount, if it exists\n      return comp._destructor instanceof Function ? comp._destructor : undefined;\n    });\n\n    // Call a component method\n    var _call = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(function (method) {\n      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      return comp[method] instanceof Function ? comp[method].apply(comp, args) : undefined;\n    } // method not found\n    , [comp]);\n\n    // propagate component props that have changed\n    var dynamicProps = (0,jerrypick__WEBPACK_IMPORTED_MODULE_1__.omit)(props, [].concat(_toConsumableArray(methodNames), _toConsumableArray(initPropNames))); // initPropNames or methodNames should not be called\n    Object.keys(dynamicProps).filter(function (p) {\n      return prevProps[p] !== props[p];\n    }).forEach(function (p) {\n      return _call(p, props[p]);\n    });\n\n    // bind external methods to parent ref\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useImperativeHandle)(ref, function () {\n      return fromentries__WEBPACK_IMPORTED_MODULE_2__(methodNames.map(function (method) {\n        return [method, function () {\n          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n          return _call.apply(void 0, [method].concat(args));\n        }];\n      }));\n    });\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createElement(wrapperElementType, {\n      ref: domEl\n    });\n  });\n}\n\n//\n\n// Handle R18 strict mode double mount at init\nfunction useEffectOnce(effect) {\n  var useEffectFn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\n  var destroyFunc = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n  var effectCalled = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  var renderAfterCalled = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n  var _useState3 = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(0),\n    _useState4 = _slicedToArray(_useState3, 2);\n    _useState4[0];\n    var setVal = _useState4[1];\n  if (effectCalled.current) {\n    renderAfterCalled.current = true;\n  }\n  useEffectFn(function () {\n    // only execute the effect first time around\n    if (!effectCalled.current) {\n      destroyFunc.current = effect();\n      effectCalled.current = true;\n    }\n\n    // this forces one render after the effect is run\n    setVal(function (val) {\n      return val + 1;\n    });\n    return function () {\n      // if the comp didn't render since the useEffect was called,\n      // we know it's the dummy React cycle\n      if (!renderAfterCalled.current) return;\n      if (destroyFunc.current) destroyFunc.current();\n    };\n  }, []);\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qta2Fwc3VsZS9kaXN0L3JlYWN0LWthcHN1bGUubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBbUk7QUFDbEc7QUFDSzs7QUFFdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsWUFBWSw2RUFBNkU7QUFDakcsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsU0FBUztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlEQUFVO0FBQ2hDLGdCQUFnQiw2Q0FBTTtBQUN0QixvQkFBb0IsK0NBQVEsR0FBRztBQUMvQjtBQUNBO0FBQ0E7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQSxLQUFLLEdBQUc7O0FBRVI7QUFDQSxlQUFlLDhDQUFPO0FBQ3RCLDBCQUEwQix3Q0FBVztBQUNyQztBQUNBLE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBLHVDQUF1QztBQUN2QyxLQUFLLEVBQUUsa0RBQWU7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGdCQUFnQixrREFBVztBQUMzQiw2RkFBNkYsYUFBYTtBQUMxRztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQSx1QkFBdUIsK0NBQUksd0ZBQXdGO0FBQ25IO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLOztBQUVMO0FBQ0EsSUFBSSwwREFBbUI7QUFDdkIsYUFBYSx3Q0FBVztBQUN4QjtBQUNBLGlGQUFpRixlQUFlO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsS0FBSztBQUNMLHdCQUF3QixnREFBbUI7QUFDM0M7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQSx3RkFBd0YsNENBQVM7QUFDakcsb0JBQW9CLDZDQUFNO0FBQzFCLHFCQUFxQiw2Q0FBTTtBQUMzQiwwQkFBMEIsNkNBQU07QUFDaEMsbUJBQW1CLCtDQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUU0QiIsInNvdXJjZXMiOlsid2VicGFjazovL3Nwb25zYXJ1Ly4vbm9kZV9tb2R1bGVzL3JlYWN0LWthcHN1bGUvZGlzdC9yZWFjdC1rYXBzdWxlLm1qcz83NGYyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyBmb3J3YXJkUmVmLCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZUNhbGxiYWNrLCB1c2VJbXBlcmF0aXZlSGFuZGxlLCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBvbWl0IH0gZnJvbSAnamVycnlwaWNrJztcbmltcG9ydCBmcm9tRW50cmllcyBmcm9tICdmcm9tZW50cmllcyc7XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9pID0gbnVsbCA9PSBhcnIgPyBudWxsIDogXCJ1bmRlZmluZWRcIiAhPSB0eXBlb2YgU3ltYm9sICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcIkBAaXRlcmF0b3JcIl07XG4gIGlmIChudWxsICE9IF9pKSB7XG4gICAgdmFyIF9zLFxuICAgICAgX2UsXG4gICAgICBfeCxcbiAgICAgIF9yLFxuICAgICAgX2FyciA9IFtdLFxuICAgICAgX24gPSAhMCxcbiAgICAgIF9kID0gITE7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChfeCA9IChfaSA9IF9pLmNhbGwoYXJyKSkubmV4dCwgMCA9PT0gaSkge1xuICAgICAgICBpZiAoT2JqZWN0KF9pKSAhPT0gX2kpIHJldHVybjtcbiAgICAgICAgX24gPSAhMTtcbiAgICAgIH0gZWxzZSBmb3IgKDsgIShfbiA9IChfcyA9IF94LmNhbGwoX2kpKS5kb25lKSAmJiAoX2Fyci5wdXNoKF9zLnZhbHVlKSwgX2Fyci5sZW5ndGggIT09IGkpOyBfbiA9ICEwKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIF9kID0gITAsIF9lID0gZXJyO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIV9uICYmIG51bGwgIT0gX2kucmV0dXJuICYmIChfciA9IF9pLnJldHVybigpLCBPYmplY3QoX3IpICE9PSBfcikpIHJldHVybjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBfYXJyO1xuICB9XG59XG5mdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7XG5cbiAgcmV0dXJuIF90eXBlb2YgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG9iaiAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgfSwgX3R5cGVvZihvYmopO1xufVxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XG59XG5mdW5jdGlvbiBfdG9Db25zdW1hYmxlQXJyYXkoYXJyKSB7XG4gIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5mdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShhcnIpO1xufVxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xuICBpZiAoIW8pIHJldHVybjtcbiAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xufVxuZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykgYXJyMltpXSA9IGFycltpXTtcbiAgcmV0dXJuIGFycjI7XG59XG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufVxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gaW5kZXggKGthcHN1bGVDb21wb25lbnQsIGNvbWJvUGFyYW0pIHtcbiAgdmFyIF9yZWYgPSBfdHlwZW9mKGNvbWJvUGFyYW0pID09PSAnb2JqZWN0JyA/IGNvbWJvUGFyYW0gOiB7XG4gICAgICAvLyBzdXBwb3J0IG9sZCBzY2hlbWEgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gICAgICB3cmFwcGVyRWxlbWVudFR5cGU6IGNvbWJvUGFyYW0sXG4gICAgICBtZXRob2ROYW1lczogKGFyZ3VtZW50cy5sZW5ndGggPD0gMiA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1syXSkgfHwgdW5kZWZpbmVkLFxuICAgICAgaW5pdFByb3BOYW1lczogKGFyZ3VtZW50cy5sZW5ndGggPD0gMyA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1szXSkgfHwgdW5kZWZpbmVkXG4gICAgfSxcbiAgICBfcmVmJHdyYXBwZXJFbGVtZW50VHkgPSBfcmVmLndyYXBwZXJFbGVtZW50VHlwZSxcbiAgICB3cmFwcGVyRWxlbWVudFR5cGUgPSBfcmVmJHdyYXBwZXJFbGVtZW50VHkgPT09IHZvaWQgMCA/ICdkaXYnIDogX3JlZiR3cmFwcGVyRWxlbWVudFR5LFxuICAgIF9yZWYkbm9kZU1hcHBlciA9IF9yZWYubm9kZU1hcHBlcixcbiAgICBub2RlTWFwcGVyID0gX3JlZiRub2RlTWFwcGVyID09PSB2b2lkIDAgPyBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSA6IF9yZWYkbm9kZU1hcHBlcixcbiAgICBfcmVmJG1ldGhvZE5hbWVzID0gX3JlZi5tZXRob2ROYW1lcyxcbiAgICBtZXRob2ROYW1lcyA9IF9yZWYkbWV0aG9kTmFtZXMgPT09IHZvaWQgMCA/IFtdIDogX3JlZiRtZXRob2ROYW1lcyxcbiAgICBfcmVmJGluaXRQcm9wTmFtZXMgPSBfcmVmLmluaXRQcm9wTmFtZXMsXG4gICAgaW5pdFByb3BOYW1lcyA9IF9yZWYkaW5pdFByb3BOYW1lcyA9PT0gdm9pZCAwID8gW10gOiBfcmVmJGluaXRQcm9wTmFtZXM7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovZm9yd2FyZFJlZihmdW5jdGlvbiAocHJvcHMsIHJlZikge1xuICAgIHZhciBkb21FbCA9IHVzZVJlZigpO1xuICAgIHZhciBfdXNlU3RhdGUgPSB1c2VTdGF0ZSh7fSksXG4gICAgICBfdXNlU3RhdGUyID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlLCAyKSxcbiAgICAgIHByZXZQcm9wcyA9IF91c2VTdGF0ZTJbMF0sXG4gICAgICBzZXRQcmV2UHJvcHMgPSBfdXNlU3RhdGUyWzFdO1xuICAgIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2V0UHJldlByb3BzKHByb3BzKTtcbiAgICB9KTsgLy8gcmVtZW1iZXIgcHJldmlvdXMgcHJvcHNcblxuICAgIC8vIGluc3RhbnRpYXRlIHRoZSBpbm5lciBrYXBzdWxlIGNvbXBvbmVudCB3aXRoIHRoZSBkZWZpbmVkIGluaXRQcm9wTmFtZXNcbiAgICB2YXIgY29tcCA9IHVzZU1lbW8oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbmZpZ09wdGlvbnMgPSBmcm9tRW50cmllcyhpbml0UHJvcE5hbWVzLmZpbHRlcihmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gcHJvcHMuaGFzT3duUHJvcGVydHkocCk7XG4gICAgICB9KS5tYXAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIFtwcm9wLCBwcm9wc1twcm9wXV07XG4gICAgICB9KSk7XG4gICAgICByZXR1cm4ga2Fwc3VsZUNvbXBvbmVudChjb25maWdPcHRpb25zKTtcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0T25jZShmdW5jdGlvbiAoKSB7XG4gICAgICBjb21wKG5vZGVNYXBwZXIoZG9tRWwuY3VycmVudCkpOyAvLyBtb3VudCBrYXBzdWxlIHN5bmNocm9ub3VzbHkgb24gdGhpcyBlbGVtZW50IHJlZiwgb3B0aW9uYWxseSBtYXBwZWQgaW50byBhbiBvYmplY3QgdGhhdCB0aGUga2Fwc3VsZSB1bmRlcnN0YW5kc1xuICAgIH0sIHVzZUxheW91dEVmZmVjdCk7XG4gICAgdXNlRWZmZWN0T25jZShmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBpbnZva2UgZGVzdHJ1Y3RvciBvbiB1bm1vdW50LCBpZiBpdCBleGlzdHNcbiAgICAgIHJldHVybiBjb21wLl9kZXN0cnVjdG9yIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBjb21wLl9kZXN0cnVjdG9yIDogdW5kZWZpbmVkO1xuICAgIH0pO1xuXG4gICAgLy8gQ2FsbCBhIGNvbXBvbmVudCBtZXRob2RcbiAgICB2YXIgX2NhbGwgPSB1c2VDYWxsYmFjayhmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgIGFyZ3NbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbXBbbWV0aG9kXSBpbnN0YW5jZW9mIEZ1bmN0aW9uID8gY29tcFttZXRob2RdLmFwcGx5KGNvbXAsIGFyZ3MpIDogdW5kZWZpbmVkO1xuICAgIH0gLy8gbWV0aG9kIG5vdCBmb3VuZFxuICAgICwgW2NvbXBdKTtcblxuICAgIC8vIHByb3BhZ2F0ZSBjb21wb25lbnQgcHJvcHMgdGhhdCBoYXZlIGNoYW5nZWRcbiAgICB2YXIgZHluYW1pY1Byb3BzID0gb21pdChwcm9wcywgW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShtZXRob2ROYW1lcyksIF90b0NvbnN1bWFibGVBcnJheShpbml0UHJvcE5hbWVzKSkpOyAvLyBpbml0UHJvcE5hbWVzIG9yIG1ldGhvZE5hbWVzIHNob3VsZCBub3QgYmUgY2FsbGVkXG4gICAgT2JqZWN0LmtleXMoZHluYW1pY1Byb3BzKS5maWx0ZXIoZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBwcmV2UHJvcHNbcF0gIT09IHByb3BzW3BdO1xuICAgIH0pLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICAgIHJldHVybiBfY2FsbChwLCBwcm9wc1twXSk7XG4gICAgfSk7XG5cbiAgICAvLyBiaW5kIGV4dGVybmFsIG1ldGhvZHMgdG8gcGFyZW50IHJlZlxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGUocmVmLCBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZnJvbUVudHJpZXMobWV0aG9kTmFtZXMubWFwKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIFttZXRob2QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIpLCBfa2V5MiA9IDA7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2tleTJdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9jYWxsLmFwcGx5KHZvaWQgMCwgW21ldGhvZF0uY29uY2F0KGFyZ3MpKTtcbiAgICAgICAgfV07XG4gICAgICB9KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KHdyYXBwZXJFbGVtZW50VHlwZSwge1xuICAgICAgcmVmOiBkb21FbFxuICAgIH0pO1xuICB9KTtcbn1cblxuLy9cblxuLy8gSGFuZGxlIFIxOCBzdHJpY3QgbW9kZSBkb3VibGUgbW91bnQgYXQgaW5pdFxuZnVuY3Rpb24gdXNlRWZmZWN0T25jZShlZmZlY3QpIHtcbiAgdmFyIHVzZUVmZmVjdEZuID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB1c2VFZmZlY3Q7XG4gIHZhciBkZXN0cm95RnVuYyA9IHVzZVJlZigpO1xuICB2YXIgZWZmZWN0Q2FsbGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgdmFyIHJlbmRlckFmdGVyQ2FsbGVkID0gdXNlUmVmKGZhbHNlKTtcbiAgdmFyIF91c2VTdGF0ZTMgPSB1c2VTdGF0ZSgwKSxcbiAgICBfdXNlU3RhdGU0ID0gX3NsaWNlZFRvQXJyYXkoX3VzZVN0YXRlMywgMik7XG4gICAgX3VzZVN0YXRlNFswXTtcbiAgICB2YXIgc2V0VmFsID0gX3VzZVN0YXRlNFsxXTtcbiAgaWYgKGVmZmVjdENhbGxlZC5jdXJyZW50KSB7XG4gICAgcmVuZGVyQWZ0ZXJDYWxsZWQuY3VycmVudCA9IHRydWU7XG4gIH1cbiAgdXNlRWZmZWN0Rm4oZnVuY3Rpb24gKCkge1xuICAgIC8vIG9ubHkgZXhlY3V0ZSB0aGUgZWZmZWN0IGZpcnN0IHRpbWUgYXJvdW5kXG4gICAgaWYgKCFlZmZlY3RDYWxsZWQuY3VycmVudCkge1xuICAgICAgZGVzdHJveUZ1bmMuY3VycmVudCA9IGVmZmVjdCgpO1xuICAgICAgZWZmZWN0Q2FsbGVkLmN1cnJlbnQgPSB0cnVlO1xuICAgIH1cblxuICAgIC8vIHRoaXMgZm9yY2VzIG9uZSByZW5kZXIgYWZ0ZXIgdGhlIGVmZmVjdCBpcyBydW5cbiAgICBzZXRWYWwoZnVuY3Rpb24gKHZhbCkge1xuICAgICAgcmV0dXJuIHZhbCArIDE7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGlmIHRoZSBjb21wIGRpZG4ndCByZW5kZXIgc2luY2UgdGhlIHVzZUVmZmVjdCB3YXMgY2FsbGVkLFxuICAgICAgLy8gd2Uga25vdyBpdCdzIHRoZSBkdW1teSBSZWFjdCBjeWNsZVxuICAgICAgaWYgKCFyZW5kZXJBZnRlckNhbGxlZC5jdXJyZW50KSByZXR1cm47XG4gICAgICBpZiAoZGVzdHJveUZ1bmMuY3VycmVudCkgZGVzdHJveUZ1bmMuY3VycmVudCgpO1xuICAgIH07XG4gIH0sIFtdKTtcbn1cblxuZXhwb3J0IHsgaW5kZXggYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-kapsule/dist/react-kapsule.mjs\n");

/***/ })

};
;