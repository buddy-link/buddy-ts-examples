(()=>{var e={};e.id=931,e.ids=[931],e.modules={7849:e=>{"use strict";e.exports=require("next/dist/client/components/action-async-storage.external")},2934:e=>{"use strict";e.exports=require("next/dist/client/components/action-async-storage.external.js")},5403:e=>{"use strict";e.exports=require("next/dist/client/components/request-async-storage.external")},4580:e=>{"use strict";e.exports=require("next/dist/client/components/request-async-storage.external.js")},4749:e=>{"use strict";e.exports=require("next/dist/client/components/static-generation-async-storage.external")},5869:e=>{"use strict";e.exports=require("next/dist/client/components/static-generation-async-storage.external.js")},399:e=>{"use strict";e.exports=require("next/dist/compiled/next-server/app-page.runtime.prod.js")},4300:e=>{"use strict";e.exports=require("buffer")},6113:e=>{"use strict";e.exports=require("crypto")},2361:e=>{"use strict";e.exports=require("events")},7147:e=>{"use strict";e.exports=require("fs")},3685:e=>{"use strict";e.exports=require("http")},5687:e=>{"use strict";e.exports=require("https")},1808:e=>{"use strict";e.exports=require("net")},6005:e=>{"use strict";e.exports=require("node:crypto")},2037:e=>{"use strict";e.exports=require("os")},1017:e=>{"use strict";e.exports=require("path")},5477:e=>{"use strict";e.exports=require("punycode")},2781:e=>{"use strict";e.exports=require("stream")},4404:e=>{"use strict";e.exports=require("tls")},7310:e=>{"use strict";e.exports=require("url")},3837:e=>{"use strict";e.exports=require("util")},9796:e=>{"use strict";e.exports=require("zlib")},3637:(e,t,r)=>{"use strict";r.r(t),r.d(t,{GlobalError:()=>a.a,__next_app__:()=>l,originalPathname:()=>c,pages:()=>h,routeModule:()=>p,tree:()=>d}),r(8015),r(5933),r(5866);var i=r(3191),n=r(8716),o=r(7922),a=r.n(o),s=r(5231),u={};for(let e in s)0>["default","tree","pages","GlobalError","originalPathname","__next_app__","routeModule"].indexOf(e)&&(u[e]=()=>s[e]);r.d(t,u);let d=["",{children:["__PAGE__",{},{page:[()=>Promise.resolve().then(r.bind(r,8015)),"/Users/rafael/work/buddy-link/buddy-ts-examples/next/sponsaru/src/app/page.tsx"],metadata:{icon:[async e=>(await Promise.resolve().then(r.bind(r,3881))).default(e)],apple:[],openGraph:[],twitter:[],manifest:void 0}}]},{layout:[()=>Promise.resolve().then(r.bind(r,5933)),"/Users/rafael/work/buddy-link/buddy-ts-examples/next/sponsaru/src/app/layout.tsx"],"not-found":[()=>Promise.resolve().then(r.t.bind(r,5866,23)),"next/dist/client/components/not-found-error"],metadata:{icon:[async e=>(await Promise.resolve().then(r.bind(r,3881))).default(e)],apple:[],openGraph:[],twitter:[],manifest:void 0}}],h=["/Users/rafael/work/buddy-link/buddy-ts-examples/next/sponsaru/src/app/page.tsx"],c="/page",l={require:r,loadChunk:()=>Promise.resolve()},p=new i.AppPageRouteModule({definition:{kind:n.x.APP_PAGE,page:"/page",pathname:"/",bundlePath:"",filename:"",appPaths:[]},userland:{loaderTree:d}})},3907:(e,t,r)=>{Promise.resolve().then(r.bind(r,9608))},6126:(e,t,r)=>{var i=r(2363),n=r(3005);e.exports=function(){var e=arguments,t=null,r=-1;return new i(function(){for(var i=null;;){if(null===t){if(++r>=e.length)return{done:!0};t=n(e[r])}if(!0===(i=t.next()).done){t=null;continue}break}return i})}},3005:(e,t,r)=>{var i=r(2363),n=r(4990),o=n.ARRAY_BUFFER_SUPPORT,a=n.SYMBOL_SUPPORT;e.exports=function(e){var t="string"==typeof e||Array.isArray(e)||o&&ArrayBuffer.isView(e)?i.fromSequence(e):"object"!=typeof e||null===e?null:a&&"function"==typeof e[Symbol.iterator]?e[Symbol.iterator]():"function"==typeof e.next?e:null;if(!t)throw Error("obliterator: target is not iterable nor a valid iterator.");return t}},2363:e=>{function t(e){if("function"!=typeof e)throw Error("obliterator/iterator: expecting a function!");this.next=e}"undefined"!=typeof Symbol&&(t.prototype[Symbol.iterator]=function(){return this}),t.of=function(){var e=arguments,r=e.length,i=0;return new t(function(){return i>=r?{done:!0}:{done:!1,value:e[i++]}})},t.empty=function(){return new t(function(){return{done:!0}})},t.fromSequence=function(e){var r=0,i=e.length;return new t(function(){return r>=i?{done:!0}:{done:!1,value:e[r++]}})},t.is=function(e){return e instanceof t||"object"==typeof e&&null!==e&&"function"==typeof e.next},e.exports=t},4990:(e,t)=>{t.ARRAY_BUFFER_SUPPORT="undefined"!=typeof ArrayBuffer,t.SYMBOL_SUPPORT="undefined"!=typeof Symbol},7500:(e,t,r)=>{var i=r(3005);e.exports=function(e,t){for(var r,n=arguments.length>1?t:1/0,o=n!==1/0?Array(n):[],a=0,s=i(e);;){if(a===n)return o;if((r=s.next()).done)return a!==t&&(o.length=a),o;o[a++]=r.value}}},9608:(e,t,r)=>{"use strict";r.d(t,{default:()=>e_});var i=r(326),n=r(7577),o=r(2361),a=r(2363),s=r.n(a),u=r(7500),d=r.n(u),h=r(6126),c=r.n(h);let l=function(){let e=arguments[0];for(let t=1,r=arguments.length;t<r;t++)if(arguments[t])for(let r in arguments[t])e[r]=arguments[t][r];return e};function p(e,t,r,i){let n=e._nodes.get(t),o=null;return n?o="mixed"===i?n.out&&n.out[r]||n.undirected&&n.undirected[r]:"directed"===i?n.out&&n.out[r]:n.undirected&&n.undirected[r]:o}function f(e){return"object"==typeof e&&null!==e}function g(e){let t;for(t in e)return!1;return!0}function y(e,t,r){Object.defineProperty(e,t,{enumerable:!1,configurable:!1,writable:!0,value:r})}function m(e,t,r){let i={enumerable:!0,configurable:!0};"function"==typeof r?i.get=r:(i.value=r,i.writable=!1),Object.defineProperty(e,t,i)}function b(e){return!!(f(e)&&(!e.attributes||Array.isArray(e.attributes)))}"function"==typeof Object.assign&&(l=Object.assign);class w extends Error{constructor(e){super(),this.name="GraphError",this.message=e}}class x extends w{constructor(e){super(e),this.name="InvalidArgumentsGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,x.prototype.constructor)}}class v extends w{constructor(e){super(e),this.name="NotFoundGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,v.prototype.constructor)}}class _ extends w{constructor(e){super(e),this.name="UsageGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(this,_.prototype.constructor)}}function E(e,t){this.key=e,this.attributes=t,this.clear()}function $(e,t){this.key=e,this.attributes=t,this.clear()}function k(e,t){this.key=e,this.attributes=t,this.clear()}function A(e,t,r,i,n){this.key=t,this.attributes=n,this.undirected=e,this.source=r,this.target=i}function G(e,t,r,i,n,o,a){let s,u,d,h;if(i=""+i,0===r){if(!(s=e._nodes.get(i)))throw new v(`Graph.${t}: could not find the "${i}" node in the graph.`);d=n,h=o}else if(3===r){if(n=""+n,!(u=e._edges.get(n)))throw new v(`Graph.${t}: could not find the "${n}" edge in the graph.`);let r=u.source.key,c=u.target.key;if(i===r)s=u.target;else if(i===c)s=u.source;else throw new v(`Graph.${t}: the "${i}" node is not attached to the "${n}" edge (${r}, ${c}).`);d=o,h=a}else{if(!(u=e._edges.get(i)))throw new v(`Graph.${t}: could not find the "${i}" edge in the graph.`);s=1===r?u.source:u.target,d=n,h=o}return[s,d,h]}E.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.undirectedLoops=0,this.directedLoops=0,this.in={},this.out={},this.undirected={}},$.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.directedLoops=0,this.in={},this.out={}},k.prototype.clear=function(){this.undirectedDegree=0,this.undirectedLoops=0,this.undirected={}},A.prototype.attach=function(){let e="out",t="in";this.undirected&&(e=t="undirected");let r=this.source.key,i=this.target.key;this.source[e][i]=this,this.undirected&&r===i||(this.target[t][r]=this)},A.prototype.attachMulti=function(){let e="out",t="in",r=this.source.key,i=this.target.key;this.undirected&&(e=t="undirected");let n=this.source[e],o=n[i];if(void 0===o){n[i]=this,this.undirected&&r===i||(this.target[t][r]=this);return}o.previous=this,this.next=o,n[i]=this,this.target[t][r]=this},A.prototype.detach=function(){let e=this.source.key,t=this.target.key,r="out",i="in";this.undirected&&(r=i="undirected"),delete this.source[r][t],delete this.target[i][e]},A.prototype.detachMulti=function(){let e=this.source.key,t=this.target.key,r="out",i="in";this.undirected&&(r=i="undirected"),void 0===this.previous?void 0===this.next?(delete this.source[r][t],delete this.target[i][e]):(this.next.previous=void 0,this.source[r][t]=this.next,this.target[i][e]=this.next):(this.previous.next=this.next,void 0!==this.next&&(this.next.previous=this.previous))};let S=[{name:e=>`get${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n){let[o,a]=G(this,t,r,e,i,n);return o.attributes[a]}}},{name:e=>`get${e}Attributes`,attacher:function(e,t,r){e.prototype[t]=function(e,i){let[n]=G(this,t,r,e,i);return n.attributes}}},{name:e=>`has${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n){let[o,a]=G(this,t,r,e,i,n);return o.attributes.hasOwnProperty(a)}}},{name:e=>`set${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n,o){let[a,s,u]=G(this,t,r,e,i,n,o);return a.attributes[s]=u,this.emit("nodeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:s}),this}}},{name:e=>`update${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n,o){let[a,s,u]=G(this,t,r,e,i,n,o);if("function"!=typeof u)throw new x(`Graph.${t}: updater should be a function.`);let d=a.attributes,h=u(d[s]);return d[s]=h,this.emit("nodeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:s}),this}}},{name:e=>`remove${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n){let[o,a]=G(this,t,r,e,i,n);return delete o.attributes[a],this.emit("nodeAttributesUpdated",{key:o.key,type:"remove",attributes:o.attributes,name:a}),this}}},{name:e=>`replace${e}Attributes`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n){let[o,a]=G(this,t,r,e,i,n);if(!f(a))throw new x(`Graph.${t}: provided attributes are not a plain object.`);return o.attributes=a,this.emit("nodeAttributesUpdated",{key:o.key,type:"replace",attributes:o.attributes}),this}}},{name:e=>`merge${e}Attributes`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n){let[o,a]=G(this,t,r,e,i,n);if(!f(a))throw new x(`Graph.${t}: provided attributes are not a plain object.`);return l(o.attributes,a),this.emit("nodeAttributesUpdated",{key:o.key,type:"merge",attributes:o.attributes,data:a}),this}}},{name:e=>`update${e}Attributes`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n){let[o,a]=G(this,t,r,e,i,n);if("function"!=typeof a)throw new x(`Graph.${t}: provided updater is not a function.`);return o.attributes=a(o.attributes),this.emit("nodeAttributesUpdated",{key:o.key,type:"update",attributes:o.attributes}),this}}}],P=[{name:e=>`get${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i){let n;if("mixed"!==this.type&&"mixed"!==r&&r!==this.type)throw new _(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new _(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let o=""+e,a=""+i;if(i=arguments[2],!(n=p(this,o,a,r)))throw new v(`Graph.${t}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if("mixed"!==r)throw new _(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(n=this._edges.get(e)))throw new v(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return n.attributes[i]}}},{name:e=>`get${e}Attributes`,attacher:function(e,t,r){e.prototype[t]=function(e){let i;if("mixed"!==this.type&&"mixed"!==r&&r!==this.type)throw new _(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>1){if(this.multi)throw new _(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let n=""+e,o=""+arguments[1];if(!(i=p(this,n,o,r)))throw new v(`Graph.${t}: could not find an edge for the given path ("${n}" - "${o}").`)}else{if("mixed"!==r)throw new _(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(i=this._edges.get(e)))throw new v(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return i.attributes}}},{name:e=>`has${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i){let n;if("mixed"!==this.type&&"mixed"!==r&&r!==this.type)throw new _(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new _(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let o=""+e,a=""+i;if(i=arguments[2],!(n=p(this,o,a,r)))throw new v(`Graph.${t}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if("mixed"!==r)throw new _(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(n=this._edges.get(e)))throw new v(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return n.attributes.hasOwnProperty(i)}}},{name:e=>`set${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n){let o;if("mixed"!==this.type&&"mixed"!==r&&r!==this.type)throw new _(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new _(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let a=""+e,s=""+i;if(i=arguments[2],n=arguments[3],!(o=p(this,a,s,r)))throw new v(`Graph.${t}: could not find an edge for the given path ("${a}" - "${s}").`)}else{if("mixed"!==r)throw new _(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(o=this._edges.get(e)))throw new v(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return o.attributes[i]=n,this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:i}),this}}},{name:e=>`update${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i,n){let o;if("mixed"!==this.type&&"mixed"!==r&&r!==this.type)throw new _(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>3){if(this.multi)throw new _(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let a=""+e,s=""+i;if(i=arguments[2],n=arguments[3],!(o=p(this,a,s,r)))throw new v(`Graph.${t}: could not find an edge for the given path ("${a}" - "${s}").`)}else{if("mixed"!==r)throw new _(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(o=this._edges.get(e)))throw new v(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if("function"!=typeof n)throw new x(`Graph.${t}: updater should be a function.`);return o.attributes[i]=n(o.attributes[i]),this.emit("edgeAttributesUpdated",{key:o.key,type:"set",attributes:o.attributes,name:i}),this}}},{name:e=>`remove${e}Attribute`,attacher:function(e,t,r){e.prototype[t]=function(e,i){let n;if("mixed"!==this.type&&"mixed"!==r&&r!==this.type)throw new _(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new _(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let o=""+e,a=""+i;if(i=arguments[2],!(n=p(this,o,a,r)))throw new v(`Graph.${t}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if("mixed"!==r)throw new _(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(n=this._edges.get(e)))throw new v(`Graph.${t}: could not find the "${e}" edge in the graph.`)}return delete n.attributes[i],this.emit("edgeAttributesUpdated",{key:n.key,type:"remove",attributes:n.attributes,name:i}),this}}},{name:e=>`replace${e}Attributes`,attacher:function(e,t,r){e.prototype[t]=function(e,i){let n;if("mixed"!==this.type&&"mixed"!==r&&r!==this.type)throw new _(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new _(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let o=""+e,a=""+i;if(i=arguments[2],!(n=p(this,o,a,r)))throw new v(`Graph.${t}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if("mixed"!==r)throw new _(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(n=this._edges.get(e)))throw new v(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if(!f(i))throw new x(`Graph.${t}: provided attributes are not a plain object.`);return n.attributes=i,this.emit("edgeAttributesUpdated",{key:n.key,type:"replace",attributes:n.attributes}),this}}},{name:e=>`merge${e}Attributes`,attacher:function(e,t,r){e.prototype[t]=function(e,i){let n;if("mixed"!==this.type&&"mixed"!==r&&r!==this.type)throw new _(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new _(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let o=""+e,a=""+i;if(i=arguments[2],!(n=p(this,o,a,r)))throw new v(`Graph.${t}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if("mixed"!==r)throw new _(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(n=this._edges.get(e)))throw new v(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if(!f(i))throw new x(`Graph.${t}: provided attributes are not a plain object.`);return l(n.attributes,i),this.emit("edgeAttributesUpdated",{key:n.key,type:"merge",attributes:n.attributes,data:i}),this}}},{name:e=>`update${e}Attributes`,attacher:function(e,t,r){e.prototype[t]=function(e,i){let n;if("mixed"!==this.type&&"mixed"!==r&&r!==this.type)throw new _(`Graph.${t}: cannot find this type of edges in your ${this.type} graph.`);if(arguments.length>2){if(this.multi)throw new _(`Graph.${t}: cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about.`);let o=""+e,a=""+i;if(i=arguments[2],!(n=p(this,o,a,r)))throw new v(`Graph.${t}: could not find an edge for the given path ("${o}" - "${a}").`)}else{if("mixed"!==r)throw new _(`Graph.${t}: calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type.`);if(e=""+e,!(n=this._edges.get(e)))throw new v(`Graph.${t}: could not find the "${e}" edge in the graph.`)}if("function"!=typeof i)throw new x(`Graph.${t}: provided updater is not a function.`);return n.attributes=i(n.attributes),this.emit("edgeAttributesUpdated",{key:n.key,type:"update",attributes:n.attributes}),this}}}],j=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function R(e,t,r,i){let n=!1;for(let o in t){if(o===i)continue;let a=t[o];if(n=r(a.key,a.attributes,a.source.key,a.target.key,a.source.attributes,a.target.attributes,a.undirected),e&&n)return a.key}}function N(e,t,r,i){let n,o,a;let s=!1;for(let u in t)if(u!==i){n=t[u];do{if(o=n.source,a=n.target,s=r(n.key,n.attributes,o.key,a.key,o.attributes,a.attributes,n.undirected),e&&s)return n.key;n=n.next}while(void 0!==n)}}function D(e,t){let r;let i=Object.keys(e),n=i.length,o=0;return new(s())(function(){do if(r)r=r.next;else{if(o>=n)return{done:!0};let a=i[o++];if(a===t){r=void 0;continue}r=e[a]}while(!r);return{done:!1,value:{edge:r.key,attributes:r.attributes,source:r.source.key,target:r.target.key,sourceAttributes:r.source.attributes,targetAttributes:r.target.attributes,undirected:r.undirected}}})}function O(e,t,r,i){let n=t[r];if(!n)return;let o=n.source,a=n.target;if(i(n.key,n.attributes,o.key,a.key,o.attributes,a.attributes,n.undirected)&&e)return n.key}function U(e,t,r,i){let n=t[r];if(!n)return;let o=!1;do{if(o=i(n.key,n.attributes,n.source.key,n.target.key,n.source.attributes,n.target.attributes,n.undirected),e&&o)return n.key;n=n.next}while(void 0!==n)}function L(e,t){let r=e[t];return void 0!==r.next?new(s())(function(){if(!r)return{done:!0};let e={edge:r.key,attributes:r.attributes,source:r.source.key,target:r.target.key,sourceAttributes:r.source.attributes,targetAttributes:r.target.attributes,undirected:r.undirected};return r=r.next,{done:!1,value:e}}):s().of({edge:r.key,attributes:r.attributes,source:r.source.key,target:r.target.key,sourceAttributes:r.source.attributes,targetAttributes:r.target.attributes,undirected:r.undirected})}function C(e,t,r,i){let n,o;if(0===t.size)return;let a="mixed"!==r&&r!==t.type,s="undirected"===r,u=!1,d=t._edges.values();for(;!0!==(n=d.next()).done;){if(o=n.value,a&&o.undirected!==s)continue;let{key:t,attributes:r,source:d,target:h}=o;if(u=i(t,r,d.key,h.key,d.attributes,h.attributes,o.undirected),e&&u)return t}}function M(e,t,r,i,n,o){let a;let s=t?N:R;if("undirected"!==r&&("out"!==i&&(a=s(e,n.in,o),e&&a)||"in"!==i&&(a=s(e,n.out,o,i?void 0:n.key),e&&a))||"directed"!==r&&(a=s(e,n.undirected,o),e&&a))return a}function T(e,t,r,i,n,o,a){let s;let u=r?U:O;if("undirected"!==t&&(void 0!==n.in&&"out"!==i&&(s=u(e,n.in,o,a),e&&s)||void 0!==n.out&&"in"!==i&&(i||n.key!==o)&&(s=u(e,n.out,o,a),e&&s))||"directed"!==t&&void 0!==n.undirected&&(s=u(e,n.undirected,o,a),e&&s))return s}let z=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function I(){this.A=null,this.B=null}function W(e,t,r,i,n){for(let o in i){let a=i[o],s=a.source,u=a.target,d=s===r?u:s;if(t&&t.has(d.key))continue;let h=n(d.key,d.attributes);if(e&&h)return d.key}}function q(e,t,r,i,n){let o;if("mixed"!==t){if("undirected"===t)return W(e,null,i,i.undirected,n);if("string"==typeof r)return W(e,null,i,i[r],n)}let a=new I;if("undirected"!==t){if("out"!==r){if(o=W(e,null,i,i.in,n),e&&o)return o;a.wrap(i.in)}if("in"!==r){if(o=W(e,a,i,i.out,n),e&&o)return o;a.wrap(i.out)}}if("directed"!==t&&(o=W(e,a,i,i.undirected,n),e&&o))return o}function F(e,t,r){let i=Object.keys(r),n=i.length,o=0;return new(s())(function(){let a=null;do{if(o>=n)return e&&e.wrap(r),{done:!0};let s=r[i[o++]],u=s.source,d=s.target;if(a=u===t?d:u,e&&e.has(a.key)){a=null;continue}}while(null===a);return{done:!1,value:{neighbor:a.key,attributes:a.attributes}}})}function K(e,t,r,i,n){let o,a,s,u,d,h,c;let l=i._nodes.values(),p=i.type;for(;!0!==(o=l.next()).done;){let i=!1;if(a=o.value,"undirected"!==p)for(s in u=a.out){d=u[s];do{if(h=d.target,i=!0,c=n(a.key,h.key,a.attributes,h.attributes,d.key,d.attributes,d.undirected),e&&c)return d;d=d.next}while(d)}if("directed"!==p){for(s in u=a.undirected)if(!t||!(a.key>s)){d=u[s];do{if((h=d.target).key!==s&&(h=d.source),i=!0,c=n(a.key,h.key,a.attributes,h.attributes,d.key,d.attributes,d.undirected),e&&c)return d;d=d.next}while(d)}}if(r&&!i&&(c=n(a.key,null,a.attributes,null,null,null,null),e&&c))return null}}I.prototype.wrap=function(e){null===this.A?this.A=e:null===this.B&&(this.B=e)},I.prototype.has=function(e){return null!==this.A&&e in this.A||null!==this.B&&e in this.B};let Y=function(){let e=255&Math.floor(256*Math.random());return()=>e++}(),H=new Set(["directed","undirected","mixed"]),B=new Set(["domain","_events","_eventsCount","_maxListeners"]),X={allowSelfLoops:!0,multi:!1,type:"mixed"};function Q(e,t,r){let i=new e.NodeDataClass(t,r);return e._nodes.set(t,i),e.emit("nodeAdded",{key:t,attributes:r}),i}function J(e,t,r,i,n,o,a,s){if(!i&&"undirected"===e.type)throw new _(`Graph.${t}: you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead.`);if(i&&"directed"===e.type)throw new _(`Graph.${t}: you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead.`);if(s&&!f(s))throw new x(`Graph.${t}: invalid attributes. Expecting an object but got "${s}"`);if(o=""+o,a=""+a,s=s||{},!e.allowSelfLoops&&o===a)throw new _(`Graph.${t}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let u=e._nodes.get(o),d=e._nodes.get(a);if(!u)throw new v(`Graph.${t}: source node "${o}" not found.`);if(!d)throw new v(`Graph.${t}: target node "${a}" not found.`);let h={key:null,undirected:i,source:o,target:a,attributes:s};if(r)n=e._edgeKeyGenerator();else if(n=""+n,e._edges.has(n))throw new _(`Graph.${t}: the "${n}" edge already exists in the graph.`);if(!e.multi&&(i?void 0!==u.undirected[a]:void 0!==u.out[a]))throw new _(`Graph.${t}: an edge linking "${o}" to "${a}" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option.`);let c=new A(i,n,u,d,s);e._edges.set(n,c);let l=o===a;return i?(u.undirectedDegree++,d.undirectedDegree++,l&&(u.undirectedLoops++,e._undirectedSelfLoopCount++)):(u.outDegree++,d.inDegree++,l&&(u.directedLoops++,e._directedSelfLoopCount++)),e.multi?c.attachMulti():c.attach(),i?e._undirectedSize++:e._directedSize++,h.key=n,e.emit("edgeAdded",h),n}function V(e,t,r,i,n,o,a,s,u){let d,h,c;if(!i&&"undirected"===e.type)throw new _(`Graph.${t}: you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead.`);if(i&&"directed"===e.type)throw new _(`Graph.${t}: you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead.`);if(s){if(u){if("function"!=typeof s)throw new x(`Graph.${t}: invalid updater function. Expecting a function but got "${s}"`)}else if(!f(s))throw new x(`Graph.${t}: invalid attributes. Expecting an object but got "${s}"`)}if(o=""+o,a=""+a,u&&(d=s,s=void 0),!e.allowSelfLoops&&o===a)throw new _(`Graph.${t}: source & target are the same ("${o}"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false.`);let p=e._nodes.get(o),g=e._nodes.get(a);if(!r&&(h=e._edges.get(n))){if((h.source.key!==o||h.target.key!==a)&&(!i||h.source.key!==a||h.target.key!==o))throw new _(`Graph.${t}: inconsistency detected when attempting to merge the "${n}" edge with "${o}" source & "${a}" target vs. ("${h.source.key}", "${h.target.key}").`);c=h}if(c||e.multi||!p||(c=i?p.undirected[a]:p.out[a]),c){let t=[c.key,!1,!1,!1];if(u?!d:!s)return t;if(u){let t=c.attributes;c.attributes=d(t),e.emit("edgeAttributesUpdated",{type:"replace",key:c.key,attributes:c.attributes})}else l(c.attributes,s),e.emit("edgeAttributesUpdated",{type:"merge",key:c.key,attributes:c.attributes,data:s});return t}s=s||{},u&&d&&(s=d(s));let y={key:null,undirected:i,source:o,target:a,attributes:s};if(r)n=e._edgeKeyGenerator();else if(n=""+n,e._edges.has(n))throw new _(`Graph.${t}: the "${n}" edge already exists in the graph.`);let m=!1,b=!1;p||(p=Q(e,o,{}),m=!0,o!==a||(g=p,b=!0)),g||(g=Q(e,a,{}),b=!0),h=new A(i,n,p,g,s),e._edges.set(n,h);let w=o===a;return i?(p.undirectedDegree++,g.undirectedDegree++,w&&(p.undirectedLoops++,e._undirectedSelfLoopCount++)):(p.outDegree++,g.inDegree++,w&&(p.directedLoops++,e._directedSelfLoopCount++)),e.multi?h.attachMulti():h.attach(),i?e._undirectedSize++:e._directedSize++,y.key=n,e.emit("edgeAdded",y),[n,!0,m,b]}function Z(e,t){e._edges.delete(t.key);let{source:r,target:i,attributes:n}=t,o=t.undirected,a=r===i;o?(r.undirectedDegree--,i.undirectedDegree--,a&&(r.undirectedLoops--,e._undirectedSelfLoopCount--)):(r.outDegree--,i.inDegree--,a&&(r.directedLoops--,e._directedSelfLoopCount--)),e.multi?t.detachMulti():t.detach(),o?e._undirectedSize--:e._directedSize--,e.emit("edgeDropped",{key:t.key,attributes:n,source:r.key,target:i.key,undirected:o})}class ee extends o.EventEmitter{constructor(e){if(super(),"boolean"!=typeof(e=l({},X,e)).multi)throw new x(`Graph.constructor: invalid 'multi' option. Expecting a boolean but got "${e.multi}".`);if(!H.has(e.type))throw new x(`Graph.constructor: invalid 'type' option. Should be one of "mixed", "directed" or "undirected" but got "${e.type}".`);if("boolean"!=typeof e.allowSelfLoops)throw new x(`Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got "${e.allowSelfLoops}".`);y(this,"NodeDataClass","mixed"===e.type?E:"directed"===e.type?$:k);let t="geid_"+Y()+"_",r=0;y(this,"_attributes",{}),y(this,"_nodes",new Map),y(this,"_edges",new Map),y(this,"_directedSize",0),y(this,"_undirectedSize",0),y(this,"_directedSelfLoopCount",0),y(this,"_undirectedSelfLoopCount",0),y(this,"_edgeKeyGenerator",()=>{let e;do e=t+r++;while(this._edges.has(e));return e}),y(this,"_options",e),B.forEach(e=>y(this,e,this[e])),m(this,"order",()=>this._nodes.size),m(this,"size",()=>this._edges.size),m(this,"directedSize",()=>this._directedSize),m(this,"undirectedSize",()=>this._undirectedSize),m(this,"selfLoopCount",()=>this._directedSelfLoopCount+this._undirectedSelfLoopCount),m(this,"directedSelfLoopCount",()=>this._directedSelfLoopCount),m(this,"undirectedSelfLoopCount",()=>this._undirectedSelfLoopCount),m(this,"multi",this._options.multi),m(this,"type",this._options.type),m(this,"allowSelfLoops",this._options.allowSelfLoops),m(this,"implementation",()=>"graphology")}_resetInstanceCounters(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0}hasNode(e){return this._nodes.has(""+e)}hasDirectedEdge(e,t){if("undirected"===this.type)return!1;if(1==arguments.length){let t=""+e,r=this._edges.get(t);return!!r&&!r.undirected}if(2==arguments.length){e=""+e,t=""+t;let r=this._nodes.get(e);return!!r&&r.out.hasOwnProperty(t)}throw new x(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasUndirectedEdge(e,t){if("directed"===this.type)return!1;if(1==arguments.length){let t=""+e,r=this._edges.get(t);return!!r&&r.undirected}if(2==arguments.length){e=""+e,t=""+t;let r=this._nodes.get(e);return!!r&&r.undirected.hasOwnProperty(t)}throw new x(`Graph.hasDirectedEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}hasEdge(e,t){if(1==arguments.length){let t=""+e;return this._edges.has(t)}if(2==arguments.length){e=""+e,t=""+t;let r=this._nodes.get(e);return!!r&&(void 0!==r.out&&r.out.hasOwnProperty(t)||void 0!==r.undirected&&r.undirected.hasOwnProperty(t))}throw new x(`Graph.hasEdge: invalid arity (${arguments.length}, instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target.`)}directedEdge(e,t){if("undirected"===this.type)return;if(e=""+e,t=""+t,this.multi)throw new _("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");let r=this._nodes.get(e);if(!r)throw new v(`Graph.directedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new v(`Graph.directedEdge: could not find the "${t}" target node in the graph.`);let i=r.out&&r.out[t]||void 0;if(i)return i.key}undirectedEdge(e,t){if("directed"===this.type)return;if(e=""+e,t=""+t,this.multi)throw new _("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");let r=this._nodes.get(e);if(!r)throw new v(`Graph.undirectedEdge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new v(`Graph.undirectedEdge: could not find the "${t}" target node in the graph.`);let i=r.undirected&&r.undirected[t]||void 0;if(i)return i.key}edge(e,t){if(this.multi)throw new _("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");e=""+e,t=""+t;let r=this._nodes.get(e);if(!r)throw new v(`Graph.edge: could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new v(`Graph.edge: could not find the "${t}" target node in the graph.`);let i=r.out&&r.out[t]||r.undirected&&r.undirected[t]||void 0;if(i)return i.key}areDirectedNeighbors(e,t){e=""+e,t=""+t;let r=this._nodes.get(e);if(!r)throw new v(`Graph.areDirectedNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&(t in r.in||t in r.out)}areOutNeighbors(e,t){e=""+e,t=""+t;let r=this._nodes.get(e);if(!r)throw new v(`Graph.areOutNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in r.out}areInNeighbors(e,t){e=""+e,t=""+t;let r=this._nodes.get(e);if(!r)throw new v(`Graph.areInNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in r.in}areUndirectedNeighbors(e,t){e=""+e,t=""+t;let r=this._nodes.get(e);if(!r)throw new v(`Graph.areUndirectedNeighbors: could not find the "${e}" node in the graph.`);return"directed"!==this.type&&t in r.undirected}areNeighbors(e,t){e=""+e,t=""+t;let r=this._nodes.get(e);if(!r)throw new v(`Graph.areNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&(t in r.in||t in r.out)||"directed"!==this.type&&t in r.undirected}areInboundNeighbors(e,t){e=""+e,t=""+t;let r=this._nodes.get(e);if(!r)throw new v(`Graph.areInboundNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in r.in||"directed"!==this.type&&t in r.undirected}areOutboundNeighbors(e,t){e=""+e,t=""+t;let r=this._nodes.get(e);if(!r)throw new v(`Graph.areOutboundNeighbors: could not find the "${e}" node in the graph.`);return"undirected"!==this.type&&t in r.out||"directed"!==this.type&&t in r.undirected}inDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new v(`Graph.inDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree}outDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new v(`Graph.outDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.outDegree}directedDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new v(`Graph.directedDegree: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree+t.outDegree}undirectedDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new v(`Graph.undirectedDegree: could not find the "${e}" node in the graph.`);return"directed"===this.type?0:t.undirectedDegree}inboundDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new v(`Graph.inboundDegree: could not find the "${e}" node in the graph.`);let r=0;return"directed"!==this.type&&(r+=t.undirectedDegree),"undirected"!==this.type&&(r+=t.inDegree),r}outboundDegree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new v(`Graph.outboundDegree: could not find the "${e}" node in the graph.`);let r=0;return"directed"!==this.type&&(r+=t.undirectedDegree),"undirected"!==this.type&&(r+=t.outDegree),r}degree(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new v(`Graph.degree: could not find the "${e}" node in the graph.`);let r=0;return"directed"!==this.type&&(r+=t.undirectedDegree),"undirected"!==this.type&&(r+=t.inDegree+t.outDegree),r}inDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new v(`Graph.inDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree-t.directedLoops}outDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new v(`Graph.outDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.outDegree-t.directedLoops}directedDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new v(`Graph.directedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"undirected"===this.type?0:t.inDegree+t.outDegree-2*t.directedLoops}undirectedDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new v(`Graph.undirectedDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);return"directed"===this.type?0:t.undirectedDegree-2*t.undirectedLoops}inboundDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new v(`Graph.inboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r=0,i=0;return"directed"!==this.type&&(r+=t.undirectedDegree,i+=2*t.undirectedLoops),"undirected"!==this.type&&(r+=t.inDegree,i+=t.directedLoops),r-i}outboundDegreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new v(`Graph.outboundDegreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r=0,i=0;return"directed"!==this.type&&(r+=t.undirectedDegree,i+=2*t.undirectedLoops),"undirected"!==this.type&&(r+=t.outDegree,i+=t.directedLoops),r-i}degreeWithoutSelfLoops(e){e=""+e;let t=this._nodes.get(e);if(!t)throw new v(`Graph.degreeWithoutSelfLoops: could not find the "${e}" node in the graph.`);let r=0,i=0;return"directed"!==this.type&&(r+=t.undirectedDegree,i+=2*t.undirectedLoops),"undirected"!==this.type&&(r+=t.inDegree+t.outDegree,i+=2*t.directedLoops),r-i}source(e){e=""+e;let t=this._edges.get(e);if(!t)throw new v(`Graph.source: could not find the "${e}" edge in the graph.`);return t.source.key}target(e){e=""+e;let t=this._edges.get(e);if(!t)throw new v(`Graph.target: could not find the "${e}" edge in the graph.`);return t.target.key}extremities(e){e=""+e;let t=this._edges.get(e);if(!t)throw new v(`Graph.extremities: could not find the "${e}" edge in the graph.`);return[t.source.key,t.target.key]}opposite(e,t){e=""+e,t=""+t;let r=this._edges.get(t);if(!r)throw new v(`Graph.opposite: could not find the "${t}" edge in the graph.`);let i=r.source.key,n=r.target.key;if(e===i)return n;if(e===n)return i;throw new v(`Graph.opposite: the "${e}" node is not attached to the "${t}" edge (${i}, ${n}).`)}hasExtremity(e,t){e=""+e,t=""+t;let r=this._edges.get(e);if(!r)throw new v(`Graph.hasExtremity: could not find the "${e}" edge in the graph.`);return r.source.key===t||r.target.key===t}isUndirected(e){e=""+e;let t=this._edges.get(e);if(!t)throw new v(`Graph.isUndirected: could not find the "${e}" edge in the graph.`);return t.undirected}isDirected(e){e=""+e;let t=this._edges.get(e);if(!t)throw new v(`Graph.isDirected: could not find the "${e}" edge in the graph.`);return!t.undirected}isSelfLoop(e){e=""+e;let t=this._edges.get(e);if(!t)throw new v(`Graph.isSelfLoop: could not find the "${e}" edge in the graph.`);return t.source===t.target}addNode(e,t){return function(e,t,r){if(r&&!f(r))throw new x(`Graph.addNode: invalid attributes. Expecting an object but got "${r}"`);if(t=""+t,r=r||{},e._nodes.has(t))throw new _(`Graph.addNode: the "${t}" node already exist in the graph.`);let i=new e.NodeDataClass(t,r);return e._nodes.set(t,i),e.emit("nodeAdded",{key:t,attributes:r}),i}(this,e,t).key}mergeNode(e,t){if(t&&!f(t))throw new x(`Graph.mergeNode: invalid attributes. Expecting an object but got "${t}"`);e=""+e,t=t||{};let r=this._nodes.get(e);return r?(t&&(l(r.attributes,t),this.emit("nodeAttributesUpdated",{type:"merge",key:e,attributes:r.attributes,data:t})),[e,!1]):(r=new this.NodeDataClass(e,t),this._nodes.set(e,r),this.emit("nodeAdded",{key:e,attributes:t}),[e,!0])}updateNode(e,t){if(t&&"function"!=typeof t)throw new x(`Graph.updateNode: invalid updater function. Expecting a function but got "${t}"`);e=""+e;let r=this._nodes.get(e);if(r){if(t){let i=r.attributes;r.attributes=t(i),this.emit("nodeAttributesUpdated",{type:"replace",key:e,attributes:r.attributes})}return[e,!1]}let i=t?t({}):{};return r=new this.NodeDataClass(e,i),this._nodes.set(e,r),this.emit("nodeAdded",{key:e,attributes:i}),[e,!0]}dropNode(e){let t;e=""+e;let r=this._nodes.get(e);if(!r)throw new v(`Graph.dropNode: could not find the "${e}" node in the graph.`);if("undirected"!==this.type){for(let e in r.out){t=r.out[e];do Z(this,t),t=t.next;while(t)}for(let e in r.in){t=r.in[e];do Z(this,t),t=t.next;while(t)}}if("directed"!==this.type)for(let e in r.undirected){t=r.undirected[e];do Z(this,t),t=t.next;while(t)}this._nodes.delete(e),this.emit("nodeDropped",{key:e,attributes:r.attributes})}dropEdge(e){let t;if(arguments.length>1){let e=""+arguments[0],r=""+arguments[1];if(!(t=p(this,e,r,this.type)))throw new v(`Graph.dropEdge: could not find the "${e}" -> "${r}" edge in the graph.`)}else if(e=""+e,!(t=this._edges.get(e)))throw new v(`Graph.dropEdge: could not find the "${e}" edge in the graph.`);return Z(this,t),this}dropDirectedEdge(e,t){if(arguments.length<2)throw new _("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new _("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");let r=p(this,e=""+e,t=""+t,"directed");if(!r)throw new v(`Graph.dropDirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return Z(this,r),this}dropUndirectedEdge(e,t){if(arguments.length<2)throw new _("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new _("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");let r=p(this,e,t,"undirected");if(!r)throw new v(`Graph.dropUndirectedEdge: could not find a "${e}" -> "${t}" edge in the graph.`);return Z(this,r),this}clear(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")}clearEdges(){let e;let t=this._nodes.values();for(;!0!==(e=t.next()).done;)e.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")}getAttribute(e){return this._attributes[e]}getAttributes(){return this._attributes}hasAttribute(e){return this._attributes.hasOwnProperty(e)}setAttribute(e,t){return this._attributes[e]=t,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}updateAttribute(e,t){if("function"!=typeof t)throw new x("Graph.updateAttribute: updater should be a function.");let r=this._attributes[e];return this._attributes[e]=t(r),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this}removeAttribute(e){return delete this._attributes[e],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:e}),this}replaceAttributes(e){if(!f(e))throw new x("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=e,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this}mergeAttributes(e){if(!f(e))throw new x("Graph.mergeAttributes: provided attributes are not a plain object.");return l(this._attributes,e),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:e}),this}updateAttributes(e){if("function"!=typeof e)throw new x("Graph.updateAttributes: provided updater is not a function.");return this._attributes=e(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this}updateEachNodeAttributes(e,t){let r,i;if("function"!=typeof e)throw new x("Graph.updateEachNodeAttributes: expecting an updater function.");if(t&&!b(t))throw new x("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");let n=this._nodes.values();for(;!0!==(r=n.next()).done;)(i=r.value).attributes=e(i.key,i.attributes);this.emit("eachNodeAttributesUpdated",{hints:t||null})}updateEachEdgeAttributes(e,t){let r,i,n,o;if("function"!=typeof e)throw new x("Graph.updateEachEdgeAttributes: expecting an updater function.");if(t&&!b(t))throw new x("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");let a=this._edges.values();for(;!0!==(r=a.next()).done;)n=(i=r.value).source,o=i.target,i.attributes=e(i.key,i.attributes,n.key,o.key,n.attributes,o.attributes,i.undirected);this.emit("eachEdgeAttributesUpdated",{hints:t||null})}forEachAdjacencyEntry(e){if("function"!=typeof e)throw new x("Graph.forEachAdjacencyEntry: expecting a callback.");K(!1,!1,!1,this,e)}forEachAdjacencyEntryWithOrphans(e){if("function"!=typeof e)throw new x("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");K(!1,!1,!0,this,e)}forEachAssymetricAdjacencyEntry(e){if("function"!=typeof e)throw new x("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");K(!1,!0,!1,this,e)}forEachAssymetricAdjacencyEntryWithOrphans(e){if("function"!=typeof e)throw new x("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");K(!1,!0,!0,this,e)}nodes(){return"function"==typeof Array.from?Array.from(this._nodes.keys()):d()(this._nodes.keys(),this._nodes.size)}forEachNode(e){let t,r;if("function"!=typeof e)throw new x("Graph.forEachNode: expecting a callback.");let i=this._nodes.values();for(;!0!==(t=i.next()).done;)e((r=t.value).key,r.attributes)}findNode(e){let t,r;if("function"!=typeof e)throw new x("Graph.findNode: expecting a callback.");let i=this._nodes.values();for(;!0!==(t=i.next()).done;)if(e((r=t.value).key,r.attributes))return r.key}mapNodes(e){let t,r;if("function"!=typeof e)throw new x("Graph.mapNode: expecting a callback.");let i=this._nodes.values(),n=Array(this.order),o=0;for(;!0!==(t=i.next()).done;)r=t.value,n[o++]=e(r.key,r.attributes);return n}someNode(e){let t,r;if("function"!=typeof e)throw new x("Graph.someNode: expecting a callback.");let i=this._nodes.values();for(;!0!==(t=i.next()).done;)if(e((r=t.value).key,r.attributes))return!0;return!1}everyNode(e){let t,r;if("function"!=typeof e)throw new x("Graph.everyNode: expecting a callback.");let i=this._nodes.values();for(;!0!==(t=i.next()).done;)if(!e((r=t.value).key,r.attributes))return!1;return!0}filterNodes(e){let t,r;if("function"!=typeof e)throw new x("Graph.filterNodes: expecting a callback.");let i=this._nodes.values(),n=[];for(;!0!==(t=i.next()).done;)e((r=t.value).key,r.attributes)&&n.push(r.key);return n}reduceNodes(e,t){let r,i;if("function"!=typeof e)throw new x("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new x("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");let n=t,o=this._nodes.values();for(;!0!==(r=o.next()).done;)n=e(n,(i=r.value).key,i.attributes);return n}nodeEntries(){let e=this._nodes.values();return new(s())(()=>{let t=e.next();if(t.done)return t;let r=t.value;return{value:{node:r.key,attributes:r.attributes},done:!1}})}export(){let e=Array(this._nodes.size),t=0;this._nodes.forEach((r,i)=>{e[t++]=function(e,t){let r={key:e};return g(t.attributes)||(r.attributes=l({},t.attributes)),r}(i,r)});let r=Array(this._edges.size);return t=0,this._edges.forEach((e,i)=>{r[t++]=function(e,t,r){let i={key:t,source:r.source.key,target:r.target.key};return g(r.attributes)||(i.attributes=l({},r.attributes)),"mixed"===e&&r.undirected&&(i.undirected=!0),i}(this.type,i,e)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:e,edges:r}}import(e,t=!1){let r,i,n,o,a;if(e instanceof ee)return e.forEachNode((e,r)=>{t?this.mergeNode(e,r):this.addNode(e,r)}),e.forEachEdge((e,r,i,n,o,a,s)=>{t?s?this.mergeUndirectedEdgeWithKey(e,i,n,r):this.mergeDirectedEdgeWithKey(e,i,n,r):s?this.addUndirectedEdgeWithKey(e,i,n,r):this.addDirectedEdgeWithKey(e,i,n,r)}),this;if(!f(e))throw new x("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(e.attributes){if(!f(e.attributes))throw new x("Graph.import: invalid attributes. Expecting a plain object.");t?this.mergeAttributes(e.attributes):this.replaceAttributes(e.attributes)}if(e.nodes){if(!Array.isArray(n=e.nodes))throw new x("Graph.import: invalid nodes. Expecting an array.");for(r=0,i=n.length;r<i;r++){!function(e){if(!f(e))throw new x('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in e))throw new x("Graph.import: serialized node is missing its key.");if("attributes"in e&&(!f(e.attributes)||null===e.attributes))throw new x("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}(o=n[r]);let{key:e,attributes:i}=o;t?this.mergeNode(e,i):this.addNode(e,i)}}if(e.edges){let o=!1;if("undirected"===this.type&&(o=!0),!Array.isArray(n=e.edges))throw new x("Graph.import: invalid edges. Expecting an array.");for(r=0,i=n.length;r<i;r++){!function(e){if(!f(e))throw new x('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in e))throw new x("Graph.import: serialized edge is missing its source.");if(!("target"in e))throw new x("Graph.import: serialized edge is missing its target.");if("attributes"in e&&(!f(e.attributes)||null===e.attributes))throw new x("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in e&&"boolean"!=typeof e.undirected)throw new x("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}(a=n[r]);let{source:e,target:i,attributes:s,undirected:u=o}=a;"key"in a?(t?u?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:u?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey).call(this,a.key,e,i,s):(t?u?this.mergeUndirectedEdge:this.mergeDirectedEdge:u?this.addUndirectedEdge:this.addDirectedEdge).call(this,e,i,s)}}return this}nullCopy(e){let t=new ee(l({},this._options,e));return t.replaceAttributes(l({},this.getAttributes())),t}emptyCopy(e){let t=this.nullCopy(e);return this._nodes.forEach((e,r)=>{let i=l({},e.attributes);e=new t.NodeDataClass(r,i),t._nodes.set(r,e)}),t}copy(e){let t,r;if("string"==typeof(e=e||{}).type&&e.type!==this.type&&"mixed"!==e.type)throw new _(`Graph.copy: cannot create an incompatible copy from "${this.type}" type to "${e.type}" because this would mean losing information about the current graph.`);if("boolean"==typeof e.multi&&e.multi!==this.multi&&!0!==e.multi)throw new _("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if("boolean"==typeof e.allowSelfLoops&&e.allowSelfLoops!==this.allowSelfLoops&&!0!==e.allowSelfLoops)throw new _("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");let i=this.emptyCopy(e),n=this._edges.values();for(;!0!==(t=n.next()).done;)J(i,"copy",!1,(r=t.value).undirected,r.key,r.source.key,r.target.key,l({},r.attributes));return i}toJSON(){return this.export()}toString(){return"[object Graph]"}inspect(){let e={};this._nodes.forEach((t,r)=>{e[r]=t.attributes});let t={},r={};this._edges.forEach((e,i)=>{let n;let o=e.undirected?"--":"->",a="",s=e.source.key,u=e.target.key;e.undirected&&s>u&&(n=s,s=u,u=n);let d=`(${s})${o}(${u})`;i.startsWith("geid_")?this.multi&&(void 0===r[d]?r[d]=0:r[d]++,a+=`${r[d]}. `):a+=`[${i}]: `,t[a+=d]=e.attributes});let i={};for(let e in this)this.hasOwnProperty(e)&&!B.has(e)&&"function"!=typeof this[e]&&"symbol"!=typeof e&&(i[e]=this[e]);return i.attributes=this._attributes,i.nodes=e,i.edges=t,y(i,"constructor",this.constructor),i}}"undefined"!=typeof Symbol&&(ee.prototype[Symbol.for("nodejs.util.inspect.custom")]=ee.prototype.inspect),[{name:e=>`${e}Edge`,generateKey:!0},{name:e=>`${e}DirectedEdge`,generateKey:!0,type:"directed"},{name:e=>`${e}UndirectedEdge`,generateKey:!0,type:"undirected"},{name:e=>`${e}EdgeWithKey`},{name:e=>`${e}DirectedEdgeWithKey`,type:"directed"},{name:e=>`${e}UndirectedEdgeWithKey`,type:"undirected"}].forEach(e=>{["add","merge","update"].forEach(t=>{let r=e.name(t),i="add"===t?J:V;e.generateKey?ee.prototype[r]=function(n,o,a){return i(this,r,!0,"undirected"===(e.type||this.type),null,n,o,a,"update"===t)}:ee.prototype[r]=function(n,o,a,s){return i(this,r,!1,"undirected"===(e.type||this.type),n,o,a,s,"update"===t)}})}),function(e){S.forEach(function({name:t,attacher:r}){r(e,t("Node"),0),r(e,t("Source"),1),r(e,t("Target"),2),r(e,t("Opposite"),3)})}(ee),function(e){P.forEach(function({name:t,attacher:r}){r(e,t("Edge"),"mixed"),r(e,t("DirectedEdge"),"directed"),r(e,t("UndirectedEdge"),"undirected")})}(ee),function(e){j.forEach(t=>{(function(e,t){let{name:r,type:i,direction:n}=t;e.prototype[r]=function(e,t){if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return[];if(!arguments.length)return function(e,t){let r,i;if(0===e.size)return[];if("mixed"===t||t===e.type)return"function"==typeof Array.from?Array.from(e._edges.keys()):d()(e._edges.keys(),e._edges.size);let n=Array("undirected"===t?e.undirectedSize:e.directedSize),o="undirected"===t,a=e._edges.values(),s=0;for(;!0!==(r=a.next()).done;)(i=r.value).undirected===o&&(n[s++]=i.key);return n}(this,i);if(1==arguments.length){e=""+e;let t=this._nodes.get(e);if(void 0===t)throw new v(`Graph.${r}: could not find the "${e}" node in the graph.`);return function(e,t,r,i){let n=[];return M(!1,e,t,r,i,function(e){n.push(e)}),n}(this.multi,"mixed"===i?this.type:i,n,t)}if(2==arguments.length){e=""+e,t=""+t;let o=this._nodes.get(e);if(!o)throw new v(`Graph.${r}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new v(`Graph.${r}:  could not find the "${t}" target node in the graph.`);return function(e,t,r,i,n){let o=[];return T(!1,e,t,r,i,n,function(e){o.push(e)}),o}(i,this.multi,n,o,t)}throw new x(`Graph.${r}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}})(e,t),function(e,t){let{name:r,type:i,direction:n}=t,o="forEach"+r[0].toUpperCase()+r.slice(1,-1);e.prototype[o]=function(e,t,r){if("mixed"===i||"mixed"===this.type||i===this.type){if(1==arguments.length)return C(!1,this,i,r=e);if(2==arguments.length){e=""+e,r=t;let a=this._nodes.get(e);if(void 0===a)throw new v(`Graph.${o}: could not find the "${e}" node in the graph.`);return M(!1,this.multi,"mixed"===i?this.type:i,n,a,r)}if(3==arguments.length){e=""+e,t=""+t;let a=this._nodes.get(e);if(!a)throw new v(`Graph.${o}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new v(`Graph.${o}:  could not find the "${t}" target node in the graph.`);return T(!1,i,this.multi,n,a,t,r)}throw new x(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)}};let a="map"+r[0].toUpperCase()+r.slice(1);e.prototype[a]=function(){let e;let t=Array.prototype.slice.call(arguments),r=t.pop();if(0===t.length){let n=0;"directed"!==i&&(n+=this.undirectedSize),"undirected"!==i&&(n+=this.directedSize),e=Array(n);let o=0;t.push((t,i,n,a,s,u,d)=>{e[o++]=r(t,i,n,a,s,u,d)})}else e=[],t.push((t,i,n,o,a,s,u)=>{e.push(r(t,i,n,o,a,s,u))});return this[o].apply(this,t),e};let s="filter"+r[0].toUpperCase()+r.slice(1);e.prototype[s]=function(){let e=Array.prototype.slice.call(arguments),t=e.pop(),r=[];return e.push((e,i,n,o,a,s,u)=>{t(e,i,n,o,a,s,u)&&r.push(e)}),this[o].apply(this,e),r};let u="reduce"+r[0].toUpperCase()+r.slice(1);e.prototype[u]=function(){let e,t,r=Array.prototype.slice.call(arguments);if(r.length<2||r.length>4)throw new x(`Graph.${u}: invalid number of arguments (expecting 2, 3 or 4 and got ${r.length}).`);if("function"==typeof r[r.length-1]&&"function"!=typeof r[r.length-2])throw new x(`Graph.${u}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);2===r.length?(e=r[0],t=r[1],r=[]):3===r.length?(e=r[1],t=r[2],r=[r[0]]):4===r.length&&(e=r[2],t=r[3],r=[r[0],r[1]]);let i=t;return r.push((t,r,n,o,a,s,u)=>{i=e(i,t,r,n,o,a,s,u)}),this[o].apply(this,r),i}}(e,t),function(e,t){let{name:r,type:i,direction:n}=t,o="find"+r[0].toUpperCase()+r.slice(1,-1);e.prototype[o]=function(e,t,r){if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return!1;if(1==arguments.length)return C(!0,this,i,r=e);if(2==arguments.length){e=""+e,r=t;let a=this._nodes.get(e);if(void 0===a)throw new v(`Graph.${o}: could not find the "${e}" node in the graph.`);return M(!0,this.multi,"mixed"===i?this.type:i,n,a,r)}if(3==arguments.length){e=""+e,t=""+t;let a=this._nodes.get(e);if(!a)throw new v(`Graph.${o}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new v(`Graph.${o}:  could not find the "${t}" target node in the graph.`);return T(!0,i,this.multi,n,a,t,r)}throw new x(`Graph.${o}: too many arguments (expecting 1, 2 or 3 and got ${arguments.length}).`)};let a="some"+r[0].toUpperCase()+r.slice(1,-1);e.prototype[a]=function(){let e=Array.prototype.slice.call(arguments),t=e.pop();return e.push((e,r,i,n,o,a,s)=>t(e,r,i,n,o,a,s)),!!this[o].apply(this,e)};let s="every"+r[0].toUpperCase()+r.slice(1,-1);e.prototype[s]=function(){let e=Array.prototype.slice.call(arguments),t=e.pop();return e.push((e,r,i,n,o,a,s)=>!t(e,r,i,n,o,a,s)),!this[o].apply(this,e)}}(e,t),function(e,t){let{name:r,type:i,direction:n}=t,o=r.slice(0,-1)+"Entries";e.prototype[o]=function(e,t){var r;if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return s().empty();if(!arguments.length)return function(e,t){if(0===e.size)return s().empty();let r="mixed"!==t&&t!==e.type,i="undirected"===t,n=e._edges.values();return new(s())(function(){let e,t;for(;;){if((e=n.next()).done)return e;if(t=e.value,!r||t.undirected===i)break}return{value:{edge:t.key,attributes:t.attributes,source:t.source.key,target:t.target.key,sourceAttributes:t.source.attributes,targetAttributes:t.target.attributes,undirected:t.undirected},done:!1}})}(this,i);if(1==arguments.length){let t;e=""+e;let r=this._nodes.get(e);if(!r)throw new v(`Graph.${o}: could not find the "${e}" node in the graph.`);return t=s().empty(),"undirected"!==i&&("out"!==n&&void 0!==r.in&&(t=c()(t,D(r.in))),"in"!==n&&void 0!==r.out&&(t=c()(t,D(r.out,n?void 0:r.key)))),"directed"!==i&&void 0!==r.undirected&&(t=c()(t,D(r.undirected))),t}if(2==arguments.length){let a;e=""+e,t=""+t;let u=this._nodes.get(e);if(!u)throw new v(`Graph.${o}:  could not find the "${e}" source node in the graph.`);if(!this._nodes.has(t))throw new v(`Graph.${o}:  could not find the "${t}" target node in the graph.`);return r=t,a=s().empty(),"undirected"!==i&&(void 0!==u.in&&"out"!==n&&r in u.in&&(a=c()(a,L(u.in,r))),void 0!==u.out&&"in"!==n&&r in u.out&&(n||u.key!==r)&&(a=c()(a,L(u.out,r)))),"directed"!==i&&void 0!==u.undirected&&r in u.undirected&&(a=c()(a,L(u.undirected,r))),a}throw new x(`Graph.${o}: too many arguments (expecting 0, 1 or 2 and got ${arguments.length}).`)}}(e,t)})}(ee),function(e){z.forEach(t=>{(function(e,t){let{name:r,type:i,direction:n}=t;e.prototype[r]=function(e){if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return[];e=""+e;let t=this._nodes.get(e);if(void 0===t)throw new v(`Graph.${r}: could not find the "${e}" node in the graph.`);return function(e,t,r){if("mixed"!==e){if("undirected"===e)return Object.keys(r.undirected);if("string"==typeof t)return Object.keys(r[t])}let i=[];return q(!1,e,t,r,function(e){i.push(e)}),i}("mixed"===i?this.type:i,n,t)}})(e,t),function(e,t){let{name:r,type:i,direction:n}=t,o="forEach"+r[0].toUpperCase()+r.slice(1,-1);e.prototype[o]=function(e,t){if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return;e=""+e;let r=this._nodes.get(e);if(void 0===r)throw new v(`Graph.${o}: could not find the "${e}" node in the graph.`);q(!1,"mixed"===i?this.type:i,n,r,t)};let a="map"+r[0].toUpperCase()+r.slice(1);e.prototype[a]=function(e,t){let r=[];return this[o](e,(e,i)=>{r.push(t(e,i))}),r};let s="filter"+r[0].toUpperCase()+r.slice(1);e.prototype[s]=function(e,t){let r=[];return this[o](e,(e,i)=>{t(e,i)&&r.push(e)}),r};let u="reduce"+r[0].toUpperCase()+r.slice(1);e.prototype[u]=function(e,t,r){if(arguments.length<3)throw new x(`Graph.${u}: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.`);let i=r;return this[o](e,(e,r)=>{i=t(i,e,r)}),i}}(e,t),function(e,t){let{name:r,type:i,direction:n}=t,o=r[0].toUpperCase()+r.slice(1,-1),a="find"+o;e.prototype[a]=function(e,t){if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return;e=""+e;let r=this._nodes.get(e);if(void 0===r)throw new v(`Graph.${a}: could not find the "${e}" node in the graph.`);return q(!0,"mixed"===i?this.type:i,n,r,t)},e.prototype["some"+o]=function(e,t){return!!this[a](e,t)},e.prototype["every"+o]=function(e,t){return!this[a](e,(e,r)=>!t(e,r))}}(e,t),function(e,t){let{name:r,type:i,direction:n}=t,o=r.slice(0,-1)+"Entries";e.prototype[o]=function(e){if("mixed"!==i&&"mixed"!==this.type&&i!==this.type)return s().empty();e=""+e;let t=this._nodes.get(e);if(void 0===t)throw new v(`Graph.${o}: could not find the "${e}" node in the graph.`);return function(e,t,r){if("mixed"!==e){if("undirected"===e)return F(null,r,r.undirected);if("string"==typeof t)return F(null,r,r[t])}let i=s().empty(),n=new I;return"undirected"!==e&&("out"!==t&&(i=c()(i,F(n,r,r.in))),"in"!==t&&(i=c()(i,F(n,r,r.out)))),"directed"!==e&&(i=c()(i,F(n,r,r.undirected))),i}("mixed"===i?this.type:i,n,t)}}(e,t)})}(ee);class et extends ee{constructor(e){let t=l({type:"directed"},e);if("multi"in t&&!1!==t.multi)throw new x("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("directed"!==t.type)throw new x('DirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class er extends ee{constructor(e){let t=l({type:"undirected"},e);if("multi"in t&&!1!==t.multi)throw new x("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("undirected"!==t.type)throw new x('UndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class ei extends ee{constructor(e){let t=l({multi:!0},e);if("multi"in t&&!0!==t.multi)throw new x("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");super(t)}}class en extends ee{constructor(e){let t=l({type:"directed",multi:!0},e);if("multi"in t&&!0!==t.multi)throw new x("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("directed"!==t.type)throw new x('MultiDirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}class eo extends ee{constructor(e){let t=l({type:"undirected",multi:!0},e);if("multi"in t&&!0!==t.multi)throw new x("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("undirected"!==t.type)throw new x('MultiUndirectedGraph.from: inconsistent "'+t.type+'" type in given options!');super(t)}}function ea(e){e.from=function(t,r){let i=new e(l({},t.options,r));return i.import(t),i}}ea(ee),ea(et),ea(er),ea(ei),ea(en),ea(eo),ee.Graph=ee,ee.DirectedGraph=et,ee.UndirectedGraph=er,ee.MultiGraph=ei,ee.MultiDirectedGraph=en,ee.MultiUndirectedGraph=eo,ee.InvalidArgumentsGraphError=x,ee.NotFoundGraphError=v,ee.UsageGraphError=_;var es=r(1664),eu=r(8958);/**
 * @license lucide-react v0.378.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */let ed=(0,r(2881).Z)("X",[["path",{d:"M18 6 6 18",key:"1bl5f8"}],["path",{d:"m6 6 12 12",key:"d8bk6v"}]]);var eh=r(1223);let ec=eu.fC;eu.xz;let el=eu.h_,ep=eu.x8,ef=n.forwardRef(({className:e,...t},r)=>i.jsx(eu.aV,{ref:r,className:(0,eh.cn)("fixed inset-0 z-50 bg-[#ffb780] bg-opacity-30 backdrop-blur-[1px]  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",e),...t}));ef.displayName=eu.aV.displayName;let eg=n.forwardRef(({className:e,children:t,...r},n)=>(0,i.jsxs)(el,{children:[i.jsx(ef,{}),(0,i.jsxs)(eu.VY,{ref:n,className:(0,eh.cn)("fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4  bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg border border-light-primary",e),...r,children:[t,(0,i.jsxs)(eu.x8,{className:"absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground",children:[i.jsx(ed,{className:"h-4 w-4"}),i.jsx("span",{className:"sr-only",children:"Close"})]})]})]}));eg.displayName=eu.VY.displayName;let ey=({className:e,...t})=>i.jsx("div",{className:(0,eh.cn)("flex flex-col space-y-1.5 text-center sm:text-left",e),...t});ey.displayName="DialogHeader";let em=({className:e,...t})=>i.jsx("div",{className:(0,eh.cn)("flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",e),...t});em.displayName="DialogFooter";let eb=n.forwardRef(({className:e,...t},r)=>i.jsx(eu.Dx,{ref:r,className:(0,eh.cn)("text-lg font-semibold leading-none tracking-tight",e),...t}));eb.displayName=eu.Dx.displayName,n.forwardRef(({className:e,...t},r)=>i.jsx(eu.dk,{ref:r,className:(0,eh.cn)("text-sm text-muted-foreground",e),...t})).displayName=eu.dk.displayName;var ew=r(6226);function ex({open:e,onClose:t}){return(0,i.jsxs)(ec,{open:e,onOpenChange:t,children:[i.jsx(ef,{className:""}),(0,i.jsxs)(eg,{className:"w-fit min-w-[240px] z-50 gap-3 py-8",children:[(0,i.jsxs)(ey,{className:"flex items-center justify-center gap-3",children:[i.jsx(ew.default,{src:"/logo.webp",width:84,height:84,alt:"BuddyLink"}),i.jsx(eb,{className:"font-bold",children:"BuddyLink"})]}),i.jsx("span",{className:"flex items-center justify-center space-x-2 text-light font-normal",children:700..toLocaleString("en-US",{minimumFractionDigits:0,maximumFractionDigits:0})}),i.jsx(em,{className:"flex items-center sm:justify-center w-full",children:i.jsx(ep,{asChild:!0,children:i.jsx(es.z,{type:"button",variant:"primary",className:"px-8",children:"Join"})})})]})]})}var ev=r(2131);let e_=({nodes:e})=>{let[t,r]=(0,n.useState)(!1);return(0,n.useEffect)(()=>{},[e]),(0,i.jsxs)(i.Fragment,{children:[i.jsx(ex,{open:t,onClose:()=>r(!1)}),(0,i.jsxs)("div",{className:"relative rounded-lg overflow-hidden",children:[i.jsx("div",{id:"sigma-container",className:"bg-white rounded-xl",style:{width:"80vw",height:"80vh"}}),(0,i.jsxs)("div",{className:"absolute bottom-4 left-4 flex gap-4 items-center justify-start",children:[(0,i.jsxs)(es.z,{type:"button",variant:"primary",className:"text-white gap-2 px-6 py-4",onClick:()=>r(!0),children:[i.jsx(ev.YJ,{}),"Quests"]}),(0,i.jsxs)(es.z,{type:"button",variant:"primary",className:"text-white gap-2 px-6 py-4",onClick:()=>r(!0),children:[i.jsx(ev.HW,{}),"Teams"]})]})]})]})}},338:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e,t){for(var r in t)Object.defineProperty(e,r,{enumerable:!0,get:t[r]})}(t,{ACTION:function(){return i},FLIGHT_PARAMETERS:function(){return u},NEXT_DID_POSTPONE_HEADER:function(){return h},NEXT_ROUTER_PREFETCH_HEADER:function(){return o},NEXT_ROUTER_STATE_TREE:function(){return n},NEXT_RSC_UNION_QUERY:function(){return d},NEXT_URL:function(){return a},RSC_CONTENT_TYPE_HEADER:function(){return s},RSC_HEADER:function(){return r}});let r="RSC",i="Next-Action",n="Next-Router-State-Tree",o="Next-Router-Prefetch",a="Next-Url",s="text/x-component",u=[[r],[n],[o]],d="_rsc",h="x-nextjs-postponed";("function"==typeof t.default||"object"==typeof t.default&&null!==t.default)&&void 0===t.default.__esModule&&(Object.defineProperty(t.default,"__esModule",{value:!0}),Object.assign(t.default,t),e.exports=t.default)},7255:e=>{(()=>{"use strict";"undefined"!=typeof __nccwpck_require__&&(__nccwpck_require__.ab=__dirname+"/");var t={};(()=>{/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */t.parse=function(t,r){if("string"!=typeof t)throw TypeError("argument str must be a string");for(var n={},o=t.split(i),a=(r||{}).decode||e,s=0;s<o.length;s++){var u=o[s],d=u.indexOf("=");if(!(d<0)){var h=u.substr(0,d).trim(),c=u.substr(++d,u.length).trim();'"'==c[0]&&(c=c.slice(1,-1)),void 0==n[h]&&(n[h]=function(e,t){try{return t(e)}catch(t){return e}}(c,a))}}return n},t.serialize=function(e,t,i){var o=i||{},a=o.encode||r;if("function"!=typeof a)throw TypeError("option encode is invalid");if(!n.test(e))throw TypeError("argument name is invalid");var s=a(t);if(s&&!n.test(s))throw TypeError("argument val is invalid");var u=e+"="+s;if(null!=o.maxAge){var d=o.maxAge-0;if(isNaN(d)||!isFinite(d))throw TypeError("option maxAge is invalid");u+="; Max-Age="+Math.floor(d)}if(o.domain){if(!n.test(o.domain))throw TypeError("option domain is invalid");u+="; Domain="+o.domain}if(o.path){if(!n.test(o.path))throw TypeError("option path is invalid");u+="; Path="+o.path}if(o.expires){if("function"!=typeof o.expires.toUTCString)throw TypeError("option expires is invalid");u+="; Expires="+o.expires.toUTCString()}if(o.httpOnly&&(u+="; HttpOnly"),o.secure&&(u+="; Secure"),o.sameSite)switch("string"==typeof o.sameSite?o.sameSite.toLowerCase():o.sameSite){case!0:case"strict":u+="; SameSite=Strict";break;case"lax":u+="; SameSite=Lax";break;case"none":u+="; SameSite=None";break;default:throw TypeError("option sameSite is invalid")}return u};var e=decodeURIComponent,r=encodeURIComponent,i=/; */,n=/^[\u0009\u0020-\u007e\u0080-\u00ff]+$/})(),e.exports=t})()},1792:(e,t)=>{"use strict";function r(e,t){void 0===t&&(t={});for(var r=function(e){for(var t=[],r=0;r<e.length;){var i=e[r];if("*"===i||"+"===i||"?"===i){t.push({type:"MODIFIER",index:r,value:e[r++]});continue}if("\\"===i){t.push({type:"ESCAPED_CHAR",index:r++,value:e[r++]});continue}if("{"===i){t.push({type:"OPEN",index:r,value:e[r++]});continue}if("}"===i){t.push({type:"CLOSE",index:r,value:e[r++]});continue}if(":"===i){for(var n="",o=r+1;o<e.length;){var a=e.charCodeAt(o);if(a>=48&&a<=57||a>=65&&a<=90||a>=97&&a<=122||95===a){n+=e[o++];continue}break}if(!n)throw TypeError("Missing parameter name at "+r);t.push({type:"NAME",index:r,value:n}),r=o;continue}if("("===i){var s=1,u="",o=r+1;if("?"===e[o])throw TypeError('Pattern cannot start with "?" at '+o);for(;o<e.length;){if("\\"===e[o]){u+=e[o++]+e[o++];continue}if(")"===e[o]){if(0==--s){o++;break}}else if("("===e[o]&&(s++,"?"!==e[o+1]))throw TypeError("Capturing groups are not allowed at "+o);u+=e[o++]}if(s)throw TypeError("Unbalanced pattern at "+r);if(!u)throw TypeError("Missing pattern at "+r);t.push({type:"PATTERN",index:r,value:u}),r=o;continue}t.push({type:"CHAR",index:r,value:e[r++]})}return t.push({type:"END",index:r,value:""}),t}(e),i=t.prefixes,n=void 0===i?"./":i,a="[^"+o(t.delimiter||"/#?")+"]+?",s=[],u=0,d=0,h="",c=function(e){if(d<r.length&&r[d].type===e)return r[d++].value},l=function(e){var t=c(e);if(void 0!==t)return t;var i=r[d];throw TypeError("Unexpected "+i.type+" at "+i.index+", expected "+e)},p=function(){for(var e,t="";e=c("CHAR")||c("ESCAPED_CHAR");)t+=e;return t};d<r.length;){var f=c("CHAR"),g=c("NAME"),y=c("PATTERN");if(g||y){var m=f||"";-1===n.indexOf(m)&&(h+=m,m=""),h&&(s.push(h),h=""),s.push({name:g||u++,prefix:m,suffix:"",pattern:y||a,modifier:c("MODIFIER")||""});continue}var b=f||c("ESCAPED_CHAR");if(b){h+=b;continue}if(h&&(s.push(h),h=""),c("OPEN")){var m=p(),w=c("NAME")||"",x=c("PATTERN")||"",v=p();l("CLOSE"),s.push({name:w||(x?u++:""),pattern:w&&!x?a:x,prefix:m,suffix:v,modifier:c("MODIFIER")||""});continue}l("END")}return s}function i(e,t){void 0===t&&(t={});var r=a(t),i=t.encode,n=void 0===i?function(e){return e}:i,o=t.validate,s=void 0===o||o,u=e.map(function(e){if("object"==typeof e)return RegExp("^(?:"+e.pattern+")$",r)});return function(t){for(var r="",i=0;i<e.length;i++){var o=e[i];if("string"==typeof o){r+=o;continue}var a=t?t[o.name]:void 0,d="?"===o.modifier||"*"===o.modifier,h="*"===o.modifier||"+"===o.modifier;if(Array.isArray(a)){if(!h)throw TypeError('Expected "'+o.name+'" to not repeat, but got an array');if(0===a.length){if(d)continue;throw TypeError('Expected "'+o.name+'" to not be empty')}for(var c=0;c<a.length;c++){var l=n(a[c],o);if(s&&!u[i].test(l))throw TypeError('Expected all "'+o.name+'" to match "'+o.pattern+'", but got "'+l+'"');r+=o.prefix+l+o.suffix}continue}if("string"==typeof a||"number"==typeof a){var l=n(String(a),o);if(s&&!u[i].test(l))throw TypeError('Expected "'+o.name+'" to match "'+o.pattern+'", but got "'+l+'"');r+=o.prefix+l+o.suffix;continue}if(!d){var p=h?"an array":"a string";throw TypeError('Expected "'+o.name+'" to be '+p)}}return r}}function n(e,t,r){void 0===r&&(r={});var i=r.decode,n=void 0===i?function(e){return e}:i;return function(r){var i=e.exec(r);if(!i)return!1;for(var o=i[0],a=i.index,s=Object.create(null),u=1;u<i.length;u++)!function(e){if(void 0!==i[e]){var r=t[e-1];"*"===r.modifier||"+"===r.modifier?s[r.name]=i[e].split(r.prefix+r.suffix).map(function(e){return n(e,r)}):s[r.name]=n(i[e],r)}}(u);return{path:o,index:a,params:s}}}function o(e){return e.replace(/([.+*?=^!:${}()[\]|/\\])/g,"\\$1")}function a(e){return e&&e.sensitive?"":"i"}function s(e,t,r){void 0===r&&(r={});for(var i=r.strict,n=void 0!==i&&i,s=r.start,u=r.end,d=r.encode,h=void 0===d?function(e){return e}:d,c="["+o(r.endsWith||"")+"]|$",l="["+o(r.delimiter||"/#?")+"]",p=void 0===s||s?"^":"",f=0;f<e.length;f++){var g=e[f];if("string"==typeof g)p+=o(h(g));else{var y=o(h(g.prefix)),m=o(h(g.suffix));if(g.pattern){if(t&&t.push(g),y||m){if("+"===g.modifier||"*"===g.modifier){var b="*"===g.modifier?"?":"";p+="(?:"+y+"((?:"+g.pattern+")(?:"+m+y+"(?:"+g.pattern+"))*)"+m+")"+b}else p+="(?:"+y+"("+g.pattern+")"+m+")"+g.modifier}else p+="("+g.pattern+")"+g.modifier}else p+="(?:"+y+m+")"+g.modifier}}if(void 0===u||u)n||(p+=l+"?"),p+=r.endsWith?"(?="+c+")":"$";else{var w=e[e.length-1],x="string"==typeof w?l.indexOf(w[w.length-1])>-1:void 0===w;n||(p+="(?:"+l+"(?="+c+"))?"),x||(p+="(?="+l+"|"+c+")")}return new RegExp(p,a(r))}function u(e,t,i){return e instanceof RegExp?function(e,t){if(!t)return e;var r=e.source.match(/\((?!\?)/g);if(r)for(var i=0;i<r.length;i++)t.push({name:i,prefix:"",suffix:"",modifier:"",pattern:""});return e}(e,t):Array.isArray(e)?RegExp("(?:"+e.map(function(e){return u(e,t,i).source}).join("|")+")",a(i)):s(r(e,i),t,i)}Object.defineProperty(t,"__esModule",{value:!0}),t.parse=r,t.compile=function(e,t){return i(r(e,t),t)},t.tokensToFunction=i,t.match=function(e,t){var r=[];return n(u(e,r,t),r,t)},t.regexpToFunction=n,t.tokensToRegexp=s,t.pathToRegexp=u},6621:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e,t){for(var r in t)Object.defineProperty(e,r,{enumerable:!0,get:t[r]})}(t,{fillMetadataSegment:function(){return c},normalizeMetadataRoute:function(){return l}});let i=r(616),n=function(e){return e&&e.__esModule?e:{default:e}}(r(1293)),o=r(7262),a=r(5679),s=r(8785),u=r(8168),d=r(1040);function h(e){let t="";return(e.includes("(")&&e.includes(")")||e.includes("@"))&&(t=(0,s.djb2Hash)(e).toString(36).slice(0,6)),t}function c(e,t,r){let i=(0,u.normalizeAppPath)(e),s=(0,a.getNamedRouteRegex)(i,!1),c=(0,o.interpolateDynamicPath)(i,t,s),l=h(e),p=l?`-${l}`:"",{name:f,ext:g}=n.default.parse(r);return(0,d.normalizePathSep)(n.default.join(c,`${f}${p}${g}`))}function l(e){if(!(0,i.isMetadataRoute)(e))return e;let t=e,r="";if("/robots"===e?t+=".txt":"/manifest"===e?t+=".webmanifest":e.endsWith("/sitemap")?t+=".xml":r=h(e.slice(0,-(n.default.basename(e).length+1))),!t.endsWith("/route")){let{dir:o,name:a,ext:s}=n.default.parse(t),u=(0,i.isStaticMetadataRoute)(e);t=n.default.posix.join(o,`${a}${r?`-${r}`:""}${s}`,u?"":"[[...__metadata_id__]]","route")}return t}},616:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e,t){for(var r in t)Object.defineProperty(e,r,{enumerable:!0,get:t[r]})}(t,{STATIC_METADATA_IMAGES:function(){return n},isMetadataRoute:function(){return h},isMetadataRouteFile:function(){return s},isStaticMetadataRoute:function(){return d},isStaticMetadataRouteFile:function(){return u}});let i=r(1040),n={icon:{filename:"icon",extensions:["ico","jpg","jpeg","png","svg"]},apple:{filename:"apple-icon",extensions:["jpg","jpeg","png"]},favicon:{filename:"favicon",extensions:["ico"]},openGraph:{filename:"opengraph-image",extensions:["jpg","jpeg","png","gif"]},twitter:{filename:"twitter-image",extensions:["jpg","jpeg","png","gif"]}},o=["js","jsx","ts","tsx"],a=e=>`(?:${e.join("|")})`;function s(e,t,r){let o=[RegExp(`^[\\\\/]robots${r?`\\.${a(t.concat("txt"))}$`:""}`),RegExp(`^[\\\\/]manifest${r?`\\.${a(t.concat("webmanifest","json"))}$`:""}`),RegExp("^[\\\\/]favicon\\.ico$"),RegExp(`[\\\\/]sitemap${r?`\\.${a(t.concat("xml"))}$`:""}`),RegExp(`[\\\\/]${n.icon.filename}\\d?${r?`\\.${a(t.concat(n.icon.extensions))}$`:""}`),RegExp(`[\\\\/]${n.apple.filename}\\d?${r?`\\.${a(t.concat(n.apple.extensions))}$`:""}`),RegExp(`[\\\\/]${n.openGraph.filename}\\d?${r?`\\.${a(t.concat(n.openGraph.extensions))}$`:""}`),RegExp(`[\\\\/]${n.twitter.filename}\\d?${r?`\\.${a(t.concat(n.twitter.extensions))}$`:""}`)],s=(0,i.normalizePathSep)(e);return o.some(e=>e.test(s))}function u(e){return s(e,[],!0)}function d(e){return"/robots"===e||"/manifest"===e||u(e)}function h(e){let t=e.replace(/^\/?app\//,"").replace(/\/route$/,"");return"/"!==t[0]&&(t="/"+t),!t.endsWith("/page")&&s(t,o,!1)}},6975:(e,t,r)=>{"use strict";function i(e){return function(){let{cookie:t}=e;if(!t)return{};let{parse:i}=r(7255);return i(Array.isArray(t)?t.join("; "):t)}}Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"getCookieParser",{enumerable:!0,get:function(){return i}})},1586:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e,t){for(var r in t)Object.defineProperty(e,r,{enumerable:!0,get:t[r]})}(t,{INTERCEPTION_ROUTE_MARKERS:function(){return n},extractInterceptionRouteInformation:function(){return a},isInterceptionRouteAppPath:function(){return o}});let i=r(8168),n=["(..)(..)","(.)","(..)","(...)"];function o(e){return void 0!==e.split("/").find(e=>n.find(t=>e.startsWith(t)))}function a(e){let t,r,o;for(let i of e.split("/"))if(r=n.find(e=>i.startsWith(e))){[t,o]=e.split(r,2);break}if(!t||!r||!o)throw Error(`Invalid interception route: ${e}. Must be in the format /<intercepting route>/(..|...|..)(..)/<intercepted route>`);switch(t=(0,i.normalizeAppPath)(t),r){case"(.)":o="/"===t?`/${o}`:t+"/"+o;break;case"(..)":if("/"===t)throw Error(`Invalid interception route: ${e}. Cannot use (..) marker at the root level, use (.) instead.`);o=t.split("/").slice(0,-1).concat(o).join("/");break;case"(...)":o="/"+o;break;case"(..)(..)":let a=t.split("/");if(a.length<=2)throw Error(`Invalid interception route: ${e}. Cannot use (..)(..) marker at the root level or one level up.`);o=a.slice(0,-2).concat(o).join("/");break;default:throw Error("Invariant: unexpected marker")}return{interceptingRoute:t,interceptedRoute:o}}},7262:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e,t){for(var r in t)Object.defineProperty(e,r,{enumerable:!0,get:t[r]})}(t,{getUtils:function(){return g},interpolateDynamicPath:function(){return p},normalizeDynamicRouteParams:function(){return f},normalizeVercelUrl:function(){return l}});let i=r(7310),n=r(5014),o=r(3707),a=r(5679),s=r(3525),u=r(5257),d=r(7847),h=r(8168),c=r(1943);function l(e,t,r,n,o){if(n&&t&&o){let t=(0,i.parse)(e.url,!0);for(let e of(delete t.search,Object.keys(t.query)))(e!==c.NEXT_QUERY_PARAM_PREFIX&&e.startsWith(c.NEXT_QUERY_PARAM_PREFIX)||(r||Object.keys(o.groups)).includes(e))&&delete t.query[e];e.url=(0,i.format)(t)}}function p(e,t,r){if(!r)return e;for(let i of Object.keys(r.groups)){let{optional:n,repeat:o}=r.groups[i],a=`[${o?"...":""}${i}]`;n&&(a=`[${a}]`);let s=e.indexOf(a);if(s>-1){let r;let n=t[i];r=Array.isArray(n)?n.map(e=>e&&encodeURIComponent(e)).join("/"):n?encodeURIComponent(n):"",e=e.slice(0,s)+r+e.slice(s+a.length)}}return e}function f(e,t,r,i){let n=!0;return r?{params:e=Object.keys(r.groups).reduce((o,a)=>{let s=e[a];"string"==typeof s&&(s=(0,h.normalizeRscURL)(s)),Array.isArray(s)&&(s=s.map(e=>("string"==typeof e&&(e=(0,h.normalizeRscURL)(e)),e)));let u=i[a],d=r.groups[a].optional;return((Array.isArray(u)?u.some(e=>Array.isArray(s)?s.some(t=>t.includes(e)):null==s?void 0:s.includes(e)):null==s?void 0:s.includes(u))||void 0===s&&!(d&&t))&&(n=!1),d&&(!s||Array.isArray(s)&&1===s.length&&("index"===s[0]||s[0]===`[[...${a}]]`))&&(s=void 0,delete e[a]),s&&"string"==typeof s&&r.groups[a].repeat&&(s=s.split("/")),s&&(o[a]=s),o},{}),hasValidParams:n}:{params:e,hasValidParams:!1}}function g({page:e,i18n:t,basePath:r,rewrites:i,pageIsDynamic:h,trailingSlash:g,caseSensitive:y}){let m,b,w;return h&&(m=(0,a.getNamedRouteRegex)(e,!1),w=(b=(0,s.getRouteMatcher)(m))(e)),{handleRewrites:function(a,s){let c={},l=s.pathname,p=i=>{let d=(0,o.getPathMatch)(i.source+(g?"(/)?":""),{removeUnnamedParams:!0,strict:!0,sensitive:!!y})(s.pathname);if((i.has||i.missing)&&d){let e=(0,u.matchHas)(a,s.query,i.has,i.missing);e?Object.assign(d,e):d=!1}if(d){let{parsedDestination:o,destQuery:a}=(0,u.prepareDestination)({appendParamsToQuery:!0,destination:i.destination,params:d,query:s.query});if(o.protocol)return!0;if(Object.assign(c,a,d),Object.assign(s.query,o.query),delete o.query,Object.assign(s,o),l=s.pathname,r&&(l=l.replace(RegExp(`^${r}`),"")||"/"),t){let e=(0,n.normalizeLocalePath)(l,t.locales);l=e.pathname,s.query.nextInternalLocale=e.detectedLocale||d.nextInternalLocale}if(l===e)return!0;if(h&&b){let e=b(l);if(e)return s.query={...s.query,...e},!0}}return!1};for(let e of i.beforeFiles||[])p(e);if(l!==e){let t=!1;for(let e of i.afterFiles||[])if(t=p(e))break;if(!t&&!(()=>{let t=(0,d.removeTrailingSlash)(l||"");return t===(0,d.removeTrailingSlash)(e)||(null==b?void 0:b(t))})()){for(let e of i.fallback||[])if(t=p(e))break}}return c},defaultRouteRegex:m,dynamicRouteMatcher:b,defaultRouteMatches:w,getParamsFromRouteMatches:function(e,r,i){return(0,s.getRouteMatcher)(function(){let{groups:e,routeKeys:n}=m;return{re:{exec:o=>{let a=Object.fromEntries(new URLSearchParams(o)),s=t&&i&&a["1"]===i;for(let e of Object.keys(a)){let t=a[e];e!==c.NEXT_QUERY_PARAM_PREFIX&&e.startsWith(c.NEXT_QUERY_PARAM_PREFIX)&&(a[e.substring(c.NEXT_QUERY_PARAM_PREFIX.length)]=t,delete a[e])}let u=Object.keys(n||{}),d=e=>{if(t){let n=Array.isArray(e),o=n?e[0]:e;if("string"==typeof o&&t.locales.some(e=>e.toLowerCase()===o.toLowerCase()&&(i=e,r.locale=i,!0)))return n&&e.splice(0,1),!n||0===e.length}return!1};return u.every(e=>a[e])?u.reduce((t,r)=>{let i=null==n?void 0:n[r];return i&&!d(a[r])&&(t[e[i].pos]=a[r]),t},{}):Object.keys(a).reduce((e,t)=>{if(!d(a[t])){let r=t;return s&&(r=parseInt(t,10)-1+""),Object.assign(e,{[r]:a[t]})}return e},{})}},groups:e}}())(e.headers["x-now-route-matches"])},normalizeDynamicRouteParams:(e,t)=>f(e,t,m,w),normalizeVercelUrl:(e,t,r)=>l(e,t,r,h,m),interpolateDynamicPath:(e,t)=>p(e,t,m)}}},4080:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"escapeStringRegexp",{enumerable:!0,get:function(){return n}});let r=/[|\\{}()[\]^$+*?.-]/,i=/[|\\{}()[\]^$+*?.-]/g;function n(e){return r.test(e)?e.replace(i,"\\$&"):e}},8785:(e,t)=>{"use strict";function r(e){let t=5381;for(let r=0;r<e.length;r++)t=(t<<5)+t+e.charCodeAt(r)&4294967295;return t>>>0}function i(e){return r(e).toString(36).slice(0,5)}Object.defineProperty(t,"__esModule",{value:!0}),function(e,t){for(var r in t)Object.defineProperty(e,r,{enumerable:!0,get:t[r]})}(t,{djb2Hash:function(){return r},hexHash:function(){return i}})},5014:(e,t)=>{"use strict";function r(e,t){let r;let i=e.split("/");return(t||[]).some(t=>!!i[1]&&i[1].toLowerCase()===t.toLowerCase()&&(r=t,i.splice(1,1),e=i.join("/")||"/",!0)),{pathname:e,detectedLocale:r}}Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"normalizeLocalePath",{enumerable:!0,get:function(){return r}})},1293:(e,t,r)=>{"use strict";let i;i=r(1017),e.exports=i},1555:(e,t)=>{"use strict";function r(e){return e.startsWith("/")?e:"/"+e}Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"ensureLeadingSlash",{enumerable:!0,get:function(){return r}})},1040:(e,t)=>{"use strict";function r(e){return e.replace(/\\/g,"/")}Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"normalizePathSep",{enumerable:!0,get:function(){return r}})},8168:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e,t){for(var r in t)Object.defineProperty(e,r,{enumerable:!0,get:t[r]})}(t,{normalizeAppPath:function(){return o},normalizeRscURL:function(){return a}});let i=r(1555),n=r(5406);function o(e){return(0,i.ensureLeadingSlash)(e.split("/").reduce((e,t,r,i)=>!t||(0,n.isGroupSegment)(t)||"@"===t[0]||("page"===t||"route"===t)&&r===i.length-1?e:e+"/"+t,""))}function a(e){return e.replace(/\.rsc($|\?)/,"$1")}},1942:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"parseRelativeUrl",{enumerable:!0,get:function(){return n}}),r(2569);let i=r(4869);function n(e,t){let r=new URL("http://n"),n=t?new URL(t,r):e.startsWith(".")?new URL("http://n"):r,{pathname:o,searchParams:a,search:s,hash:u,href:d,origin:h}=new URL(e,n);if(h!==r.origin)throw Error("invariant: invalid relative URL, router received "+e);return{pathname:o,query:(0,i.searchParamsToUrlQuery)(a),search:s,hash:u,href:d.slice(r.origin.length)}}},3226:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"parseUrl",{enumerable:!0,get:function(){return o}});let i=r(4869),n=r(1942);function o(e){if(e.startsWith("/"))return(0,n.parseRelativeUrl)(e);let t=new URL(e);return{hash:t.hash,hostname:t.hostname,href:t.href,pathname:t.pathname,port:t.port,protocol:t.protocol,query:(0,i.searchParamsToUrlQuery)(t.searchParams),search:t.search}}},3707:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"getPathMatch",{enumerable:!0,get:function(){return n}});let i=r(1792);function n(e,t){let r=[],n=(0,i.pathToRegexp)(e,r,{delimiter:"/",sensitive:"boolean"==typeof(null==t?void 0:t.sensitive)&&t.sensitive,strict:null==t?void 0:t.strict}),o=(0,i.regexpToFunction)((null==t?void 0:t.regexModifier)?new RegExp(t.regexModifier(n.source),n.flags):n,r);return(e,i)=>{if("string"!=typeof e)return!1;let n=o(e);if(!n)return!1;if(null==t?void 0:t.removeUnnamedParams)for(let e of r)"number"==typeof e.name&&delete n.params[e.name];return{...i,...n.params}}}},5257:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e,t){for(var r in t)Object.defineProperty(e,r,{enumerable:!0,get:t[r]})}(t,{compileNonPath:function(){return c},matchHas:function(){return h},prepareDestination:function(){return l}});let i=r(1792),n=r(4080),o=r(3226),a=r(1586),s=r(338),u=r(6975);function d(e){return e.replace(/__ESC_COLON_/gi,":")}function h(e,t,r,i){void 0===r&&(r=[]),void 0===i&&(i=[]);let n={},o=r=>{let i;let o=r.key;switch(r.type){case"header":o=o.toLowerCase(),i=e.headers[o];break;case"cookie":i="cookies"in e?e.cookies[r.key]:(0,u.getCookieParser)(e.headers)()[r.key];break;case"query":i=t[o];break;case"host":{let{host:t}=(null==e?void 0:e.headers)||{};i=null==t?void 0:t.split(":",1)[0].toLowerCase()}}if(!r.value&&i)return n[function(e){let t="";for(let r=0;r<e.length;r++){let i=e.charCodeAt(r);(i>64&&i<91||i>96&&i<123)&&(t+=e[r])}return t}(o)]=i,!0;if(i){let e=RegExp("^"+r.value+"$"),t=Array.isArray(i)?i.slice(-1)[0].match(e):i.match(e);if(t)return Array.isArray(t)&&(t.groups?Object.keys(t.groups).forEach(e=>{n[e]=t.groups[e]}):"host"===r.type&&t[0]&&(n.host=t[0])),!0}return!1};return!!r.every(e=>o(e))&&!i.some(e=>o(e))&&n}function c(e,t){if(!e.includes(":"))return e;for(let r of Object.keys(t))e.includes(":"+r)&&(e=e.replace(RegExp(":"+r+"\\*","g"),":"+r+"--ESCAPED_PARAM_ASTERISKS").replace(RegExp(":"+r+"\\?","g"),":"+r+"--ESCAPED_PARAM_QUESTION").replace(RegExp(":"+r+"\\+","g"),":"+r+"--ESCAPED_PARAM_PLUS").replace(RegExp(":"+r+"(?!\\w)","g"),"--ESCAPED_PARAM_COLON"+r));return e=e.replace(/(:|\*|\?|\+|\(|\)|\{|\})/g,"\\$1").replace(/--ESCAPED_PARAM_PLUS/g,"+").replace(/--ESCAPED_PARAM_COLON/g,":").replace(/--ESCAPED_PARAM_QUESTION/g,"?").replace(/--ESCAPED_PARAM_ASTERISKS/g,"*"),(0,i.compile)("/"+e,{validate:!1})(t).slice(1)}function l(e){let t;let r=Object.assign({},e.query);delete r.__nextLocale,delete r.__nextDefaultLocale,delete r.__nextDataReq,delete r.__nextInferredLocaleFromDefault,delete r[s.NEXT_RSC_UNION_QUERY];let u=e.destination;for(let t of Object.keys({...e.params,...r}))u=u.replace(RegExp(":"+(0,n.escapeStringRegexp)(t),"g"),"__ESC_COLON_"+t);let h=(0,o.parseUrl)(u),l=h.query,p=d(""+h.pathname+(h.hash||"")),f=d(h.hostname||""),g=[],y=[];(0,i.pathToRegexp)(p,g),(0,i.pathToRegexp)(f,y);let m=[];g.forEach(e=>m.push(e.name)),y.forEach(e=>m.push(e.name));let b=(0,i.compile)(p,{validate:!1}),w=(0,i.compile)(f,{validate:!1});for(let[t,r]of Object.entries(l))Array.isArray(r)?l[t]=r.map(t=>c(d(t),e.params)):"string"==typeof r&&(l[t]=c(d(r),e.params));let x=Object.keys(e.params).filter(e=>"nextInternalLocale"!==e);if(e.appendParamsToQuery&&!x.some(e=>m.includes(e)))for(let t of x)t in l||(l[t]=e.params[t]);if((0,a.isInterceptionRouteAppPath)(p))for(let t of p.split("/")){let r=a.INTERCEPTION_ROUTE_MARKERS.find(e=>t.startsWith(e));if(r){e.params["0"]=r;break}}try{let[r,i]=(t=b(e.params)).split("#",2);h.hostname=w(e.params),h.pathname=r,h.hash=(i?"#":"")+(i||""),delete h.search}catch(e){if(e.message.match(/Expected .*? to not repeat, but got an array/))throw Error("To use a multi-match in the destination you must add `*` at the end of the param name to signify it should repeat. https://nextjs.org/docs/messages/invalid-multi-match");throw e}return h.query={...r,...h.query},{newUrl:t,destQuery:l,parsedDestination:h}}},4869:(e,t)=>{"use strict";function r(e){let t={};return e.forEach((e,r)=>{void 0===t[r]?t[r]=e:Array.isArray(t[r])?t[r].push(e):t[r]=[t[r],e]}),t}function i(e){return"string"!=typeof e&&("number"!=typeof e||isNaN(e))&&"boolean"!=typeof e?"":String(e)}function n(e){let t=new URLSearchParams;return Object.entries(e).forEach(e=>{let[r,n]=e;Array.isArray(n)?n.forEach(e=>t.append(r,i(e))):t.set(r,i(n))}),t}function o(e){for(var t=arguments.length,r=Array(t>1?t-1:0),i=1;i<t;i++)r[i-1]=arguments[i];return r.forEach(t=>{Array.from(t.keys()).forEach(t=>e.delete(t)),t.forEach((t,r)=>e.append(r,t))}),e}Object.defineProperty(t,"__esModule",{value:!0}),function(e,t){for(var r in t)Object.defineProperty(e,r,{enumerable:!0,get:t[r]})}(t,{assign:function(){return o},searchParamsToUrlQuery:function(){return r},urlQueryToSearchParams:function(){return n}})},7847:(e,t)=>{"use strict";function r(e){return e.replace(/\/$/,"")||"/"}Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"removeTrailingSlash",{enumerable:!0,get:function(){return r}})},3525:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"getRouteMatcher",{enumerable:!0,get:function(){return n}});let i=r(2569);function n(e){let{re:t,groups:r}=e;return e=>{let n=t.exec(e);if(!n)return!1;let o=e=>{try{return decodeURIComponent(e)}catch(e){throw new i.DecodeError("failed to decode param")}},a={};return Object.keys(r).forEach(e=>{let t=r[e],i=n[t.pos];void 0!==i&&(a[e]=~i.indexOf("/")?i.split("/").map(e=>o(e)):t.repeat?[o(i)]:o(i))}),a}}},5679:(e,t,r)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e,t){for(var r in t)Object.defineProperty(e,r,{enumerable:!0,get:t[r]})}(t,{getNamedMiddlewareRegex:function(){return l},getNamedRouteRegex:function(){return c},getRouteRegex:function(){return u}});let i=r(1586),n=r(4080),o=r(7847);function a(e){let t=e.startsWith("[")&&e.endsWith("]");t&&(e=e.slice(1,-1));let r=e.startsWith("...");return r&&(e=e.slice(3)),{key:e,repeat:r,optional:t}}function s(e){let t=(0,o.removeTrailingSlash)(e).slice(1).split("/"),r={},s=1;return{parameterizedRoute:t.map(e=>{let t=i.INTERCEPTION_ROUTE_MARKERS.find(t=>e.startsWith(t)),o=e.match(/\[((?:\[.*\])|.+)\]/);if(t&&o){let{key:e,optional:i,repeat:u}=a(o[1]);return r[e]={pos:s++,repeat:u,optional:i},"/"+(0,n.escapeStringRegexp)(t)+"([^/]+?)"}if(!o)return"/"+(0,n.escapeStringRegexp)(e);{let{key:e,repeat:t,optional:i}=a(o[1]);return r[e]={pos:s++,repeat:t,optional:i},t?i?"(?:/(.+?))?":"/(.+?)":"/([^/]+?)"}}).join(""),groups:r}}function u(e){let{parameterizedRoute:t,groups:r}=s(e);return{re:RegExp("^"+t+"(?:/)?$"),groups:r}}function d(e){let{interceptionMarker:t,getSafeRouteKey:r,segment:i,routeKeys:o,keyPrefix:s}=e,{key:u,optional:d,repeat:h}=a(i),c=u.replace(/\W/g,"");s&&(c=""+s+c);let l=!1;(0===c.length||c.length>30)&&(l=!0),isNaN(parseInt(c.slice(0,1)))||(l=!0),l&&(c=r()),s?o[c]=""+s+u:o[c]=u;let p=t?(0,n.escapeStringRegexp)(t):"";return h?d?"(?:/"+p+"(?<"+c+">.+?))?":"/"+p+"(?<"+c+">.+?)":"/"+p+"(?<"+c+">[^/]+?)"}function h(e,t){let r;let a=(0,o.removeTrailingSlash)(e).slice(1).split("/"),s=(r=0,()=>{let e="",t=++r;for(;t>0;)e+=String.fromCharCode(97+(t-1)%26),t=Math.floor((t-1)/26);return e}),u={};return{namedParameterizedRoute:a.map(e=>{let r=i.INTERCEPTION_ROUTE_MARKERS.some(t=>e.startsWith(t)),o=e.match(/\[((?:\[.*\])|.+)\]/);if(r&&o){let[r]=e.split(o[0]);return d({getSafeRouteKey:s,interceptionMarker:r,segment:o[1],routeKeys:u,keyPrefix:t?"nxtI":void 0})}return o?d({getSafeRouteKey:s,segment:o[1],routeKeys:u,keyPrefix:t?"nxtP":void 0}):"/"+(0,n.escapeStringRegexp)(e)}).join(""),routeKeys:u}}function c(e,t){let r=h(e,t);return{...u(e),namedRegex:"^"+r.namedParameterizedRoute+"(?:/)?$",routeKeys:r.routeKeys}}function l(e,t){let{parameterizedRoute:r}=s(e),{catchAll:i=!0}=t;if("/"===r)return{namedRegex:"^/"+(i?".*":"")+"$"};let{namedParameterizedRoute:n}=h(e,!1);return{namedRegex:"^"+n+(i?"(?:(/.*)?)":"")+"$"}}},5406:(e,t)=>{"use strict";function r(e){return"("===e[0]&&e.endsWith(")")}Object.defineProperty(t,"__esModule",{value:!0}),function(e,t){for(var r in t)Object.defineProperty(e,r,{enumerable:!0,get:t[r]})}(t,{DEFAULT_SEGMENT_KEY:function(){return n},PAGE_SEGMENT_KEY:function(){return i},isGroupSegment:function(){return r}});let i="__PAGE__",n="__DEFAULT__"},2569:(e,t)=>{"use strict";Object.defineProperty(t,"__esModule",{value:!0}),function(e,t){for(var r in t)Object.defineProperty(e,r,{enumerable:!0,get:t[r]})}(t,{DecodeError:function(){return f},MiddlewareNotFoundError:function(){return b},MissingStaticPage:function(){return m},NormalizeError:function(){return g},PageNotFoundError:function(){return y},SP:function(){return l},ST:function(){return p},WEB_VITALS:function(){return r},execOnce:function(){return i},getDisplayName:function(){return u},getLocationOrigin:function(){return a},getURL:function(){return s},isAbsoluteUrl:function(){return o},isResSent:function(){return d},loadGetInitialProps:function(){return c},normalizeRepeatedSlashes:function(){return h},stringifyError:function(){return w}});let r=["CLS","FCP","FID","INP","LCP","TTFB"];function i(e){let t,r=!1;return function(){for(var i=arguments.length,n=Array(i),o=0;o<i;o++)n[o]=arguments[o];return r||(r=!0,t=e(...n)),t}}let n=/^[a-zA-Z][a-zA-Z\d+\-.]*?:/,o=e=>n.test(e);function a(){let{protocol:e,hostname:t,port:r}=window.location;return e+"//"+t+(r?":"+r:"")}function s(){let{href:e}=window.location,t=a();return e.substring(t.length)}function u(e){return"string"==typeof e?e:e.displayName||e.name||"Unknown"}function d(e){return e.finished||e.headersSent}function h(e){let t=e.split("?");return t[0].replace(/\\/g,"/").replace(/\/\/+/g,"/")+(t[1]?"?"+t.slice(1).join("?"):"")}async function c(e,t){let r=t.res||t.ctx&&t.ctx.res;if(!e.getInitialProps)return t.ctx&&t.Component?{pageProps:await c(t.Component,t.ctx)}:{};let i=await e.getInitialProps(t);if(r&&d(r))return i;if(!i)throw Error('"'+u(e)+'.getInitialProps()" should resolve to an object. But found "'+i+'" instead.');return i}let l="undefined"!=typeof performance,p=l&&["mark","measure","getEntriesByName"].every(e=>"function"==typeof performance[e]);class f extends Error{}class g extends Error{}class y extends Error{constructor(e){super(),this.code="ENOENT",this.name="PageNotFoundError",this.message="Cannot find module for page: "+e}}class m extends Error{constructor(e,t){super(),this.message="Failed to load static file for page: "+e+" "+t}}class b extends Error{constructor(){super(),this.code="ENOENT",this.message="Cannot find the middleware module"}}function w(e){return JSON.stringify({message:e.message,stack:e.stack})}},8015:(e,t,r)=>{"use strict";r.r(t),r.d(t,{default:()=>h});var i=r(9510);r(1159);var n=r(8570);let o=(0,n.createProxy)(String.raw`/Users/rafael/work/buddy-link/buddy-ts-examples/next/sponsaru/src/components/chart.tsx`),{__esModule:a,$$typeof:s}=o;o.default;let u=(0,n.createProxy)(String.raw`/Users/rafael/work/buddy-link/buddy-ts-examples/next/sponsaru/src/components/chart.tsx#default`),d=[{id:"c",label:"Jimi",image:"https://upload.wikimedia.org/wikipedia/commons/6/6c/Jimi-Hendrix-1967-Helsinki-d.jpg",members:20},{id:"a",label:"Jim",image:"https://upload.wikimedia.org/wikipedia/commons/7/7f/Jim_Morrison_1969.JPG",members:60},{id:"d",label:"Bonko",image:"image-1.webp",members:150},{id:"e",label:"Bonkerz",image:"image-0.webp",members:300},{id:"f",label:"BuddyLink",image:"/logo.webp",members:700}];function h(){return i.jsx("main",{className:"flex min-h-screen flex-col items-center justify-between ",children:i.jsx(u,{nodes:d})})}},3881:(e,t,r)=>{"use strict";r.r(t),r.d(t,{default:()=>n});var i=r(6621);let n=e=>[{type:"image/x-icon",sizes:"16x16",url:(0,i.fillMetadataSegment)(".",e.params,"favicon.ico")+""}]}};var t=require("../webpack-runtime.js");t.C(e);var r=e=>t(t.s=e),i=t.X(0,[948,745,840],()=>r(3637));module.exports=i})();