/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "?e082":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "?dced":
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

/* (ignored) */

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Frafael%2Fwork%2Fbuddy-link%2Fbuddy-ts-examples%2Fnext%2Fsponsaru%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fimage-component.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Frafael%2Fwork%2Fbuddy-link%2Fbuddy-ts-examples%2Fnext%2Fsponsaru%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Poppins%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22weight%5C%22%3A%5B%5C%22100%5C%22%2C%5C%22200%5C%22%2C%5C%22300%5C%22%2C%5C%22400%5C%22%2C%5C%22500%5C%22%2C%5C%22600%5C%22%2C%5C%22700%5C%22%2C%5C%22800%5C%22%2C%5C%22900%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22popins%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Frafael%2Fwork%2Fbuddy-link%2Fbuddy-ts-examples%2Fnext%2Fsponsaru%2Fsrc%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Frafael%2Fwork%2Fbuddy-link%2Fbuddy-ts-examples%2Fnext%2Fsponsaru%2Fsrc%2Fcomponents%2Fwallet-connect-button.tsx%22%2C%22ids%22%3A%5B%22BuddyConnectWalletButton%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Frafael%2Fwork%2Fbuddy-link%2Fbuddy-ts-examples%2Fnext%2Fsponsaru%2Fsrc%2Fproviders%2Fwallet-provider.tsx%22%2C%22ids%22%3A%5B%22WalletConnectionProvider%22%5D%7D&server=false!":
/*!*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Frafael%2Fwork%2Fbuddy-link%2Fbuddy-ts-examples%2Fnext%2Fsponsaru%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fimage-component.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Frafael%2Fwork%2Fbuddy-link%2Fbuddy-ts-examples%2Fnext%2Fsponsaru%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Poppins%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22weight%5C%22%3A%5B%5C%22100%5C%22%2C%5C%22200%5C%22%2C%5C%22300%5C%22%2C%5C%22400%5C%22%2C%5C%22500%5C%22%2C%5C%22600%5C%22%2C%5C%22700%5C%22%2C%5C%22800%5C%22%2C%5C%22900%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22popins%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Frafael%2Fwork%2Fbuddy-link%2Fbuddy-ts-examples%2Fnext%2Fsponsaru%2Fsrc%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Frafael%2Fwork%2Fbuddy-link%2Fbuddy-ts-examples%2Fnext%2Fsponsaru%2Fsrc%2Fcomponents%2Fwallet-connect-button.tsx%22%2C%22ids%22%3A%5B%22BuddyConnectWalletButton%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Frafael%2Fwork%2Fbuddy-link%2Fbuddy-ts-examples%2Fnext%2Fsponsaru%2Fsrc%2Fproviders%2Fwallet-provider.tsx%22%2C%22ids%22%3A%5B%22WalletConnectionProvider%22%5D%7D&server=false! ***!
  \*************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/dist/client/image-component.js */ \"(app-pages-browser)/./node_modules/next/dist/client/image-component.js\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.t.bind(__webpack_require__, /*! ./node_modules/next/font/google/target.css?{\"path\":\"src/app/layout.tsx\",\"import\":\"Poppins\",\"arguments\":[{\"subsets\":[\"latin\"],\"weight\":[\"100\",\"200\",\"300\",\"400\",\"500\",\"600\",\"700\",\"800\",\"900\"]}],\"variableName\":\"popins\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"src/app/layout.tsx\\\",\\\"import\\\":\\\"Poppins\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"],\\\"weight\\\":[\\\"100\\\",\\\"200\\\",\\\"300\\\",\\\"400\\\",\\\"500\\\",\\\"600\\\",\\\"700\\\",\\\"800\\\",\\\"900\\\"]}],\\\"variableName\\\":\\\"popins\\\"}\", 23));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/app/globals.css */ \"(app-pages-browser)/./src/app/globals.css\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/components/wallet-connect-button.tsx */ \"(app-pages-browser)/./src/components/wallet-connect-button.tsx\"));\n;\nPromise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./src/providers/wallet-provider.tsx */ \"(app-pages-browser)/./src/providers/wallet-provider.tsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZyYWZhZWwlMkZ3b3JrJTJGYnVkZHktbGluayUyRmJ1ZGR5LXRzLWV4YW1wbGVzJTJGbmV4dCUyRnNwb25zYXJ1JTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmRpc3QlMkZjbGllbnQlMkZpbWFnZS1jb21wb25lbnQuanMlMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0QmbW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZyYWZhZWwlMkZ3b3JrJTJGYnVkZHktbGluayUyRmJ1ZGR5LXRzLWV4YW1wbGVzJTJGbmV4dCUyRnNwb25zYXJ1JTJGbm9kZV9tb2R1bGVzJTJGbmV4dCUyRmZvbnQlMkZnb29nbGUlMkZ0YXJnZXQuY3NzJTNGJTdCJTVDJTIycGF0aCU1QyUyMiUzQSU1QyUyMnNyYyUyRmFwcCUyRmxheW91dC50c3glNUMlMjIlMkMlNUMlMjJpbXBvcnQlNUMlMjIlM0ElNUMlMjJQb3BwaW5zJTVDJTIyJTJDJTVDJTIyYXJndW1lbnRzJTVDJTIyJTNBJTVCJTdCJTVDJTIyc3Vic2V0cyU1QyUyMiUzQSU1QiU1QyUyMmxhdGluJTVDJTIyJTVEJTJDJTVDJTIyd2VpZ2h0JTVDJTIyJTNBJTVCJTVDJTIyMTAwJTVDJTIyJTJDJTVDJTIyMjAwJTVDJTIyJTJDJTVDJTIyMzAwJTVDJTIyJTJDJTVDJTIyNDAwJTVDJTIyJTJDJTVDJTIyNTAwJTVDJTIyJTJDJTVDJTIyNjAwJTVDJTIyJTJDJTVDJTIyNzAwJTVDJTIyJTJDJTVDJTIyODAwJTVDJTIyJTJDJTVDJTIyOTAwJTVDJTIyJTVEJTdEJTVEJTJDJTVDJTIydmFyaWFibGVOYW1lJTVDJTIyJTNBJTVDJTIycG9waW5zJTVDJTIyJTdEJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRlVzZXJzJTJGcmFmYWVsJTJGd29yayUyRmJ1ZGR5LWxpbmslMkZidWRkeS10cy1leGFtcGxlcyUyRm5leHQlMkZzcG9uc2FydSUyRnNyYyUyRmFwcCUyRmdsb2JhbHMuY3NzJTIyJTJDJTIyaWRzJTIyJTNBJTVCJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRlVzZXJzJTJGcmFmYWVsJTJGd29yayUyRmJ1ZGR5LWxpbmslMkZidWRkeS10cy1leGFtcGxlcyUyRm5leHQlMkZzcG9uc2FydSUyRnNyYyUyRmNvbXBvbmVudHMlMkZ3YWxsZXQtY29ubmVjdC1idXR0b24udHN4JTIyJTJDJTIyaWRzJTIyJTNBJTVCJTIyQnVkZHlDb25uZWN0V2FsbGV0QnV0dG9uJTIyJTVEJTdEJm1vZHVsZXM9JTdCJTIycmVxdWVzdCUyMiUzQSUyMiUyRlVzZXJzJTJGcmFmYWVsJTJGd29yayUyRmJ1ZGR5LWxpbmslMkZidWRkeS10cy1leGFtcGxlcyUyRm5leHQlMkZzcG9uc2FydSUyRnNyYyUyRnByb3ZpZGVycyUyRndhbGxldC1wcm92aWRlci50c3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlMjJXYWxsZXRDb25uZWN0aW9uUHJvdmlkZXIlMjIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSxvT0FBbUo7QUFDbko7QUFDQSxzbEJBQStWO0FBQy9WO0FBQ0Esb0tBQXNIO0FBQ3RIO0FBQ0EsOE1BQXlMO0FBQ3pMO0FBQ0EsZ01BQWtMIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8/OWNlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9yYWZhZWwvd29yay9idWRkeS1saW5rL2J1ZGR5LXRzLWV4YW1wbGVzL25leHQvc3BvbnNhcnUvbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jbGllbnQvaW1hZ2UtY29tcG9uZW50LmpzXCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvcmFmYWVsL3dvcmsvYnVkZHktbGluay9idWRkeS10cy1leGFtcGxlcy9uZXh0L3Nwb25zYXJ1L25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1xcXCJwYXRoXFxcIjpcXFwic3JjL2FwcC9sYXlvdXQudHN4XFxcIixcXFwiaW1wb3J0XFxcIjpcXFwiUG9wcGluc1xcXCIsXFxcImFyZ3VtZW50c1xcXCI6W3tcXFwic3Vic2V0c1xcXCI6W1xcXCJsYXRpblxcXCJdLFxcXCJ3ZWlnaHRcXFwiOltcXFwiMTAwXFxcIixcXFwiMjAwXFxcIixcXFwiMzAwXFxcIixcXFwiNDAwXFxcIixcXFwiNTAwXFxcIixcXFwiNjAwXFxcIixcXFwiNzAwXFxcIixcXFwiODAwXFxcIixcXFwiOTAwXFxcIl19XSxcXFwidmFyaWFibGVOYW1lXFxcIjpcXFwicG9waW5zXFxcIn1cIik7XG47XG5pbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9yYWZhZWwvd29yay9idWRkeS1saW5rL2J1ZGR5LXRzLWV4YW1wbGVzL25leHQvc3BvbnNhcnUvc3JjL2FwcC9nbG9iYWxzLmNzc1wiKTtcbjtcbmltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiLCB3ZWJwYWNrRXhwb3J0czogW1wiQnVkZHlDb25uZWN0V2FsbGV0QnV0dG9uXCJdICovIFwiL1VzZXJzL3JhZmFlbC93b3JrL2J1ZGR5LWxpbmsvYnVkZHktdHMtZXhhbXBsZXMvbmV4dC9zcG9uc2FydS9zcmMvY29tcG9uZW50cy93YWxsZXQtY29ubmVjdC1idXR0b24udHN4XCIpO1xuO1xuaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIsIHdlYnBhY2tFeHBvcnRzOiBbXCJXYWxsZXRDb25uZWN0aW9uUHJvdmlkZXJcIl0gKi8gXCIvVXNlcnMvcmFmYWVsL3dvcmsvYnVkZHktbGluay9idWRkeS10cy1leGFtcGxlcy9uZXh0L3Nwb25zYXJ1L3NyYy9wcm92aWRlcnMvd2FsbGV0LXByb3ZpZGVyLnRzeFwiKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Frafael%2Fwork%2Fbuddy-link%2Fbuddy-ts-examples%2Fnext%2Fsponsaru%2Fnode_modules%2Fnext%2Fdist%2Fclient%2Fimage-component.js%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Frafael%2Fwork%2Fbuddy-link%2Fbuddy-ts-examples%2Fnext%2Fsponsaru%2Fnode_modules%2Fnext%2Ffont%2Fgoogle%2Ftarget.css%3F%7B%5C%22path%5C%22%3A%5C%22src%2Fapp%2Flayout.tsx%5C%22%2C%5C%22import%5C%22%3A%5C%22Poppins%5C%22%2C%5C%22arguments%5C%22%3A%5B%7B%5C%22subsets%5C%22%3A%5B%5C%22latin%5C%22%5D%2C%5C%22weight%5C%22%3A%5B%5C%22100%5C%22%2C%5C%22200%5C%22%2C%5C%22300%5C%22%2C%5C%22400%5C%22%2C%5C%22500%5C%22%2C%5C%22600%5C%22%2C%5C%22700%5C%22%2C%5C%22800%5C%22%2C%5C%22900%5C%22%5D%7D%5D%2C%5C%22variableName%5C%22%3A%5C%22popins%5C%22%7D%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Frafael%2Fwork%2Fbuddy-link%2Fbuddy-ts-examples%2Fnext%2Fsponsaru%2Fsrc%2Fapp%2Fglobals.css%22%2C%22ids%22%3A%5B%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Frafael%2Fwork%2Fbuddy-link%2Fbuddy-ts-examples%2Fnext%2Fsponsaru%2Fsrc%2Fcomponents%2Fwallet-connect-button.tsx%22%2C%22ids%22%3A%5B%22BuddyConnectWalletButton%22%5D%7D&modules=%7B%22request%22%3A%22%2FUsers%2Frafael%2Fwork%2Fbuddy-link%2Fbuddy-ts-examples%2Fnext%2Fsponsaru%2Fsrc%2Fproviders%2Fwallet-provider.tsx%22%2C%22ids%22%3A%5B%22WalletConnectionProvider%22%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/buffer-layout/lib/Layout.js":
/*!**********************************************************!*\
  !*** ./node_modules/@solana/buffer-layout/lib/Layout.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n/**\n * Support for translating between Uint8Array instances and JavaScript\n * native types.\n *\n * {@link module:Layout~Layout|Layout} is the basis of a class\n * hierarchy that associates property names with sequences of encoded\n * bytes.\n *\n * Layouts are supported for these scalar (numeric) types:\n * * {@link module:Layout~UInt|Unsigned integers in little-endian\n *   format} with {@link module:Layout.u8|8-bit}, {@link\n *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n *   {@link module:Layout.u32|32-bit}, {@link\n *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n *   format} with {@link module:Layout.u16be|16-bit}, {@link\n *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n *   {@link module:Layout.u40be|40-bit}, and {@link\n *   module:Layout.u48be|48-bit} representation ranges;\n * * {@link module:Layout~Int|Signed integers in little-endian\n *   format} with {@link module:Layout.s8|8-bit}, {@link\n *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n *   {@link module:Layout.s32|32-bit}, {@link\n *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n *   representation ranges;\n * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n *   with {@link module:Layout.s16be|16-bit}, {@link\n *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n *   {@link module:Layout.s40be|40-bit}, and {@link\n *   module:Layout.s48be|48-bit} representation ranges;\n * * 64-bit integral values that decode to an exact (if magnitude is\n *   less than 2^53) or nearby integral Number in {@link\n *   module:Layout.nu64|unsigned little-endian}, {@link\n *   module:Layout.nu64be|unsigned big-endian}, {@link\n *   module:Layout.ns64|signed little-endian}, and {@link\n *   module:Layout.ns64be|unsigned big-endian} encodings;\n * * 32-bit floating point values with {@link\n *   module:Layout.f32|little-endian} and {@link\n *   module:Layout.f32be|big-endian} representations;\n * * 64-bit floating point values with {@link\n *   module:Layout.f64|little-endian} and {@link\n *   module:Layout.f64be|big-endian} representations;\n * * {@link module:Layout.const|Constants} that take no space in the\n *   encoded expression.\n *\n * and for these aggregate types:\n * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n *   module:Layout~Layout|Layout}, with JavaScript representation as\n *   an Array and constant or data-dependent {@link\n *   module:Layout~Sequence#count|length};\n * * {@link module:Layout.struct|Structure}s that aggregate a\n *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n *   instances, with JavaScript representation as an Object;\n * * {@link module:Layout.union|Union}s that support multiple {@link\n *   module:Layout~VariantLayout|variant layouts} over a fixed\n *   (padded) or variable (not padded) span of bytes, using an\n *   unsigned integer at the start of the data or a separate {@link\n *   module:Layout.unionLayoutDiscriminator|layout element} to\n *   determine which layout to use when interpreting the buffer\n *   contents;\n * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n *   of individual {@link\n *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n *   16, 24, or 32-bit unsigned integer starting at the least- or\n *   most-significant bit;\n * * {@link module:Layout.cstr|C strings} of varying length;\n * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n *   module:Layout~Blob#length|length} raw data.\n *\n * All {@link module:Layout~Layout|Layout} instances are immutable\n * after construction, to prevent internal state from becoming\n * inconsistent.\n *\n * @local Layout\n * @local ExternalLayout\n * @local GreedyCount\n * @local OffsetLayout\n * @local UInt\n * @local UIntBE\n * @local Int\n * @local IntBE\n * @local NearUInt64\n * @local NearUInt64BE\n * @local NearInt64\n * @local NearInt64BE\n * @local Float\n * @local FloatBE\n * @local Double\n * @local DoubleBE\n * @local Sequence\n * @local Structure\n * @local UnionDiscriminator\n * @local UnionLayoutDiscriminator\n * @local Union\n * @local VariantLayout\n * @local BitStructure\n * @local BitField\n * @local Boolean\n * @local Blob\n * @local CString\n * @local Constant\n * @local bindConstructorLayout\n * @module Layout\n * @license MIT\n * @author Peter A. Bigot\n * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.s16 = exports.s8 = exports.nu64be = exports.u48be = exports.u40be = exports.u32be = exports.u24be = exports.u16be = exports.nu64 = exports.u48 = exports.u40 = exports.u32 = exports.u24 = exports.u16 = exports.u8 = exports.offset = exports.greedy = exports.Constant = exports.UTF8 = exports.CString = exports.Blob = exports.Boolean = exports.BitField = exports.BitStructure = exports.VariantLayout = exports.Union = exports.UnionLayoutDiscriminator = exports.UnionDiscriminator = exports.Structure = exports.Sequence = exports.DoubleBE = exports.Double = exports.FloatBE = exports.Float = exports.NearInt64BE = exports.NearInt64 = exports.NearUInt64BE = exports.NearUInt64 = exports.IntBE = exports.Int = exports.UIntBE = exports.UInt = exports.OffsetLayout = exports.GreedyCount = exports.ExternalLayout = exports.bindConstructorLayout = exports.nameWithProperty = exports.Layout = exports.uint8ArrayToBuffer = exports.checkUint8Array = void 0;\nexports.constant = exports.utf8 = exports.cstr = exports.blob = exports.unionLayoutDiscriminator = exports.union = exports.seq = exports.bits = exports.struct = exports.f64be = exports.f64 = exports.f32be = exports.f32 = exports.ns64be = exports.s48be = exports.s40be = exports.s32be = exports.s24be = exports.s16be = exports.ns64 = exports.s48 = exports.s40 = exports.s32 = exports.s24 = void 0;\nconst buffer_1 = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\");\n/* Check if a value is a Uint8Array.\n *\n * @ignore */\nfunction checkUint8Array(b) {\n    if (!(b instanceof Uint8Array)) {\n        throw new TypeError('b must be a Uint8Array');\n    }\n}\nexports.checkUint8Array = checkUint8Array;\n/* Create a Buffer instance from a Uint8Array.\n *\n * @ignore */\nfunction uint8ArrayToBuffer(b) {\n    checkUint8Array(b);\n    return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);\n}\nexports.uint8ArrayToBuffer = uint8ArrayToBuffer;\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */\nclass Layout {\n    constructor(span, property) {\n        if (!Number.isInteger(span)) {\n            throw new TypeError('span must be an integer');\n        }\n        /** The span of the layout in bytes.\n         *\n         * Positive values are generally expected.\n         *\n         * Zero will only appear in {@link Constant}s and in {@link\n         * Sequence}s where the {@link Sequence#count|count} is zero.\n         *\n         * A negative value indicates that the span is value-specific, and\n         * must be obtained using {@link Layout#getSpan|getSpan}. */\n        this.span = span;\n        /** The property name used when this layout is represented in an\n         * Object.\n         *\n         * Used only for layouts that {@link Layout#decode|decode} to Object\n         * instances.  If left undefined the span of the unnamed layout will\n         * be treated as padding: it will not be mutated by {@link\n         * Layout#encode|encode} nor represented as a property in the\n         * decoded Object. */\n        this.property = property;\n    }\n    /** Function to create an Object into which decoded properties will\n     * be written.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances, which means:\n     * * {@link Structure}\n     * * {@link Union}\n     * * {@link VariantLayout}\n     * * {@link BitStructure}\n     *\n     * If left undefined the JavaScript representation of these layouts\n     * will be Object instances.\n     *\n     * See {@link bindConstructorLayout}.\n     */\n    makeDestinationObject() {\n        return {};\n    }\n    /**\n     * Calculate the span of a specific instance of a layout.\n     *\n     * @param {Uint8Array} b - the buffer that contains an encoded instance.\n     *\n     * @param {Number} [offset] - the offset at which the encoded instance\n     * starts.  If absent a zero offset is inferred.\n     *\n     * @return {Number} - the number of bytes covered by the layout\n     * instance.  If this method is not overridden in a subclass the\n     * definition-time constant {@link Layout#span|span} will be\n     * returned.\n     *\n     * @throws {RangeError} - if the length of the value cannot be\n     * determined.\n     */\n    getSpan(b, offset) {\n        if (0 > this.span) {\n            throw new RangeError('indeterminate span');\n        }\n        return this.span;\n    }\n    /**\n     * Replicate the layout using a new property.\n     *\n     * This function must be used to get a structurally-equivalent layout\n     * with a different name since all {@link Layout} instances are\n     * immutable.\n     *\n     * **NOTE** This is a shallow copy.  All fields except {@link\n     * Layout#property|property} are strictly equal to the origin layout.\n     *\n     * @param {String} property - the value for {@link\n     * Layout#property|property} in the replica.\n     *\n     * @returns {Layout} - the copy with {@link Layout#property|property}\n     * set to `property`.\n     */\n    replicate(property) {\n        const rv = Object.create(this.constructor.prototype);\n        Object.assign(rv, this);\n        rv.property = property;\n        return rv;\n    }\n    /**\n     * Create an object from layout properties and an array of values.\n     *\n     * **NOTE** This function returns `undefined` if invoked on a layout\n     * that does not return its value as an Object.  Objects are\n     * returned for things that are a {@link Structure}, which includes\n     * {@link VariantLayout|variant layouts} if they are structures, and\n     * excludes {@link Union}s.  If you want this feature for a union\n     * you must use {@link Union.getVariant|getVariant} to select the\n     * desired layout.\n     *\n     * @param {Array} values - an array of values that correspond to the\n     * default order for properties.  As with {@link Layout#decode|decode}\n     * layout elements that have no property name are skipped when\n     * iterating over the array values.  Only the top-level properties are\n     * assigned; arguments are not assigned to properties of contained\n     * layouts.  Any unused values are ignored.\n     *\n     * @return {(Object|undefined)}\n     */\n    fromArray(values) {\n        return undefined;\n    }\n}\nexports.Layout = Layout;\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */\nfunction nameWithProperty(name, lo) {\n    if (lo.property) {\n        return name + '[' + lo.property + ']';\n    }\n    return name;\n}\nexports.nameWithProperty = nameWithProperty;\n/**\n * Augment a class so that instances can be encoded/decoded using a\n * given layout.\n *\n * Calling this function couples `Class` with `layout` in several ways:\n *\n * * `Class.layout_` becomes a static member property equal to `layout`;\n * * `layout.boundConstructor_` becomes a static member property equal\n *    to `Class`;\n * * The {@link Layout#makeDestinationObject|makeDestinationObject()}\n *   property of `layout` is set to a function that returns a `new\n *   Class()`;\n * * `Class.decode(b, offset)` becomes a static member function that\n *   delegates to {@link Layout#decode|layout.decode}.  The\n *   synthesized function may be captured and extended.\n * * `Class.prototype.encode(b, offset)` provides an instance member\n *   function that delegates to {@link Layout#encode|layout.encode}\n *   with `src` set to `this`.  The synthesized function may be\n *   captured and extended, but when the extension is invoked `this`\n *   must be explicitly bound to the instance.\n *\n * @param {class} Class - a JavaScript class with a nullary\n * constructor.\n *\n * @param {Layout} layout - the {@link Layout} instance used to encode\n * instances of `Class`.\n */\n// `Class` must be a constructor Function, but the assignment of a `layout_` property to it makes it difficult to type\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nfunction bindConstructorLayout(Class, layout) {\n    if ('function' !== typeof Class) {\n        throw new TypeError('Class must be constructor');\n    }\n    if (Object.prototype.hasOwnProperty.call(Class, 'layout_')) {\n        throw new Error('Class is already bound to a layout');\n    }\n    if (!(layout && (layout instanceof Layout))) {\n        throw new TypeError('layout must be a Layout');\n    }\n    if (Object.prototype.hasOwnProperty.call(layout, 'boundConstructor_')) {\n        throw new Error('layout is already bound to a constructor');\n    }\n    Class.layout_ = layout;\n    layout.boundConstructor_ = Class;\n    layout.makeDestinationObject = (() => new Class());\n    Object.defineProperty(Class.prototype, 'encode', {\n        value(b, offset) {\n            return layout.encode(this, b, offset);\n        },\n        writable: true,\n    });\n    Object.defineProperty(Class, 'decode', {\n        value(b, offset) {\n            return layout.decode(b, offset);\n        },\n        writable: true,\n    });\n}\nexports.bindConstructorLayout = bindConstructorLayout;\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */\nclass ExternalLayout extends Layout {\n    /**\n     * Return `true` iff the external layout decodes to an unsigned\n     * integer layout.\n     *\n     * In that case it can be used as the source of {@link\n     * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n     * or as {@link UnionLayoutDiscriminator#layout|external union\n     * discriminators}.\n     *\n     * @abstract\n     */\n    isCount() {\n        throw new Error('ExternalLayout is abstract');\n    }\n}\nexports.ExternalLayout = ExternalLayout;\n/**\n * An {@link ExternalLayout} that determines its {@link\n * Layout#decode|value} based on offset into and length of the buffer\n * on which it is invoked.\n *\n * *Factory*: {@link module:Layout.greedy|greedy}\n *\n * @param {Number} [elementSpan] - initializer for {@link\n * GreedyCount#elementSpan|elementSpan}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {ExternalLayout}\n */\nclass GreedyCount extends ExternalLayout {\n    constructor(elementSpan = 1, property) {\n        if ((!Number.isInteger(elementSpan)) || (0 >= elementSpan)) {\n            throw new TypeError('elementSpan must be a (positive) integer');\n        }\n        super(-1, property);\n        /** The layout for individual elements of the sequence.  The value\n         * must be a positive integer.  If not provided, the value will be\n         * 1. */\n        this.elementSpan = elementSpan;\n    }\n    /** @override */\n    isCount() {\n        return true;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        checkUint8Array(b);\n        const rem = b.length - offset;\n        return Math.floor(rem / this.elementSpan);\n    }\n    /** @override */\n    encode(src, b, offset) {\n        return 0;\n    }\n}\nexports.GreedyCount = GreedyCount;\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */\nclass OffsetLayout extends ExternalLayout {\n    constructor(layout, offset = 0, property) {\n        if (!(layout instanceof Layout)) {\n            throw new TypeError('layout must be a Layout');\n        }\n        if (!Number.isInteger(offset)) {\n            throw new TypeError('offset must be integer or undefined');\n        }\n        super(layout.span, property || layout.property);\n        /** The subordinated layout. */\n        this.layout = layout;\n        /** The location of {@link OffsetLayout#layout} relative to the\n         * start of another layout.\n         *\n         * The value may be positive or negative, but an error will thrown\n         * if at the point of use it goes outside the span of the Uint8Array\n         * being accessed.  */\n        this.offset = offset;\n    }\n    /** @override */\n    isCount() {\n        return ((this.layout instanceof UInt)\n            || (this.layout instanceof UIntBE));\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return this.layout.decode(b, offset + this.offset);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        return this.layout.encode(src, b, offset + this.offset);\n    }\n}\nexports.OffsetLayout = OffsetLayout;\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UInt extends Layout {\n    constructor(span, property) {\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError('span must not exceed 6 bytes');\n        }\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readUIntLE(offset, this.span);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeUIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.UInt = UInt;\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UIntBE extends Layout {\n    constructor(span, property) {\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError('span must not exceed 6 bytes');\n        }\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readUIntBE(offset, this.span);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeUIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.UIntBE = UIntBE;\n/**\n * Represent a signed integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.s8|s8}, {@link\n *  module:Layout.s16|s16}, {@link module:Layout.s24|s24}, {@link\n *  module:Layout.s32|s32}, {@link module:Layout.s40|s40}, {@link\n *  module:Layout.s48|s48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Int extends Layout {\n    constructor(span, property) {\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError('span must not exceed 6 bytes');\n        }\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readIntLE(offset, this.span);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeIntLE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.Int = Int;\n/**\n * Represent a signed integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.s8be|s8be}, {@link\n * module:Layout.s16be|s16be}, {@link module:Layout.s24be|s24be},\n * {@link module:Layout.s32be|s32be}, {@link\n * module:Layout.s40be|s40be}, {@link module:Layout.s48be|s48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass IntBE extends Layout {\n    constructor(span, property) {\n        super(span, property);\n        if (6 < this.span) {\n            throw new RangeError('span must not exceed 6 bytes');\n        }\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readIntBE(offset, this.span);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeIntBE(src, offset, this.span);\n        return this.span;\n    }\n}\nexports.IntBE = IntBE;\nconst V2E32 = Math.pow(2, 32);\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */\nfunction divmodInt64(src) {\n    const hi32 = Math.floor(src / V2E32);\n    const lo32 = src - (hi32 * V2E32);\n    return { hi32, lo32 };\n}\n/* Reconstruct Number from quotient and non-negative remainder */\nfunction roundedInt64(hi32, lo32) {\n    return hi32 * V2E32 + lo32;\n}\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64 extends Layout {\n    constructor(property) {\n        super(8, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const lo32 = buffer.readUInt32LE(offset);\n        const hi32 = buffer.readUInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32LE(split.lo32, offset);\n        buffer.writeUInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\nexports.NearUInt64 = NearUInt64;\n/**\n * Represent an unsigned 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64be|nu64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64BE extends Layout {\n    constructor(property) {\n        super(8, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const hi32 = buffer.readUInt32BE(offset);\n        const lo32 = buffer.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32BE(split.hi32, offset);\n        buffer.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\nexports.NearUInt64BE = NearUInt64BE;\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64 extends Layout {\n    constructor(property) {\n        super(8, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const lo32 = buffer.readUInt32LE(offset);\n        const hi32 = buffer.readInt32LE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeUInt32LE(split.lo32, offset);\n        buffer.writeInt32LE(split.hi32, offset + 4);\n        return 8;\n    }\n}\nexports.NearInt64 = NearInt64;\n/**\n * Represent a signed 64-bit integer in big-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64be|ns64be}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64BE extends Layout {\n    constructor(property) {\n        super(8, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const buffer = uint8ArrayToBuffer(b);\n        const hi32 = buffer.readInt32BE(offset);\n        const lo32 = buffer.readUInt32BE(offset + 4);\n        return roundedInt64(hi32, lo32);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        const split = divmodInt64(src);\n        const buffer = uint8ArrayToBuffer(b);\n        buffer.writeInt32BE(split.hi32, offset);\n        buffer.writeUInt32BE(split.lo32, offset + 4);\n        return 8;\n    }\n}\nexports.NearInt64BE = NearInt64BE;\n/**\n * Represent a 32-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f32|f32}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Float extends Layout {\n    constructor(property) {\n        super(4, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readFloatLE(offset);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeFloatLE(src, offset);\n        return 4;\n    }\n}\nexports.Float = Float;\n/**\n * Represent a 32-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f32be|f32be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass FloatBE extends Layout {\n    constructor(property) {\n        super(4, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readFloatBE(offset);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeFloatBE(src, offset);\n        return 4;\n    }\n}\nexports.FloatBE = FloatBE;\n/**\n * Represent a 64-bit floating point number in little-endian format.\n *\n * *Factory*: {@link module:Layout.f64|f64}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Double extends Layout {\n    constructor(property) {\n        super(8, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readDoubleLE(offset);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeDoubleLE(src, offset);\n        return 8;\n    }\n}\nexports.Double = Double;\n/**\n * Represent a 64-bit floating point number in big-endian format.\n *\n * *Factory*: {@link module:Layout.f64be|f64be}\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass DoubleBE extends Layout {\n    constructor(property) {\n        super(8, property);\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        return uint8ArrayToBuffer(b).readDoubleBE(offset);\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        uint8ArrayToBuffer(b).writeDoubleBE(src, offset);\n        return 8;\n    }\n}\nexports.DoubleBE = DoubleBE;\n/**\n * Represent a contiguous sequence of a specific layout as an Array.\n *\n * *Factory*: {@link module:Layout.seq|seq}\n *\n * @param {Layout} elementLayout - initializer for {@link\n * Sequence#elementLayout|elementLayout}.\n *\n * @param {(Number|ExternalLayout)} count - initializer for {@link\n * Sequence#count|count}.  The parameter must be either a positive\n * integer or an instance of {@link ExternalLayout}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Sequence extends Layout {\n    constructor(elementLayout, count, property) {\n        if (!(elementLayout instanceof Layout)) {\n            throw new TypeError('elementLayout must be a Layout');\n        }\n        if (!(((count instanceof ExternalLayout) && count.isCount())\n            || (Number.isInteger(count) && (0 <= count)))) {\n            throw new TypeError('count must be non-negative integer '\n                + 'or an unsigned integer ExternalLayout');\n        }\n        let span = -1;\n        if ((!(count instanceof ExternalLayout))\n            && (0 < elementLayout.span)) {\n            span = count * elementLayout.span;\n        }\n        super(span, property);\n        /** The layout for individual elements of the sequence. */\n        this.elementLayout = elementLayout;\n        /** The number of elements in the sequence.\n         *\n         * This will be either a non-negative integer or an instance of\n         * {@link ExternalLayout} for which {@link\n         * ExternalLayout#isCount|isCount()} is `true`. */\n        this.count = count;\n    }\n    /** @override */\n    getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        let span = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        if (0 < this.elementLayout.span) {\n            span = count * this.elementLayout.span;\n        }\n        else {\n            let idx = 0;\n            while (idx < count) {\n                span += this.elementLayout.getSpan(b, offset + span);\n                ++idx;\n            }\n        }\n        return span;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const rv = [];\n        let i = 0;\n        let count = this.count;\n        if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset);\n        }\n        while (i < count) {\n            rv.push(this.elementLayout.decode(b, offset));\n            offset += this.elementLayout.getSpan(b, offset);\n            i += 1;\n        }\n        return rv;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n     *\n     * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n     * the unused space in the buffer is left unchanged.  If `src` is\n     * longer than {@link Sequence#count|count} the unneeded elements are\n     * ignored.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */\n    encode(src, b, offset = 0) {\n        const elo = this.elementLayout;\n        const span = src.reduce((span, v) => {\n            return span + elo.encode(v, b, offset + span);\n        }, 0);\n        if (this.count instanceof ExternalLayout) {\n            this.count.encode(src.length, b, offset);\n        }\n        return span;\n    }\n}\nexports.Sequence = Sequence;\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */\nclass Structure extends Layout {\n    constructor(fields, property, decodePrefixes) {\n        if (!(Array.isArray(fields)\n            && fields.reduce((acc, v) => acc && (v instanceof Layout), true))) {\n            throw new TypeError('fields must be array of Layout instances');\n        }\n        if (('boolean' === typeof property)\n            && (undefined === decodePrefixes)) {\n            decodePrefixes = property;\n            property = undefined;\n        }\n        /* Verify absence of unnamed variable-length fields. */\n        for (const fd of fields) {\n            if ((0 > fd.span)\n                && (undefined === fd.property)) {\n                throw new Error('fields cannot contain unnamed variable-length layout');\n            }\n        }\n        let span = -1;\n        try {\n            span = fields.reduce((span, fd) => span + fd.getSpan(), 0);\n        }\n        catch (e) {\n            // ignore error\n        }\n        super(span, property);\n        /** The sequence of {@link Layout} values that comprise the\n         * structure.\n         *\n         * The individual elements need not be the same type, and may be\n         * either scalar or aggregate layouts.  If a member layout leaves\n         * its {@link Layout#property|property} undefined the\n         * corresponding region of the buffer associated with the element\n         * will not be mutated.\n         *\n         * @type {Layout[]} */\n        this.fields = fields;\n        /** Control behavior of {@link Layout#decode|decode()} given short\n         * buffers.\n         *\n         * In some situations a structure many be extended with additional\n         * fields over time, with older installations providing only a\n         * prefix of the full structure.  If this property is `true`\n         * decoding will accept those buffers and leave subsequent fields\n         * undefined, as long as the buffer ends at a field boundary.\n         * Defaults to `false`. */\n        this.decodePrefixes = !!decodePrefixes;\n    }\n    /** @override */\n    getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        let span = 0;\n        try {\n            span = this.fields.reduce((span, fd) => {\n                const fsp = fd.getSpan(b, offset);\n                offset += fsp;\n                return span + fsp;\n            }, 0);\n        }\n        catch (e) {\n            throw new RangeError('indeterminate span');\n        }\n        return span;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        checkUint8Array(b);\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields) {\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b, offset);\n            }\n            offset += fd.getSpan(b, offset);\n            if (this.decodePrefixes\n                && (b.length === offset)) {\n                break;\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Structure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the buffer is\n     * left unmodified. */\n    encode(src, b, offset = 0) {\n        const firstOffset = offset;\n        let lastOffset = 0;\n        let lastWrote = 0;\n        for (const fd of this.fields) {\n            let span = fd.span;\n            lastWrote = (0 < span) ? span : 0;\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    lastWrote = fd.encode(fv, b, offset);\n                    if (0 > span) {\n                        /* Read the as-encoded span, which is not necessarily the\n                         * same as what we wrote. */\n                        span = fd.getSpan(b, offset);\n                    }\n                }\n            }\n            lastOffset = offset;\n            offset += span;\n        }\n        /* Use (lastOffset + lastWrote) instead of offset because the last\n         * item may have had a dynamic length and we don't want to include\n         * the padding between it and the end of the space reserved for\n         * it. */\n        return (lastOffset + lastWrote) - firstOffset;\n    }\n    /** @override */\n    fromArray(values) {\n        const dest = this.makeDestinationObject();\n        for (const fd of this.fields) {\n            if ((undefined !== fd.property)\n                && (0 < values.length)) {\n                dest[fd.property] = values.shift();\n            }\n        }\n        return dest;\n    }\n    /**\n     * Get access to the layout of a given property.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Layout} - the layout associated with `property`, or\n     * undefined if there is no such property.\n     */\n    layoutFor(property) {\n        if ('string' !== typeof property) {\n            throw new TypeError('property must be string');\n        }\n        for (const fd of this.fields) {\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Get the offset of a structure member.\n     *\n     * @param {String} property - the structure member of interest.\n     *\n     * @return {Number} - the offset in bytes to the start of `property`\n     * within the structure, or undefined if `property` is not a field\n     * within the structure.  If the property is a member but follows a\n     * variable-length structure member a negative number will be\n     * returned.\n     */\n    offsetOf(property) {\n        if ('string' !== typeof property) {\n            throw new TypeError('property must be string');\n        }\n        let offset = 0;\n        for (const fd of this.fields) {\n            if (fd.property === property) {\n                return offset;\n            }\n            if (0 > fd.span) {\n                offset = -1;\n            }\n            else if (0 <= offset) {\n                offset += fd.span;\n            }\n        }\n        return undefined;\n    }\n}\nexports.Structure = Structure;\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */\nclass UnionDiscriminator {\n    constructor(property) {\n        /** The {@link Layout#property|property} to be used when the\n         * discriminator is referenced in isolation (generally when {@link\n         * Union#decode|Union decode} cannot delegate to a specific\n         * variant). */\n        this.property = property;\n    }\n    /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n     *\n     * The implementation of this method need not reference the buffer if\n     * variant information is available through other means. */\n    decode(b, offset) {\n        throw new Error('UnionDiscriminator is abstract');\n    }\n    /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n     *\n     * The implementation of this method need not store the value if\n     * variant information is maintained through other means. */\n    encode(src, b, offset) {\n        throw new Error('UnionDiscriminator is abstract');\n    }\n}\nexports.UnionDiscriminator = UnionDiscriminator;\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */\nclass UnionLayoutDiscriminator extends UnionDiscriminator {\n    constructor(layout, property) {\n        if (!((layout instanceof ExternalLayout)\n            && layout.isCount())) {\n            throw new TypeError('layout must be an unsigned integer ExternalLayout');\n        }\n        super(property || layout.property || 'variant');\n        /** The {@link ExternalLayout} used to access the discriminator\n         * value. */\n        this.layout = layout;\n    }\n    /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n    decode(b, offset) {\n        return this.layout.decode(b, offset);\n    }\n    /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n    encode(src, b, offset) {\n        return this.layout.encode(src, b, offset);\n    }\n}\nexports.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Union extends Layout {\n    constructor(discr, defaultLayout, property) {\n        let discriminator;\n        if ((discr instanceof UInt)\n            || (discr instanceof UIntBE)) {\n            discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n        }\n        else if ((discr instanceof ExternalLayout)\n            && discr.isCount()) {\n            discriminator = new UnionLayoutDiscriminator(discr);\n        }\n        else if (!(discr instanceof UnionDiscriminator)) {\n            throw new TypeError('discr must be a UnionDiscriminator '\n                + 'or an unsigned integer layout');\n        }\n        else {\n            discriminator = discr;\n        }\n        if (undefined === defaultLayout) {\n            defaultLayout = null;\n        }\n        if (!((null === defaultLayout)\n            || (defaultLayout instanceof Layout))) {\n            throw new TypeError('defaultLayout must be null or a Layout');\n        }\n        if (null !== defaultLayout) {\n            if (0 > defaultLayout.span) {\n                throw new Error('defaultLayout must have constant span');\n            }\n            if (undefined === defaultLayout.property) {\n                defaultLayout = defaultLayout.replicate('content');\n            }\n        }\n        /* The union span can be estimated only if there's a default\n         * layout.  The union spans its default layout, plus any prefix\n         * variant layout.  By construction both layouts, if present, have\n         * non-negative span. */\n        let span = -1;\n        if (defaultLayout) {\n            span = defaultLayout.span;\n            if ((0 <= span) && ((discr instanceof UInt)\n                || (discr instanceof UIntBE))) {\n                span += discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The interface for the discriminator value in isolation.\n         *\n         * This a {@link UnionDiscriminator} either passed to the\n         * constructor or synthesized from the `discr` constructor\n         * argument.  {@link\n         * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n         * `true` iff the `discr` parameter was a non-offset {@link\n         * Layout} instance. */\n        this.discriminator = discriminator;\n        /** `true` if the {@link Union#discriminator|discriminator} is the\n         * first field in the union.\n         *\n         * If `false` the discriminator is obtained from somewhere\n         * else. */\n        this.usesPrefixDiscriminator = (discr instanceof UInt)\n            || (discr instanceof UIntBE);\n        /** The layout for non-discriminator content when the value of the\n         * discriminator is not recognized.\n         *\n         * This is the value passed to the constructor.  It is\n         * structurally equivalent to the second component of {@link\n         * Union#layout|layout} but may have a different property\n         * name. */\n        this.defaultLayout = defaultLayout;\n        /** A registry of allowed variants.\n         *\n         * The keys are unsigned integers which should be compatible with\n         * {@link Union.discriminator|discriminator}.  The property value\n         * is the corresponding {@link VariantLayout} instances assigned\n         * to this union by {@link Union#addVariant|addVariant}.\n         *\n         * **NOTE** The registry remains mutable so that variants can be\n         * {@link Union#addVariant|added} at any time.  Users should not\n         * manipulate the content of this property. */\n        this.registry = {};\n        /* Private variable used when invoking getSourceVariant */\n        let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n        /** Function to infer the variant selected by a source object.\n         *\n         * Defaults to {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n         * be overridden using {@link\n         * Union#configGetSourceVariant|configGetSourceVariant}.\n         *\n         * @param {Object} src - as with {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n         *\n         * @returns {(undefined|VariantLayout)} The default variant\n         * (`undefined`) or first registered variant that uses a property\n         * available in `src`. */\n        this.getSourceVariant = function (src) {\n            return boundGetSourceVariant(src);\n        };\n        /** Function to override the implementation of {@link\n         * Union#getSourceVariant|getSourceVariant}.\n         *\n         * Use this if the desired variant cannot be identified using the\n         * algorithm of {@link\n         * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n         *\n         * **NOTE** The provided function will be invoked bound to this\n         * Union instance, providing local access to {@link\n         * Union#registry|registry}.\n         *\n         * @param {Function} gsv - a function that follows the API of\n         * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\n        this.configGetSourceVariant = function (gsv) {\n            boundGetSourceVariant = gsv.bind(this);\n        };\n    }\n    /** @override */\n    getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            return this.span;\n        }\n        /* Default layouts always have non-negative span, so we don't have\n         * one and we have to recognize the variant which will in turn\n         * determine the span. */\n        const vlo = this.getVariant(b, offset);\n        if (!vlo) {\n            throw new Error('unable to determine span for unrecognized variant');\n        }\n        return vlo.getSpan(b, offset);\n    }\n    /**\n     * Method to infer a registered Union variant compatible with `src`.\n     *\n     * The first satisfied rule in the following sequence defines the\n     * return value:\n     * * If `src` has properties matching the Union discriminator and\n     *   the default layout, `undefined` is returned regardless of the\n     *   value of the discriminator property (this ensures the default\n     *   layout will be used);\n     * * If `src` has a property matching the Union discriminator, the\n     *   value of the discriminator identifies a registered variant, and\n     *   either (a) the variant has no layout, or (b) `src` has the\n     *   variant's property, then the variant is returned (because the\n     *   source satisfies the constraints of the variant it identifies);\n     * * If `src` does not have a property matching the Union\n     *   discriminator, but does have a property matching a registered\n     *   variant, then the variant is returned (because the source\n     *   matches a variant without an explicit conflict);\n     * * An error is thrown (because we either can't identify a variant,\n     *   or we were explicitly told the variant but can't satisfy it).\n     *\n     * @param {Object} src - an object presumed to be compatible with\n     * the content of the Union.\n     *\n     * @return {(undefined|VariantLayout)} - as described above.\n     *\n     * @throws {Error} - if `src` cannot be associated with a default or\n     * registered variant.\n     */\n    defaultGetSourceVariant(src) {\n        if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {\n            if (this.defaultLayout && this.defaultLayout.property\n                && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {\n                return undefined;\n            }\n            const vlo = this.registry[src[this.discriminator.property]];\n            if (vlo\n                && ((!vlo.layout)\n                    || (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)))) {\n                return vlo;\n            }\n        }\n        else {\n            for (const tag in this.registry) {\n                const vlo = this.registry[tag];\n                if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {\n                    return vlo;\n                }\n            }\n        }\n        throw new Error('unable to infer src variant');\n    }\n    /** Implement {@link Layout#decode|decode} for {@link Union}.\n     *\n     * If the variant is {@link Union#addVariant|registered} the return\n     * value is an instance of that variant, with no explicit\n     * discriminator.  Otherwise the {@link Union#defaultLayout|default\n     * layout} is used to decode the content. */\n    decode(b, offset = 0) {\n        let dest;\n        const dlo = this.discriminator;\n        const discr = dlo.decode(b, offset);\n        const clo = this.registry[discr];\n        if (undefined === clo) {\n            const defaultLayout = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dest = this.makeDestinationObject();\n            dest[dlo.property] = discr;\n            // defaultLayout.property can be undefined, but this is allowed by buffer-layout\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            dest[defaultLayout.property] = defaultLayout.decode(b, offset + contentOffset);\n        }\n        else {\n            dest = clo.decode(b, offset);\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Union}.\n     *\n     * This API assumes the `src` object is consistent with the union's\n     * {@link Union#defaultLayout|default layout}.  To encode variants\n     * use the appropriate variant-specific {@link VariantLayout#encode}\n     * method. */\n    encode(src, b, offset = 0) {\n        const vlo = this.getSourceVariant(src);\n        if (undefined === vlo) {\n            const dlo = this.discriminator;\n            // this.defaultLayout is not undefined when vlo is undefined\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const clo = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n                contentOffset = dlo.layout.span;\n            }\n            dlo.encode(src[dlo.property], b, offset);\n            // clo.property is not undefined when vlo is undefined\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return contentOffset + clo.encode(src[clo.property], b, offset + contentOffset);\n        }\n        return vlo.encode(src, b, offset);\n    }\n    /** Register a new variant structure within a union.  The newly\n     * created variant is returned.\n     *\n     * @param {Number} variant - initializer for {@link\n     * VariantLayout#variant|variant}.\n     *\n     * @param {Layout} layout - initializer for {@link\n     * VariantLayout#layout|layout}.\n     *\n     * @param {String} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {VariantLayout} */\n    addVariant(variant, layout, property) {\n        const rv = new VariantLayout(this, variant, layout, property);\n        this.registry[variant] = rv;\n        return rv;\n    }\n    /**\n     * Get the layout associated with a registered variant.\n     *\n     * If `vb` does not produce a registered variant the function returns\n     * `undefined`.\n     *\n     * @param {(Number|Uint8Array)} vb - either the variant number, or a\n     * buffer from which the discriminator is to be read.\n     *\n     * @param {Number} offset - offset into `vb` for the start of the\n     * union.  Used only when `vb` is an instance of {Uint8Array}.\n     *\n     * @return {({VariantLayout}|undefined)}\n     */\n    getVariant(vb, offset = 0) {\n        let variant;\n        if (vb instanceof Uint8Array) {\n            variant = this.discriminator.decode(vb, offset);\n        }\n        else {\n            variant = vb;\n        }\n        return this.registry[variant];\n    }\n}\nexports.Union = Union;\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */\nclass VariantLayout extends Layout {\n    constructor(union, variant, layout, property) {\n        if (!(union instanceof Union)) {\n            throw new TypeError('union must be a Union');\n        }\n        if ((!Number.isInteger(variant)) || (0 > variant)) {\n            throw new TypeError('variant must be a (non-negative) integer');\n        }\n        if (('string' === typeof layout)\n            && (undefined === property)) {\n            property = layout;\n            layout = null;\n        }\n        if (layout) {\n            if (!(layout instanceof Layout)) {\n                throw new TypeError('layout must be a Layout');\n            }\n            if ((null !== union.defaultLayout)\n                && (0 <= layout.span)\n                && (layout.span > union.defaultLayout.span)) {\n                throw new Error('variant span exceeds span of containing union');\n            }\n            if ('string' !== typeof property) {\n                throw new TypeError('variant must have a String property');\n            }\n        }\n        let span = union.span;\n        if (0 > union.span) {\n            span = layout ? layout.span : 0;\n            if ((0 <= span) && union.usesPrefixDiscriminator) {\n                span += union.discriminator.layout.span;\n            }\n        }\n        super(span, property);\n        /** The {@link Union} to which this variant belongs. */\n        this.union = union;\n        /** The unsigned integral value identifying this variant within\n         * the {@link Union#discriminator|discriminator} of the containing\n         * union. */\n        this.variant = variant;\n        /** The {@link Layout} to be used when reading/writing the\n         * non-discriminator part of the {@link\n         * VariantLayout#union|union}.  If `null` the variant carries no\n         * data. */\n        this.layout = layout || null;\n    }\n    /** @override */\n    getSpan(b, offset = 0) {\n        if (0 <= this.span) {\n            /* Will be equal to the containing union span if that is not\n             * variable. */\n            return this.span;\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        /* Span is defined solely by the variant (and prefix discriminator) */\n        let span = 0;\n        if (this.layout) {\n            span = this.layout.getSpan(b, offset + contentOffset);\n        }\n        return contentOffset + span;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const dest = this.makeDestinationObject();\n        if (this !== this.union.getVariant(b, offset)) {\n            throw new Error('variant mismatch');\n        }\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout) {\n            dest[this.property] = this.layout.decode(b, offset + contentOffset);\n        }\n        else if (this.property) {\n            dest[this.property] = true;\n        }\n        else if (this.union.usesPrefixDiscriminator) {\n            dest[this.union.discriminator.property] = this.variant;\n        }\n        return dest;\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        let contentOffset = 0;\n        if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n        }\n        if (this.layout\n            && (!Object.prototype.hasOwnProperty.call(src, this.property))) {\n            throw new TypeError('variant lacks property ' + this.property);\n        }\n        this.union.discriminator.encode(this.variant, b, offset);\n        let span = contentOffset;\n        if (this.layout) {\n            this.layout.encode(src[this.property], b, offset + contentOffset);\n            span += this.layout.getSpan(b, offset + contentOffset);\n            if ((0 <= this.union.span)\n                && (span > this.union.span)) {\n                throw new Error('encoded variant overruns containing union');\n            }\n        }\n        return span;\n    }\n    /** Delegate {@link Layout#fromArray|fromArray} to {@link\n     * VariantLayout#layout|layout}. */\n    fromArray(values) {\n        if (this.layout) {\n            return this.layout.fromArray(values);\n        }\n        return undefined;\n    }\n}\nexports.VariantLayout = VariantLayout;\n/** JavaScript chose to define bitwise operations as operating on\n * signed 32-bit values in 2's complement form, meaning any integer\n * with bit 31 set is going to look negative.  For right shifts that's\n * not a problem, because `>>>` is a logical shift, but for every\n * other bitwise operator we have to compensate for possible negative\n * results. */\nfunction fixBitwiseResult(v) {\n    if (0 > v) {\n        v += 0x100000000;\n    }\n    return v;\n}\n/**\n * Contain a sequence of bit fields as an unsigned integer.\n *\n * *Factory*: {@link module:Layout.bits|bits}\n *\n * This is a container element; within it there are {@link BitField}\n * instances that provide the extracted properties.  The container\n * simply defines the aggregate representation and its bit ordering.\n * The representation is an object containing properties with numeric\n * or {@link Boolean} values.\n *\n * {@link BitField}s are added with the {@link\n * BitStructure#addField|addField} and {@link\n * BitStructure#addBoolean|addBoolean} methods.\n\n * @param {Layout} word - initializer for {@link\n * BitStructure#word|word}.  The parameter must be an instance of\n * {@link UInt} (or {@link UIntBE}) that is no more than 4 bytes wide.\n *\n * @param {bool} [msb] - `true` if the bit numbering starts at the\n * most significant bit of the containing word; `false` (default) if\n * it starts at the least significant bit of the containing word.  If\n * the parameter at this position is a string and `property` is\n * `undefined` the value of this argument will instead be used as the\n * value of `property`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass BitStructure extends Layout {\n    constructor(word, msb, property) {\n        if (!((word instanceof UInt)\n            || (word instanceof UIntBE))) {\n            throw new TypeError('word must be a UInt or UIntBE layout');\n        }\n        if (('string' === typeof msb)\n            && (undefined === property)) {\n            property = msb;\n            msb = false;\n        }\n        if (4 < word.span) {\n            throw new RangeError('word cannot exceed 32 bits');\n        }\n        super(word.span, property);\n        /** The layout used for the packed value.  {@link BitField}\n         * instances are packed sequentially depending on {@link\n         * BitStructure#msb|msb}. */\n        this.word = word;\n        /** Whether the bit sequences are packed starting at the most\n         * significant bit growing down (`true`), or the least significant\n         * bit growing up (`false`).\n         *\n         * **NOTE** Regardless of this value, the least significant bit of\n         * any {@link BitField} value is the least significant bit of the\n         * corresponding section of the packed value. */\n        this.msb = !!msb;\n        /** The sequence of {@link BitField} layouts that comprise the\n         * packed structure.\n         *\n         * **NOTE** The array remains mutable to allow fields to be {@link\n         * BitStructure#addField|added} after construction.  Users should\n         * not manipulate the content of this property.*/\n        this.fields = [];\n        /* Storage for the value.  Capture a variable instead of using an\n         * instance property because we don't want anything to change the\n         * value without going through the mutator. */\n        let value = 0;\n        this._packedSetValue = function (v) {\n            value = fixBitwiseResult(v);\n            return this;\n        };\n        this._packedGetValue = function () {\n            return value;\n        };\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const dest = this.makeDestinationObject();\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields) {\n            if (undefined !== fd.property) {\n                dest[fd.property] = fd.decode(b);\n            }\n        }\n        return dest;\n    }\n    /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n     *\n     * If `src` is missing a property for a member with a defined {@link\n     * Layout#property|property} the corresponding region of the packed\n     * value is left unmodified.  Unused bits are also left unmodified. */\n    encode(src, b, offset = 0) {\n        const value = this.word.decode(b, offset);\n        this._packedSetValue(value);\n        for (const fd of this.fields) {\n            if (undefined !== fd.property) {\n                const fv = src[fd.property];\n                if (undefined !== fv) {\n                    fd.encode(fv);\n                }\n            }\n        }\n        return this.word.encode(this._packedGetValue(), b, offset);\n    }\n    /** Register a new bitfield with a containing bit structure.  The\n     * resulting bitfield is returned.\n     *\n     * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {BitField} */\n    addField(bits, property) {\n        const bf = new BitField(this, bits, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /** As with {@link BitStructure#addField|addField} for single-bit\n     * fields with `boolean` value representation.\n     *\n     * @param {string} property - initializer for {@link\n     * Layout#property|property}.\n     *\n     * @return {Boolean} */\n    // `Boolean` conflicts with the native primitive type\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    addBoolean(property) {\n        // This is my Boolean, not the Javascript one.\n        const bf = new Boolean(this, property);\n        this.fields.push(bf);\n        return bf;\n    }\n    /**\n     * Get access to the bit field for a given property.\n     *\n     * @param {String} property - the bit field of interest.\n     *\n     * @return {BitField} - the field associated with `property`, or\n     * undefined if there is no such property.\n     */\n    fieldFor(property) {\n        if ('string' !== typeof property) {\n            throw new TypeError('property must be string');\n        }\n        for (const fd of this.fields) {\n            if (fd.property === property) {\n                return fd;\n            }\n        }\n        return undefined;\n    }\n}\nexports.BitStructure = BitStructure;\n/**\n * Represent a sequence of bits within a {@link BitStructure}.\n *\n * All bit field values are represented as unsigned integers.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addField|addField} helper\n * method.\n *\n * **NOTE** BitField instances are not instances of {@link Layout}\n * since {@link Layout#span|span} measures 8-bit units.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n */\nclass BitField {\n    constructor(container, bits, property) {\n        if (!(container instanceof BitStructure)) {\n            throw new TypeError('container must be a BitStructure');\n        }\n        if ((!Number.isInteger(bits)) || (0 >= bits)) {\n            throw new TypeError('bits must be positive integer');\n        }\n        const totalBits = 8 * container.span;\n        const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);\n        if ((bits + usedBits) > totalBits) {\n            throw new Error('bits too long for span remainder ('\n                + (totalBits - usedBits) + ' of '\n                + totalBits + ' remain)');\n        }\n        /** The {@link BitStructure} instance to which this bit field\n         * belongs. */\n        this.container = container;\n        /** The span of this value in bits. */\n        this.bits = bits;\n        /** A mask of {@link BitField#bits|bits} bits isolating value bits\n         * that fit within the field.\n         *\n         * That is, it masks a value that has not yet been shifted into\n         * position within its containing packed integer. */\n        this.valueMask = (1 << bits) - 1;\n        if (32 === bits) { // shifted value out of range\n            this.valueMask = 0xFFFFFFFF;\n        }\n        /** The offset of the value within the containing packed unsigned\n         * integer.  The least significant bit of the packed value is at\n         * offset zero, regardless of bit ordering used. */\n        this.start = usedBits;\n        if (this.container.msb) {\n            this.start = totalBits - usedBits - bits;\n        }\n        /** A mask of {@link BitField#bits|bits} isolating the field value\n         * within the containing packed unsigned integer. */\n        this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n        /** The property name used when this bitfield is represented in an\n         * Object.\n         *\n         * Intended to be functionally equivalent to {@link\n         * Layout#property}.\n         *\n         * If left undefined the corresponding span of bits will be\n         * treated as padding: it will not be mutated by {@link\n         * Layout#encode|encode} nor represented as a property in the\n         * decoded Object. */\n        this.property = property;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field. */\n    decode(b, offset) {\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(word & this.wordMask);\n        const value = wordValue >>> this.start;\n        return value;\n    }\n    /** Store a value into the corresponding subsequence of the containing\n     * bit field.\n     *\n     * **NOTE** This is not a specialization of {@link\n     * Layout#encode|Layout.encode} and there is no return value. */\n    encode(value) {\n        if ('number' !== typeof value\n            || !Number.isInteger(value)\n            || (value !== fixBitwiseResult(value & this.valueMask))) {\n            throw new TypeError(nameWithProperty('BitField.encode', this)\n                + ' value must be integer not exceeding ' + this.valueMask);\n        }\n        const word = this.container._packedGetValue();\n        const wordValue = fixBitwiseResult(value << this.start);\n        this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask)\n            | wordValue);\n    }\n}\nexports.BitField = BitField;\n/**\n * Represent a single bit within a {@link BitStructure} as a\n * JavaScript boolean.\n *\n * **NOTE** User code should not invoke this constructor directly.\n * Use the container {@link BitStructure#addBoolean|addBoolean} helper\n * method.\n *\n * @param {BitStructure} container - initializer for {@link\n * BitField#container|container}.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {BitField}\n */\n/* eslint-disable no-extend-native */\nclass Boolean extends BitField {\n    constructor(container, property) {\n        super(container, 1, property);\n    }\n    /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n     *\n     * @returns {boolean} */\n    decode(b, offset) {\n        return !!super.decode(b, offset);\n    }\n    /** @override */\n    encode(value) {\n        if ('boolean' === typeof value) {\n            // BitField requires integer values\n            value = +value;\n        }\n        super.encode(value);\n    }\n}\nexports.Boolean = Boolean;\n/* eslint-enable no-extend-native */\n/**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Uint8Array.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Blob extends Layout {\n    constructor(length, property) {\n        if (!(((length instanceof ExternalLayout) && length.isCount())\n            || (Number.isInteger(length) && (0 <= length)))) {\n            throw new TypeError('length must be positive integer '\n                + 'or an unsigned integer ExternalLayout');\n        }\n        let span = -1;\n        if (!(length instanceof ExternalLayout)) {\n            span = length;\n        }\n        super(span, property);\n        /** The number of bytes in the blob.\n         *\n         * This may be a non-negative integer, or an instance of {@link\n         * ExternalLayout} that satisfies {@link\n         * ExternalLayout#isCount|isCount()}. */\n        this.length = length;\n    }\n    /** @override */\n    getSpan(b, offset) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return span;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        let span = this.span;\n        if (0 > span) {\n            span = this.length.decode(b, offset);\n        }\n        return uint8ArrayToBuffer(b).slice(offset, offset + span);\n    }\n    /** Implement {@link Layout#encode|encode} for {@link Blob}.\n     *\n     * **NOTE** If {@link Layout#count|count} is an instance of {@link\n     * ExternalLayout} then the length of `src` will be encoded as the\n     * count after `src` is encoded. */\n    encode(src, b, offset) {\n        let span = this.length;\n        if (this.length instanceof ExternalLayout) {\n            span = src.length;\n        }\n        if (!(src instanceof Uint8Array && span === src.length)) {\n            throw new TypeError(nameWithProperty('Blob.encode', this)\n                + ' requires (length ' + span + ') Uint8Array as src');\n        }\n        if ((offset + span) > b.length) {\n            throw new RangeError('encoding overruns Uint8Array');\n        }\n        const srcBuffer = uint8ArrayToBuffer(src);\n        uint8ArrayToBuffer(b).write(srcBuffer.toString('hex'), offset, span, 'hex');\n        if (this.length instanceof ExternalLayout) {\n            this.length.encode(span, b, offset);\n        }\n        return span;\n    }\n}\nexports.Blob = Blob;\n/**\n * Contain a `NUL`-terminated UTF8 string.\n *\n * *Factory*: {@link module:Layout.cstr|cstr}\n *\n * **NOTE** Any UTF8 string that incorporates a zero-valued byte will\n * not be correctly decoded by this layout.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass CString extends Layout {\n    constructor(property) {\n        super(-1, property);\n    }\n    /** @override */\n    getSpan(b, offset = 0) {\n        checkUint8Array(b);\n        let idx = offset;\n        while ((idx < b.length) && (0 !== b[idx])) {\n            idx += 1;\n        }\n        return 1 + idx - offset;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const span = this.getSpan(b, offset);\n        return uint8ArrayToBuffer(b).slice(offset, offset + span - 1).toString('utf-8');\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        /* Must force this to a string, lest it be a number and the\n         * \"utf8-encoding\" below actually allocate a buffer of length\n         * src */\n        if ('string' !== typeof src) {\n            src = String(src);\n        }\n        const srcb = buffer_1.Buffer.from(src, 'utf8');\n        const span = srcb.length;\n        if ((offset + span) > b.length) {\n            throw new RangeError('encoding overruns Buffer');\n        }\n        const buffer = uint8ArrayToBuffer(b);\n        srcb.copy(buffer, offset);\n        buffer[offset + span] = 0;\n        return span + 1;\n    }\n}\nexports.CString = CString;\n/**\n * Contain a UTF8 string with implicit length.\n *\n * *Factory*: {@link module:Layout.utf8|utf8}\n *\n * **NOTE** Because the length is implicit in the size of the buffer\n * this layout should be used only in isolation, or in a situation\n * where the length can be expressed by operating on a slice of the\n * containing buffer.\n *\n * @param {Number} [maxSpan] - the maximum length allowed for encoded\n * string content.  If not provided there is no bound on the allowed\n * content.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UTF8 extends Layout {\n    constructor(maxSpan, property) {\n        if (('string' === typeof maxSpan) && (undefined === property)) {\n            property = maxSpan;\n            maxSpan = undefined;\n        }\n        if (undefined === maxSpan) {\n            maxSpan = -1;\n        }\n        else if (!Number.isInteger(maxSpan)) {\n            throw new TypeError('maxSpan must be an integer');\n        }\n        super(-1, property);\n        /** The maximum span of the layout in bytes.\n         *\n         * Positive values are generally expected.  Zero is abnormal.\n         * Attempts to encode or decode a value that exceeds this length\n         * will throw a `RangeError`.\n         *\n         * A negative value indicates that there is no bound on the length\n         * of the content. */\n        this.maxSpan = maxSpan;\n    }\n    /** @override */\n    getSpan(b, offset = 0) {\n        checkUint8Array(b);\n        return b.length - offset;\n    }\n    /** @override */\n    decode(b, offset = 0) {\n        const span = this.getSpan(b, offset);\n        if ((0 <= this.maxSpan)\n            && (this.maxSpan < span)) {\n            throw new RangeError('text length exceeds maxSpan');\n        }\n        return uint8ArrayToBuffer(b).slice(offset, offset + span).toString('utf-8');\n    }\n    /** @override */\n    encode(src, b, offset = 0) {\n        /* Must force this to a string, lest it be a number and the\n         * \"utf8-encoding\" below actually allocate a buffer of length\n         * src */\n        if ('string' !== typeof src) {\n            src = String(src);\n        }\n        const srcb = buffer_1.Buffer.from(src, 'utf8');\n        const span = srcb.length;\n        if ((0 <= this.maxSpan)\n            && (this.maxSpan < span)) {\n            throw new RangeError('text length exceeds maxSpan');\n        }\n        if ((offset + span) > b.length) {\n            throw new RangeError('encoding overruns Buffer');\n        }\n        srcb.copy(uint8ArrayToBuffer(b), offset);\n        return span;\n    }\n}\nexports.UTF8 = UTF8;\n/**\n * Contain a constant value.\n *\n * This layout may be used in cases where a JavaScript value can be\n * inferred without an expression in the binary encoding.  An example\n * would be a {@link VariantLayout|variant layout} where the content\n * is implied by the union {@link Union#discriminator|discriminator}.\n *\n * @param {Object|Number|String} value - initializer for {@link\n * Constant#value|value}.  If the value is an object (or array) and\n * the application intends the object to remain unchanged regardless\n * of what is done to values decoded by this layout, the value should\n * be frozen prior passing it to this constructor.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Constant extends Layout {\n    constructor(value, property) {\n        super(0, property);\n        /** The value produced by this constant when the layout is {@link\n         * Constant#decode|decoded}.\n         *\n         * Any JavaScript value including `null` and `undefined` is\n         * permitted.\n         *\n         * **WARNING** If `value` passed in the constructor was not\n         * frozen, it is possible for users of decoded values to change\n         * the content of the value. */\n        this.value = value;\n    }\n    /** @override */\n    decode(b, offset) {\n        return this.value;\n    }\n    /** @override */\n    encode(src, b, offset) {\n        /* Constants take no space */\n        return 0;\n    }\n}\nexports.Constant = Constant;\n/** Factory for {@link GreedyCount}. */\nexports.greedy = ((elementSpan, property) => new GreedyCount(elementSpan, property));\n/** Factory for {@link OffsetLayout}. */\nexports.offset = ((layout, offset, property) => new OffsetLayout(layout, offset, property));\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */\nexports.u8 = ((property) => new UInt(1, property));\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16 = ((property) => new UInt(2, property));\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24 = ((property) => new UInt(3, property));\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32 = ((property) => new UInt(4, property));\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40 = ((property) => new UInt(5, property));\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48 = ((property) => new UInt(6, property));\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64 = ((property) => new NearUInt64(property));\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning two bytes. */\nexports.u16be = ((property) => new UIntBE(2, property));\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning three bytes. */\nexports.u24be = ((property) => new UIntBE(3, property));\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning four bytes. */\nexports.u32be = ((property) => new UIntBE(4, property));\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning five bytes. */\nexports.u40be = ((property) => new UIntBE(5, property));\n/** Factory for {@link UInt|big-endian unsigned int layouts}\n * spanning six bytes. */\nexports.u48be = ((property) => new UIntBE(6, property));\n/** Factory for {@link NearUInt64BE|big-endian unsigned int\n * layouts} interpreted as Numbers. */\nexports.nu64be = ((property) => new NearUInt64BE(property));\n/** Factory for {@link Int|signed int layouts} spanning one\n * byte. */\nexports.s8 = ((property) => new Int(1, property));\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning two bytes. */\nexports.s16 = ((property) => new Int(2, property));\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning three bytes. */\nexports.s24 = ((property) => new Int(3, property));\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning four bytes. */\nexports.s32 = ((property) => new Int(4, property));\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning five bytes. */\nexports.s40 = ((property) => new Int(5, property));\n/** Factory for {@link Int|little-endian signed int layouts}\n * spanning six bytes. */\nexports.s48 = ((property) => new Int(6, property));\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64 = ((property) => new NearInt64(property));\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning two bytes. */\nexports.s16be = ((property) => new IntBE(2, property));\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning three bytes. */\nexports.s24be = ((property) => new IntBE(3, property));\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning four bytes. */\nexports.s32be = ((property) => new IntBE(4, property));\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning five bytes. */\nexports.s40be = ((property) => new IntBE(5, property));\n/** Factory for {@link Int|big-endian signed int layouts}\n * spanning six bytes. */\nexports.s48be = ((property) => new IntBE(6, property));\n/** Factory for {@link NearInt64BE|big-endian signed int layouts}\n * interpreted as Numbers. */\nexports.ns64be = ((property) => new NearInt64BE(property));\n/** Factory for {@link Float|little-endian 32-bit floating point} values. */\nexports.f32 = ((property) => new Float(property));\n/** Factory for {@link FloatBE|big-endian 32-bit floating point} values. */\nexports.f32be = ((property) => new FloatBE(property));\n/** Factory for {@link Double|little-endian 64-bit floating point} values. */\nexports.f64 = ((property) => new Double(property));\n/** Factory for {@link DoubleBE|big-endian 64-bit floating point} values. */\nexports.f64be = ((property) => new DoubleBE(property));\n/** Factory for {@link Structure} values. */\nexports.struct = ((fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes));\n/** Factory for {@link BitStructure} values. */\nexports.bits = ((word, msb, property) => new BitStructure(word, msb, property));\n/** Factory for {@link Sequence} values. */\nexports.seq = ((elementLayout, count, property) => new Sequence(elementLayout, count, property));\n/** Factory for {@link Union} values. */\nexports.union = ((discr, defaultLayout, property) => new Union(discr, defaultLayout, property));\n/** Factory for {@link UnionLayoutDiscriminator} values. */\nexports.unionLayoutDiscriminator = ((layout, property) => new UnionLayoutDiscriminator(layout, property));\n/** Factory for {@link Blob} values. */\nexports.blob = ((length, property) => new Blob(length, property));\n/** Factory for {@link CString} values. */\nexports.cstr = ((property) => new CString(property));\n/** Factory for {@link UTF8} values. */\nexports.utf8 = ((maxSpan, property) => new UTF8(maxSpan, property));\n/** Factory for {@link Constant} values. */\nexports.constant = ((value, property) => new Constant(value, property));\n//# sourceMappingURL=Layout.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL2J1ZmZlci1sYXlvdXQvbGliL0xheW91dC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQ0FBbUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sYUFBYSxNQUFNLDZCQUE2QixHQUFHO0FBQ25ELDhCQUE4QixHQUFHLCtCQUErQjtBQUNoRSxNQUFNLCtCQUErQixHQUFHO0FBQ3hDLDhCQUE4QixPQUFPO0FBQ3JDO0FBQ0EsTUFBTTtBQUNOLGFBQWEsTUFBTSxpQ0FBaUMsR0FBRztBQUN2RCxnQ0FBZ0MsR0FBRyxpQ0FBaUM7QUFDcEUsTUFBTSxpQ0FBaUMsT0FBTztBQUM5QyxpQ0FBaUM7QUFDakMsTUFBTTtBQUNOLGFBQWEsTUFBTSw2QkFBNkIsR0FBRztBQUNuRCw4QkFBOEIsR0FBRywrQkFBK0I7QUFDaEUsTUFBTSwrQkFBK0IsR0FBRztBQUN4Qyw4QkFBOEIsT0FBTztBQUNyQztBQUNBLE1BQU07QUFDTixXQUFXLGlDQUFpQyxHQUFHO0FBQy9DLGdDQUFnQyxHQUFHLGlDQUFpQztBQUNwRSxNQUFNLGlDQUFpQyxPQUFPO0FBQzlDLGlDQUFpQztBQUNqQztBQUNBLG1EQUFtRDtBQUNuRCwrQ0FBK0MsR0FBRztBQUNsRCw4Q0FBOEMsR0FBRztBQUNqRCw2Q0FBNkMsT0FBTztBQUNwRCwrQ0FBK0M7QUFDL0Msd0NBQXdDO0FBQ3hDLHNDQUFzQyxLQUFLO0FBQzNDLHFDQUFxQztBQUNyQyx3Q0FBd0M7QUFDeEMsc0NBQXNDLEtBQUs7QUFDM0MscUNBQXFDO0FBQ3JDLE1BQU0scUNBQXFDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLE1BQU0s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QVc7QUFDWCxpQkFBaUIsZ0RBQWdEO0FBQ2pFLGFBQWE7QUFDYixpQkFBaUIsa0RBQWtEO0FBQ25FLFdBQVc7QUFDWCxpQkFBaUIsaURBQWlEO0FBQ2xFLGFBQWE7QUFDYixpQkFBaUIsaUJBQWlCO0FBQ2xDLGNBQWM7QUFDZCxpQkFBaUIsb0JBQW9CO0FBQ3JDLFlBQVk7QUFDWixpQkFBaUIsZ0JBQWdCO0FBQ2pDLFdBQVc7QUFDWCxpQkFBaUIsYUFBYTtBQUM5QixhQUFhO0FBQ2IsaUJBQWlCLGdDQUFnQztBQUNqRCxnQ0FBZ0M7QUFDaEMsaUJBQWlCLFlBQVk7QUFDN0IsWUFBWTtBQUNaLGlCQUFpQixlQUFlO0FBQ2hDLFlBQVk7QUFDWixpQkFBaUIsWUFBWTtBQUM3QixZQUFZO0FBQ1osaUJBQWlCLGdCQUFnQjtBQUNqQyxnQkFBZ0I7QUFDaEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvYnVmZmVyLWxheW91dC9saWIvTGF5b3V0LmpzPzNhNGQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IDIwMTUtMjAxOCBQZXRlciBBLiBCaWdvdFxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cbi8qKlxuICogU3VwcG9ydCBmb3IgdHJhbnNsYXRpbmcgYmV0d2VlbiBVaW50OEFycmF5IGluc3RhbmNlcyBhbmQgSmF2YVNjcmlwdFxuICogbmF0aXZlIHR5cGVzLlxuICpcbiAqIHtAbGluayBtb2R1bGU6TGF5b3V0fkxheW91dHxMYXlvdXR9IGlzIHRoZSBiYXNpcyBvZiBhIGNsYXNzXG4gKiBoaWVyYXJjaHkgdGhhdCBhc3NvY2lhdGVzIHByb3BlcnR5IG5hbWVzIHdpdGggc2VxdWVuY2VzIG9mIGVuY29kZWRcbiAqIGJ5dGVzLlxuICpcbiAqIExheW91dHMgYXJlIHN1cHBvcnRlZCBmb3IgdGhlc2Ugc2NhbGFyIChudW1lcmljKSB0eXBlczpcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXR+VUludHxVbnNpZ25lZCBpbnRlZ2VycyBpbiBsaXR0bGUtZW5kaWFuXG4gKiAgIGZvcm1hdH0gd2l0aCB7QGxpbmsgbW9kdWxlOkxheW91dC51OHw4LWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnUxNnwxNi1iaXR9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51MjR8MjQtYml0fSxcbiAqICAge0BsaW5rIG1vZHVsZTpMYXlvdXQudTMyfDMyLWJpdH0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnU0MHw0MC1iaXR9LCBhbmQge0BsaW5rIG1vZHVsZTpMYXlvdXQudTQ4fDQ4LWJpdH1cbiAqICAgcmVwcmVzZW50YXRpb24gcmFuZ2VzO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dH5VSW50QkV8VW5zaWduZWQgaW50ZWdlcnMgaW4gYmlnLWVuZGlhblxuICogICBmb3JtYXR9IHdpdGgge0BsaW5rIG1vZHVsZTpMYXlvdXQudTE2YmV8MTYtYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQudTI0YmV8MjQtYml0fSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTMyYmV8MzItYml0fSxcbiAqICAge0BsaW5rIG1vZHVsZTpMYXlvdXQudTQwYmV8NDAtYml0fSwgYW5kIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnU0OGJlfDQ4LWJpdH0gcmVwcmVzZW50YXRpb24gcmFuZ2VzO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dH5JbnR8U2lnbmVkIGludGVnZXJzIGluIGxpdHRsZS1lbmRpYW5cbiAqICAgZm9ybWF0fSB3aXRoIHtAbGluayBtb2R1bGU6TGF5b3V0LnM4fDgtYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuczE2fDE2LWJpdH0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnMyNHwyNC1iaXR9LFxuICogICB7QGxpbmsgbW9kdWxlOkxheW91dC5zMzJ8MzItYml0fSwge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuczQwfDQwLWJpdH0sIGFuZCB7QGxpbmsgbW9kdWxlOkxheW91dC5zNDh8NDgtYml0fVxuICogICByZXByZXNlbnRhdGlvbiByYW5nZXM7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0fkludEJFfFNpZ25lZCBpbnRlZ2VycyBpbiBiaWctZW5kaWFuIGZvcm1hdH1cbiAqICAgd2l0aCB7QGxpbmsgbW9kdWxlOkxheW91dC5zMTZiZXwxNi1iaXR9LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5zMjRiZXwyNC1iaXR9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zMzJiZXwzMi1iaXR9LFxuICogICB7QGxpbmsgbW9kdWxlOkxheW91dC5zNDBiZXw0MC1iaXR9LCBhbmQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuczQ4YmV8NDgtYml0fSByZXByZXNlbnRhdGlvbiByYW5nZXM7XG4gKiAqIDY0LWJpdCBpbnRlZ3JhbCB2YWx1ZXMgdGhhdCBkZWNvZGUgdG8gYW4gZXhhY3QgKGlmIG1hZ25pdHVkZSBpc1xuICogICBsZXNzIHRoYW4gMl41Mykgb3IgbmVhcmJ5IGludGVncmFsIE51bWJlciBpbiB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5udTY0fHVuc2lnbmVkIGxpdHRsZS1lbmRpYW59LCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5udTY0YmV8dW5zaWduZWQgYmlnLWVuZGlhbn0sIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0Lm5zNjR8c2lnbmVkIGxpdHRsZS1lbmRpYW59LCBhbmQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQubnM2NGJlfHVuc2lnbmVkIGJpZy1lbmRpYW59IGVuY29kaW5ncztcbiAqICogMzItYml0IGZsb2F0aW5nIHBvaW50IHZhbHVlcyB3aXRoIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LmYzMnxsaXR0bGUtZW5kaWFufSBhbmQge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuZjMyYmV8YmlnLWVuZGlhbn0gcmVwcmVzZW50YXRpb25zO1xuICogKiA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgdmFsdWVzIHdpdGgge0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXQuZjY0fGxpdHRsZS1lbmRpYW59IGFuZCB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dC5mNjRiZXxiaWctZW5kaWFufSByZXByZXNlbnRhdGlvbnM7XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LmNvbnN0fENvbnN0YW50c30gdGhhdCB0YWtlIG5vIHNwYWNlIGluIHRoZVxuICogICBlbmNvZGVkIGV4cHJlc3Npb24uXG4gKlxuICogYW5kIGZvciB0aGVzZSBhZ2dyZWdhdGUgdHlwZXM6XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LnNlcXxTZXF1ZW5jZX1zIG9mIGluc3RhbmNlcyBvZiBhIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0fkxheW91dHxMYXlvdXR9LCB3aXRoIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gYXNcbiAqICAgYW4gQXJyYXkgYW5kIGNvbnN0YW50IG9yIGRhdGEtZGVwZW5kZW50IHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0flNlcXVlbmNlI2NvdW50fGxlbmd0aH07XG4gKiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LnN0cnVjdHxTdHJ1Y3R1cmV9cyB0aGF0IGFnZ3JlZ2F0ZSBhXG4gKiAgIGhldGVyb2dlbmVvdXMgc2VxdWVuY2Ugb2Yge0BsaW5rIG1vZHVsZTpMYXlvdXR+TGF5b3V0fExheW91dH1cbiAqICAgaW5zdGFuY2VzLCB3aXRoIEphdmFTY3JpcHQgcmVwcmVzZW50YXRpb24gYXMgYW4gT2JqZWN0O1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC51bmlvbnxVbmlvbn1zIHRoYXQgc3VwcG9ydCBtdWx0aXBsZSB7QGxpbmtcbiAqICAgbW9kdWxlOkxheW91dH5WYXJpYW50TGF5b3V0fHZhcmlhbnQgbGF5b3V0c30gb3ZlciBhIGZpeGVkXG4gKiAgIChwYWRkZWQpIG9yIHZhcmlhYmxlIChub3QgcGFkZGVkKSBzcGFuIG9mIGJ5dGVzLCB1c2luZyBhblxuICogICB1bnNpZ25lZCBpbnRlZ2VyIGF0IHRoZSBzdGFydCBvZiB0aGUgZGF0YSBvciBhIHNlcGFyYXRlIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0LnVuaW9uTGF5b3V0RGlzY3JpbWluYXRvcnxsYXlvdXQgZWxlbWVudH0gdG9cbiAqICAgZGV0ZXJtaW5lIHdoaWNoIGxheW91dCB0byB1c2Ugd2hlbiBpbnRlcnByZXRpbmcgdGhlIGJ1ZmZlclxuICogICBjb250ZW50cztcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuYml0c3xCaXRTdHJ1Y3R1cmV9cyB0aGF0IGNvbnRhaW4gYSBzZXF1ZW5jZVxuICogICBvZiBpbmRpdmlkdWFsIHtAbGlua1xuICogICBtb2R1bGU6TGF5b3V0fkJpdFN0cnVjdHVyZSNhZGRGaWVsZHxCaXRGaWVsZH1zIHBhY2tlZCBpbnRvIGFuIDgsXG4gKiAgIDE2LCAyNCwgb3IgMzItYml0IHVuc2lnbmVkIGludGVnZXIgc3RhcnRpbmcgYXQgdGhlIGxlYXN0LSBvclxuICogICBtb3N0LXNpZ25pZmljYW50IGJpdDtcbiAqICoge0BsaW5rIG1vZHVsZTpMYXlvdXQuY3N0cnxDIHN0cmluZ3N9IG9mIHZhcnlpbmcgbGVuZ3RoO1xuICogKiB7QGxpbmsgbW9kdWxlOkxheW91dC5ibG9ifEJsb2JzfSBvZiBmaXhlZC0gb3IgdmFyaWFibGUte0BsaW5rXG4gKiAgIG1vZHVsZTpMYXlvdXR+QmxvYiNsZW5ndGh8bGVuZ3RofSByYXcgZGF0YS5cbiAqXG4gKiBBbGwge0BsaW5rIG1vZHVsZTpMYXlvdXR+TGF5b3V0fExheW91dH0gaW5zdGFuY2VzIGFyZSBpbW11dGFibGVcbiAqIGFmdGVyIGNvbnN0cnVjdGlvbiwgdG8gcHJldmVudCBpbnRlcm5hbCBzdGF0ZSBmcm9tIGJlY29taW5nXG4gKiBpbmNvbnNpc3RlbnQuXG4gKlxuICogQGxvY2FsIExheW91dFxuICogQGxvY2FsIEV4dGVybmFsTGF5b3V0XG4gKiBAbG9jYWwgR3JlZWR5Q291bnRcbiAqIEBsb2NhbCBPZmZzZXRMYXlvdXRcbiAqIEBsb2NhbCBVSW50XG4gKiBAbG9jYWwgVUludEJFXG4gKiBAbG9jYWwgSW50XG4gKiBAbG9jYWwgSW50QkVcbiAqIEBsb2NhbCBOZWFyVUludDY0XG4gKiBAbG9jYWwgTmVhclVJbnQ2NEJFXG4gKiBAbG9jYWwgTmVhckludDY0XG4gKiBAbG9jYWwgTmVhckludDY0QkVcbiAqIEBsb2NhbCBGbG9hdFxuICogQGxvY2FsIEZsb2F0QkVcbiAqIEBsb2NhbCBEb3VibGVcbiAqIEBsb2NhbCBEb3VibGVCRVxuICogQGxvY2FsIFNlcXVlbmNlXG4gKiBAbG9jYWwgU3RydWN0dXJlXG4gKiBAbG9jYWwgVW5pb25EaXNjcmltaW5hdG9yXG4gKiBAbG9jYWwgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yXG4gKiBAbG9jYWwgVW5pb25cbiAqIEBsb2NhbCBWYXJpYW50TGF5b3V0XG4gKiBAbG9jYWwgQml0U3RydWN0dXJlXG4gKiBAbG9jYWwgQml0RmllbGRcbiAqIEBsb2NhbCBCb29sZWFuXG4gKiBAbG9jYWwgQmxvYlxuICogQGxvY2FsIENTdHJpbmdcbiAqIEBsb2NhbCBDb25zdGFudFxuICogQGxvY2FsIGJpbmRDb25zdHJ1Y3RvckxheW91dFxuICogQG1vZHVsZSBMYXlvdXRcbiAqIEBsaWNlbnNlIE1JVFxuICogQGF1dGhvciBQZXRlciBBLiBCaWdvdFxuICogQHNlZSB7QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL3BhYmlnb3QvYnVmZmVyLWxheW91dHxidWZmZXItbGF5b3V0IG9uIEdpdEh1Yn1cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zMTYgPSBleHBvcnRzLnM4ID0gZXhwb3J0cy5udTY0YmUgPSBleHBvcnRzLnU0OGJlID0gZXhwb3J0cy51NDBiZSA9IGV4cG9ydHMudTMyYmUgPSBleHBvcnRzLnUyNGJlID0gZXhwb3J0cy51MTZiZSA9IGV4cG9ydHMubnU2NCA9IGV4cG9ydHMudTQ4ID0gZXhwb3J0cy51NDAgPSBleHBvcnRzLnUzMiA9IGV4cG9ydHMudTI0ID0gZXhwb3J0cy51MTYgPSBleHBvcnRzLnU4ID0gZXhwb3J0cy5vZmZzZXQgPSBleHBvcnRzLmdyZWVkeSA9IGV4cG9ydHMuQ29uc3RhbnQgPSBleHBvcnRzLlVURjggPSBleHBvcnRzLkNTdHJpbmcgPSBleHBvcnRzLkJsb2IgPSBleHBvcnRzLkJvb2xlYW4gPSBleHBvcnRzLkJpdEZpZWxkID0gZXhwb3J0cy5CaXRTdHJ1Y3R1cmUgPSBleHBvcnRzLlZhcmlhbnRMYXlvdXQgPSBleHBvcnRzLlVuaW9uID0gZXhwb3J0cy5VbmlvbkxheW91dERpc2NyaW1pbmF0b3IgPSBleHBvcnRzLlVuaW9uRGlzY3JpbWluYXRvciA9IGV4cG9ydHMuU3RydWN0dXJlID0gZXhwb3J0cy5TZXF1ZW5jZSA9IGV4cG9ydHMuRG91YmxlQkUgPSBleHBvcnRzLkRvdWJsZSA9IGV4cG9ydHMuRmxvYXRCRSA9IGV4cG9ydHMuRmxvYXQgPSBleHBvcnRzLk5lYXJJbnQ2NEJFID0gZXhwb3J0cy5OZWFySW50NjQgPSBleHBvcnRzLk5lYXJVSW50NjRCRSA9IGV4cG9ydHMuTmVhclVJbnQ2NCA9IGV4cG9ydHMuSW50QkUgPSBleHBvcnRzLkludCA9IGV4cG9ydHMuVUludEJFID0gZXhwb3J0cy5VSW50ID0gZXhwb3J0cy5PZmZzZXRMYXlvdXQgPSBleHBvcnRzLkdyZWVkeUNvdW50ID0gZXhwb3J0cy5FeHRlcm5hbExheW91dCA9IGV4cG9ydHMuYmluZENvbnN0cnVjdG9yTGF5b3V0ID0gZXhwb3J0cy5uYW1lV2l0aFByb3BlcnR5ID0gZXhwb3J0cy5MYXlvdXQgPSBleHBvcnRzLnVpbnQ4QXJyYXlUb0J1ZmZlciA9IGV4cG9ydHMuY2hlY2tVaW50OEFycmF5ID0gdm9pZCAwO1xuZXhwb3J0cy5jb25zdGFudCA9IGV4cG9ydHMudXRmOCA9IGV4cG9ydHMuY3N0ciA9IGV4cG9ydHMuYmxvYiA9IGV4cG9ydHMudW5pb25MYXlvdXREaXNjcmltaW5hdG9yID0gZXhwb3J0cy51bmlvbiA9IGV4cG9ydHMuc2VxID0gZXhwb3J0cy5iaXRzID0gZXhwb3J0cy5zdHJ1Y3QgPSBleHBvcnRzLmY2NGJlID0gZXhwb3J0cy5mNjQgPSBleHBvcnRzLmYzMmJlID0gZXhwb3J0cy5mMzIgPSBleHBvcnRzLm5zNjRiZSA9IGV4cG9ydHMuczQ4YmUgPSBleHBvcnRzLnM0MGJlID0gZXhwb3J0cy5zMzJiZSA9IGV4cG9ydHMuczI0YmUgPSBleHBvcnRzLnMxNmJlID0gZXhwb3J0cy5uczY0ID0gZXhwb3J0cy5zNDggPSBleHBvcnRzLnM0MCA9IGV4cG9ydHMuczMyID0gZXhwb3J0cy5zMjQgPSB2b2lkIDA7XG5jb25zdCBidWZmZXJfMSA9IHJlcXVpcmUoXCJidWZmZXJcIik7XG4vKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgVWludDhBcnJheS5cbiAqXG4gKiBAaWdub3JlICovXG5mdW5jdGlvbiBjaGVja1VpbnQ4QXJyYXkoYikge1xuICAgIGlmICghKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiIG11c3QgYmUgYSBVaW50OEFycmF5Jyk7XG4gICAgfVxufVxuZXhwb3J0cy5jaGVja1VpbnQ4QXJyYXkgPSBjaGVja1VpbnQ4QXJyYXk7XG4vKiBDcmVhdGUgYSBCdWZmZXIgaW5zdGFuY2UgZnJvbSBhIFVpbnQ4QXJyYXkuXG4gKlxuICogQGlnbm9yZSAqL1xuZnVuY3Rpb24gdWludDhBcnJheVRvQnVmZmVyKGIpIHtcbiAgICBjaGVja1VpbnQ4QXJyYXkoYik7XG4gICAgcmV0dXJuIGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKGIuYnVmZmVyLCBiLmJ5dGVPZmZzZXQsIGIubGVuZ3RoKTtcbn1cbmV4cG9ydHMudWludDhBcnJheVRvQnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBsYXlvdXQgb2JqZWN0cy5cbiAqXG4gKiAqKk5PVEUqKiBUaGlzIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3M7IHlvdSBjYW4gY3JlYXRlIGluc3RhbmNlc1xuICogaWYgaXQgYW11c2VzIHlvdSwgYnV0IHRoZXkgd29uJ3Qgc3VwcG9ydCB0aGUge0BsaW5rXG4gKiBMYXlvdXQjZW5jb2RlfGVuY29kZX0gb3Ige0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfSBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBJbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LiAgVGhlXG4gKiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnRlZ2VyOyBhIG5lZ2F0aXZlIHZhbHVlIHNpZ25pZmllcyB0aGF0IHRoZVxuICogc3BhbiBpcyB7QGxpbmsgTGF5b3V0I2dldFNwYW58dmFsdWUtc3BlY2lmaWN9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gSW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuY2xhc3MgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIoc3BhbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NwYW4gbXVzdCBiZSBhbiBpbnRlZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIFRoZSBzcGFuIG9mIHRoZSBsYXlvdXQgaW4gYnl0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBvc2l0aXZlIHZhbHVlcyBhcmUgZ2VuZXJhbGx5IGV4cGVjdGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBaZXJvIHdpbGwgb25seSBhcHBlYXIgaW4ge0BsaW5rIENvbnN0YW50fXMgYW5kIGluIHtAbGlua1xuICAgICAgICAgKiBTZXF1ZW5jZX1zIHdoZXJlIHRoZSB7QGxpbmsgU2VxdWVuY2UjY291bnR8Y291bnR9IGlzIHplcm8uXG4gICAgICAgICAqXG4gICAgICAgICAqIEEgbmVnYXRpdmUgdmFsdWUgaW5kaWNhdGVzIHRoYXQgdGhlIHNwYW4gaXMgdmFsdWUtc3BlY2lmaWMsIGFuZFxuICAgICAgICAgKiBtdXN0IGJlIG9idGFpbmVkIHVzaW5nIHtAbGluayBMYXlvdXQjZ2V0U3BhbnxnZXRTcGFufS4gKi9cbiAgICAgICAgdGhpcy5zcGFuID0gc3BhbjtcbiAgICAgICAgLyoqIFRoZSBwcm9wZXJ0eSBuYW1lIHVzZWQgd2hlbiB0aGlzIGxheW91dCBpcyByZXByZXNlbnRlZCBpbiBhblxuICAgICAgICAgKiBPYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZWQgb25seSBmb3IgbGF5b3V0cyB0aGF0IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gdG8gT2JqZWN0XG4gICAgICAgICAqIGluc3RhbmNlcy4gIElmIGxlZnQgdW5kZWZpbmVkIHRoZSBzcGFuIG9mIHRoZSB1bm5hbWVkIGxheW91dCB3aWxsXG4gICAgICAgICAqIGJlIHRyZWF0ZWQgYXMgcGFkZGluZzogaXQgd2lsbCBub3QgYmUgbXV0YXRlZCBieSB7QGxpbmtcbiAgICAgICAgICogTGF5b3V0I2VuY29kZXxlbmNvZGV9IG5vciByZXByZXNlbnRlZCBhcyBhIHByb3BlcnR5IGluIHRoZVxuICAgICAgICAgKiBkZWNvZGVkIE9iamVjdC4gKi9cbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIH1cbiAgICAvKiogRnVuY3Rpb24gdG8gY3JlYXRlIGFuIE9iamVjdCBpbnRvIHdoaWNoIGRlY29kZWQgcHJvcGVydGllcyB3aWxsXG4gICAgICogYmUgd3JpdHRlbi5cbiAgICAgKlxuICAgICAqIFVzZWQgb25seSBmb3IgbGF5b3V0cyB0aGF0IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gdG8gT2JqZWN0XG4gICAgICogaW5zdGFuY2VzLCB3aGljaCBtZWFuczpcbiAgICAgKiAqIHtAbGluayBTdHJ1Y3R1cmV9XG4gICAgICogKiB7QGxpbmsgVW5pb259XG4gICAgICogKiB7QGxpbmsgVmFyaWFudExheW91dH1cbiAgICAgKiAqIHtAbGluayBCaXRTdHJ1Y3R1cmV9XG4gICAgICpcbiAgICAgKiBJZiBsZWZ0IHVuZGVmaW5lZCB0aGUgSmF2YVNjcmlwdCByZXByZXNlbnRhdGlvbiBvZiB0aGVzZSBsYXlvdXRzXG4gICAgICogd2lsbCBiZSBPYmplY3QgaW5zdGFuY2VzLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBiaW5kQ29uc3RydWN0b3JMYXlvdXR9LlxuICAgICAqL1xuICAgIG1ha2VEZXN0aW5hdGlvbk9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxjdWxhdGUgdGhlIHNwYW4gb2YgYSBzcGVjaWZpYyBpbnN0YW5jZSBvZiBhIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VWludDhBcnJheX0gYiAtIHRoZSBidWZmZXIgdGhhdCBjb250YWlucyBhbiBlbmNvZGVkIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IFtvZmZzZXRdIC0gdGhlIG9mZnNldCBhdCB3aGljaCB0aGUgZW5jb2RlZCBpbnN0YW5jZVxuICAgICAqIHN0YXJ0cy4gIElmIGFic2VudCBhIHplcm8gb2Zmc2V0IGlzIGluZmVycmVkLlxuICAgICAqXG4gICAgICogQHJldHVybiB7TnVtYmVyfSAtIHRoZSBudW1iZXIgb2YgYnl0ZXMgY292ZXJlZCBieSB0aGUgbGF5b3V0XG4gICAgICogaW5zdGFuY2UuICBJZiB0aGlzIG1ldGhvZCBpcyBub3Qgb3ZlcnJpZGRlbiBpbiBhIHN1YmNsYXNzIHRoZVxuICAgICAqIGRlZmluaXRpb24tdGltZSBjb25zdGFudCB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0gd2lsbCBiZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHRocm93cyB7UmFuZ2VFcnJvcn0gLSBpZiB0aGUgbGVuZ3RoIG9mIHRoZSB2YWx1ZSBjYW5ub3QgYmVcbiAgICAgKiBkZXRlcm1pbmVkLlxuICAgICAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0KSB7XG4gICAgICAgIGlmICgwID4gdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXRlcm1pbmF0ZSBzcGFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGljYXRlIHRoZSBsYXlvdXQgdXNpbmcgYSBuZXcgcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgdXNlZCB0byBnZXQgYSBzdHJ1Y3R1cmFsbHktZXF1aXZhbGVudCBsYXlvdXRcbiAgICAgKiB3aXRoIGEgZGlmZmVyZW50IG5hbWUgc2luY2UgYWxsIHtAbGluayBMYXlvdXR9IGluc3RhbmNlcyBhcmVcbiAgICAgKiBpbW11dGFibGUuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBUaGlzIGlzIGEgc2hhbGxvdyBjb3B5LiAgQWxsIGZpZWxkcyBleGNlcHQge0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSBhcmUgc3RyaWN0bHkgZXF1YWwgdG8gdGhlIG9yaWdpbiBsYXlvdXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSB0aGUgdmFsdWUgZm9yIHtAbGlua1xuICAgICAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0gaW4gdGhlIHJlcGxpY2EuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TGF5b3V0fSAtIHRoZSBjb3B5IHdpdGgge0BsaW5rIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX1cbiAgICAgKiBzZXQgdG8gYHByb3BlcnR5YC5cbiAgICAgKi9cbiAgICByZXBsaWNhdGUocHJvcGVydHkpIHtcbiAgICAgICAgY29uc3QgcnYgPSBPYmplY3QuY3JlYXRlKHRoaXMuY29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihydiwgdGhpcyk7XG4gICAgICAgIHJ2LnByb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICAgIHJldHVybiBydjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuIG9iamVjdCBmcm9tIGxheW91dCBwcm9wZXJ0aWVzIGFuZCBhbiBhcnJheSBvZiB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYHVuZGVmaW5lZGAgaWYgaW52b2tlZCBvbiBhIGxheW91dFxuICAgICAqIHRoYXQgZG9lcyBub3QgcmV0dXJuIGl0cyB2YWx1ZSBhcyBhbiBPYmplY3QuICBPYmplY3RzIGFyZVxuICAgICAqIHJldHVybmVkIGZvciB0aGluZ3MgdGhhdCBhcmUgYSB7QGxpbmsgU3RydWN0dXJlfSwgd2hpY2ggaW5jbHVkZXNcbiAgICAgKiB7QGxpbmsgVmFyaWFudExheW91dHx2YXJpYW50IGxheW91dHN9IGlmIHRoZXkgYXJlIHN0cnVjdHVyZXMsIGFuZFxuICAgICAqIGV4Y2x1ZGVzIHtAbGluayBVbmlvbn1zLiAgSWYgeW91IHdhbnQgdGhpcyBmZWF0dXJlIGZvciBhIHVuaW9uXG4gICAgICogeW91IG11c3QgdXNlIHtAbGluayBVbmlvbi5nZXRWYXJpYW50fGdldFZhcmlhbnR9IHRvIHNlbGVjdCB0aGVcbiAgICAgKiBkZXNpcmVkIGxheW91dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyAtIGFuIGFycmF5IG9mIHZhbHVlcyB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlXG4gICAgICogZGVmYXVsdCBvcmRlciBmb3IgcHJvcGVydGllcy4gIEFzIHdpdGgge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlfVxuICAgICAqIGxheW91dCBlbGVtZW50cyB0aGF0IGhhdmUgbm8gcHJvcGVydHkgbmFtZSBhcmUgc2tpcHBlZCB3aGVuXG4gICAgICogaXRlcmF0aW5nIG92ZXIgdGhlIGFycmF5IHZhbHVlcy4gIE9ubHkgdGhlIHRvcC1sZXZlbCBwcm9wZXJ0aWVzIGFyZVxuICAgICAqIGFzc2lnbmVkOyBhcmd1bWVudHMgYXJlIG5vdCBhc3NpZ25lZCB0byBwcm9wZXJ0aWVzIG9mIGNvbnRhaW5lZFxuICAgICAqIGxheW91dHMuICBBbnkgdW51c2VkIHZhbHVlcyBhcmUgaWdub3JlZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4geyhPYmplY3R8dW5kZWZpbmVkKX1cbiAgICAgKi9cbiAgICBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5MYXlvdXQgPSBMYXlvdXQ7XG4vKiBQcm92aWRlIHRleHQgdGhhdCBjYXJyaWVzIGEgbmFtZSAoc3VjaCBhcyBmb3IgYSBmdW5jdGlvbiB0aGF0IHdpbGxcbiAqIGJlIHRocm93aW5nIGFuIGVycm9yKSBhbm5vdGF0ZWQgd2l0aCB0aGUgcHJvcGVydHkgb2YgYSBnaXZlbiBsYXlvdXRcbiAqIChzdWNoIGFzIG9uZSBmb3Igd2hpY2ggdGhlIHZhbHVlIHdhcyB1bmFjY2VwdGFibGUpLlxuICpcbiAqIEBpZ25vcmUgKi9cbmZ1bmN0aW9uIG5hbWVXaXRoUHJvcGVydHkobmFtZSwgbG8pIHtcbiAgICBpZiAobG8ucHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUgKyAnWycgKyBsby5wcm9wZXJ0eSArICddJztcbiAgICB9XG4gICAgcmV0dXJuIG5hbWU7XG59XG5leHBvcnRzLm5hbWVXaXRoUHJvcGVydHkgPSBuYW1lV2l0aFByb3BlcnR5O1xuLyoqXG4gKiBBdWdtZW50IGEgY2xhc3Mgc28gdGhhdCBpbnN0YW5jZXMgY2FuIGJlIGVuY29kZWQvZGVjb2RlZCB1c2luZyBhXG4gKiBnaXZlbiBsYXlvdXQuXG4gKlxuICogQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIGNvdXBsZXMgYENsYXNzYCB3aXRoIGBsYXlvdXRgIGluIHNldmVyYWwgd2F5czpcbiAqXG4gKiAqIGBDbGFzcy5sYXlvdXRfYCBiZWNvbWVzIGEgc3RhdGljIG1lbWJlciBwcm9wZXJ0eSBlcXVhbCB0byBgbGF5b3V0YDtcbiAqICogYGxheW91dC5ib3VuZENvbnN0cnVjdG9yX2AgYmVjb21lcyBhIHN0YXRpYyBtZW1iZXIgcHJvcGVydHkgZXF1YWxcbiAqICAgIHRvIGBDbGFzc2A7XG4gKiAqIFRoZSB7QGxpbmsgTGF5b3V0I21ha2VEZXN0aW5hdGlvbk9iamVjdHxtYWtlRGVzdGluYXRpb25PYmplY3QoKX1cbiAqICAgcHJvcGVydHkgb2YgYGxheW91dGAgaXMgc2V0IHRvIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgYG5ld1xuICogICBDbGFzcygpYDtcbiAqICogYENsYXNzLmRlY29kZShiLCBvZmZzZXQpYCBiZWNvbWVzIGEgc3RhdGljIG1lbWJlciBmdW5jdGlvbiB0aGF0XG4gKiAgIGRlbGVnYXRlcyB0byB7QGxpbmsgTGF5b3V0I2RlY29kZXxsYXlvdXQuZGVjb2RlfS4gIFRoZVxuICogICBzeW50aGVzaXplZCBmdW5jdGlvbiBtYXkgYmUgY2FwdHVyZWQgYW5kIGV4dGVuZGVkLlxuICogKiBgQ2xhc3MucHJvdG90eXBlLmVuY29kZShiLCBvZmZzZXQpYCBwcm92aWRlcyBhbiBpbnN0YW5jZSBtZW1iZXJcbiAqICAgZnVuY3Rpb24gdGhhdCBkZWxlZ2F0ZXMgdG8ge0BsaW5rIExheW91dCNlbmNvZGV8bGF5b3V0LmVuY29kZX1cbiAqICAgd2l0aCBgc3JjYCBzZXQgdG8gYHRoaXNgLiAgVGhlIHN5bnRoZXNpemVkIGZ1bmN0aW9uIG1heSBiZVxuICogICBjYXB0dXJlZCBhbmQgZXh0ZW5kZWQsIGJ1dCB3aGVuIHRoZSBleHRlbnNpb24gaXMgaW52b2tlZCBgdGhpc2BcbiAqICAgbXVzdCBiZSBleHBsaWNpdGx5IGJvdW5kIHRvIHRoZSBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge2NsYXNzfSBDbGFzcyAtIGEgSmF2YVNjcmlwdCBjbGFzcyB3aXRoIGEgbnVsbGFyeVxuICogY29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIHtMYXlvdXR9IGxheW91dCAtIHRoZSB7QGxpbmsgTGF5b3V0fSBpbnN0YW5jZSB1c2VkIHRvIGVuY29kZVxuICogaW5zdGFuY2VzIG9mIGBDbGFzc2AuXG4gKi9cbi8vIGBDbGFzc2AgbXVzdCBiZSBhIGNvbnN0cnVjdG9yIEZ1bmN0aW9uLCBidXQgdGhlIGFzc2lnbm1lbnQgb2YgYSBgbGF5b3V0X2AgcHJvcGVydHkgdG8gaXQgbWFrZXMgaXQgZGlmZmljdWx0IHRvIHR5cGVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG5mdW5jdGlvbiBiaW5kQ29uc3RydWN0b3JMYXlvdXQoQ2xhc3MsIGxheW91dCkge1xuICAgIGlmICgnZnVuY3Rpb24nICE9PSB0eXBlb2YgQ2xhc3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQ2xhc3MgbXVzdCBiZSBjb25zdHJ1Y3RvcicpO1xuICAgIH1cbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKENsYXNzLCAnbGF5b3V0XycpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2xhc3MgaXMgYWxyZWFkeSBib3VuZCB0byBhIGxheW91dCcpO1xuICAgIH1cbiAgICBpZiAoIShsYXlvdXQgJiYgKGxheW91dCBpbnN0YW5jZW9mIExheW91dCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobGF5b3V0LCAnYm91bmRDb25zdHJ1Y3Rvcl8nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2xheW91dCBpcyBhbHJlYWR5IGJvdW5kIHRvIGEgY29uc3RydWN0b3InKTtcbiAgICB9XG4gICAgQ2xhc3MubGF5b3V0XyA9IGxheW91dDtcbiAgICBsYXlvdXQuYm91bmRDb25zdHJ1Y3Rvcl8gPSBDbGFzcztcbiAgICBsYXlvdXQubWFrZURlc3RpbmF0aW9uT2JqZWN0ID0gKCgpID0+IG5ldyBDbGFzcygpKTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xhc3MucHJvdG90eXBlLCAnZW5jb2RlJywge1xuICAgICAgICB2YWx1ZShiLCBvZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBsYXlvdXQuZW5jb2RlKHRoaXMsIGIsIG9mZnNldCk7XG4gICAgICAgIH0sXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbGFzcywgJ2RlY29kZScsIHtcbiAgICAgICAgdmFsdWUoYiwgb2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbGF5b3V0LmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB9LFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICB9KTtcbn1cbmV4cG9ydHMuYmluZENvbnN0cnVjdG9yTGF5b3V0ID0gYmluZENvbnN0cnVjdG9yTGF5b3V0O1xuLyoqXG4gKiBBbiBvYmplY3QgdGhhdCBiZWhhdmVzIGxpa2UgYSBsYXlvdXQgYnV0IGRvZXMgbm90IGNvbnN1bWUgc3BhY2VcbiAqIHdpdGhpbiBpdHMgY29udGFpbmluZyBsYXlvdXQuXG4gKlxuICogVGhpcyBpcyBwcmltYXJpbHkgdXNlZCB0byBvYnRhaW4gbWV0YWRhdGEgYWJvdXQgYSBtZW1iZXIsIHN1Y2ggYXMgYVxuICoge0BsaW5rIE9mZnNldExheW91dH0gdGhhdCBjYW4gcHJvdmlkZSBkYXRhIGFib3V0IGEge0BsaW5rXG4gKiBMYXlvdXQjZ2V0U3Bhbnx2YWx1ZS1zcGVjaWZpYyBzcGFufS5cbiAqXG4gKiAqKk5PVEUqKiBUaGlzIGlzIGFuIGFic3RyYWN0IGJhc2UgY2xhc3M7IHlvdSBjYW4gY3JlYXRlIGluc3RhbmNlc1xuICogaWYgaXQgYW11c2VzIHlvdSwgYnV0IHRoZXkgd29uJ3Qgc3VwcG9ydCB7QGxpbmtcbiAqIEV4dGVybmFsTGF5b3V0I2lzQ291bnR8aXNDb3VudH0gb3Igb3RoZXIge0BsaW5rIExheW91dH0gZnVuY3Rpb25zLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzcGFuIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS5cbiAqIFRoZSBwYXJhbWV0ZXIgY2FuIHJhbmdlIGZyb20gMSB0aHJvdWdoIDYuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhYnN0cmFjdFxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEV4dGVybmFsTGF5b3V0IGV4dGVuZHMgTGF5b3V0IHtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYHRydWVgIGlmZiB0aGUgZXh0ZXJuYWwgbGF5b3V0IGRlY29kZXMgdG8gYW4gdW5zaWduZWRcbiAgICAgKiBpbnRlZ2VyIGxheW91dC5cbiAgICAgKlxuICAgICAqIEluIHRoYXQgY2FzZSBpdCBjYW4gYmUgdXNlZCBhcyB0aGUgc291cmNlIG9mIHtAbGlua1xuICAgICAqIFNlcXVlbmNlI2NvdW50fFNlcXVlbmNlIGNvdW50c30sIHtAbGluayBCbG9iI2xlbmd0aHxCbG9iIGxlbmd0aHN9LFxuICAgICAqIG9yIGFzIHtAbGluayBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IjbGF5b3V0fGV4dGVybmFsIHVuaW9uXG4gICAgICogZGlzY3JpbWluYXRvcnN9LlxuICAgICAqXG4gICAgICogQGFic3RyYWN0XG4gICAgICovXG4gICAgaXNDb3VudCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHRlcm5hbExheW91dCBpcyBhYnN0cmFjdCcpO1xuICAgIH1cbn1cbmV4cG9ydHMuRXh0ZXJuYWxMYXlvdXQgPSBFeHRlcm5hbExheW91dDtcbi8qKlxuICogQW4ge0BsaW5rIEV4dGVybmFsTGF5b3V0fSB0aGF0IGRldGVybWluZXMgaXRzIHtAbGlua1xuICogTGF5b3V0I2RlY29kZXx2YWx1ZX0gYmFzZWQgb24gb2Zmc2V0IGludG8gYW5kIGxlbmd0aCBvZiB0aGUgYnVmZmVyXG4gKiBvbiB3aGljaCBpdCBpcyBpbnZva2VkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuZ3JlZWR5fGdyZWVkeX1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW2VsZW1lbnRTcGFuXSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIEdyZWVkeUNvdW50I2VsZW1lbnRTcGFufGVsZW1lbnRTcGFufS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtFeHRlcm5hbExheW91dH1cbiAqL1xuY2xhc3MgR3JlZWR5Q291bnQgZXh0ZW5kcyBFeHRlcm5hbExheW91dCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudFNwYW4gPSAxLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoKCFOdW1iZXIuaXNJbnRlZ2VyKGVsZW1lbnRTcGFuKSkgfHwgKDAgPj0gZWxlbWVudFNwYW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbGVtZW50U3BhbiBtdXN0IGJlIGEgKHBvc2l0aXZlKSBpbnRlZ2VyJyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoLTEsIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBsYXlvdXQgZm9yIGluZGl2aWR1YWwgZWxlbWVudHMgb2YgdGhlIHNlcXVlbmNlLiAgVGhlIHZhbHVlXG4gICAgICAgICAqIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyLiAgSWYgbm90IHByb3ZpZGVkLCB0aGUgdmFsdWUgd2lsbCBiZVxuICAgICAgICAgKiAxLiAqL1xuICAgICAgICB0aGlzLmVsZW1lbnRTcGFuID0gZWxlbWVudFNwYW47XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBpc0NvdW50KCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNoZWNrVWludDhBcnJheShiKTtcbiAgICAgICAgY29uc3QgcmVtID0gYi5sZW5ndGggLSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiBNYXRoLmZsb29yKHJlbSAvIHRoaXMuZWxlbWVudFNwYW4pO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbmV4cG9ydHMuR3JlZWR5Q291bnQgPSBHcmVlZHlDb3VudDtcbi8qKlxuICogQW4ge0BsaW5rIEV4dGVybmFsTGF5b3V0fSB0aGF0IHN1cHBvcnRzIGFjY2Vzc2luZyBhIHtAbGluayBMYXlvdXR9XG4gKiBhdCBhIGZpeGVkIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiBhbm90aGVyIExheW91dC4gIFRoZSBvZmZzZXQgbWF5XG4gKiBiZSBiZWZvcmUsIHdpdGhpbiwgb3IgYWZ0ZXIgdGhlIGJhc2UgbGF5b3V0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQub2Zmc2V0fG9mZnNldH1cbiAqXG4gKiBAcGFyYW0ge0xheW91dH0gbGF5b3V0IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogT2Zmc2V0TGF5b3V0I2xheW91dHxsYXlvdXR9LCBtb2R1bG8gYHByb3BlcnR5YC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gW29mZnNldF0gLSBJbml0aWFsaXplcyB7QGxpbmtcbiAqIE9mZnNldExheW91dCNvZmZzZXR8b2Zmc2V0fS4gIERlZmF1bHRzIHRvIHplcm8uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBPcHRpb25hbCBuZXcgcHJvcGVydHkgbmFtZSBmb3IgYVxuICoge0BsaW5rIExheW91dCNyZXBsaWNhdGV8IHJlcGxpY2F9IG9mIGBsYXlvdXRgIHRvIGJlIHVzZWQgYXMge0BsaW5rXG4gKiBPZmZzZXRMYXlvdXQjbGF5b3V0fGxheW91dH0uICBJZiBub3QgcHJvdmlkZWQgdGhlIGBsYXlvdXRgIGlzIHVzZWRcbiAqIHVuY2hhbmdlZC5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgT2Zmc2V0TGF5b3V0IGV4dGVuZHMgRXh0ZXJuYWxMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGxheW91dCwgb2Zmc2V0ID0gMCwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEobGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGF5b3V0IG11c3QgYmUgYSBMYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIob2Zmc2V0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb2Zmc2V0IG11c3QgYmUgaW50ZWdlciBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihsYXlvdXQuc3BhbiwgcHJvcGVydHkgfHwgbGF5b3V0LnByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBzdWJvcmRpbmF0ZWQgbGF5b3V0LiAqL1xuICAgICAgICB0aGlzLmxheW91dCA9IGxheW91dDtcbiAgICAgICAgLyoqIFRoZSBsb2NhdGlvbiBvZiB7QGxpbmsgT2Zmc2V0TGF5b3V0I2xheW91dH0gcmVsYXRpdmUgdG8gdGhlXG4gICAgICAgICAqIHN0YXJ0IG9mIGFub3RoZXIgbGF5b3V0LlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgdmFsdWUgbWF5IGJlIHBvc2l0aXZlIG9yIG5lZ2F0aXZlLCBidXQgYW4gZXJyb3Igd2lsbCB0aHJvd25cbiAgICAgICAgICogaWYgYXQgdGhlIHBvaW50IG9mIHVzZSBpdCBnb2VzIG91dHNpZGUgdGhlIHNwYW4gb2YgdGhlIFVpbnQ4QXJyYXlcbiAgICAgICAgICogYmVpbmcgYWNjZXNzZWQuICAqL1xuICAgICAgICB0aGlzLm9mZnNldCA9IG9mZnNldDtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGlzQ291bnQoKSB7XG4gICAgICAgIHJldHVybiAoKHRoaXMubGF5b3V0IGluc3RhbmNlb2YgVUludClcbiAgICAgICAgICAgIHx8ICh0aGlzLmxheW91dCBpbnN0YW5jZW9mIFVJbnRCRSkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmRlY29kZShiLCBvZmZzZXQgKyB0aGlzLm9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheW91dC5lbmNvZGUoc3JjLCBiLCBvZmZzZXQgKyB0aGlzLm9mZnNldCk7XG4gICAgfVxufVxuZXhwb3J0cy5PZmZzZXRMYXlvdXQgPSBPZmZzZXRMYXlvdXQ7XG4vKipcbiAqIFJlcHJlc2VudCBhbiB1bnNpZ25lZCBpbnRlZ2VyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQudTh8dTh9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnUxNnx1MTZ9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51MjR8dTI0fSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC51MzJ8dTMyfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTQwfHU0MH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQudTQ4fHU0OH1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVUludCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3Ioc3BhbiwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICBpZiAoNiA8IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NwYW4gbXVzdCBub3QgZXhjZWVkIDYgYnl0ZXMnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkVUludExFKG9mZnNldCwgdGhpcy5zcGFuKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlVUludExFKHNyYywgb2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuVUludCA9IFVJbnQ7XG4vKipcbiAqIFJlcHJlc2VudCBhbiB1bnNpZ25lZCBpbnRlZ2VyIGluIGJpZy1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQudThiZXx1OGJlfSwge0BsaW5rXG4gKiBtb2R1bGU6TGF5b3V0LnUxNmJlfHUxNmJlfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQudTI0YmV8dTI0YmV9LFxuICoge0BsaW5rIG1vZHVsZTpMYXlvdXQudTMyYmV8dTMyYmV9LCB7QGxpbmtcbiAqIG1vZHVsZTpMYXlvdXQudTQwYmV8dTQwYmV9LCB7QGxpbmsgbW9kdWxlOkxheW91dC51NDhiZXx1NDhiZX1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVUludEJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIGlmICg2IDwgdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlcycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWRVSW50QkUob2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVVSW50QkUoc3JjLCBvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5VSW50QkUgPSBVSW50QkU7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNpZ25lZCBpbnRlZ2VyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuczh8czh9LCB7QGxpbmtcbiAqICBtb2R1bGU6TGF5b3V0LnMxNnxzMTZ9LCB7QGxpbmsgbW9kdWxlOkxheW91dC5zMjR8czI0fSwge0BsaW5rXG4gKiAgbW9kdWxlOkxheW91dC5zMzJ8czMyfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczQwfHM0MH0sIHtAbGlua1xuICogIG1vZHVsZTpMYXlvdXQuczQ4fHM0OH1cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gc3BhbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0uXG4gKiBUaGUgcGFyYW1ldGVyIGNhbiByYW5nZSBmcm9tIDEgdGhyb3VnaCA2LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgSW50IGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIGlmICg2IDwgdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlcycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWRJbnRMRShvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZUludExFKHNyYywgb2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50ID0gSW50O1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzaWduZWQgaW50ZWdlciBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnM4YmV8czhiZX0sIHtAbGlua1xuICogbW9kdWxlOkxheW91dC5zMTZiZXxzMTZiZX0sIHtAbGluayBtb2R1bGU6TGF5b3V0LnMyNGJlfHMyNGJlfSxcbiAqIHtAbGluayBtb2R1bGU6TGF5b3V0LnMzMmJlfHMzMmJlfSwge0BsaW5rXG4gKiBtb2R1bGU6TGF5b3V0LnM0MGJlfHM0MGJlfSwge0BsaW5rIG1vZHVsZTpMYXlvdXQuczQ4YmV8czQ4YmV9XG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHNwYW4gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIExheW91dCNzcGFufHNwYW59LlxuICogVGhlIHBhcmFtZXRlciBjYW4gcmFuZ2UgZnJvbSAxIHRocm91Z2ggNi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIEludEJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihzcGFuLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIGlmICg2IDwgdGhpcy5zcGFuKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc3BhbiBtdXN0IG5vdCBleGNlZWQgNiBieXRlcycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWRJbnRCRShvZmZzZXQsIHRoaXMuc3Bhbik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZUludEJFKHNyYywgb2Zmc2V0LCB0aGlzLnNwYW4pO1xuICAgICAgICByZXR1cm4gdGhpcy5zcGFuO1xuICAgIH1cbn1cbmV4cG9ydHMuSW50QkUgPSBJbnRCRTtcbmNvbnN0IFYyRTMyID0gTWF0aC5wb3coMiwgMzIpO1xuLyogVHJ1ZSBtb2R1bHVzIGhpZ2ggYW5kIGxvdyAzMi1iaXQgd29yZHMsIHdoZXJlIGxvdyB3b3JkIGlzIGFsd2F5c1xuICogbm9uLW5lZ2F0aXZlLiAqL1xuZnVuY3Rpb24gZGl2bW9kSW50NjQoc3JjKSB7XG4gICAgY29uc3QgaGkzMiA9IE1hdGguZmxvb3Ioc3JjIC8gVjJFMzIpO1xuICAgIGNvbnN0IGxvMzIgPSBzcmMgLSAoaGkzMiAqIFYyRTMyKTtcbiAgICByZXR1cm4geyBoaTMyLCBsbzMyIH07XG59XG4vKiBSZWNvbnN0cnVjdCBOdW1iZXIgZnJvbSBxdW90aWVudCBhbmQgbm9uLW5lZ2F0aXZlIHJlbWFpbmRlciAqL1xuZnVuY3Rpb24gcm91bmRlZEludDY0KGhpMzIsIGxvMzIpIHtcbiAgICByZXR1cm4gaGkzMiAqIFYyRTMyICsgbG8zMjtcbn1cbi8qKlxuICogUmVwcmVzZW50IGFuIHVuc2lnbmVkIDY0LWJpdCBpbnRlZ2VyIGluIGxpdHRsZS1lbmRpYW4gZm9ybWF0IHdoZW5cbiAqIGVuY29kZWQgYW5kIGFzIGEgbmVhciBpbnRlZ3JhbCBKYXZhU2NyaXB0IE51bWJlciB3aGVuIGRlY29kZWQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5udTY0fG51NjR9XG4gKlxuICogKipOT1RFKiogVmFsdWVzIHdpdGggbWFnbml0dWRlIGdyZWF0ZXIgdGhhbiAyXjUyIG1heSBub3QgZGVjb2RlIHRvXG4gKiB0aGUgZXhhY3QgdmFsdWUgb2YgdGhlIGVuY29kZWQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIE5lYXJVSW50NjQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgY29uc3QgbG8zMiA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgaGkzMiA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gZGl2bW9kSW50NjQoc3JjKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJMRShzcGxpdC5sbzMyLCBvZmZzZXQpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJMRShzcGxpdC5oaTMyLCBvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxufVxuZXhwb3J0cy5OZWFyVUludDY0ID0gTmVhclVJbnQ2NDtcbi8qKlxuICogUmVwcmVzZW50IGFuIHVuc2lnbmVkIDY0LWJpdCBpbnRlZ2VyIGluIGJpZy1lbmRpYW4gZm9ybWF0IHdoZW5cbiAqIGVuY29kZWQgYW5kIGFzIGEgbmVhciBpbnRlZ3JhbCBKYXZhU2NyaXB0IE51bWJlciB3aGVuIGRlY29kZWQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5udTY0YmV8bnU2NGJlfVxuICpcbiAqICoqTk9URSoqIFZhbHVlcyB3aXRoIG1hZ25pdHVkZSBncmVhdGVyIHRoYW4gMl41MiBtYXkgbm90IGRlY29kZSB0b1xuICogdGhlIGV4YWN0IHZhbHVlIG9mIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBOZWFyVUludDY0QkUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgY29uc3QgaGkzMiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgbG8zMiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gZGl2bW9kSW50NjQoc3JjKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRShzcGxpdC5oaTMyLCBvZmZzZXQpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRShzcGxpdC5sbzMyLCBvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxufVxuZXhwb3J0cy5OZWFyVUludDY0QkUgPSBOZWFyVUludDY0QkU7XG4vKipcbiAqIFJlcHJlc2VudCBhIHNpZ25lZCA2NC1iaXQgaW50ZWdlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdCB3aGVuXG4gKiBlbmNvZGVkIGFuZCBhcyBhIG5lYXIgaW50ZWdyYWwgSmF2YVNjcmlwdCBOdW1iZXIgd2hlbiBkZWNvZGVkLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQubnM2NHxuczY0fVxuICpcbiAqICoqTk9URSoqIFZhbHVlcyB3aXRoIG1hZ25pdHVkZSBncmVhdGVyIHRoYW4gMl41MiBtYXkgbm90IGRlY29kZSB0b1xuICogdGhlIGV4YWN0IHZhbHVlIG9mIHRoZSBlbmNvZGVkIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBOZWFySW50NjQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHVpbnQ4QXJyYXlUb0J1ZmZlcihiKTtcbiAgICAgICAgY29uc3QgbG8zMiA9IGJ1ZmZlci5yZWFkVUludDMyTEUob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgaGkzMiA9IGJ1ZmZlci5yZWFkSW50MzJMRShvZmZzZXQgKyA0KTtcbiAgICAgICAgcmV0dXJuIHJvdW5kZWRJbnQ2NChoaTMyLCBsbzMyKTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBkaXZtb2RJbnQ2NChzcmMpO1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkxFKHNwbGl0LmxvMzIsIG9mZnNldCk7XG4gICAgICAgIGJ1ZmZlci53cml0ZUludDMyTEUoc3BsaXQuaGkzMiwgb2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cbn1cbmV4cG9ydHMuTmVhckludDY0ID0gTmVhckludDY0O1xuLyoqXG4gKiBSZXByZXNlbnQgYSBzaWduZWQgNjQtYml0IGludGVnZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQgd2hlblxuICogZW5jb2RlZCBhbmQgYXMgYSBuZWFyIGludGVncmFsIEphdmFTY3JpcHQgTnVtYmVyIHdoZW4gZGVjb2RlZC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0Lm5zNjRiZXxuczY0YmV9XG4gKlxuICogKipOT1RFKiogVmFsdWVzIHdpdGggbWFnbml0dWRlIGdyZWF0ZXIgdGhhbiAyXjUyIG1heSBub3QgZGVjb2RlIHRvXG4gKiB0aGUgZXhhY3QgdmFsdWUgb2YgdGhlIGVuY29kZWQgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIE5lYXJJbnQ2NEJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIGNvbnN0IGhpMzIgPSBidWZmZXIucmVhZEludDMyQkUob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgbG8zMiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0ICsgNCk7XG4gICAgICAgIHJldHVybiByb3VuZGVkSW50NjQoaGkzMiwgbG8zMik7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gZGl2bW9kSW50NjQoc3JjKTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gdWludDhBcnJheVRvQnVmZmVyKGIpO1xuICAgICAgICBidWZmZXIud3JpdGVJbnQzMkJFKHNwbGl0LmhpMzIsIG9mZnNldCk7XG4gICAgICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHNwbGl0LmxvMzIsIG9mZnNldCArIDQpO1xuICAgICAgICByZXR1cm4gODtcbiAgICB9XG59XG5leHBvcnRzLk5lYXJJbnQ2NEJFID0gTmVhckludDY0QkU7XG4vKipcbiAqIFJlcHJlc2VudCBhIDMyLWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIgaW4gbGl0dGxlLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5mMzJ8ZjMyfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgRmxvYXQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDQsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZEZsb2F0TEUob2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlRmxvYXRMRShzcmMsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiA0O1xuICAgIH1cbn1cbmV4cG9ydHMuRmxvYXQgPSBGbG9hdDtcbi8qKlxuICogUmVwcmVzZW50IGEgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciBpbiBiaWctZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmYzMmJlfGYzMmJlfVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgRmxvYXRCRSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoNCwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS5yZWFkRmxvYXRCRShvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVGbG9hdEJFKHNyYywgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfVxufVxuZXhwb3J0cy5GbG9hdEJFID0gRmxvYXRCRTtcbi8qKlxuICogUmVwcmVzZW50IGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlciBpbiBsaXR0bGUtZW5kaWFuIGZvcm1hdC5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmY2NHxmNjR9XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBEb3VibGUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHByb3BlcnR5KSB7XG4gICAgICAgIHN1cGVyKDgsIHByb3BlcnR5KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikucmVhZERvdWJsZUxFKG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIHVpbnQ4QXJyYXlUb0J1ZmZlcihiKS53cml0ZURvdWJsZUxFKHNyYywgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIDg7XG4gICAgfVxufVxuZXhwb3J0cy5Eb3VibGUgPSBEb3VibGU7XG4vKipcbiAqIFJlcHJlc2VudCBhIDY0LWJpdCBmbG9hdGluZyBwb2ludCBudW1iZXIgaW4gYmlnLWVuZGlhbiBmb3JtYXQuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5mNjRiZXxmNjRiZX1cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIERvdWJsZUJFIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcig4LCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnJlYWREb3VibGVCRShvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB1aW50OEFycmF5VG9CdWZmZXIoYikud3JpdGVEb3VibGVCRShzcmMsIG9mZnNldCk7XG4gICAgICAgIHJldHVybiA4O1xuICAgIH1cbn1cbmV4cG9ydHMuRG91YmxlQkUgPSBEb3VibGVCRTtcbi8qKlxuICogUmVwcmVzZW50IGEgY29udGlndW91cyBzZXF1ZW5jZSBvZiBhIHNwZWNpZmljIGxheW91dCBhcyBhbiBBcnJheS5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LnNlcXxzZXF9XG4gKlxuICogQHBhcmFtIHtMYXlvdXR9IGVsZW1lbnRMYXlvdXQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBTZXF1ZW5jZSNlbGVtZW50TGF5b3V0fGVsZW1lbnRMYXlvdXR9LlxuICpcbiAqIEBwYXJhbSB7KE51bWJlcnxFeHRlcm5hbExheW91dCl9IGNvdW50IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogU2VxdWVuY2UjY291bnR8Y291bnR9LiAgVGhlIHBhcmFtZXRlciBtdXN0IGJlIGVpdGhlciBhIHBvc2l0aXZlXG4gKiBpbnRlZ2VyIG9yIGFuIGluc3RhbmNlIG9mIHtAbGluayBFeHRlcm5hbExheW91dH0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBTZXF1ZW5jZSBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudExheW91dCwgY291bnQsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKGVsZW1lbnRMYXlvdXQgaW5zdGFuY2VvZiBMYXlvdXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbGVtZW50TGF5b3V0IG11c3QgYmUgYSBMYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoISgoKGNvdW50IGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpICYmIGNvdW50LmlzQ291bnQoKSlcbiAgICAgICAgICAgIHx8IChOdW1iZXIuaXNJbnRlZ2VyKGNvdW50KSAmJiAoMCA8PSBjb3VudCkpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY291bnQgbXVzdCBiZSBub24tbmVnYXRpdmUgaW50ZWdlciAnXG4gICAgICAgICAgICAgICAgKyAnb3IgYW4gdW5zaWduZWQgaW50ZWdlciBFeHRlcm5hbExheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcGFuID0gLTE7XG4gICAgICAgIGlmICgoIShjb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSlcbiAgICAgICAgICAgICYmICgwIDwgZWxlbWVudExheW91dC5zcGFuKSkge1xuICAgICAgICAgICAgc3BhbiA9IGNvdW50ICogZWxlbWVudExheW91dC5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHNwYW4sIHByb3BlcnR5KTtcbiAgICAgICAgLyoqIFRoZSBsYXlvdXQgZm9yIGluZGl2aWR1YWwgZWxlbWVudHMgb2YgdGhlIHNlcXVlbmNlLiAqL1xuICAgICAgICB0aGlzLmVsZW1lbnRMYXlvdXQgPSBlbGVtZW50TGF5b3V0O1xuICAgICAgICAvKiogVGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgc2VxdWVuY2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgd2lsbCBiZSBlaXRoZXIgYSBub24tbmVnYXRpdmUgaW50ZWdlciBvciBhbiBpbnN0YW5jZSBvZlxuICAgICAgICAgKiB7QGxpbmsgRXh0ZXJuYWxMYXlvdXR9IGZvciB3aGljaCB7QGxpbmtcbiAgICAgICAgICogRXh0ZXJuYWxMYXlvdXQjaXNDb3VudHxpc0NvdW50KCl9IGlzIGB0cnVlYC4gKi9cbiAgICAgICAgdGhpcy5jb3VudCA9IGNvdW50O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGlmICgwIDw9IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BhbiA9IDA7XG4gICAgICAgIGxldCBjb3VudCA9IHRoaXMuY291bnQ7XG4gICAgICAgIGlmIChjb3VudCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSB7XG4gICAgICAgICAgICBjb3VudCA9IGNvdW50LmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgwIDwgdGhpcy5lbGVtZW50TGF5b3V0LnNwYW4pIHtcbiAgICAgICAgICAgIHNwYW4gPSBjb3VudCAqIHRoaXMuZWxlbWVudExheW91dC5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IGlkeCA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoaWR4IDwgY291bnQpIHtcbiAgICAgICAgICAgICAgICBzcGFuICs9IHRoaXMuZWxlbWVudExheW91dC5nZXRTcGFuKGIsIG9mZnNldCArIHNwYW4pO1xuICAgICAgICAgICAgICAgICsraWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgcnYgPSBbXTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBsZXQgY291bnQgPSB0aGlzLmNvdW50O1xuICAgICAgICBpZiAoY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkge1xuICAgICAgICAgICAgY291bnQgPSBjb3VudC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaSA8IGNvdW50KSB7XG4gICAgICAgICAgICBydi5wdXNoKHRoaXMuZWxlbWVudExheW91dC5kZWNvZGUoYiwgb2Zmc2V0KSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gdGhpcy5lbGVtZW50TGF5b3V0LmdldFNwYW4oYiwgb2Zmc2V0KTtcbiAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnQge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2RlfSBmb3Ige0BsaW5rIFNlcXVlbmNlfS5cbiAgICAgKlxuICAgICAqICoqTk9URSoqIElmIGBzcmNgIGlzIHNob3J0ZXIgdGhhbiB7QGxpbmsgU2VxdWVuY2UjY291bnR8Y291bnR9IHRoZW5cbiAgICAgKiB0aGUgdW51c2VkIHNwYWNlIGluIHRoZSBidWZmZXIgaXMgbGVmdCB1bmNoYW5nZWQuICBJZiBgc3JjYCBpc1xuICAgICAqIGxvbmdlciB0aGFuIHtAbGluayBTZXF1ZW5jZSNjb3VudHxjb3VudH0gdGhlIHVubmVlZGVkIGVsZW1lbnRzIGFyZVxuICAgICAqIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBJZiB7QGxpbmsgTGF5b3V0I2NvdW50fGNvdW50fSBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmtcbiAgICAgKiBFeHRlcm5hbExheW91dH0gdGhlbiB0aGUgbGVuZ3RoIG9mIGBzcmNgIHdpbGwgYmUgZW5jb2RlZCBhcyB0aGVcbiAgICAgKiBjb3VudCBhZnRlciBgc3JjYCBpcyBlbmNvZGVkLiAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgZWxvID0gdGhpcy5lbGVtZW50TGF5b3V0O1xuICAgICAgICBjb25zdCBzcGFuID0gc3JjLnJlZHVjZSgoc3BhbiwgdikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHNwYW4gKyBlbG8uZW5jb2RlKHYsIGIsIG9mZnNldCArIHNwYW4pO1xuICAgICAgICB9LCAwKTtcbiAgICAgICAgaWYgKHRoaXMuY291bnQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkge1xuICAgICAgICAgICAgdGhpcy5jb3VudC5lbmNvZGUoc3JjLmxlbmd0aCwgYiwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG59XG5leHBvcnRzLlNlcXVlbmNlID0gU2VxdWVuY2U7XG4vKipcbiAqIFJlcHJlc2VudCBhIGNvbnRpZ3VvdXMgc2VxdWVuY2Ugb2YgYXJiaXRyYXJ5IGxheW91dCBlbGVtZW50cyBhcyBhblxuICogT2JqZWN0LlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQuc3RydWN0fHN0cnVjdH1cbiAqXG4gKiAqKk5PVEUqKiBUaGUge0BsaW5rIExheW91dCNzcGFufHNwYW59IG9mIHRoZSBzdHJ1Y3R1cmUgaXMgdmFyaWFibGVcbiAqIGlmIGFueSBsYXlvdXQgaW4ge0BsaW5rIFN0cnVjdHVyZSNmaWVsZHN8ZmllbGRzfSBoYXMgYSB2YXJpYWJsZVxuICogc3Bhbi4gIFdoZW4ge0BsaW5rIExheW91dCNlbmNvZGV8ZW5jb2Rpbmd9IHdlIG11c3QgaGF2ZSBhIHZhbHVlIGZvclxuICogYWxsIHZhcmlhYmxlLWxlbmd0aCBmaWVsZHMsIG9yIHdlIHdvdWxkbid0IGJlIGFibGUgdG8gZmlndXJlIG91dFxuICogaG93IG11Y2ggc3BhY2UgdG8gdXNlIGZvciBzdG9yYWdlLiAgV2UgY2FuIG9ubHkgaWRlbnRpZnkgdGhlIHZhbHVlXG4gKiBmb3IgYSBmaWVsZCB3aGVuIGl0IGhhcyBhIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LiAgQXNcbiAqIHN1Y2gsIGFsdGhvdWdoIGEgc3RydWN0dXJlIG1heSBjb250YWluIGJvdGggdW5uYW1lZCBmaWVsZHMgYW5kXG4gKiB2YXJpYWJsZS1sZW5ndGggZmllbGRzLCBpdCBjYW5ub3QgY29udGFpbiBhbiB1bm5hbWVkXG4gKiB2YXJpYWJsZS1sZW5ndGggZmllbGQuXG4gKlxuICogQHBhcmFtIHtMYXlvdXRbXX0gZmllbGRzIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogU3RydWN0dXJlI2ZpZWxkc3xmaWVsZHN9LiAgQW4gZXJyb3IgaXMgcmFpc2VkIGlmIHRoaXMgY29udGFpbnMgYVxuICogdmFyaWFibGUtbGVuZ3RoIGZpZWxkIGZvciB3aGljaCBhIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9XG4gKiBpcyBub3QgZGVmaW5lZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBbZGVjb2RlUHJlZml4ZXNdIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogU3RydWN0dXJlI2RlY29kZVByZWZpeGVzfHByb3BlcnR5fS5cbiAqXG4gKiBAdGhyb3dzIHtFcnJvcn0gLSBpZiBgZmllbGRzYCBjb250YWlucyBhbiB1bm5hbWVkIHZhcmlhYmxlLWxlbmd0aFxuICogbGF5b3V0LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBTdHJ1Y3R1cmUgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKGZpZWxkcywgcHJvcGVydHksIGRlY29kZVByZWZpeGVzKSB7XG4gICAgICAgIGlmICghKEFycmF5LmlzQXJyYXkoZmllbGRzKVxuICAgICAgICAgICAgJiYgZmllbGRzLnJlZHVjZSgoYWNjLCB2KSA9PiBhY2MgJiYgKHYgaW5zdGFuY2VvZiBMYXlvdXQpLCB0cnVlKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZpZWxkcyBtdXN0IGJlIGFycmF5IG9mIExheW91dCBpbnN0YW5jZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCdib29sZWFuJyA9PT0gdHlwZW9mIHByb3BlcnR5KVxuICAgICAgICAgICAgJiYgKHVuZGVmaW5lZCA9PT0gZGVjb2RlUHJlZml4ZXMpKSB7XG4gICAgICAgICAgICBkZWNvZGVQcmVmaXhlcyA9IHByb3BlcnR5O1xuICAgICAgICAgICAgcHJvcGVydHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogVmVyaWZ5IGFic2VuY2Ugb2YgdW5uYW1lZCB2YXJpYWJsZS1sZW5ndGggZmllbGRzLiAqL1xuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgaWYgKCgwID4gZmQuc3BhbilcbiAgICAgICAgICAgICAgICAmJiAodW5kZWZpbmVkID09PSBmZC5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpZWxkcyBjYW5ub3QgY29udGFpbiB1bm5hbWVkIHZhcmlhYmxlLWxlbmd0aCBsYXlvdXQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgc3BhbiA9IC0xO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3BhbiA9IGZpZWxkcy5yZWR1Y2UoKHNwYW4sIGZkKSA9PiBzcGFuICsgZmQuZ2V0U3BhbigpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gaWdub3JlIGVycm9yXG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIHNlcXVlbmNlIG9mIHtAbGluayBMYXlvdXR9IHZhbHVlcyB0aGF0IGNvbXByaXNlIHRoZVxuICAgICAgICAgKiBzdHJ1Y3R1cmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBpbmRpdmlkdWFsIGVsZW1lbnRzIG5lZWQgbm90IGJlIHRoZSBzYW1lIHR5cGUsIGFuZCBtYXkgYmVcbiAgICAgICAgICogZWl0aGVyIHNjYWxhciBvciBhZ2dyZWdhdGUgbGF5b3V0cy4gIElmIGEgbWVtYmVyIGxheW91dCBsZWF2ZXNcbiAgICAgICAgICogaXRzIHtAbGluayBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHVuZGVmaW5lZCB0aGVcbiAgICAgICAgICogY29ycmVzcG9uZGluZyByZWdpb24gb2YgdGhlIGJ1ZmZlciBhc3NvY2lhdGVkIHdpdGggdGhlIGVsZW1lbnRcbiAgICAgICAgICogd2lsbCBub3QgYmUgbXV0YXRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0xheW91dFtdfSAqL1xuICAgICAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgLyoqIENvbnRyb2wgYmVoYXZpb3Igb2Yge0BsaW5rIExheW91dCNkZWNvZGV8ZGVjb2RlKCl9IGdpdmVuIHNob3J0XG4gICAgICAgICAqIGJ1ZmZlcnMuXG4gICAgICAgICAqXG4gICAgICAgICAqIEluIHNvbWUgc2l0dWF0aW9ucyBhIHN0cnVjdHVyZSBtYW55IGJlIGV4dGVuZGVkIHdpdGggYWRkaXRpb25hbFxuICAgICAgICAgKiBmaWVsZHMgb3ZlciB0aW1lLCB3aXRoIG9sZGVyIGluc3RhbGxhdGlvbnMgcHJvdmlkaW5nIG9ubHkgYVxuICAgICAgICAgKiBwcmVmaXggb2YgdGhlIGZ1bGwgc3RydWN0dXJlLiAgSWYgdGhpcyBwcm9wZXJ0eSBpcyBgdHJ1ZWBcbiAgICAgICAgICogZGVjb2Rpbmcgd2lsbCBhY2NlcHQgdGhvc2UgYnVmZmVycyBhbmQgbGVhdmUgc3Vic2VxdWVudCBmaWVsZHNcbiAgICAgICAgICogdW5kZWZpbmVkLCBhcyBsb25nIGFzIHRoZSBidWZmZXIgZW5kcyBhdCBhIGZpZWxkIGJvdW5kYXJ5LlxuICAgICAgICAgKiBEZWZhdWx0cyB0byBgZmFsc2VgLiAqL1xuICAgICAgICB0aGlzLmRlY29kZVByZWZpeGVzID0gISFkZWNvZGVQcmVmaXhlcztcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGdldFNwYW4oYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBpZiAoMCA8PSB0aGlzLnNwYW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNwYW4gPSAwO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3BhbiA9IHRoaXMuZmllbGRzLnJlZHVjZSgoc3BhbiwgZmQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmc3AgPSBmZC5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGZzcDtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3BhbiArIGZzcDtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignaW5kZXRlcm1pbmF0ZSBzcGFuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjaGVja1VpbnQ4QXJyYXkoYik7XG4gICAgICAgIGNvbnN0IGRlc3QgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmZC5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGRlc3RbZmQucHJvcGVydHldID0gZmQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgKz0gZmQuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZGVjb2RlUHJlZml4ZXNcbiAgICAgICAgICAgICAgICAmJiAoYi5sZW5ndGggPT09IG9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzdDtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgU3RydWN0dXJlfS5cbiAgICAgKlxuICAgICAqIElmIGBzcmNgIGlzIG1pc3NpbmcgYSBwcm9wZXJ0eSBmb3IgYSBtZW1iZXIgd2l0aCBhIGRlZmluZWQge0BsaW5rXG4gICAgICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB0aGUgY29ycmVzcG9uZGluZyByZWdpb24gb2YgdGhlIGJ1ZmZlciBpc1xuICAgICAqIGxlZnQgdW5tb2RpZmllZC4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGZpcnN0T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICBsZXQgbGFzdE9mZnNldCA9IDA7XG4gICAgICAgIGxldCBsYXN0V3JvdGUgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBsZXQgc3BhbiA9IGZkLnNwYW47XG4gICAgICAgICAgICBsYXN0V3JvdGUgPSAoMCA8IHNwYW4pID8gc3BhbiA6IDA7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmZC5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ2ID0gc3JjW2ZkLnByb3BlcnR5XTtcbiAgICAgICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmdikge1xuICAgICAgICAgICAgICAgICAgICBsYXN0V3JvdGUgPSBmZC5lbmNvZGUoZnYsIGIsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICgwID4gc3Bhbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogUmVhZCB0aGUgYXMtZW5jb2RlZCBzcGFuLCB3aGljaCBpcyBub3QgbmVjZXNzYXJpbHkgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBzYW1lIGFzIHdoYXQgd2Ugd3JvdGUuICovXG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuID0gZmQuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIG9mZnNldCArPSBzcGFuO1xuICAgICAgICB9XG4gICAgICAgIC8qIFVzZSAobGFzdE9mZnNldCArIGxhc3RXcm90ZSkgaW5zdGVhZCBvZiBvZmZzZXQgYmVjYXVzZSB0aGUgbGFzdFxuICAgICAgICAgKiBpdGVtIG1heSBoYXZlIGhhZCBhIGR5bmFtaWMgbGVuZ3RoIGFuZCB3ZSBkb24ndCB3YW50IHRvIGluY2x1ZGVcbiAgICAgICAgICogdGhlIHBhZGRpbmcgYmV0d2VlbiBpdCBhbmQgdGhlIGVuZCBvZiB0aGUgc3BhY2UgcmVzZXJ2ZWQgZm9yXG4gICAgICAgICAqIGl0LiAqL1xuICAgICAgICByZXR1cm4gKGxhc3RPZmZzZXQgKyBsYXN0V3JvdGUpIC0gZmlyc3RPZmZzZXQ7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBmcm9tQXJyYXkodmFsdWVzKSB7XG4gICAgICAgIGNvbnN0IGRlc3QgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAoKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpXG4gICAgICAgICAgICAgICAgJiYgKDAgPCB2YWx1ZXMubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIGRlc3RbZmQucHJvcGVydHldID0gdmFsdWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhY2Nlc3MgdG8gdGhlIGxheW91dCBvZiBhIGdpdmVuIHByb3BlcnR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IC0gdGhlIHN0cnVjdHVyZSBtZW1iZXIgb2YgaW50ZXJlc3QuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtMYXlvdXR9IC0gdGhlIGxheW91dCBhc3NvY2lhdGVkIHdpdGggYHByb3BlcnR5YCwgb3JcbiAgICAgKiB1bmRlZmluZWQgaWYgdGhlcmUgaXMgbm8gc3VjaCBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBsYXlvdXRGb3IocHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2YgcHJvcGVydHkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3Byb3BlcnR5IG11c3QgYmUgc3RyaW5nJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZkLnByb3BlcnR5ID09PSBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIG9mZnNldCBvZiBhIHN0cnVjdHVyZSBtZW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSB0aGUgc3RydWN0dXJlIG1lbWJlciBvZiBpbnRlcmVzdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge051bWJlcn0gLSB0aGUgb2Zmc2V0IGluIGJ5dGVzIHRvIHRoZSBzdGFydCBvZiBgcHJvcGVydHlgXG4gICAgICogd2l0aGluIHRoZSBzdHJ1Y3R1cmUsIG9yIHVuZGVmaW5lZCBpZiBgcHJvcGVydHlgIGlzIG5vdCBhIGZpZWxkXG4gICAgICogd2l0aGluIHRoZSBzdHJ1Y3R1cmUuICBJZiB0aGUgcHJvcGVydHkgaXMgYSBtZW1iZXIgYnV0IGZvbGxvd3MgYVxuICAgICAqIHZhcmlhYmxlLWxlbmd0aCBzdHJ1Y3R1cmUgbWVtYmVyIGEgbmVnYXRpdmUgbnVtYmVyIHdpbGwgYmVcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKi9cbiAgICBvZmZzZXRPZihwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJvcGVydHkgbXVzdCBiZSBzdHJpbmcnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZkLnByb3BlcnR5ID09PSBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvZmZzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoMCA+IGZkLnNwYW4pIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKDAgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IGZkLnNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLlN0cnVjdHVyZSA9IFN0cnVjdHVyZTtcbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY2FuIHByb3ZpZGUgYSB7QGxpbmtcbiAqIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0gQVBJIGZvciB7QGxpbmsgVW5pb259LlxuICpcbiAqICoqTk9URSoqIFRoaXMgaXMgYW4gYWJzdHJhY3QgYmFzZSBjbGFzczsgeW91IGNhbiBjcmVhdGUgaW5zdGFuY2VzXG4gKiBpZiBpdCBhbXVzZXMgeW91LCBidXQgdGhleSB3b24ndCBzdXBwb3J0IHRoZSB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNlbmNvZGV8ZW5jb2RlfSBvciB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNkZWNvZGV8ZGVjb2RlfSBmdW5jdGlvbnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBEZWZhdWx0IGZvciB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGFic3RyYWN0XG4gKi9cbmNsYXNzIFVuaW9uRGlzY3JpbWluYXRvciB7XG4gICAgY29uc3RydWN0b3IocHJvcGVydHkpIHtcbiAgICAgICAgLyoqIFRoZSB7QGxpbmsgTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB0byBiZSB1c2VkIHdoZW4gdGhlXG4gICAgICAgICAqIGRpc2NyaW1pbmF0b3IgaXMgcmVmZXJlbmNlZCBpbiBpc29sYXRpb24gKGdlbmVyYWxseSB3aGVuIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNkZWNvZGV8VW5pb24gZGVjb2RlfSBjYW5ub3QgZGVsZWdhdGUgdG8gYSBzcGVjaWZpY1xuICAgICAgICAgKiB2YXJpYW50KS4gKi9cbiAgICAgICAgdGhpcy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuICAgIH1cbiAgICAvKiogQW5hbG9nIHRvIHtAbGluayBMYXlvdXQjZGVjb2RlfExheW91dCBkZWNvZGV9IGZvciB1bmlvbiBkaXNjcmltaW5hdG9ycy5cbiAgICAgKlxuICAgICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBuZWVkIG5vdCByZWZlcmVuY2UgdGhlIGJ1ZmZlciBpZlxuICAgICAqIHZhcmlhbnQgaW5mb3JtYXRpb24gaXMgYXZhaWxhYmxlIHRocm91Z2ggb3RoZXIgbWVhbnMuICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuaW9uRGlzY3JpbWluYXRvciBpcyBhYnN0cmFjdCcpO1xuICAgIH1cbiAgICAvKiogQW5hbG9nIHRvIHtAbGluayBMYXlvdXQjZGVjb2RlfExheW91dCBlbmNvZGV9IGZvciB1bmlvbiBkaXNjcmltaW5hdG9ycy5cbiAgICAgKlxuICAgICAqIFRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIG1ldGhvZCBuZWVkIG5vdCBzdG9yZSB0aGUgdmFsdWUgaWZcbiAgICAgKiB2YXJpYW50IGluZm9ybWF0aW9uIGlzIG1haW50YWluZWQgdGhyb3VnaCBvdGhlciBtZWFucy4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmlvbkRpc2NyaW1pbmF0b3IgaXMgYWJzdHJhY3QnKTtcbiAgICB9XG59XG5leHBvcnRzLlVuaW9uRGlzY3JpbWluYXRvciA9IFVuaW9uRGlzY3JpbWluYXRvcjtcbi8qKlxuICogQW4gb2JqZWN0IHRoYXQgY2FuIHByb3ZpZGUgYSB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yIEFQSX0gZm9yIHtAbGluayBVbmlvbn0gdXNpbmcgYW5cbiAqIHVuc2lnbmVkIGludGVncmFsIHtAbGluayBMYXlvdXR9IGluc3RhbmNlIGxvY2F0ZWQgZWl0aGVyIGluc2lkZSBvclxuICogb3V0c2lkZSB0aGUgdW5pb24uXG4gKlxuICogQHBhcmFtIHtFeHRlcm5hbExheW91dH0gbGF5b3V0IC0gaW5pdGlhbGl6ZXMge0BsaW5rXG4gKiBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IjbGF5b3V0fGxheW91dH0uICBNdXN0IHNhdGlzZnkge0BsaW5rXG4gKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnQoKX0uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBEZWZhdWx0IGZvciB7QGxpbmtcbiAqIFVuaW9uRGlzY3JpbWluYXRvciNwcm9wZXJ0eXxwcm9wZXJ0eX0sIHN1cGVyc2VkaW5nIHRoZSBwcm9wZXJ0eVxuICogZnJvbSBgbGF5b3V0YCwgYnV0IGRlZmF1bHRpbmcgdG8gYHZhcmlhbnRgIGlmIG5laXRoZXIgYHByb3BlcnR5YFxuICogbm9yIGxheW91dCBwcm92aWRlIGEgcHJvcGVydHkgbmFtZS5cbiAqXG4gKiBAYXVnbWVudHMge1VuaW9uRGlzY3JpbWluYXRvcn1cbiAqL1xuY2xhc3MgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yIGV4dGVuZHMgVW5pb25EaXNjcmltaW5hdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihsYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKChsYXlvdXQgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dClcbiAgICAgICAgICAgICYmIGxheW91dC5pc0NvdW50KCkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdsYXlvdXQgbXVzdCBiZSBhbiB1bnNpZ25lZCBpbnRlZ2VyIEV4dGVybmFsTGF5b3V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocHJvcGVydHkgfHwgbGF5b3V0LnByb3BlcnR5IHx8ICd2YXJpYW50Jyk7XG4gICAgICAgIC8qKiBUaGUge0BsaW5rIEV4dGVybmFsTGF5b3V0fSB1c2VkIHRvIGFjY2VzcyB0aGUgZGlzY3JpbWluYXRvclxuICAgICAgICAgKiB2YWx1ZS4gKi9cbiAgICAgICAgdGhpcy5sYXlvdXQgPSBsYXlvdXQ7XG4gICAgfVxuICAgIC8qKiBEZWxlZ2F0ZSBkZWNvZGluZyB0byB7QGxpbmsgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yI2xheW91dHxsYXlvdXR9LiAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmRlY29kZShiLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKiogRGVsZWdhdGUgZW5jb2RpbmcgdG8ge0BsaW5rIFVuaW9uTGF5b3V0RGlzY3JpbWluYXRvciNsYXlvdXR8bGF5b3V0fS4gKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0LmVuY29kZShzcmMsIGIsIG9mZnNldCk7XG4gICAgfVxufVxuZXhwb3J0cy5VbmlvbkxheW91dERpc2NyaW1pbmF0b3IgPSBVbmlvbkxheW91dERpc2NyaW1pbmF0b3I7XG4vKipcbiAqIFJlcHJlc2VudCBhbnkgbnVtYmVyIG9mIHNwYW4tY29tcGF0aWJsZSBsYXlvdXRzLlxuICpcbiAqICpGYWN0b3J5Kjoge0BsaW5rIG1vZHVsZTpMYXlvdXQudW5pb258dW5pb259XG4gKlxuICogSWYgdGhlIHVuaW9uIGhhcyBhIHtAbGluayBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHQgbGF5b3V0fSB0aGF0XG4gKiBsYXlvdXQgbXVzdCBoYXZlIGEgbm9uLW5lZ2F0aXZlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufS4gIFRoZSBzcGFuXG4gKiBvZiBhIGZpeGVkLXNwYW4gdW5pb24gaW5jbHVkZXMgaXRzIHtAbGlua1xuICogVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSBpZiB0aGUgdmFyaWFudCBpcyBhIHtAbGlua1xuICogVW5pb24jdXNlc1ByZWZpeERpc2NyaW1pbmF0b3J8cHJlZml4IG9mIHRoZSB1bmlvbn0sIHBsdXMgdGhlIHNwYW5cbiAqIG9mIGl0cyB7QGxpbmsgVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0uXG4gKlxuICogSWYgdGhlIHVuaW9uIGRvZXMgbm90IGhhdmUgYSBkZWZhdWx0IGxheW91dCB0aGVuIHRoZSBlbmNvZGVkIHNwYW5cbiAqIG9mIHRoZSB1bmlvbiBkZXBlbmRzIG9uIHRoZSBlbmNvZGVkIHNwYW4gb2YgaXRzIHZhcmlhbnQgKHdoaWNoIG1heVxuICogYmUgZml4ZWQgb3IgdmFyaWFibGUpLlxuICpcbiAqIHtAbGluayBWYXJpYW50TGF5b3V0I2xheW91dHxWYXJpYW50IGxheW91dH1zIGFyZSBhZGRlZCB0aHJvdWdoXG4gKiB7QGxpbmsgVW5pb24jYWRkVmFyaWFudHxhZGRWYXJpYW50fS4gIElmIHRoZSB1bmlvbiBoYXMgYSBkZWZhdWx0XG4gKiBsYXlvdXQsIHRoZSBzcGFuIG9mIHRoZSB7QGxpbmsgVmFyaWFudExheW91dCNsYXlvdXR8bGF5b3V0XG4gKiBjb250YWluZWQgYnkgdGhlIHZhcmlhbnR9IG11c3Qgbm90IGV4Y2VlZCB0aGUgc3BhbiBvZiB0aGUge0BsaW5rXG4gKiBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHQgbGF5b3V0fSAobWludXMgdGhlIHNwYW4gb2YgYSB7QGxpbmtcbiAqIFVuaW9uI3VzZXNQcmVmaXhEaXNjcmltaW5hdG9yfHByZWZpeCBkaXNyaW1pbmF0b3J9LCBpZiB1c2VkKS4gIFRoZVxuICogc3BhbiBvZiB0aGUgdmFyaWFudCB3aWxsIGVxdWFsIHRoZSBzcGFuIG9mIHRoZSB1bmlvbiBpdHNlbGYuXG4gKlxuICogVGhlIHZhcmlhbnQgZm9yIGEgYnVmZmVyIGNhbiBvbmx5IGJlIGlkZW50aWZpZWQgZnJvbSB0aGUge0BsaW5rXG4gKiBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9IHtAbGlua1xuICogVW5pb25EaXNjcmltaW5hdG9yI3Byb3BlcnR5fHByb3BlcnR5fSAoaW4gdGhlIGNhc2Ugb2YgdGhlIHtAbGlua1xuICogVW5pb24jZGVmYXVsdExheW91dHxkZWZhdWx0IGxheW91dH0pLCBvciBieSB1c2luZyB7QGxpbmtcbiAqIFVuaW9uI2dldFZhcmlhbnR8Z2V0VmFyaWFudH0gYW5kIGV4YW1pbmluZyB0aGUgcmVzdWx0aW5nIHtAbGlua1xuICogVmFyaWFudExheW91dH0gaW5zdGFuY2UuXG4gKlxuICogQSB2YXJpYW50IGNvbXBhdGlibGUgd2l0aCBhIEphdmFTY3JpcHQgb2JqZWN0IGNhbiBiZSBpZGVudGlmaWVkXG4gKiB1c2luZyB7QGxpbmsgVW5pb24jZ2V0U291cmNlVmFyaWFudHxnZXRTb3VyY2VWYXJpYW50fS5cbiAqXG4gKiBAcGFyYW0geyhVbmlvbkRpc2NyaW1pbmF0b3J8RXh0ZXJuYWxMYXlvdXR8TGF5b3V0KX0gZGlzY3IgLSBIb3cgdG9cbiAqIGlkZW50aWZ5IHRoZSBsYXlvdXQgdXNlZCB0byBpbnRlcnByZXQgdGhlIHVuaW9uIGNvbnRlbnRzLiAgVGhlXG4gKiBwYXJhbWV0ZXIgbXVzdCBiZSBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgVW5pb25EaXNjcmltaW5hdG9yfSwgYW5cbiAqIHtAbGluayBFeHRlcm5hbExheW91dH0gdGhhdCBzYXRpc2ZpZXMge0BsaW5rXG4gKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnQoKX0sIG9yIHtAbGluayBVSW50fSAob3Ige0BsaW5rXG4gKiBVSW50QkV9KS4gIFdoZW4gYSBub24tZXh0ZXJuYWwgbGF5b3V0IGVsZW1lbnQgaXMgcGFzc2VkIHRoZSBsYXlvdXRcbiAqIGFwcGVhcnMgYXQgdGhlIHN0YXJ0IG9mIHRoZSB1bmlvbi4gIEluIGFsbCBjYXNlcyB0aGUgKHN5bnRoZXNpemVkKVxuICoge0BsaW5rIFVuaW9uRGlzY3JpbWluYXRvcn0gaW5zdGFuY2UgaXMgcmVjb3JkZWQgYXMge0BsaW5rXG4gKiBVbmlvbiNkaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9LlxuICpcbiAqIEBwYXJhbSB7KExheW91dHxudWxsKX0gZGVmYXVsdExheW91dCAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdExheW91dH0uICBJZiBhYnNlbnQgZGVmYXVsdHMgdG8gYG51bGxgLlxuICogSWYgYG51bGxgIHRoZXJlIGlzIG5vIGRlZmF1bHQgbGF5b3V0OiB0aGUgdW5pb24gaGFzIGRhdGEtZGVwZW5kZW50XG4gKiBsZW5ndGggYW5kIGF0dGVtcHRzIHRvIGRlY29kZSBvciBlbmNvZGUgdW5yZWNvZ25pemVkIHZhcmlhbnRzIHdpbGxcbiAqIHRocm93IGFuIGV4Y2VwdGlvbi4gIEEge0BsaW5rIExheW91dH0gaW5zdGFuY2UgbXVzdCBoYXZlIGFcbiAqIG5vbi1uZWdhdGl2ZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0sIGFuZCBpZiBpdCBsYWNrcyBhIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fSB0aGUge0BsaW5rXG4gKiBVbmlvbiNkZWZhdWx0TGF5b3V0fGRlZmF1bHRMYXlvdXR9IHdpbGwgYmUgYSB7QGxpbmtcbiAqIExheW91dCNyZXBsaWNhdGV8cmVwbGljYX0gd2l0aCBwcm9wZXJ0eSBgY29udGVudGAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBVbmlvbiBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IoZGlzY3IsIGRlZmF1bHRMYXlvdXQsIHByb3BlcnR5KSB7XG4gICAgICAgIGxldCBkaXNjcmltaW5hdG9yO1xuICAgICAgICBpZiAoKGRpc2NyIGluc3RhbmNlb2YgVUludClcbiAgICAgICAgICAgIHx8IChkaXNjciBpbnN0YW5jZW9mIFVJbnRCRSkpIHtcbiAgICAgICAgICAgIGRpc2NyaW1pbmF0b3IgPSBuZXcgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yKG5ldyBPZmZzZXRMYXlvdXQoZGlzY3IpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoZGlzY3IgaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dClcbiAgICAgICAgICAgICYmIGRpc2NyLmlzQ291bnQoKSkge1xuICAgICAgICAgICAgZGlzY3JpbWluYXRvciA9IG5ldyBVbmlvbkxheW91dERpc2NyaW1pbmF0b3IoZGlzY3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoZGlzY3IgaW5zdGFuY2VvZiBVbmlvbkRpc2NyaW1pbmF0b3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdkaXNjciBtdXN0IGJlIGEgVW5pb25EaXNjcmltaW5hdG9yICdcbiAgICAgICAgICAgICAgICArICdvciBhbiB1bnNpZ25lZCBpbnRlZ2VyIGxheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGlzY3JpbWluYXRvciA9IGRpc2NyO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IGRlZmF1bHRMYXlvdXQpIHtcbiAgICAgICAgICAgIGRlZmF1bHRMYXlvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKChudWxsID09PSBkZWZhdWx0TGF5b3V0KVxuICAgICAgICAgICAgfHwgKGRlZmF1bHRMYXlvdXQgaW5zdGFuY2VvZiBMYXlvdXQpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZGVmYXVsdExheW91dCBtdXN0IGJlIG51bGwgb3IgYSBMYXlvdXQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnVsbCAhPT0gZGVmYXVsdExheW91dCkge1xuICAgICAgICAgICAgaWYgKDAgPiBkZWZhdWx0TGF5b3V0LnNwYW4pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RlZmF1bHRMYXlvdXQgbXVzdCBoYXZlIGNvbnN0YW50IHNwYW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmRlZmluZWQgPT09IGRlZmF1bHRMYXlvdXQucHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBkZWZhdWx0TGF5b3V0ID0gZGVmYXVsdExheW91dC5yZXBsaWNhdGUoJ2NvbnRlbnQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBUaGUgdW5pb24gc3BhbiBjYW4gYmUgZXN0aW1hdGVkIG9ubHkgaWYgdGhlcmUncyBhIGRlZmF1bHRcbiAgICAgICAgICogbGF5b3V0LiAgVGhlIHVuaW9uIHNwYW5zIGl0cyBkZWZhdWx0IGxheW91dCwgcGx1cyBhbnkgcHJlZml4XG4gICAgICAgICAqIHZhcmlhbnQgbGF5b3V0LiAgQnkgY29uc3RydWN0aW9uIGJvdGggbGF5b3V0cywgaWYgcHJlc2VudCwgaGF2ZVxuICAgICAgICAgKiBub24tbmVnYXRpdmUgc3Bhbi4gKi9cbiAgICAgICAgbGV0IHNwYW4gPSAtMTtcbiAgICAgICAgaWYgKGRlZmF1bHRMYXlvdXQpIHtcbiAgICAgICAgICAgIHNwYW4gPSBkZWZhdWx0TGF5b3V0LnNwYW47XG4gICAgICAgICAgICBpZiAoKDAgPD0gc3BhbikgJiYgKChkaXNjciBpbnN0YW5jZW9mIFVJbnQpXG4gICAgICAgICAgICAgICAgfHwgKGRpc2NyIGluc3RhbmNlb2YgVUludEJFKSkpIHtcbiAgICAgICAgICAgICAgICBzcGFuICs9IGRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIGludGVyZmFjZSBmb3IgdGhlIGRpc2NyaW1pbmF0b3IgdmFsdWUgaW4gaXNvbGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIGEge0BsaW5rIFVuaW9uRGlzY3JpbWluYXRvcn0gZWl0aGVyIHBhc3NlZCB0byB0aGVcbiAgICAgICAgICogY29uc3RydWN0b3Igb3Igc3ludGhlc2l6ZWQgZnJvbSB0aGUgYGRpc2NyYCBjb25zdHJ1Y3RvclxuICAgICAgICAgKiBhcmd1bWVudC4gIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiN1c2VzUHJlZml4RGlzY3JpbWluYXRvcnx1c2VzUHJlZml4RGlzY3JpbWluYXRvcn0gd2lsbCBiZVxuICAgICAgICAgKiBgdHJ1ZWAgaWZmIHRoZSBgZGlzY3JgIHBhcmFtZXRlciB3YXMgYSBub24tb2Zmc2V0IHtAbGlua1xuICAgICAgICAgKiBMYXlvdXR9IGluc3RhbmNlLiAqL1xuICAgICAgICB0aGlzLmRpc2NyaW1pbmF0b3IgPSBkaXNjcmltaW5hdG9yO1xuICAgICAgICAvKiogYHRydWVgIGlmIHRoZSB7QGxpbmsgVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSBpcyB0aGVcbiAgICAgICAgICogZmlyc3QgZmllbGQgaW4gdGhlIHVuaW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBgZmFsc2VgIHRoZSBkaXNjcmltaW5hdG9yIGlzIG9idGFpbmVkIGZyb20gc29tZXdoZXJlXG4gICAgICAgICAqIGVsc2UuICovXG4gICAgICAgIHRoaXMudXNlc1ByZWZpeERpc2NyaW1pbmF0b3IgPSAoZGlzY3IgaW5zdGFuY2VvZiBVSW50KVxuICAgICAgICAgICAgfHwgKGRpc2NyIGluc3RhbmNlb2YgVUludEJFKTtcbiAgICAgICAgLyoqIFRoZSBsYXlvdXQgZm9yIG5vbi1kaXNjcmltaW5hdG9yIGNvbnRlbnQgd2hlbiB0aGUgdmFsdWUgb2YgdGhlXG4gICAgICAgICAqIGRpc2NyaW1pbmF0b3IgaXMgbm90IHJlY29nbml6ZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoaXMgaXMgdGhlIHZhbHVlIHBhc3NlZCB0byB0aGUgY29uc3RydWN0b3IuICBJdCBpc1xuICAgICAgICAgKiBzdHJ1Y3R1cmFsbHkgZXF1aXZhbGVudCB0byB0aGUgc2Vjb25kIGNvbXBvbmVudCBvZiB7QGxpbmtcbiAgICAgICAgICogVW5pb24jbGF5b3V0fGxheW91dH0gYnV0IG1heSBoYXZlIGEgZGlmZmVyZW50IHByb3BlcnR5XG4gICAgICAgICAqIG5hbWUuICovXG4gICAgICAgIHRoaXMuZGVmYXVsdExheW91dCA9IGRlZmF1bHRMYXlvdXQ7XG4gICAgICAgIC8qKiBBIHJlZ2lzdHJ5IG9mIGFsbG93ZWQgdmFyaWFudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBrZXlzIGFyZSB1bnNpZ25lZCBpbnRlZ2VycyB3aGljaCBzaG91bGQgYmUgY29tcGF0aWJsZSB3aXRoXG4gICAgICAgICAqIHtAbGluayBVbmlvbi5kaXNjcmltaW5hdG9yfGRpc2NyaW1pbmF0b3J9LiAgVGhlIHByb3BlcnR5IHZhbHVlXG4gICAgICAgICAqIGlzIHRoZSBjb3JyZXNwb25kaW5nIHtAbGluayBWYXJpYW50TGF5b3V0fSBpbnN0YW5jZXMgYXNzaWduZWRcbiAgICAgICAgICogdG8gdGhpcyB1bmlvbiBieSB7QGxpbmsgVW5pb24jYWRkVmFyaWFudHxhZGRWYXJpYW50fS5cbiAgICAgICAgICpcbiAgICAgICAgICogKipOT1RFKiogVGhlIHJlZ2lzdHJ5IHJlbWFpbnMgbXV0YWJsZSBzbyB0aGF0IHZhcmlhbnRzIGNhbiBiZVxuICAgICAgICAgKiB7QGxpbmsgVW5pb24jYWRkVmFyaWFudHxhZGRlZH0gYXQgYW55IHRpbWUuICBVc2VycyBzaG91bGQgbm90XG4gICAgICAgICAqIG1hbmlwdWxhdGUgdGhlIGNvbnRlbnQgb2YgdGhpcyBwcm9wZXJ0eS4gKi9cbiAgICAgICAgdGhpcy5yZWdpc3RyeSA9IHt9O1xuICAgICAgICAvKiBQcml2YXRlIHZhcmlhYmxlIHVzZWQgd2hlbiBpbnZva2luZyBnZXRTb3VyY2VWYXJpYW50ICovXG4gICAgICAgIGxldCBib3VuZEdldFNvdXJjZVZhcmlhbnQgPSB0aGlzLmRlZmF1bHRHZXRTb3VyY2VWYXJpYW50LmJpbmQodGhpcyk7XG4gICAgICAgIC8qKiBGdW5jdGlvbiB0byBpbmZlciB0aGUgdmFyaWFudCBzZWxlY3RlZCBieSBhIHNvdXJjZSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIERlZmF1bHRzIHRvIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNkZWZhdWx0R2V0U291cmNlVmFyaWFudHxkZWZhdWx0R2V0U291cmNlVmFyaWFudH0gYnV0IG1heVxuICAgICAgICAgKiBiZSBvdmVycmlkZGVuIHVzaW5nIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNjb25maWdHZXRTb3VyY2VWYXJpYW50fGNvbmZpZ0dldFNvdXJjZVZhcmlhbnR9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gc3JjIC0gYXMgd2l0aCB7QGxpbmtcbiAgICAgICAgICogVW5pb24jZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR8ZGVmYXVsdEdldFNvdXJjZVZhcmlhbnR9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7KHVuZGVmaW5lZHxWYXJpYW50TGF5b3V0KX0gVGhlIGRlZmF1bHQgdmFyaWFudFxuICAgICAgICAgKiAoYHVuZGVmaW5lZGApIG9yIGZpcnN0IHJlZ2lzdGVyZWQgdmFyaWFudCB0aGF0IHVzZXMgYSBwcm9wZXJ0eVxuICAgICAgICAgKiBhdmFpbGFibGUgaW4gYHNyY2AuICovXG4gICAgICAgIHRoaXMuZ2V0U291cmNlVmFyaWFudCA9IGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgICAgIHJldHVybiBib3VuZEdldFNvdXJjZVZhcmlhbnQoc3JjKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIEZ1bmN0aW9uIHRvIG92ZXJyaWRlIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmtcbiAgICAgICAgICogVW5pb24jZ2V0U291cmNlVmFyaWFudHxnZXRTb3VyY2VWYXJpYW50fS5cbiAgICAgICAgICpcbiAgICAgICAgICogVXNlIHRoaXMgaWYgdGhlIGRlc2lyZWQgdmFyaWFudCBjYW5ub3QgYmUgaWRlbnRpZmllZCB1c2luZyB0aGVcbiAgICAgICAgICogYWxnb3JpdGhtIG9mIHtAbGlua1xuICAgICAgICAgKiBVbmlvbiNkZWZhdWx0R2V0U291cmNlVmFyaWFudHxkZWZhdWx0R2V0U291cmNlVmFyaWFudH0uXG4gICAgICAgICAqXG4gICAgICAgICAqICoqTk9URSoqIFRoZSBwcm92aWRlZCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgYm91bmQgdG8gdGhpc1xuICAgICAgICAgKiBVbmlvbiBpbnN0YW5jZSwgcHJvdmlkaW5nIGxvY2FsIGFjY2VzcyB0byB7QGxpbmtcbiAgICAgICAgICogVW5pb24jcmVnaXN0cnl8cmVnaXN0cnl9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBnc3YgLSBhIGZ1bmN0aW9uIHRoYXQgZm9sbG93cyB0aGUgQVBJIG9mXG4gICAgICAgICAqIHtAbGluayBVbmlvbiNkZWZhdWx0R2V0U291cmNlVmFyaWFudHxkZWZhdWx0R2V0U291cmNlVmFyaWFudH0uICovXG4gICAgICAgIHRoaXMuY29uZmlnR2V0U291cmNlVmFyaWFudCA9IGZ1bmN0aW9uIChnc3YpIHtcbiAgICAgICAgICAgIGJvdW5kR2V0U291cmNlVmFyaWFudCA9IGdzdi5iaW5kKHRoaXMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGlmICgwIDw9IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICAvKiBEZWZhdWx0IGxheW91dHMgYWx3YXlzIGhhdmUgbm9uLW5lZ2F0aXZlIHNwYW4sIHNvIHdlIGRvbid0IGhhdmVcbiAgICAgICAgICogb25lIGFuZCB3ZSBoYXZlIHRvIHJlY29nbml6ZSB0aGUgdmFyaWFudCB3aGljaCB3aWxsIGluIHR1cm5cbiAgICAgICAgICogZGV0ZXJtaW5lIHRoZSBzcGFuLiAqL1xuICAgICAgICBjb25zdCB2bG8gPSB0aGlzLmdldFZhcmlhbnQoYiwgb2Zmc2V0KTtcbiAgICAgICAgaWYgKCF2bG8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndW5hYmxlIHRvIGRldGVybWluZSBzcGFuIGZvciB1bnJlY29nbml6ZWQgdmFyaWFudCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2bG8uZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gaW5mZXIgYSByZWdpc3RlcmVkIFVuaW9uIHZhcmlhbnQgY29tcGF0aWJsZSB3aXRoIGBzcmNgLlxuICAgICAqXG4gICAgICogVGhlIGZpcnN0IHNhdGlzZmllZCBydWxlIGluIHRoZSBmb2xsb3dpbmcgc2VxdWVuY2UgZGVmaW5lcyB0aGVcbiAgICAgKiByZXR1cm4gdmFsdWU6XG4gICAgICogKiBJZiBgc3JjYCBoYXMgcHJvcGVydGllcyBtYXRjaGluZyB0aGUgVW5pb24gZGlzY3JpbWluYXRvciBhbmRcbiAgICAgKiAgIHRoZSBkZWZhdWx0IGxheW91dCwgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQgcmVnYXJkbGVzcyBvZiB0aGVcbiAgICAgKiAgIHZhbHVlIG9mIHRoZSBkaXNjcmltaW5hdG9yIHByb3BlcnR5ICh0aGlzIGVuc3VyZXMgdGhlIGRlZmF1bHRcbiAgICAgKiAgIGxheW91dCB3aWxsIGJlIHVzZWQpO1xuICAgICAqICogSWYgYHNyY2AgaGFzIGEgcHJvcGVydHkgbWF0Y2hpbmcgdGhlIFVuaW9uIGRpc2NyaW1pbmF0b3IsIHRoZVxuICAgICAqICAgdmFsdWUgb2YgdGhlIGRpc2NyaW1pbmF0b3IgaWRlbnRpZmllcyBhIHJlZ2lzdGVyZWQgdmFyaWFudCwgYW5kXG4gICAgICogICBlaXRoZXIgKGEpIHRoZSB2YXJpYW50IGhhcyBubyBsYXlvdXQsIG9yIChiKSBgc3JjYCBoYXMgdGhlXG4gICAgICogICB2YXJpYW50J3MgcHJvcGVydHksIHRoZW4gdGhlIHZhcmlhbnQgaXMgcmV0dXJuZWQgKGJlY2F1c2UgdGhlXG4gICAgICogICBzb3VyY2Ugc2F0aXNmaWVzIHRoZSBjb25zdHJhaW50cyBvZiB0aGUgdmFyaWFudCBpdCBpZGVudGlmaWVzKTtcbiAgICAgKiAqIElmIGBzcmNgIGRvZXMgbm90IGhhdmUgYSBwcm9wZXJ0eSBtYXRjaGluZyB0aGUgVW5pb25cbiAgICAgKiAgIGRpc2NyaW1pbmF0b3IsIGJ1dCBkb2VzIGhhdmUgYSBwcm9wZXJ0eSBtYXRjaGluZyBhIHJlZ2lzdGVyZWRcbiAgICAgKiAgIHZhcmlhbnQsIHRoZW4gdGhlIHZhcmlhbnQgaXMgcmV0dXJuZWQgKGJlY2F1c2UgdGhlIHNvdXJjZVxuICAgICAqICAgbWF0Y2hlcyBhIHZhcmlhbnQgd2l0aG91dCBhbiBleHBsaWNpdCBjb25mbGljdCk7XG4gICAgICogKiBBbiBlcnJvciBpcyB0aHJvd24gKGJlY2F1c2Ugd2UgZWl0aGVyIGNhbid0IGlkZW50aWZ5IGEgdmFyaWFudCxcbiAgICAgKiAgIG9yIHdlIHdlcmUgZXhwbGljaXRseSB0b2xkIHRoZSB2YXJpYW50IGJ1dCBjYW4ndCBzYXRpc2Z5IGl0KS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcmMgLSBhbiBvYmplY3QgcHJlc3VtZWQgdG8gYmUgY29tcGF0aWJsZSB3aXRoXG4gICAgICogdGhlIGNvbnRlbnQgb2YgdGhlIFVuaW9uLlxuICAgICAqXG4gICAgICogQHJldHVybiB7KHVuZGVmaW5lZHxWYXJpYW50TGF5b3V0KX0gLSBhcyBkZXNjcmliZWQgYWJvdmUuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtFcnJvcn0gLSBpZiBgc3JjYCBjYW5ub3QgYmUgYXNzb2NpYXRlZCB3aXRoIGEgZGVmYXVsdCBvclxuICAgICAqIHJlZ2lzdGVyZWQgdmFyaWFudC5cbiAgICAgKi9cbiAgICBkZWZhdWx0R2V0U291cmNlVmFyaWFudChzcmMpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIHRoaXMuZGlzY3JpbWluYXRvci5wcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRlZmF1bHRMYXlvdXQgJiYgdGhpcy5kZWZhdWx0TGF5b3V0LnByb3BlcnR5XG4gICAgICAgICAgICAgICAgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgdGhpcy5kZWZhdWx0TGF5b3V0LnByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2bG8gPSB0aGlzLnJlZ2lzdHJ5W3NyY1t0aGlzLmRpc2NyaW1pbmF0b3IucHJvcGVydHldXTtcbiAgICAgICAgICAgIGlmICh2bG9cbiAgICAgICAgICAgICAgICAmJiAoKCF2bG8ubGF5b3V0KVxuICAgICAgICAgICAgICAgICAgICB8fCAodmxvLnByb3BlcnR5ICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIHZsby5wcm9wZXJ0eSkpKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2bG87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRhZyBpbiB0aGlzLnJlZ2lzdHJ5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmxvID0gdGhpcy5yZWdpc3RyeVt0YWddO1xuICAgICAgICAgICAgICAgIGlmICh2bG8ucHJvcGVydHkgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNyYywgdmxvLnByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmxvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBpbmZlciBzcmMgdmFyaWFudCcpO1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZGVjb2RlfGRlY29kZX0gZm9yIHtAbGluayBVbmlvbn0uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdmFyaWFudCBpcyB7QGxpbmsgVW5pb24jYWRkVmFyaWFudHxyZWdpc3RlcmVkfSB0aGUgcmV0dXJuXG4gICAgICogdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgdGhhdCB2YXJpYW50LCB3aXRoIG5vIGV4cGxpY2l0XG4gICAgICogZGlzY3JpbWluYXRvci4gIE90aGVyd2lzZSB0aGUge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdFxuICAgICAqIGxheW91dH0gaXMgdXNlZCB0byBkZWNvZGUgdGhlIGNvbnRlbnQuICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGRlc3Q7XG4gICAgICAgIGNvbnN0IGRsbyA9IHRoaXMuZGlzY3JpbWluYXRvcjtcbiAgICAgICAgY29uc3QgZGlzY3IgPSBkbG8uZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIGNvbnN0IGNsbyA9IHRoaXMucmVnaXN0cnlbZGlzY3JdO1xuICAgICAgICBpZiAodW5kZWZpbmVkID09PSBjbG8pIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRMYXlvdXQgPSB0aGlzLmRlZmF1bHRMYXlvdXQ7XG4gICAgICAgICAgICBsZXQgY29udGVudE9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRPZmZzZXQgPSBkbG8ubGF5b3V0LnNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgICAgICAgIGRlc3RbZGxvLnByb3BlcnR5XSA9IGRpc2NyO1xuICAgICAgICAgICAgLy8gZGVmYXVsdExheW91dC5wcm9wZXJ0eSBjYW4gYmUgdW5kZWZpbmVkLCBidXQgdGhpcyBpcyBhbGxvd2VkIGJ5IGJ1ZmZlci1sYXlvdXRcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBkZXN0W2RlZmF1bHRMYXlvdXQucHJvcGVydHldID0gZGVmYXVsdExheW91dC5kZWNvZGUoYiwgb2Zmc2V0ICsgY29udGVudE9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZXN0ID0gY2xvLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBVbmlvbn0uXG4gICAgICpcbiAgICAgKiBUaGlzIEFQSSBhc3N1bWVzIHRoZSBgc3JjYCBvYmplY3QgaXMgY29uc2lzdGVudCB3aXRoIHRoZSB1bmlvbidzXG4gICAgICoge0BsaW5rIFVuaW9uI2RlZmF1bHRMYXlvdXR8ZGVmYXVsdCBsYXlvdXR9LiAgVG8gZW5jb2RlIHZhcmlhbnRzXG4gICAgICogdXNlIHRoZSBhcHByb3ByaWF0ZSB2YXJpYW50LXNwZWNpZmljIHtAbGluayBWYXJpYW50TGF5b3V0I2VuY29kZX1cbiAgICAgKiBtZXRob2QuICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCB2bG8gPSB0aGlzLmdldFNvdXJjZVZhcmlhbnQoc3JjKTtcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gdmxvKSB7XG4gICAgICAgICAgICBjb25zdCBkbG8gPSB0aGlzLmRpc2NyaW1pbmF0b3I7XG4gICAgICAgICAgICAvLyB0aGlzLmRlZmF1bHRMYXlvdXQgaXMgbm90IHVuZGVmaW5lZCB3aGVuIHZsbyBpcyB1bmRlZmluZWRcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICBjb25zdCBjbG8gPSB0aGlzLmRlZmF1bHRMYXlvdXQ7XG4gICAgICAgICAgICBsZXQgY29udGVudE9mZnNldCA9IDA7XG4gICAgICAgICAgICBpZiAodGhpcy51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgICAgIGNvbnRlbnRPZmZzZXQgPSBkbG8ubGF5b3V0LnNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkbG8uZW5jb2RlKHNyY1tkbG8ucHJvcGVydHldLCBiLCBvZmZzZXQpO1xuICAgICAgICAgICAgLy8gY2xvLnByb3BlcnR5IGlzIG5vdCB1bmRlZmluZWQgd2hlbiB2bG8gaXMgdW5kZWZpbmVkXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnRPZmZzZXQgKyBjbG8uZW5jb2RlKHNyY1tjbG8ucHJvcGVydHldLCBiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmxvLmVuY29kZShzcmMsIGIsIG9mZnNldCk7XG4gICAgfVxuICAgIC8qKiBSZWdpc3RlciBhIG5ldyB2YXJpYW50IHN0cnVjdHVyZSB3aXRoaW4gYSB1bmlvbi4gIFRoZSBuZXdseVxuICAgICAqIGNyZWF0ZWQgdmFyaWFudCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YXJpYW50IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICAgICAqIFZhcmlhbnRMYXlvdXQjdmFyaWFudHx2YXJpYW50fS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TGF5b3V0fSBsYXlvdXQgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gICAgICogVmFyaWFudExheW91dCNsYXlvdXR8bGF5b3V0fS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICAgICAqXG4gICAgICogQHJldHVybiB7VmFyaWFudExheW91dH0gKi9cbiAgICBhZGRWYXJpYW50KHZhcmlhbnQsIGxheW91dCwgcHJvcGVydHkpIHtcbiAgICAgICAgY29uc3QgcnYgPSBuZXcgVmFyaWFudExheW91dCh0aGlzLCB2YXJpYW50LCBsYXlvdXQsIHByb3BlcnR5KTtcbiAgICAgICAgdGhpcy5yZWdpc3RyeVt2YXJpYW50XSA9IHJ2O1xuICAgICAgICByZXR1cm4gcnY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGF5b3V0IGFzc29jaWF0ZWQgd2l0aCBhIHJlZ2lzdGVyZWQgdmFyaWFudC5cbiAgICAgKlxuICAgICAqIElmIGB2YmAgZG9lcyBub3QgcHJvZHVjZSBhIHJlZ2lzdGVyZWQgdmFyaWFudCB0aGUgZnVuY3Rpb24gcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHsoTnVtYmVyfFVpbnQ4QXJyYXkpfSB2YiAtIGVpdGhlciB0aGUgdmFyaWFudCBudW1iZXIsIG9yIGFcbiAgICAgKiBidWZmZXIgZnJvbSB3aGljaCB0aGUgZGlzY3JpbWluYXRvciBpcyB0byBiZSByZWFkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCAtIG9mZnNldCBpbnRvIGB2YmAgZm9yIHRoZSBzdGFydCBvZiB0aGVcbiAgICAgKiB1bmlvbi4gIFVzZWQgb25seSB3aGVuIGB2YmAgaXMgYW4gaW5zdGFuY2Ugb2Yge1VpbnQ4QXJyYXl9LlxuICAgICAqXG4gICAgICogQHJldHVybiB7KHtWYXJpYW50TGF5b3V0fXx1bmRlZmluZWQpfVxuICAgICAqL1xuICAgIGdldFZhcmlhbnQodmIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IHZhcmlhbnQ7XG4gICAgICAgIGlmICh2YiBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgIHZhcmlhbnQgPSB0aGlzLmRpc2NyaW1pbmF0b3IuZGVjb2RlKHZiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyaWFudCA9IHZiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdHJ5W3ZhcmlhbnRdO1xuICAgIH1cbn1cbmV4cG9ydHMuVW5pb24gPSBVbmlvbjtcbi8qKlxuICogUmVwcmVzZW50IGEgc3BlY2lmaWMgdmFyaWFudCB3aXRoaW4gYSBjb250YWluaW5nIHVuaW9uLlxuICpcbiAqICoqTk9URSoqIFRoZSB7QGxpbmsgTGF5b3V0I3NwYW58c3Bhbn0gb2YgdGhlIHZhcmlhbnQgbWF5IGluY2x1ZGVcbiAqIHRoZSBzcGFuIG9mIHRoZSB7QGxpbmsgVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSB1c2VkIHRvXG4gKiBpZGVudGlmeSBpdCwgYnV0IHZhbHVlcyByZWFkIGFuZCB3cml0dGVuIHVzaW5nIHRoZSB2YXJpYW50IHN0cmljdGx5XG4gKiBjb25mb3JtIHRvIHRoZSBjb250ZW50IG9mIHtAbGluayBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LlxuICpcbiAqICoqTk9URSoqIFVzZXIgY29kZSBzaG91bGQgbm90IGludm9rZSB0aGlzIGNvbnN0cnVjdG9yIGRpcmVjdGx5LiAgVXNlXG4gKiB0aGUgdW5pb24ge0BsaW5rIFVuaW9uI2FkZFZhcmlhbnR8YWRkVmFyaWFudH0gaGVscGVyIG1ldGhvZC5cbiAqXG4gKiBAcGFyYW0ge1VuaW9ufSB1bmlvbiAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXQjdW5pb258dW5pb259LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YXJpYW50IC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogVmFyaWFudExheW91dCN2YXJpYW50fHZhcmlhbnR9LlxuICpcbiAqIEBwYXJhbSB7TGF5b3V0fSBbbGF5b3V0XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIFZhcmlhbnRMYXlvdXQjbGF5b3V0fGxheW91dH0uICBJZiBhYnNlbnQgdGhlIHZhcmlhbnQgY2FycmllcyBub1xuICogZGF0YS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uICBVbmxpa2UgbWFueSBvdGhlciBsYXlvdXRzLCB2YXJpYW50XG4gKiBsYXlvdXRzIG5vcm1hbGx5IGluY2x1ZGUgYSBwcm9wZXJ0eSBuYW1lIHNvIHRoZXkgY2FuIGJlIGlkZW50aWZpZWRcbiAqIHdpdGhpbiB0aGVpciBjb250YWluaW5nIHtAbGluayBVbmlvbn0uICBUaGUgcHJvcGVydHkgaWRlbnRpZmllciBtYXlcbiAqIGJlIGFic2VudCBvbmx5IGlmIGBsYXlvdXRgIGlzIGlzIGFic2VudC5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgVmFyaWFudExheW91dCBleHRlbmRzIExheW91dCB7XG4gICAgY29uc3RydWN0b3IodW5pb24sIHZhcmlhbnQsIGxheW91dCwgcHJvcGVydHkpIHtcbiAgICAgICAgaWYgKCEodW5pb24gaW5zdGFuY2VvZiBVbmlvbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3VuaW9uIG11c3QgYmUgYSBVbmlvbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIU51bWJlci5pc0ludGVnZXIodmFyaWFudCkpIHx8ICgwID4gdmFyaWFudCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhcmlhbnQgbXVzdCBiZSBhIChub24tbmVnYXRpdmUpIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKCdzdHJpbmcnID09PSB0eXBlb2YgbGF5b3V0KVxuICAgICAgICAgICAgJiYgKHVuZGVmaW5lZCA9PT0gcHJvcGVydHkpKSB7XG4gICAgICAgICAgICBwcm9wZXJ0eSA9IGxheW91dDtcbiAgICAgICAgICAgIGxheW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxheW91dCkge1xuICAgICAgICAgICAgaWYgKCEobGF5b3V0IGluc3RhbmNlb2YgTGF5b3V0KSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xheW91dCBtdXN0IGJlIGEgTGF5b3V0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKG51bGwgIT09IHVuaW9uLmRlZmF1bHRMYXlvdXQpXG4gICAgICAgICAgICAgICAgJiYgKDAgPD0gbGF5b3V0LnNwYW4pXG4gICAgICAgICAgICAgICAgJiYgKGxheW91dC5zcGFuID4gdW5pb24uZGVmYXVsdExheW91dC5zcGFuKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndmFyaWFudCBzcGFuIGV4Y2VlZHMgc3BhbiBvZiBjb250YWluaW5nIHVuaW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoJ3N0cmluZycgIT09IHR5cGVvZiBwcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhcmlhbnQgbXVzdCBoYXZlIGEgU3RyaW5nIHByb3BlcnR5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHNwYW4gPSB1bmlvbi5zcGFuO1xuICAgICAgICBpZiAoMCA+IHVuaW9uLnNwYW4pIHtcbiAgICAgICAgICAgIHNwYW4gPSBsYXlvdXQgPyBsYXlvdXQuc3BhbiA6IDA7XG4gICAgICAgICAgICBpZiAoKDAgPD0gc3BhbikgJiYgdW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgICAgICBzcGFuICs9IHVuaW9uLmRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIHtAbGluayBVbmlvbn0gdG8gd2hpY2ggdGhpcyB2YXJpYW50IGJlbG9uZ3MuICovXG4gICAgICAgIHRoaXMudW5pb24gPSB1bmlvbjtcbiAgICAgICAgLyoqIFRoZSB1bnNpZ25lZCBpbnRlZ3JhbCB2YWx1ZSBpZGVudGlmeWluZyB0aGlzIHZhcmlhbnQgd2l0aGluXG4gICAgICAgICAqIHRoZSB7QGxpbmsgVW5pb24jZGlzY3JpbWluYXRvcnxkaXNjcmltaW5hdG9yfSBvZiB0aGUgY29udGFpbmluZ1xuICAgICAgICAgKiB1bmlvbi4gKi9cbiAgICAgICAgdGhpcy52YXJpYW50ID0gdmFyaWFudDtcbiAgICAgICAgLyoqIFRoZSB7QGxpbmsgTGF5b3V0fSB0byBiZSB1c2VkIHdoZW4gcmVhZGluZy93cml0aW5nIHRoZVxuICAgICAgICAgKiBub24tZGlzY3JpbWluYXRvciBwYXJ0IG9mIHRoZSB7QGxpbmtcbiAgICAgICAgICogVmFyaWFudExheW91dCN1bmlvbnx1bmlvbn0uICBJZiBgbnVsbGAgdGhlIHZhcmlhbnQgY2FycmllcyBub1xuICAgICAgICAgKiBkYXRhLiAqL1xuICAgICAgICB0aGlzLmxheW91dCA9IGxheW91dCB8fCBudWxsO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGlmICgwIDw9IHRoaXMuc3Bhbikge1xuICAgICAgICAgICAgLyogV2lsbCBiZSBlcXVhbCB0byB0aGUgY29udGFpbmluZyB1bmlvbiBzcGFuIGlmIHRoYXQgaXMgbm90XG4gICAgICAgICAgICAgKiB2YXJpYWJsZS4gKi9cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvbnRlbnRPZmZzZXQgPSAwO1xuICAgICAgICBpZiAodGhpcy51bmlvbi51c2VzUHJlZml4RGlzY3JpbWluYXRvcikge1xuICAgICAgICAgICAgY29udGVudE9mZnNldCA9IHRoaXMudW5pb24uZGlzY3JpbWluYXRvci5sYXlvdXQuc3BhbjtcbiAgICAgICAgfVxuICAgICAgICAvKiBTcGFuIGlzIGRlZmluZWQgc29sZWx5IGJ5IHRoZSB2YXJpYW50IChhbmQgcHJlZml4IGRpc2NyaW1pbmF0b3IpICovXG4gICAgICAgIGxldCBzcGFuID0gMDtcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0KSB7XG4gICAgICAgICAgICBzcGFuID0gdGhpcy5sYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGVudE9mZnNldCArIHNwYW47XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBkZXN0ID0gdGhpcy5tYWtlRGVzdGluYXRpb25PYmplY3QoKTtcbiAgICAgICAgaWYgKHRoaXMgIT09IHRoaXMudW5pb24uZ2V0VmFyaWFudChiLCBvZmZzZXQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ZhcmlhbnQgbWlzbWF0Y2gnKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29udGVudE9mZnNldCA9IDA7XG4gICAgICAgIGlmICh0aGlzLnVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICBjb250ZW50T2Zmc2V0ID0gdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLmxheW91dC5zcGFuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxheW91dCkge1xuICAgICAgICAgICAgZGVzdFt0aGlzLnByb3BlcnR5XSA9IHRoaXMubGF5b3V0LmRlY29kZShiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BlcnR5KSB7XG4gICAgICAgICAgICBkZXN0W3RoaXMucHJvcGVydHldID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnVuaW9uLnVzZXNQcmVmaXhEaXNjcmltaW5hdG9yKSB7XG4gICAgICAgICAgICBkZXN0W3RoaXMudW5pb24uZGlzY3JpbWluYXRvci5wcm9wZXJ0eV0gPSB0aGlzLnZhcmlhbnQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc3Q7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGxldCBjb250ZW50T2Zmc2V0ID0gMDtcbiAgICAgICAgaWYgKHRoaXMudW5pb24udXNlc1ByZWZpeERpc2NyaW1pbmF0b3IpIHtcbiAgICAgICAgICAgIGNvbnRlbnRPZmZzZXQgPSB0aGlzLnVuaW9uLmRpc2NyaW1pbmF0b3IubGF5b3V0LnNwYW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubGF5b3V0XG4gICAgICAgICAgICAmJiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcmMsIHRoaXMucHJvcGVydHkpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFyaWFudCBsYWNrcyBwcm9wZXJ0eSAnICsgdGhpcy5wcm9wZXJ0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51bmlvbi5kaXNjcmltaW5hdG9yLmVuY29kZSh0aGlzLnZhcmlhbnQsIGIsIG9mZnNldCk7XG4gICAgICAgIGxldCBzcGFuID0gY29udGVudE9mZnNldDtcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0KSB7XG4gICAgICAgICAgICB0aGlzLmxheW91dC5lbmNvZGUoc3JjW3RoaXMucHJvcGVydHldLCBiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICAgICAgICAgIHNwYW4gKz0gdGhpcy5sYXlvdXQuZ2V0U3BhbihiLCBvZmZzZXQgKyBjb250ZW50T2Zmc2V0KTtcbiAgICAgICAgICAgIGlmICgoMCA8PSB0aGlzLnVuaW9uLnNwYW4pXG4gICAgICAgICAgICAgICAgJiYgKHNwYW4gPiB0aGlzLnVuaW9uLnNwYW4pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdlbmNvZGVkIHZhcmlhbnQgb3ZlcnJ1bnMgY29udGFpbmluZyB1bmlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICAvKiogRGVsZWdhdGUge0BsaW5rIExheW91dCNmcm9tQXJyYXl8ZnJvbUFycmF5fSB0byB7QGxpbmtcbiAgICAgKiBWYXJpYW50TGF5b3V0I2xheW91dHxsYXlvdXR9LiAqL1xuICAgIGZyb21BcnJheSh2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHRoaXMubGF5b3V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sYXlvdXQuZnJvbUFycmF5KHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLlZhcmlhbnRMYXlvdXQgPSBWYXJpYW50TGF5b3V0O1xuLyoqIEphdmFTY3JpcHQgY2hvc2UgdG8gZGVmaW5lIGJpdHdpc2Ugb3BlcmF0aW9ucyBhcyBvcGVyYXRpbmcgb25cbiAqIHNpZ25lZCAzMi1iaXQgdmFsdWVzIGluIDIncyBjb21wbGVtZW50IGZvcm0sIG1lYW5pbmcgYW55IGludGVnZXJcbiAqIHdpdGggYml0IDMxIHNldCBpcyBnb2luZyB0byBsb29rIG5lZ2F0aXZlLiAgRm9yIHJpZ2h0IHNoaWZ0cyB0aGF0J3NcbiAqIG5vdCBhIHByb2JsZW0sIGJlY2F1c2UgYD4+PmAgaXMgYSBsb2dpY2FsIHNoaWZ0LCBidXQgZm9yIGV2ZXJ5XG4gKiBvdGhlciBiaXR3aXNlIG9wZXJhdG9yIHdlIGhhdmUgdG8gY29tcGVuc2F0ZSBmb3IgcG9zc2libGUgbmVnYXRpdmVcbiAqIHJlc3VsdHMuICovXG5mdW5jdGlvbiBmaXhCaXR3aXNlUmVzdWx0KHYpIHtcbiAgICBpZiAoMCA+IHYpIHtcbiAgICAgICAgdiArPSAweDEwMDAwMDAwMDtcbiAgICB9XG4gICAgcmV0dXJuIHY7XG59XG4vKipcbiAqIENvbnRhaW4gYSBzZXF1ZW5jZSBvZiBiaXQgZmllbGRzIGFzIGFuIHVuc2lnbmVkIGludGVnZXIuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5iaXRzfGJpdHN9XG4gKlxuICogVGhpcyBpcyBhIGNvbnRhaW5lciBlbGVtZW50OyB3aXRoaW4gaXQgdGhlcmUgYXJlIHtAbGluayBCaXRGaWVsZH1cbiAqIGluc3RhbmNlcyB0aGF0IHByb3ZpZGUgdGhlIGV4dHJhY3RlZCBwcm9wZXJ0aWVzLiAgVGhlIGNvbnRhaW5lclxuICogc2ltcGx5IGRlZmluZXMgdGhlIGFnZ3JlZ2F0ZSByZXByZXNlbnRhdGlvbiBhbmQgaXRzIGJpdCBvcmRlcmluZy5cbiAqIFRoZSByZXByZXNlbnRhdGlvbiBpcyBhbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIHdpdGggbnVtZXJpY1xuICogb3Ige0BsaW5rIEJvb2xlYW59IHZhbHVlcy5cbiAqXG4gKiB7QGxpbmsgQml0RmllbGR9cyBhcmUgYWRkZWQgd2l0aCB0aGUge0BsaW5rXG4gKiBCaXRTdHJ1Y3R1cmUjYWRkRmllbGR8YWRkRmllbGR9IGFuZCB7QGxpbmtcbiAqIEJpdFN0cnVjdHVyZSNhZGRCb29sZWFufGFkZEJvb2xlYW59IG1ldGhvZHMuXG5cbiAqIEBwYXJhbSB7TGF5b3V0fSB3b3JkIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogQml0U3RydWN0dXJlI3dvcmR8d29yZH0uICBUaGUgcGFyYW1ldGVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2ZcbiAqIHtAbGluayBVSW50fSAob3Ige0BsaW5rIFVJbnRCRX0pIHRoYXQgaXMgbm8gbW9yZSB0aGFuIDQgYnl0ZXMgd2lkZS5cbiAqXG4gKiBAcGFyYW0ge2Jvb2x9IFttc2JdIC0gYHRydWVgIGlmIHRoZSBiaXQgbnVtYmVyaW5nIHN0YXJ0cyBhdCB0aGVcbiAqIG1vc3Qgc2lnbmlmaWNhbnQgYml0IG9mIHRoZSBjb250YWluaW5nIHdvcmQ7IGBmYWxzZWAgKGRlZmF1bHQpIGlmXG4gKiBpdCBzdGFydHMgYXQgdGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgY29udGFpbmluZyB3b3JkLiAgSWZcbiAqIHRoZSBwYXJhbWV0ZXIgYXQgdGhpcyBwb3NpdGlvbiBpcyBhIHN0cmluZyBhbmQgYHByb3BlcnR5YCBpc1xuICogYHVuZGVmaW5lZGAgdGhlIHZhbHVlIG9mIHRoaXMgYXJndW1lbnQgd2lsbCBpbnN0ZWFkIGJlIHVzZWQgYXMgdGhlXG4gKiB2YWx1ZSBvZiBgcHJvcGVydHlgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgQml0U3RydWN0dXJlIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcih3b3JkLCBtc2IsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKCh3b3JkIGluc3RhbmNlb2YgVUludClcbiAgICAgICAgICAgIHx8ICh3b3JkIGluc3RhbmNlb2YgVUludEJFKSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3dvcmQgbXVzdCBiZSBhIFVJbnQgb3IgVUludEJFIGxheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoJ3N0cmluZycgPT09IHR5cGVvZiBtc2IpXG4gICAgICAgICAgICAmJiAodW5kZWZpbmVkID09PSBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gbXNiO1xuICAgICAgICAgICAgbXNiID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKDQgPCB3b3JkLnNwYW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd3b3JkIGNhbm5vdCBleGNlZWQgMzIgYml0cycpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKHdvcmQuc3BhbiwgcHJvcGVydHkpO1xuICAgICAgICAvKiogVGhlIGxheW91dCB1c2VkIGZvciB0aGUgcGFja2VkIHZhbHVlLiAge0BsaW5rIEJpdEZpZWxkfVxuICAgICAgICAgKiBpbnN0YW5jZXMgYXJlIHBhY2tlZCBzZXF1ZW50aWFsbHkgZGVwZW5kaW5nIG9uIHtAbGlua1xuICAgICAgICAgKiBCaXRTdHJ1Y3R1cmUjbXNifG1zYn0uICovXG4gICAgICAgIHRoaXMud29yZCA9IHdvcmQ7XG4gICAgICAgIC8qKiBXaGV0aGVyIHRoZSBiaXQgc2VxdWVuY2VzIGFyZSBwYWNrZWQgc3RhcnRpbmcgYXQgdGhlIG1vc3RcbiAgICAgICAgICogc2lnbmlmaWNhbnQgYml0IGdyb3dpbmcgZG93biAoYHRydWVgKSwgb3IgdGhlIGxlYXN0IHNpZ25pZmljYW50XG4gICAgICAgICAqIGJpdCBncm93aW5nIHVwIChgZmFsc2VgKS5cbiAgICAgICAgICpcbiAgICAgICAgICogKipOT1RFKiogUmVnYXJkbGVzcyBvZiB0aGlzIHZhbHVlLCB0aGUgbGVhc3Qgc2lnbmlmaWNhbnQgYml0IG9mXG4gICAgICAgICAqIGFueSB7QGxpbmsgQml0RmllbGR9IHZhbHVlIGlzIHRoZSBsZWFzdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlXG4gICAgICAgICAqIGNvcnJlc3BvbmRpbmcgc2VjdGlvbiBvZiB0aGUgcGFja2VkIHZhbHVlLiAqL1xuICAgICAgICB0aGlzLm1zYiA9ICEhbXNiO1xuICAgICAgICAvKiogVGhlIHNlcXVlbmNlIG9mIHtAbGluayBCaXRGaWVsZH0gbGF5b3V0cyB0aGF0IGNvbXByaXNlIHRoZVxuICAgICAgICAgKiBwYWNrZWQgc3RydWN0dXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKk5PVEUqKiBUaGUgYXJyYXkgcmVtYWlucyBtdXRhYmxlIHRvIGFsbG93IGZpZWxkcyB0byBiZSB7QGxpbmtcbiAgICAgICAgICogQml0U3RydWN0dXJlI2FkZEZpZWxkfGFkZGVkfSBhZnRlciBjb25zdHJ1Y3Rpb24uICBVc2VycyBzaG91bGRcbiAgICAgICAgICogbm90IG1hbmlwdWxhdGUgdGhlIGNvbnRlbnQgb2YgdGhpcyBwcm9wZXJ0eS4qL1xuICAgICAgICB0aGlzLmZpZWxkcyA9IFtdO1xuICAgICAgICAvKiBTdG9yYWdlIGZvciB0aGUgdmFsdWUuICBDYXB0dXJlIGEgdmFyaWFibGUgaW5zdGVhZCBvZiB1c2luZyBhblxuICAgICAgICAgKiBpbnN0YW5jZSBwcm9wZXJ0eSBiZWNhdXNlIHdlIGRvbid0IHdhbnQgYW55dGhpbmcgdG8gY2hhbmdlIHRoZVxuICAgICAgICAgKiB2YWx1ZSB3aXRob3V0IGdvaW5nIHRocm91Z2ggdGhlIG11dGF0b3IuICovXG4gICAgICAgIGxldCB2YWx1ZSA9IDA7XG4gICAgICAgIHRoaXMuX3BhY2tlZFNldFZhbHVlID0gZnVuY3Rpb24gKHYpIHtcbiAgICAgICAgICAgIHZhbHVlID0gZml4Qml0d2lzZVJlc3VsdCh2KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wYWNrZWRHZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGRlY29kZShiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNvbnN0IGRlc3QgPSB0aGlzLm1ha2VEZXN0aW5hdGlvbk9iamVjdCgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMud29yZC5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICAgICAgdGhpcy5fcGFja2VkU2V0VmFsdWUodmFsdWUpO1xuICAgICAgICBmb3IgKGNvbnN0IGZkIG9mIHRoaXMuZmllbGRzKSB7XG4gICAgICAgICAgICBpZiAodW5kZWZpbmVkICE9PSBmZC5wcm9wZXJ0eSkge1xuICAgICAgICAgICAgICAgIGRlc3RbZmQucHJvcGVydHldID0gZmQuZGVjb2RlKGIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50IHtAbGluayBMYXlvdXQjZW5jb2RlfGVuY29kZX0gZm9yIHtAbGluayBCaXRTdHJ1Y3R1cmV9LlxuICAgICAqXG4gICAgICogSWYgYHNyY2AgaXMgbWlzc2luZyBhIHByb3BlcnR5IGZvciBhIG1lbWJlciB3aXRoIGEgZGVmaW5lZCB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9IHRoZSBjb3JyZXNwb25kaW5nIHJlZ2lvbiBvZiB0aGUgcGFja2VkXG4gICAgICogdmFsdWUgaXMgbGVmdCB1bm1vZGlmaWVkLiAgVW51c2VkIGJpdHMgYXJlIGFsc28gbGVmdCB1bm1vZGlmaWVkLiAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLndvcmQuZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgICAgIHRoaXMuX3BhY2tlZFNldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgZm9yIChjb25zdCBmZCBvZiB0aGlzLmZpZWxkcykge1xuICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZmQucHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmdiA9IHNyY1tmZC5wcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgaWYgKHVuZGVmaW5lZCAhPT0gZnYpIHtcbiAgICAgICAgICAgICAgICAgICAgZmQuZW5jb2RlKGZ2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud29yZC5lbmNvZGUodGhpcy5fcGFja2VkR2V0VmFsdWUoKSwgYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIFJlZ2lzdGVyIGEgbmV3IGJpdGZpZWxkIHdpdGggYSBjb250YWluaW5nIGJpdCBzdHJ1Y3R1cmUuICBUaGVcbiAgICAgKiByZXN1bHRpbmcgYml0ZmllbGQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gYml0cyAtIGluaXRpYWxpemVyIGZvciB7QGxpbmsgQml0RmllbGQjYml0c3xiaXRzfS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qml0RmllbGR9ICovXG4gICAgYWRkRmllbGQoYml0cywgcHJvcGVydHkpIHtcbiAgICAgICAgY29uc3QgYmYgPSBuZXcgQml0RmllbGQodGhpcywgYml0cywgcHJvcGVydHkpO1xuICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKGJmKTtcbiAgICAgICAgcmV0dXJuIGJmO1xuICAgIH1cbiAgICAvKiogQXMgd2l0aCB7QGxpbmsgQml0U3RydWN0dXJlI2FkZEZpZWxkfGFkZEZpZWxkfSBmb3Igc2luZ2xlLWJpdFxuICAgICAqIGZpZWxkcyB3aXRoIGBib29sZWFuYCB2YWx1ZSByZXByZXNlbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAgICAgKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gKi9cbiAgICAvLyBgQm9vbGVhbmAgY29uZmxpY3RzIHdpdGggdGhlIG5hdGl2ZSBwcmltaXRpdmUgdHlwZVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXR5cGVzXG4gICAgYWRkQm9vbGVhbihwcm9wZXJ0eSkge1xuICAgICAgICAvLyBUaGlzIGlzIG15IEJvb2xlYW4sIG5vdCB0aGUgSmF2YXNjcmlwdCBvbmUuXG4gICAgICAgIGNvbnN0IGJmID0gbmV3IEJvb2xlYW4odGhpcywgcHJvcGVydHkpO1xuICAgICAgICB0aGlzLmZpZWxkcy5wdXNoKGJmKTtcbiAgICAgICAgcmV0dXJuIGJmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYWNjZXNzIHRvIHRoZSBiaXQgZmllbGQgZm9yIGEgZ2l2ZW4gcHJvcGVydHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgLSB0aGUgYml0IGZpZWxkIG9mIGludGVyZXN0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7Qml0RmllbGR9IC0gdGhlIGZpZWxkIGFzc29jaWF0ZWQgd2l0aCBgcHJvcGVydHlgLCBvclxuICAgICAqIHVuZGVmaW5lZCBpZiB0aGVyZSBpcyBubyBzdWNoIHByb3BlcnR5LlxuICAgICAqL1xuICAgIGZpZWxkRm9yKHByb3BlcnR5KSB7XG4gICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByb3BlcnR5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwcm9wZXJ0eSBtdXN0IGJlIHN0cmluZycpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZmQgb2YgdGhpcy5maWVsZHMpIHtcbiAgICAgICAgICAgIGlmIChmZC5wcm9wZXJ0eSA9PT0gcHJvcGVydHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLkJpdFN0cnVjdHVyZSA9IEJpdFN0cnVjdHVyZTtcbi8qKlxuICogUmVwcmVzZW50IGEgc2VxdWVuY2Ugb2YgYml0cyB3aXRoaW4gYSB7QGxpbmsgQml0U3RydWN0dXJlfS5cbiAqXG4gKiBBbGwgYml0IGZpZWxkIHZhbHVlcyBhcmUgcmVwcmVzZW50ZWQgYXMgdW5zaWduZWQgaW50ZWdlcnMuXG4gKlxuICogKipOT1RFKiogVXNlciBjb2RlIHNob3VsZCBub3QgaW52b2tlIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuXG4gKiBVc2UgdGhlIGNvbnRhaW5lciB7QGxpbmsgQml0U3RydWN0dXJlI2FkZEZpZWxkfGFkZEZpZWxkfSBoZWxwZXJcbiAqIG1ldGhvZC5cbiAqXG4gKiAqKk5PVEUqKiBCaXRGaWVsZCBpbnN0YW5jZXMgYXJlIG5vdCBpbnN0YW5jZXMgb2Yge0BsaW5rIExheW91dH1cbiAqIHNpbmNlIHtAbGluayBMYXlvdXQjc3BhbnxzcGFufSBtZWFzdXJlcyA4LWJpdCB1bml0cy5cbiAqXG4gKiBAcGFyYW0ge0JpdFN0cnVjdHVyZX0gY29udGFpbmVyIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogQml0RmllbGQjY29udGFpbmVyfGNvbnRhaW5lcn0uXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGJpdHMgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rIEJpdEZpZWxkI2JpdHN8Yml0c30uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICovXG5jbGFzcyBCaXRGaWVsZCB7XG4gICAgY29uc3RydWN0b3IoY29udGFpbmVyLCBiaXRzLCBwcm9wZXJ0eSkge1xuICAgICAgICBpZiAoIShjb250YWluZXIgaW5zdGFuY2VvZiBCaXRTdHJ1Y3R1cmUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb250YWluZXIgbXVzdCBiZSBhIEJpdFN0cnVjdHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIU51bWJlci5pc0ludGVnZXIoYml0cykpIHx8ICgwID49IGJpdHMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdiaXRzIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvdGFsQml0cyA9IDggKiBjb250YWluZXIuc3BhbjtcbiAgICAgICAgY29uc3QgdXNlZEJpdHMgPSBjb250YWluZXIuZmllbGRzLnJlZHVjZSgoc3VtLCBmZCkgPT4gc3VtICsgZmQuYml0cywgMCk7XG4gICAgICAgIGlmICgoYml0cyArIHVzZWRCaXRzKSA+IHRvdGFsQml0cykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiaXRzIHRvbyBsb25nIGZvciBzcGFuIHJlbWFpbmRlciAoJ1xuICAgICAgICAgICAgICAgICsgKHRvdGFsQml0cyAtIHVzZWRCaXRzKSArICcgb2YgJ1xuICAgICAgICAgICAgICAgICsgdG90YWxCaXRzICsgJyByZW1haW4pJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIFRoZSB7QGxpbmsgQml0U3RydWN0dXJlfSBpbnN0YW5jZSB0byB3aGljaCB0aGlzIGJpdCBmaWVsZFxuICAgICAgICAgKiBiZWxvbmdzLiAqL1xuICAgICAgICB0aGlzLmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgLyoqIFRoZSBzcGFuIG9mIHRoaXMgdmFsdWUgaW4gYml0cy4gKi9cbiAgICAgICAgdGhpcy5iaXRzID0gYml0cztcbiAgICAgICAgLyoqIEEgbWFzayBvZiB7QGxpbmsgQml0RmllbGQjYml0c3xiaXRzfSBiaXRzIGlzb2xhdGluZyB2YWx1ZSBiaXRzXG4gICAgICAgICAqIHRoYXQgZml0IHdpdGhpbiB0aGUgZmllbGQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoYXQgaXMsIGl0IG1hc2tzIGEgdmFsdWUgdGhhdCBoYXMgbm90IHlldCBiZWVuIHNoaWZ0ZWQgaW50b1xuICAgICAgICAgKiBwb3NpdGlvbiB3aXRoaW4gaXRzIGNvbnRhaW5pbmcgcGFja2VkIGludGVnZXIuICovXG4gICAgICAgIHRoaXMudmFsdWVNYXNrID0gKDEgPDwgYml0cykgLSAxO1xuICAgICAgICBpZiAoMzIgPT09IGJpdHMpIHsgLy8gc2hpZnRlZCB2YWx1ZSBvdXQgb2YgcmFuZ2VcbiAgICAgICAgICAgIHRoaXMudmFsdWVNYXNrID0gMHhGRkZGRkZGRjtcbiAgICAgICAgfVxuICAgICAgICAvKiogVGhlIG9mZnNldCBvZiB0aGUgdmFsdWUgd2l0aGluIHRoZSBjb250YWluaW5nIHBhY2tlZCB1bnNpZ25lZFxuICAgICAgICAgKiBpbnRlZ2VyLiAgVGhlIGxlYXN0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgcGFja2VkIHZhbHVlIGlzIGF0XG4gICAgICAgICAqIG9mZnNldCB6ZXJvLCByZWdhcmRsZXNzIG9mIGJpdCBvcmRlcmluZyB1c2VkLiAqL1xuICAgICAgICB0aGlzLnN0YXJ0ID0gdXNlZEJpdHM7XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lci5tc2IpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQgPSB0b3RhbEJpdHMgLSB1c2VkQml0cyAtIGJpdHM7XG4gICAgICAgIH1cbiAgICAgICAgLyoqIEEgbWFzayBvZiB7QGxpbmsgQml0RmllbGQjYml0c3xiaXRzfSBpc29sYXRpbmcgdGhlIGZpZWxkIHZhbHVlXG4gICAgICAgICAqIHdpdGhpbiB0aGUgY29udGFpbmluZyBwYWNrZWQgdW5zaWduZWQgaW50ZWdlci4gKi9cbiAgICAgICAgdGhpcy53b3JkTWFzayA9IGZpeEJpdHdpc2VSZXN1bHQodGhpcy52YWx1ZU1hc2sgPDwgdGhpcy5zdGFydCk7XG4gICAgICAgIC8qKiBUaGUgcHJvcGVydHkgbmFtZSB1c2VkIHdoZW4gdGhpcyBiaXRmaWVsZCBpcyByZXByZXNlbnRlZCBpbiBhblxuICAgICAgICAgKiBPYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIEludGVuZGVkIHRvIGJlIGZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIHtAbGlua1xuICAgICAgICAgKiBMYXlvdXQjcHJvcGVydHl9LlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiBsZWZ0IHVuZGVmaW5lZCB0aGUgY29ycmVzcG9uZGluZyBzcGFuIG9mIGJpdHMgd2lsbCBiZVxuICAgICAgICAgKiB0cmVhdGVkIGFzIHBhZGRpbmc6IGl0IHdpbGwgbm90IGJlIG11dGF0ZWQgYnkge0BsaW5rXG4gICAgICAgICAqIExheW91dCNlbmNvZGV8ZW5jb2RlfSBub3IgcmVwcmVzZW50ZWQgYXMgYSBwcm9wZXJ0eSBpbiB0aGVcbiAgICAgICAgICogZGVjb2RlZCBPYmplY3QuICovXG4gICAgICAgIHRoaXMucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICB9XG4gICAgLyoqIFN0b3JlIGEgdmFsdWUgaW50byB0aGUgY29ycmVzcG9uZGluZyBzdWJzZXF1ZW5jZSBvZiB0aGUgY29udGFpbmluZ1xuICAgICAqIGJpdCBmaWVsZC4gKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHdvcmQgPSB0aGlzLmNvbnRhaW5lci5fcGFja2VkR2V0VmFsdWUoKTtcbiAgICAgICAgY29uc3Qgd29yZFZhbHVlID0gZml4Qml0d2lzZVJlc3VsdCh3b3JkICYgdGhpcy53b3JkTWFzayk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gd29yZFZhbHVlID4+PiB0aGlzLnN0YXJ0O1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8qKiBTdG9yZSBhIHZhbHVlIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgc3Vic2VxdWVuY2Ugb2YgdGhlIGNvbnRhaW5pbmdcbiAgICAgKiBiaXQgZmllbGQuXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBUaGlzIGlzIG5vdCBhIHNwZWNpYWxpemF0aW9uIG9mIHtAbGlua1xuICAgICAqIExheW91dCNlbmNvZGV8TGF5b3V0LmVuY29kZX0gYW5kIHRoZXJlIGlzIG5vIHJldHVybiB2YWx1ZS4gKi9cbiAgICBlbmNvZGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCdudW1iZXInICE9PSB0eXBlb2YgdmFsdWVcbiAgICAgICAgICAgIHx8ICFOdW1iZXIuaXNJbnRlZ2VyKHZhbHVlKVxuICAgICAgICAgICAgfHwgKHZhbHVlICE9PSBmaXhCaXR3aXNlUmVzdWx0KHZhbHVlICYgdGhpcy52YWx1ZU1hc2spKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihuYW1lV2l0aFByb3BlcnR5KCdCaXRGaWVsZC5lbmNvZGUnLCB0aGlzKVxuICAgICAgICAgICAgICAgICsgJyB2YWx1ZSBtdXN0IGJlIGludGVnZXIgbm90IGV4Y2VlZGluZyAnICsgdGhpcy52YWx1ZU1hc2spO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdvcmQgPSB0aGlzLmNvbnRhaW5lci5fcGFja2VkR2V0VmFsdWUoKTtcbiAgICAgICAgY29uc3Qgd29yZFZhbHVlID0gZml4Qml0d2lzZVJlc3VsdCh2YWx1ZSA8PCB0aGlzLnN0YXJ0KTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuX3BhY2tlZFNldFZhbHVlKGZpeEJpdHdpc2VSZXN1bHQod29yZCAmIH50aGlzLndvcmRNYXNrKVxuICAgICAgICAgICAgfCB3b3JkVmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQml0RmllbGQgPSBCaXRGaWVsZDtcbi8qKlxuICogUmVwcmVzZW50IGEgc2luZ2xlIGJpdCB3aXRoaW4gYSB7QGxpbmsgQml0U3RydWN0dXJlfSBhcyBhXG4gKiBKYXZhU2NyaXB0IGJvb2xlYW4uXG4gKlxuICogKipOT1RFKiogVXNlciBjb2RlIHNob3VsZCBub3QgaW52b2tlIHRoaXMgY29uc3RydWN0b3IgZGlyZWN0bHkuXG4gKiBVc2UgdGhlIGNvbnRhaW5lciB7QGxpbmsgQml0U3RydWN0dXJlI2FkZEJvb2xlYW58YWRkQm9vbGVhbn0gaGVscGVyXG4gKiBtZXRob2QuXG4gKlxuICogQHBhcmFtIHtCaXRTdHJ1Y3R1cmV9IGNvbnRhaW5lciAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIEJpdEZpZWxkI2NvbnRhaW5lcnxjb250YWluZXJ9LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0JpdEZpZWxkfVxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1leHRlbmQtbmF0aXZlICovXG5jbGFzcyBCb29sZWFuIGV4dGVuZHMgQml0RmllbGQge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRhaW5lciwgcHJvcGVydHkpIHtcbiAgICAgICAgc3VwZXIoY29udGFpbmVyLCAxLCBwcm9wZXJ0eSk7XG4gICAgfVxuICAgIC8qKiBPdmVycmlkZSB7QGxpbmsgQml0RmllbGQjZGVjb2RlfGRlY29kZX0gZm9yIHtAbGluayBCb29sZWFufEJvb2xlYW59LlxuICAgICAqXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59ICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCkge1xuICAgICAgICByZXR1cm4gISFzdXBlci5kZWNvZGUoYiwgb2Zmc2V0KTtcbiAgICB9XG4gICAgLyoqIEBvdmVycmlkZSAqL1xuICAgIGVuY29kZSh2YWx1ZSkge1xuICAgICAgICBpZiAoJ2Jvb2xlYW4nID09PSB0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgICAgIC8vIEJpdEZpZWxkIHJlcXVpcmVzIGludGVnZXIgdmFsdWVzXG4gICAgICAgICAgICB2YWx1ZSA9ICt2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5lbmNvZGUodmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydHMuQm9vbGVhbiA9IEJvb2xlYW47XG4vKiBlc2xpbnQtZW5hYmxlIG5vLWV4dGVuZC1uYXRpdmUgKi9cbi8qKlxuICogQ29udGFpbiBhIGZpeGVkLWxlbmd0aCBibG9jayBvZiBhcmJpdHJhcnkgZGF0YSwgcmVwcmVzZW50ZWQgYXMgYVxuICogVWludDhBcnJheS5cbiAqXG4gKiAqRmFjdG9yeSo6IHtAbGluayBtb2R1bGU6TGF5b3V0LmJsb2J8YmxvYn1cbiAqXG4gKiBAcGFyYW0geyhOdW1iZXJ8RXh0ZXJuYWxMYXlvdXQpfSBsZW5ndGggLSBpbml0aWFsaXplcyB7QGxpbmtcbiAqIEJsb2IjbGVuZ3RofGxlbmd0aH0uXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBCbG9iIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3RvcihsZW5ndGgsIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICghKCgobGVuZ3RoIGluc3RhbmNlb2YgRXh0ZXJuYWxMYXlvdXQpICYmIGxlbmd0aC5pc0NvdW50KCkpXG4gICAgICAgICAgICB8fCAoTnVtYmVyLmlzSW50ZWdlcihsZW5ndGgpICYmICgwIDw9IGxlbmd0aCkpKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbGVuZ3RoIG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlciAnXG4gICAgICAgICAgICAgICAgKyAnb3IgYW4gdW5zaWduZWQgaW50ZWdlciBFeHRlcm5hbExheW91dCcpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzcGFuID0gLTE7XG4gICAgICAgIGlmICghKGxlbmd0aCBpbnN0YW5jZW9mIEV4dGVybmFsTGF5b3V0KSkge1xuICAgICAgICAgICAgc3BhbiA9IGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihzcGFuLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgbnVtYmVyIG9mIGJ5dGVzIGluIHRoZSBibG9iLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG1heSBiZSBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLCBvciBhbiBpbnN0YW5jZSBvZiB7QGxpbmtcbiAgICAgICAgICogRXh0ZXJuYWxMYXlvdXR9IHRoYXQgc2F0aXNmaWVzIHtAbGlua1xuICAgICAgICAgKiBFeHRlcm5hbExheW91dCNpc0NvdW50fGlzQ291bnQoKX0uICovXG4gICAgICAgIHRoaXMubGVuZ3RoID0gbGVuZ3RoO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQpIHtcbiAgICAgICAgbGV0IHNwYW4gPSB0aGlzLnNwYW47XG4gICAgICAgIGlmICgwID4gc3Bhbikge1xuICAgICAgICAgICAgc3BhbiA9IHRoaXMubGVuZ3RoLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzcGFuO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IHNwYW4gPSB0aGlzLnNwYW47XG4gICAgICAgIGlmICgwID4gc3Bhbikge1xuICAgICAgICAgICAgc3BhbiA9IHRoaXMubGVuZ3RoLmRlY29kZShiLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1aW50OEFycmF5VG9CdWZmZXIoYikuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBzcGFuKTtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudCB7QGxpbmsgTGF5b3V0I2VuY29kZXxlbmNvZGV9IGZvciB7QGxpbmsgQmxvYn0uXG4gICAgICpcbiAgICAgKiAqKk5PVEUqKiBJZiB7QGxpbmsgTGF5b3V0I2NvdW50fGNvdW50fSBpcyBhbiBpbnN0YW5jZSBvZiB7QGxpbmtcbiAgICAgKiBFeHRlcm5hbExheW91dH0gdGhlbiB0aGUgbGVuZ3RoIG9mIGBzcmNgIHdpbGwgYmUgZW5jb2RlZCBhcyB0aGVcbiAgICAgKiBjb3VudCBhZnRlciBgc3JjYCBpcyBlbmNvZGVkLiAqL1xuICAgIGVuY29kZShzcmMsIGIsIG9mZnNldCkge1xuICAgICAgICBsZXQgc3BhbiA9IHRoaXMubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkge1xuICAgICAgICAgICAgc3BhbiA9IHNyYy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoc3JjIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBzcGFuID09PSBzcmMubGVuZ3RoKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihuYW1lV2l0aFByb3BlcnR5KCdCbG9iLmVuY29kZScsIHRoaXMpXG4gICAgICAgICAgICAgICAgKyAnIHJlcXVpcmVzIChsZW5ndGggJyArIHNwYW4gKyAnKSBVaW50OEFycmF5IGFzIHNyYycpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgob2Zmc2V0ICsgc3BhbikgPiBiLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ2VuY29kaW5nIG92ZXJydW5zIFVpbnQ4QXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcmNCdWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoc3JjKTtcbiAgICAgICAgdWludDhBcnJheVRvQnVmZmVyKGIpLndyaXRlKHNyY0J1ZmZlci50b1N0cmluZygnaGV4JyksIG9mZnNldCwgc3BhbiwgJ2hleCcpO1xuICAgICAgICBpZiAodGhpcy5sZW5ndGggaW5zdGFuY2VvZiBFeHRlcm5hbExheW91dCkge1xuICAgICAgICAgICAgdGhpcy5sZW5ndGguZW5jb2RlKHNwYW4sIGIsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNwYW47XG4gICAgfVxufVxuZXhwb3J0cy5CbG9iID0gQmxvYjtcbi8qKlxuICogQ29udGFpbiBhIGBOVUxgLXRlcm1pbmF0ZWQgVVRGOCBzdHJpbmcuXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC5jc3RyfGNzdHJ9XG4gKlxuICogKipOT1RFKiogQW55IFVURjggc3RyaW5nIHRoYXQgaW5jb3Jwb3JhdGVzIGEgemVyby12YWx1ZWQgYnl0ZSB3aWxsXG4gKiBub3QgYmUgY29ycmVjdGx5IGRlY29kZWQgYnkgdGhpcyBsYXlvdXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFtwcm9wZXJ0eV0gLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBMYXlvdXQjcHJvcGVydHl8cHJvcGVydHl9LlxuICpcbiAqIEBhdWdtZW50cyB7TGF5b3V0fVxuICovXG5jbGFzcyBDU3RyaW5nIGV4dGVuZHMgTGF5b3V0IHtcbiAgICBjb25zdHJ1Y3Rvcihwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcigtMSwgcHJvcGVydHkpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZ2V0U3BhbihiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIGNoZWNrVWludDhBcnJheShiKTtcbiAgICAgICAgbGV0IGlkeCA9IG9mZnNldDtcbiAgICAgICAgd2hpbGUgKChpZHggPCBiLmxlbmd0aCkgJiYgKDAgIT09IGJbaWR4XSkpIHtcbiAgICAgICAgICAgIGlkeCArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxICsgaWR4IC0gb2Zmc2V0O1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZGVjb2RlKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuZ2V0U3BhbihiLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3BhbiAtIDEpLnRvU3RyaW5nKCd1dGYtOCcpO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICAvKiBNdXN0IGZvcmNlIHRoaXMgdG8gYSBzdHJpbmcsIGxlc3QgaXQgYmUgYSBudW1iZXIgYW5kIHRoZVxuICAgICAgICAgKiBcInV0ZjgtZW5jb2RpbmdcIiBiZWxvdyBhY3R1YWxseSBhbGxvY2F0ZSBhIGJ1ZmZlciBvZiBsZW5ndGhcbiAgICAgICAgICogc3JjICovXG4gICAgICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHNyYykge1xuICAgICAgICAgICAgc3JjID0gU3RyaW5nKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3JjYiA9IGJ1ZmZlcl8xLkJ1ZmZlci5mcm9tKHNyYywgJ3V0ZjgnKTtcbiAgICAgICAgY29uc3Qgc3BhbiA9IHNyY2IubGVuZ3RoO1xuICAgICAgICBpZiAoKG9mZnNldCArIHNwYW4pID4gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmNvZGluZyBvdmVycnVucyBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWZmZXIgPSB1aW50OEFycmF5VG9CdWZmZXIoYik7XG4gICAgICAgIHNyY2IuY29weShidWZmZXIsIG9mZnNldCk7XG4gICAgICAgIGJ1ZmZlcltvZmZzZXQgKyBzcGFuXSA9IDA7XG4gICAgICAgIHJldHVybiBzcGFuICsgMTtcbiAgICB9XG59XG5leHBvcnRzLkNTdHJpbmcgPSBDU3RyaW5nO1xuLyoqXG4gKiBDb250YWluIGEgVVRGOCBzdHJpbmcgd2l0aCBpbXBsaWNpdCBsZW5ndGguXG4gKlxuICogKkZhY3RvcnkqOiB7QGxpbmsgbW9kdWxlOkxheW91dC51dGY4fHV0Zjh9XG4gKlxuICogKipOT1RFKiogQmVjYXVzZSB0aGUgbGVuZ3RoIGlzIGltcGxpY2l0IGluIHRoZSBzaXplIG9mIHRoZSBidWZmZXJcbiAqIHRoaXMgbGF5b3V0IHNob3VsZCBiZSB1c2VkIG9ubHkgaW4gaXNvbGF0aW9uLCBvciBpbiBhIHNpdHVhdGlvblxuICogd2hlcmUgdGhlIGxlbmd0aCBjYW4gYmUgZXhwcmVzc2VkIGJ5IG9wZXJhdGluZyBvbiBhIHNsaWNlIG9mIHRoZVxuICogY29udGFpbmluZyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IFttYXhTcGFuXSAtIHRoZSBtYXhpbXVtIGxlbmd0aCBhbGxvd2VkIGZvciBlbmNvZGVkXG4gKiBzdHJpbmcgY29udGVudC4gIElmIG5vdCBwcm92aWRlZCB0aGVyZSBpcyBubyBib3VuZCBvbiB0aGUgYWxsb3dlZFxuICogY29udGVudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gW3Byb3BlcnR5XSAtIGluaXRpYWxpemVyIGZvciB7QGxpbmtcbiAqIExheW91dCNwcm9wZXJ0eXxwcm9wZXJ0eX0uXG4gKlxuICogQGF1Z21lbnRzIHtMYXlvdXR9XG4gKi9cbmNsYXNzIFVURjggZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKG1heFNwYW4sIHByb3BlcnR5KSB7XG4gICAgICAgIGlmICgoJ3N0cmluZycgPT09IHR5cGVvZiBtYXhTcGFuKSAmJiAodW5kZWZpbmVkID09PSBwcm9wZXJ0eSkpIHtcbiAgICAgICAgICAgIHByb3BlcnR5ID0gbWF4U3BhbjtcbiAgICAgICAgICAgIG1heFNwYW4gPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gbWF4U3Bhbikge1xuICAgICAgICAgICAgbWF4U3BhbiA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1heFNwYW4pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhTcGFuIG11c3QgYmUgYW4gaW50ZWdlcicpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyKC0xLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgbWF4aW11bSBzcGFuIG9mIHRoZSBsYXlvdXQgaW4gYnl0ZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFBvc2l0aXZlIHZhbHVlcyBhcmUgZ2VuZXJhbGx5IGV4cGVjdGVkLiAgWmVybyBpcyBhYm5vcm1hbC5cbiAgICAgICAgICogQXR0ZW1wdHMgdG8gZW5jb2RlIG9yIGRlY29kZSBhIHZhbHVlIHRoYXQgZXhjZWVkcyB0aGlzIGxlbmd0aFxuICAgICAgICAgKiB3aWxsIHRocm93IGEgYFJhbmdlRXJyb3JgLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBIG5lZ2F0aXZlIHZhbHVlIGluZGljYXRlcyB0aGF0IHRoZXJlIGlzIG5vIGJvdW5kIG9uIHRoZSBsZW5ndGhcbiAgICAgICAgICogb2YgdGhlIGNvbnRlbnQuICovXG4gICAgICAgIHRoaXMubWF4U3BhbiA9IG1heFNwYW47XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBnZXRTcGFuKGIsIG9mZnNldCA9IDApIHtcbiAgICAgICAgY2hlY2tVaW50OEFycmF5KGIpO1xuICAgICAgICByZXR1cm4gYi5sZW5ndGggLSBvZmZzZXQ7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0ID0gMCkge1xuICAgICAgICBjb25zdCBzcGFuID0gdGhpcy5nZXRTcGFuKGIsIG9mZnNldCk7XG4gICAgICAgIGlmICgoMCA8PSB0aGlzLm1heFNwYW4pXG4gICAgICAgICAgICAmJiAodGhpcy5tYXhTcGFuIDwgc3BhbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0ZXh0IGxlbmd0aCBleGNlZWRzIG1heFNwYW4nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdWludDhBcnJheVRvQnVmZmVyKGIpLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgc3BhbikudG9TdHJpbmcoJ3V0Zi04Jyk7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBlbmNvZGUoc3JjLCBiLCBvZmZzZXQgPSAwKSB7XG4gICAgICAgIC8qIE11c3QgZm9yY2UgdGhpcyB0byBhIHN0cmluZywgbGVzdCBpdCBiZSBhIG51bWJlciBhbmQgdGhlXG4gICAgICAgICAqIFwidXRmOC1lbmNvZGluZ1wiIGJlbG93IGFjdHVhbGx5IGFsbG9jYXRlIGEgYnVmZmVyIG9mIGxlbmd0aFxuICAgICAgICAgKiBzcmMgKi9cbiAgICAgICAgaWYgKCdzdHJpbmcnICE9PSB0eXBlb2Ygc3JjKSB7XG4gICAgICAgICAgICBzcmMgPSBTdHJpbmcoc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzcmNiID0gYnVmZmVyXzEuQnVmZmVyLmZyb20oc3JjLCAndXRmOCcpO1xuICAgICAgICBjb25zdCBzcGFuID0gc3JjYi5sZW5ndGg7XG4gICAgICAgIGlmICgoMCA8PSB0aGlzLm1heFNwYW4pXG4gICAgICAgICAgICAmJiAodGhpcy5tYXhTcGFuIDwgc3BhbikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0ZXh0IGxlbmd0aCBleGNlZWRzIG1heFNwYW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKG9mZnNldCArIHNwYW4pID4gYi5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdlbmNvZGluZyBvdmVycnVucyBCdWZmZXInKTtcbiAgICAgICAgfVxuICAgICAgICBzcmNiLmNvcHkodWludDhBcnJheVRvQnVmZmVyKGIpLCBvZmZzZXQpO1xuICAgICAgICByZXR1cm4gc3BhbjtcbiAgICB9XG59XG5leHBvcnRzLlVURjggPSBVVEY4O1xuLyoqXG4gKiBDb250YWluIGEgY29uc3RhbnQgdmFsdWUuXG4gKlxuICogVGhpcyBsYXlvdXQgbWF5IGJlIHVzZWQgaW4gY2FzZXMgd2hlcmUgYSBKYXZhU2NyaXB0IHZhbHVlIGNhbiBiZVxuICogaW5mZXJyZWQgd2l0aG91dCBhbiBleHByZXNzaW9uIGluIHRoZSBiaW5hcnkgZW5jb2RpbmcuICBBbiBleGFtcGxlXG4gKiB3b3VsZCBiZSBhIHtAbGluayBWYXJpYW50TGF5b3V0fHZhcmlhbnQgbGF5b3V0fSB3aGVyZSB0aGUgY29udGVudFxuICogaXMgaW1wbGllZCBieSB0aGUgdW5pb24ge0BsaW5rIFVuaW9uI2Rpc2NyaW1pbmF0b3J8ZGlzY3JpbWluYXRvcn0uXG4gKlxuICogQHBhcmFtIHtPYmplY3R8TnVtYmVyfFN0cmluZ30gdmFsdWUgLSBpbml0aWFsaXplciBmb3Ige0BsaW5rXG4gKiBDb25zdGFudCN2YWx1ZXx2YWx1ZX0uICBJZiB0aGUgdmFsdWUgaXMgYW4gb2JqZWN0IChvciBhcnJheSkgYW5kXG4gKiB0aGUgYXBwbGljYXRpb24gaW50ZW5kcyB0aGUgb2JqZWN0IHRvIHJlbWFpbiB1bmNoYW5nZWQgcmVnYXJkbGVzc1xuICogb2Ygd2hhdCBpcyBkb25lIHRvIHZhbHVlcyBkZWNvZGVkIGJ5IHRoaXMgbGF5b3V0LCB0aGUgdmFsdWUgc2hvdWxkXG4gKiBiZSBmcm96ZW4gcHJpb3IgcGFzc2luZyBpdCB0byB0aGlzIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBbcHJvcGVydHldIC0gaW5pdGlhbGl6ZXIgZm9yIHtAbGlua1xuICogTGF5b3V0I3Byb3BlcnR5fHByb3BlcnR5fS5cbiAqXG4gKiBAYXVnbWVudHMge0xheW91dH1cbiAqL1xuY2xhc3MgQ29uc3RhbnQgZXh0ZW5kcyBMYXlvdXQge1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCBwcm9wZXJ0eSkge1xuICAgICAgICBzdXBlcigwLCBwcm9wZXJ0eSk7XG4gICAgICAgIC8qKiBUaGUgdmFsdWUgcHJvZHVjZWQgYnkgdGhpcyBjb25zdGFudCB3aGVuIHRoZSBsYXlvdXQgaXMge0BsaW5rXG4gICAgICAgICAqIENvbnN0YW50I2RlY29kZXxkZWNvZGVkfS5cbiAgICAgICAgICpcbiAgICAgICAgICogQW55IEphdmFTY3JpcHQgdmFsdWUgaW5jbHVkaW5nIGBudWxsYCBhbmQgYHVuZGVmaW5lZGAgaXNcbiAgICAgICAgICogcGVybWl0dGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiAqKldBUk5JTkcqKiBJZiBgdmFsdWVgIHBhc3NlZCBpbiB0aGUgY29uc3RydWN0b3Igd2FzIG5vdFxuICAgICAgICAgKiBmcm96ZW4sIGl0IGlzIHBvc3NpYmxlIGZvciB1c2VycyBvZiBkZWNvZGVkIHZhbHVlcyB0byBjaGFuZ2VcbiAgICAgICAgICogdGhlIGNvbnRlbnQgb2YgdGhlIHZhbHVlLiAqL1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKiBAb3ZlcnJpZGUgKi9cbiAgICBkZWNvZGUoYiwgb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICAgIH1cbiAgICAvKiogQG92ZXJyaWRlICovXG4gICAgZW5jb2RlKHNyYywgYiwgb2Zmc2V0KSB7XG4gICAgICAgIC8qIENvbnN0YW50cyB0YWtlIG5vIHNwYWNlICovXG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbmV4cG9ydHMuQ29uc3RhbnQgPSBDb25zdGFudDtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgR3JlZWR5Q291bnR9LiAqL1xuZXhwb3J0cy5ncmVlZHkgPSAoKGVsZW1lbnRTcGFuLCBwcm9wZXJ0eSkgPT4gbmV3IEdyZWVkeUNvdW50KGVsZW1lbnRTcGFuLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBPZmZzZXRMYXlvdXR9LiAqL1xuZXhwb3J0cy5vZmZzZXQgPSAoKGxheW91dCwgb2Zmc2V0LCBwcm9wZXJ0eSkgPT4gbmV3IE9mZnNldExheW91dChsYXlvdXQsIG9mZnNldCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHx1bnNpZ25lZCBpbnQgbGF5b3V0c30gc3Bhbm5pbmcgb25lXG4gKiBieXRlLiAqL1xuZXhwb3J0cy51OCA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50KDEsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHR3byBieXRlcy4gKi9cbmV4cG9ydHMudTE2ID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnQoMiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdGhyZWUgYnl0ZXMuICovXG5leHBvcnRzLnUyNCA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50KDMsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG5leHBvcnRzLnUzMiA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50KDQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZpdmUgYnl0ZXMuICovXG5leHBvcnRzLnU0MCA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50KDUsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8bGl0dGxlLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHNpeCBieXRlcy4gKi9cbmV4cG9ydHMudTQ4ID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnQoNiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgTmVhclVJbnQ2NHxsaXR0bGUtZW5kaWFuIHVuc2lnbmVkIGludFxuICogbGF5b3V0c30gaW50ZXJwcmV0ZWQgYXMgTnVtYmVycy4gKi9cbmV4cG9ydHMubnU2NCA9ICgocHJvcGVydHkpID0+IG5ldyBOZWFyVUludDY0KHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHR3byBieXRlcy4gKi9cbmV4cG9ydHMudTE2YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludEJFKDIsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHRocmVlIGJ5dGVzLiAqL1xuZXhwb3J0cy51MjRiZSA9ICgocHJvcGVydHkpID0+IG5ldyBVSW50QkUoMywgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVUludHxiaWctZW5kaWFuIHVuc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZm91ciBieXRlcy4gKi9cbmV4cG9ydHMudTMyYmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgVUludEJFKDQsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVJbnR8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZpdmUgYnl0ZXMuICovXG5leHBvcnRzLnU0MGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnRCRSg1LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVSW50fGJpZy1lbmRpYW4gdW5zaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBzaXggYnl0ZXMuICovXG5leHBvcnRzLnU0OGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IFVJbnRCRSg2LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBOZWFyVUludDY0QkV8YmlnLWVuZGlhbiB1bnNpZ25lZCBpbnRcbiAqIGxheW91dHN9IGludGVycHJldGVkIGFzIE51bWJlcnMuICovXG5leHBvcnRzLm51NjRiZSA9ICgocHJvcGVydHkpID0+IG5ldyBOZWFyVUludDY0QkUocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fHNpZ25lZCBpbnQgbGF5b3V0c30gc3Bhbm5pbmcgb25lXG4gKiBieXRlLiAqL1xuZXhwb3J0cy5zOCA9ICgocHJvcGVydHkpID0+IG5ldyBJbnQoMSwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdHdvIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMTYgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50KDIsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIHRocmVlIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMjQgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50KDMsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEludHxsaXR0bGUtZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIHNwYW5uaW5nIGZvdXIgYnl0ZXMuICovXG5leHBvcnRzLnMzMiA9ICgocHJvcGVydHkpID0+IG5ldyBJbnQoNCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZml2ZSBieXRlcy4gKi9cbmV4cG9ydHMuczQwID0gKChwcm9wZXJ0eSkgPT4gbmV3IEludCg1LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8bGl0dGxlLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyBzaXggYnl0ZXMuICovXG5leHBvcnRzLnM0OCA9ICgocHJvcGVydHkpID0+IG5ldyBJbnQoNiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgTmVhckludDY0fGxpdHRsZS1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogaW50ZXJwcmV0ZWQgYXMgTnVtYmVycy4gKi9cbmV4cG9ydHMubnM2NCA9ICgocHJvcGVydHkpID0+IG5ldyBOZWFySW50NjQocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgdHdvIGJ5dGVzLiAqL1xuZXhwb3J0cy5zMTZiZSA9ICgocHJvcGVydHkpID0+IG5ldyBJbnRCRSgyLCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBJbnR8YmlnLWVuZGlhbiBzaWduZWQgaW50IGxheW91dHN9XG4gKiBzcGFubmluZyB0aHJlZSBieXRlcy4gKi9cbmV4cG9ydHMuczI0YmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50QkUoMywgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZm91ciBieXRlcy4gKi9cbmV4cG9ydHMuczMyYmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50QkUoNCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgZml2ZSBieXRlcy4gKi9cbmV4cG9ydHMuczQwYmUgPSAoKHByb3BlcnR5KSA9PiBuZXcgSW50QkUoNSwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgSW50fGJpZy1lbmRpYW4gc2lnbmVkIGludCBsYXlvdXRzfVxuICogc3Bhbm5pbmcgc2l4IGJ5dGVzLiAqL1xuZXhwb3J0cy5zNDhiZSA9ICgocHJvcGVydHkpID0+IG5ldyBJbnRCRSg2LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBOZWFySW50NjRCRXxiaWctZW5kaWFuIHNpZ25lZCBpbnQgbGF5b3V0c31cbiAqIGludGVycHJldGVkIGFzIE51bWJlcnMuICovXG5leHBvcnRzLm5zNjRiZSA9ICgocHJvcGVydHkpID0+IG5ldyBOZWFySW50NjRCRShwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBGbG9hdHxsaXR0bGUtZW5kaWFuIDMyLWJpdCBmbG9hdGluZyBwb2ludH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5mMzIgPSAoKHByb3BlcnR5KSA9PiBuZXcgRmxvYXQocHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgRmxvYXRCRXxiaWctZW5kaWFuIDMyLWJpdCBmbG9hdGluZyBwb2ludH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5mMzJiZSA9ICgocHJvcGVydHkpID0+IG5ldyBGbG9hdEJFKHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIERvdWJsZXxsaXR0bGUtZW5kaWFuIDY0LWJpdCBmbG9hdGluZyBwb2ludH0gdmFsdWVzLiAqL1xuZXhwb3J0cy5mNjQgPSAoKHByb3BlcnR5KSA9PiBuZXcgRG91YmxlKHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIERvdWJsZUJFfGJpZy1lbmRpYW4gNjQtYml0IGZsb2F0aW5nIHBvaW50fSB2YWx1ZXMuICovXG5leHBvcnRzLmY2NGJlID0gKChwcm9wZXJ0eSkgPT4gbmV3IERvdWJsZUJFKHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFN0cnVjdHVyZX0gdmFsdWVzLiAqL1xuZXhwb3J0cy5zdHJ1Y3QgPSAoKGZpZWxkcywgcHJvcGVydHksIGRlY29kZVByZWZpeGVzKSA9PiBuZXcgU3RydWN0dXJlKGZpZWxkcywgcHJvcGVydHksIGRlY29kZVByZWZpeGVzKSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIEJpdFN0cnVjdHVyZX0gdmFsdWVzLiAqL1xuZXhwb3J0cy5iaXRzID0gKCh3b3JkLCBtc2IsIHByb3BlcnR5KSA9PiBuZXcgQml0U3RydWN0dXJlKHdvcmQsIG1zYiwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgU2VxdWVuY2V9IHZhbHVlcy4gKi9cbmV4cG9ydHMuc2VxID0gKChlbGVtZW50TGF5b3V0LCBjb3VudCwgcHJvcGVydHkpID0+IG5ldyBTZXF1ZW5jZShlbGVtZW50TGF5b3V0LCBjb3VudCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgVW5pb259IHZhbHVlcy4gKi9cbmV4cG9ydHMudW5pb24gPSAoKGRpc2NyLCBkZWZhdWx0TGF5b3V0LCBwcm9wZXJ0eSkgPT4gbmV3IFVuaW9uKGRpc2NyLCBkZWZhdWx0TGF5b3V0LCBwcm9wZXJ0eSkpO1xuLyoqIEZhY3RvcnkgZm9yIHtAbGluayBVbmlvbkxheW91dERpc2NyaW1pbmF0b3J9IHZhbHVlcy4gKi9cbmV4cG9ydHMudW5pb25MYXlvdXREaXNjcmltaW5hdG9yID0gKChsYXlvdXQsIHByb3BlcnR5KSA9PiBuZXcgVW5pb25MYXlvdXREaXNjcmltaW5hdG9yKGxheW91dCwgcHJvcGVydHkpKTtcbi8qKiBGYWN0b3J5IGZvciB7QGxpbmsgQmxvYn0gdmFsdWVzLiAqL1xuZXhwb3J0cy5ibG9iID0gKChsZW5ndGgsIHByb3BlcnR5KSA9PiBuZXcgQmxvYihsZW5ndGgsIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIENTdHJpbmd9IHZhbHVlcy4gKi9cbmV4cG9ydHMuY3N0ciA9ICgocHJvcGVydHkpID0+IG5ldyBDU3RyaW5nKHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIFVURjh9IHZhbHVlcy4gKi9cbmV4cG9ydHMudXRmOCA9ICgobWF4U3BhbiwgcHJvcGVydHkpID0+IG5ldyBVVEY4KG1heFNwYW4sIHByb3BlcnR5KSk7XG4vKiogRmFjdG9yeSBmb3Ige0BsaW5rIENvbnN0YW50fSB2YWx1ZXMuICovXG5leHBvcnRzLmNvbnN0YW50ID0gKCh2YWx1ZSwgcHJvcGVydHkpID0+IG5ldyBDb25zdGFudCh2YWx1ZSwgcHJvcGVydHkpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxheW91dC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/buffer-layout/lib/Layout.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/@solana/web3.js/lib/index.browser.esm.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: function() { return /* binding */ Account; },\n/* harmony export */   AddressLookupTableAccount: function() { return /* binding */ AddressLookupTableAccount; },\n/* harmony export */   AddressLookupTableInstruction: function() { return /* binding */ AddressLookupTableInstruction; },\n/* harmony export */   AddressLookupTableProgram: function() { return /* binding */ AddressLookupTableProgram; },\n/* harmony export */   Authorized: function() { return /* binding */ Authorized; },\n/* harmony export */   BLOCKHASH_CACHE_TIMEOUT_MS: function() { return /* binding */ BLOCKHASH_CACHE_TIMEOUT_MS; },\n/* harmony export */   BPF_LOADER_DEPRECATED_PROGRAM_ID: function() { return /* binding */ BPF_LOADER_DEPRECATED_PROGRAM_ID; },\n/* harmony export */   BPF_LOADER_PROGRAM_ID: function() { return /* binding */ BPF_LOADER_PROGRAM_ID; },\n/* harmony export */   BpfLoader: function() { return /* binding */ BpfLoader; },\n/* harmony export */   COMPUTE_BUDGET_INSTRUCTION_LAYOUTS: function() { return /* binding */ COMPUTE_BUDGET_INSTRUCTION_LAYOUTS; },\n/* harmony export */   ComputeBudgetInstruction: function() { return /* binding */ ComputeBudgetInstruction; },\n/* harmony export */   ComputeBudgetProgram: function() { return /* binding */ ComputeBudgetProgram; },\n/* harmony export */   Connection: function() { return /* binding */ Connection; },\n/* harmony export */   Ed25519Program: function() { return /* binding */ Ed25519Program; },\n/* harmony export */   Enum: function() { return /* binding */ Enum; },\n/* harmony export */   EpochSchedule: function() { return /* binding */ EpochSchedule; },\n/* harmony export */   FeeCalculatorLayout: function() { return /* binding */ FeeCalculatorLayout; },\n/* harmony export */   Keypair: function() { return /* binding */ Keypair; },\n/* harmony export */   LAMPORTS_PER_SOL: function() { return /* binding */ LAMPORTS_PER_SOL; },\n/* harmony export */   LOOKUP_TABLE_INSTRUCTION_LAYOUTS: function() { return /* binding */ LOOKUP_TABLE_INSTRUCTION_LAYOUTS; },\n/* harmony export */   Loader: function() { return /* binding */ Loader; },\n/* harmony export */   Lockup: function() { return /* binding */ Lockup; },\n/* harmony export */   MAX_SEED_LENGTH: function() { return /* binding */ MAX_SEED_LENGTH; },\n/* harmony export */   Message: function() { return /* binding */ Message; },\n/* harmony export */   MessageAccountKeys: function() { return /* binding */ MessageAccountKeys; },\n/* harmony export */   MessageV0: function() { return /* binding */ MessageV0; },\n/* harmony export */   NONCE_ACCOUNT_LENGTH: function() { return /* binding */ NONCE_ACCOUNT_LENGTH; },\n/* harmony export */   NonceAccount: function() { return /* binding */ NonceAccount; },\n/* harmony export */   PACKET_DATA_SIZE: function() { return /* binding */ PACKET_DATA_SIZE; },\n/* harmony export */   PUBLIC_KEY_LENGTH: function() { return /* binding */ PUBLIC_KEY_LENGTH; },\n/* harmony export */   PublicKey: function() { return /* binding */ PublicKey; },\n/* harmony export */   SIGNATURE_LENGTH_IN_BYTES: function() { return /* binding */ SIGNATURE_LENGTH_IN_BYTES; },\n/* harmony export */   SOLANA_SCHEMA: function() { return /* binding */ SOLANA_SCHEMA; },\n/* harmony export */   STAKE_CONFIG_ID: function() { return /* binding */ STAKE_CONFIG_ID; },\n/* harmony export */   STAKE_INSTRUCTION_LAYOUTS: function() { return /* binding */ STAKE_INSTRUCTION_LAYOUTS; },\n/* harmony export */   SYSTEM_INSTRUCTION_LAYOUTS: function() { return /* binding */ SYSTEM_INSTRUCTION_LAYOUTS; },\n/* harmony export */   SYSVAR_CLOCK_PUBKEY: function() { return /* binding */ SYSVAR_CLOCK_PUBKEY; },\n/* harmony export */   SYSVAR_EPOCH_SCHEDULE_PUBKEY: function() { return /* binding */ SYSVAR_EPOCH_SCHEDULE_PUBKEY; },\n/* harmony export */   SYSVAR_INSTRUCTIONS_PUBKEY: function() { return /* binding */ SYSVAR_INSTRUCTIONS_PUBKEY; },\n/* harmony export */   SYSVAR_RECENT_BLOCKHASHES_PUBKEY: function() { return /* binding */ SYSVAR_RECENT_BLOCKHASHES_PUBKEY; },\n/* harmony export */   SYSVAR_RENT_PUBKEY: function() { return /* binding */ SYSVAR_RENT_PUBKEY; },\n/* harmony export */   SYSVAR_REWARDS_PUBKEY: function() { return /* binding */ SYSVAR_REWARDS_PUBKEY; },\n/* harmony export */   SYSVAR_SLOT_HASHES_PUBKEY: function() { return /* binding */ SYSVAR_SLOT_HASHES_PUBKEY; },\n/* harmony export */   SYSVAR_SLOT_HISTORY_PUBKEY: function() { return /* binding */ SYSVAR_SLOT_HISTORY_PUBKEY; },\n/* harmony export */   SYSVAR_STAKE_HISTORY_PUBKEY: function() { return /* binding */ SYSVAR_STAKE_HISTORY_PUBKEY; },\n/* harmony export */   Secp256k1Program: function() { return /* binding */ Secp256k1Program; },\n/* harmony export */   SendTransactionError: function() { return /* binding */ SendTransactionError; },\n/* harmony export */   SolanaJSONRPCError: function() { return /* binding */ SolanaJSONRPCError; },\n/* harmony export */   SolanaJSONRPCErrorCode: function() { return /* binding */ SolanaJSONRPCErrorCode; },\n/* harmony export */   StakeAuthorizationLayout: function() { return /* binding */ StakeAuthorizationLayout; },\n/* harmony export */   StakeInstruction: function() { return /* binding */ StakeInstruction; },\n/* harmony export */   StakeProgram: function() { return /* binding */ StakeProgram; },\n/* harmony export */   Struct: function() { return /* binding */ Struct; },\n/* harmony export */   SystemInstruction: function() { return /* binding */ SystemInstruction; },\n/* harmony export */   SystemProgram: function() { return /* binding */ SystemProgram; },\n/* harmony export */   Transaction: function() { return /* binding */ Transaction; },\n/* harmony export */   TransactionExpiredBlockheightExceededError: function() { return /* binding */ TransactionExpiredBlockheightExceededError; },\n/* harmony export */   TransactionExpiredNonceInvalidError: function() { return /* binding */ TransactionExpiredNonceInvalidError; },\n/* harmony export */   TransactionExpiredTimeoutError: function() { return /* binding */ TransactionExpiredTimeoutError; },\n/* harmony export */   TransactionInstruction: function() { return /* binding */ TransactionInstruction; },\n/* harmony export */   TransactionMessage: function() { return /* binding */ TransactionMessage; },\n/* harmony export */   TransactionStatus: function() { return /* binding */ TransactionStatus; },\n/* harmony export */   VALIDATOR_INFO_KEY: function() { return /* binding */ VALIDATOR_INFO_KEY; },\n/* harmony export */   VERSION_PREFIX_MASK: function() { return /* binding */ VERSION_PREFIX_MASK; },\n/* harmony export */   VOTE_PROGRAM_ID: function() { return /* binding */ VOTE_PROGRAM_ID; },\n/* harmony export */   ValidatorInfo: function() { return /* binding */ ValidatorInfo; },\n/* harmony export */   VersionedMessage: function() { return /* binding */ VersionedMessage; },\n/* harmony export */   VersionedTransaction: function() { return /* binding */ VersionedTransaction; },\n/* harmony export */   VoteAccount: function() { return /* binding */ VoteAccount; },\n/* harmony export */   VoteAuthorizationLayout: function() { return /* binding */ VoteAuthorizationLayout; },\n/* harmony export */   VoteInit: function() { return /* binding */ VoteInit; },\n/* harmony export */   VoteInstruction: function() { return /* binding */ VoteInstruction; },\n/* harmony export */   VoteProgram: function() { return /* binding */ VoteProgram; },\n/* harmony export */   clusterApiUrl: function() { return /* binding */ clusterApiUrl; },\n/* harmony export */   sendAndConfirmRawTransaction: function() { return /* binding */ sendAndConfirmRawTransaction; },\n/* harmony export */   sendAndConfirmTransaction: function() { return /* binding */ sendAndConfirmTransaction; }\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\");\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/ed25519.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bn.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/bn.js/lib/bn.js\");\n/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bs58 */ \"(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/bs58/index.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(bs58__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! borsh */ \"(app-pages-browser)/./node_modules/borsh/lib/index.js\");\n/* harmony import */ var borsh__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(borsh__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/buffer-layout */ \"(app-pages-browser)/./node_modules/@solana/buffer-layout/lib/Layout.js\");\n/* harmony import */ var bigint_buffer__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! bigint-buffer */ \"(app-pages-browser)/./node_modules/bigint-buffer/dist/browser.js\");\n/* harmony import */ var superstruct__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! superstruct */ \"(app-pages-browser)/./node_modules/superstruct/lib/index.es.js\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! jayson/lib/client/browser */ \"(app-pages-browser)/./node_modules/jayson/lib/client/browser/index.js\");\n/* harmony import */ var jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var rpc_websockets_dist_lib_client__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rpc-websockets/dist/lib/client */ \"(app-pages-browser)/./node_modules/rpc-websockets/dist/lib/client.js\");\n/* harmony import */ var rpc_websockets_dist_lib_client_websocket_browser__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! rpc-websockets/dist/lib/client/websocket.browser */ \"(app-pages-browser)/./node_modules/rpc-websockets/dist/lib/client/websocket.browser.js\");\n/* harmony import */ var _noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @noble/hashes/sha3 */ \"(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha3.js\");\n/* harmony import */ var _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @noble/curves/secp256k1 */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\n * A 64 byte secret key, the first 32 bytes of which is the\n * private scalar and the last 32 bytes is the public key.\n * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n */\n\n/**\n * Ed25519 Keypair\n */\n\nconst generatePrivateKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_9__.ed25519.utils.randomPrivateKey;\nconst generateKeypair = () => {\n  const privateScalar = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_9__.ed25519.utils.randomPrivateKey();\n  const publicKey = getPublicKey(privateScalar);\n  const secretKey = new Uint8Array(64);\n  secretKey.set(privateScalar);\n  secretKey.set(publicKey, 32);\n  return {\n    publicKey,\n    secretKey\n  };\n};\nconst getPublicKey = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_9__.ed25519.getPublicKey;\nfunction isOnCurve(publicKey) {\n  try {\n    _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_9__.ed25519.ExtendedPoint.fromHex(publicKey);\n    return true;\n  } catch {\n    return false;\n  }\n}\nconst sign = (message, secretKey) => _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_9__.ed25519.sign(message, secretKey.slice(0, 32));\nconst verify = _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_9__.ed25519.verify;\n\nconst toBuffer = arr => {\n  if (buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.isBuffer(arr)) {\n    return arr;\n  } else if (arr instanceof Uint8Array) {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr.buffer, arr.byteOffset, arr.byteLength);\n  } else {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(arr);\n  }\n};\n\n// Class wrapping a plain object\nclass Struct {\n  constructor(properties) {\n    Object.assign(this, properties);\n  }\n  encode() {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,borsh__WEBPACK_IMPORTED_MODULE_3__.serialize)(SOLANA_SCHEMA, this));\n  }\n  static decode(data) {\n    return (0,borsh__WEBPACK_IMPORTED_MODULE_3__.deserialize)(SOLANA_SCHEMA, this, data);\n  }\n  static decodeUnchecked(data) {\n    return (0,borsh__WEBPACK_IMPORTED_MODULE_3__.deserializeUnchecked)(SOLANA_SCHEMA, this, data);\n  }\n}\n\n// Class representing a Rust-compatible enum, since enums are only strings or\n// numbers in pure JS\nclass Enum extends Struct {\n  constructor(properties) {\n    super(properties);\n    this.enum = '';\n    if (Object.keys(properties).length !== 1) {\n      throw new Error('Enum can only take single value');\n    }\n    Object.keys(properties).map(key => {\n      this.enum = key;\n    });\n  }\n}\nconst SOLANA_SCHEMA = new Map();\n\nvar _PublicKey;\n\n/**\n * Maximum length of derived pubkey seed\n */\nconst MAX_SEED_LENGTH = 32;\n\n/**\n * Size of public key in bytes\n */\nconst PUBLIC_KEY_LENGTH = 32;\n\n/**\n * Value to be converted into public key\n */\n\n/**\n * JSON object representation of PublicKey class\n */\n\nfunction isPublicKeyData(value) {\n  return value._bn !== undefined;\n}\n\n// local counter used by PublicKey.unique()\nlet uniquePublicKeyCounter = 1;\n\n/**\n * A public key\n */\nclass PublicKey extends Struct {\n  /**\n   * Create a new PublicKey object\n   * @param value ed25519 public key as buffer or base-58 encoded string\n   */\n  constructor(value) {\n    super({});\n    /** @internal */\n    this._bn = void 0;\n    if (isPublicKeyData(value)) {\n      this._bn = value._bn;\n    } else {\n      if (typeof value === 'string') {\n        // assume base 58 encoding by default\n        const decoded = bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(value);\n        if (decoded.length != PUBLIC_KEY_LENGTH) {\n          throw new Error(`Invalid public key input`);\n        }\n        this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_1___default())(decoded);\n      } else {\n        this._bn = new (bn_js__WEBPACK_IMPORTED_MODULE_1___default())(value);\n      }\n      if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {\n        throw new Error(`Invalid public key input`);\n      }\n    }\n  }\n\n  /**\n   * Returns a unique PublicKey for tests and benchmarks using a counter\n   */\n  static unique() {\n    const key = new PublicKey(uniquePublicKeyCounter);\n    uniquePublicKeyCounter += 1;\n    return new PublicKey(key.toBuffer());\n  }\n\n  /**\n   * Default public key value. The base58-encoded string representation is all ones (as seen below)\n   * The underlying BN number is 32 bytes that are all zeros\n   */\n\n  /**\n   * Checks if two publicKeys are equal\n   */\n  equals(publicKey) {\n    return this._bn.eq(publicKey._bn);\n  }\n\n  /**\n   * Return the base-58 representation of the public key\n   */\n  toBase58() {\n    return bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(this.toBytes());\n  }\n  toJSON() {\n    return this.toBase58();\n  }\n\n  /**\n   * Return the byte array representation of the public key in big endian\n   */\n  toBytes() {\n    const buf = this.toBuffer();\n    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n  }\n\n  /**\n   * Return the Buffer representation of the public key in big endian\n   */\n  toBuffer() {\n    const b = this._bn.toArrayLike(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer);\n    if (b.length === PUBLIC_KEY_LENGTH) {\n      return b;\n    }\n    const zeroPad = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(32);\n    b.copy(zeroPad, 32 - b.length);\n    return zeroPad;\n  }\n  get [Symbol.toStringTag]() {\n    return `PublicKey(${this.toString()})`;\n  }\n\n  /**\n   * Return the base-58 representation of the public key\n   */\n  toString() {\n    return this.toBase58();\n  }\n\n  /**\n   * Derive a public key from another key, a seed, and a program ID.\n   * The program ID will also serve as the owner of the public key, giving\n   * it permission to write data to the account.\n   */\n  /* eslint-disable require-await */\n  static async createWithSeed(fromPublicKey, seed, programId) {\n    const buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([fromPublicKey.toBuffer(), buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(seed), programId.toBuffer()]);\n    const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_10__.sha256)(buffer);\n    return new PublicKey(publicKeyBytes);\n  }\n\n  /**\n   * Derive a program address from seeds and a program ID.\n   */\n  /* eslint-disable require-await */\n  static createProgramAddressSync(seeds, programId) {\n    let buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);\n    seeds.forEach(function (seed) {\n      if (seed.length > MAX_SEED_LENGTH) {\n        throw new TypeError(`Max seed length exceeded`);\n      }\n      buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([buffer, toBuffer(seed)]);\n    });\n    buffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([buffer, programId.toBuffer(), buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from('ProgramDerivedAddress')]);\n    const publicKeyBytes = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_10__.sha256)(buffer);\n    if (isOnCurve(publicKeyBytes)) {\n      throw new Error(`Invalid seeds, address must fall off the curve`);\n    }\n    return new PublicKey(publicKeyBytes);\n  }\n\n  /**\n   * Async version of createProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link createProgramAddressSync} instead\n   */\n  /* eslint-disable require-await */\n  static async createProgramAddress(seeds, programId) {\n    return this.createProgramAddressSync(seeds, programId);\n  }\n\n  /**\n   * Find a valid program address\n   *\n   * Valid program addresses must fall off the ed25519 curve.  This function\n   * iterates a nonce until it finds one that when combined with the seeds\n   * results in a valid program address.\n   */\n  static findProgramAddressSync(seeds, programId) {\n    let nonce = 255;\n    let address;\n    while (nonce != 0) {\n      try {\n        const seedsWithNonce = seeds.concat(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([nonce]));\n        address = this.createProgramAddressSync(seedsWithNonce, programId);\n      } catch (err) {\n        if (err instanceof TypeError) {\n          throw err;\n        }\n        nonce--;\n        continue;\n      }\n      return [address, nonce];\n    }\n    throw new Error(`Unable to find a viable program address nonce`);\n  }\n\n  /**\n   * Async version of findProgramAddressSync\n   * For backwards compatibility\n   *\n   * @deprecated Use {@link findProgramAddressSync} instead\n   */\n  static async findProgramAddress(seeds, programId) {\n    return this.findProgramAddressSync(seeds, programId);\n  }\n\n  /**\n   * Check that a pubkey is on the ed25519 curve.\n   */\n  static isOnCurve(pubkeyData) {\n    const pubkey = new PublicKey(pubkeyData);\n    return isOnCurve(pubkey.toBytes());\n  }\n}\n_PublicKey = PublicKey;\nPublicKey.default = new _PublicKey('11111111111111111111111111111111');\nSOLANA_SCHEMA.set(PublicKey, {\n  kind: 'struct',\n  fields: [['_bn', 'u256']]\n});\n\n/**\n * An account key pair (public and secret keys).\n *\n * @deprecated since v1.10.0, please use {@link Keypair} instead.\n */\nclass Account {\n  /**\n   * Create a new Account object\n   *\n   * If the secretKey parameter is not provided a new key pair is randomly\n   * created for the account\n   *\n   * @param secretKey Secret key for the account\n   */\n  constructor(secretKey) {\n    /** @internal */\n    this._publicKey = void 0;\n    /** @internal */\n    this._secretKey = void 0;\n    if (secretKey) {\n      const secretKeyBuffer = toBuffer(secretKey);\n      if (secretKey.length !== 64) {\n        throw new Error('bad secret key size');\n      }\n      this._publicKey = secretKeyBuffer.slice(32, 64);\n      this._secretKey = secretKeyBuffer.slice(0, 32);\n    } else {\n      this._secretKey = toBuffer(generatePrivateKey());\n      this._publicKey = toBuffer(getPublicKey(this._secretKey));\n    }\n  }\n\n  /**\n   * The public key for this account\n   */\n  get publicKey() {\n    return new PublicKey(this._publicKey);\n  }\n\n  /**\n   * The **unencrypted** secret key for this account. The first 32 bytes\n   * is the private scalar and the last 32 bytes is the public key.\n   * Read more: https://blog.mozilla.org/warner/2011/11/29/ed25519-keys/\n   */\n  get secretKey() {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.concat([this._secretKey, this._publicKey], 64);\n  }\n}\n\nconst BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey('BPFLoader1111111111111111111111111111111111');\n\n/**\n * Maximum over-the-wire size of a Transaction\n *\n * 1280 is IPv6 minimum MTU\n * 40 bytes is the size of the IPv6 header\n * 8 bytes is the size of the fragment header\n */\nconst PACKET_DATA_SIZE = 1280 - 40 - 8;\nconst VERSION_PREFIX_MASK = 0x7f;\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\n\nclass TransactionExpiredBlockheightExceededError extends Error {\n  constructor(signature) {\n    super(`Signature ${signature} has expired: block height exceeded.`);\n    this.signature = void 0;\n    this.signature = signature;\n  }\n}\nObject.defineProperty(TransactionExpiredBlockheightExceededError.prototype, 'name', {\n  value: 'TransactionExpiredBlockheightExceededError'\n});\nclass TransactionExpiredTimeoutError extends Error {\n  constructor(signature, timeoutSeconds) {\n    super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is ` + 'unknown if it succeeded or failed. Check signature ' + `${signature} using the Solana Explorer or CLI tools.`);\n    this.signature = void 0;\n    this.signature = signature;\n  }\n}\nObject.defineProperty(TransactionExpiredTimeoutError.prototype, 'name', {\n  value: 'TransactionExpiredTimeoutError'\n});\nclass TransactionExpiredNonceInvalidError extends Error {\n  constructor(signature) {\n    super(`Signature ${signature} has expired: the nonce is no longer valid.`);\n    this.signature = void 0;\n    this.signature = signature;\n  }\n}\nObject.defineProperty(TransactionExpiredNonceInvalidError.prototype, 'name', {\n  value: 'TransactionExpiredNonceInvalidError'\n});\n\nclass MessageAccountKeys {\n  constructor(staticAccountKeys, accountKeysFromLookups) {\n    this.staticAccountKeys = void 0;\n    this.accountKeysFromLookups = void 0;\n    this.staticAccountKeys = staticAccountKeys;\n    this.accountKeysFromLookups = accountKeysFromLookups;\n  }\n  keySegments() {\n    const keySegments = [this.staticAccountKeys];\n    if (this.accountKeysFromLookups) {\n      keySegments.push(this.accountKeysFromLookups.writable);\n      keySegments.push(this.accountKeysFromLookups.readonly);\n    }\n    return keySegments;\n  }\n  get(index) {\n    for (const keySegment of this.keySegments()) {\n      if (index < keySegment.length) {\n        return keySegment[index];\n      } else {\n        index -= keySegment.length;\n      }\n    }\n    return;\n  }\n  get length() {\n    return this.keySegments().flat().length;\n  }\n  compileInstructions(instructions) {\n    // Bail early if any account indexes would overflow a u8\n    const U8_MAX = 255;\n    if (this.length > U8_MAX + 1) {\n      throw new Error('Account index overflow encountered during compilation');\n    }\n    const keyIndexMap = new Map();\n    this.keySegments().flat().forEach((key, index) => {\n      keyIndexMap.set(key.toBase58(), index);\n    });\n    const findKeyIndex = key => {\n      const keyIndex = keyIndexMap.get(key.toBase58());\n      if (keyIndex === undefined) throw new Error('Encountered an unknown instruction account key during compilation');\n      return keyIndex;\n    };\n    return instructions.map(instruction => {\n      return {\n        programIdIndex: findKeyIndex(instruction.programId),\n        accountKeyIndexes: instruction.keys.map(meta => findKeyIndex(meta.pubkey)),\n        data: instruction.data\n      };\n    });\n  }\n}\n\n/**\n * Layout for a public key\n */\nconst publicKey = (property = 'publicKey') => {\n  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(32, property);\n};\n\n/**\n * Layout for a signature\n */\nconst signature = (property = 'signature') => {\n  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(64, property);\n};\n/**\n * Layout for a Rust String type\n */\nconst rustString = (property = 'string') => {\n  const rsl = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('length'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('lengthPadding'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), 'chars')], property);\n  const _decode = rsl.decode.bind(rsl);\n  const _encode = rsl.encode.bind(rsl);\n  const rslShim = rsl;\n  rslShim.decode = (b, offset) => {\n    const data = _decode(b, offset);\n    return data['chars'].toString();\n  };\n  rslShim.encode = (str, b, offset) => {\n    const data = {\n      chars: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, 'utf8')\n    };\n    return _encode(data, b, offset);\n  };\n  rslShim.alloc = str => {\n    return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32().span + _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32().span + buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, 'utf8').length;\n  };\n  return rslShim;\n};\n\n/**\n * Layout for an Authorized object\n */\nconst authorized = (property = 'authorized') => {\n  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([publicKey('staker'), publicKey('withdrawer')], property);\n};\n\n/**\n * Layout for a Lockup object\n */\nconst lockup = (property = 'lockup') => {\n  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64('unixTimestamp'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64('epoch'), publicKey('custodian')], property);\n};\n\n/**\n *  Layout for a VoteInit object\n */\nconst voteInit = (property = 'voteInit') => {\n  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([publicKey('nodePubkey'), publicKey('authorizedVoter'), publicKey('authorizedWithdrawer'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('commission')], property);\n};\n\n/**\n *  Layout for a VoteAuthorizeWithSeedArgs object\n */\nconst voteAuthorizeWithSeedArgs = (property = 'voteAuthorizeWithSeedArgs') => {\n  return _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('voteAuthorizationType'), publicKey('currentAuthorityDerivedKeyOwnerPubkey'), rustString('currentAuthorityDerivedKeySeed'), publicKey('newAuthorized')], property);\n};\nfunction getAlloc(type, fields) {\n  const getItemAlloc = item => {\n    if (item.span >= 0) {\n      return item.span;\n    } else if (typeof item.alloc === 'function') {\n      return item.alloc(fields[item.property]);\n    } else if ('count' in item && 'elementLayout' in item) {\n      const field = fields[item.property];\n      if (Array.isArray(field)) {\n        return field.length * getItemAlloc(item.elementLayout);\n      }\n    } else if ('fields' in item) {\n      // This is a `Structure` whose size needs to be recursively measured.\n      return getAlloc({\n        layout: item\n      }, fields[item.property]);\n    }\n    // Couldn't determine allocated size of layout\n    return 0;\n  };\n  let alloc = 0;\n  type.layout.fields.forEach(item => {\n    alloc += getItemAlloc(item);\n  });\n  return alloc;\n}\n\nfunction decodeLength(bytes) {\n  let len = 0;\n  let size = 0;\n  for (;;) {\n    let elem = bytes.shift();\n    len |= (elem & 0x7f) << size * 7;\n    size += 1;\n    if ((elem & 0x80) === 0) {\n      break;\n    }\n  }\n  return len;\n}\nfunction encodeLength(bytes, len) {\n  let rem_len = len;\n  for (;;) {\n    let elem = rem_len & 0x7f;\n    rem_len >>= 7;\n    if (rem_len == 0) {\n      bytes.push(elem);\n      break;\n    } else {\n      elem |= 0x80;\n      bytes.push(elem);\n    }\n  }\n}\n\nfunction assert (condition, message) {\n  if (!condition) {\n    throw new Error(message || 'Assertion failed');\n  }\n}\n\nclass CompiledKeys {\n  constructor(payer, keyMetaMap) {\n    this.payer = void 0;\n    this.keyMetaMap = void 0;\n    this.payer = payer;\n    this.keyMetaMap = keyMetaMap;\n  }\n  static compile(instructions, payer) {\n    const keyMetaMap = new Map();\n    const getOrInsertDefault = pubkey => {\n      const address = pubkey.toBase58();\n      let keyMeta = keyMetaMap.get(address);\n      if (keyMeta === undefined) {\n        keyMeta = {\n          isSigner: false,\n          isWritable: false,\n          isInvoked: false\n        };\n        keyMetaMap.set(address, keyMeta);\n      }\n      return keyMeta;\n    };\n    const payerKeyMeta = getOrInsertDefault(payer);\n    payerKeyMeta.isSigner = true;\n    payerKeyMeta.isWritable = true;\n    for (const ix of instructions) {\n      getOrInsertDefault(ix.programId).isInvoked = true;\n      for (const accountMeta of ix.keys) {\n        const keyMeta = getOrInsertDefault(accountMeta.pubkey);\n        keyMeta.isSigner ||= accountMeta.isSigner;\n        keyMeta.isWritable ||= accountMeta.isWritable;\n      }\n    }\n    return new CompiledKeys(payer, keyMetaMap);\n  }\n  getMessageComponents() {\n    const mapEntries = [...this.keyMetaMap.entries()];\n    assert(mapEntries.length <= 256, 'Max static account keys length exceeded');\n    const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);\n    const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);\n    const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);\n    const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);\n    const header = {\n      numRequiredSignatures: writableSigners.length + readonlySigners.length,\n      numReadonlySignedAccounts: readonlySigners.length,\n      numReadonlyUnsignedAccounts: readonlyNonSigners.length\n    };\n\n    // sanity checks\n    {\n      assert(writableSigners.length > 0, 'Expected at least one writable signer key');\n      const [payerAddress] = writableSigners[0];\n      assert(payerAddress === this.payer.toBase58(), 'Expected first writable signer key to be the fee payer');\n    }\n    const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey(address)), ...readonlySigners.map(([address]) => new PublicKey(address)), ...writableNonSigners.map(([address]) => new PublicKey(address)), ...readonlyNonSigners.map(([address]) => new PublicKey(address))];\n    return [header, staticAccountKeys];\n  }\n  extractTableLookup(lookupTable) {\n    const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, keyMeta => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);\n    const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, keyMeta => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);\n\n    // Don't extract lookup if no keys were found\n    if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {\n      return;\n    }\n    return [{\n      accountKey: lookupTable.key,\n      writableIndexes,\n      readonlyIndexes\n    }, {\n      writable: drainedWritableKeys,\n      readonly: drainedReadonlyKeys\n    }];\n  }\n\n  /** @internal */\n  drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {\n    const lookupTableIndexes = new Array();\n    const drainedKeys = new Array();\n    for (const [address, keyMeta] of this.keyMetaMap.entries()) {\n      if (keyMetaFilter(keyMeta)) {\n        const key = new PublicKey(address);\n        const lookupTableIndex = lookupTableEntries.findIndex(entry => entry.equals(key));\n        if (lookupTableIndex >= 0) {\n          assert(lookupTableIndex < 256, 'Max lookup table index exceeded');\n          lookupTableIndexes.push(lookupTableIndex);\n          drainedKeys.push(key);\n          this.keyMetaMap.delete(address);\n        }\n      }\n    }\n    return [lookupTableIndexes, drainedKeys];\n  }\n}\n\nconst END_OF_BUFFER_ERROR_MESSAGE = 'Reached end of buffer unexpectedly';\n\n/**\n * Delegates to `Array#shift`, but throws if the array is zero-length.\n */\nfunction guardedShift(byteArray) {\n  if (byteArray.length === 0) {\n    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n  }\n  return byteArray.shift();\n}\n\n/**\n * Delegates to `Array#splice`, but throws if the section being spliced out extends past the end of\n * the array.\n */\nfunction guardedSplice(byteArray, ...args) {\n  const [start] = args;\n  if (args.length === 2 // Implies that `deleteCount` was supplied\n  ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {\n    throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n  }\n  return byteArray.splice(...args);\n}\n\n/**\n * An instruction to execute by a program\n *\n * @property {number} programIdIndex\n * @property {number[]} accounts\n * @property {string} data\n */\n\n/**\n * Message constructor arguments\n */\n\n/**\n * List of instructions to be processed atomically\n */\nclass Message {\n  constructor(args) {\n    this.header = void 0;\n    this.accountKeys = void 0;\n    this.recentBlockhash = void 0;\n    this.instructions = void 0;\n    this.indexToProgramIds = new Map();\n    this.header = args.header;\n    this.accountKeys = args.accountKeys.map(account => new PublicKey(account));\n    this.recentBlockhash = args.recentBlockhash;\n    this.instructions = args.instructions;\n    this.instructions.forEach(ix => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));\n  }\n  get version() {\n    return 'legacy';\n  }\n  get staticAccountKeys() {\n    return this.accountKeys;\n  }\n  get compiledInstructions() {\n    return this.instructions.map(ix => ({\n      programIdIndex: ix.programIdIndex,\n      accountKeyIndexes: ix.accounts,\n      data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(ix.data)\n    }));\n  }\n  get addressTableLookups() {\n    return [];\n  }\n  getAccountKeys() {\n    return new MessageAccountKeys(this.staticAccountKeys);\n  }\n  static compile(args) {\n    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n    const accountKeys = new MessageAccountKeys(staticAccountKeys);\n    const instructions = accountKeys.compileInstructions(args.instructions).map(ix => ({\n      programIdIndex: ix.programIdIndex,\n      accounts: ix.accountKeyIndexes,\n      data: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(ix.data)\n    }));\n    return new Message({\n      header,\n      accountKeys: staticAccountKeys,\n      recentBlockhash: args.recentBlockhash,\n      instructions\n    });\n  }\n  isAccountSigner(index) {\n    return index < this.header.numRequiredSignatures;\n  }\n  isAccountWritable(index) {\n    const numSignedAccounts = this.header.numRequiredSignatures;\n    if (index >= this.header.numRequiredSignatures) {\n      const unsignedAccountIndex = index - numSignedAccounts;\n      const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;\n      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n      return unsignedAccountIndex < numWritableUnsignedAccounts;\n    } else {\n      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n      return index < numWritableSignedAccounts;\n    }\n  }\n  isProgramId(index) {\n    return this.indexToProgramIds.has(index);\n  }\n  programIds() {\n    return [...this.indexToProgramIds.values()];\n  }\n  nonProgramIds() {\n    return this.accountKeys.filter((_, index) => !this.isProgramId(index));\n  }\n  serialize() {\n    const numKeys = this.accountKeys.length;\n    let keyCount = [];\n    encodeLength(keyCount, numKeys);\n    const instructions = this.instructions.map(instruction => {\n      const {\n        accounts,\n        programIdIndex\n      } = instruction;\n      const data = Array.from(bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(instruction.data));\n      let keyIndicesCount = [];\n      encodeLength(keyIndicesCount, accounts.length);\n      let dataCount = [];\n      encodeLength(dataCount, data.length);\n      return {\n        programIdIndex,\n        keyIndicesCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyIndicesCount),\n        keyIndices: accounts,\n        dataLength: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataCount),\n        data\n      };\n    });\n    let instructionCount = [];\n    encodeLength(instructionCount, instructions.length);\n    let instructionBuffer = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(PACKET_DATA_SIZE);\n    buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(instructionCount).copy(instructionBuffer);\n    let instructionBufferLength = instructionCount.length;\n    instructions.forEach(instruction => {\n      const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('programIdIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.keyIndicesCount.length, 'keyIndicesCount'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('keyIndex'), instruction.keyIndices.length, 'keyIndices'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.dataLength.length, 'dataLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('userdatum'), instruction.data.length, 'data')]);\n      const length = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);\n      instructionBufferLength += length;\n    });\n    instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);\n    const signDataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, 'numRequiredSignatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, 'numReadonlySignedAccounts'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(1, 'numReadonlyUnsignedAccounts'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(keyCount.length, 'keyCount'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey('key'), numKeys, 'keys'), publicKey('recentBlockhash')]);\n    const transaction = {\n      numRequiredSignatures: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([this.header.numRequiredSignatures]),\n      numReadonlySignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([this.header.numReadonlySignedAccounts]),\n      numReadonlyUnsignedAccounts: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from([this.header.numReadonlyUnsignedAccounts]),\n      keyCount: buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(keyCount),\n      keys: this.accountKeys.map(key => toBuffer(key.toBytes())),\n      recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(this.recentBlockhash)\n    };\n    let signData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(2048);\n    const length = signDataLayout.encode(transaction, signData);\n    instructionBuffer.copy(signData, length);\n    return signData.slice(0, length + instructionBuffer.length);\n  }\n\n  /**\n   * Decode a compiled message into a Message object.\n   */\n  static from(buffer) {\n    // Slice up wire data\n    let byteArray = [...buffer];\n    const numRequiredSignatures = guardedShift(byteArray);\n    if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {\n      throw new Error('Versioned messages must be deserialized with VersionedMessage.deserialize()');\n    }\n    const numReadonlySignedAccounts = guardedShift(byteArray);\n    const numReadonlyUnsignedAccounts = guardedShift(byteArray);\n    const accountCount = decodeLength(byteArray);\n    let accountKeys = [];\n    for (let i = 0; i < accountCount; i++) {\n      const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n      accountKeys.push(new PublicKey(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(account)));\n    }\n    const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n    const instructionCount = decodeLength(byteArray);\n    let instructions = [];\n    for (let i = 0; i < instructionCount; i++) {\n      const programIdIndex = guardedShift(byteArray);\n      const accountCount = decodeLength(byteArray);\n      const accounts = guardedSplice(byteArray, 0, accountCount);\n      const dataLength = decodeLength(byteArray);\n      const dataSlice = guardedSplice(byteArray, 0, dataLength);\n      const data = bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(dataSlice));\n      instructions.push({\n        programIdIndex,\n        accounts,\n        data\n      });\n    }\n    const messageArgs = {\n      header: {\n        numRequiredSignatures,\n        numReadonlySignedAccounts,\n        numReadonlyUnsignedAccounts\n      },\n      recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(recentBlockhash)),\n      accountKeys,\n      instructions\n    };\n    return new Message(messageArgs);\n  }\n}\n\n/**\n * Message constructor arguments\n */\n\nclass MessageV0 {\n  constructor(args) {\n    this.header = void 0;\n    this.staticAccountKeys = void 0;\n    this.recentBlockhash = void 0;\n    this.compiledInstructions = void 0;\n    this.addressTableLookups = void 0;\n    this.header = args.header;\n    this.staticAccountKeys = args.staticAccountKeys;\n    this.recentBlockhash = args.recentBlockhash;\n    this.compiledInstructions = args.compiledInstructions;\n    this.addressTableLookups = args.addressTableLookups;\n  }\n  get version() {\n    return 0;\n  }\n  get numAccountKeysFromLookups() {\n    let count = 0;\n    for (const lookup of this.addressTableLookups) {\n      count += lookup.readonlyIndexes.length + lookup.writableIndexes.length;\n    }\n    return count;\n  }\n  getAccountKeys(args) {\n    let accountKeysFromLookups;\n    if (args && 'accountKeysFromLookups' in args && args.accountKeysFromLookups) {\n      if (this.numAccountKeysFromLookups != args.accountKeysFromLookups.writable.length + args.accountKeysFromLookups.readonly.length) {\n        throw new Error('Failed to get account keys because of a mismatch in the number of account keys from lookups');\n      }\n      accountKeysFromLookups = args.accountKeysFromLookups;\n    } else if (args && 'addressLookupTableAccounts' in args && args.addressLookupTableAccounts) {\n      accountKeysFromLookups = this.resolveAddressTableLookups(args.addressLookupTableAccounts);\n    } else if (this.addressTableLookups.length > 0) {\n      throw new Error('Failed to get account keys because address table lookups were not resolved');\n    }\n    return new MessageAccountKeys(this.staticAccountKeys, accountKeysFromLookups);\n  }\n  isAccountSigner(index) {\n    return index < this.header.numRequiredSignatures;\n  }\n  isAccountWritable(index) {\n    const numSignedAccounts = this.header.numRequiredSignatures;\n    const numStaticAccountKeys = this.staticAccountKeys.length;\n    if (index >= numStaticAccountKeys) {\n      const lookupAccountKeysIndex = index - numStaticAccountKeys;\n      const numWritableLookupAccountKeys = this.addressTableLookups.reduce((count, lookup) => count + lookup.writableIndexes.length, 0);\n      return lookupAccountKeysIndex < numWritableLookupAccountKeys;\n    } else if (index >= this.header.numRequiredSignatures) {\n      const unsignedAccountIndex = index - numSignedAccounts;\n      const numUnsignedAccounts = numStaticAccountKeys - numSignedAccounts;\n      const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n      return unsignedAccountIndex < numWritableUnsignedAccounts;\n    } else {\n      const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n      return index < numWritableSignedAccounts;\n    }\n  }\n  resolveAddressTableLookups(addressLookupTableAccounts) {\n    const accountKeysFromLookups = {\n      writable: [],\n      readonly: []\n    };\n    for (const tableLookup of this.addressTableLookups) {\n      const tableAccount = addressLookupTableAccounts.find(account => account.key.equals(tableLookup.accountKey));\n      if (!tableAccount) {\n        throw new Error(`Failed to find address lookup table account for table key ${tableLookup.accountKey.toBase58()}`);\n      }\n      for (const index of tableLookup.writableIndexes) {\n        if (index < tableAccount.state.addresses.length) {\n          accountKeysFromLookups.writable.push(tableAccount.state.addresses[index]);\n        } else {\n          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n        }\n      }\n      for (const index of tableLookup.readonlyIndexes) {\n        if (index < tableAccount.state.addresses.length) {\n          accountKeysFromLookups.readonly.push(tableAccount.state.addresses[index]);\n        } else {\n          throw new Error(`Failed to find address for index ${index} in address lookup table ${tableLookup.accountKey.toBase58()}`);\n        }\n      }\n    }\n    return accountKeysFromLookups;\n  }\n  static compile(args) {\n    const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n    const addressTableLookups = new Array();\n    const accountKeysFromLookups = {\n      writable: new Array(),\n      readonly: new Array()\n    };\n    const lookupTableAccounts = args.addressLookupTableAccounts || [];\n    for (const lookupTable of lookupTableAccounts) {\n      const extractResult = compiledKeys.extractTableLookup(lookupTable);\n      if (extractResult !== undefined) {\n        const [addressTableLookup, {\n          writable,\n          readonly\n        }] = extractResult;\n        addressTableLookups.push(addressTableLookup);\n        accountKeysFromLookups.writable.push(...writable);\n        accountKeysFromLookups.readonly.push(...readonly);\n      }\n    }\n    const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n    const accountKeys = new MessageAccountKeys(staticAccountKeys, accountKeysFromLookups);\n    const compiledInstructions = accountKeys.compileInstructions(args.instructions);\n    return new MessageV0({\n      header,\n      staticAccountKeys,\n      recentBlockhash: args.recentBlockhash,\n      compiledInstructions,\n      addressTableLookups\n    });\n  }\n  serialize() {\n    const encodedStaticAccountKeysLength = Array();\n    encodeLength(encodedStaticAccountKeysLength, this.staticAccountKeys.length);\n    const serializedInstructions = this.serializeInstructions();\n    const encodedInstructionsLength = Array();\n    encodeLength(encodedInstructionsLength, this.compiledInstructions.length);\n    const serializedAddressTableLookups = this.serializeAddressTableLookups();\n    const encodedAddressTableLookupsLength = Array();\n    encodeLength(encodedAddressTableLookupsLength, this.addressTableLookups.length);\n    const messageLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('prefix'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('numRequiredSignatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('numReadonlySignedAccounts'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('numReadonlyUnsignedAccounts')], 'header'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedStaticAccountKeysLength.length, 'staticAccountKeysLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), this.staticAccountKeys.length, 'staticAccountKeys'), publicKey('recentBlockhash'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedInstructionsLength.length, 'instructionsLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedInstructions.length, 'serializedInstructions'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedAddressTableLookupsLength.length, 'addressTableLookupsLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedAddressTableLookups.length, 'serializedAddressTableLookups')]);\n    const serializedMessage = new Uint8Array(PACKET_DATA_SIZE);\n    const MESSAGE_VERSION_0_PREFIX = 1 << 7;\n    const serializedMessageLength = messageLayout.encode({\n      prefix: MESSAGE_VERSION_0_PREFIX,\n      header: this.header,\n      staticAccountKeysLength: new Uint8Array(encodedStaticAccountKeysLength),\n      staticAccountKeys: this.staticAccountKeys.map(key => key.toBytes()),\n      recentBlockhash: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(this.recentBlockhash),\n      instructionsLength: new Uint8Array(encodedInstructionsLength),\n      serializedInstructions,\n      addressTableLookupsLength: new Uint8Array(encodedAddressTableLookupsLength),\n      serializedAddressTableLookups\n    }, serializedMessage);\n    return serializedMessage.slice(0, serializedMessageLength);\n  }\n  serializeInstructions() {\n    let serializedLength = 0;\n    const serializedInstructions = new Uint8Array(PACKET_DATA_SIZE);\n    for (const instruction of this.compiledInstructions) {\n      const encodedAccountKeyIndexesLength = Array();\n      encodeLength(encodedAccountKeyIndexesLength, instruction.accountKeyIndexes.length);\n      const encodedDataLength = Array();\n      encodeLength(encodedDataLength, instruction.data.length);\n      const instructionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('programIdIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedAccountKeyIndexesLength.length, 'encodedAccountKeyIndexesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), instruction.accountKeyIndexes.length, 'accountKeyIndexes'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedDataLength.length, 'encodedDataLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(instruction.data.length, 'data')]);\n      serializedLength += instructionLayout.encode({\n        programIdIndex: instruction.programIdIndex,\n        encodedAccountKeyIndexesLength: new Uint8Array(encodedAccountKeyIndexesLength),\n        accountKeyIndexes: instruction.accountKeyIndexes,\n        encodedDataLength: new Uint8Array(encodedDataLength),\n        data: instruction.data\n      }, serializedInstructions, serializedLength);\n    }\n    return serializedInstructions.slice(0, serializedLength);\n  }\n  serializeAddressTableLookups() {\n    let serializedLength = 0;\n    const serializedAddressTableLookups = new Uint8Array(PACKET_DATA_SIZE);\n    for (const lookup of this.addressTableLookups) {\n      const encodedWritableIndexesLength = Array();\n      encodeLength(encodedWritableIndexesLength, lookup.writableIndexes.length);\n      const encodedReadonlyIndexesLength = Array();\n      encodeLength(encodedReadonlyIndexesLength, lookup.readonlyIndexes.length);\n      const addressTableLookupLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([publicKey('accountKey'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedWritableIndexesLength.length, 'encodedWritableIndexesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), lookup.writableIndexes.length, 'writableIndexes'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedReadonlyIndexesLength.length, 'encodedReadonlyIndexesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), lookup.readonlyIndexes.length, 'readonlyIndexes')]);\n      serializedLength += addressTableLookupLayout.encode({\n        accountKey: lookup.accountKey.toBytes(),\n        encodedWritableIndexesLength: new Uint8Array(encodedWritableIndexesLength),\n        writableIndexes: lookup.writableIndexes,\n        encodedReadonlyIndexesLength: new Uint8Array(encodedReadonlyIndexesLength),\n        readonlyIndexes: lookup.readonlyIndexes\n      }, serializedAddressTableLookups, serializedLength);\n    }\n    return serializedAddressTableLookups.slice(0, serializedLength);\n  }\n  static deserialize(serializedMessage) {\n    let byteArray = [...serializedMessage];\n    const prefix = guardedShift(byteArray);\n    const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n    assert(prefix !== maskedPrefix, `Expected versioned message but received legacy message`);\n    const version = maskedPrefix;\n    assert(version === 0, `Expected versioned message with version 0 but found version ${version}`);\n    const header = {\n      numRequiredSignatures: guardedShift(byteArray),\n      numReadonlySignedAccounts: guardedShift(byteArray),\n      numReadonlyUnsignedAccounts: guardedShift(byteArray)\n    };\n    const staticAccountKeys = [];\n    const staticAccountKeysLength = decodeLength(byteArray);\n    for (let i = 0; i < staticAccountKeysLength; i++) {\n      staticAccountKeys.push(new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH)));\n    }\n    const recentBlockhash = bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n    const instructionCount = decodeLength(byteArray);\n    const compiledInstructions = [];\n    for (let i = 0; i < instructionCount; i++) {\n      const programIdIndex = guardedShift(byteArray);\n      const accountKeyIndexesLength = decodeLength(byteArray);\n      const accountKeyIndexes = guardedSplice(byteArray, 0, accountKeyIndexesLength);\n      const dataLength = decodeLength(byteArray);\n      const data = new Uint8Array(guardedSplice(byteArray, 0, dataLength));\n      compiledInstructions.push({\n        programIdIndex,\n        accountKeyIndexes,\n        data\n      });\n    }\n    const addressTableLookupsCount = decodeLength(byteArray);\n    const addressTableLookups = [];\n    for (let i = 0; i < addressTableLookupsCount; i++) {\n      const accountKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n      const writableIndexesLength = decodeLength(byteArray);\n      const writableIndexes = guardedSplice(byteArray, 0, writableIndexesLength);\n      const readonlyIndexesLength = decodeLength(byteArray);\n      const readonlyIndexes = guardedSplice(byteArray, 0, readonlyIndexesLength);\n      addressTableLookups.push({\n        accountKey,\n        writableIndexes,\n        readonlyIndexes\n      });\n    }\n    return new MessageV0({\n      header,\n      staticAccountKeys,\n      recentBlockhash,\n      compiledInstructions,\n      addressTableLookups\n    });\n  }\n}\n\n// eslint-disable-next-line no-redeclare\nconst VersionedMessage = {\n  deserializeMessageVersion(serializedMessage) {\n    const prefix = serializedMessage[0];\n    const maskedPrefix = prefix & VERSION_PREFIX_MASK;\n\n    // if the highest bit of the prefix is not set, the message is not versioned\n    if (maskedPrefix === prefix) {\n      return 'legacy';\n    }\n\n    // the lower 7 bits of the prefix indicate the message version\n    return maskedPrefix;\n  },\n  deserialize: serializedMessage => {\n    const version = VersionedMessage.deserializeMessageVersion(serializedMessage);\n    if (version === 'legacy') {\n      return Message.from(serializedMessage);\n    }\n    if (version === 0) {\n      return MessageV0.deserialize(serializedMessage);\n    } else {\n      throw new Error(`Transaction message version ${version} deserialization is not supported`);\n    }\n  }\n};\n\n/** @internal */\n\n/**\n * Transaction signature as base-58 encoded string\n */\n\nlet TransactionStatus = /*#__PURE__*/function (TransactionStatus) {\n  TransactionStatus[TransactionStatus[\"BLOCKHEIGHT_EXCEEDED\"] = 0] = \"BLOCKHEIGHT_EXCEEDED\";\n  TransactionStatus[TransactionStatus[\"PROCESSED\"] = 1] = \"PROCESSED\";\n  TransactionStatus[TransactionStatus[\"TIMED_OUT\"] = 2] = \"TIMED_OUT\";\n  TransactionStatus[TransactionStatus[\"NONCE_INVALID\"] = 3] = \"NONCE_INVALID\";\n  return TransactionStatus;\n}({});\n\n/**\n * Default (empty) signature\n */\nconst DEFAULT_SIGNATURE = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);\n\n/**\n * Account metadata used to define instructions\n */\n\n/**\n * List of TransactionInstruction object fields that may be initialized at construction\n */\n\n/**\n * Configuration object for Transaction.serialize()\n */\n\n/**\n * @internal\n */\n\n/**\n * Transaction Instruction class\n */\nclass TransactionInstruction {\n  constructor(opts) {\n    /**\n     * Public keys to include in this transaction\n     * Boolean represents whether this pubkey needs to sign the transaction\n     */\n    this.keys = void 0;\n    /**\n     * Program Id to execute\n     */\n    this.programId = void 0;\n    /**\n     * Program input\n     */\n    this.data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(0);\n    this.programId = opts.programId;\n    this.keys = opts.keys;\n    if (opts.data) {\n      this.data = opts.data;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  toJSON() {\n    return {\n      keys: this.keys.map(({\n        pubkey,\n        isSigner,\n        isWritable\n      }) => ({\n        pubkey: pubkey.toJSON(),\n        isSigner,\n        isWritable\n      })),\n      programId: this.programId.toJSON(),\n      data: [...this.data]\n    };\n  }\n}\n\n/**\n * Pair of signature and corresponding public key\n */\n\n/**\n * List of Transaction object fields that may be initialized at construction\n */\n\n// For backward compatibility; an unfortunate consequence of being\n// forced to over-export types by the documentation generator.\n// See https://github.com/solana-labs/solana/pull/25820\n\n/**\n * Blockhash-based transactions have a lifetime that are defined by\n * the blockhash they include. Any transaction whose blockhash is\n * too old will be rejected.\n */\n\n/**\n * Use these options to construct a durable nonce transaction.\n */\n\n/**\n * Nonce information to be used to build an offline Transaction.\n */\n\n/**\n * @internal\n */\n\n/**\n * Transaction class\n */\nclass Transaction {\n  /**\n   * The first (payer) Transaction signature\n   *\n   * @returns {Buffer | null} Buffer of payer's signature\n   */\n  get signature() {\n    if (this.signatures.length > 0) {\n      return this.signatures[0].signature;\n    }\n    return null;\n  }\n\n  /**\n   * The transaction fee payer\n   */\n\n  // Construct a transaction with a blockhash and lastValidBlockHeight\n\n  // Construct a transaction using a durable nonce\n\n  /**\n   * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.\n   * Please supply a `TransactionBlockhashCtor` instead.\n   */\n\n  /**\n   * Construct an empty Transaction\n   */\n  constructor(opts) {\n    /**\n     * Signatures for the transaction.  Typically created by invoking the\n     * `sign()` method\n     */\n    this.signatures = [];\n    this.feePayer = void 0;\n    /**\n     * The instructions to atomically execute\n     */\n    this.instructions = [];\n    /**\n     * A recent transaction id. Must be populated by the caller\n     */\n    this.recentBlockhash = void 0;\n    /**\n     * the last block chain can advance to before tx is declared expired\n     * */\n    this.lastValidBlockHeight = void 0;\n    /**\n     * Optional Nonce information. If populated, transaction will use a durable\n     * Nonce hash instead of a recentBlockhash. Must be populated by the caller\n     */\n    this.nonceInfo = void 0;\n    /**\n     * If this is a nonce transaction this represents the minimum slot from which\n     * to evaluate if the nonce has advanced when attempting to confirm the\n     * transaction. This protects against a case where the transaction confirmation\n     * logic loads the nonce account from an old slot and assumes the mismatch in\n     * nonce value implies that the nonce has been advanced.\n     */\n    this.minNonceContextSlot = void 0;\n    /**\n     * @internal\n     */\n    this._message = void 0;\n    /**\n     * @internal\n     */\n    this._json = void 0;\n    if (!opts) {\n      return;\n    }\n    if (opts.feePayer) {\n      this.feePayer = opts.feePayer;\n    }\n    if (opts.signatures) {\n      this.signatures = opts.signatures;\n    }\n    if (Object.prototype.hasOwnProperty.call(opts, 'nonceInfo')) {\n      const {\n        minContextSlot,\n        nonceInfo\n      } = opts;\n      this.minNonceContextSlot = minContextSlot;\n      this.nonceInfo = nonceInfo;\n    } else if (Object.prototype.hasOwnProperty.call(opts, 'lastValidBlockHeight')) {\n      const {\n        blockhash,\n        lastValidBlockHeight\n      } = opts;\n      this.recentBlockhash = blockhash;\n      this.lastValidBlockHeight = lastValidBlockHeight;\n    } else {\n      const {\n        recentBlockhash,\n        nonceInfo\n      } = opts;\n      if (nonceInfo) {\n        this.nonceInfo = nonceInfo;\n      }\n      this.recentBlockhash = recentBlockhash;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  toJSON() {\n    return {\n      recentBlockhash: this.recentBlockhash || null,\n      feePayer: this.feePayer ? this.feePayer.toJSON() : null,\n      nonceInfo: this.nonceInfo ? {\n        nonce: this.nonceInfo.nonce,\n        nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()\n      } : null,\n      instructions: this.instructions.map(instruction => instruction.toJSON()),\n      signers: this.signatures.map(({\n        publicKey\n      }) => {\n        return publicKey.toJSON();\n      })\n    };\n  }\n\n  /**\n   * Add one or more instructions to this Transaction\n   *\n   * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction\n   */\n  add(...items) {\n    if (items.length === 0) {\n      throw new Error('No instructions');\n    }\n    items.forEach(item => {\n      if ('instructions' in item) {\n        this.instructions = this.instructions.concat(item.instructions);\n      } else if ('data' in item && 'programId' in item && 'keys' in item) {\n        this.instructions.push(item);\n      } else {\n        this.instructions.push(new TransactionInstruction(item));\n      }\n    });\n    return this;\n  }\n\n  /**\n   * Compile transaction data\n   */\n  compileMessage() {\n    if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {\n      return this._message;\n    }\n    let recentBlockhash;\n    let instructions;\n    if (this.nonceInfo) {\n      recentBlockhash = this.nonceInfo.nonce;\n      if (this.instructions[0] != this.nonceInfo.nonceInstruction) {\n        instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];\n      } else {\n        instructions = this.instructions;\n      }\n    } else {\n      recentBlockhash = this.recentBlockhash;\n      instructions = this.instructions;\n    }\n    if (!recentBlockhash) {\n      throw new Error('Transaction recentBlockhash required');\n    }\n    if (instructions.length < 1) {\n      console.warn('No instructions provided');\n    }\n    let feePayer;\n    if (this.feePayer) {\n      feePayer = this.feePayer;\n    } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {\n      // Use implicit fee payer\n      feePayer = this.signatures[0].publicKey;\n    } else {\n      throw new Error('Transaction fee payer required');\n    }\n    for (let i = 0; i < instructions.length; i++) {\n      if (instructions[i].programId === undefined) {\n        throw new Error(`Transaction instruction index ${i} has undefined program id`);\n      }\n    }\n    const programIds = [];\n    const accountMetas = [];\n    instructions.forEach(instruction => {\n      instruction.keys.forEach(accountMeta => {\n        accountMetas.push({\n          ...accountMeta\n        });\n      });\n      const programId = instruction.programId.toString();\n      if (!programIds.includes(programId)) {\n        programIds.push(programId);\n      }\n    });\n\n    // Append programID account metas\n    programIds.forEach(programId => {\n      accountMetas.push({\n        pubkey: new PublicKey(programId),\n        isSigner: false,\n        isWritable: false\n      });\n    });\n\n    // Cull duplicate account metas\n    const uniqueMetas = [];\n    accountMetas.forEach(accountMeta => {\n      const pubkeyString = accountMeta.pubkey.toString();\n      const uniqueIndex = uniqueMetas.findIndex(x => {\n        return x.pubkey.toString() === pubkeyString;\n      });\n      if (uniqueIndex > -1) {\n        uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;\n        uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;\n      } else {\n        uniqueMetas.push(accountMeta);\n      }\n    });\n\n    // Sort. Prioritizing first by signer, then by writable\n    uniqueMetas.sort(function (x, y) {\n      if (x.isSigner !== y.isSigner) {\n        // Signers always come before non-signers\n        return x.isSigner ? -1 : 1;\n      }\n      if (x.isWritable !== y.isWritable) {\n        // Writable accounts always come before read-only accounts\n        return x.isWritable ? -1 : 1;\n      }\n      // Otherwise, sort by pubkey, stringwise.\n      const options = {\n        localeMatcher: 'best fit',\n        usage: 'sort',\n        sensitivity: 'variant',\n        ignorePunctuation: false,\n        numeric: false,\n        caseFirst: 'lower'\n      };\n      return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), 'en', options);\n    });\n\n    // Move fee payer to the front\n    const feePayerIndex = uniqueMetas.findIndex(x => {\n      return x.pubkey.equals(feePayer);\n    });\n    if (feePayerIndex > -1) {\n      const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);\n      payerMeta.isSigner = true;\n      payerMeta.isWritable = true;\n      uniqueMetas.unshift(payerMeta);\n    } else {\n      uniqueMetas.unshift({\n        pubkey: feePayer,\n        isSigner: true,\n        isWritable: true\n      });\n    }\n\n    // Disallow unknown signers\n    for (const signature of this.signatures) {\n      const uniqueIndex = uniqueMetas.findIndex(x => {\n        return x.pubkey.equals(signature.publicKey);\n      });\n      if (uniqueIndex > -1) {\n        if (!uniqueMetas[uniqueIndex].isSigner) {\n          uniqueMetas[uniqueIndex].isSigner = true;\n          console.warn('Transaction references a signature that is unnecessary, ' + 'only the fee payer and instruction signer accounts should sign a transaction. ' + 'This behavior is deprecated and will throw an error in the next major version release.');\n        }\n      } else {\n        throw new Error(`unknown signer: ${signature.publicKey.toString()}`);\n      }\n    }\n    let numRequiredSignatures = 0;\n    let numReadonlySignedAccounts = 0;\n    let numReadonlyUnsignedAccounts = 0;\n\n    // Split out signing from non-signing keys and count header values\n    const signedKeys = [];\n    const unsignedKeys = [];\n    uniqueMetas.forEach(({\n      pubkey,\n      isSigner,\n      isWritable\n    }) => {\n      if (isSigner) {\n        signedKeys.push(pubkey.toString());\n        numRequiredSignatures += 1;\n        if (!isWritable) {\n          numReadonlySignedAccounts += 1;\n        }\n      } else {\n        unsignedKeys.push(pubkey.toString());\n        if (!isWritable) {\n          numReadonlyUnsignedAccounts += 1;\n        }\n      }\n    });\n    const accountKeys = signedKeys.concat(unsignedKeys);\n    const compiledInstructions = instructions.map(instruction => {\n      const {\n        data,\n        programId\n      } = instruction;\n      return {\n        programIdIndex: accountKeys.indexOf(programId.toString()),\n        accounts: instruction.keys.map(meta => accountKeys.indexOf(meta.pubkey.toString())),\n        data: bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(data)\n      };\n    });\n    compiledInstructions.forEach(instruction => {\n      assert(instruction.programIdIndex >= 0);\n      instruction.accounts.forEach(keyIndex => assert(keyIndex >= 0));\n    });\n    return new Message({\n      header: {\n        numRequiredSignatures,\n        numReadonlySignedAccounts,\n        numReadonlyUnsignedAccounts\n      },\n      accountKeys,\n      recentBlockhash,\n      instructions: compiledInstructions\n    });\n  }\n\n  /**\n   * @internal\n   */\n  _compile() {\n    const message = this.compileMessage();\n    const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);\n    if (this.signatures.length === signedKeys.length) {\n      const valid = this.signatures.every((pair, index) => {\n        return signedKeys[index].equals(pair.publicKey);\n      });\n      if (valid) return message;\n    }\n    this.signatures = signedKeys.map(publicKey => ({\n      signature: null,\n      publicKey\n    }));\n    return message;\n  }\n\n  /**\n   * Get a buffer of the Transaction data that need to be covered by signatures\n   */\n  serializeMessage() {\n    return this._compile().serialize();\n  }\n\n  /**\n   * Get the estimated fee associated with a transaction\n   *\n   * @param {Connection} connection Connection to RPC Endpoint.\n   *\n   * @returns {Promise<number | null>} The estimated fee for the transaction\n   */\n  async getEstimatedFee(connection) {\n    return (await connection.getFeeForMessage(this.compileMessage())).value;\n  }\n\n  /**\n   * Specify the public keys which will be used to sign the Transaction.\n   * The first signer will be used as the transaction fee payer account.\n   *\n   * Signatures can be added with either `partialSign` or `addSignature`\n   *\n   * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be\n   * specified and it can be set in the Transaction constructor or with the\n   * `feePayer` property.\n   */\n  setSigners(...signers) {\n    if (signers.length === 0) {\n      throw new Error('No signers');\n    }\n    const seen = new Set();\n    this.signatures = signers.filter(publicKey => {\n      const key = publicKey.toString();\n      if (seen.has(key)) {\n        return false;\n      } else {\n        seen.add(key);\n        return true;\n      }\n    }).map(publicKey => ({\n      signature: null,\n      publicKey\n    }));\n  }\n\n  /**\n   * Sign the Transaction with the specified signers. Multiple signatures may\n   * be applied to a Transaction. The first signature is considered \"primary\"\n   * and is used identify and confirm transactions.\n   *\n   * If the Transaction `feePayer` is not set, the first signer will be used\n   * as the transaction fee payer account.\n   *\n   * Transaction fields should not be modified after the first call to `sign`,\n   * as doing so may invalidate the signature and cause the Transaction to be\n   * rejected.\n   *\n   * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */\n  sign(...signers) {\n    if (signers.length === 0) {\n      throw new Error('No signers');\n    }\n\n    // Dedupe signers\n    const seen = new Set();\n    const uniqueSigners = [];\n    for (const signer of signers) {\n      const key = signer.publicKey.toString();\n      if (seen.has(key)) {\n        continue;\n      } else {\n        seen.add(key);\n        uniqueSigners.push(signer);\n      }\n    }\n    this.signatures = uniqueSigners.map(signer => ({\n      signature: null,\n      publicKey: signer.publicKey\n    }));\n    const message = this._compile();\n    this._partialSign(message, ...uniqueSigners);\n  }\n\n  /**\n   * Partially sign a transaction with the specified accounts. All accounts must\n   * correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * All the caveats from the `sign` method apply to `partialSign`\n   *\n   * @param {Array<Signer>} signers Array of signers that will sign the transaction\n   */\n  partialSign(...signers) {\n    if (signers.length === 0) {\n      throw new Error('No signers');\n    }\n\n    // Dedupe signers\n    const seen = new Set();\n    const uniqueSigners = [];\n    for (const signer of signers) {\n      const key = signer.publicKey.toString();\n      if (seen.has(key)) {\n        continue;\n      } else {\n        seen.add(key);\n        uniqueSigners.push(signer);\n      }\n    }\n    const message = this._compile();\n    this._partialSign(message, ...uniqueSigners);\n  }\n\n  /**\n   * @internal\n   */\n  _partialSign(message, ...signers) {\n    const signData = message.serialize();\n    signers.forEach(signer => {\n      const signature = sign(signData, signer.secretKey);\n      this._addSignature(signer.publicKey, toBuffer(signature));\n    });\n  }\n\n  /**\n   * Add an externally created signature to a transaction. The public key\n   * must correspond to either the fee payer or a signer account in the transaction\n   * instructions.\n   *\n   * @param {PublicKey} pubkey Public key that will be added to the transaction.\n   * @param {Buffer} signature An externally created signature to add to the transaction.\n   */\n  addSignature(pubkey, signature) {\n    this._compile(); // Ensure signatures array is populated\n    this._addSignature(pubkey, signature);\n  }\n\n  /**\n   * @internal\n   */\n  _addSignature(pubkey, signature) {\n    assert(signature.length === 64);\n    const index = this.signatures.findIndex(sigpair => pubkey.equals(sigpair.publicKey));\n    if (index < 0) {\n      throw new Error(`unknown signer: ${pubkey.toString()}`);\n    }\n    this.signatures[index].signature = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature);\n  }\n\n  /**\n   * Verify signatures of a Transaction\n   * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.\n   * If no boolean is provided, we expect a fully signed Transaction by default.\n   *\n   * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction\n   */\n  verifySignatures(requireAllSignatures = true) {\n    const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);\n    return !signatureErrors;\n  }\n\n  /**\n   * @internal\n   */\n  _getMessageSignednessErrors(message, requireAllSignatures) {\n    const errors = {};\n    for (const {\n      signature,\n      publicKey\n    } of this.signatures) {\n      if (signature === null) {\n        if (requireAllSignatures) {\n          (errors.missing ||= []).push(publicKey);\n        }\n      } else {\n        if (!verify(signature, message, publicKey.toBytes())) {\n          (errors.invalid ||= []).push(publicKey);\n        }\n      }\n    }\n    return errors.invalid || errors.missing ? errors : undefined;\n  }\n\n  /**\n   * Serialize the Transaction in the wire format.\n   *\n   * @param {Buffer} [config] Config of transaction.\n   *\n   * @returns {Buffer} Signature of transaction in wire format.\n   */\n  serialize(config) {\n    const {\n      requireAllSignatures,\n      verifySignatures\n    } = Object.assign({\n      requireAllSignatures: true,\n      verifySignatures: true\n    }, config);\n    const signData = this.serializeMessage();\n    if (verifySignatures) {\n      const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);\n      if (sigErrors) {\n        let errorMessage = 'Signature verification failed.';\n        if (sigErrors.invalid) {\n          errorMessage += `\\nInvalid signature for public key${sigErrors.invalid.length === 1 ? '' : '(s)'} [\\`${sigErrors.invalid.map(p => p.toBase58()).join('`, `')}\\`].`;\n        }\n        if (sigErrors.missing) {\n          errorMessage += `\\nMissing signature for public key${sigErrors.missing.length === 1 ? '' : '(s)'} [\\`${sigErrors.missing.map(p => p.toBase58()).join('`, `')}\\`].`;\n        }\n        throw new Error(errorMessage);\n      }\n    }\n    return this._serialize(signData);\n  }\n\n  /**\n   * @internal\n   */\n  _serialize(signData) {\n    const {\n      signatures\n    } = this;\n    const signatureCount = [];\n    encodeLength(signatureCount, signatures.length);\n    const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;\n    const wireTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(transactionLength);\n    assert(signatures.length < 256);\n    buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signatureCount).copy(wireTransaction, 0);\n    signatures.forEach(({\n      signature\n    }, index) => {\n      if (signature !== null) {\n        assert(signature.length === 64, `signature has invalid length`);\n        buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature).copy(wireTransaction, signatureCount.length + index * 64);\n      }\n    });\n    signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);\n    assert(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);\n    return wireTransaction;\n  }\n\n  /**\n   * Deprecated method\n   * @internal\n   */\n  get keys() {\n    assert(this.instructions.length === 1);\n    return this.instructions[0].keys.map(keyObj => keyObj.pubkey);\n  }\n\n  /**\n   * Deprecated method\n   * @internal\n   */\n  get programId() {\n    assert(this.instructions.length === 1);\n    return this.instructions[0].programId;\n  }\n\n  /**\n   * Deprecated method\n   * @internal\n   */\n  get data() {\n    assert(this.instructions.length === 1);\n    return this.instructions[0].data;\n  }\n\n  /**\n   * Parse a wire transaction into a Transaction object.\n   *\n   * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction\n   *\n   * @returns {Transaction} Transaction associated with the signature\n   */\n  static from(buffer) {\n    // Slice up wire data\n    let byteArray = [...buffer];\n    const signatureCount = decodeLength(byteArray);\n    let signatures = [];\n    for (let i = 0; i < signatureCount; i++) {\n      const signature = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);\n      signatures.push(bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(signature)));\n    }\n    return Transaction.populate(Message.from(byteArray), signatures);\n  }\n\n  /**\n   * Populate Transaction object from message and signatures\n   *\n   * @param {Message} message Message of transaction\n   * @param {Array<string>} signatures List of signatures to assign to the transaction\n   *\n   * @returns {Transaction} The populated Transaction\n   */\n  static populate(message, signatures = []) {\n    const transaction = new Transaction();\n    transaction.recentBlockhash = message.recentBlockhash;\n    if (message.header.numRequiredSignatures > 0) {\n      transaction.feePayer = message.accountKeys[0];\n    }\n    signatures.forEach((signature, index) => {\n      const sigPubkeyPair = {\n        signature: signature == bs58__WEBPACK_IMPORTED_MODULE_2___default().encode(DEFAULT_SIGNATURE) ? null : bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(signature),\n        publicKey: message.accountKeys[index]\n      };\n      transaction.signatures.push(sigPubkeyPair);\n    });\n    message.instructions.forEach(instruction => {\n      const keys = instruction.accounts.map(account => {\n        const pubkey = message.accountKeys[account];\n        return {\n          pubkey,\n          isSigner: transaction.signatures.some(keyObj => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),\n          isWritable: message.isAccountWritable(account)\n        };\n      });\n      transaction.instructions.push(new TransactionInstruction({\n        keys,\n        programId: message.accountKeys[instruction.programIdIndex],\n        data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(instruction.data)\n      }));\n    });\n    transaction._message = message;\n    transaction._json = transaction.toJSON();\n    return transaction;\n  }\n}\n\nclass TransactionMessage {\n  constructor(args) {\n    this.payerKey = void 0;\n    this.instructions = void 0;\n    this.recentBlockhash = void 0;\n    this.payerKey = args.payerKey;\n    this.instructions = args.instructions;\n    this.recentBlockhash = args.recentBlockhash;\n  }\n  static decompile(message, args) {\n    const {\n      header,\n      compiledInstructions,\n      recentBlockhash\n    } = message;\n    const {\n      numRequiredSignatures,\n      numReadonlySignedAccounts,\n      numReadonlyUnsignedAccounts\n    } = header;\n    const numWritableSignedAccounts = numRequiredSignatures - numReadonlySignedAccounts;\n    assert(numWritableSignedAccounts > 0, 'Message header is invalid');\n    const numWritableUnsignedAccounts = message.staticAccountKeys.length - numRequiredSignatures - numReadonlyUnsignedAccounts;\n    assert(numWritableUnsignedAccounts >= 0, 'Message header is invalid');\n    const accountKeys = message.getAccountKeys(args);\n    const payerKey = accountKeys.get(0);\n    if (payerKey === undefined) {\n      throw new Error('Failed to decompile message because no account keys were found');\n    }\n    const instructions = [];\n    for (const compiledIx of compiledInstructions) {\n      const keys = [];\n      for (const keyIndex of compiledIx.accountKeyIndexes) {\n        const pubkey = accountKeys.get(keyIndex);\n        if (pubkey === undefined) {\n          throw new Error(`Failed to find key for account key index ${keyIndex}`);\n        }\n        const isSigner = keyIndex < numRequiredSignatures;\n        let isWritable;\n        if (isSigner) {\n          isWritable = keyIndex < numWritableSignedAccounts;\n        } else if (keyIndex < accountKeys.staticAccountKeys.length) {\n          isWritable = keyIndex - numRequiredSignatures < numWritableUnsignedAccounts;\n        } else {\n          isWritable = keyIndex - accountKeys.staticAccountKeys.length <\n          // accountKeysFromLookups cannot be undefined because we already found a pubkey for this index above\n          accountKeys.accountKeysFromLookups.writable.length;\n        }\n        keys.push({\n          pubkey,\n          isSigner: keyIndex < header.numRequiredSignatures,\n          isWritable\n        });\n      }\n      const programId = accountKeys.get(compiledIx.programIdIndex);\n      if (programId === undefined) {\n        throw new Error(`Failed to find program id for program id index ${compiledIx.programIdIndex}`);\n      }\n      instructions.push(new TransactionInstruction({\n        programId,\n        data: toBuffer(compiledIx.data),\n        keys\n      }));\n    }\n    return new TransactionMessage({\n      payerKey,\n      instructions,\n      recentBlockhash\n    });\n  }\n  compileToLegacyMessage() {\n    return Message.compile({\n      payerKey: this.payerKey,\n      recentBlockhash: this.recentBlockhash,\n      instructions: this.instructions\n    });\n  }\n  compileToV0Message(addressLookupTableAccounts) {\n    return MessageV0.compile({\n      payerKey: this.payerKey,\n      recentBlockhash: this.recentBlockhash,\n      instructions: this.instructions,\n      addressLookupTableAccounts\n    });\n  }\n}\n\n/**\n * Versioned transaction class\n */\nclass VersionedTransaction {\n  get version() {\n    return this.message.version;\n  }\n  constructor(message, signatures) {\n    this.signatures = void 0;\n    this.message = void 0;\n    if (signatures !== undefined) {\n      assert(signatures.length === message.header.numRequiredSignatures, 'Expected signatures length to be equal to the number of required signatures');\n      this.signatures = signatures;\n    } else {\n      const defaultSignatures = [];\n      for (let i = 0; i < message.header.numRequiredSignatures; i++) {\n        defaultSignatures.push(new Uint8Array(SIGNATURE_LENGTH_IN_BYTES));\n      }\n      this.signatures = defaultSignatures;\n    }\n    this.message = message;\n  }\n  serialize() {\n    const serializedMessage = this.message.serialize();\n    const encodedSignaturesLength = Array();\n    encodeLength(encodedSignaturesLength, this.signatures.length);\n    const transactionLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(encodedSignaturesLength.length, 'encodedSignaturesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(signature(), this.signatures.length, 'signatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(serializedMessage.length, 'serializedMessage')]);\n    const serializedTransaction = new Uint8Array(2048);\n    const serializedTransactionLength = transactionLayout.encode({\n      encodedSignaturesLength: new Uint8Array(encodedSignaturesLength),\n      signatures: this.signatures,\n      serializedMessage\n    }, serializedTransaction);\n    return serializedTransaction.slice(0, serializedTransactionLength);\n  }\n  static deserialize(serializedTransaction) {\n    let byteArray = [...serializedTransaction];\n    const signatures = [];\n    const signaturesLength = decodeLength(byteArray);\n    for (let i = 0; i < signaturesLength; i++) {\n      signatures.push(new Uint8Array(guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES)));\n    }\n    const message = VersionedMessage.deserialize(new Uint8Array(byteArray));\n    return new VersionedTransaction(message, signatures);\n  }\n  sign(signers) {\n    const messageData = this.message.serialize();\n    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n    for (const signer of signers) {\n      const signerIndex = signerPubkeys.findIndex(pubkey => pubkey.equals(signer.publicKey));\n      assert(signerIndex >= 0, `Cannot sign with non signer key ${signer.publicKey.toBase58()}`);\n      this.signatures[signerIndex] = sign(messageData, signer.secretKey);\n    }\n  }\n  addSignature(publicKey, signature) {\n    assert(signature.byteLength === 64, 'Signature must be 64 bytes long');\n    const signerPubkeys = this.message.staticAccountKeys.slice(0, this.message.header.numRequiredSignatures);\n    const signerIndex = signerPubkeys.findIndex(pubkey => pubkey.equals(publicKey));\n    assert(signerIndex >= 0, `Can not add signature; \\`${publicKey.toBase58()}\\` is not required to sign this transaction`);\n    this.signatures[signerIndex] = signature;\n  }\n}\n\n// TODO: These constants should be removed in favor of reading them out of a\n// Syscall account\n\n/**\n * @internal\n */\nconst NUM_TICKS_PER_SECOND = 160;\n\n/**\n * @internal\n */\nconst DEFAULT_TICKS_PER_SLOT = 64;\n\n/**\n * @internal\n */\nconst NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;\n\n/**\n * @internal\n */\nconst MS_PER_SLOT = 1000 / NUM_SLOTS_PER_SECOND;\n\nconst SYSVAR_CLOCK_PUBKEY = new PublicKey('SysvarC1ock11111111111111111111111111111111');\nconst SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey('SysvarEpochSchedu1e111111111111111111111111');\nconst SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey('Sysvar1nstructions1111111111111111111111111');\nconst SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey('SysvarRecentB1ockHashes11111111111111111111');\nconst SYSVAR_RENT_PUBKEY = new PublicKey('SysvarRent111111111111111111111111111111111');\nconst SYSVAR_REWARDS_PUBKEY = new PublicKey('SysvarRewards111111111111111111111111111111');\nconst SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey('SysvarS1otHashes111111111111111111111111111');\nconst SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey('SysvarS1otHistory11111111111111111111111111');\nconst SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey('SysvarStakeHistory1111111111111111111111111');\n\n/**\n * Sign, send and confirm a transaction.\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Transaction} transaction\n * @param {Array<Signer>} signers\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */\nasync function sendAndConfirmTransaction(connection, transaction, signers, options) {\n  const sendOptions = options && {\n    skipPreflight: options.skipPreflight,\n    preflightCommitment: options.preflightCommitment || options.commitment,\n    maxRetries: options.maxRetries,\n    minContextSlot: options.minContextSlot\n  };\n  const signature = await connection.sendTransaction(transaction, signers, sendOptions);\n  let status;\n  if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {\n    status = (await connection.confirmTransaction({\n      abortSignal: options?.abortSignal,\n      signature: signature,\n      blockhash: transaction.recentBlockhash,\n      lastValidBlockHeight: transaction.lastValidBlockHeight\n    }, options && options.commitment)).value;\n  } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {\n    const {\n      nonceInstruction\n    } = transaction.nonceInfo;\n    const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;\n    status = (await connection.confirmTransaction({\n      abortSignal: options?.abortSignal,\n      minContextSlot: transaction.minNonceContextSlot,\n      nonceAccountPubkey,\n      nonceValue: transaction.nonceInfo.nonce,\n      signature\n    }, options && options.commitment)).value;\n  } else {\n    if (options?.abortSignal != null) {\n      console.warn('sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was ' + 'supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` ' + 'or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.');\n    }\n    status = (await connection.confirmTransaction(signature, options && options.commitment)).value;\n  }\n  if (status.err) {\n    throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);\n  }\n  return signature;\n}\n\n// zzz\nfunction sleep(ms) {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * @internal\n */\n\n/**\n * Populate a buffer of instruction data using an InstructionType\n * @internal\n */\nfunction encodeData(type, fields) {\n  const allocLength = type.layout.span >= 0 ? type.layout.span : getAlloc(type, fields);\n  const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(allocLength);\n  const layoutFields = Object.assign({\n    instruction: type.index\n  }, fields);\n  type.layout.encode(layoutFields, data);\n  return data;\n}\n\n/**\n * Decode instruction data buffer using an InstructionType\n * @internal\n */\nfunction decodeData$1(type, buffer) {\n  let data;\n  try {\n    data = type.layout.decode(buffer);\n  } catch (err) {\n    throw new Error('invalid instruction; ' + err);\n  }\n  if (data.instruction !== type.index) {\n    throw new Error(`invalid instruction; instruction index mismatch ${data.instruction} != ${type.index}`);\n  }\n  return data;\n}\n\n/**\n * https://github.com/solana-labs/solana/blob/90bedd7e067b5b8f3ddbb45da00a4e9cabb22c62/sdk/src/fee_calculator.rs#L7-L11\n *\n * @internal\n */\nconst FeeCalculatorLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64('lamportsPerSignature');\n\n/**\n * Calculator for transaction fees.\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */\n\n/**\n * See https://github.com/solana-labs/solana/blob/0ea2843ec9cdc517572b8e62c959f41b55cf4453/sdk/src/nonce_state.rs#L29-L32\n *\n * @internal\n */\nconst NonceAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('version'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('state'), publicKey('authorizedPubkey'), publicKey('nonce'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([FeeCalculatorLayout], 'feeCalculator')]);\nconst NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;\n\n/**\n * A durable nonce is a 32 byte value encoded as a base58 string.\n */\n\n/**\n * NonceAccount class\n */\nclass NonceAccount {\n  /**\n   * @internal\n   */\n  constructor(args) {\n    this.authorizedPubkey = void 0;\n    this.nonce = void 0;\n    this.feeCalculator = void 0;\n    this.authorizedPubkey = args.authorizedPubkey;\n    this.nonce = args.nonce;\n    this.feeCalculator = args.feeCalculator;\n  }\n\n  /**\n   * Deserialize NonceAccount from the account data.\n   *\n   * @param buffer account data\n   * @return NonceAccount\n   */\n  static fromAccountData(buffer) {\n    const nonceAccount = NonceAccountLayout.decode(toBuffer(buffer), 0);\n    return new NonceAccount({\n      authorizedPubkey: new PublicKey(nonceAccount.authorizedPubkey),\n      nonce: new PublicKey(nonceAccount.nonce).toString(),\n      feeCalculator: nonceAccount.feeCalculator\n    });\n  }\n}\n\nconst encodeDecode = layout => {\n  const decode = layout.decode.bind(layout);\n  const encode = layout.encode.bind(layout);\n  return {\n    decode,\n    encode\n  };\n};\nconst bigInt = length => property => {\n  const layout = (0,_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob)(length, property);\n  const {\n    encode,\n    decode\n  } = encodeDecode(layout);\n  const bigIntLayout = layout;\n  bigIntLayout.decode = (buffer, offset) => {\n    const src = decode(buffer, offset);\n    return (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_5__.toBigIntLE)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(src));\n  };\n  bigIntLayout.encode = (bigInt, buffer, offset) => {\n    const src = (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_5__.toBufferLE)(bigInt, length);\n    return encode(src, buffer, offset);\n  };\n  return bigIntLayout;\n};\nconst u64 = bigInt(8);\n\n/**\n * Create account system transaction params\n */\n\n/**\n * Transfer system transaction params\n */\n\n/**\n * Assign system transaction params\n */\n\n/**\n * Create account with seed system transaction params\n */\n\n/**\n * Create nonce account system transaction params\n */\n\n/**\n * Create nonce account with seed system transaction params\n */\n\n/**\n * Initialize nonce account system instruction params\n */\n\n/**\n * Advance nonce account system instruction params\n */\n\n/**\n * Withdraw nonce account system transaction params\n */\n\n/**\n * Authorize nonce account system transaction params\n */\n\n/**\n * Allocate account system transaction params\n */\n\n/**\n * Allocate account with seed system transaction params\n */\n\n/**\n * Assign account with seed system transaction params\n */\n\n/**\n * Transfer with seed system transaction params\n */\n\n/** Decoded transfer system transaction instruction */\n\n/** Decoded transferWithSeed system transaction instruction */\n\n/**\n * System Instruction class\n */\nclass SystemInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Decode a system instruction and retrieve the instruction type.\n   */\n  static decodeInstructionType(instruction) {\n    this.checkProgramId(instruction.programId);\n    const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction');\n    const typeIndex = instructionTypeLayout.decode(instruction.data);\n    let type;\n    for (const [ixType, layout] of Object.entries(SYSTEM_INSTRUCTION_LAYOUTS)) {\n      if (layout.index == typeIndex) {\n        type = ixType;\n        break;\n      }\n    }\n    if (!type) {\n      throw new Error('Instruction type incorrect; not a SystemInstruction');\n    }\n    return type;\n  }\n\n  /**\n   * Decode a create account system instruction and retrieve the instruction params.\n   */\n  static decodeCreateAccount(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 2);\n    const {\n      lamports,\n      space,\n      programId\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Create, instruction.data);\n    return {\n      fromPubkey: instruction.keys[0].pubkey,\n      newAccountPubkey: instruction.keys[1].pubkey,\n      lamports,\n      space,\n      programId: new PublicKey(programId)\n    };\n  }\n\n  /**\n   * Decode a transfer system instruction and retrieve the instruction params.\n   */\n  static decodeTransfer(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 2);\n    const {\n      lamports\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Transfer, instruction.data);\n    return {\n      fromPubkey: instruction.keys[0].pubkey,\n      toPubkey: instruction.keys[1].pubkey,\n      lamports\n    };\n  }\n\n  /**\n   * Decode a transfer with seed system instruction and retrieve the instruction params.\n   */\n  static decodeTransferWithSeed(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    const {\n      lamports,\n      seed,\n      programId\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed, instruction.data);\n    return {\n      fromPubkey: instruction.keys[0].pubkey,\n      basePubkey: instruction.keys[1].pubkey,\n      toPubkey: instruction.keys[2].pubkey,\n      lamports,\n      seed,\n      programId: new PublicKey(programId)\n    };\n  }\n\n  /**\n   * Decode an allocate system instruction and retrieve the instruction params.\n   */\n  static decodeAllocate(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 1);\n    const {\n      space\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Allocate, instruction.data);\n    return {\n      accountPubkey: instruction.keys[0].pubkey,\n      space\n    };\n  }\n\n  /**\n   * Decode an allocate with seed system instruction and retrieve the instruction params.\n   */\n  static decodeAllocateWithSeed(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 1);\n    const {\n      base,\n      seed,\n      space,\n      programId\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed, instruction.data);\n    return {\n      accountPubkey: instruction.keys[0].pubkey,\n      basePubkey: new PublicKey(base),\n      seed,\n      space,\n      programId: new PublicKey(programId)\n    };\n  }\n\n  /**\n   * Decode an assign system instruction and retrieve the instruction params.\n   */\n  static decodeAssign(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 1);\n    const {\n      programId\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.Assign, instruction.data);\n    return {\n      accountPubkey: instruction.keys[0].pubkey,\n      programId: new PublicKey(programId)\n    };\n  }\n\n  /**\n   * Decode an assign with seed system instruction and retrieve the instruction params.\n   */\n  static decodeAssignWithSeed(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 1);\n    const {\n      base,\n      seed,\n      programId\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed, instruction.data);\n    return {\n      accountPubkey: instruction.keys[0].pubkey,\n      basePubkey: new PublicKey(base),\n      seed,\n      programId: new PublicKey(programId)\n    };\n  }\n\n  /**\n   * Decode a create account with seed system instruction and retrieve the instruction params.\n   */\n  static decodeCreateWithSeed(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 2);\n    const {\n      base,\n      seed,\n      lamports,\n      space,\n      programId\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed, instruction.data);\n    return {\n      fromPubkey: instruction.keys[0].pubkey,\n      newAccountPubkey: instruction.keys[1].pubkey,\n      basePubkey: new PublicKey(base),\n      seed,\n      lamports,\n      space,\n      programId: new PublicKey(programId)\n    };\n  }\n\n  /**\n   * Decode a nonce initialize system instruction and retrieve the instruction params.\n   */\n  static decodeNonceInitialize(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    const {\n      authorized\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount, instruction.data);\n    return {\n      noncePubkey: instruction.keys[0].pubkey,\n      authorizedPubkey: new PublicKey(authorized)\n    };\n  }\n\n  /**\n   * Decode a nonce advance system instruction and retrieve the instruction params.\n   */\n  static decodeNonceAdvance(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount, instruction.data);\n    return {\n      noncePubkey: instruction.keys[0].pubkey,\n      authorizedPubkey: instruction.keys[2].pubkey\n    };\n  }\n\n  /**\n   * Decode a nonce withdraw system instruction and retrieve the instruction params.\n   */\n  static decodeNonceWithdraw(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 5);\n    const {\n      lamports\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount, instruction.data);\n    return {\n      noncePubkey: instruction.keys[0].pubkey,\n      toPubkey: instruction.keys[1].pubkey,\n      authorizedPubkey: instruction.keys[4].pubkey,\n      lamports\n    };\n  }\n\n  /**\n   * Decode a nonce authorize system instruction and retrieve the instruction params.\n   */\n  static decodeNonceAuthorize(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 2);\n    const {\n      authorized\n    } = decodeData$1(SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount, instruction.data);\n    return {\n      noncePubkey: instruction.keys[0].pubkey,\n      authorizedPubkey: instruction.keys[1].pubkey,\n      newAuthorizedPubkey: new PublicKey(authorized)\n    };\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId) {\n    if (!programId.equals(SystemProgram.programId)) {\n      throw new Error('invalid instruction; programId is not SystemProgram');\n    }\n  }\n\n  /**\n   * @internal\n   */\n  static checkKeyLength(keys, expectedLength) {\n    if (keys.length < expectedLength) {\n      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n    }\n  }\n}\n\n/**\n * An enumeration of valid SystemInstructionType's\n */\n\n/**\n * An enumeration of valid system InstructionType's\n * @internal\n */\nconst SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({\n  Create: {\n    index: 0,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64('lamports'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64('space'), publicKey('programId')])\n  },\n  Assign: {\n    index: 1,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), publicKey('programId')])\n  },\n  Transfer: {\n    index: 2,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), u64('lamports')])\n  },\n  CreateWithSeed: {\n    index: 3,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), publicKey('base'), rustString('seed'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64('lamports'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64('space'), publicKey('programId')])\n  },\n  AdvanceNonceAccount: {\n    index: 4,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction')])\n  },\n  WithdrawNonceAccount: {\n    index: 5,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64('lamports')])\n  },\n  InitializeNonceAccount: {\n    index: 6,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), publicKey('authorized')])\n  },\n  AuthorizeNonceAccount: {\n    index: 7,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), publicKey('authorized')])\n  },\n  Allocate: {\n    index: 8,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64('space')])\n  },\n  AllocateWithSeed: {\n    index: 9,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), publicKey('base'), rustString('seed'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64('space'), publicKey('programId')])\n  },\n  AssignWithSeed: {\n    index: 10,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), publicKey('base'), rustString('seed'), publicKey('programId')])\n  },\n  TransferWithSeed: {\n    index: 11,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), u64('lamports'), rustString('seed'), publicKey('programId')])\n  },\n  UpgradeNonceAccount: {\n    index: 12,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction')])\n  }\n});\n\n/**\n * Factory class for transactions to interact with the System program\n */\nclass SystemProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the System program\n   */\n\n  /**\n   * Generate a transaction instruction that creates a new account\n   */\n  static createAccount(params) {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.Create;\n    const data = encodeData(type, {\n      lamports: params.lamports,\n      space: params.space,\n      programId: toBuffer(params.programId.toBuffer())\n    });\n    return new TransactionInstruction({\n      keys: [{\n        pubkey: params.fromPubkey,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: params.newAccountPubkey,\n        isSigner: true,\n        isWritable: true\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that transfers lamports from one account to another\n   */\n  static transfer(params) {\n    let data;\n    let keys;\n    if ('basePubkey' in params) {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;\n      data = encodeData(type, {\n        lamports: BigInt(params.lamports),\n        seed: params.seed,\n        programId: toBuffer(params.programId.toBuffer())\n      });\n      keys = [{\n        pubkey: params.fromPubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.basePubkey,\n        isSigner: true,\n        isWritable: false\n      }, {\n        pubkey: params.toPubkey,\n        isSigner: false,\n        isWritable: true\n      }];\n    } else {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;\n      data = encodeData(type, {\n        lamports: BigInt(params.lamports)\n      });\n      keys = [{\n        pubkey: params.fromPubkey,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: params.toPubkey,\n        isSigner: false,\n        isWritable: true\n      }];\n    }\n    return new TransactionInstruction({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that assigns an account to a program\n   */\n  static assign(params) {\n    let data;\n    let keys;\n    if ('basePubkey' in params) {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;\n      data = encodeData(type, {\n        base: toBuffer(params.basePubkey.toBuffer()),\n        seed: params.seed,\n        programId: toBuffer(params.programId.toBuffer())\n      });\n      keys = [{\n        pubkey: params.accountPubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.basePubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n    } else {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.Assign;\n      data = encodeData(type, {\n        programId: toBuffer(params.programId.toBuffer())\n      });\n      keys = [{\n        pubkey: params.accountPubkey,\n        isSigner: true,\n        isWritable: true\n      }];\n    }\n    return new TransactionInstruction({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that creates a new account at\n   *   an address generated with `from`, a seed, and programId\n   */\n  static createAccountWithSeed(params) {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;\n    const data = encodeData(type, {\n      base: toBuffer(params.basePubkey.toBuffer()),\n      seed: params.seed,\n      lamports: params.lamports,\n      space: params.space,\n      programId: toBuffer(params.programId.toBuffer())\n    });\n    let keys = [{\n      pubkey: params.fromPubkey,\n      isSigner: true,\n      isWritable: true\n    }, {\n      pubkey: params.newAccountPubkey,\n      isSigner: false,\n      isWritable: true\n    }];\n    if (params.basePubkey != params.fromPubkey) {\n      keys.push({\n        pubkey: params.basePubkey,\n        isSigner: true,\n        isWritable: false\n      });\n    }\n    return new TransactionInstruction({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction that creates a new Nonce account\n   */\n  static createNonceAccount(params) {\n    const transaction = new Transaction();\n    if ('basePubkey' in params && 'seed' in params) {\n      transaction.add(SystemProgram.createAccountWithSeed({\n        fromPubkey: params.fromPubkey,\n        newAccountPubkey: params.noncePubkey,\n        basePubkey: params.basePubkey,\n        seed: params.seed,\n        lamports: params.lamports,\n        space: NONCE_ACCOUNT_LENGTH,\n        programId: this.programId\n      }));\n    } else {\n      transaction.add(SystemProgram.createAccount({\n        fromPubkey: params.fromPubkey,\n        newAccountPubkey: params.noncePubkey,\n        lamports: params.lamports,\n        space: NONCE_ACCOUNT_LENGTH,\n        programId: this.programId\n      }));\n    }\n    const initParams = {\n      noncePubkey: params.noncePubkey,\n      authorizedPubkey: params.authorizedPubkey\n    };\n    transaction.add(this.nonceInitialize(initParams));\n    return transaction;\n  }\n\n  /**\n   * Generate an instruction to initialize a Nonce account\n   */\n  static nonceInitialize(params) {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;\n    const data = encodeData(type, {\n      authorized: toBuffer(params.authorizedPubkey.toBuffer())\n    });\n    const instructionData = {\n      keys: [{\n        pubkey: params.noncePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    };\n    return new TransactionInstruction(instructionData);\n  }\n\n  /**\n   * Generate an instruction to advance the nonce in a Nonce account\n   */\n  static nonceAdvance(params) {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;\n    const data = encodeData(type);\n    const instructionData = {\n      keys: [{\n        pubkey: params.noncePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: params.authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    };\n    return new TransactionInstruction(instructionData);\n  }\n\n  /**\n   * Generate a transaction instruction that withdraws lamports from a Nonce account\n   */\n  static nonceWithdraw(params) {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;\n    const data = encodeData(type, {\n      lamports: params.lamports\n    });\n    return new TransactionInstruction({\n      keys: [{\n        pubkey: params.noncePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.toPubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: params.authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that authorizes a new PublicKey as the authority\n   * on a Nonce account.\n   */\n  static nonceAuthorize(params) {\n    const type = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;\n    const data = encodeData(type, {\n      authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())\n    });\n    return new TransactionInstruction({\n      keys: [{\n        pubkey: params.noncePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction instruction that allocates space in an account without funding\n   */\n  static allocate(params) {\n    let data;\n    let keys;\n    if ('basePubkey' in params) {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;\n      data = encodeData(type, {\n        base: toBuffer(params.basePubkey.toBuffer()),\n        seed: params.seed,\n        space: params.space,\n        programId: toBuffer(params.programId.toBuffer())\n      });\n      keys = [{\n        pubkey: params.accountPubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.basePubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n    } else {\n      const type = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;\n      data = encodeData(type, {\n        space: params.space\n      });\n      keys = [{\n        pubkey: params.accountPubkey,\n        isSigner: true,\n        isWritable: true\n      }];\n    }\n    return new TransactionInstruction({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n}\nSystemProgram.programId = new PublicKey('11111111111111111111111111111111');\n\n// Keep program chunks under PACKET_DATA_SIZE, leaving enough room for the\n// rest of the Transaction fields\n//\n// TODO: replace 300 with a proper constant for the size of the other\n// Transaction fields\nconst CHUNK_SIZE = PACKET_DATA_SIZE - 300;\n\n/**\n * Program loader interface\n */\nclass Loader {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Amount of program data placed in each load Transaction\n   */\n\n  /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */\n  static getMinNumSignatures(dataLength) {\n    return 2 * (\n    // Every transaction requires two signatures (payer + program)\n    Math.ceil(dataLength / Loader.chunkSize) + 1 +\n    // Add one for Create transaction\n    1) // Add one for Finalize transaction\n    ;\n  }\n\n  /**\n   * Loads a generic program\n   *\n   * @param connection The connection to use\n   * @param payer System account that pays to load the program\n   * @param program Account to load the program into\n   * @param programId Public key that identifies the loader\n   * @param data Program octets\n   * @return true if program was loaded successfully, false if program was already loaded\n   */\n  static async load(connection, payer, program, programId, data) {\n    {\n      const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);\n\n      // Fetch program account info to check if it has already been created\n      const programInfo = await connection.getAccountInfo(program.publicKey, 'confirmed');\n      let transaction = null;\n      if (programInfo !== null) {\n        if (programInfo.executable) {\n          console.error('Program load failed, account is already executable');\n          return false;\n        }\n        if (programInfo.data.length !== data.length) {\n          transaction = transaction || new Transaction();\n          transaction.add(SystemProgram.allocate({\n            accountPubkey: program.publicKey,\n            space: data.length\n          }));\n        }\n        if (!programInfo.owner.equals(programId)) {\n          transaction = transaction || new Transaction();\n          transaction.add(SystemProgram.assign({\n            accountPubkey: program.publicKey,\n            programId\n          }));\n        }\n        if (programInfo.lamports < balanceNeeded) {\n          transaction = transaction || new Transaction();\n          transaction.add(SystemProgram.transfer({\n            fromPubkey: payer.publicKey,\n            toPubkey: program.publicKey,\n            lamports: balanceNeeded - programInfo.lamports\n          }));\n        }\n      } else {\n        transaction = new Transaction().add(SystemProgram.createAccount({\n          fromPubkey: payer.publicKey,\n          newAccountPubkey: program.publicKey,\n          lamports: balanceNeeded > 0 ? balanceNeeded : 1,\n          space: data.length,\n          programId\n        }));\n      }\n\n      // If the account is already created correctly, skip this step\n      // and proceed directly to loading instructions\n      if (transaction !== null) {\n        await sendAndConfirmTransaction(connection, transaction, [payer, program], {\n          commitment: 'confirmed'\n        });\n      }\n    }\n    const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('offset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('bytesLength'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('bytesLengthPadding'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('byte'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), 'bytes')]);\n    const chunkSize = Loader.chunkSize;\n    let offset = 0;\n    let array = data;\n    let transactions = [];\n    while (array.length > 0) {\n      const bytes = array.slice(0, chunkSize);\n      const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(chunkSize + 16);\n      dataLayout.encode({\n        instruction: 0,\n        // Load instruction\n        offset,\n        bytes: bytes,\n        bytesLength: 0,\n        bytesLengthPadding: 0\n      }, data);\n      const transaction = new Transaction().add({\n        keys: [{\n          pubkey: program.publicKey,\n          isSigner: true,\n          isWritable: true\n        }],\n        programId,\n        data\n      });\n      transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program], {\n        commitment: 'confirmed'\n      }));\n\n      // Delay between sends in an attempt to reduce rate limit errors\n      if (connection._rpcEndpoint.includes('solana.com')) {\n        const REQUESTS_PER_SECOND = 4;\n        await sleep(1000 / REQUESTS_PER_SECOND);\n      }\n      offset += chunkSize;\n      array = array.slice(chunkSize);\n    }\n    await Promise.all(transactions);\n\n    // Finalize the account loaded with program data for execution\n    {\n      const dataLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction')]);\n      const data = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(dataLayout.span);\n      dataLayout.encode({\n        instruction: 1 // Finalize instruction\n      }, data);\n      const transaction = new Transaction().add({\n        keys: [{\n          pubkey: program.publicKey,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }],\n        programId,\n        data\n      });\n      const deployCommitment = 'processed';\n      const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], {\n        preflightCommitment: deployCommitment\n      });\n      const {\n        context,\n        value\n      } = await connection.confirmTransaction({\n        signature: finalizeSignature,\n        lastValidBlockHeight: transaction.lastValidBlockHeight,\n        blockhash: transaction.recentBlockhash\n      }, deployCommitment);\n      if (value.err) {\n        throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);\n      }\n      // We prevent programs from being usable until the slot after their deployment.\n      // See https://github.com/solana-labs/solana/pull/29654\n      while (true // eslint-disable-line no-constant-condition\n      ) {\n        try {\n          const currentSlot = await connection.getSlot({\n            commitment: deployCommitment\n          });\n          if (currentSlot > context.slot) {\n            break;\n          }\n        } catch {\n          /* empty */\n        }\n        await new Promise(resolve => setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));\n      }\n    }\n\n    // success\n    return true;\n  }\n}\nLoader.chunkSize = CHUNK_SIZE;\n\n/**\n * @deprecated Deprecated since Solana v1.17.20.\n */\nconst BPF_LOADER_PROGRAM_ID = new PublicKey('BPFLoader2111111111111111111111111111111111');\n\n/**\n * Factory class for transactions to interact with a program loader\n *\n * @deprecated Deprecated since Solana v1.17.20.\n */\nclass BpfLoader {\n  /**\n   * Minimum number of signatures required to load a program not including\n   * retries\n   *\n   * Can be used to calculate transaction fees\n   */\n  static getMinNumSignatures(dataLength) {\n    return Loader.getMinNumSignatures(dataLength);\n  }\n\n  /**\n   * Load a SBF program\n   *\n   * @param connection The connection to use\n   * @param payer Account that will pay program loading fees\n   * @param program Account to load the program into\n   * @param elf The entire ELF containing the SBF program\n   * @param loaderProgramId The program id of the BPF loader to use\n   * @return true if program was loaded successfully, false if program was already loaded\n   */\n  static load(connection, payer, program, elf, loaderProgramId) {\n    return Loader.load(connection, payer, program, loaderProgramId, elf);\n  }\n}\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar objToString = Object.prototype.toString;\nvar objKeys = Object.keys || function(obj) {\n\t\tvar keys = [];\n\t\tfor (var name in obj) {\n\t\t\tkeys.push(name);\n\t\t}\n\t\treturn keys;\n\t};\n\nfunction stringify(val, isArrayProp) {\n\tvar i, max, str, keys, key, propVal, toStr;\n\tif (val === true) {\n\t\treturn \"true\";\n\t}\n\tif (val === false) {\n\t\treturn \"false\";\n\t}\n\tswitch (typeof val) {\n\t\tcase \"object\":\n\t\t\tif (val === null) {\n\t\t\t\treturn null;\n\t\t\t} else if (val.toJSON && typeof val.toJSON === \"function\") {\n\t\t\t\treturn stringify(val.toJSON(), isArrayProp);\n\t\t\t} else {\n\t\t\t\ttoStr = objToString.call(val);\n\t\t\t\tif (toStr === \"[object Array]\") {\n\t\t\t\t\tstr = '[';\n\t\t\t\t\tmax = val.length - 1;\n\t\t\t\t\tfor(i = 0; i < max; i++) {\n\t\t\t\t\t\tstr += stringify(val[i], true) + ',';\n\t\t\t\t\t}\n\t\t\t\t\tif (max > -1) {\n\t\t\t\t\t\tstr += stringify(val[i], true);\n\t\t\t\t\t}\n\t\t\t\t\treturn str + ']';\n\t\t\t\t} else if (toStr === \"[object Object]\") {\n\t\t\t\t\t// only object is left\n\t\t\t\t\tkeys = objKeys(val).sort();\n\t\t\t\t\tmax = keys.length;\n\t\t\t\t\tstr = \"\";\n\t\t\t\t\ti = 0;\n\t\t\t\t\twhile (i < max) {\n\t\t\t\t\t\tkey = keys[i];\n\t\t\t\t\t\tpropVal = stringify(val[key], false);\n\t\t\t\t\t\tif (propVal !== undefined) {\n\t\t\t\t\t\t\tif (str) {\n\t\t\t\t\t\t\t\tstr += ',';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tstr += JSON.stringify(key) + ':' + propVal;\n\t\t\t\t\t\t}\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\treturn '{' + str + '}';\n\t\t\t\t} else {\n\t\t\t\t\treturn JSON.stringify(val);\n\t\t\t\t}\n\t\t\t}\n\t\tcase \"function\":\n\t\tcase \"undefined\":\n\t\t\treturn isArrayProp ? null : undefined;\n\t\tcase \"string\":\n\t\t\treturn JSON.stringify(val);\n\t\tdefault:\n\t\t\treturn isFinite(val) ? val : null;\n\t}\n}\n\nvar fastStableStringify = function(val) {\n\tvar returnVal = stringify(val, false);\n\tif (returnVal !== undefined) {\n\t\treturn ''+ returnVal;\n\t}\n};\n\nvar fastStableStringify$1 = /*@__PURE__*/getDefaultExportFromCjs(fastStableStringify);\n\nconst MINIMUM_SLOT_PER_EPOCH = 32;\n\n// Returns the number of trailing zeros in the binary representation of self.\nfunction trailingZeros(n) {\n  let trailingZeros = 0;\n  while (n > 1) {\n    n /= 2;\n    trailingZeros++;\n  }\n  return trailingZeros;\n}\n\n// Returns the smallest power of two greater than or equal to n\nfunction nextPowerOfTwo(n) {\n  if (n === 0) return 1;\n  n--;\n  n |= n >> 1;\n  n |= n >> 2;\n  n |= n >> 4;\n  n |= n >> 8;\n  n |= n >> 16;\n  n |= n >> 32;\n  return n + 1;\n}\n\n/**\n * Epoch schedule\n * (see https://docs.solana.com/terminology#epoch)\n * Can be retrieved with the {@link Connection.getEpochSchedule} method\n */\nclass EpochSchedule {\n  constructor(slotsPerEpoch, leaderScheduleSlotOffset, warmup, firstNormalEpoch, firstNormalSlot) {\n    /** The maximum number of slots in each epoch */\n    this.slotsPerEpoch = void 0;\n    /** The number of slots before beginning of an epoch to calculate a leader schedule for that epoch */\n    this.leaderScheduleSlotOffset = void 0;\n    /** Indicates whether epochs start short and grow */\n    this.warmup = void 0;\n    /** The first epoch with `slotsPerEpoch` slots */\n    this.firstNormalEpoch = void 0;\n    /** The first slot of `firstNormalEpoch` */\n    this.firstNormalSlot = void 0;\n    this.slotsPerEpoch = slotsPerEpoch;\n    this.leaderScheduleSlotOffset = leaderScheduleSlotOffset;\n    this.warmup = warmup;\n    this.firstNormalEpoch = firstNormalEpoch;\n    this.firstNormalSlot = firstNormalSlot;\n  }\n  getEpoch(slot) {\n    return this.getEpochAndSlotIndex(slot)[0];\n  }\n  getEpochAndSlotIndex(slot) {\n    if (slot < this.firstNormalSlot) {\n      const epoch = trailingZeros(nextPowerOfTwo(slot + MINIMUM_SLOT_PER_EPOCH + 1)) - trailingZeros(MINIMUM_SLOT_PER_EPOCH) - 1;\n      const epochLen = this.getSlotsInEpoch(epoch);\n      const slotIndex = slot - (epochLen - MINIMUM_SLOT_PER_EPOCH);\n      return [epoch, slotIndex];\n    } else {\n      const normalSlotIndex = slot - this.firstNormalSlot;\n      const normalEpochIndex = Math.floor(normalSlotIndex / this.slotsPerEpoch);\n      const epoch = this.firstNormalEpoch + normalEpochIndex;\n      const slotIndex = normalSlotIndex % this.slotsPerEpoch;\n      return [epoch, slotIndex];\n    }\n  }\n  getFirstSlotInEpoch(epoch) {\n    if (epoch <= this.firstNormalEpoch) {\n      return (Math.pow(2, epoch) - 1) * MINIMUM_SLOT_PER_EPOCH;\n    } else {\n      return (epoch - this.firstNormalEpoch) * this.slotsPerEpoch + this.firstNormalSlot;\n    }\n  }\n  getLastSlotInEpoch(epoch) {\n    return this.getFirstSlotInEpoch(epoch) + this.getSlotsInEpoch(epoch) - 1;\n  }\n  getSlotsInEpoch(epoch) {\n    if (epoch < this.firstNormalEpoch) {\n      return Math.pow(2, epoch + trailingZeros(MINIMUM_SLOT_PER_EPOCH));\n    } else {\n      return this.slotsPerEpoch;\n    }\n  }\n}\n\nclass SendTransactionError extends Error {\n  constructor(message, logs) {\n    super(message);\n    this.logs = void 0;\n    this.logs = logs;\n  }\n}\n\n// Keep in sync with client/src/rpc_custom_errors.rs\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaJSONRPCErrorCode = {\n  JSON_RPC_SERVER_ERROR_BLOCK_CLEANED_UP: -32001,\n  JSON_RPC_SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE: -32002,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE: -32003,\n  JSON_RPC_SERVER_ERROR_BLOCK_NOT_AVAILABLE: -32004,\n  JSON_RPC_SERVER_ERROR_NODE_UNHEALTHY: -32005,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE: -32006,\n  JSON_RPC_SERVER_ERROR_SLOT_SKIPPED: -32007,\n  JSON_RPC_SERVER_ERROR_NO_SNAPSHOT: -32008,\n  JSON_RPC_SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED: -32009,\n  JSON_RPC_SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX: -32010,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE: -32011,\n  JSON_RPC_SCAN_ERROR: -32012,\n  JSON_RPC_SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH: -32013,\n  JSON_RPC_SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET: -32014,\n  JSON_RPC_SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION: -32015,\n  JSON_RPC_SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED: -32016\n};\nclass SolanaJSONRPCError extends Error {\n  constructor({\n    code,\n    message,\n    data\n  }, customMessage) {\n    super(customMessage != null ? `${customMessage}: ${message}` : message);\n    this.code = void 0;\n    this.data = void 0;\n    this.code = code;\n    this.data = data;\n    this.name = 'SolanaJSONRPCError';\n  }\n}\n\nvar fetchImpl = globalThis.fetch;\n\nclass RpcWebSocketClient extends rpc_websockets_dist_lib_client__WEBPACK_IMPORTED_MODULE_7__[\"default\"] {\n  constructor(address, options, generate_request_id) {\n    const webSocketFactory = url => {\n      const rpc = (0,rpc_websockets_dist_lib_client_websocket_browser__WEBPACK_IMPORTED_MODULE_8__[\"default\"])(url, {\n        autoconnect: true,\n        max_reconnects: 5,\n        reconnect: true,\n        reconnect_interval: 1000,\n        ...options\n      });\n      if ('socket' in rpc) {\n        this.underlyingSocket = rpc.socket;\n      } else {\n        this.underlyingSocket = rpc;\n      }\n      return rpc;\n    };\n    super(webSocketFactory, address, options, generate_request_id);\n    this.underlyingSocket = void 0;\n  }\n  call(...args) {\n    const readyState = this.underlyingSocket?.readyState;\n    if (readyState === 1 /* WebSocket.OPEN */) {\n      return super.call(...args);\n    }\n    return Promise.reject(new Error('Tried to call a JSON-RPC method `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));\n  }\n  notify(...args) {\n    const readyState = this.underlyingSocket?.readyState;\n    if (readyState === 1 /* WebSocket.OPEN */) {\n      return super.notify(...args);\n    }\n    return Promise.reject(new Error('Tried to send a JSON-RPC notification `' + args[0] + '` but the socket was not `CONNECTING` or `OPEN` (`readyState` was ' + readyState + ')'));\n  }\n}\n\n/**\n * @internal\n */\n\n/**\n * Decode account data buffer using an AccountType\n * @internal\n */\nfunction decodeData(type, data) {\n  let decoded;\n  try {\n    decoded = type.layout.decode(data);\n  } catch (err) {\n    throw new Error('invalid instruction; ' + err);\n  }\n  if (decoded.typeIndex !== type.index) {\n    throw new Error(`invalid account data; account type mismatch ${decoded.typeIndex} != ${type.index}`);\n  }\n  return decoded;\n}\n\n/// The serialized size of lookup table metadata\nconst LOOKUP_TABLE_META_SIZE = 56;\nclass AddressLookupTableAccount {\n  constructor(args) {\n    this.key = void 0;\n    this.state = void 0;\n    this.key = args.key;\n    this.state = args.state;\n  }\n  isActive() {\n    const U64_MAX = BigInt('0xffffffffffffffff');\n    return this.state.deactivationSlot === U64_MAX;\n  }\n  static deserialize(accountData) {\n    const meta = decodeData(LookupTableMetaLayout, accountData);\n    const serializedAddressesLen = accountData.length - LOOKUP_TABLE_META_SIZE;\n    assert(serializedAddressesLen >= 0, 'lookup table is invalid');\n    assert(serializedAddressesLen % 32 === 0, 'lookup table is invalid');\n    const numSerializedAddresses = serializedAddressesLen / 32;\n    const {\n      addresses\n    } = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), numSerializedAddresses, 'addresses')]).decode(accountData.slice(LOOKUP_TABLE_META_SIZE));\n    return {\n      deactivationSlot: meta.deactivationSlot,\n      lastExtendedSlot: meta.lastExtendedSlot,\n      lastExtendedSlotStartIndex: meta.lastExtendedStartIndex,\n      authority: meta.authority.length !== 0 ? new PublicKey(meta.authority[0]) : undefined,\n      addresses: addresses.map(address => new PublicKey(address))\n    };\n  }\n}\nconst LookupTableMetaLayout = {\n  index: 1,\n  layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('typeIndex'), u64('deactivationSlot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64('lastExtendedSlot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('lastExtendedStartIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(),\n  // option\n  _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8(), -1), 'authority')])\n};\n\nconst URL_RE = /^[^:]+:\\/\\/([^:[]+|\\[[^\\]]+\\])(:\\d+)?(.*)/i;\nfunction makeWebsocketUrl(endpoint) {\n  const matches = endpoint.match(URL_RE);\n  if (matches == null) {\n    throw TypeError(`Failed to validate endpoint URL \\`${endpoint}\\``);\n  }\n  const [_,\n  // eslint-disable-line @typescript-eslint/no-unused-vars\n  hostish, portWithColon, rest] = matches;\n  const protocol = endpoint.startsWith('https:') ? 'wss:' : 'ws:';\n  const startPort = portWithColon == null ? null : parseInt(portWithColon.slice(1), 10);\n  const websocketPort =\n  // Only shift the port by +1 as a convention for ws(s) only if given endpoint\n  // is explicitly specifying the endpoint port (HTTP-based RPC), assuming\n  // we're directly trying to connect to solana-validator's ws listening port.\n  // When the endpoint omits the port, we're connecting to the protocol\n  // default ports: http(80) or https(443) and it's assumed we're behind a reverse\n  // proxy which manages WebSocket upgrade and backend port redirection.\n  startPort == null ? '' : `:${startPort + 1}`;\n  return `${protocol}//${hostish}${websocketPort}${rest}`;\n}\n\nconst PublicKeyFromString = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.instance)(PublicKey), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(), value => new PublicKey(value));\nconst RawAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.tuple)([(0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('base64')]);\nconst BufferFromRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.instance)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer), RawAccountDataResult, value => buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value[0], 'base64'));\n\n/**\n * Attempt to use a recent blockhash for up to 30 seconds\n * @internal\n */\nconst BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1000;\n\n/**\n * HACK.\n * Copied from rpc-websockets/dist/lib/client.\n * Otherwise, `yarn build` fails with:\n * https://gist.github.com/steveluscher/c057eca81d479ef705cdb53162f9971d\n */\n\n/** @internal */\n/** @internal */\n/** @internal */\n/** @internal */\n\n/** @internal */\n/**\n * @internal\n * Every subscription contains the args used to open the subscription with\n * the server, and a list of callers interested in notifications.\n */\n\n/**\n * @internal\n * A subscription may be in various states of connectedness. Only when it is\n * fully connected will it have a server subscription id associated with it.\n * This id can be returned to the server to unsubscribe the client entirely.\n */\n\n/**\n * A type that encapsulates a subscription's RPC method\n * names and notification (callback) signature.\n */\n\n/**\n * @internal\n * Utility type that keeps tagged unions intact while omitting properties.\n */\n\n/**\n * @internal\n * This type represents a single subscribable 'topic.' It's made up of:\n *\n * - The args used to open the subscription with the server,\n * - The state of the subscription, in terms of its connectedness, and\n * - The set of callbacks to call when the server publishes notifications\n *\n * This record gets indexed by `SubscriptionConfigHash` and is used to\n * set up subscriptions, fan out notifications, and track subscription state.\n */\n\n/**\n * @internal\n */\n\n/**\n * Extra contextual information for RPC responses\n */\n\n/**\n * Options for sending transactions\n */\n\n/**\n * Options for confirming transactions\n */\n\n/**\n * Options for getConfirmedSignaturesForAddress2\n */\n\n/**\n * Options for getSignaturesForAddress\n */\n\n/**\n * RPC Response with extra contextual information\n */\n\n/**\n * A strategy for confirming transactions that uses the last valid\n * block height for a given blockhash to check for transaction expiration.\n */\n\n/**\n * A strategy for confirming durable nonce transactions.\n */\n\n/**\n * Properties shared by all transaction confirmation strategies\n */\n\n/**\n * This type represents all transaction confirmation strategies\n */\n\n/* @internal */\nfunction assertEndpointUrl(putativeUrl) {\n  if (/^https?:/.test(putativeUrl) === false) {\n    throw new TypeError('Endpoint URL must start with `http:` or `https:`.');\n  }\n  return putativeUrl;\n}\n\n/** @internal */\nfunction extractCommitmentFromConfig(commitmentOrConfig) {\n  let commitment;\n  let config;\n  if (typeof commitmentOrConfig === 'string') {\n    commitment = commitmentOrConfig;\n  } else if (commitmentOrConfig) {\n    const {\n      commitment: specifiedCommitment,\n      ...specifiedConfig\n    } = commitmentOrConfig;\n    commitment = specifiedCommitment;\n    config = specifiedConfig;\n  }\n  return {\n    commitment,\n    config\n  };\n}\n\n/**\n * @internal\n */\nfunction createRpcResult(result) {\n  return (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('2.0'),\n    id: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n    result\n  }), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    jsonrpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('2.0'),\n    id: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n    error: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n      code: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.unknown)(),\n      message: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n      data: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.any)())\n    })\n  })]);\n}\nconst UnknownRpcResult = createRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.unknown)());\n\n/**\n * @internal\n */\nfunction jsonRpcResult(schema) {\n  return (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.coerce)(createRpcResult(schema), UnknownRpcResult, value => {\n    if ('error' in value) {\n      return value;\n    } else {\n      return {\n        ...value,\n        result: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(value.result, schema)\n      };\n    }\n  });\n}\n\n/**\n * @internal\n */\nfunction jsonRpcResultAndContext(value) {\n  return jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    context: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n      slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n    }),\n    value\n  }));\n}\n\n/**\n * @internal\n */\nfunction notificationResultAndContext(value) {\n  return (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    context: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n      slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n    }),\n    value\n  });\n}\n\n/**\n * @internal\n */\nfunction versionedMessageFromResponse(version, response) {\n  if (version === 0) {\n    return new MessageV0({\n      header: response.header,\n      staticAccountKeys: response.accountKeys.map(accountKey => new PublicKey(accountKey)),\n      recentBlockhash: response.recentBlockhash,\n      compiledInstructions: response.instructions.map(ix => ({\n        programIdIndex: ix.programIdIndex,\n        accountKeyIndexes: ix.accounts,\n        data: bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(ix.data)\n      })),\n      addressTableLookups: response.addressTableLookups\n    });\n  } else {\n    return new Message(response);\n  }\n}\n\n/**\n * The level of commitment desired when querying state\n * <pre>\n *   'processed': Query the most recent block which has reached 1 confirmation by the connected node\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */\n\n// Deprecated as of v1.5.5\n\n/**\n * A subset of Commitment levels, which are at least optimistically confirmed\n * <pre>\n *   'confirmed': Query the most recent block which has reached 1 confirmation by the cluster\n *   'finalized': Query the most recent block which has been finalized by the cluster\n * </pre>\n */\n\n/**\n * Filter for largest accounts query\n * <pre>\n *   'circulating':    Return the largest accounts that are part of the circulating supply\n *   'nonCirculating': Return the largest accounts that are not part of the circulating supply\n * </pre>\n */\n\n/**\n * Configuration object for changing `getAccountInfo` query behavior\n */\n\n/**\n * Configuration object for changing `getBalance` query behavior\n */\n\n/**\n * Configuration object for changing `getBlock` query behavior\n */\n\n/**\n * Configuration object for changing `getBlock` query behavior\n */\n\n/**\n * Configuration object for changing `getStakeMinimumDelegation` query behavior\n */\n\n/**\n * Configuration object for changing `getBlockHeight` query behavior\n */\n\n/**\n * Configuration object for changing `getEpochInfo` query behavior\n */\n\n/**\n * Configuration object for changing `getInflationReward` query behavior\n */\n\n/**\n * Configuration object for changing `getLatestBlockhash` query behavior\n */\n\n/**\n * Configuration object for changing `isBlockhashValid` query behavior\n */\n\n/**\n * Configuration object for changing `getSlot` query behavior\n */\n\n/**\n * Configuration object for changing `getSlotLeader` query behavior\n */\n\n/**\n * Configuration object for changing `getTransaction` query behavior\n */\n\n/**\n * Configuration object for changing `getTransaction` query behavior\n */\n\n/**\n * Configuration object for changing `getLargestAccounts` query behavior\n */\n\n/**\n * Configuration object for changing `getSupply` request behavior\n */\n\n/**\n * Configuration object for changing query behavior\n */\n\n/**\n * Information describing a cluster node\n */\n\n/**\n * Information describing a vote account\n */\n\n/**\n * A collection of cluster vote accounts\n */\n\n/**\n * Network Inflation\n * (see https://docs.solana.com/implemented-proposals/ed_overview)\n */\n\nconst GetInflationGovernorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  foundationTerm: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  initial: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  taper: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  terminal: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n});\n\n/**\n * The inflation reward for an epoch\n */\n\n/**\n * Expected JSON RPC response for the \"getInflationReward\" message\n */\nconst GetInflationRewardResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  effectiveSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()))\n}))));\n\n/**\n * Configuration object for changing `getRecentPrioritizationFees` query behavior\n */\n\n/**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */\nconst GetRecentPrioritizationFeesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  prioritizationFee: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n}));\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */\nconst GetInflationRateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  total: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  validator: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  foundation: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n});\n\n/**\n * Information about the current epoch\n */\n\nconst GetEpochInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  epoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  slotIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  slotsInEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  absoluteSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()),\n  transactionCount: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())\n});\nconst GetEpochScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  slotsPerEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  leaderScheduleSlotOffset: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  warmup: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.boolean)(),\n  firstNormalEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  firstNormalSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n});\n\n/**\n * Leader schedule\n * (see https://docs.solana.com/terminology#leader-schedule)\n */\n\nconst GetLeaderScheduleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()));\n\n/**\n * Transaction error or null\n */\nconst TransactionErrorResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({}), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()]));\n\n/**\n * Signature status for a transaction\n */\nconst SignatureStatusResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  err: TransactionErrorResult\n});\n\n/**\n * Transaction signature received notification\n */\nconst SignatureReceivedResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('receivedSignature');\n\n/**\n * Version info for a node\n */\n\nconst VersionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  'solana-core': (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  'feature-set': (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())\n});\nconst SimulatedTransactionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  err: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({}), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()])),\n  logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)())),\n  accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.boolean)(),\n    owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()),\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())\n  }))))),\n  unitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()),\n  returnData: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n    data: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.tuple)([(0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('base64')])\n  })))\n}));\n\n/**\n * Metadata for a parsed confirmed transaction on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link ParsedTransactionMeta} instead.\n */\n\n/**\n * Collection of addresses loaded by a transaction using address table lookups\n */\n\n/**\n * Metadata for a parsed transaction on the ledger\n */\n\n/**\n * Metadata for a confirmed transaction on the ledger\n */\n\n/**\n * A processed transaction from the RPC API\n */\n\n/**\n * A processed transaction from the RPC API\n */\n\n/**\n * A processed transaction message from the RPC API\n */\n\n/**\n * A confirmed transaction on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */\n\n/**\n * A partially decoded transaction instruction\n */\n\n/**\n * A parsed transaction message account\n */\n\n/**\n * A parsed transaction instruction\n */\n\n/**\n * A parsed address table lookup\n */\n\n/**\n * A parsed transaction message\n */\n\n/**\n * A parsed transaction\n */\n\n/**\n * A parsed and confirmed transaction on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link ParsedTransactionWithMeta} instead.\n */\n\n/**\n * A parsed transaction on the ledger with meta\n */\n\n/**\n * A processed block fetched from the RPC API\n */\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */\n\n/**\n * A block with parsed transactions\n */\n\n/**\n * A block with parsed transactions where the `transactionDetails` mode is `accounts`\n */\n\n/**\n * A block with parsed transactions where the `transactionDetails` mode is `none`\n */\n\n/**\n * A processed block fetched from the RPC API\n */\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `accounts`\n */\n\n/**\n * A processed block fetched from the RPC API where the `transactionDetails` mode is `none`\n */\n\n/**\n * A confirmed block on the ledger\n *\n * @deprecated Deprecated since Solana v1.8.0.\n */\n\n/**\n * A Block on the ledger with signatures only\n */\n\n/**\n * recent block production information\n */\n\n/**\n * Expected JSON RPC response for the \"getBlockProduction\" message\n */\nconst BlockProductionResponseStruct = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  byIdentity: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.record)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())),\n  range: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    firstSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n    lastSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n  })\n}));\n\n/**\n * A performance sample\n */\n\nfunction createRpcClient(url, httpHeaders, customFetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent) {\n  const fetch = customFetch ? customFetch : fetchImpl;\n  let agent;\n  {\n    if (httpAgent != null) {\n      console.warn('You have supplied an `httpAgent` when creating a `Connection` in a browser environment.' + 'It has been ignored; `httpAgent` is only used in Node environments.');\n    }\n  }\n  let fetchWithMiddleware;\n  if (fetchMiddleware) {\n    fetchWithMiddleware = async (info, init) => {\n      const modifiedFetchArgs = await new Promise((resolve, reject) => {\n        try {\n          fetchMiddleware(info, init, (modifiedInfo, modifiedInit) => resolve([modifiedInfo, modifiedInit]));\n        } catch (error) {\n          reject(error);\n        }\n      });\n      return await fetch(...modifiedFetchArgs);\n    };\n  }\n  const clientBrowser = new (jayson_lib_client_browser__WEBPACK_IMPORTED_MODULE_6___default())(async (request, callback) => {\n    const options = {\n      method: 'POST',\n      body: request,\n      agent,\n      headers: Object.assign({\n        'Content-Type': 'application/json'\n      }, httpHeaders || {}, COMMON_HTTP_HEADERS)\n    };\n    try {\n      let too_many_requests_retries = 5;\n      let res;\n      let waitTime = 500;\n      for (;;) {\n        if (fetchWithMiddleware) {\n          res = await fetchWithMiddleware(url, options);\n        } else {\n          res = await fetch(url, options);\n        }\n        if (res.status !== 429 /* Too many requests */) {\n          break;\n        }\n        if (disableRetryOnRateLimit === true) {\n          break;\n        }\n        too_many_requests_retries -= 1;\n        if (too_many_requests_retries === 0) {\n          break;\n        }\n        console.error(`Server responded with ${res.status} ${res.statusText}.  Retrying after ${waitTime}ms delay...`);\n        await sleep(waitTime);\n        waitTime *= 2;\n      }\n      const text = await res.text();\n      if (res.ok) {\n        callback(null, text);\n      } else {\n        callback(new Error(`${res.status} ${res.statusText}: ${text}`));\n      }\n    } catch (err) {\n      if (err instanceof Error) callback(err);\n    }\n  }, {});\n  return clientBrowser;\n}\nfunction createRpcRequest(client) {\n  return (method, args) => {\n    return new Promise((resolve, reject) => {\n      client.request(method, args, (err, response) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(response);\n      });\n    });\n  };\n}\nfunction createRpcBatchRequest(client) {\n  return requests => {\n    return new Promise((resolve, reject) => {\n      // Do nothing if requests is empty\n      if (requests.length === 0) resolve([]);\n      const batch = requests.map(params => {\n        return client.request(params.methodName, params.args);\n      });\n      client.request(batch, (err, response) => {\n        if (err) {\n          reject(err);\n          return;\n        }\n        resolve(response);\n      });\n    });\n  };\n}\n\n/**\n * Expected JSON RPC response for the \"getInflationGovernor\" message\n */\nconst GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);\n\n/**\n * Expected JSON RPC response for the \"getInflationRate\" message\n */\nconst GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);\n\n/**\n * Expected JSON RPC response for the \"getRecentPrioritizationFees\" message\n */\nconst GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);\n\n/**\n * Expected JSON RPC response for the \"getEpochInfo\" message\n */\nconst GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);\n\n/**\n * Expected JSON RPC response for the \"getEpochSchedule\" message\n */\nconst GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);\n\n/**\n * Expected JSON RPC response for the \"getLeaderSchedule\" message\n */\nconst GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);\n\n/**\n * Expected JSON RPC response for the \"minimumLedgerSlot\" and \"getFirstAvailableBlock\" messages\n */\nconst SlotRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)());\n\n/**\n * Supply\n */\n\n/**\n * Expected JSON RPC response for the \"getSupply\" message\n */\nconst GetSupplyRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  total: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  circulating: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  nonCirculating: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  nonCirculatingAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(PublicKeyFromString)\n}));\n\n/**\n * Token amount object which returns a token amount in different formats\n * for various client use cases.\n */\n\n/**\n * Expected JSON RPC structure for token amounts\n */\nconst TokenAmountResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()),\n  decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)())\n});\n\n/**\n * Token address and balance.\n */\n\n/**\n * Expected JSON RPC response for the \"getTokenLargestAccounts\" message\n */\nconst GetTokenLargestAccountsResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  address: PublicKeyFromString,\n  amount: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  uiAmount: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()),\n  decimals: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  uiAmountString: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)())\n})));\n\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message\n */\nconst GetTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  pubkey: PublicKeyFromString,\n  account: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n    data: BufferFromRawAccountData,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n  })\n})));\nconst ParsedAccountDataResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  program: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.unknown)(),\n  space: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n});\n\n/**\n * Expected JSON RPC response for the \"getTokenAccountsByOwner\" message with parsed data\n */\nconst GetParsedTokenAccountsByOwner = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  pubkey: PublicKeyFromString,\n  account: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.boolean)(),\n    owner: PublicKeyFromString,\n    lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n    data: ParsedAccountDataResult,\n    rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n  })\n})));\n\n/**\n * Pair of an account address and its balance\n */\n\n/**\n * Expected JSON RPC response for the \"getLargestAccounts\" message\n */\nconst GetLargestAccountsRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  address: PublicKeyFromString\n})));\n\n/**\n * @internal\n */\nconst AccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.boolean)(),\n  owner: PublicKeyFromString,\n  lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  data: BufferFromRawAccountData,\n  rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n});\n\n/**\n * @internal\n */\nconst KeyedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  pubkey: PublicKeyFromString,\n  account: AccountInfoResult\n});\nconst ParsedOrRawAccountData = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.coerce)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_11__.instance)(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer), ParsedAccountDataResult]), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.union)([RawAccountDataResult, ParsedAccountDataResult]), value => {\n  if (Array.isArray(value)) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(value, BufferFromRawAccountData);\n  } else {\n    return value;\n  }\n});\n\n/**\n * @internal\n */\nconst ParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  executable: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.boolean)(),\n  owner: PublicKeyFromString,\n  lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  data: ParsedOrRawAccountData,\n  rentEpoch: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n});\nconst KeyedParsedAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  pubkey: PublicKeyFromString,\n  account: ParsedAccountInfoResult\n});\n\n/**\n * @internal\n */\nconst StakeActivationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  state: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('active'), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('inactive'), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('activating'), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('deactivating')]),\n  active: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  inactive: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n});\n\n/**\n * Expected JSON RPC response for the \"getConfirmedSignaturesForAddress2\" message\n */\n\nconst GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  err: TransactionErrorResult,\n  memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()))\n})));\n\n/**\n * Expected JSON RPC response for the \"getSignaturesForAddress\" message\n */\nconst GetSignaturesForAddressRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  err: TransactionErrorResult,\n  memo: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()))\n})));\n\n/***\n * Expected JSON RPC response for the \"accountNotification\" message\n */\nconst AccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  result: notificationResultAndContext(AccountInfoResult)\n});\n\n/**\n * @internal\n */\nconst ProgramAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  pubkey: PublicKeyFromString,\n  account: AccountInfoResult\n});\n\n/***\n * Expected JSON RPC response for the \"programNotification\" message\n */\nconst ProgramAccountNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  result: notificationResultAndContext(ProgramAccountInfoResult)\n});\n\n/**\n * @internal\n */\nconst SlotInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  root: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n});\n\n/**\n * Expected JSON RPC response for the \"slotNotification\" message\n */\nconst SlotNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  result: SlotInfoResult\n});\n\n/**\n * Slot updates which can be used for tracking the live progress of a cluster.\n * - `\"firstShredReceived\"`: connected node received the first shred of a block.\n * Indicates that a new block that is being produced.\n * - `\"completed\"`: connected node has received all shreds of a block. Indicates\n * a block was recently produced.\n * - `\"optimisticConfirmation\"`: block was optimistically confirmed by the\n * cluster. It is not guaranteed that an optimistic confirmation notification\n * will be sent for every finalized blocks.\n * - `\"root\"`: the connected node rooted this block.\n * - `\"createdBank\"`: the connected node has started validating this block.\n * - `\"frozen\"`: the connected node has validated this block.\n * - `\"dead\"`: the connected node failed to validate this block.\n */\n\n/**\n * @internal\n */\nconst SlotUpdateResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  type: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('firstShredReceived'), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('completed'), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('optimisticConfirmation'), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('root')]),\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n}), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  type: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('createdBank'),\n  parent: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n}), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  type: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('frozen'),\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  stats: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    numTransactionEntries: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n    numSuccessfulTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n    numFailedTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n    maxTransactionsPerEntry: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n  })\n}), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  type: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('dead'),\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  timestamp: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  err: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()\n})]);\n\n/**\n * Expected JSON RPC response for the \"slotsUpdatesNotification\" message\n */\nconst SlotUpdateNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  result: SlotUpdateResult\n});\n\n/**\n * Expected JSON RPC response for the \"signatureNotification\" message\n */\nconst SignatureNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  result: notificationResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.union)([SignatureStatusResult, SignatureReceivedResult]))\n});\n\n/**\n * Expected JSON RPC response for the \"rootNotification\" message\n */\nconst RootNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  result: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n});\nconst ContactInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  gossip: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()),\n  tpu: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()),\n  rpc: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()),\n  version: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)())\n});\nconst VoteAccountInfoResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  votePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  nodePubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  activatedStake: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  epochVoteAccount: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.boolean)(),\n  epochCredits: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.tuple)([(0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()])),\n  commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  lastVote: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  rootSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())\n});\n\n/**\n * Expected JSON RPC response for the \"getVoteAccounts\" message\n */\nconst GetVoteAccounts = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  current: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(VoteAccountInfoResult),\n  delinquent: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(VoteAccountInfoResult)\n}));\nconst ConfirmationStatus = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('processed'), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('confirmed'), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('finalized')]);\nconst SignatureStatusResponse = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  confirmations: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()),\n  err: TransactionErrorResult,\n  confirmationStatus: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)(ConfirmationStatus)\n});\n\n/**\n * Expected JSON RPC response for the \"getSignatureStatuses\" message\n */\nconst GetSignatureStatusesRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)(SignatureStatusResponse)));\n\n/**\n * Expected JSON RPC response for the \"getMinimumBalanceForRentExemption\" message\n */\nconst GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)());\nconst AddressTableLookupStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  accountKey: PublicKeyFromString,\n  writableIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()),\n  readonlyIndexes: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())\n});\nconst ConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()),\n  message: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()),\n    header: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n      numRequiredSignatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n      numReadonlySignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n      numReadonlyUnsignedAccounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n    }),\n    instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n      accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()),\n      data: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n      programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n    })),\n    recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n    addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(AddressTableLookupStruct))\n  })\n});\nconst AnnotatedAccountKey = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  pubkey: PublicKeyFromString,\n  signer: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.boolean)(),\n  writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.boolean)(),\n  source: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('transaction'), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('lookupTable')]))\n});\nconst ConfirmedTransactionAccountsModeResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(AnnotatedAccountKey),\n  signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)())\n});\nconst ParsedInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.unknown)(),\n  program: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  programId: PublicKeyFromString\n});\nconst RawInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(PublicKeyFromString),\n  data: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  programId: PublicKeyFromString\n});\nconst InstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.union)([RawInstructionResult, ParsedInstructionResult]);\nconst UnknownInstructionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  parsed: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.unknown)(),\n  program: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()\n}), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()),\n  data: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  programId: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()\n})]);\nconst ParsedOrRawInstruction = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.coerce)(InstructionResult, UnknownInstructionResult, value => {\n  if ('accounts' in value) {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(value, RawInstructionResult);\n  } else {\n    return (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(value, ParsedInstructionResult);\n  }\n});\n\n/**\n * @internal\n */\nconst ParsedConfirmedTransactionResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()),\n  message: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    accountKeys: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(AnnotatedAccountKey),\n    instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(ParsedOrRawInstruction),\n    recentBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n    addressTableLookups: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(AddressTableLookupStruct)))\n  })\n});\nconst TokenBalanceResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  accountIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  mint: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  owner: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()),\n  uiTokenAmount: TokenAmountResult\n});\nconst LoadedAddressesResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  writable: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(PublicKeyFromString),\n  readonly: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(PublicKeyFromString)\n});\n\n/**\n * @internal\n */\nconst ConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  err: TransactionErrorResult,\n  fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    index: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n    instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n      accounts: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()),\n      data: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n      programIdIndex: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n    }))\n  })))),\n  preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()),\n  postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()),\n  logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()))),\n  preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(TokenBalanceResult))),\n  postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(TokenBalanceResult))),\n  loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)(LoadedAddressesResult),\n  computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())\n});\n\n/**\n * @internal\n */\nconst ParsedConfirmedTransactionMetaResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  err: TransactionErrorResult,\n  fee: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  innerInstructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    index: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n    instructions: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(ParsedOrRawInstruction)\n  })))),\n  preBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()),\n  postBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()),\n  logMessages: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()))),\n  preTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(TokenBalanceResult))),\n  postTokenBalances: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(TokenBalanceResult))),\n  loadedAddresses: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)(LoadedAddressesResult),\n  computeUnitsConsumed: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())\n});\nconst TransactionVersionStruct = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.union)([(0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)(0), (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.literal)('legacy')]);\n\n/** @internal */\nconst RewardsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  pubkey: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  lamports: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  postBalance: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()),\n  rewardType: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()),\n  commission: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()))\n});\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */\nconst GetBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    transaction: ConfirmedTransactionResult,\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)(ConfirmedTransactionMetaResult),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)(TransactionVersionStruct)\n  })),\n  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(RewardsResult)),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()),\n  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())\n})));\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `none`\n */\nconst GetNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(RewardsResult)),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()),\n  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())\n})));\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message when `transactionDetails` is `accounts`\n */\nconst GetAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    transaction: ConfirmedTransactionAccountsModeResult,\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)(ConfirmedTransactionMetaResult),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)(TransactionVersionStruct)\n  })),\n  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(RewardsResult)),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()),\n  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())\n})));\n\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message\n */\nconst GetParsedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    transaction: ParsedConfirmedTransactionResult,\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)(ParsedConfirmedTransactionMetaResult),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)(TransactionVersionStruct)\n  })),\n  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(RewardsResult)),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()),\n  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())\n})));\n\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `accounts`\n */\nconst GetParsedAccountsModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    transaction: ConfirmedTransactionAccountsModeResult,\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)(ParsedConfirmedTransactionMetaResult),\n    version: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)(TransactionVersionStruct)\n  })),\n  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(RewardsResult)),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()),\n  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())\n})));\n\n/**\n * Expected parsed JSON RPC response for the \"getBlock\" message  when `transactionDetails` is `none`\n */\nconst GetParsedNoneModeBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(RewardsResult)),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()),\n  blockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())\n})));\n\n/**\n * Expected JSON RPC response for the \"getConfirmedBlock\" message\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetBlockRpcResult} instead.\n */\nconst GetConfirmedBlockRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  transactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    transaction: ConfirmedTransactionResult,\n    meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)(ConfirmedTransactionMetaResult)\n  })),\n  rewards: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(RewardsResult)),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())\n})));\n\n/**\n * Expected JSON RPC response for the \"getBlock\" message\n */\nconst GetBlockSignaturesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  previousBlockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  parentSlot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  signatures: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())\n})));\n\n/**\n * Expected JSON RPC response for the \"getTransaction\" message\n */\nconst GetTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)(ConfirmedTransactionMetaResult),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())),\n  transaction: ConfirmedTransactionResult,\n  version: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)(TransactionVersionStruct)\n})));\n\n/**\n * Expected parsed JSON RPC response for the \"getTransaction\" message\n */\nconst GetParsedTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  transaction: ParsedConfirmedTransactionResult,\n  meta: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)(ParsedConfirmedTransactionMetaResult),\n  blockTime: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())),\n  version: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)(TransactionVersionStruct)\n})));\n\n/**\n * Expected JSON RPC response for the \"getRecentBlockhash\" message\n *\n * @deprecated Deprecated since Solana v1.8.0. Please use {@link GetLatestBlockhashRpcResult} instead.\n */\nconst GetRecentBlockhashAndContextRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  feeCalculator: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    lamportsPerSignature: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n  })\n}));\n\n/**\n * Expected JSON RPC response for the \"getLatestBlockhash\" message\n */\nconst GetLatestBlockhashRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  blockhash: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  lastValidBlockHeight: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n}));\n\n/**\n * Expected JSON RPC response for the \"isBlockhashValid\" message\n */\nconst IsBlockhashValidRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.boolean)());\nconst PerfSampleResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  slot: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  numTransactions: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  numSlots: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)(),\n  samplePeriodSecs: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n});\n\n/*\n * Expected JSON RPC response for \"getRecentPerformanceSamples\" message\n */\nconst GetRecentPerformanceSamplesRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(PerfSampleResult));\n\n/**\n * Expected JSON RPC response for the \"getFeeCalculatorForBlockhash\" message\n */\nconst GetFeeCalculatorRpcResult = jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  feeCalculator: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n    lamportsPerSignature: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n  })\n})));\n\n/**\n * Expected JSON RPC response for the \"requestAirdrop\" message\n */\nconst RequestAirdropRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)());\n\n/**\n * Expected JSON RPC response for the \"sendTransaction\" message\n */\nconst SendTransactionRpcResult = jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)());\n\n/**\n * Information about the latest slot being processed by a node\n */\n\n/**\n * Parsed account data\n */\n\n/**\n * Stake Activation data\n */\n\n/**\n * Data slice argument for getProgramAccounts\n */\n\n/**\n * Memory comparison filter for getProgramAccounts\n */\n\n/**\n * Data size comparison filter for getProgramAccounts\n */\n\n/**\n * A filter object for getProgramAccounts\n */\n\n/**\n * Configuration object for getProgramAccounts requests\n */\n\n/**\n * Configuration object for getParsedProgramAccounts\n */\n\n/**\n * Configuration object for getMultipleAccounts\n */\n\n/**\n * Configuration object for `getStakeActivation`\n */\n\n/**\n * Configuration object for `getStakeActivation`\n */\n\n/**\n * Configuration object for `getStakeActivation`\n */\n\n/**\n * Configuration object for `getNonce`\n */\n\n/**\n * Configuration object for `getNonceAndContext`\n */\n\n/**\n * Information describing an account\n */\n\n/**\n * Account information identified by pubkey\n */\n\n/**\n * Callback function for account change notifications\n */\n\n/**\n * Callback function for program account change notifications\n */\n\n/**\n * Callback function for slot change notifications\n */\n\n/**\n * Callback function for slot update notifications\n */\n\n/**\n * Callback function for signature status notifications\n */\n\n/**\n * Signature status notification with transaction result\n */\n\n/**\n * Signature received notification\n */\n\n/**\n * Callback function for signature notifications\n */\n\n/**\n * Signature subscription options\n */\n\n/**\n * Callback function for root change notifications\n */\n\n/**\n * @internal\n */\nconst LogsResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  err: TransactionErrorResult,\n  logs: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()),\n  signature: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()\n});\n\n/**\n * Logs result.\n */\n\n/**\n * Expected JSON RPC response for the \"logsNotification\" message.\n */\nconst LogsNotificationResult = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  result: notificationResultAndContext(LogsResult),\n  subscription: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()\n});\n\n/**\n * Filter for log subscriptions.\n */\n\n/**\n * Callback function for log notifications.\n */\n\n/**\n * Signature result\n */\n\n/**\n * Transaction error\n */\n\n/**\n * Transaction confirmation status\n * <pre>\n *   'processed': Transaction landed in a block which has reached 1 confirmation by the connected node\n *   'confirmed': Transaction landed in a block which has reached 1 confirmation by the cluster\n *   'finalized': Transaction landed in a block which has been finalized by the cluster\n * </pre>\n */\n\n/**\n * Signature status\n */\n\n/**\n * A confirmed signature with its status\n */\n\n/**\n * An object defining headers to be passed to the RPC server\n */\n\n/**\n * The type of the JavaScript `fetch()` API\n */\n\n/**\n * A callback used to augment the outgoing HTTP request\n */\n\n/**\n * Configuration for instantiating a Connection\n */\n\n/** @internal */\nconst COMMON_HTTP_HEADERS = {\n  'solana-client': `js/${\"0.0.0-development\" }`\n};\n\n/**\n * A connection to a fullnode JSON RPC endpoint\n */\nclass Connection {\n  /**\n   * Establish a JSON RPC connection\n   *\n   * @param endpoint URL to the fullnode JSON RPC endpoint\n   * @param commitmentOrConfig optional default commitment level or optional ConnectionConfig configuration object\n   */\n  constructor(endpoint, _commitmentOrConfig) {\n    /** @internal */\n    this._commitment = void 0;\n    /** @internal */\n    this._confirmTransactionInitialTimeout = void 0;\n    /** @internal */\n    this._rpcEndpoint = void 0;\n    /** @internal */\n    this._rpcWsEndpoint = void 0;\n    /** @internal */\n    this._rpcClient = void 0;\n    /** @internal */\n    this._rpcRequest = void 0;\n    /** @internal */\n    this._rpcBatchRequest = void 0;\n    /** @internal */\n    this._rpcWebSocket = void 0;\n    /** @internal */\n    this._rpcWebSocketConnected = false;\n    /** @internal */\n    this._rpcWebSocketHeartbeat = null;\n    /** @internal */\n    this._rpcWebSocketIdleTimeout = null;\n    /** @internal\n     * A number that we increment every time an active connection closes.\n     * Used to determine whether the same socket connection that was open\n     * when an async operation started is the same one that's active when\n     * its continuation fires.\n     *\n     */\n    this._rpcWebSocketGeneration = 0;\n    /** @internal */\n    this._disableBlockhashCaching = false;\n    /** @internal */\n    this._pollingBlockhash = false;\n    /** @internal */\n    this._blockhashInfo = {\n      latestBlockhash: null,\n      lastFetch: 0,\n      transactionSignatures: [],\n      simulatedSignatures: []\n    };\n    /** @internal */\n    this._nextClientSubscriptionId = 0;\n    /** @internal */\n    this._subscriptionDisposeFunctionsByClientSubscriptionId = {};\n    /** @internal */\n    this._subscriptionHashByClientSubscriptionId = {};\n    /** @internal */\n    this._subscriptionStateChangeCallbacksByHash = {};\n    /** @internal */\n    this._subscriptionCallbacksByServerSubscriptionId = {};\n    /** @internal */\n    this._subscriptionsByHash = {};\n    /**\n     * Special case.\n     * After a signature is processed, RPCs automatically dispose of the\n     * subscription on the server side. We need to track which of these\n     * subscriptions have been disposed in such a way, so that we know\n     * whether the client is dealing with a not-yet-processed signature\n     * (in which case we must tear down the server subscription) or an\n     * already-processed signature (in which case the client can simply\n     * clear out the subscription locally without telling the server).\n     *\n     * NOTE: There is a proposal to eliminate this special case, here:\n     * https://github.com/solana-labs/solana/issues/18892\n     */\n    /** @internal */\n    this._subscriptionsAutoDisposedByRpc = new Set();\n    /*\n     * Returns the current block height of the node\n     */\n    this.getBlockHeight = (() => {\n      const requestPromises = {};\n      return async commitmentOrConfig => {\n        const {\n          commitment,\n          config\n        } = extractCommitmentFromConfig(commitmentOrConfig);\n        const args = this._buildArgs([], commitment, undefined /* encoding */, config);\n        const requestHash = fastStableStringify$1(args);\n        requestPromises[requestHash] = requestPromises[requestHash] ?? (async () => {\n          try {\n            const unsafeRes = await this._rpcRequest('getBlockHeight', args);\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()));\n            if ('error' in res) {\n              throw new SolanaJSONRPCError(res.error, 'failed to get block height information');\n            }\n            return res.result;\n          } finally {\n            delete requestPromises[requestHash];\n          }\n        })();\n        return await requestPromises[requestHash];\n      };\n    })();\n    let wsEndpoint;\n    let httpHeaders;\n    let fetch;\n    let fetchMiddleware;\n    let disableRetryOnRateLimit;\n    let httpAgent;\n    if (_commitmentOrConfig && typeof _commitmentOrConfig === 'string') {\n      this._commitment = _commitmentOrConfig;\n    } else if (_commitmentOrConfig) {\n      this._commitment = _commitmentOrConfig.commitment;\n      this._confirmTransactionInitialTimeout = _commitmentOrConfig.confirmTransactionInitialTimeout;\n      wsEndpoint = _commitmentOrConfig.wsEndpoint;\n      httpHeaders = _commitmentOrConfig.httpHeaders;\n      fetch = _commitmentOrConfig.fetch;\n      fetchMiddleware = _commitmentOrConfig.fetchMiddleware;\n      disableRetryOnRateLimit = _commitmentOrConfig.disableRetryOnRateLimit;\n      httpAgent = _commitmentOrConfig.httpAgent;\n    }\n    this._rpcEndpoint = assertEndpointUrl(endpoint);\n    this._rpcWsEndpoint = wsEndpoint || makeWebsocketUrl(endpoint);\n    this._rpcClient = createRpcClient(endpoint, httpHeaders, fetch, fetchMiddleware, disableRetryOnRateLimit, httpAgent);\n    this._rpcRequest = createRpcRequest(this._rpcClient);\n    this._rpcBatchRequest = createRpcBatchRequest(this._rpcClient);\n    this._rpcWebSocket = new RpcWebSocketClient(this._rpcWsEndpoint, {\n      autoconnect: false,\n      max_reconnects: Infinity\n    });\n    this._rpcWebSocket.on('open', this._wsOnOpen.bind(this));\n    this._rpcWebSocket.on('error', this._wsOnError.bind(this));\n    this._rpcWebSocket.on('close', this._wsOnClose.bind(this));\n    this._rpcWebSocket.on('accountNotification', this._wsOnAccountNotification.bind(this));\n    this._rpcWebSocket.on('programNotification', this._wsOnProgramAccountNotification.bind(this));\n    this._rpcWebSocket.on('slotNotification', this._wsOnSlotNotification.bind(this));\n    this._rpcWebSocket.on('slotsUpdatesNotification', this._wsOnSlotUpdatesNotification.bind(this));\n    this._rpcWebSocket.on('signatureNotification', this._wsOnSignatureNotification.bind(this));\n    this._rpcWebSocket.on('rootNotification', this._wsOnRootNotification.bind(this));\n    this._rpcWebSocket.on('logsNotification', this._wsOnLogsNotification.bind(this));\n  }\n\n  /**\n   * The default commitment used for requests\n   */\n  get commitment() {\n    return this._commitment;\n  }\n\n  /**\n   * The RPC endpoint\n   */\n  get rpcEndpoint() {\n    return this._rpcEndpoint;\n  }\n\n  /**\n   * Fetch the balance for the specified public key, return with context\n   */\n  async getBalanceAndContext(publicKey, commitmentOrConfig) {\n    /** @internal */\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([publicKey.toBase58()], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getBalance', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get balance for ${publicKey.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the balance for the specified public key\n   */\n  async getBalance(publicKey, commitmentOrConfig) {\n    return await this.getBalanceAndContext(publicKey, commitmentOrConfig).then(x => x.value).catch(e => {\n      throw new Error('failed to get balance of account ' + publicKey.toBase58() + ': ' + e);\n    });\n  }\n\n  /**\n   * Fetch the estimated production time of a block\n   */\n  async getBlockTime(slot) {\n    const unsafeRes = await this._rpcRequest('getBlockTime', [slot]);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get block time for slot ${slot}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the lowest slot that the node has information about in its ledger.\n   * This value may increase over time if the node is configured to purge older ledger data\n   */\n  async getMinimumLedgerSlot() {\n    const unsafeRes = await this._rpcRequest('minimumLedgerSlot', []);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get minimum ledger slot');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the slot of the lowest confirmed block that has not been purged from the ledger\n   */\n  async getFirstAvailableBlock() {\n    const unsafeRes = await this._rpcRequest('getFirstAvailableBlock', []);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, SlotRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get first available block');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch information about the current supply\n   */\n  async getSupply(config) {\n    let configArg = {};\n    if (typeof config === 'string') {\n      configArg = {\n        commitment: config\n      };\n    } else if (config) {\n      configArg = {\n        ...config,\n        commitment: config && config.commitment || this.commitment\n      };\n    } else {\n      configArg = {\n        commitment: this.commitment\n      };\n    }\n    const unsafeRes = await this._rpcRequest('getSupply', [configArg]);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetSupplyRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get supply');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current supply of a token mint\n   */\n  async getTokenSupply(tokenMintAddress, commitment) {\n    const args = this._buildArgs([tokenMintAddress.toBase58()], commitment);\n    const unsafeRes = await this._rpcRequest('getTokenSupply', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get token supply');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current balance of a token account\n   */\n  async getTokenAccountBalance(tokenAddress, commitment) {\n    const args = this._buildArgs([tokenAddress.toBase58()], commitment);\n    const unsafeRes = await this._rpcRequest('getTokenAccountBalance', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResultAndContext(TokenAmountResult));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get token account balance');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<GetProgramAccountsResponse>}\n   */\n  async getTokenAccountsByOwner(ownerAddress, filter, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    let _args = [ownerAddress.toBase58()];\n    if ('mint' in filter) {\n      _args.push({\n        mint: filter.mint.toBase58()\n      });\n    } else {\n      _args.push({\n        programId: filter.programId.toBase58()\n      });\n    }\n    const args = this._buildArgs(_args, commitment, 'base64', config);\n    const unsafeRes = await this._rpcRequest('getTokenAccountsByOwner', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetTokenAccountsByOwner);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch parsed token accounts owned by the specified account\n   *\n   * @return {Promise<RpcResponseAndContext<Array<{pubkey: PublicKey, account: AccountInfo<ParsedAccountData>}>>>}\n   */\n  async getParsedTokenAccountsByOwner(ownerAddress, filter, commitment) {\n    let _args = [ownerAddress.toBase58()];\n    if ('mint' in filter) {\n      _args.push({\n        mint: filter.mint.toBase58()\n      });\n    } else {\n      _args.push({\n        programId: filter.programId.toBase58()\n      });\n    }\n    const args = this._buildArgs(_args, commitment, 'jsonParsed');\n    const unsafeRes = await this._rpcRequest('getTokenAccountsByOwner', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetParsedTokenAccountsByOwner);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get token accounts owned by account ${ownerAddress.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the 20 largest accounts with their current balances\n   */\n  async getLargestAccounts(config) {\n    const arg = {\n      ...config,\n      commitment: config && config.commitment || this.commitment\n    };\n    const args = arg.filter || arg.commitment ? [arg] : [];\n    const unsafeRes = await this._rpcRequest('getLargestAccounts', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetLargestAccountsRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get largest accounts');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the 20 largest token accounts with their current balances\n   * for a given mint.\n   */\n  async getTokenLargestAccounts(mintAddress, commitment) {\n    const args = this._buildArgs([mintAddress.toBase58()], commitment);\n    const unsafeRes = await this._rpcRequest('getTokenLargestAccounts', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetTokenLargestAccountsResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get token largest accounts');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the account info for the specified public key, return with context\n   */\n  async getAccountInfoAndContext(publicKey, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([publicKey.toBase58()], commitment, 'base64', config);\n    const unsafeRes = await this._rpcRequest('getAccountInfo', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)(AccountInfoResult)));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch parsed account info for the specified public key\n   */\n  async getParsedAccountInfo(publicKey, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([publicKey.toBase58()], commitment, 'jsonParsed', config);\n    const unsafeRes = await this._rpcRequest('getAccountInfo', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)(ParsedAccountInfoResult)));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get info about account ${publicKey.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the account info for the specified public key\n   */\n  async getAccountInfo(publicKey, commitmentOrConfig) {\n    try {\n      const res = await this.getAccountInfoAndContext(publicKey, commitmentOrConfig);\n      return res.value;\n    } catch (e) {\n      throw new Error('failed to get info about account ' + publicKey.toBase58() + ': ' + e);\n    }\n  }\n\n  /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */\n  async getMultipleParsedAccounts(publicKeys, rawConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(rawConfig);\n    const keys = publicKeys.map(key => key.toBase58());\n    const args = this._buildArgs([keys], commitment, 'jsonParsed', config);\n    const unsafeRes = await this._rpcRequest('getMultipleAccounts', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)(ParsedAccountInfoResult))));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys, return with context\n   */\n  async getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const keys = publicKeys.map(key => key.toBase58());\n    const args = this._buildArgs([keys], commitment, 'base64', config);\n    const unsafeRes = await this._rpcRequest('getMultipleAccounts', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)(AccountInfoResult))));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get info for accounts ${keys}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the account info for multiple accounts specified by an array of public keys\n   */\n  async getMultipleAccountsInfo(publicKeys, commitmentOrConfig) {\n    const res = await this.getMultipleAccountsInfoAndContext(publicKeys, commitmentOrConfig);\n    return res.value;\n  }\n\n  /**\n   * Returns epoch activation information for a stake account that has been delegated\n   */\n  async getStakeActivation(publicKey, commitmentOrConfig, epoch) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([publicKey.toBase58()], commitment, undefined /* encoding */, {\n      ...config,\n      epoch: epoch != null ? epoch : config?.epoch\n    });\n    const unsafeRes = await this._rpcRequest('getStakeActivation', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResult(StakeActivationResult));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get Stake Activation ${publicKey.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer>}>>}\n   */\n\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n  async getProgramAccounts(programId, configOrCommitment) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(configOrCommitment);\n    const {\n      encoding,\n      ...configWithoutEncoding\n    } = config || {};\n    const args = this._buildArgs([programId.toBase58()], commitment, encoding || 'base64', configWithoutEncoding);\n    const unsafeRes = await this._rpcRequest('getProgramAccounts', args);\n    const baseSchema = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(KeyedAccountInfoResult);\n    const res = configWithoutEncoding.withContext === true ? (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResultAndContext(baseSchema)) : (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResult(baseSchema));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch and parse all the accounts owned by the specified program id\n   *\n   * @return {Promise<Array<{pubkey: PublicKey, account: AccountInfo<Buffer | ParsedAccountData>}>>}\n   */\n  async getParsedProgramAccounts(programId, configOrCommitment) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(configOrCommitment);\n    const args = this._buildArgs([programId.toBase58()], commitment, 'jsonParsed', config);\n    const unsafeRes = await this._rpcRequest('getProgramAccounts', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(KeyedParsedAccountInfoResult)));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get accounts owned by program ${programId.toBase58()}`);\n    }\n    return res.result;\n  }\n\n  /** @deprecated Instead, call `confirmTransaction` and pass in {@link TransactionConfirmationStrategy} */\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n  async confirmTransaction(strategy, commitment) {\n    let rawSignature;\n    if (typeof strategy == 'string') {\n      rawSignature = strategy;\n    } else {\n      const config = strategy;\n      if (config.abortSignal?.aborted) {\n        return Promise.reject(config.abortSignal.reason);\n      }\n      rawSignature = config.signature;\n    }\n    let decodedSignature;\n    try {\n      decodedSignature = bs58__WEBPACK_IMPORTED_MODULE_2___default().decode(rawSignature);\n    } catch (err) {\n      throw new Error('signature must be base58 encoded: ' + rawSignature);\n    }\n    assert(decodedSignature.length === 64, 'signature has invalid length');\n    if (typeof strategy === 'string') {\n      return await this.confirmTransactionUsingLegacyTimeoutStrategy({\n        commitment: commitment || this.commitment,\n        signature: rawSignature\n      });\n    } else if ('lastValidBlockHeight' in strategy) {\n      return await this.confirmTransactionUsingBlockHeightExceedanceStrategy({\n        commitment: commitment || this.commitment,\n        strategy\n      });\n    } else {\n      return await this.confirmTransactionUsingDurableNonceStrategy({\n        commitment: commitment || this.commitment,\n        strategy\n      });\n    }\n  }\n  getCancellationPromise(signal) {\n    return new Promise((_, reject) => {\n      if (signal == null) {\n        return;\n      }\n      if (signal.aborted) {\n        reject(signal.reason);\n      } else {\n        signal.addEventListener('abort', () => {\n          reject(signal.reason);\n        });\n      }\n    });\n  }\n  getTransactionConfirmationPromise({\n    commitment,\n    signature\n  }) {\n    let signatureSubscriptionId;\n    let disposeSignatureSubscriptionStateChangeObserver;\n    let done = false;\n    const confirmationPromise = new Promise((resolve, reject) => {\n      try {\n        signatureSubscriptionId = this.onSignature(signature, (result, context) => {\n          signatureSubscriptionId = undefined;\n          const response = {\n            context,\n            value: result\n          };\n          resolve({\n            __type: TransactionStatus.PROCESSED,\n            response\n          });\n        }, commitment);\n        const subscriptionSetupPromise = new Promise(resolveSubscriptionSetup => {\n          if (signatureSubscriptionId == null) {\n            resolveSubscriptionSetup();\n          } else {\n            disposeSignatureSubscriptionStateChangeObserver = this._onSubscriptionStateChange(signatureSubscriptionId, nextState => {\n              if (nextState === 'subscribed') {\n                resolveSubscriptionSetup();\n              }\n            });\n          }\n        });\n        (async () => {\n          await subscriptionSetupPromise;\n          if (done) return;\n          const response = await this.getSignatureStatus(signature);\n          if (done) return;\n          if (response == null) {\n            return;\n          }\n          const {\n            context,\n            value\n          } = response;\n          if (value == null) {\n            return;\n          }\n          if (value?.err) {\n            reject(value.err);\n          } else {\n            switch (commitment) {\n              case 'confirmed':\n              case 'single':\n              case 'singleGossip':\n                {\n                  if (value.confirmationStatus === 'processed') {\n                    return;\n                  }\n                  break;\n                }\n              case 'finalized':\n              case 'max':\n              case 'root':\n                {\n                  if (value.confirmationStatus === 'processed' || value.confirmationStatus === 'confirmed') {\n                    return;\n                  }\n                  break;\n                }\n              // exhaust enums to ensure full coverage\n              case 'processed':\n              case 'recent':\n            }\n            done = true;\n            resolve({\n              __type: TransactionStatus.PROCESSED,\n              response: {\n                context,\n                value\n              }\n            });\n          }\n        })();\n      } catch (err) {\n        reject(err);\n      }\n    });\n    const abortConfirmation = () => {\n      if (disposeSignatureSubscriptionStateChangeObserver) {\n        disposeSignatureSubscriptionStateChangeObserver();\n        disposeSignatureSubscriptionStateChangeObserver = undefined;\n      }\n      if (signatureSubscriptionId != null) {\n        this.removeSignatureListener(signatureSubscriptionId);\n        signatureSubscriptionId = undefined;\n      }\n    };\n    return {\n      abortConfirmation,\n      confirmationPromise\n    };\n  }\n  async confirmTransactionUsingBlockHeightExceedanceStrategy({\n    commitment,\n    strategy: {\n      abortSignal,\n      lastValidBlockHeight,\n      signature\n    }\n  }) {\n    let done = false;\n    const expiryPromise = new Promise(resolve => {\n      const checkBlockHeight = async () => {\n        try {\n          const blockHeight = await this.getBlockHeight(commitment);\n          return blockHeight;\n        } catch (_e) {\n          return -1;\n        }\n      };\n      (async () => {\n        let currentBlockHeight = await checkBlockHeight();\n        if (done) return;\n        while (currentBlockHeight <= lastValidBlockHeight) {\n          await sleep(1000);\n          if (done) return;\n          currentBlockHeight = await checkBlockHeight();\n          if (done) return;\n        }\n        resolve({\n          __type: TransactionStatus.BLOCKHEIGHT_EXCEEDED\n        });\n      })();\n    });\n    const {\n      abortConfirmation,\n      confirmationPromise\n    } = this.getTransactionConfirmationPromise({\n      commitment,\n      signature\n    });\n    const cancellationPromise = this.getCancellationPromise(abortSignal);\n    let result;\n    try {\n      const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);\n      if (outcome.__type === TransactionStatus.PROCESSED) {\n        result = outcome.response;\n      } else {\n        throw new TransactionExpiredBlockheightExceededError(signature);\n      }\n    } finally {\n      done = true;\n      abortConfirmation();\n    }\n    return result;\n  }\n  async confirmTransactionUsingDurableNonceStrategy({\n    commitment,\n    strategy: {\n      abortSignal,\n      minContextSlot,\n      nonceAccountPubkey,\n      nonceValue,\n      signature\n    }\n  }) {\n    let done = false;\n    const expiryPromise = new Promise(resolve => {\n      let currentNonceValue = nonceValue;\n      let lastCheckedSlot = null;\n      const getCurrentNonceValue = async () => {\n        try {\n          const {\n            context,\n            value: nonceAccount\n          } = await this.getNonceAndContext(nonceAccountPubkey, {\n            commitment,\n            minContextSlot\n          });\n          lastCheckedSlot = context.slot;\n          return nonceAccount?.nonce;\n        } catch (e) {\n          // If for whatever reason we can't reach/read the nonce\n          // account, just keep using the last-known value.\n          return currentNonceValue;\n        }\n      };\n      (async () => {\n        currentNonceValue = await getCurrentNonceValue();\n        if (done) return;\n        while (true // eslint-disable-line no-constant-condition\n        ) {\n          if (nonceValue !== currentNonceValue) {\n            resolve({\n              __type: TransactionStatus.NONCE_INVALID,\n              slotInWhichNonceDidAdvance: lastCheckedSlot\n            });\n            return;\n          }\n          await sleep(2000);\n          if (done) return;\n          currentNonceValue = await getCurrentNonceValue();\n          if (done) return;\n        }\n      })();\n    });\n    const {\n      abortConfirmation,\n      confirmationPromise\n    } = this.getTransactionConfirmationPromise({\n      commitment,\n      signature\n    });\n    const cancellationPromise = this.getCancellationPromise(abortSignal);\n    let result;\n    try {\n      const outcome = await Promise.race([cancellationPromise, confirmationPromise, expiryPromise]);\n      if (outcome.__type === TransactionStatus.PROCESSED) {\n        result = outcome.response;\n      } else {\n        // Double check that the transaction is indeed unconfirmed.\n        let signatureStatus;\n        while (true // eslint-disable-line no-constant-condition\n        ) {\n          const status = await this.getSignatureStatus(signature);\n          if (status == null) {\n            break;\n          }\n          if (status.context.slot < (outcome.slotInWhichNonceDidAdvance ?? minContextSlot)) {\n            await sleep(400);\n            continue;\n          }\n          signatureStatus = status;\n          break;\n        }\n        if (signatureStatus?.value) {\n          const commitmentForStatus = commitment || 'finalized';\n          const {\n            confirmationStatus\n          } = signatureStatus.value;\n          switch (commitmentForStatus) {\n            case 'processed':\n            case 'recent':\n              if (confirmationStatus !== 'processed' && confirmationStatus !== 'confirmed' && confirmationStatus !== 'finalized') {\n                throw new TransactionExpiredNonceInvalidError(signature);\n              }\n              break;\n            case 'confirmed':\n            case 'single':\n            case 'singleGossip':\n              if (confirmationStatus !== 'confirmed' && confirmationStatus !== 'finalized') {\n                throw new TransactionExpiredNonceInvalidError(signature);\n              }\n              break;\n            case 'finalized':\n            case 'max':\n            case 'root':\n              if (confirmationStatus !== 'finalized') {\n                throw new TransactionExpiredNonceInvalidError(signature);\n              }\n              break;\n            default:\n              // Exhaustive switch.\n              // eslint-disable-next-line @typescript-eslint/no-unused-vars\n              (_ => {})(commitmentForStatus);\n          }\n          result = {\n            context: signatureStatus.context,\n            value: {\n              err: signatureStatus.value.err\n            }\n          };\n        } else {\n          throw new TransactionExpiredNonceInvalidError(signature);\n        }\n      }\n    } finally {\n      done = true;\n      abortConfirmation();\n    }\n    return result;\n  }\n  async confirmTransactionUsingLegacyTimeoutStrategy({\n    commitment,\n    signature\n  }) {\n    let timeoutId;\n    const expiryPromise = new Promise(resolve => {\n      let timeoutMs = this._confirmTransactionInitialTimeout || 60 * 1000;\n      switch (commitment) {\n        case 'processed':\n        case 'recent':\n        case 'single':\n        case 'confirmed':\n        case 'singleGossip':\n          {\n            timeoutMs = this._confirmTransactionInitialTimeout || 30 * 1000;\n            break;\n          }\n      }\n      timeoutId = setTimeout(() => resolve({\n        __type: TransactionStatus.TIMED_OUT,\n        timeoutMs\n      }), timeoutMs);\n    });\n    const {\n      abortConfirmation,\n      confirmationPromise\n    } = this.getTransactionConfirmationPromise({\n      commitment,\n      signature\n    });\n    let result;\n    try {\n      const outcome = await Promise.race([confirmationPromise, expiryPromise]);\n      if (outcome.__type === TransactionStatus.PROCESSED) {\n        result = outcome.response;\n      } else {\n        throw new TransactionExpiredTimeoutError(signature, outcome.timeoutMs / 1000);\n      }\n    } finally {\n      clearTimeout(timeoutId);\n      abortConfirmation();\n    }\n    return result;\n  }\n\n  /**\n   * Return the list of nodes that are currently participating in the cluster\n   */\n  async getClusterNodes() {\n    const unsafeRes = await this._rpcRequest('getClusterNodes', []);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(ContactInfoResult)));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get cluster nodes');\n    }\n    return res.result;\n  }\n\n  /**\n   * Return the list of nodes that are currently participating in the cluster\n   */\n  async getVoteAccounts(commitment) {\n    const args = this._buildArgs([], commitment);\n    const unsafeRes = await this._rpcRequest('getVoteAccounts', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetVoteAccounts);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get vote accounts');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current slot that the node is processing\n   */\n  async getSlot(commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getSlot', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get slot');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current slot leader of the cluster\n   */\n  async getSlotLeader(commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getSlotLeader', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get slot leader');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch `limit` number of slot leaders starting from `startSlot`\n   *\n   * @param startSlot fetch slot leaders starting from this slot\n   * @param limit number of slot leaders to return\n   */\n  async getSlotLeaders(startSlot, limit) {\n    const args = [startSlot, limit];\n    const unsafeRes = await this._rpcRequest('getSlotLeaders', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)(PublicKeyFromString)));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get slot leaders');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current status of a signature\n   */\n  async getSignatureStatus(signature, config) {\n    const {\n      context,\n      value: values\n    } = await this.getSignatureStatuses([signature], config);\n    assert(values.length === 1);\n    const value = values[0];\n    return {\n      context,\n      value\n    };\n  }\n\n  /**\n   * Fetch the current statuses of a batch of signatures\n   */\n  async getSignatureStatuses(signatures, config) {\n    const params = [signatures];\n    if (config) {\n      params.push(config);\n    }\n    const unsafeRes = await this._rpcRequest('getSignatureStatuses', params);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetSignatureStatusesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get signature status');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current transaction count of the cluster\n   */\n  async getTransactionCount(commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getTransactionCount', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get transaction count');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the current total currency supply of the cluster in lamports\n   *\n   * @deprecated Deprecated since v1.2.8. Please use {@link getSupply} instead.\n   */\n  async getTotalSupply(commitment) {\n    const result = await this.getSupply({\n      commitment,\n      excludeNonCirculatingAccountsList: true\n    });\n    return result.value.total;\n  }\n\n  /**\n   * Fetch the cluster InflationGovernor parameters\n   */\n  async getInflationGovernor(commitment) {\n    const args = this._buildArgs([], commitment);\n    const unsafeRes = await this._rpcRequest('getInflationGovernor', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetInflationGovernorRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get inflation');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the inflation reward for a list of addresses for an epoch\n   */\n  async getInflationReward(addresses, epoch, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([addresses.map(pubkey => pubkey.toBase58())], commitment, undefined /* encoding */, {\n      ...config,\n      epoch: epoch != null ? epoch : config?.epoch\n    });\n    const unsafeRes = await this._rpcRequest('getInflationReward', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetInflationRewardResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get inflation reward');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the specific inflation values for the current epoch\n   */\n  async getInflationRate() {\n    const unsafeRes = await this._rpcRequest('getInflationRate', []);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetInflationRateRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get inflation rate');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the Epoch Info parameters\n   */\n  async getEpochInfo(commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getEpochInfo', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetEpochInfoRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get epoch info');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the Epoch Schedule parameters\n   */\n  async getEpochSchedule() {\n    const unsafeRes = await this._rpcRequest('getEpochSchedule', []);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetEpochScheduleRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get epoch schedule');\n    }\n    const epochSchedule = res.result;\n    return new EpochSchedule(epochSchedule.slotsPerEpoch, epochSchedule.leaderScheduleSlotOffset, epochSchedule.warmup, epochSchedule.firstNormalEpoch, epochSchedule.firstNormalSlot);\n  }\n\n  /**\n   * Fetch the leader schedule for the current epoch\n   * @return {Promise<RpcResponseAndContext<LeaderSchedule>>}\n   */\n  async getLeaderSchedule() {\n    const unsafeRes = await this._rpcRequest('getLeaderSchedule', []);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetLeaderScheduleRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get leader schedule');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the minimum balance needed to exempt an account of `dataLength`\n   * size from rent\n   */\n  async getMinimumBalanceForRentExemption(dataLength, commitment) {\n    const args = this._buildArgs([dataLength], commitment);\n    const unsafeRes = await this._rpcRequest('getMinimumBalanceForRentExemption', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetMinimumBalanceForRentExemptionRpcResult);\n    if ('error' in res) {\n      console.warn('Unable to fetch minimum balance for rent exemption');\n      return 0;\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch a recent blockhash from the cluster, return with context\n   * @return {Promise<RpcResponseAndContext<{blockhash: Blockhash, feeCalculator: FeeCalculator}>>}\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.\n   */\n  async getRecentBlockhashAndContext(commitment) {\n    const args = this._buildArgs([], commitment);\n    const unsafeRes = await this._rpcRequest('getRecentBlockhash', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetRecentBlockhashAndContextRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get recent blockhash');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch recent performance samples\n   * @return {Promise<Array<PerfSample>>}\n   */\n  async getRecentPerformanceSamples(limit) {\n    const unsafeRes = await this._rpcRequest('getRecentPerformanceSamples', limit ? [limit] : []);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetRecentPerformanceSamplesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get recent performance samples');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the fee calculator for a recent blockhash from the cluster, return with context\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getFeeForMessage} instead.\n   */\n  async getFeeCalculatorForBlockhash(blockhash, commitment) {\n    const args = this._buildArgs([blockhash], commitment);\n    const unsafeRes = await this._rpcRequest('getFeeCalculatorForBlockhash', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetFeeCalculatorRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get fee calculator');\n    }\n    const {\n      context,\n      value\n    } = res.result;\n    return {\n      context,\n      value: value !== null ? value.feeCalculator : null\n    };\n  }\n\n  /**\n   * Fetch the fee for a message from the cluster, return with context\n   */\n  async getFeeForMessage(message, commitment) {\n    const wireMessage = toBuffer(message.serialize()).toString('base64');\n    const args = this._buildArgs([wireMessage], commitment);\n    const unsafeRes = await this._rpcRequest('getFeeForMessage', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.nullable)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get fee for message');\n    }\n    if (res.result === null) {\n      throw new Error('invalid blockhash');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch a list of prioritization fees from recent blocks.\n   */\n  async getRecentPrioritizationFees(config) {\n    const accounts = config?.lockedWritableAccounts?.map(key => key.toBase58());\n    const args = accounts?.length ? [accounts] : [];\n    const unsafeRes = await this._rpcRequest('getRecentPrioritizationFees', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetRecentPrioritizationFeesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get recent prioritization fees');\n    }\n    return res.result;\n  }\n  /**\n   * Fetch a recent blockhash from the cluster\n   * @return {Promise<{blockhash: Blockhash, feeCalculator: FeeCalculator}>}\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getLatestBlockhash} instead.\n   */\n  async getRecentBlockhash(commitment) {\n    try {\n      const res = await this.getRecentBlockhashAndContext(commitment);\n      return res.value;\n    } catch (e) {\n      throw new Error('failed to get recent blockhash: ' + e);\n    }\n  }\n\n  /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */\n  async getLatestBlockhash(commitmentOrConfig) {\n    try {\n      const res = await this.getLatestBlockhashAndContext(commitmentOrConfig);\n      return res.value;\n    } catch (e) {\n      throw new Error('failed to get recent blockhash: ' + e);\n    }\n  }\n\n  /**\n   * Fetch the latest blockhash from the cluster\n   * @return {Promise<BlockhashWithExpiryBlockHeight>}\n   */\n  async getLatestBlockhashAndContext(commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgs([], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getLatestBlockhash', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetLatestBlockhashRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get latest blockhash');\n    }\n    return res.result;\n  }\n\n  /**\n   * Returns whether a blockhash is still valid or not\n   */\n  async isBlockhashValid(blockhash, rawConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(rawConfig);\n    const args = this._buildArgs([blockhash], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('isBlockhashValid', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, IsBlockhashValidRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to determine if the blockhash `' + blockhash + '`is valid');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the node version\n   */\n  async getVersion() {\n    const unsafeRes = await this._rpcRequest('getVersion', []);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResult(VersionResult));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get version');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch the genesis hash\n   */\n  async getGenesisHash() {\n    const unsafeRes = await this._rpcRequest('getGenesisHash', []);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get genesis hash');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch a processed block from the cluster.\n   *\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */\n\n  /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * @deprecated Instead, call `getBlock` using a `GetVersionedBlockConfig` by\n   * setting the `maxSupportedTransactionVersion` property.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * Fetch a processed block from the cluster.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * Fetch a processed block from the cluster.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async getBlock(slot, rawConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(rawConfig);\n    const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getBlock', args);\n    try {\n      switch (config?.transactionDetails) {\n        case 'accounts':\n          {\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetAccountsModeBlockRpcResult);\n            if ('error' in res) {\n              throw res.error;\n            }\n            return res.result;\n          }\n        case 'none':\n          {\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetNoneModeBlockRpcResult);\n            if ('error' in res) {\n              throw res.error;\n            }\n            return res.result;\n          }\n        default:\n          {\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetBlockRpcResult);\n            if ('error' in res) {\n              throw res.error;\n            }\n            const {\n              result\n            } = res;\n            return result ? {\n              ...result,\n              transactions: result.transactions.map(({\n                transaction,\n                meta,\n                version\n              }) => ({\n                meta,\n                transaction: {\n                  ...transaction,\n                  message: versionedMessageFromResponse(version, transaction.message)\n                },\n                version\n              }))\n            } : null;\n          }\n      }\n    } catch (e) {\n      throw new SolanaJSONRPCError(e, 'failed to get confirmed block');\n    }\n  }\n\n  /**\n   * Fetch parsed transaction details for a confirmed or finalized block\n   */\n\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n\n  // eslint-disable-next-line no-dupe-class-members\n  async getParsedBlock(slot, rawConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(rawConfig);\n    const args = this._buildArgsAtLeastConfirmed([slot], commitment, 'jsonParsed', config);\n    const unsafeRes = await this._rpcRequest('getBlock', args);\n    try {\n      switch (config?.transactionDetails) {\n        case 'accounts':\n          {\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetParsedAccountsModeBlockRpcResult);\n            if ('error' in res) {\n              throw res.error;\n            }\n            return res.result;\n          }\n        case 'none':\n          {\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetParsedNoneModeBlockRpcResult);\n            if ('error' in res) {\n              throw res.error;\n            }\n            return res.result;\n          }\n        default:\n          {\n            const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetParsedBlockRpcResult);\n            if ('error' in res) {\n              throw res.error;\n            }\n            return res.result;\n          }\n      }\n    } catch (e) {\n      throw new SolanaJSONRPCError(e, 'failed to get block');\n    }\n  }\n  /*\n   * Returns recent block production information from the current or previous epoch\n   */\n  async getBlockProduction(configOrCommitment) {\n    let extra;\n    let commitment;\n    if (typeof configOrCommitment === 'string') {\n      commitment = configOrCommitment;\n    } else if (configOrCommitment) {\n      const {\n        commitment: c,\n        ...rest\n      } = configOrCommitment;\n      commitment = c;\n      extra = rest;\n    }\n    const args = this._buildArgs([], commitment, 'base64', extra);\n    const unsafeRes = await this._rpcRequest('getBlockProduction', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, BlockProductionResponseStruct);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get block production information');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   *\n   * @deprecated Instead, call `getTransaction` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */\n\n  /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * Fetch a confirmed or finalized transaction from the cluster.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async getTransaction(signature, rawConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(rawConfig);\n    const args = this._buildArgsAtLeastConfirmed([signature], commitment, undefined /* encoding */, config);\n    const unsafeRes = await this._rpcRequest('getTransaction', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetTransactionRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get transaction');\n    }\n    const result = res.result;\n    if (!result) return result;\n    return {\n      ...result,\n      transaction: {\n        ...result.transaction,\n        message: versionedMessageFromResponse(result.version, result.transaction.message)\n      }\n    };\n  }\n\n  /**\n   * Fetch parsed transaction details for a confirmed or finalized transaction\n   */\n  async getParsedTransaction(signature, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);\n    const unsafeRes = await this._rpcRequest('getTransaction', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetParsedTransactionRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get transaction');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   */\n  async getParsedTransactions(signatures, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const batch = signatures.map(signature => {\n      const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed', config);\n      return {\n        methodName: 'getTransaction',\n        args\n      };\n    });\n    const unsafeRes = await this._rpcBatchRequest(batch);\n    const res = unsafeRes.map(unsafeRes => {\n      const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetParsedTransactionRpcResult);\n      if ('error' in res) {\n        throw new SolanaJSONRPCError(res.error, 'failed to get transactions');\n      }\n      return res.result;\n    });\n    return res;\n  }\n\n  /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link TransactionResponse}.\n   *\n   * @deprecated Instead, call `getTransactions` using a\n   * `GetVersionedTransactionConfig` by setting the\n   * `maxSupportedTransactionVersion` property.\n   */\n\n  /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * Fetch transaction details for a batch of confirmed transactions.\n   * Similar to {@link getParsedTransactions} but returns a {@link\n   * VersionedTransactionResponse}.\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async getTransactions(signatures, commitmentOrConfig) {\n    const {\n      commitment,\n      config\n    } = extractCommitmentFromConfig(commitmentOrConfig);\n    const batch = signatures.map(signature => {\n      const args = this._buildArgsAtLeastConfirmed([signature], commitment, undefined /* encoding */, config);\n      return {\n        methodName: 'getTransaction',\n        args\n      };\n    });\n    const unsafeRes = await this._rpcBatchRequest(batch);\n    const res = unsafeRes.map(unsafeRes => {\n      const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetTransactionRpcResult);\n      if ('error' in res) {\n        throw new SolanaJSONRPCError(res.error, 'failed to get transactions');\n      }\n      const result = res.result;\n      if (!result) return result;\n      return {\n        ...result,\n        transaction: {\n          ...result.transaction,\n          message: versionedMessageFromResponse(result.version, result.transaction.message)\n        }\n      };\n    });\n    return res;\n  }\n\n  /**\n   * Fetch a list of Transactions and transaction statuses from the cluster\n   * for a confirmed block.\n   *\n   * @deprecated Deprecated since v1.13.0. Please use {@link getBlock} instead.\n   */\n  async getConfirmedBlock(slot, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([slot], commitment);\n    const unsafeRes = await this._rpcRequest('getConfirmedBlock', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetConfirmedBlockRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');\n    }\n    const result = res.result;\n    if (!result) {\n      throw new Error('Confirmed block ' + slot + ' not found');\n    }\n    const block = {\n      ...result,\n      transactions: result.transactions.map(({\n        transaction,\n        meta\n      }) => {\n        const message = new Message(transaction.message);\n        return {\n          meta,\n          transaction: {\n            ...transaction,\n            message\n          }\n        };\n      })\n    };\n    return {\n      ...block,\n      transactions: block.transactions.map(({\n        transaction,\n        meta\n      }) => {\n        return {\n          meta,\n          transaction: Transaction.populate(transaction.message, transaction.signatures)\n        };\n      })\n    };\n  }\n\n  /**\n   * Fetch confirmed blocks between two slots\n   */\n  async getBlocks(startSlot, endSlot, commitment) {\n    const args = this._buildArgsAtLeastConfirmed(endSlot !== undefined ? [startSlot, endSlot] : [startSlot], commitment);\n    const unsafeRes = await this._rpcRequest('getBlocks', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResult((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.array)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)())));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get blocks');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch a list of Signatures from the cluster for a block, excluding rewards\n   */\n  async getBlockSignatures(slot, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {\n      transactionDetails: 'signatures',\n      rewards: false\n    });\n    const unsafeRes = await this._rpcRequest('getBlock', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get block');\n    }\n    const result = res.result;\n    if (!result) {\n      throw new Error('Block ' + slot + ' not found');\n    }\n    return result;\n  }\n\n  /**\n   * Fetch a list of Signatures from the cluster for a confirmed block, excluding rewards\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getBlockSignatures} instead.\n   */\n  async getConfirmedBlockSignatures(slot, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([slot], commitment, undefined, {\n      transactionDetails: 'signatures',\n      rewards: false\n    });\n    const unsafeRes = await this._rpcRequest('getConfirmedBlock', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetBlockSignaturesRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed block');\n    }\n    const result = res.result;\n    if (!result) {\n      throw new Error('Confirmed block ' + slot + ' not found');\n    }\n    return result;\n  }\n\n  /**\n   * Fetch a transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getTransaction} instead.\n   */\n  async getConfirmedTransaction(signature, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([signature], commitment);\n    const unsafeRes = await this._rpcRequest('getConfirmedTransaction', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetTransactionRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get transaction');\n    }\n    const result = res.result;\n    if (!result) return result;\n    const message = new Message(result.transaction.message);\n    const signatures = result.transaction.signatures;\n    return {\n      ...result,\n      transaction: Transaction.populate(message, signatures)\n    };\n  }\n\n  /**\n   * Fetch parsed transaction details for a confirmed transaction\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransaction} instead.\n   */\n  async getParsedConfirmedTransaction(signature, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');\n    const unsafeRes = await this._rpcRequest('getConfirmedTransaction', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetParsedTransactionRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transaction');\n    }\n    return res.result;\n  }\n\n  /**\n   * Fetch parsed transaction details for a batch of confirmed transactions\n   *\n   * @deprecated Deprecated since Solana v1.8.0. Please use {@link getParsedTransactions} instead.\n   */\n  async getParsedConfirmedTransactions(signatures, commitment) {\n    const batch = signatures.map(signature => {\n      const args = this._buildArgsAtLeastConfirmed([signature], commitment, 'jsonParsed');\n      return {\n        methodName: 'getConfirmedTransaction',\n        args\n      };\n    });\n    const unsafeRes = await this._rpcBatchRequest(batch);\n    const res = unsafeRes.map(unsafeRes => {\n      const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetParsedTransactionRpcResult);\n      if ('error' in res) {\n        throw new SolanaJSONRPCError(res.error, 'failed to get confirmed transactions');\n      }\n      return res.result;\n    });\n    return res;\n  }\n\n  /**\n   * Fetch a list of all the confirmed signatures for transactions involving an address\n   * within a specified slot range. Max range allowed is 10,000 slots.\n   *\n   * @deprecated Deprecated since v1.3. Please use {@link getConfirmedSignaturesForAddress2} instead.\n   *\n   * @param address queried address\n   * @param startSlot start slot, inclusive\n   * @param endSlot end slot, inclusive\n   */\n  async getConfirmedSignaturesForAddress(address, startSlot, endSlot) {\n    let options = {};\n    let firstAvailableBlock = await this.getFirstAvailableBlock();\n    while (!('until' in options)) {\n      startSlot--;\n      if (startSlot <= 0 || startSlot < firstAvailableBlock) {\n        break;\n      }\n      try {\n        const block = await this.getConfirmedBlockSignatures(startSlot, 'finalized');\n        if (block.signatures.length > 0) {\n          options.until = block.signatures[block.signatures.length - 1].toString();\n        }\n      } catch (err) {\n        if (err instanceof Error && err.message.includes('skipped')) {\n          continue;\n        } else {\n          throw err;\n        }\n      }\n    }\n    let highestConfirmedRoot = await this.getSlot('finalized');\n    while (!('before' in options)) {\n      endSlot++;\n      if (endSlot > highestConfirmedRoot) {\n        break;\n      }\n      try {\n        const block = await this.getConfirmedBlockSignatures(endSlot);\n        if (block.signatures.length > 0) {\n          options.before = block.signatures[block.signatures.length - 1].toString();\n        }\n      } catch (err) {\n        if (err instanceof Error && err.message.includes('skipped')) {\n          continue;\n        } else {\n          throw err;\n        }\n      }\n    }\n    const confirmedSignatureInfo = await this.getConfirmedSignaturesForAddress2(address, options);\n    return confirmedSignatureInfo.map(info => info.signature);\n  }\n\n  /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   *\n   * @param address queried address\n   * @param options\n   */\n  async getConfirmedSignaturesForAddress2(address, options, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);\n    const unsafeRes = await this._rpcRequest('getConfirmedSignaturesForAddress2', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetConfirmedSignaturesForAddress2RpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get confirmed signatures for address');\n    }\n    return res.result;\n  }\n\n  /**\n   * Returns confirmed signatures for transactions involving an\n   * address backwards in time from the provided signature or most recent confirmed block\n   *\n   *\n   * @param address queried address\n   * @param options\n   */\n  async getSignaturesForAddress(address, options, commitment) {\n    const args = this._buildArgsAtLeastConfirmed([address.toBase58()], commitment, undefined, options);\n    const unsafeRes = await this._rpcRequest('getSignaturesForAddress', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, GetSignaturesForAddressRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, 'failed to get signatures for address');\n    }\n    return res.result;\n  }\n  async getAddressLookupTable(accountKey, config) {\n    const {\n      context,\n      value: accountInfo\n    } = await this.getAccountInfoAndContext(accountKey, config);\n    let value = null;\n    if (accountInfo !== null) {\n      value = new AddressLookupTableAccount({\n        key: accountKey,\n        state: AddressLookupTableAccount.deserialize(accountInfo.data)\n      });\n    }\n    return {\n      context,\n      value\n    };\n  }\n\n  /**\n   * Fetch the contents of a Nonce account from the cluster, return with context\n   */\n  async getNonceAndContext(nonceAccount, commitmentOrConfig) {\n    const {\n      context,\n      value: accountInfo\n    } = await this.getAccountInfoAndContext(nonceAccount, commitmentOrConfig);\n    let value = null;\n    if (accountInfo !== null) {\n      value = NonceAccount.fromAccountData(accountInfo.data);\n    }\n    return {\n      context,\n      value\n    };\n  }\n\n  /**\n   * Fetch the contents of a Nonce account from the cluster\n   */\n  async getNonce(nonceAccount, commitmentOrConfig) {\n    return await this.getNonceAndContext(nonceAccount, commitmentOrConfig).then(x => x.value).catch(e => {\n      throw new Error('failed to get nonce for account ' + nonceAccount.toBase58() + ': ' + e);\n    });\n  }\n\n  /**\n   * Request an allocation of lamports to the specified address\n   *\n   * ```typescript\n   * import { Connection, PublicKey, LAMPORTS_PER_SOL } from \"@solana/web3.js\";\n   *\n   * (async () => {\n   *   const connection = new Connection(\"https://api.testnet.solana.com\", \"confirmed\");\n   *   const myAddress = new PublicKey(\"2nr1bHFT86W9tGnyvmYW4vcHKsQB3sVQfnddasz4kExM\");\n   *   const signature = await connection.requestAirdrop(myAddress, LAMPORTS_PER_SOL);\n   *   await connection.confirmTransaction(signature);\n   * })();\n   * ```\n   */\n  async requestAirdrop(to, lamports) {\n    const unsafeRes = await this._rpcRequest('requestAirdrop', [to.toBase58(), lamports]);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, RequestAirdropRpcResult);\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `airdrop to ${to.toBase58()} failed`);\n    }\n    return res.result;\n  }\n\n  /**\n   * @internal\n   */\n  async _blockhashWithExpiryBlockHeight(disableCache) {\n    if (!disableCache) {\n      // Wait for polling to finish\n      while (this._pollingBlockhash) {\n        await sleep(100);\n      }\n      const timeSinceFetch = Date.now() - this._blockhashInfo.lastFetch;\n      const expired = timeSinceFetch >= BLOCKHASH_CACHE_TIMEOUT_MS;\n      if (this._blockhashInfo.latestBlockhash !== null && !expired) {\n        return this._blockhashInfo.latestBlockhash;\n      }\n    }\n    return await this._pollNewBlockhash();\n  }\n\n  /**\n   * @internal\n   */\n  async _pollNewBlockhash() {\n    this._pollingBlockhash = true;\n    try {\n      const startTime = Date.now();\n      const cachedLatestBlockhash = this._blockhashInfo.latestBlockhash;\n      const cachedBlockhash = cachedLatestBlockhash ? cachedLatestBlockhash.blockhash : null;\n      for (let i = 0; i < 50; i++) {\n        const latestBlockhash = await this.getLatestBlockhash('finalized');\n        if (cachedBlockhash !== latestBlockhash.blockhash) {\n          this._blockhashInfo = {\n            latestBlockhash,\n            lastFetch: Date.now(),\n            transactionSignatures: [],\n            simulatedSignatures: []\n          };\n          return latestBlockhash;\n        }\n\n        // Sleep for approximately half a slot\n        await sleep(MS_PER_SLOT / 2);\n      }\n      throw new Error(`Unable to obtain a new blockhash after ${Date.now() - startTime}ms`);\n    } finally {\n      this._pollingBlockhash = false;\n    }\n  }\n\n  /**\n   * get the stake minimum delegation\n   */\n  async getStakeMinimumDelegation(config) {\n    const {\n      commitment,\n      config: configArg\n    } = extractCommitmentFromConfig(config);\n    const args = this._buildArgs([], commitment, 'base64', configArg);\n    const unsafeRes = await this._rpcRequest('getStakeMinimumDelegation', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, jsonRpcResultAndContext((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.number)()));\n    if ('error' in res) {\n      throw new SolanaJSONRPCError(res.error, `failed to get stake minimum delegation`);\n    }\n    return res.result;\n  }\n\n  /**\n   * Simulate a transaction\n   *\n   * @deprecated Instead, call {@link simulateTransaction} with {@link\n   * VersionedTransaction} and {@link SimulateTransactionConfig} parameters\n   */\n\n  /**\n   * Simulate a transaction\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * Simulate a transaction\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async simulateTransaction(transactionOrMessage, configOrSigners, includeAccounts) {\n    if ('message' in transactionOrMessage) {\n      const versionedTx = transactionOrMessage;\n      const wireTransaction = versionedTx.serialize();\n      const encodedTransaction = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(wireTransaction).toString('base64');\n      if (Array.isArray(configOrSigners) || includeAccounts !== undefined) {\n        throw new Error('Invalid arguments');\n      }\n      const config = configOrSigners || {};\n      config.encoding = 'base64';\n      if (!('commitment' in config)) {\n        config.commitment = this.commitment;\n      }\n      const args = [encodedTransaction, config];\n      const unsafeRes = await this._rpcRequest('simulateTransaction', args);\n      const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n      if ('error' in res) {\n        throw new Error('failed to simulate transaction: ' + res.error.message);\n      }\n      return res.result;\n    }\n    let transaction;\n    if (transactionOrMessage instanceof Transaction) {\n      let originalTx = transactionOrMessage;\n      transaction = new Transaction();\n      transaction.feePayer = originalTx.feePayer;\n      transaction.instructions = transactionOrMessage.instructions;\n      transaction.nonceInfo = originalTx.nonceInfo;\n      transaction.signatures = originalTx.signatures;\n    } else {\n      transaction = Transaction.populate(transactionOrMessage);\n      // HACK: this function relies on mutating the populated transaction\n      transaction._message = transaction._json = undefined;\n    }\n    if (configOrSigners !== undefined && !Array.isArray(configOrSigners)) {\n      throw new Error('Invalid arguments');\n    }\n    const signers = configOrSigners;\n    if (transaction.nonceInfo && signers) {\n      transaction.sign(...signers);\n    } else {\n      let disableCache = this._disableBlockhashCaching;\n      for (;;) {\n        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n        transaction.recentBlockhash = latestBlockhash.blockhash;\n        if (!signers) break;\n        transaction.sign(...signers);\n        if (!transaction.signature) {\n          throw new Error('!signature'); // should never happen\n        }\n        const signature = transaction.signature.toString('base64');\n        if (!this._blockhashInfo.simulatedSignatures.includes(signature) && !this._blockhashInfo.transactionSignatures.includes(signature)) {\n          // The signature of this transaction has not been seen before with the\n          // current recentBlockhash, all done. Let's break\n          this._blockhashInfo.simulatedSignatures.push(signature);\n          break;\n        } else {\n          // This transaction would be treated as duplicate (its derived signature\n          // matched to one of already recorded signatures).\n          // So, we must fetch a new blockhash for a different signature by disabling\n          // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n          disableCache = true;\n        }\n      }\n    }\n    const message = transaction._compile();\n    const signData = message.serialize();\n    const wireTransaction = transaction._serialize(signData);\n    const encodedTransaction = wireTransaction.toString('base64');\n    const config = {\n      encoding: 'base64',\n      commitment: this.commitment\n    };\n    if (includeAccounts) {\n      const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map(key => key.toBase58());\n      config['accounts'] = {\n        encoding: 'base64',\n        addresses\n      };\n    }\n    if (signers) {\n      config.sigVerify = true;\n    }\n    const args = [encodedTransaction, config];\n    const unsafeRes = await this._rpcRequest('simulateTransaction', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, SimulatedTransactionResponseStruct);\n    if ('error' in res) {\n      let logs;\n      if ('data' in res.error) {\n        logs = res.error.data.logs;\n        if (logs && Array.isArray(logs)) {\n          const traceIndent = '\\n    ';\n          const logTrace = traceIndent + logs.join(traceIndent);\n          console.error(res.error.message, logTrace);\n        }\n      }\n      throw new SendTransactionError('failed to simulate transaction: ' + res.error.message, logs);\n    }\n    return res.result;\n  }\n\n  /**\n   * Sign and send a transaction\n   *\n   * @deprecated Instead, call {@link sendTransaction} with a {@link\n   * VersionedTransaction}\n   */\n\n  /**\n   * Send a signed transaction\n   */\n  // eslint-disable-next-line no-dupe-class-members\n\n  /**\n   * Sign and send a transaction\n   */\n  // eslint-disable-next-line no-dupe-class-members\n  async sendTransaction(transaction, signersOrOptions, options) {\n    if ('version' in transaction) {\n      if (signersOrOptions && Array.isArray(signersOrOptions)) {\n        throw new Error('Invalid arguments');\n      }\n      const wireTransaction = transaction.serialize();\n      return await this.sendRawTransaction(wireTransaction, signersOrOptions);\n    }\n    if (signersOrOptions === undefined || !Array.isArray(signersOrOptions)) {\n      throw new Error('Invalid arguments');\n    }\n    const signers = signersOrOptions;\n    if (transaction.nonceInfo) {\n      transaction.sign(...signers);\n    } else {\n      let disableCache = this._disableBlockhashCaching;\n      for (;;) {\n        const latestBlockhash = await this._blockhashWithExpiryBlockHeight(disableCache);\n        transaction.lastValidBlockHeight = latestBlockhash.lastValidBlockHeight;\n        transaction.recentBlockhash = latestBlockhash.blockhash;\n        transaction.sign(...signers);\n        if (!transaction.signature) {\n          throw new Error('!signature'); // should never happen\n        }\n        const signature = transaction.signature.toString('base64');\n        if (!this._blockhashInfo.transactionSignatures.includes(signature)) {\n          // The signature of this transaction has not been seen before with the\n          // current recentBlockhash, all done. Let's break\n          this._blockhashInfo.transactionSignatures.push(signature);\n          break;\n        } else {\n          // This transaction would be treated as duplicate (its derived signature\n          // matched to one of already recorded signatures).\n          // So, we must fetch a new blockhash for a different signature by disabling\n          // our cache not to wait for the cache expiration (BLOCKHASH_CACHE_TIMEOUT_MS).\n          disableCache = true;\n        }\n      }\n    }\n    const wireTransaction = transaction.serialize();\n    return await this.sendRawTransaction(wireTransaction, options);\n  }\n\n  /**\n   * Send a transaction that has already been signed and serialized into the\n   * wire format\n   */\n  async sendRawTransaction(rawTransaction, options) {\n    const encodedTransaction = toBuffer(rawTransaction).toString('base64');\n    const result = await this.sendEncodedTransaction(encodedTransaction, options);\n    return result;\n  }\n\n  /**\n   * Send a transaction that has already been signed, serialized into the\n   * wire format, and encoded as a base64 string\n   */\n  async sendEncodedTransaction(encodedTransaction, options) {\n    const config = {\n      encoding: 'base64'\n    };\n    const skipPreflight = options && options.skipPreflight;\n    const preflightCommitment = skipPreflight === true ? 'processed' // FIXME Remove when https://github.com/anza-xyz/agave/pull/483 is deployed.\n    : options && options.preflightCommitment || this.commitment;\n    if (options && options.maxRetries != null) {\n      config.maxRetries = options.maxRetries;\n    }\n    if (options && options.minContextSlot != null) {\n      config.minContextSlot = options.minContextSlot;\n    }\n    if (skipPreflight) {\n      config.skipPreflight = skipPreflight;\n    }\n    if (preflightCommitment) {\n      config.preflightCommitment = preflightCommitment;\n    }\n    const args = [encodedTransaction, config];\n    const unsafeRes = await this._rpcRequest('sendTransaction', args);\n    const res = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(unsafeRes, SendTransactionRpcResult);\n    if ('error' in res) {\n      let logs;\n      if ('data' in res.error) {\n        logs = res.error.data.logs;\n      }\n      throw new SendTransactionError('failed to send transaction: ' + res.error.message, logs);\n    }\n    return res.result;\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnOpen() {\n    this._rpcWebSocketConnected = true;\n    this._rpcWebSocketHeartbeat = setInterval(() => {\n      // Ping server every 5s to prevent idle timeouts\n      (async () => {\n        try {\n          await this._rpcWebSocket.notify('ping');\n          // eslint-disable-next-line no-empty\n        } catch {}\n      })();\n    }, 5000);\n    this._updateSubscriptions();\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnError(err) {\n    this._rpcWebSocketConnected = false;\n    console.error('ws error:', err.message);\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnClose(code) {\n    this._rpcWebSocketConnected = false;\n    this._rpcWebSocketGeneration = (this._rpcWebSocketGeneration + 1) % Number.MAX_SAFE_INTEGER;\n    if (this._rpcWebSocketIdleTimeout) {\n      clearTimeout(this._rpcWebSocketIdleTimeout);\n      this._rpcWebSocketIdleTimeout = null;\n    }\n    if (this._rpcWebSocketHeartbeat) {\n      clearInterval(this._rpcWebSocketHeartbeat);\n      this._rpcWebSocketHeartbeat = null;\n    }\n    if (code === 1000) {\n      // explicit close, check if any subscriptions have been made since close\n      this._updateSubscriptions();\n      return;\n    }\n\n    // implicit close, prepare subscriptions for auto-reconnect\n    this._subscriptionCallbacksByServerSubscriptionId = {};\n    Object.entries(this._subscriptionsByHash).forEach(([hash, subscription]) => {\n      this._setSubscription(hash, {\n        ...subscription,\n        state: 'pending'\n      });\n    });\n  }\n\n  /**\n   * @internal\n   */\n  _setSubscription(hash, nextSubscription) {\n    const prevState = this._subscriptionsByHash[hash]?.state;\n    this._subscriptionsByHash[hash] = nextSubscription;\n    if (prevState !== nextSubscription.state) {\n      const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash];\n      if (stateChangeCallbacks) {\n        stateChangeCallbacks.forEach(cb => {\n          try {\n            cb(nextSubscription.state);\n            // eslint-disable-next-line no-empty\n          } catch {}\n        });\n      }\n    }\n  }\n\n  /**\n   * @internal\n   */\n  _onSubscriptionStateChange(clientSubscriptionId, callback) {\n    const hash = this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n    if (hash == null) {\n      return () => {};\n    }\n    const stateChangeCallbacks = this._subscriptionStateChangeCallbacksByHash[hash] ||= new Set();\n    stateChangeCallbacks.add(callback);\n    return () => {\n      stateChangeCallbacks.delete(callback);\n      if (stateChangeCallbacks.size === 0) {\n        delete this._subscriptionStateChangeCallbacksByHash[hash];\n      }\n    };\n  }\n\n  /**\n   * @internal\n   */\n  async _updateSubscriptions() {\n    if (Object.keys(this._subscriptionsByHash).length === 0) {\n      if (this._rpcWebSocketConnected) {\n        this._rpcWebSocketConnected = false;\n        this._rpcWebSocketIdleTimeout = setTimeout(() => {\n          this._rpcWebSocketIdleTimeout = null;\n          try {\n            this._rpcWebSocket.close();\n          } catch (err) {\n            // swallow error if socket has already been closed.\n            if (err instanceof Error) {\n              console.log(`Error when closing socket connection: ${err.message}`);\n            }\n          }\n        }, 500);\n      }\n      return;\n    }\n    if (this._rpcWebSocketIdleTimeout !== null) {\n      clearTimeout(this._rpcWebSocketIdleTimeout);\n      this._rpcWebSocketIdleTimeout = null;\n      this._rpcWebSocketConnected = true;\n    }\n    if (!this._rpcWebSocketConnected) {\n      this._rpcWebSocket.connect();\n      return;\n    }\n    const activeWebSocketGeneration = this._rpcWebSocketGeneration;\n    const isCurrentConnectionStillActive = () => {\n      return activeWebSocketGeneration === this._rpcWebSocketGeneration;\n    };\n    await Promise.all(\n    // Don't be tempted to change this to `Object.entries`. We call\n    // `_updateSubscriptions` recursively when processing the state,\n    // so it's important that we look up the *current* version of\n    // each subscription, every time we process a hash.\n    Object.keys(this._subscriptionsByHash).map(async hash => {\n      const subscription = this._subscriptionsByHash[hash];\n      if (subscription === undefined) {\n        // This entry has since been deleted. Skip.\n        return;\n      }\n      switch (subscription.state) {\n        case 'pending':\n        case 'unsubscribed':\n          if (subscription.callbacks.size === 0) {\n            /**\n             * You can end up here when:\n             *\n             * - a subscription has recently unsubscribed\n             *   without having new callbacks added to it\n             *   while the unsubscribe was in flight, or\n             * - when a pending subscription has its\n             *   listeners removed before a request was\n             *   sent to the server.\n             *\n             * Being that nobody is interested in this\n             * subscription any longer, delete it.\n             */\n            delete this._subscriptionsByHash[hash];\n            if (subscription.state === 'unsubscribed') {\n              delete this._subscriptionCallbacksByServerSubscriptionId[subscription.serverSubscriptionId];\n            }\n            await this._updateSubscriptions();\n            return;\n          }\n          await (async () => {\n            const {\n              args,\n              method\n            } = subscription;\n            try {\n              this._setSubscription(hash, {\n                ...subscription,\n                state: 'subscribing'\n              });\n              const serverSubscriptionId = await this._rpcWebSocket.call(method, args);\n              this._setSubscription(hash, {\n                ...subscription,\n                serverSubscriptionId,\n                state: 'subscribed'\n              });\n              this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId] = subscription.callbacks;\n              await this._updateSubscriptions();\n            } catch (e) {\n              if (e instanceof Error) {\n                console.error(`${method} error for argument`, args, e.message);\n              }\n              if (!isCurrentConnectionStillActive()) {\n                return;\n              }\n              // TODO: Maybe add an 'errored' state or a retry limit?\n              this._setSubscription(hash, {\n                ...subscription,\n                state: 'pending'\n              });\n              await this._updateSubscriptions();\n            }\n          })();\n          break;\n        case 'subscribed':\n          if (subscription.callbacks.size === 0) {\n            // By the time we successfully set up a subscription\n            // with the server, the client stopped caring about it.\n            // Tear it down now.\n            await (async () => {\n              const {\n                serverSubscriptionId,\n                unsubscribeMethod\n              } = subscription;\n              if (this._subscriptionsAutoDisposedByRpc.has(serverSubscriptionId)) {\n                /**\n                 * Special case.\n                 * If we're dealing with a subscription that has been auto-\n                 * disposed by the RPC, then we can skip the RPC call to\n                 * tear down the subscription here.\n                 *\n                 * NOTE: There is a proposal to eliminate this special case, here:\n                 * https://github.com/solana-labs/solana/issues/18892\n                 */\n                this._subscriptionsAutoDisposedByRpc.delete(serverSubscriptionId);\n              } else {\n                this._setSubscription(hash, {\n                  ...subscription,\n                  state: 'unsubscribing'\n                });\n                this._setSubscription(hash, {\n                  ...subscription,\n                  state: 'unsubscribing'\n                });\n                try {\n                  await this._rpcWebSocket.call(unsubscribeMethod, [serverSubscriptionId]);\n                } catch (e) {\n                  if (e instanceof Error) {\n                    console.error(`${unsubscribeMethod} error:`, e.message);\n                  }\n                  if (!isCurrentConnectionStillActive()) {\n                    return;\n                  }\n                  // TODO: Maybe add an 'errored' state or a retry limit?\n                  this._setSubscription(hash, {\n                    ...subscription,\n                    state: 'subscribed'\n                  });\n                  await this._updateSubscriptions();\n                  return;\n                }\n              }\n              this._setSubscription(hash, {\n                ...subscription,\n                state: 'unsubscribed'\n              });\n              await this._updateSubscriptions();\n            })();\n          }\n          break;\n      }\n    }));\n  }\n\n  /**\n   * @internal\n   */\n  _handleServerNotification(serverSubscriptionId, callbackArgs) {\n    const callbacks = this._subscriptionCallbacksByServerSubscriptionId[serverSubscriptionId];\n    if (callbacks === undefined) {\n      return;\n    }\n    callbacks.forEach(cb => {\n      try {\n        cb(\n        // I failed to find a way to convince TypeScript that `cb` is of type\n        // `TCallback` which is certainly compatible with `Parameters<TCallback>`.\n        // See https://github.com/microsoft/TypeScript/issues/47615\n        // @ts-ignore\n        ...callbackArgs);\n      } catch (e) {\n        console.error(e);\n      }\n    });\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnAccountNotification(notification) {\n    const {\n      result,\n      subscription\n    } = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(notification, AccountNotificationResult);\n    this._handleServerNotification(subscription, [result.value, result.context]);\n  }\n\n  /**\n   * @internal\n   */\n  _makeSubscription(subscriptionConfig,\n  /**\n   * When preparing `args` for a call to `_makeSubscription`, be sure\n   * to carefully apply a default `commitment` property, if necessary.\n   *\n   * - If the user supplied a `commitment` use that.\n   * - Otherwise, if the `Connection::commitment` is set, use that.\n   * - Otherwise, set it to the RPC server default: `finalized`.\n   *\n   * This is extremely important to ensure that these two fundamentally\n   * identical subscriptions produce the same identifying hash:\n   *\n   * - A subscription made without specifying a commitment.\n   * - A subscription made where the commitment specified is the same\n   *   as the default applied to the subscription above.\n   *\n   * Example; these two subscriptions must produce the same hash:\n   *\n   * - An `accountSubscribe` subscription for `'PUBKEY'`\n   * - An `accountSubscribe` subscription for `'PUBKEY'` with commitment\n   *   `'finalized'`.\n   *\n   * See the 'making a subscription with defaulted params omitted' test\n   * in `connection-subscriptions.ts` for more.\n   */\n  args) {\n    const clientSubscriptionId = this._nextClientSubscriptionId++;\n    const hash = fastStableStringify$1([subscriptionConfig.method, args]);\n    const existingSubscription = this._subscriptionsByHash[hash];\n    if (existingSubscription === undefined) {\n      this._subscriptionsByHash[hash] = {\n        ...subscriptionConfig,\n        args,\n        callbacks: new Set([subscriptionConfig.callback]),\n        state: 'pending'\n      };\n    } else {\n      existingSubscription.callbacks.add(subscriptionConfig.callback);\n    }\n    this._subscriptionHashByClientSubscriptionId[clientSubscriptionId] = hash;\n    this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId] = async () => {\n      delete this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n      delete this._subscriptionHashByClientSubscriptionId[clientSubscriptionId];\n      const subscription = this._subscriptionsByHash[hash];\n      assert(subscription !== undefined, `Could not find a \\`Subscription\\` when tearing down client subscription #${clientSubscriptionId}`);\n      subscription.callbacks.delete(subscriptionConfig.callback);\n      await this._updateSubscriptions();\n    };\n    this._updateSubscriptions();\n    return clientSubscriptionId;\n  }\n\n  /**\n   * Register a callback to be invoked whenever the specified account changes\n   *\n   * @param publicKey Public key of the account to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param commitment Specify the commitment level account changes must reach before notification\n   * @return subscription id\n   */\n  onAccountChange(publicKey, callback, commitment) {\n    const args = this._buildArgs([publicKey.toBase58()], commitment || this._commitment || 'finalized',\n    // Apply connection/server default.\n    'base64');\n    return this._makeSubscription({\n      callback,\n      method: 'accountSubscribe',\n      unsubscribeMethod: 'accountUnsubscribe'\n    }, args);\n  }\n\n  /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeAccountChangeListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'account change');\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnProgramAccountNotification(notification) {\n    const {\n      result,\n      subscription\n    } = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(notification, ProgramAccountNotificationResult);\n    this._handleServerNotification(subscription, [{\n      accountId: result.value.pubkey,\n      accountInfo: result.value.account\n    }, result.context]);\n  }\n\n  /**\n   * Register a callback to be invoked whenever accounts owned by the\n   * specified program change\n   *\n   * @param programId Public key of the program to monitor\n   * @param callback Function to invoke whenever the account is changed\n   * @param commitment Specify the commitment level account changes must reach before notification\n   * @param filters The program account filters to pass into the RPC method\n   * @return subscription id\n   */\n  onProgramAccountChange(programId, callback, commitment, filters) {\n    const args = this._buildArgs([programId.toBase58()], commitment || this._commitment || 'finalized',\n    // Apply connection/server default.\n    'base64' /* encoding */, filters ? {\n      filters: filters\n    } : undefined /* extra */);\n    return this._makeSubscription({\n      callback,\n      method: 'programSubscribe',\n      unsubscribeMethod: 'programUnsubscribe'\n    }, args);\n  }\n\n  /**\n   * Deregister an account notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeProgramAccountChangeListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'program account change');\n  }\n\n  /**\n   * Registers a callback to be invoked whenever logs are emitted.\n   */\n  onLogs(filter, callback, commitment) {\n    const args = this._buildArgs([typeof filter === 'object' ? {\n      mentions: [filter.toString()]\n    } : filter], commitment || this._commitment || 'finalized' // Apply connection/server default.\n    );\n    return this._makeSubscription({\n      callback,\n      method: 'logsSubscribe',\n      unsubscribeMethod: 'logsUnsubscribe'\n    }, args);\n  }\n\n  /**\n   * Deregister a logs callback.\n   *\n   * @param clientSubscriptionId client subscription id to deregister.\n   */\n  async removeOnLogsListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'logs');\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnLogsNotification(notification) {\n    const {\n      result,\n      subscription\n    } = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(notification, LogsNotificationResult);\n    this._handleServerNotification(subscription, [result.value, result.context]);\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnSlotNotification(notification) {\n    const {\n      result,\n      subscription\n    } = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(notification, SlotNotificationResult);\n    this._handleServerNotification(subscription, [result]);\n  }\n\n  /**\n   * Register a callback to be invoked upon slot changes\n   *\n   * @param callback Function to invoke whenever the slot changes\n   * @return subscription id\n   */\n  onSlotChange(callback) {\n    return this._makeSubscription({\n      callback,\n      method: 'slotSubscribe',\n      unsubscribeMethod: 'slotUnsubscribe'\n    }, [] /* args */);\n  }\n\n  /**\n   * Deregister a slot notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeSlotChangeListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'slot change');\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnSlotUpdatesNotification(notification) {\n    const {\n      result,\n      subscription\n    } = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(notification, SlotUpdateNotificationResult);\n    this._handleServerNotification(subscription, [result]);\n  }\n\n  /**\n   * Register a callback to be invoked upon slot updates. {@link SlotUpdate}'s\n   * may be useful to track live progress of a cluster.\n   *\n   * @param callback Function to invoke whenever the slot updates\n   * @return subscription id\n   */\n  onSlotUpdate(callback) {\n    return this._makeSubscription({\n      callback,\n      method: 'slotsUpdatesSubscribe',\n      unsubscribeMethod: 'slotsUpdatesUnsubscribe'\n    }, [] /* args */);\n  }\n\n  /**\n   * Deregister a slot update notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeSlotUpdateListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'slot update');\n  }\n\n  /**\n   * @internal\n   */\n\n  async _unsubscribeClientSubscription(clientSubscriptionId, subscriptionName) {\n    const dispose = this._subscriptionDisposeFunctionsByClientSubscriptionId[clientSubscriptionId];\n    if (dispose) {\n      await dispose();\n    } else {\n      console.warn('Ignored unsubscribe request because an active subscription with id ' + `\\`${clientSubscriptionId}\\` for '${subscriptionName}' events ` + 'could not be found.');\n    }\n  }\n  _buildArgs(args, override, encoding, extra) {\n    const commitment = override || this._commitment;\n    if (commitment || encoding || extra) {\n      let options = {};\n      if (encoding) {\n        options.encoding = encoding;\n      }\n      if (commitment) {\n        options.commitment = commitment;\n      }\n      if (extra) {\n        options = Object.assign(options, extra);\n      }\n      args.push(options);\n    }\n    return args;\n  }\n\n  /**\n   * @internal\n   */\n  _buildArgsAtLeastConfirmed(args, override, encoding, extra) {\n    const commitment = override || this._commitment;\n    if (commitment && !['confirmed', 'finalized'].includes(commitment)) {\n      throw new Error('Using Connection with default commitment: `' + this._commitment + '`, but method requires at least `confirmed`');\n    }\n    return this._buildArgs(args, override, encoding, extra);\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnSignatureNotification(notification) {\n    const {\n      result,\n      subscription\n    } = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(notification, SignatureNotificationResult);\n    if (result.value !== 'receivedSignature') {\n      /**\n       * Special case.\n       * After a signature is processed, RPCs automatically dispose of the\n       * subscription on the server side. We need to track which of these\n       * subscriptions have been disposed in such a way, so that we know\n       * whether the client is dealing with a not-yet-processed signature\n       * (in which case we must tear down the server subscription) or an\n       * already-processed signature (in which case the client can simply\n       * clear out the subscription locally without telling the server).\n       *\n       * NOTE: There is a proposal to eliminate this special case, here:\n       * https://github.com/solana-labs/solana/issues/18892\n       */\n      this._subscriptionsAutoDisposedByRpc.add(subscription);\n    }\n    this._handleServerNotification(subscription, result.value === 'receivedSignature' ? [{\n      type: 'received'\n    }, result.context] : [{\n      type: 'status',\n      result: result.value\n    }, result.context]);\n  }\n\n  /**\n   * Register a callback to be invoked upon signature updates\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param commitment Specify the commitment level signature must reach before notification\n   * @return subscription id\n   */\n  onSignature(signature, callback, commitment) {\n    const args = this._buildArgs([signature], commitment || this._commitment || 'finalized' // Apply connection/server default.\n    );\n    const clientSubscriptionId = this._makeSubscription({\n      callback: (notification, context) => {\n        if (notification.type === 'status') {\n          callback(notification.result, context);\n          // Signatures subscriptions are auto-removed by the RPC service\n          // so no need to explicitly send an unsubscribe message.\n          try {\n            this.removeSignatureListener(clientSubscriptionId);\n            // eslint-disable-next-line no-empty\n          } catch (_err) {\n            // Already removed.\n          }\n        }\n      },\n      method: 'signatureSubscribe',\n      unsubscribeMethod: 'signatureUnsubscribe'\n    }, args);\n    return clientSubscriptionId;\n  }\n\n  /**\n   * Register a callback to be invoked when a transaction is\n   * received and/or processed.\n   *\n   * @param signature Transaction signature string in base 58\n   * @param callback Function to invoke on signature notifications\n   * @param options Enable received notifications and set the commitment\n   *   level that signature must reach before notification\n   * @return subscription id\n   */\n  onSignatureWithOptions(signature, callback, options) {\n    const {\n      commitment,\n      ...extra\n    } = {\n      ...options,\n      commitment: options && options.commitment || this._commitment || 'finalized' // Apply connection/server default.\n    };\n    const args = this._buildArgs([signature], commitment, undefined /* encoding */, extra);\n    const clientSubscriptionId = this._makeSubscription({\n      callback: (notification, context) => {\n        callback(notification, context);\n        // Signatures subscriptions are auto-removed by the RPC service\n        // so no need to explicitly send an unsubscribe message.\n        try {\n          this.removeSignatureListener(clientSubscriptionId);\n          // eslint-disable-next-line no-empty\n        } catch (_err) {\n          // Already removed.\n        }\n      },\n      method: 'signatureSubscribe',\n      unsubscribeMethod: 'signatureUnsubscribe'\n    }, args);\n    return clientSubscriptionId;\n  }\n\n  /**\n   * Deregister a signature notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeSignatureListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'signature result');\n  }\n\n  /**\n   * @internal\n   */\n  _wsOnRootNotification(notification) {\n    const {\n      result,\n      subscription\n    } = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.create)(notification, RootNotificationResult);\n    this._handleServerNotification(subscription, [result]);\n  }\n\n  /**\n   * Register a callback to be invoked upon root changes\n   *\n   * @param callback Function to invoke whenever the root changes\n   * @return subscription id\n   */\n  onRootChange(callback) {\n    return this._makeSubscription({\n      callback,\n      method: 'rootSubscribe',\n      unsubscribeMethod: 'rootUnsubscribe'\n    }, [] /* args */);\n  }\n\n  /**\n   * Deregister a root notification callback\n   *\n   * @param clientSubscriptionId client subscription id to deregister\n   */\n  async removeRootChangeListener(clientSubscriptionId) {\n    await this._unsubscribeClientSubscription(clientSubscriptionId, 'root change');\n  }\n}\n\n/**\n * Keypair signer interface\n */\n\n/**\n * An account keypair used for signing transactions.\n */\nclass Keypair {\n  /**\n   * Create a new keypair instance.\n   * Generate random keypair if no {@link Ed25519Keypair} is provided.\n   *\n   * @param {Ed25519Keypair} keypair ed25519 keypair\n   */\n  constructor(keypair) {\n    this._keypair = void 0;\n    this._keypair = keypair ?? generateKeypair();\n  }\n\n  /**\n   * Generate a new random keypair\n   *\n   * @returns {Keypair} Keypair\n   */\n  static generate() {\n    return new Keypair(generateKeypair());\n  }\n\n  /**\n   * Create a keypair from a raw secret key byte array.\n   *\n   * This method should only be used to recreate a keypair from a previously\n   * generated secret key. Generating keypairs from a random seed should be done\n   * with the {@link Keypair.fromSeed} method.\n   *\n   * @throws error if the provided secret key is invalid and validation is not skipped.\n   *\n   * @param secretKey secret key byte array\n   * @param options skip secret key validation\n   *\n   * @returns {Keypair} Keypair\n   */\n  static fromSecretKey(secretKey, options) {\n    if (secretKey.byteLength !== 64) {\n      throw new Error('bad secret key size');\n    }\n    const publicKey = secretKey.slice(32, 64);\n    if (!options || !options.skipValidation) {\n      const privateScalar = secretKey.slice(0, 32);\n      const computedPublicKey = getPublicKey(privateScalar);\n      for (let ii = 0; ii < 32; ii++) {\n        if (publicKey[ii] !== computedPublicKey[ii]) {\n          throw new Error('provided secretKey is invalid');\n        }\n      }\n    }\n    return new Keypair({\n      publicKey,\n      secretKey\n    });\n  }\n\n  /**\n   * Generate a keypair from a 32 byte seed.\n   *\n   * @param seed seed byte array\n   *\n   * @returns {Keypair} Keypair\n   */\n  static fromSeed(seed) {\n    const publicKey = getPublicKey(seed);\n    const secretKey = new Uint8Array(64);\n    secretKey.set(seed);\n    secretKey.set(publicKey, 32);\n    return new Keypair({\n      publicKey,\n      secretKey\n    });\n  }\n\n  /**\n   * The public key for this keypair\n   *\n   * @returns {PublicKey} PublicKey\n   */\n  get publicKey() {\n    return new PublicKey(this._keypair.publicKey);\n  }\n\n  /**\n   * The raw secret key for this keypair\n   * @returns {Uint8Array} Secret key in an array of Uint8 bytes\n   */\n  get secretKey() {\n    return new Uint8Array(this._keypair.secretKey);\n  }\n}\n\n/**\n * An enumeration of valid LookupTableInstructionType's\n */\n\n/**\n * An enumeration of valid address lookup table InstructionType's\n * @internal\n */\nconst LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({\n  CreateLookupTable: {\n    index: 0,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), u64('recentSlot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('bumpSeed')])\n  },\n  FreezeLookupTable: {\n    index: 1,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction')])\n  },\n  ExtendLookupTable: {\n    index: 2,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), u64(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(publicKey(), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), 'addresses')])\n  },\n  DeactivateLookupTable: {\n    index: 3,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction')])\n  },\n  CloseLookupTable: {\n    index: 4,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction')])\n  }\n});\nclass AddressLookupTableInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n  static decodeInstructionType(instruction) {\n    this.checkProgramId(instruction.programId);\n    const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction');\n    const index = instructionTypeLayout.decode(instruction.data);\n    let type;\n    for (const [layoutType, layout] of Object.entries(LOOKUP_TABLE_INSTRUCTION_LAYOUTS)) {\n      if (layout.index == index) {\n        type = layoutType;\n        break;\n      }\n    }\n    if (!type) {\n      throw new Error('Invalid Instruction. Should be a LookupTable Instruction');\n    }\n    return type;\n  }\n  static decodeCreateLookupTable(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeysLength(instruction.keys, 4);\n    const {\n      recentSlot\n    } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable, instruction.data);\n    return {\n      authority: instruction.keys[1].pubkey,\n      payer: instruction.keys[2].pubkey,\n      recentSlot: Number(recentSlot)\n    };\n  }\n  static decodeExtendLookupTable(instruction) {\n    this.checkProgramId(instruction.programId);\n    if (instruction.keys.length < 2) {\n      throw new Error(`invalid instruction; found ${instruction.keys.length} keys, expected at least 2`);\n    }\n    const {\n      addresses\n    } = decodeData$1(LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable, instruction.data);\n    return {\n      lookupTable: instruction.keys[0].pubkey,\n      authority: instruction.keys[1].pubkey,\n      payer: instruction.keys.length > 2 ? instruction.keys[2].pubkey : undefined,\n      addresses: addresses.map(buffer => new PublicKey(buffer))\n    };\n  }\n  static decodeCloseLookupTable(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeysLength(instruction.keys, 3);\n    return {\n      lookupTable: instruction.keys[0].pubkey,\n      authority: instruction.keys[1].pubkey,\n      recipient: instruction.keys[2].pubkey\n    };\n  }\n  static decodeFreezeLookupTable(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeysLength(instruction.keys, 2);\n    return {\n      lookupTable: instruction.keys[0].pubkey,\n      authority: instruction.keys[1].pubkey\n    };\n  }\n  static decodeDeactivateLookupTable(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeysLength(instruction.keys, 2);\n    return {\n      lookupTable: instruction.keys[0].pubkey,\n      authority: instruction.keys[1].pubkey\n    };\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId) {\n    if (!programId.equals(AddressLookupTableProgram.programId)) {\n      throw new Error('invalid instruction; programId is not AddressLookupTable Program');\n    }\n  }\n  /**\n   * @internal\n   */\n  static checkKeysLength(keys, expectedLength) {\n    if (keys.length < expectedLength) {\n      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n    }\n  }\n}\nclass AddressLookupTableProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n  static createLookupTable(params) {\n    const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([params.authority.toBuffer(), (0,bigint_buffer__WEBPACK_IMPORTED_MODULE_5__.toBufferLE)(BigInt(params.recentSlot), 8)], this.programId);\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;\n    const data = encodeData(type, {\n      recentSlot: BigInt(params.recentSlot),\n      bumpSeed: bumpSeed\n    });\n    const keys = [{\n      pubkey: lookupTableAddress,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: params.authority,\n      isSigner: true,\n      isWritable: false\n    }, {\n      pubkey: params.payer,\n      isSigner: true,\n      isWritable: true\n    }, {\n      pubkey: SystemProgram.programId,\n      isSigner: false,\n      isWritable: false\n    }];\n    return [new TransactionInstruction({\n      programId: this.programId,\n      keys: keys,\n      data: data\n    }), lookupTableAddress];\n  }\n  static freezeLookupTable(params) {\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;\n    const data = encodeData(type);\n    const keys = [{\n      pubkey: params.lookupTable,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: params.authority,\n      isSigner: true,\n      isWritable: false\n    }];\n    return new TransactionInstruction({\n      programId: this.programId,\n      keys: keys,\n      data: data\n    });\n  }\n  static extendLookupTable(params) {\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;\n    const data = encodeData(type, {\n      addresses: params.addresses.map(addr => addr.toBytes())\n    });\n    const keys = [{\n      pubkey: params.lookupTable,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: params.authority,\n      isSigner: true,\n      isWritable: false\n    }];\n    if (params.payer) {\n      keys.push({\n        pubkey: params.payer,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false\n      });\n    }\n    return new TransactionInstruction({\n      programId: this.programId,\n      keys: keys,\n      data: data\n    });\n  }\n  static deactivateLookupTable(params) {\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;\n    const data = encodeData(type);\n    const keys = [{\n      pubkey: params.lookupTable,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: params.authority,\n      isSigner: true,\n      isWritable: false\n    }];\n    return new TransactionInstruction({\n      programId: this.programId,\n      keys: keys,\n      data: data\n    });\n  }\n  static closeLookupTable(params) {\n    const type = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;\n    const data = encodeData(type);\n    const keys = [{\n      pubkey: params.lookupTable,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: params.authority,\n      isSigner: true,\n      isWritable: false\n    }, {\n      pubkey: params.recipient,\n      isSigner: false,\n      isWritable: true\n    }];\n    return new TransactionInstruction({\n      programId: this.programId,\n      keys: keys,\n      data: data\n    });\n  }\n}\nAddressLookupTableProgram.programId = new PublicKey('AddressLookupTab1e1111111111111111111111111');\n\n/**\n * Compute Budget Instruction class\n */\nclass ComputeBudgetInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Decode a compute budget instruction and retrieve the instruction type.\n   */\n  static decodeInstructionType(instruction) {\n    this.checkProgramId(instruction.programId);\n    const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('instruction');\n    const typeIndex = instructionTypeLayout.decode(instruction.data);\n    let type;\n    for (const [ixType, layout] of Object.entries(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS)) {\n      if (layout.index == typeIndex) {\n        type = ixType;\n        break;\n      }\n    }\n    if (!type) {\n      throw new Error('Instruction type incorrect; not a ComputeBudgetInstruction');\n    }\n    return type;\n  }\n\n  /**\n   * Decode request units compute budget instruction and retrieve the instruction params.\n   */\n  static decodeRequestUnits(instruction) {\n    this.checkProgramId(instruction.programId);\n    const {\n      units,\n      additionalFee\n    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits, instruction.data);\n    return {\n      units,\n      additionalFee\n    };\n  }\n\n  /**\n   * Decode request heap frame compute budget instruction and retrieve the instruction params.\n   */\n  static decodeRequestHeapFrame(instruction) {\n    this.checkProgramId(instruction.programId);\n    const {\n      bytes\n    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame, instruction.data);\n    return {\n      bytes\n    };\n  }\n\n  /**\n   * Decode set compute unit limit compute budget instruction and retrieve the instruction params.\n   */\n  static decodeSetComputeUnitLimit(instruction) {\n    this.checkProgramId(instruction.programId);\n    const {\n      units\n    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit, instruction.data);\n    return {\n      units\n    };\n  }\n\n  /**\n   * Decode set compute unit price compute budget instruction and retrieve the instruction params.\n   */\n  static decodeSetComputeUnitPrice(instruction) {\n    this.checkProgramId(instruction.programId);\n    const {\n      microLamports\n    } = decodeData$1(COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice, instruction.data);\n    return {\n      microLamports\n    };\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId) {\n    if (!programId.equals(ComputeBudgetProgram.programId)) {\n      throw new Error('invalid instruction; programId is not ComputeBudgetProgram');\n    }\n  }\n}\n\n/**\n * An enumeration of valid ComputeBudgetInstructionType's\n */\n\n/**\n * Request units instruction params\n */\n\n/**\n * Request heap frame instruction params\n */\n\n/**\n * Set compute unit limit instruction params\n */\n\n/**\n * Set compute unit price instruction params\n */\n\n/**\n * An enumeration of valid ComputeBudget InstructionType's\n * @internal\n */\nconst COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({\n  RequestUnits: {\n    index: 0,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('units'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('additionalFee')])\n  },\n  RequestHeapFrame: {\n    index: 1,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('bytes')])\n  },\n  SetComputeUnitLimit: {\n    index: 2,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('units')])\n  },\n  SetComputeUnitPrice: {\n    index: 3,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('instruction'), u64('microLamports')])\n  }\n});\n\n/**\n * Factory class for transaction instructions to interact with the Compute Budget program\n */\nclass ComputeBudgetProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the Compute Budget program\n   */\n\n  /**\n   * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}\n   */\n  static requestUnits(params) {\n    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;\n    const data = encodeData(type, params);\n    return new TransactionInstruction({\n      keys: [],\n      programId: this.programId,\n      data\n    });\n  }\n  static requestHeapFrame(params) {\n    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;\n    const data = encodeData(type, params);\n    return new TransactionInstruction({\n      keys: [],\n      programId: this.programId,\n      data\n    });\n  }\n  static setComputeUnitLimit(params) {\n    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;\n    const data = encodeData(type, params);\n    return new TransactionInstruction({\n      keys: [],\n      programId: this.programId,\n      data\n    });\n  }\n  static setComputeUnitPrice(params) {\n    const type = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;\n    const data = encodeData(type, {\n      microLamports: BigInt(params.microLamports)\n    });\n    return new TransactionInstruction({\n      keys: [],\n      programId: this.programId,\n      data\n    });\n  }\n}\nComputeBudgetProgram.programId = new PublicKey('ComputeBudget111111111111111111111111111111');\n\nconst PRIVATE_KEY_BYTES$1 = 64;\nconst PUBLIC_KEY_BYTES$1 = 32;\nconst SIGNATURE_BYTES = 64;\n\n/**\n * Params for creating an ed25519 instruction using a public key\n */\n\n/**\n * Params for creating an ed25519 instruction using a private key\n */\n\nconst ED25519_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('numSignatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('padding'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16('signatureOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16('signatureInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16('publicKeyOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16('publicKeyInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16('messageDataOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16('messageDataSize'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16('messageInstructionIndex')]);\nclass Ed25519Program {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the ed25519 program\n   */\n\n  /**\n   * Create an ed25519 instruction with a public key and signature. The\n   * public key must be a buffer that is 32 bytes long, and the signature\n   * must be a buffer of 64 bytes.\n   */\n  static createInstructionWithPublicKey(params) {\n    const {\n      publicKey,\n      message,\n      signature,\n      instructionIndex\n    } = params;\n    assert(publicKey.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey.length} bytes`);\n    assert(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);\n    const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;\n    const signatureOffset = publicKeyOffset + publicKey.length;\n    const messageDataOffset = signatureOffset + signature.length;\n    const numSignatures = 1;\n    const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(messageDataOffset + message.length);\n    const index = instructionIndex == null ? 0xffff // An index of `u16::MAX` makes it default to the current instruction.\n    : instructionIndex;\n    ED25519_INSTRUCTION_LAYOUT.encode({\n      numSignatures,\n      padding: 0,\n      signatureOffset,\n      signatureInstructionIndex: index,\n      publicKeyOffset,\n      publicKeyInstructionIndex: index,\n      messageDataOffset,\n      messageDataSize: message.length,\n      messageInstructionIndex: index\n    }, instructionData);\n    instructionData.fill(publicKey, publicKeyOffset);\n    instructionData.fill(signature, signatureOffset);\n    instructionData.fill(message, messageDataOffset);\n    return new TransactionInstruction({\n      keys: [],\n      programId: Ed25519Program.programId,\n      data: instructionData\n    });\n  }\n\n  /**\n   * Create an ed25519 instruction with a private key. The private key\n   * must be a buffer that is 64 bytes long.\n   */\n  static createInstructionWithPrivateKey(params) {\n    const {\n      privateKey,\n      message,\n      instructionIndex\n    } = params;\n    assert(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);\n    try {\n      const keypair = Keypair.fromSecretKey(privateKey);\n      const publicKey = keypair.publicKey.toBytes();\n      const signature = sign(message, keypair.secretKey);\n      return this.createInstructionWithPublicKey({\n        publicKey,\n        message,\n        signature,\n        instructionIndex\n      });\n    } catch (error) {\n      throw new Error(`Error creating instruction; ${error}`);\n    }\n  }\n}\nEd25519Program.programId = new PublicKey('Ed25519SigVerify111111111111111111111111111');\n\nconst ecdsaSign = (msgHash, privKey) => {\n  const signature = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_12__.secp256k1.sign(msgHash, privKey);\n  return [signature.toCompactRawBytes(), signature.recovery];\n};\n_noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_12__.secp256k1.utils.isValidPrivateKey;\nconst publicKeyCreate = _noble_curves_secp256k1__WEBPACK_IMPORTED_MODULE_12__.secp256k1.getPublicKey;\n\nconst PRIVATE_KEY_BYTES = 32;\nconst ETHEREUM_ADDRESS_BYTES = 20;\nconst PUBLIC_KEY_BYTES = 64;\nconst SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;\n\n/**\n * Params for creating an secp256k1 instruction using a public key\n */\n\n/**\n * Params for creating an secp256k1 instruction using an Ethereum address\n */\n\n/**\n * Params for creating an secp256k1 instruction using a private key\n */\n\nconst SECP256K1_INSTRUCTION_LAYOUT = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('numSignatures'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16('signatureOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('signatureInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16('ethAddressOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('ethAddressInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16('messageDataOffset'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u16('messageDataSize'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('messageInstructionIndex'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(20, 'ethAddress'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.blob(64, 'signature'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('recoveryId')]);\nclass Secp256k1Program {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the secp256k1 program\n   */\n\n  /**\n   * Construct an Ethereum address from a secp256k1 public key buffer.\n   * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer\n   */\n  static publicKeyToEthAddress(publicKey) {\n    assert(publicKey.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey.length} bytes`);\n    try {\n      return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_13__.keccak_256)(toBuffer(publicKey))).slice(-ETHEREUM_ADDRESS_BYTES);\n    } catch (error) {\n      throw new Error(`Error constructing Ethereum address: ${error}`);\n    }\n  }\n\n  /**\n   * Create an secp256k1 instruction with a public key. The public key\n   * must be a buffer that is 64 bytes long.\n   */\n  static createInstructionWithPublicKey(params) {\n    const {\n      publicKey,\n      message,\n      signature,\n      recoveryId,\n      instructionIndex\n    } = params;\n    return Secp256k1Program.createInstructionWithEthAddress({\n      ethAddress: Secp256k1Program.publicKeyToEthAddress(publicKey),\n      message,\n      signature,\n      recoveryId,\n      instructionIndex\n    });\n  }\n\n  /**\n   * Create an secp256k1 instruction with an Ethereum address. The address\n   * must be a hex string or a buffer that is 20 bytes long.\n   */\n  static createInstructionWithEthAddress(params) {\n    const {\n      ethAddress: rawAddress,\n      message,\n      signature,\n      recoveryId,\n      instructionIndex = 0\n    } = params;\n    let ethAddress;\n    if (typeof rawAddress === 'string') {\n      if (rawAddress.startsWith('0x')) {\n        ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress.substr(2), 'hex');\n      } else {\n        ethAddress = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(rawAddress, 'hex');\n      }\n    } else {\n      ethAddress = rawAddress;\n    }\n    assert(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);\n    const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n    const ethAddressOffset = dataStart;\n    const signatureOffset = dataStart + ethAddress.length;\n    const messageDataOffset = signatureOffset + signature.length + 1;\n    const numSignatures = 1;\n    const instructionData = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);\n    SECP256K1_INSTRUCTION_LAYOUT.encode({\n      numSignatures,\n      signatureOffset,\n      signatureInstructionIndex: instructionIndex,\n      ethAddressOffset,\n      ethAddressInstructionIndex: instructionIndex,\n      messageDataOffset,\n      messageDataSize: message.length,\n      messageInstructionIndex: instructionIndex,\n      signature: toBuffer(signature),\n      ethAddress: toBuffer(ethAddress),\n      recoveryId\n    }, instructionData);\n    instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);\n    return new TransactionInstruction({\n      keys: [],\n      programId: Secp256k1Program.programId,\n      data: instructionData\n    });\n  }\n\n  /**\n   * Create an secp256k1 instruction with a private key. The private key\n   * must be a buffer that is 32 bytes long.\n   */\n  static createInstructionWithPrivateKey(params) {\n    const {\n      privateKey: pkey,\n      message,\n      instructionIndex\n    } = params;\n    assert(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);\n    try {\n      const privateKey = toBuffer(pkey);\n      const publicKey = publicKeyCreate(privateKey, false /* isCompressed */).slice(1); // throw away leading byte\n      const messageHash = buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from((0,_noble_hashes_sha3__WEBPACK_IMPORTED_MODULE_13__.keccak_256)(toBuffer(message)));\n      const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);\n      return this.createInstructionWithPublicKey({\n        publicKey,\n        message,\n        signature,\n        recoveryId,\n        instructionIndex\n      });\n    } catch (error) {\n      throw new Error(`Error creating instruction; ${error}`);\n    }\n  }\n}\nSecp256k1Program.programId = new PublicKey('KeccakSecp256k11111111111111111111111111111');\n\nvar _Lockup;\n\n/**\n * Address of the stake config account which configures the rate\n * of stake warmup and cooldown as well as the slashing penalty.\n */\nconst STAKE_CONFIG_ID = new PublicKey('StakeConfig11111111111111111111111111111111');\n\n/**\n * Stake account authority info\n */\nclass Authorized {\n  /**\n   * Create a new Authorized object\n   * @param staker the stake authority\n   * @param withdrawer the withdraw authority\n   */\n  constructor(staker, withdrawer) {\n    /** stake authority */\n    this.staker = void 0;\n    /** withdraw authority */\n    this.withdrawer = void 0;\n    this.staker = staker;\n    this.withdrawer = withdrawer;\n  }\n}\n/**\n * Stake account lockup info\n */\nclass Lockup {\n  /**\n   * Create a new Lockup object\n   */\n  constructor(unixTimestamp, epoch, custodian) {\n    /** Unix timestamp of lockup expiration */\n    this.unixTimestamp = void 0;\n    /** Epoch of lockup expiration */\n    this.epoch = void 0;\n    /** Lockup custodian authority */\n    this.custodian = void 0;\n    this.unixTimestamp = unixTimestamp;\n    this.epoch = epoch;\n    this.custodian = custodian;\n  }\n\n  /**\n   * Default, inactive Lockup value\n   */\n}\n_Lockup = Lockup;\nLockup.default = new _Lockup(0, 0, PublicKey.default);\n/**\n * Create stake account transaction params\n */\n/**\n * Create stake account with seed transaction params\n */\n/**\n * Initialize stake instruction params\n */\n/**\n * Delegate stake instruction params\n */\n/**\n * Authorize stake instruction params\n */\n/**\n * Authorize stake instruction params using a derived key\n */\n/**\n * Split stake instruction params\n */\n/**\n * Split with seed transaction params\n */\n/**\n * Withdraw stake instruction params\n */\n/**\n * Deactivate stake instruction params\n */\n/**\n * Merge stake instruction params\n */\n/**\n * Stake Instruction class\n */\nclass StakeInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Decode a stake instruction and retrieve the instruction type.\n   */\n  static decodeInstructionType(instruction) {\n    this.checkProgramId(instruction.programId);\n    const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction');\n    const typeIndex = instructionTypeLayout.decode(instruction.data);\n    let type;\n    for (const [ixType, layout] of Object.entries(STAKE_INSTRUCTION_LAYOUTS)) {\n      if (layout.index == typeIndex) {\n        type = ixType;\n        break;\n      }\n    }\n    if (!type) {\n      throw new Error('Instruction type incorrect; not a StakeInstruction');\n    }\n    return type;\n  }\n\n  /**\n   * Decode a initialize stake instruction and retrieve the instruction params.\n   */\n  static decodeInitialize(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 2);\n    const {\n      authorized,\n      lockup\n    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Initialize, instruction.data);\n    return {\n      stakePubkey: instruction.keys[0].pubkey,\n      authorized: new Authorized(new PublicKey(authorized.staker), new PublicKey(authorized.withdrawer)),\n      lockup: new Lockup(lockup.unixTimestamp, lockup.epoch, new PublicKey(lockup.custodian))\n    };\n  }\n\n  /**\n   * Decode a delegate stake instruction and retrieve the instruction params.\n   */\n  static decodeDelegate(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 6);\n    decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Delegate, instruction.data);\n    return {\n      stakePubkey: instruction.keys[0].pubkey,\n      votePubkey: instruction.keys[1].pubkey,\n      authorizedPubkey: instruction.keys[5].pubkey\n    };\n  }\n\n  /**\n   * Decode an authorize stake instruction and retrieve the instruction params.\n   */\n  static decodeAuthorize(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    const {\n      newAuthorized,\n      stakeAuthorizationType\n    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n    const o = {\n      stakePubkey: instruction.keys[0].pubkey,\n      authorizedPubkey: instruction.keys[2].pubkey,\n      newAuthorizedPubkey: new PublicKey(newAuthorized),\n      stakeAuthorizationType: {\n        index: stakeAuthorizationType\n      }\n    };\n    if (instruction.keys.length > 3) {\n      o.custodianPubkey = instruction.keys[3].pubkey;\n    }\n    return o;\n  }\n\n  /**\n   * Decode an authorize-with-seed stake instruction and retrieve the instruction params.\n   */\n  static decodeAuthorizeWithSeed(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 2);\n    const {\n      newAuthorized,\n      stakeAuthorizationType,\n      authoritySeed,\n      authorityOwner\n    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n    const o = {\n      stakePubkey: instruction.keys[0].pubkey,\n      authorityBase: instruction.keys[1].pubkey,\n      authoritySeed: authoritySeed,\n      authorityOwner: new PublicKey(authorityOwner),\n      newAuthorizedPubkey: new PublicKey(newAuthorized),\n      stakeAuthorizationType: {\n        index: stakeAuthorizationType\n      }\n    };\n    if (instruction.keys.length > 3) {\n      o.custodianPubkey = instruction.keys[3].pubkey;\n    }\n    return o;\n  }\n\n  /**\n   * Decode a split stake instruction and retrieve the instruction params.\n   */\n  static decodeSplit(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    const {\n      lamports\n    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Split, instruction.data);\n    return {\n      stakePubkey: instruction.keys[0].pubkey,\n      splitStakePubkey: instruction.keys[1].pubkey,\n      authorizedPubkey: instruction.keys[2].pubkey,\n      lamports\n    };\n  }\n\n  /**\n   * Decode a merge stake instruction and retrieve the instruction params.\n   */\n  static decodeMerge(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Merge, instruction.data);\n    return {\n      stakePubkey: instruction.keys[0].pubkey,\n      sourceStakePubKey: instruction.keys[1].pubkey,\n      authorizedPubkey: instruction.keys[4].pubkey\n    };\n  }\n\n  /**\n   * Decode a withdraw stake instruction and retrieve the instruction params.\n   */\n  static decodeWithdraw(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 5);\n    const {\n      lamports\n    } = decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n    const o = {\n      stakePubkey: instruction.keys[0].pubkey,\n      toPubkey: instruction.keys[1].pubkey,\n      authorizedPubkey: instruction.keys[4].pubkey,\n      lamports\n    };\n    if (instruction.keys.length > 5) {\n      o.custodianPubkey = instruction.keys[5].pubkey;\n    }\n    return o;\n  }\n\n  /**\n   * Decode a deactivate stake instruction and retrieve the instruction params.\n   */\n  static decodeDeactivate(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    decodeData$1(STAKE_INSTRUCTION_LAYOUTS.Deactivate, instruction.data);\n    return {\n      stakePubkey: instruction.keys[0].pubkey,\n      authorizedPubkey: instruction.keys[2].pubkey\n    };\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId) {\n    if (!programId.equals(StakeProgram.programId)) {\n      throw new Error('invalid instruction; programId is not StakeProgram');\n    }\n  }\n\n  /**\n   * @internal\n   */\n  static checkKeyLength(keys, expectedLength) {\n    if (keys.length < expectedLength) {\n      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n    }\n  }\n}\n\n/**\n * An enumeration of valid StakeInstructionType's\n */\n\n/**\n * An enumeration of valid stake InstructionType's\n * @internal\n */\nconst STAKE_INSTRUCTION_LAYOUTS = Object.freeze({\n  Initialize: {\n    index: 0,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), authorized(), lockup()])\n  },\n  Authorize: {\n    index: 1,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), publicKey('newAuthorized'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('stakeAuthorizationType')])\n  },\n  Delegate: {\n    index: 2,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction')])\n  },\n  Split: {\n    index: 3,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64('lamports')])\n  },\n  Withdraw: {\n    index: 4,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64('lamports')])\n  },\n  Deactivate: {\n    index: 5,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction')])\n  },\n  Merge: {\n    index: 7,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction')])\n  },\n  AuthorizeWithSeed: {\n    index: 8,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), publicKey('newAuthorized'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('stakeAuthorizationType'), rustString('authoritySeed'), publicKey('authorityOwner')])\n  }\n});\n\n/**\n * Stake authorization type\n */\n\n/**\n * An enumeration of valid StakeAuthorizationLayout's\n */\nconst StakeAuthorizationLayout = Object.freeze({\n  Staker: {\n    index: 0\n  },\n  Withdrawer: {\n    index: 1\n  }\n});\n\n/**\n * Factory class for transactions to interact with the Stake program\n */\nclass StakeProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the Stake program\n   */\n\n  /**\n   * Generate an Initialize instruction to add to a Stake Create transaction\n   */\n  static initialize(params) {\n    const {\n      stakePubkey,\n      authorized,\n      lockup: maybeLockup\n    } = params;\n    const lockup = maybeLockup || Lockup.default;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Initialize;\n    const data = encodeData(type, {\n      authorized: {\n        staker: toBuffer(authorized.staker.toBuffer()),\n        withdrawer: toBuffer(authorized.withdrawer.toBuffer())\n      },\n      lockup: {\n        unixTimestamp: lockup.unixTimestamp,\n        epoch: lockup.epoch,\n        custodian: toBuffer(lockup.custodian.toBuffer())\n      }\n    });\n    const instructionData = {\n      keys: [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    };\n    return new TransactionInstruction(instructionData);\n  }\n\n  /**\n   * Generate a Transaction that creates a new Stake account at\n   *   an address generated with `from`, a seed, and the Stake programId\n   */\n  static createAccountWithSeed(params) {\n    const transaction = new Transaction();\n    transaction.add(SystemProgram.createAccountWithSeed({\n      fromPubkey: params.fromPubkey,\n      newAccountPubkey: params.stakePubkey,\n      basePubkey: params.basePubkey,\n      seed: params.seed,\n      lamports: params.lamports,\n      space: this.space,\n      programId: this.programId\n    }));\n    const {\n      stakePubkey,\n      authorized,\n      lockup\n    } = params;\n    return transaction.add(this.initialize({\n      stakePubkey,\n      authorized,\n      lockup\n    }));\n  }\n\n  /**\n   * Generate a Transaction that creates a new Stake account\n   */\n  static createAccount(params) {\n    const transaction = new Transaction();\n    transaction.add(SystemProgram.createAccount({\n      fromPubkey: params.fromPubkey,\n      newAccountPubkey: params.stakePubkey,\n      lamports: params.lamports,\n      space: this.space,\n      programId: this.programId\n    }));\n    const {\n      stakePubkey,\n      authorized,\n      lockup\n    } = params;\n    return transaction.add(this.initialize({\n      stakePubkey,\n      authorized,\n      lockup\n    }));\n  }\n\n  /**\n   * Generate a Transaction that delegates Stake tokens to a validator\n   * Vote PublicKey. This transaction can also be used to redelegate Stake\n   * to a new validator Vote PublicKey.\n   */\n  static delegate(params) {\n    const {\n      stakePubkey,\n      authorizedPubkey,\n      votePubkey\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Delegate;\n    const data = encodeData(type);\n    return new Transaction().add({\n      keys: [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: votePubkey,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: STAKE_CONFIG_ID,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */\n  static authorize(params) {\n    const {\n      stakePubkey,\n      authorizedPubkey,\n      newAuthorizedPubkey,\n      stakeAuthorizationType,\n      custodianPubkey\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Authorize;\n    const data = encodeData(type, {\n      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n      stakeAuthorizationType: stakeAuthorizationType.index\n    });\n    const keys = [{\n      pubkey: stakePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: SYSVAR_CLOCK_PUBKEY,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: authorizedPubkey,\n      isSigner: true,\n      isWritable: false\n    }];\n    if (custodianPubkey) {\n      keys.push({\n        pubkey: custodianPubkey,\n        isSigner: true,\n        isWritable: false\n      });\n    }\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a Transaction that authorizes a new PublicKey as Staker\n   * or Withdrawer on the Stake account.\n   */\n  static authorizeWithSeed(params) {\n    const {\n      stakePubkey,\n      authorityBase,\n      authoritySeed,\n      authorityOwner,\n      newAuthorizedPubkey,\n      stakeAuthorizationType,\n      custodianPubkey\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n    const data = encodeData(type, {\n      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n      stakeAuthorizationType: stakeAuthorizationType.index,\n      authoritySeed: authoritySeed,\n      authorityOwner: toBuffer(authorityOwner.toBuffer())\n    });\n    const keys = [{\n      pubkey: stakePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: authorityBase,\n      isSigner: true,\n      isWritable: false\n    }, {\n      pubkey: SYSVAR_CLOCK_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }];\n    if (custodianPubkey) {\n      keys.push({\n        pubkey: custodianPubkey,\n        isSigner: true,\n        isWritable: false\n      });\n    }\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * @internal\n   */\n  static splitInstruction(params) {\n    const {\n      stakePubkey,\n      authorizedPubkey,\n      splitStakePubkey,\n      lamports\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Split;\n    const data = encodeData(type, {\n      lamports\n    });\n    return new TransactionInstruction({\n      keys: [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: splitStakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a Transaction that splits Stake tokens into another stake account\n   */\n  static split(params,\n  // Compute the cost of allocating the new stake account in lamports\n  rentExemptReserve) {\n    const transaction = new Transaction();\n    transaction.add(SystemProgram.createAccount({\n      fromPubkey: params.authorizedPubkey,\n      newAccountPubkey: params.splitStakePubkey,\n      lamports: rentExemptReserve,\n      space: this.space,\n      programId: this.programId\n    }));\n    return transaction.add(this.splitInstruction(params));\n  }\n\n  /**\n   * Generate a Transaction that splits Stake tokens into another account\n   * derived from a base public key and seed\n   */\n  static splitWithSeed(params,\n  // If this stake account is new, compute the cost of allocating it in lamports\n  rentExemptReserve) {\n    const {\n      stakePubkey,\n      authorizedPubkey,\n      splitStakePubkey,\n      basePubkey,\n      seed,\n      lamports\n    } = params;\n    const transaction = new Transaction();\n    transaction.add(SystemProgram.allocate({\n      accountPubkey: splitStakePubkey,\n      basePubkey,\n      seed,\n      space: this.space,\n      programId: this.programId\n    }));\n    if (rentExemptReserve && rentExemptReserve > 0) {\n      transaction.add(SystemProgram.transfer({\n        fromPubkey: params.authorizedPubkey,\n        toPubkey: splitStakePubkey,\n        lamports: rentExemptReserve\n      }));\n    }\n    return transaction.add(this.splitInstruction({\n      stakePubkey,\n      authorizedPubkey,\n      splitStakePubkey,\n      lamports\n    }));\n  }\n\n  /**\n   * Generate a Transaction that merges Stake accounts.\n   */\n  static merge(params) {\n    const {\n      stakePubkey,\n      sourceStakePubKey,\n      authorizedPubkey\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Merge;\n    const data = encodeData(type);\n    return new Transaction().add({\n      keys: [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: sourceStakePubKey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a Transaction that withdraws deactivated Stake tokens.\n   */\n  static withdraw(params) {\n    const {\n      stakePubkey,\n      authorizedPubkey,\n      toPubkey,\n      lamports,\n      custodianPubkey\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Withdraw;\n    const data = encodeData(type, {\n      lamports\n    });\n    const keys = [{\n      pubkey: stakePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: toPubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: SYSVAR_CLOCK_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: authorizedPubkey,\n      isSigner: true,\n      isWritable: false\n    }];\n    if (custodianPubkey) {\n      keys.push({\n        pubkey: custodianPubkey,\n        isSigner: true,\n        isWritable: false\n      });\n    }\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a Transaction that deactivates Stake tokens.\n   */\n  static deactivate(params) {\n    const {\n      stakePubkey,\n      authorizedPubkey\n    } = params;\n    const type = STAKE_INSTRUCTION_LAYOUTS.Deactivate;\n    const data = encodeData(type);\n    return new Transaction().add({\n      keys: [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    });\n  }\n}\nStakeProgram.programId = new PublicKey('Stake11111111111111111111111111111111111111');\n/**\n * Max space of a Stake account\n *\n * This is generated from the solana-stake-program StakeState struct as\n * `StakeStateV2::size_of()`:\n * https://docs.rs/solana-stake-program/latest/solana_stake_program/stake_state/enum.StakeStateV2.html\n */\nStakeProgram.space = 200;\n\n/**\n * Vote account info\n */\nclass VoteInit {\n  /** [0, 100] */\n\n  constructor(nodePubkey, authorizedVoter, authorizedWithdrawer, commission) {\n    this.nodePubkey = void 0;\n    this.authorizedVoter = void 0;\n    this.authorizedWithdrawer = void 0;\n    this.commission = void 0;\n    this.nodePubkey = nodePubkey;\n    this.authorizedVoter = authorizedVoter;\n    this.authorizedWithdrawer = authorizedWithdrawer;\n    this.commission = commission;\n  }\n}\n\n/**\n * Create vote account transaction params\n */\n\n/**\n * InitializeAccount instruction params\n */\n\n/**\n * Authorize instruction params\n */\n\n/**\n * AuthorizeWithSeed instruction params\n */\n\n/**\n * Withdraw from vote account transaction params\n */\n\n/**\n * Update validator identity (node pubkey) vote account instruction params.\n */\n\n/**\n * Vote Instruction class\n */\nclass VoteInstruction {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Decode a vote instruction and retrieve the instruction type.\n   */\n  static decodeInstructionType(instruction) {\n    this.checkProgramId(instruction.programId);\n    const instructionTypeLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction');\n    const typeIndex = instructionTypeLayout.decode(instruction.data);\n    let type;\n    for (const [ixType, layout] of Object.entries(VOTE_INSTRUCTION_LAYOUTS)) {\n      if (layout.index == typeIndex) {\n        type = ixType;\n        break;\n      }\n    }\n    if (!type) {\n      throw new Error('Instruction type incorrect; not a VoteInstruction');\n    }\n    return type;\n  }\n\n  /**\n   * Decode an initialize vote instruction and retrieve the instruction params.\n   */\n  static decodeInitializeAccount(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 4);\n    const {\n      voteInit\n    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.InitializeAccount, instruction.data);\n    return {\n      votePubkey: instruction.keys[0].pubkey,\n      nodePubkey: instruction.keys[3].pubkey,\n      voteInit: new VoteInit(new PublicKey(voteInit.nodePubkey), new PublicKey(voteInit.authorizedVoter), new PublicKey(voteInit.authorizedWithdrawer), voteInit.commission)\n    };\n  }\n\n  /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */\n  static decodeAuthorize(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    const {\n      newAuthorized,\n      voteAuthorizationType\n    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Authorize, instruction.data);\n    return {\n      votePubkey: instruction.keys[0].pubkey,\n      authorizedPubkey: instruction.keys[2].pubkey,\n      newAuthorizedPubkey: new PublicKey(newAuthorized),\n      voteAuthorizationType: {\n        index: voteAuthorizationType\n      }\n    };\n  }\n\n  /**\n   * Decode an authorize instruction and retrieve the instruction params.\n   */\n  static decodeAuthorizeWithSeed(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    const {\n      voteAuthorizeWithSeedArgs: {\n        currentAuthorityDerivedKeyOwnerPubkey,\n        currentAuthorityDerivedKeySeed,\n        newAuthorized,\n        voteAuthorizationType\n      }\n    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed, instruction.data);\n    return {\n      currentAuthorityDerivedKeyBasePubkey: instruction.keys[2].pubkey,\n      currentAuthorityDerivedKeyOwnerPubkey: new PublicKey(currentAuthorityDerivedKeyOwnerPubkey),\n      currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n      newAuthorizedPubkey: new PublicKey(newAuthorized),\n      voteAuthorizationType: {\n        index: voteAuthorizationType\n      },\n      votePubkey: instruction.keys[0].pubkey\n    };\n  }\n\n  /**\n   * Decode a withdraw instruction and retrieve the instruction params.\n   */\n  static decodeWithdraw(instruction) {\n    this.checkProgramId(instruction.programId);\n    this.checkKeyLength(instruction.keys, 3);\n    const {\n      lamports\n    } = decodeData$1(VOTE_INSTRUCTION_LAYOUTS.Withdraw, instruction.data);\n    return {\n      votePubkey: instruction.keys[0].pubkey,\n      authorizedWithdrawerPubkey: instruction.keys[2].pubkey,\n      lamports,\n      toPubkey: instruction.keys[1].pubkey\n    };\n  }\n\n  /**\n   * @internal\n   */\n  static checkProgramId(programId) {\n    if (!programId.equals(VoteProgram.programId)) {\n      throw new Error('invalid instruction; programId is not VoteProgram');\n    }\n  }\n\n  /**\n   * @internal\n   */\n  static checkKeyLength(keys, expectedLength) {\n    if (keys.length < expectedLength) {\n      throw new Error(`invalid instruction; found ${keys.length} keys, expected at least ${expectedLength}`);\n    }\n  }\n}\n\n/**\n * An enumeration of valid VoteInstructionType's\n */\n\n/** @internal */\n\nconst VOTE_INSTRUCTION_LAYOUTS = Object.freeze({\n  InitializeAccount: {\n    index: 0,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), voteInit()])\n  },\n  Authorize: {\n    index: 1,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), publicKey('newAuthorized'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('voteAuthorizationType')])\n  },\n  Withdraw: {\n    index: 3,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.ns64('lamports')])\n  },\n  UpdateValidatorIdentity: {\n    index: 4,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction')])\n  },\n  AuthorizeWithSeed: {\n    index: 10,\n    layout: _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('instruction'), voteAuthorizeWithSeedArgs()])\n  }\n});\n\n/**\n * VoteAuthorize type\n */\n\n/**\n * An enumeration of valid VoteAuthorization layouts.\n */\nconst VoteAuthorizationLayout = Object.freeze({\n  Voter: {\n    index: 0\n  },\n  Withdrawer: {\n    index: 1\n  }\n});\n\n/**\n * Factory class for transactions to interact with the Vote program\n */\nclass VoteProgram {\n  /**\n   * @internal\n   */\n  constructor() {}\n\n  /**\n   * Public key that identifies the Vote program\n   */\n\n  /**\n   * Generate an Initialize instruction.\n   */\n  static initializeAccount(params) {\n    const {\n      votePubkey,\n      nodePubkey,\n      voteInit\n    } = params;\n    const type = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;\n    const data = encodeData(type, {\n      voteInit: {\n        nodePubkey: toBuffer(voteInit.nodePubkey.toBuffer()),\n        authorizedVoter: toBuffer(voteInit.authorizedVoter.toBuffer()),\n        authorizedWithdrawer: toBuffer(voteInit.authorizedWithdrawer.toBuffer()),\n        commission: voteInit.commission\n      }\n    });\n    const instructionData = {\n      keys: [{\n        pubkey: votePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_RENT_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: nodePubkey,\n        isSigner: true,\n        isWritable: false\n      }],\n      programId: this.programId,\n      data\n    };\n    return new TransactionInstruction(instructionData);\n  }\n\n  /**\n   * Generate a transaction that creates a new Vote account.\n   */\n  static createAccount(params) {\n    const transaction = new Transaction();\n    transaction.add(SystemProgram.createAccount({\n      fromPubkey: params.fromPubkey,\n      newAccountPubkey: params.votePubkey,\n      lamports: params.lamports,\n      space: this.space,\n      programId: this.programId\n    }));\n    return transaction.add(this.initializeAccount({\n      votePubkey: params.votePubkey,\n      nodePubkey: params.voteInit.nodePubkey,\n      voteInit: params.voteInit\n    }));\n  }\n\n  /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.\n   */\n  static authorize(params) {\n    const {\n      votePubkey,\n      authorizedPubkey,\n      newAuthorizedPubkey,\n      voteAuthorizationType\n    } = params;\n    const type = VOTE_INSTRUCTION_LAYOUTS.Authorize;\n    const data = encodeData(type, {\n      newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n      voteAuthorizationType: voteAuthorizationType.index\n    });\n    const keys = [{\n      pubkey: votePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: SYSVAR_CLOCK_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: authorizedPubkey,\n      isSigner: true,\n      isWritable: false\n    }];\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account\n   * where the current Voter or Withdrawer authority is a derived key.\n   */\n  static authorizeWithSeed(params) {\n    const {\n      currentAuthorityDerivedKeyBasePubkey,\n      currentAuthorityDerivedKeyOwnerPubkey,\n      currentAuthorityDerivedKeySeed,\n      newAuthorizedPubkey,\n      voteAuthorizationType,\n      votePubkey\n    } = params;\n    const type = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n    const data = encodeData(type, {\n      voteAuthorizeWithSeedArgs: {\n        currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),\n        currentAuthorityDerivedKeySeed: currentAuthorityDerivedKeySeed,\n        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n        voteAuthorizationType: voteAuthorizationType.index\n      }\n    });\n    const keys = [{\n      pubkey: votePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: SYSVAR_CLOCK_PUBKEY,\n      isSigner: false,\n      isWritable: false\n    }, {\n      pubkey: currentAuthorityDerivedKeyBasePubkey,\n      isSigner: true,\n      isWritable: false\n    }];\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction to withdraw from a Vote account.\n   */\n  static withdraw(params) {\n    const {\n      votePubkey,\n      authorizedWithdrawerPubkey,\n      lamports,\n      toPubkey\n    } = params;\n    const type = VOTE_INSTRUCTION_LAYOUTS.Withdraw;\n    const data = encodeData(type, {\n      lamports\n    });\n    const keys = [{\n      pubkey: votePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: toPubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: authorizedWithdrawerPubkey,\n      isSigner: true,\n      isWritable: false\n    }];\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n\n  /**\n   * Generate a transaction to withdraw safely from a Vote account.\n   *\n   * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`\n   * checks that the withdraw amount will not exceed the specified balance while leaving enough left\n   * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the\n   * `withdraw` method directly.\n   */\n  static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {\n    if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {\n      throw new Error('Withdraw will leave vote account with insufficient funds.');\n    }\n    return VoteProgram.withdraw(params);\n  }\n\n  /**\n   * Generate a transaction to update the validator identity (node pubkey) of a Vote account.\n   */\n  static updateValidatorIdentity(params) {\n    const {\n      votePubkey,\n      authorizedWithdrawerPubkey,\n      nodePubkey\n    } = params;\n    const type = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;\n    const data = encodeData(type);\n    const keys = [{\n      pubkey: votePubkey,\n      isSigner: false,\n      isWritable: true\n    }, {\n      pubkey: nodePubkey,\n      isSigner: true,\n      isWritable: false\n    }, {\n      pubkey: authorizedWithdrawerPubkey,\n      isSigner: true,\n      isWritable: false\n    }];\n    return new Transaction().add({\n      keys,\n      programId: this.programId,\n      data\n    });\n  }\n}\nVoteProgram.programId = new PublicKey('Vote111111111111111111111111111111111111111');\n/**\n * Max space of a Vote account\n *\n * This is generated from the solana-vote-program VoteState struct as\n * `VoteState::size_of()`:\n * https://docs.rs/solana-vote-program/1.9.5/solana_vote_program/vote_state/struct.VoteState.html#method.size_of\n *\n * KEEP IN SYNC WITH `VoteState::size_of()` in https://github.com/solana-labs/solana/blob/a474cb24b9238f5edcc982f65c0b37d4a1046f7e/sdk/program/src/vote/state/mod.rs#L340-L342\n */\nVoteProgram.space = 3762;\n\nconst VALIDATOR_INFO_KEY = new PublicKey('Va1idator1nfo111111111111111111111111111111');\n\n/**\n * @internal\n */\n\n/**\n * Info used to identity validators.\n */\n\nconst InfoString = (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.type)({\n  name: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)(),\n  website: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()),\n  details: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)()),\n  keybaseUsername: (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.optional)((0,superstruct__WEBPACK_IMPORTED_MODULE_11__.string)())\n});\n\n/**\n * ValidatorInfo class\n */\nclass ValidatorInfo {\n  /**\n   * Construct a valid ValidatorInfo\n   *\n   * @param key validator public key\n   * @param info validator information\n   */\n  constructor(key, info) {\n    /**\n     * validator public key\n     */\n    this.key = void 0;\n    /**\n     * validator information\n     */\n    this.info = void 0;\n    this.key = key;\n    this.info = info;\n  }\n\n  /**\n   * Deserialize ValidatorInfo from the config account data. Exactly two config\n   * keys are required in the data.\n   *\n   * @param buffer config account data\n   * @return null if info was not found\n   */\n  static fromConfigData(buffer) {\n    let byteArray = [...buffer];\n    const configKeyCount = decodeLength(byteArray);\n    if (configKeyCount !== 2) return null;\n    const configKeys = [];\n    for (let i = 0; i < 2; i++) {\n      const publicKey = new PublicKey(guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH));\n      const isSigner = guardedShift(byteArray) === 1;\n      configKeys.push({\n        publicKey,\n        isSigner\n      });\n    }\n    if (configKeys[0].publicKey.equals(VALIDATOR_INFO_KEY)) {\n      if (configKeys[1].isSigner) {\n        const rawInfo = rustString().decode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(byteArray));\n        const info = JSON.parse(rawInfo);\n        (0,superstruct__WEBPACK_IMPORTED_MODULE_11__.assert)(info, InfoString);\n        return new ValidatorInfo(configKeys[1].publicKey, info);\n      }\n    }\n    return null;\n  }\n}\n\nconst VOTE_PROGRAM_ID = new PublicKey('Vote111111111111111111111111111111111111111');\n\n/**\n * History of how many credits earned by the end of each epoch\n */\n\n/**\n * See https://github.com/solana-labs/solana/blob/8a12ed029cfa38d4a45400916c2463fb82bbec8c/programs/vote_api/src/vote_state.rs#L68-L88\n *\n * @internal\n */\nconst VoteAccountLayout = _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([publicKey('nodePubkey'), publicKey('authorizedWithdrawer'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('commission'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n// votes.length\n_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64('slot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32('confirmationCount')]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), 'votes'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('rootSlotValid'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64('rootSlot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n// authorizedVoters.length\n_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64('epoch'), publicKey('authorizedVoter')]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), 'authorizedVoters'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([publicKey('authorizedPubkey'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64('epochOfLastAuthorizedSwitch'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64('targetEpoch')]), 32, 'buf'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64('idx'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u8('isEmpty')], 'priorVoters'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64(),\n// epochCredits.length\n_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.seq(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64('epoch'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64('credits'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64('prevCredits')]), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.offset(_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.u32(), -8), 'epochCredits'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.struct([_solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64('slot'), _solana_buffer_layout__WEBPACK_IMPORTED_MODULE_4__.nu64('timestamp')], 'lastTimestamp')]);\n/**\n * VoteAccount class\n */\nclass VoteAccount {\n  /**\n   * @internal\n   */\n  constructor(args) {\n    this.nodePubkey = void 0;\n    this.authorizedWithdrawer = void 0;\n    this.commission = void 0;\n    this.rootSlot = void 0;\n    this.votes = void 0;\n    this.authorizedVoters = void 0;\n    this.priorVoters = void 0;\n    this.epochCredits = void 0;\n    this.lastTimestamp = void 0;\n    this.nodePubkey = args.nodePubkey;\n    this.authorizedWithdrawer = args.authorizedWithdrawer;\n    this.commission = args.commission;\n    this.rootSlot = args.rootSlot;\n    this.votes = args.votes;\n    this.authorizedVoters = args.authorizedVoters;\n    this.priorVoters = args.priorVoters;\n    this.epochCredits = args.epochCredits;\n    this.lastTimestamp = args.lastTimestamp;\n  }\n\n  /**\n   * Deserialize VoteAccount from the account data.\n   *\n   * @param buffer account data\n   * @return VoteAccount\n   */\n  static fromAccountData(buffer) {\n    const versionOffset = 4;\n    const va = VoteAccountLayout.decode(toBuffer(buffer), versionOffset);\n    let rootSlot = va.rootSlot;\n    if (!va.rootSlotValid) {\n      rootSlot = null;\n    }\n    return new VoteAccount({\n      nodePubkey: new PublicKey(va.nodePubkey),\n      authorizedWithdrawer: new PublicKey(va.authorizedWithdrawer),\n      commission: va.commission,\n      votes: va.votes,\n      rootSlot,\n      authorizedVoters: va.authorizedVoters.map(parseAuthorizedVoter),\n      priorVoters: getPriorVoters(va.priorVoters),\n      epochCredits: va.epochCredits,\n      lastTimestamp: va.lastTimestamp\n    });\n  }\n}\nfunction parseAuthorizedVoter({\n  authorizedVoter,\n  epoch\n}) {\n  return {\n    epoch,\n    authorizedVoter: new PublicKey(authorizedVoter)\n  };\n}\nfunction parsePriorVoters({\n  authorizedPubkey,\n  epochOfLastAuthorizedSwitch,\n  targetEpoch\n}) {\n  return {\n    authorizedPubkey: new PublicKey(authorizedPubkey),\n    epochOfLastAuthorizedSwitch,\n    targetEpoch\n  };\n}\nfunction getPriorVoters({\n  buf,\n  idx,\n  isEmpty\n}) {\n  if (isEmpty) {\n    return [];\n  }\n  return [...buf.slice(idx + 1).map(parsePriorVoters), ...buf.slice(0, idx).map(parsePriorVoters)];\n}\n\nconst endpoint = {\n  http: {\n    devnet: 'http://api.devnet.solana.com',\n    testnet: 'http://api.testnet.solana.com',\n    'mainnet-beta': 'http://api.mainnet-beta.solana.com/'\n  },\n  https: {\n    devnet: 'https://api.devnet.solana.com',\n    testnet: 'https://api.testnet.solana.com',\n    'mainnet-beta': 'https://api.mainnet-beta.solana.com/'\n  }\n};\n/**\n * Retrieves the RPC API URL for the specified cluster\n * @param {Cluster} [cluster=\"devnet\"] - The cluster name of the RPC API URL to use. Possible options: 'devnet' | 'testnet' | 'mainnet-beta'\n * @param {boolean} [tls=\"http\"] - Use TLS when connecting to cluster.\n *\n * @returns {string} URL string of the RPC endpoint\n */\nfunction clusterApiUrl(cluster, tls) {\n  const key = tls === false ? 'http' : 'https';\n  if (!cluster) {\n    return endpoint[key]['devnet'];\n  }\n  const url = endpoint[key][cluster];\n  if (!url) {\n    throw new Error(`Unknown ${key} cluster: ${cluster}`);\n  }\n  return url;\n}\n\n/**\n * Send and confirm a raw transaction\n *\n * If `commitment` option is not specified, defaults to 'max' commitment.\n *\n * @param {Connection} connection\n * @param {Buffer} rawTransaction\n * @param {TransactionConfirmationStrategy} confirmationStrategy\n * @param {ConfirmOptions} [options]\n * @returns {Promise<TransactionSignature>}\n */\n\n/**\n * @deprecated Calling `sendAndConfirmRawTransaction()` without a `confirmationStrategy`\n * is no longer supported and will be removed in a future version.\n */\n// eslint-disable-next-line no-redeclare\n\n// eslint-disable-next-line no-redeclare\nasync function sendAndConfirmRawTransaction(connection, rawTransaction, confirmationStrategyOrConfirmOptions, maybeConfirmOptions) {\n  let confirmationStrategy;\n  let options;\n  if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'lastValidBlockHeight')) {\n    confirmationStrategy = confirmationStrategyOrConfirmOptions;\n    options = maybeConfirmOptions;\n  } else if (confirmationStrategyOrConfirmOptions && Object.prototype.hasOwnProperty.call(confirmationStrategyOrConfirmOptions, 'nonceValue')) {\n    confirmationStrategy = confirmationStrategyOrConfirmOptions;\n    options = maybeConfirmOptions;\n  } else {\n    options = confirmationStrategyOrConfirmOptions;\n  }\n  const sendOptions = options && {\n    skipPreflight: options.skipPreflight,\n    preflightCommitment: options.preflightCommitment || options.commitment,\n    minContextSlot: options.minContextSlot\n  };\n  const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);\n  const commitment = options && options.commitment;\n  const confirmationPromise = confirmationStrategy ? connection.confirmTransaction(confirmationStrategy, commitment) : connection.confirmTransaction(signature, commitment);\n  const status = (await confirmationPromise).value;\n  if (status.err) {\n    throw new Error(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);\n  }\n  return signature;\n}\n\n/**\n * There are 1-billion lamports in one SOL\n */\nconst LAMPORTS_PER_SOL = 1000000000;\n\n\n//# sourceMappingURL=index.browser.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbGliL2luZGV4LmJyb3dzZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0M7QUFDZ0I7QUFDekI7QUFDQztBQUNzQjtBQUN1QjtBQUNmO0FBQ1Q7QUFDVTtBQUMySDtBQUNoSTtBQUNvQjtBQUNHO0FBQ3pCO0FBQ0k7O0FBRXBEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJCQUEyQiwwREFBTztBQUNsQztBQUNBLHdCQUF3QiwwREFBTztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMERBQU87QUFDNUI7QUFDQTtBQUNBLElBQUksMERBQU87QUFDWDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsMERBQU87QUFDNUMsZUFBZSwwREFBTzs7QUFFdEI7QUFDQSxNQUFNLDBDQUFNO0FBQ1o7QUFDQSxJQUFJO0FBQ0osV0FBVywwQ0FBTTtBQUNqQixJQUFJO0FBQ0osV0FBVywwQ0FBTTtBQUNqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMENBQU0sTUFBTSxnREFBUztBQUNoQztBQUNBO0FBQ0EsV0FBVyxrREFBVztBQUN0QjtBQUNBO0FBQ0EsV0FBVywyREFBb0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0Esd0JBQXdCLGtEQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw4Q0FBRTtBQUN6QixRQUFRO0FBQ1IsdUJBQXVCLDhDQUFFO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0RBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsMENBQU07QUFDekM7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDBDQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdCQUFnQjtBQUN4Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMENBQU0sbUNBQW1DLDBDQUFNO0FBQ2xFLDJCQUEyQiw2REFBTTtBQUNqQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMENBQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBDQUFNO0FBQ3JCLEtBQUs7QUFDTCxhQUFhLDBDQUFNLHVDQUF1QywwQ0FBTTtBQUNoRSwyQkFBMkIsNkRBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQ0FBZ0M7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsMENBQU07QUFDbEQ7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsOEJBQThCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZUFBZTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywwQ0FBTTtBQUNqQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLDhDQUE4QywyQkFBMkIsOEVBQThFLFdBQVc7QUFDbEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSx1QkFBdUIsV0FBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx1REFBaUI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHVEQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyx5REFBbUIsRUFBRSxzREFBZ0IsWUFBWSxzREFBZ0IsbUJBQW1CLHVEQUFpQixDQUFDLHlEQUFtQixDQUFDLHNEQUFnQjtBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLDBDQUFNO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxzREFBZ0IsVUFBVSxzREFBZ0IsVUFBVSwwQ0FBTTtBQUNyRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlEQUFtQjtBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMseURBQW1CLEVBQUUsdURBQWlCLG1CQUFtQix1REFBaUI7QUFDbkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlEQUFtQiw0RkFBNEYscURBQWU7QUFDdkk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLHlEQUFtQixFQUFFLHNEQUFnQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QixjQUFjLFVBQVU7QUFDeEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtGQUFrRjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxvQkFBb0IseUJBQXlCO0FBQzdDO0FBQ0EseURBQXlELEdBQUc7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUiwyQ0FBMkMsK0JBQStCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtEQUFXO0FBQ3pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekI7QUFDQSxlQUFlLHdCQUF3QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBLFdBQVcseURBQVUsQ0FBQywwQ0FBTTtBQUM1QjtBQUNBO0FBQ0EsZ0JBQWdCLHlEQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0RBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVCQUF1Qix5REFBbUIsRUFBRSxzREFBZ0IsaUJBQWlCLHNEQUFnQixZQUFZLHNEQUFnQixpQkFBaUIsc0RBQWdCLHdCQUF3QixzREFBZ0IsQ0FBQyxxREFBZSxVQUFVLHlEQUFtQixDQUFDLHNEQUFnQjtBQUNoUTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsMENBQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLHlEQUFtQixFQUFFLHNEQUFnQjtBQUM5RCxtQkFBbUIsMENBQU07QUFDekI7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsdUNBQXVDLG1CQUFtQixVQUFVLHNCQUFzQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QkFBcUI7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixvREFBTSwwQkFBMEIsb0RBQU07QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1B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UjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxFQUFFLG9EQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEVBQUUsb0RBQU07QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxFQUFFLG9EQUFNO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLEVBQUUsb0RBQU07QUFDZDtBQUNBOztBQUVBO0FBQ0EsMkRBQTJELGlCQUFpQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixn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Q0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxREFBZTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msc0RBQWdCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHNEQUFnQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUSxhQUFhLDBCQUEwQixlQUFlO0FBQzFHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBbUIsRUFBRSxzREFBZ0I7QUFDakQsR0FBRztBQUNIO0FBQ0E7QUFDQSxZQUFZLHlEQUFtQixFQUFFLHNEQUFnQiw2Q0FBNkMsc0RBQWdCO0FBQzlHLEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSx5REFBbUIsRUFBRSxzREFBZ0IsaUJBQWlCLHVEQUFpQjtBQUNuRixHQUFHO0FBQ0g7QUFDQTtBQUNBLFlBQVkseURBQW1CLEVBQUUsc0RBQWdCO0FBQ2pELEdBQUc7QUFDSDtBQUNBO0FBQ0EsWUFBWSx5REFBbUIsRUFBRSxzREFBZ0I7QUFDakQ7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGtEQUFJO0FBQ3ZCLFFBQVEsb0RBQU07QUFDZCxXQUFXLHNEQUFRLENBQUMsb0RBQU07QUFDMUIsV0FBVyxzREFBUSxDQUFDLG9EQUFNO0FBQzFC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QjtBQUNuRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRXNpRDtBQUN0aUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9saWIvaW5kZXguYnJvd3Nlci5lc20uanM/MTA1ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXIgfSBmcm9tICdidWZmZXInO1xuaW1wb3J0IHsgZWQyNTUxOSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOSc7XG5pbXBvcnQgQk4gZnJvbSAnYm4uanMnO1xuaW1wb3J0IGJzNTggZnJvbSAnYnM1OCc7XG5pbXBvcnQgeyBzaGEyNTYgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3NoYTI1Nic7XG5pbXBvcnQgeyBzZXJpYWxpemUsIGRlc2VyaWFsaXplLCBkZXNlcmlhbGl6ZVVuY2hlY2tlZCB9IGZyb20gJ2JvcnNoJztcbmltcG9ydCAqIGFzIEJ1ZmZlckxheW91dCBmcm9tICdAc29sYW5hL2J1ZmZlci1sYXlvdXQnO1xuaW1wb3J0IHsgYmxvYiB9IGZyb20gJ0Bzb2xhbmEvYnVmZmVyLWxheW91dCc7XG5pbXBvcnQgeyB0b0JpZ0ludExFLCB0b0J1ZmZlckxFIH0gZnJvbSAnYmlnaW50LWJ1ZmZlcic7XG5pbXBvcnQgeyBjb2VyY2UsIGluc3RhbmNlLCBzdHJpbmcsIHR1cGxlLCBsaXRlcmFsLCB1bmtub3duLCB0eXBlLCBudW1iZXIsIGFycmF5LCBudWxsYWJsZSwgb3B0aW9uYWwsIGJvb2xlYW4sIHJlY29yZCwgdW5pb24sIGNyZWF0ZSwgYW55LCBhc3NlcnQgYXMgYXNzZXJ0JDEgfSBmcm9tICdzdXBlcnN0cnVjdCc7XG5pbXBvcnQgUnBjQ2xpZW50IGZyb20gJ2pheXNvbi9saWIvY2xpZW50L2Jyb3dzZXInO1xuaW1wb3J0IFJwY1dlYlNvY2tldENvbW1vbkNsaWVudCBmcm9tICdycGMtd2Vic29ja2V0cy9kaXN0L2xpYi9jbGllbnQnO1xuaW1wb3J0IGNyZWF0ZVJwYyBmcm9tICdycGMtd2Vic29ja2V0cy9kaXN0L2xpYi9jbGllbnQvd2Vic29ja2V0LmJyb3dzZXInO1xuaW1wb3J0IHsga2VjY2FrXzI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMyc7XG5pbXBvcnQgeyBzZWNwMjU2azEgfSBmcm9tICdAbm9ibGUvY3VydmVzL3NlY3AyNTZrMSc7XG5cbi8qKlxuICogQSA2NCBieXRlIHNlY3JldCBrZXksIHRoZSBmaXJzdCAzMiBieXRlcyBvZiB3aGljaCBpcyB0aGVcbiAqIHByaXZhdGUgc2NhbGFyIGFuZCB0aGUgbGFzdCAzMiBieXRlcyBpcyB0aGUgcHVibGljIGtleS5cbiAqIFJlYWQgbW9yZTogaHR0cHM6Ly9ibG9nLm1vemlsbGEub3JnL3dhcm5lci8yMDExLzExLzI5L2VkMjU1MTkta2V5cy9cbiAqL1xuXG4vKipcbiAqIEVkMjU1MTkgS2V5cGFpclxuICovXG5cbmNvbnN0IGdlbmVyYXRlUHJpdmF0ZUtleSA9IGVkMjU1MTkudXRpbHMucmFuZG9tUHJpdmF0ZUtleTtcbmNvbnN0IGdlbmVyYXRlS2V5cGFpciA9ICgpID0+IHtcbiAgY29uc3QgcHJpdmF0ZVNjYWxhciA9IGVkMjU1MTkudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXkocHJpdmF0ZVNjYWxhcik7XG4gIGNvbnN0IHNlY3JldEtleSA9IG5ldyBVaW50OEFycmF5KDY0KTtcbiAgc2VjcmV0S2V5LnNldChwcml2YXRlU2NhbGFyKTtcbiAgc2VjcmV0S2V5LnNldChwdWJsaWNLZXksIDMyKTtcbiAgcmV0dXJuIHtcbiAgICBwdWJsaWNLZXksXG4gICAgc2VjcmV0S2V5XG4gIH07XG59O1xuY29uc3QgZ2V0UHVibGljS2V5ID0gZWQyNTUxOS5nZXRQdWJsaWNLZXk7XG5mdW5jdGlvbiBpc09uQ3VydmUocHVibGljS2V5KSB7XG4gIHRyeSB7XG4gICAgZWQyNTUxOS5FeHRlbmRlZFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5jb25zdCBzaWduID0gKG1lc3NhZ2UsIHNlY3JldEtleSkgPT4gZWQyNTUxOS5zaWduKG1lc3NhZ2UsIHNlY3JldEtleS5zbGljZSgwLCAzMikpO1xuY29uc3QgdmVyaWZ5ID0gZWQyNTUxOS52ZXJpZnk7XG5cbmNvbnN0IHRvQnVmZmVyID0gYXJyID0+IHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihhcnIpKSB7XG4gICAgcmV0dXJuIGFycjtcbiAgfSBlbHNlIGlmIChhcnIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGFycik7XG4gIH1cbn07XG5cbi8vIENsYXNzIHdyYXBwaW5nIGEgcGxhaW4gb2JqZWN0XG5jbGFzcyBTdHJ1Y3Qge1xuICBjb25zdHJ1Y3Rvcihwcm9wZXJ0aWVzKSB7XG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLCBwcm9wZXJ0aWVzKTtcbiAgfVxuICBlbmNvZGUoKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHNlcmlhbGl6ZShTT0xBTkFfU0NIRU1BLCB0aGlzKSk7XG4gIH1cbiAgc3RhdGljIGRlY29kZShkYXRhKSB7XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplKFNPTEFOQV9TQ0hFTUEsIHRoaXMsIGRhdGEpO1xuICB9XG4gIHN0YXRpYyBkZWNvZGVVbmNoZWNrZWQoZGF0YSkge1xuICAgIHJldHVybiBkZXNlcmlhbGl6ZVVuY2hlY2tlZChTT0xBTkFfU0NIRU1BLCB0aGlzLCBkYXRhKTtcbiAgfVxufVxuXG4vLyBDbGFzcyByZXByZXNlbnRpbmcgYSBSdXN0LWNvbXBhdGlibGUgZW51bSwgc2luY2UgZW51bXMgYXJlIG9ubHkgc3RyaW5ncyBvclxuLy8gbnVtYmVycyBpbiBwdXJlIEpTXG5jbGFzcyBFbnVtIGV4dGVuZHMgU3RydWN0IHtcbiAgY29uc3RydWN0b3IocHJvcGVydGllcykge1xuICAgIHN1cGVyKHByb3BlcnRpZXMpO1xuICAgIHRoaXMuZW51bSA9ICcnO1xuICAgIGlmIChPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5sZW5ndGggIT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRW51bSBjYW4gb25seSB0YWtlIHNpbmdsZSB2YWx1ZScpO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKS5tYXAoa2V5ID0+IHtcbiAgICAgIHRoaXMuZW51bSA9IGtleTtcbiAgICB9KTtcbiAgfVxufVxuY29uc3QgU09MQU5BX1NDSEVNQSA9IG5ldyBNYXAoKTtcblxudmFyIF9QdWJsaWNLZXk7XG5cbi8qKlxuICogTWF4aW11bSBsZW5ndGggb2YgZGVyaXZlZCBwdWJrZXkgc2VlZFxuICovXG5jb25zdCBNQVhfU0VFRF9MRU5HVEggPSAzMjtcblxuLyoqXG4gKiBTaXplIG9mIHB1YmxpYyBrZXkgaW4gYnl0ZXNcbiAqL1xuY29uc3QgUFVCTElDX0tFWV9MRU5HVEggPSAzMjtcblxuLyoqXG4gKiBWYWx1ZSB0byBiZSBjb252ZXJ0ZWQgaW50byBwdWJsaWMga2V5XG4gKi9cblxuLyoqXG4gKiBKU09OIG9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBQdWJsaWNLZXkgY2xhc3NcbiAqL1xuXG5mdW5jdGlvbiBpc1B1YmxpY0tleURhdGEodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLl9ibiAhPT0gdW5kZWZpbmVkO1xufVxuXG4vLyBsb2NhbCBjb3VudGVyIHVzZWQgYnkgUHVibGljS2V5LnVuaXF1ZSgpXG5sZXQgdW5pcXVlUHVibGljS2V5Q291bnRlciA9IDE7XG5cbi8qKlxuICogQSBwdWJsaWMga2V5XG4gKi9cbmNsYXNzIFB1YmxpY0tleSBleHRlbmRzIFN0cnVjdCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUHVibGljS2V5IG9iamVjdFxuICAgKiBAcGFyYW0gdmFsdWUgZWQyNTUxOSBwdWJsaWMga2V5IGFzIGJ1ZmZlciBvciBiYXNlLTU4IGVuY29kZWQgc3RyaW5nXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgIHN1cGVyKHt9KTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fYm4gPSB2b2lkIDA7XG4gICAgaWYgKGlzUHVibGljS2V5RGF0YSh2YWx1ZSkpIHtcbiAgICAgIHRoaXMuX2JuID0gdmFsdWUuX2JuO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBhc3N1bWUgYmFzZSA1OCBlbmNvZGluZyBieSBkZWZhdWx0XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBiczU4LmRlY29kZSh2YWx1ZSk7XG4gICAgICAgIGlmIChkZWNvZGVkLmxlbmd0aCAhPSBQVUJMSUNfS0VZX0xFTkdUSCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwdWJsaWMga2V5IGlucHV0YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYm4gPSBuZXcgQk4oZGVjb2RlZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9ibiA9IG5ldyBCTih2YWx1ZSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fYm4uYnl0ZUxlbmd0aCgpID4gUFVCTElDX0tFWV9MRU5HVEgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHB1YmxpYyBrZXkgaW5wdXRgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIHVuaXF1ZSBQdWJsaWNLZXkgZm9yIHRlc3RzIGFuZCBiZW5jaG1hcmtzIHVzaW5nIGEgY291bnRlclxuICAgKi9cbiAgc3RhdGljIHVuaXF1ZSgpIHtcbiAgICBjb25zdCBrZXkgPSBuZXcgUHVibGljS2V5KHVuaXF1ZVB1YmxpY0tleUNvdW50ZXIpO1xuICAgIHVuaXF1ZVB1YmxpY0tleUNvdW50ZXIgKz0gMTtcbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleShrZXkudG9CdWZmZXIoKSk7XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCBwdWJsaWMga2V5IHZhbHVlLiBUaGUgYmFzZTU4LWVuY29kZWQgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGlzIGFsbCBvbmVzIChhcyBzZWVuIGJlbG93KVxuICAgKiBUaGUgdW5kZXJseWluZyBCTiBudW1iZXIgaXMgMzIgYnl0ZXMgdGhhdCBhcmUgYWxsIHplcm9zXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdHdvIHB1YmxpY0tleXMgYXJlIGVxdWFsXG4gICAqL1xuICBlcXVhbHMocHVibGljS2V5KSB7XG4gICAgcmV0dXJuIHRoaXMuX2JuLmVxKHB1YmxpY0tleS5fYm4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgYmFzZS01OCByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHVibGljIGtleVxuICAgKi9cbiAgdG9CYXNlNTgoKSB7XG4gICAgcmV0dXJuIGJzNTguZW5jb2RlKHRoaXMudG9CeXRlcygpKTtcbiAgfVxuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9CYXNlNTgoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGJ5dGUgYXJyYXkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXkgaW4gYmlnIGVuZGlhblxuICAgKi9cbiAgdG9CeXRlcygpIHtcbiAgICBjb25zdCBidWYgPSB0aGlzLnRvQnVmZmVyKCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1Zi5idWZmZXIsIGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZUxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBCdWZmZXIgcmVwcmVzZW50YXRpb24gb2YgdGhlIHB1YmxpYyBrZXkgaW4gYmlnIGVuZGlhblxuICAgKi9cbiAgdG9CdWZmZXIoKSB7XG4gICAgY29uc3QgYiA9IHRoaXMuX2JuLnRvQXJyYXlMaWtlKEJ1ZmZlcik7XG4gICAgaWYgKGIubGVuZ3RoID09PSBQVUJMSUNfS0VZX0xFTkdUSCkge1xuICAgICAgcmV0dXJuIGI7XG4gICAgfVxuICAgIGNvbnN0IHplcm9QYWQgPSBCdWZmZXIuYWxsb2MoMzIpO1xuICAgIGIuY29weSh6ZXJvUGFkLCAzMiAtIGIubGVuZ3RoKTtcbiAgICByZXR1cm4gemVyb1BhZDtcbiAgfVxuICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgcmV0dXJuIGBQdWJsaWNLZXkoJHt0aGlzLnRvU3RyaW5nKCl9KWA7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBiYXNlLTU4IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBwdWJsaWMga2V5XG4gICAqL1xuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy50b0Jhc2U1OCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcml2ZSBhIHB1YmxpYyBrZXkgZnJvbSBhbm90aGVyIGtleSwgYSBzZWVkLCBhbmQgYSBwcm9ncmFtIElELlxuICAgKiBUaGUgcHJvZ3JhbSBJRCB3aWxsIGFsc28gc2VydmUgYXMgdGhlIG93bmVyIG9mIHRoZSBwdWJsaWMga2V5LCBnaXZpbmdcbiAgICogaXQgcGVybWlzc2lvbiB0byB3cml0ZSBkYXRhIHRvIHRoZSBhY2NvdW50LlxuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1hd2FpdCAqL1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlV2l0aFNlZWQoZnJvbVB1YmxpY0tleSwgc2VlZCwgcHJvZ3JhbUlkKSB7XG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmNvbmNhdChbZnJvbVB1YmxpY0tleS50b0J1ZmZlcigpLCBCdWZmZXIuZnJvbShzZWVkKSwgcHJvZ3JhbUlkLnRvQnVmZmVyKCldKTtcbiAgICBjb25zdCBwdWJsaWNLZXlCeXRlcyA9IHNoYTI1NihidWZmZXIpO1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KHB1YmxpY0tleUJ5dGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJpdmUgYSBwcm9ncmFtIGFkZHJlc3MgZnJvbSBzZWVkcyBhbmQgYSBwcm9ncmFtIElELlxuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1hd2FpdCAqL1xuICBzdGF0aWMgY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzLCBwcm9ncmFtSWQpIHtcbiAgICBsZXQgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDApO1xuICAgIHNlZWRzLmZvckVhY2goZnVuY3Rpb24gKHNlZWQpIHtcbiAgICAgIGlmIChzZWVkLmxlbmd0aCA+IE1BWF9TRUVEX0xFTkdUSCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBNYXggc2VlZCBsZW5ndGggZXhjZWVkZWRgKTtcbiAgICAgIH1cbiAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoW2J1ZmZlciwgdG9CdWZmZXIoc2VlZCldKTtcbiAgICB9KTtcbiAgICBidWZmZXIgPSBCdWZmZXIuY29uY2F0KFtidWZmZXIsIHByb2dyYW1JZC50b0J1ZmZlcigpLCBCdWZmZXIuZnJvbSgnUHJvZ3JhbURlcml2ZWRBZGRyZXNzJyldKTtcbiAgICBjb25zdCBwdWJsaWNLZXlCeXRlcyA9IHNoYTI1NihidWZmZXIpO1xuICAgIGlmIChpc09uQ3VydmUocHVibGljS2V5Qnl0ZXMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc2VlZHMsIGFkZHJlc3MgbXVzdCBmYWxsIG9mZiB0aGUgY3VydmVgKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkocHVibGljS2V5Qnl0ZXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jIHZlcnNpb24gb2YgY3JlYXRlUHJvZ3JhbUFkZHJlc3NTeW5jXG4gICAqIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGNyZWF0ZVByb2dyYW1BZGRyZXNzU3luY30gaW5zdGVhZFxuICAgKi9cbiAgLyogZXNsaW50LWRpc2FibGUgcmVxdWlyZS1hd2FpdCAqL1xuICBzdGF0aWMgYXN5bmMgY3JlYXRlUHJvZ3JhbUFkZHJlc3Moc2VlZHMsIHByb2dyYW1JZCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVByb2dyYW1BZGRyZXNzU3luYyhzZWVkcywgcHJvZ3JhbUlkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGaW5kIGEgdmFsaWQgcHJvZ3JhbSBhZGRyZXNzXG4gICAqXG4gICAqIFZhbGlkIHByb2dyYW0gYWRkcmVzc2VzIG11c3QgZmFsbCBvZmYgdGhlIGVkMjU1MTkgY3VydmUuICBUaGlzIGZ1bmN0aW9uXG4gICAqIGl0ZXJhdGVzIGEgbm9uY2UgdW50aWwgaXQgZmluZHMgb25lIHRoYXQgd2hlbiBjb21iaW5lZCB3aXRoIHRoZSBzZWVkc1xuICAgKiByZXN1bHRzIGluIGEgdmFsaWQgcHJvZ3JhbSBhZGRyZXNzLlxuICAgKi9cbiAgc3RhdGljIGZpbmRQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHMsIHByb2dyYW1JZCkge1xuICAgIGxldCBub25jZSA9IDI1NTtcbiAgICBsZXQgYWRkcmVzcztcbiAgICB3aGlsZSAobm9uY2UgIT0gMCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2VlZHNXaXRoTm9uY2UgPSBzZWVkcy5jb25jYXQoQnVmZmVyLmZyb20oW25vbmNlXSkpO1xuICAgICAgICBhZGRyZXNzID0gdGhpcy5jcmVhdGVQcm9ncmFtQWRkcmVzc1N5bmMoc2VlZHNXaXRoTm9uY2UsIHByb2dyYW1JZCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBub25jZS0tO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbYWRkcmVzcywgbm9uY2VdO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBmaW5kIGEgdmlhYmxlIHByb2dyYW0gYWRkcmVzcyBub25jZWApO1xuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jIHZlcnNpb24gb2YgZmluZFByb2dyYW1BZGRyZXNzU3luY1xuICAgKiBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBmaW5kUHJvZ3JhbUFkZHJlc3NTeW5jfSBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgZmluZFByb2dyYW1BZGRyZXNzKHNlZWRzLCBwcm9ncmFtSWQpIHtcbiAgICByZXR1cm4gdGhpcy5maW5kUHJvZ3JhbUFkZHJlc3NTeW5jKHNlZWRzLCBwcm9ncmFtSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIHRoYXQgYSBwdWJrZXkgaXMgb24gdGhlIGVkMjU1MTkgY3VydmUuXG4gICAqL1xuICBzdGF0aWMgaXNPbkN1cnZlKHB1YmtleURhdGEpIHtcbiAgICBjb25zdCBwdWJrZXkgPSBuZXcgUHVibGljS2V5KHB1YmtleURhdGEpO1xuICAgIHJldHVybiBpc09uQ3VydmUocHVia2V5LnRvQnl0ZXMoKSk7XG4gIH1cbn1cbl9QdWJsaWNLZXkgPSBQdWJsaWNLZXk7XG5QdWJsaWNLZXkuZGVmYXVsdCA9IG5ldyBfUHVibGljS2V5KCcxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuU09MQU5BX1NDSEVNQS5zZXQoUHVibGljS2V5LCB7XG4gIGtpbmQ6ICdzdHJ1Y3QnLFxuICBmaWVsZHM6IFtbJ19ibicsICd1MjU2J11dXG59KTtcblxuLyoqXG4gKiBBbiBhY2NvdW50IGtleSBwYWlyIChwdWJsaWMgYW5kIHNlY3JldCBrZXlzKS5cbiAqXG4gKiBAZGVwcmVjYXRlZCBzaW5jZSB2MS4xMC4wLCBwbGVhc2UgdXNlIHtAbGluayBLZXlwYWlyfSBpbnN0ZWFkLlxuICovXG5jbGFzcyBBY2NvdW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBBY2NvdW50IG9iamVjdFxuICAgKlxuICAgKiBJZiB0aGUgc2VjcmV0S2V5IHBhcmFtZXRlciBpcyBub3QgcHJvdmlkZWQgYSBuZXcga2V5IHBhaXIgaXMgcmFuZG9tbHlcbiAgICogY3JlYXRlZCBmb3IgdGhlIGFjY291bnRcbiAgICpcbiAgICogQHBhcmFtIHNlY3JldEtleSBTZWNyZXQga2V5IGZvciB0aGUgYWNjb3VudFxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2VjcmV0S2V5KSB7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3B1YmxpY0tleSA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc2VjcmV0S2V5ID0gdm9pZCAwO1xuICAgIGlmIChzZWNyZXRLZXkpIHtcbiAgICAgIGNvbnN0IHNlY3JldEtleUJ1ZmZlciA9IHRvQnVmZmVyKHNlY3JldEtleSk7XG4gICAgICBpZiAoc2VjcmV0S2V5Lmxlbmd0aCAhPT0gNjQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgc2VjcmV0IGtleSBzaXplJyk7XG4gICAgICB9XG4gICAgICB0aGlzLl9wdWJsaWNLZXkgPSBzZWNyZXRLZXlCdWZmZXIuc2xpY2UoMzIsIDY0KTtcbiAgICAgIHRoaXMuX3NlY3JldEtleSA9IHNlY3JldEtleUJ1ZmZlci5zbGljZSgwLCAzMik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NlY3JldEtleSA9IHRvQnVmZmVyKGdlbmVyYXRlUHJpdmF0ZUtleSgpKTtcbiAgICAgIHRoaXMuX3B1YmxpY0tleSA9IHRvQnVmZmVyKGdldFB1YmxpY0tleSh0aGlzLl9zZWNyZXRLZXkpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhlIHB1YmxpYyBrZXkgZm9yIHRoaXMgYWNjb3VudFxuICAgKi9cbiAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICByZXR1cm4gbmV3IFB1YmxpY0tleSh0aGlzLl9wdWJsaWNLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSAqKnVuZW5jcnlwdGVkKiogc2VjcmV0IGtleSBmb3IgdGhpcyBhY2NvdW50LiBUaGUgZmlyc3QgMzIgYnl0ZXNcbiAgICogaXMgdGhlIHByaXZhdGUgc2NhbGFyIGFuZCB0aGUgbGFzdCAzMiBieXRlcyBpcyB0aGUgcHVibGljIGtleS5cbiAgICogUmVhZCBtb3JlOiBodHRwczovL2Jsb2cubW96aWxsYS5vcmcvd2FybmVyLzIwMTEvMTEvMjkvZWQyNTUxOS1rZXlzL1xuICAgKi9cbiAgZ2V0IHNlY3JldEtleSgpIHtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbdGhpcy5fc2VjcmV0S2V5LCB0aGlzLl9wdWJsaWNLZXldLCA2NCk7XG4gIH1cbn1cblxuY29uc3QgQlBGX0xPQURFUl9ERVBSRUNBVEVEX1BST0dSQU1fSUQgPSBuZXcgUHVibGljS2V5KCdCUEZMb2FkZXIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogTWF4aW11bSBvdmVyLXRoZS13aXJlIHNpemUgb2YgYSBUcmFuc2FjdGlvblxuICpcbiAqIDEyODAgaXMgSVB2NiBtaW5pbXVtIE1UVVxuICogNDAgYnl0ZXMgaXMgdGhlIHNpemUgb2YgdGhlIElQdjYgaGVhZGVyXG4gKiA4IGJ5dGVzIGlzIHRoZSBzaXplIG9mIHRoZSBmcmFnbWVudCBoZWFkZXJcbiAqL1xuY29uc3QgUEFDS0VUX0RBVEFfU0laRSA9IDEyODAgLSA0MCAtIDg7XG5jb25zdCBWRVJTSU9OX1BSRUZJWF9NQVNLID0gMHg3ZjtcbmNvbnN0IFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMgPSA2NDtcblxuY2xhc3MgVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihzaWduYXR1cmUpIHtcbiAgICBzdXBlcihgU2lnbmF0dXJlICR7c2lnbmF0dXJlfSBoYXMgZXhwaXJlZDogYmxvY2sgaGVpZ2h0IGV4Y2VlZGVkLmApO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gdm9pZCAwO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yJ1xufSk7XG5jbGFzcyBUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHNpZ25hdHVyZSwgdGltZW91dFNlY29uZHMpIHtcbiAgICBzdXBlcihgVHJhbnNhY3Rpb24gd2FzIG5vdCBjb25maXJtZWQgaW4gJHt0aW1lb3V0U2Vjb25kcy50b0ZpeGVkKDIpfSBzZWNvbmRzLiBJdCBpcyBgICsgJ3Vua25vd24gaWYgaXQgc3VjY2VlZGVkIG9yIGZhaWxlZC4gQ2hlY2sgc2lnbmF0dXJlICcgKyBgJHtzaWduYXR1cmV9IHVzaW5nIHRoZSBTb2xhbmEgRXhwbG9yZXIgb3IgQ0xJIHRvb2xzLmApO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gdm9pZCAwO1xuICAgIHRoaXMuc2lnbmF0dXJlID0gc2lnbmF0dXJlO1xuICB9XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yLnByb3RvdHlwZSwgJ25hbWUnLCB7XG4gIHZhbHVlOiAnVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yJ1xufSk7XG5jbGFzcyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3Ioc2lnbmF0dXJlKSB7XG4gICAgc3VwZXIoYFNpZ25hdHVyZSAke3NpZ25hdHVyZX0gaGFzIGV4cGlyZWQ6IHRoZSBub25jZSBpcyBubyBsb25nZXIgdmFsaWQuYCk7XG4gICAgdGhpcy5zaWduYXR1cmUgPSB2b2lkIDA7XG4gICAgdGhpcy5zaWduYXR1cmUgPSBzaWduYXR1cmU7XG4gIH1cbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvci5wcm90b3R5cGUsICduYW1lJywge1xuICB2YWx1ZTogJ1RyYW5zYWN0aW9uRXhwaXJlZE5vbmNlSW52YWxpZEVycm9yJ1xufSk7XG5cbmNsYXNzIE1lc3NhZ2VBY2NvdW50S2V5cyB7XG4gIGNvbnN0cnVjdG9yKHN0YXRpY0FjY291bnRLZXlzLCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzKSB7XG4gICAgdGhpcy5zdGF0aWNBY2NvdW50S2V5cyA9IHZvaWQgMDtcbiAgICB0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGF0aWNBY2NvdW50S2V5cyA9IHN0YXRpY0FjY291bnRLZXlzO1xuICAgIHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IGFjY291bnRLZXlzRnJvbUxvb2t1cHM7XG4gIH1cbiAga2V5U2VnbWVudHMoKSB7XG4gICAgY29uc3Qga2V5U2VnbWVudHMgPSBbdGhpcy5zdGF0aWNBY2NvdW50S2V5c107XG4gICAgaWYgKHRoaXMuYWNjb3VudEtleXNGcm9tTG9va3Vwcykge1xuICAgICAga2V5U2VnbWVudHMucHVzaCh0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUpO1xuICAgICAga2V5U2VnbWVudHMucHVzaCh0aGlzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMucmVhZG9ubHkpO1xuICAgIH1cbiAgICByZXR1cm4ga2V5U2VnbWVudHM7XG4gIH1cbiAgZ2V0KGluZGV4KSB7XG4gICAgZm9yIChjb25zdCBrZXlTZWdtZW50IG9mIHRoaXMua2V5U2VnbWVudHMoKSkge1xuICAgICAgaWYgKGluZGV4IDwga2V5U2VnbWVudC5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGtleVNlZ21lbnRbaW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5kZXggLT0ga2V5U2VnbWVudC5sZW5ndGg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICBnZXQgbGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLmtleVNlZ21lbnRzKCkuZmxhdCgpLmxlbmd0aDtcbiAgfVxuICBjb21waWxlSW5zdHJ1Y3Rpb25zKGluc3RydWN0aW9ucykge1xuICAgIC8vIEJhaWwgZWFybHkgaWYgYW55IGFjY291bnQgaW5kZXhlcyB3b3VsZCBvdmVyZmxvdyBhIHU4XG4gICAgY29uc3QgVThfTUFYID0gMjU1O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IFU4X01BWCArIDEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQWNjb3VudCBpbmRleCBvdmVyZmxvdyBlbmNvdW50ZXJlZCBkdXJpbmcgY29tcGlsYXRpb24nKTtcbiAgICB9XG4gICAgY29uc3Qga2V5SW5kZXhNYXAgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5rZXlTZWdtZW50cygpLmZsYXQoKS5mb3JFYWNoKChrZXksIGluZGV4KSA9PiB7XG4gICAgICBrZXlJbmRleE1hcC5zZXQoa2V5LnRvQmFzZTU4KCksIGluZGV4KTtcbiAgICB9KTtcbiAgICBjb25zdCBmaW5kS2V5SW5kZXggPSBrZXkgPT4ge1xuICAgICAgY29uc3Qga2V5SW5kZXggPSBrZXlJbmRleE1hcC5nZXQoa2V5LnRvQmFzZTU4KCkpO1xuICAgICAgaWYgKGtleUluZGV4ID09PSB1bmRlZmluZWQpIHRocm93IG5ldyBFcnJvcignRW5jb3VudGVyZWQgYW4gdW5rbm93biBpbnN0cnVjdGlvbiBhY2NvdW50IGtleSBkdXJpbmcgY29tcGlsYXRpb24nKTtcbiAgICAgIHJldHVybiBrZXlJbmRleDtcbiAgICB9O1xuICAgIHJldHVybiBpbnN0cnVjdGlvbnMubWFwKGluc3RydWN0aW9uID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHByb2dyYW1JZEluZGV4OiBmaW5kS2V5SW5kZXgoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKSxcbiAgICAgICAgYWNjb3VudEtleUluZGV4ZXM6IGluc3RydWN0aW9uLmtleXMubWFwKG1ldGEgPT4gZmluZEtleUluZGV4KG1ldGEucHVia2V5KSksXG4gICAgICAgIGRhdGE6IGluc3RydWN0aW9uLmRhdGFcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBMYXlvdXQgZm9yIGEgcHVibGljIGtleVxuICovXG5jb25zdCBwdWJsaWNLZXkgPSAocHJvcGVydHkgPSAncHVibGljS2V5JykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LmJsb2IoMzIsIHByb3BlcnR5KTtcbn07XG5cbi8qKlxuICogTGF5b3V0IGZvciBhIHNpZ25hdHVyZVxuICovXG5jb25zdCBzaWduYXR1cmUgPSAocHJvcGVydHkgPSAnc2lnbmF0dXJlJykgPT4ge1xuICByZXR1cm4gQnVmZmVyTGF5b3V0LmJsb2IoNjQsIHByb3BlcnR5KTtcbn07XG4vKipcbiAqIExheW91dCBmb3IgYSBSdXN0IFN0cmluZyB0eXBlXG4gKi9cbmNvbnN0IHJ1c3RTdHJpbmcgPSAocHJvcGVydHkgPSAnc3RyaW5nJykgPT4ge1xuICBjb25zdCByc2wgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdsZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnUzMignbGVuZ3RoUGFkZGluZycpLCBCdWZmZXJMYXlvdXQuYmxvYihCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLCAnY2hhcnMnKV0sIHByb3BlcnR5KTtcbiAgY29uc3QgX2RlY29kZSA9IHJzbC5kZWNvZGUuYmluZChyc2wpO1xuICBjb25zdCBfZW5jb2RlID0gcnNsLmVuY29kZS5iaW5kKHJzbCk7XG4gIGNvbnN0IHJzbFNoaW0gPSByc2w7XG4gIHJzbFNoaW0uZGVjb2RlID0gKGIsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBfZGVjb2RlKGIsIG9mZnNldCk7XG4gICAgcmV0dXJuIGRhdGFbJ2NoYXJzJ10udG9TdHJpbmcoKTtcbiAgfTtcbiAgcnNsU2hpbS5lbmNvZGUgPSAoc3RyLCBiLCBvZmZzZXQpID0+IHtcbiAgICBjb25zdCBkYXRhID0ge1xuICAgICAgY2hhcnM6IEJ1ZmZlci5mcm9tKHN0ciwgJ3V0ZjgnKVxuICAgIH07XG4gICAgcmV0dXJuIF9lbmNvZGUoZGF0YSwgYiwgb2Zmc2V0KTtcbiAgfTtcbiAgcnNsU2hpbS5hbGxvYyA9IHN0ciA9PiB7XG4gICAgcmV0dXJuIEJ1ZmZlckxheW91dC51MzIoKS5zcGFuICsgQnVmZmVyTGF5b3V0LnUzMigpLnNwYW4gKyBCdWZmZXIuZnJvbShzdHIsICd1dGY4JykubGVuZ3RoO1xuICB9O1xuICByZXR1cm4gcnNsU2hpbTtcbn07XG5cbi8qKlxuICogTGF5b3V0IGZvciBhbiBBdXRob3JpemVkIG9iamVjdFxuICovXG5jb25zdCBhdXRob3JpemVkID0gKHByb3BlcnR5ID0gJ2F1dGhvcml6ZWQnKSA9PiB7XG4gIHJldHVybiBCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ3N0YWtlcicpLCBwdWJsaWNLZXkoJ3dpdGhkcmF3ZXInKV0sIHByb3BlcnR5KTtcbn07XG5cbi8qKlxuICogTGF5b3V0IGZvciBhIExvY2t1cCBvYmplY3RcbiAqL1xuY29uc3QgbG9ja3VwID0gKHByb3BlcnR5ID0gJ2xvY2t1cCcpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5uczY0KCd1bml4VGltZXN0YW1wJyksIEJ1ZmZlckxheW91dC5uczY0KCdlcG9jaCcpLCBwdWJsaWNLZXkoJ2N1c3RvZGlhbicpXSwgcHJvcGVydHkpO1xufTtcblxuLyoqXG4gKiAgTGF5b3V0IGZvciBhIFZvdGVJbml0IG9iamVjdFxuICovXG5jb25zdCB2b3RlSW5pdCA9IChwcm9wZXJ0eSA9ICd2b3RlSW5pdCcpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW3B1YmxpY0tleSgnbm9kZVB1YmtleScpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWRWb3RlcicpLCBwdWJsaWNLZXkoJ2F1dGhvcml6ZWRXaXRoZHJhd2VyJyksIEJ1ZmZlckxheW91dC51OCgnY29tbWlzc2lvbicpXSwgcHJvcGVydHkpO1xufTtcblxuLyoqXG4gKiAgTGF5b3V0IGZvciBhIFZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3Mgb2JqZWN0XG4gKi9cbmNvbnN0IHZvdGVBdXRob3JpemVXaXRoU2VlZEFyZ3MgPSAocHJvcGVydHkgPSAndm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncycpID0+IHtcbiAgcmV0dXJuIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ3ZvdGVBdXRob3JpemF0aW9uVHlwZScpLCBwdWJsaWNLZXkoJ2N1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXknKSwgcnVzdFN0cmluZygnY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkJyksIHB1YmxpY0tleSgnbmV3QXV0aG9yaXplZCcpXSwgcHJvcGVydHkpO1xufTtcbmZ1bmN0aW9uIGdldEFsbG9jKHR5cGUsIGZpZWxkcykge1xuICBjb25zdCBnZXRJdGVtQWxsb2MgPSBpdGVtID0+IHtcbiAgICBpZiAoaXRlbS5zcGFuID49IDApIHtcbiAgICAgIHJldHVybiBpdGVtLnNwYW47XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaXRlbS5hbGxvYyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGl0ZW0uYWxsb2MoZmllbGRzW2l0ZW0ucHJvcGVydHldKTtcbiAgICB9IGVsc2UgaWYgKCdjb3VudCcgaW4gaXRlbSAmJiAnZWxlbWVudExheW91dCcgaW4gaXRlbSkge1xuICAgICAgY29uc3QgZmllbGQgPSBmaWVsZHNbaXRlbS5wcm9wZXJ0eV07XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZCkpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkLmxlbmd0aCAqIGdldEl0ZW1BbGxvYyhpdGVtLmVsZW1lbnRMYXlvdXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoJ2ZpZWxkcycgaW4gaXRlbSkge1xuICAgICAgLy8gVGhpcyBpcyBhIGBTdHJ1Y3R1cmVgIHdob3NlIHNpemUgbmVlZHMgdG8gYmUgcmVjdXJzaXZlbHkgbWVhc3VyZWQuXG4gICAgICByZXR1cm4gZ2V0QWxsb2Moe1xuICAgICAgICBsYXlvdXQ6IGl0ZW1cbiAgICAgIH0sIGZpZWxkc1tpdGVtLnByb3BlcnR5XSk7XG4gICAgfVxuICAgIC8vIENvdWxkbid0IGRldGVybWluZSBhbGxvY2F0ZWQgc2l6ZSBvZiBsYXlvdXRcbiAgICByZXR1cm4gMDtcbiAgfTtcbiAgbGV0IGFsbG9jID0gMDtcbiAgdHlwZS5sYXlvdXQuZmllbGRzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgYWxsb2MgKz0gZ2V0SXRlbUFsbG9jKGl0ZW0pO1xuICB9KTtcbiAgcmV0dXJuIGFsbG9jO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVMZW5ndGgoYnl0ZXMpIHtcbiAgbGV0IGxlbiA9IDA7XG4gIGxldCBzaXplID0gMDtcbiAgZm9yICg7Oykge1xuICAgIGxldCBlbGVtID0gYnl0ZXMuc2hpZnQoKTtcbiAgICBsZW4gfD0gKGVsZW0gJiAweDdmKSA8PCBzaXplICogNztcbiAgICBzaXplICs9IDE7XG4gICAgaWYgKChlbGVtICYgMHg4MCkgPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbGVuO1xufVxuZnVuY3Rpb24gZW5jb2RlTGVuZ3RoKGJ5dGVzLCBsZW4pIHtcbiAgbGV0IHJlbV9sZW4gPSBsZW47XG4gIGZvciAoOzspIHtcbiAgICBsZXQgZWxlbSA9IHJlbV9sZW4gJiAweDdmO1xuICAgIHJlbV9sZW4gPj49IDc7XG4gICAgaWYgKHJlbV9sZW4gPT0gMCkge1xuICAgICAgYnl0ZXMucHVzaChlbGVtKTtcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtIHw9IDB4ODA7XG4gICAgICBieXRlcy5wdXNoKGVsZW0pO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhc3NlcnQgKGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihtZXNzYWdlIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG4gIH1cbn1cblxuY2xhc3MgQ29tcGlsZWRLZXlzIHtcbiAgY29uc3RydWN0b3IocGF5ZXIsIGtleU1ldGFNYXApIHtcbiAgICB0aGlzLnBheWVyID0gdm9pZCAwO1xuICAgIHRoaXMua2V5TWV0YU1hcCA9IHZvaWQgMDtcbiAgICB0aGlzLnBheWVyID0gcGF5ZXI7XG4gICAgdGhpcy5rZXlNZXRhTWFwID0ga2V5TWV0YU1hcDtcbiAgfVxuICBzdGF0aWMgY29tcGlsZShpbnN0cnVjdGlvbnMsIHBheWVyKSB7XG4gICAgY29uc3Qga2V5TWV0YU1hcCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBnZXRPckluc2VydERlZmF1bHQgPSBwdWJrZXkgPT4ge1xuICAgICAgY29uc3QgYWRkcmVzcyA9IHB1YmtleS50b0Jhc2U1OCgpO1xuICAgICAgbGV0IGtleU1ldGEgPSBrZXlNZXRhTWFwLmdldChhZGRyZXNzKTtcbiAgICAgIGlmIChrZXlNZXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAga2V5TWV0YSA9IHtcbiAgICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgICAgaXNXcml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgaXNJbnZva2VkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBrZXlNZXRhTWFwLnNldChhZGRyZXNzLCBrZXlNZXRhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBrZXlNZXRhO1xuICAgIH07XG4gICAgY29uc3QgcGF5ZXJLZXlNZXRhID0gZ2V0T3JJbnNlcnREZWZhdWx0KHBheWVyKTtcbiAgICBwYXllcktleU1ldGEuaXNTaWduZXIgPSB0cnVlO1xuICAgIHBheWVyS2V5TWV0YS5pc1dyaXRhYmxlID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IGl4IG9mIGluc3RydWN0aW9ucykge1xuICAgICAgZ2V0T3JJbnNlcnREZWZhdWx0KGl4LnByb2dyYW1JZCkuaXNJbnZva2VkID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgYWNjb3VudE1ldGEgb2YgaXgua2V5cykge1xuICAgICAgICBjb25zdCBrZXlNZXRhID0gZ2V0T3JJbnNlcnREZWZhdWx0KGFjY291bnRNZXRhLnB1YmtleSk7XG4gICAgICAgIGtleU1ldGEuaXNTaWduZXIgfHw9IGFjY291bnRNZXRhLmlzU2lnbmVyO1xuICAgICAgICBrZXlNZXRhLmlzV3JpdGFibGUgfHw9IGFjY291bnRNZXRhLmlzV3JpdGFibGU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgQ29tcGlsZWRLZXlzKHBheWVyLCBrZXlNZXRhTWFwKTtcbiAgfVxuICBnZXRNZXNzYWdlQ29tcG9uZW50cygpIHtcbiAgICBjb25zdCBtYXBFbnRyaWVzID0gWy4uLnRoaXMua2V5TWV0YU1hcC5lbnRyaWVzKCldO1xuICAgIGFzc2VydChtYXBFbnRyaWVzLmxlbmd0aCA8PSAyNTYsICdNYXggc3RhdGljIGFjY291bnQga2V5cyBsZW5ndGggZXhjZWVkZWQnKTtcbiAgICBjb25zdCB3cml0YWJsZVNpZ25lcnMgPSBtYXBFbnRyaWVzLmZpbHRlcigoWywgbWV0YV0pID0+IG1ldGEuaXNTaWduZXIgJiYgbWV0YS5pc1dyaXRhYmxlKTtcbiAgICBjb25zdCByZWFkb25seVNpZ25lcnMgPSBtYXBFbnRyaWVzLmZpbHRlcigoWywgbWV0YV0pID0+IG1ldGEuaXNTaWduZXIgJiYgIW1ldGEuaXNXcml0YWJsZSk7XG4gICAgY29uc3Qgd3JpdGFibGVOb25TaWduZXJzID0gbWFwRW50cmllcy5maWx0ZXIoKFssIG1ldGFdKSA9PiAhbWV0YS5pc1NpZ25lciAmJiBtZXRhLmlzV3JpdGFibGUpO1xuICAgIGNvbnN0IHJlYWRvbmx5Tm9uU2lnbmVycyA9IG1hcEVudHJpZXMuZmlsdGVyKChbLCBtZXRhXSkgPT4gIW1ldGEuaXNTaWduZXIgJiYgIW1ldGEuaXNXcml0YWJsZSk7XG4gICAgY29uc3QgaGVhZGVyID0ge1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiB3cml0YWJsZVNpZ25lcnMubGVuZ3RoICsgcmVhZG9ubHlTaWduZXJzLmxlbmd0aCxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM6IHJlYWRvbmx5U2lnbmVycy5sZW5ndGgsXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IHJlYWRvbmx5Tm9uU2lnbmVycy5sZW5ndGhcbiAgICB9O1xuXG4gICAgLy8gc2FuaXR5IGNoZWNrc1xuICAgIHtcbiAgICAgIGFzc2VydCh3cml0YWJsZVNpZ25lcnMubGVuZ3RoID4gMCwgJ0V4cGVjdGVkIGF0IGxlYXN0IG9uZSB3cml0YWJsZSBzaWduZXIga2V5Jyk7XG4gICAgICBjb25zdCBbcGF5ZXJBZGRyZXNzXSA9IHdyaXRhYmxlU2lnbmVyc1swXTtcbiAgICAgIGFzc2VydChwYXllckFkZHJlc3MgPT09IHRoaXMucGF5ZXIudG9CYXNlNTgoKSwgJ0V4cGVjdGVkIGZpcnN0IHdyaXRhYmxlIHNpZ25lciBrZXkgdG8gYmUgdGhlIGZlZSBwYXllcicpO1xuICAgIH1cbiAgICBjb25zdCBzdGF0aWNBY2NvdW50S2V5cyA9IFsuLi53cml0YWJsZVNpZ25lcnMubWFwKChbYWRkcmVzc10pID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpLCAuLi5yZWFkb25seVNpZ25lcnMubWFwKChbYWRkcmVzc10pID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpLCAuLi53cml0YWJsZU5vblNpZ25lcnMubWFwKChbYWRkcmVzc10pID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpLCAuLi5yZWFkb25seU5vblNpZ25lcnMubWFwKChbYWRkcmVzc10pID0+IG5ldyBQdWJsaWNLZXkoYWRkcmVzcykpXTtcbiAgICByZXR1cm4gW2hlYWRlciwgc3RhdGljQWNjb3VudEtleXNdO1xuICB9XG4gIGV4dHJhY3RUYWJsZUxvb2t1cChsb29rdXBUYWJsZSkge1xuICAgIGNvbnN0IFt3cml0YWJsZUluZGV4ZXMsIGRyYWluZWRXcml0YWJsZUtleXNdID0gdGhpcy5kcmFpbktleXNGb3VuZEluTG9va3VwVGFibGUobG9va3VwVGFibGUuc3RhdGUuYWRkcmVzc2VzLCBrZXlNZXRhID0+ICFrZXlNZXRhLmlzU2lnbmVyICYmICFrZXlNZXRhLmlzSW52b2tlZCAmJiBrZXlNZXRhLmlzV3JpdGFibGUpO1xuICAgIGNvbnN0IFtyZWFkb25seUluZGV4ZXMsIGRyYWluZWRSZWFkb25seUtleXNdID0gdGhpcy5kcmFpbktleXNGb3VuZEluTG9va3VwVGFibGUobG9va3VwVGFibGUuc3RhdGUuYWRkcmVzc2VzLCBrZXlNZXRhID0+ICFrZXlNZXRhLmlzU2lnbmVyICYmICFrZXlNZXRhLmlzSW52b2tlZCAmJiAha2V5TWV0YS5pc1dyaXRhYmxlKTtcblxuICAgIC8vIERvbid0IGV4dHJhY3QgbG9va3VwIGlmIG5vIGtleXMgd2VyZSBmb3VuZFxuICAgIGlmICh3cml0YWJsZUluZGV4ZXMubGVuZ3RoID09PSAwICYmIHJlYWRvbmx5SW5kZXhlcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuIFt7XG4gICAgICBhY2NvdW50S2V5OiBsb29rdXBUYWJsZS5rZXksXG4gICAgICB3cml0YWJsZUluZGV4ZXMsXG4gICAgICByZWFkb25seUluZGV4ZXNcbiAgICB9LCB7XG4gICAgICB3cml0YWJsZTogZHJhaW5lZFdyaXRhYmxlS2V5cyxcbiAgICAgIHJlYWRvbmx5OiBkcmFpbmVkUmVhZG9ubHlLZXlzXG4gICAgfV07XG4gIH1cblxuICAvKiogQGludGVybmFsICovXG4gIGRyYWluS2V5c0ZvdW5kSW5Mb29rdXBUYWJsZShsb29rdXBUYWJsZUVudHJpZXMsIGtleU1ldGFGaWx0ZXIpIHtcbiAgICBjb25zdCBsb29rdXBUYWJsZUluZGV4ZXMgPSBuZXcgQXJyYXkoKTtcbiAgICBjb25zdCBkcmFpbmVkS2V5cyA9IG5ldyBBcnJheSgpO1xuICAgIGZvciAoY29uc3QgW2FkZHJlc3MsIGtleU1ldGFdIG9mIHRoaXMua2V5TWV0YU1hcC5lbnRyaWVzKCkpIHtcbiAgICAgIGlmIChrZXlNZXRhRmlsdGVyKGtleU1ldGEpKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IG5ldyBQdWJsaWNLZXkoYWRkcmVzcyk7XG4gICAgICAgIGNvbnN0IGxvb2t1cFRhYmxlSW5kZXggPSBsb29rdXBUYWJsZUVudHJpZXMuZmluZEluZGV4KGVudHJ5ID0+IGVudHJ5LmVxdWFscyhrZXkpKTtcbiAgICAgICAgaWYgKGxvb2t1cFRhYmxlSW5kZXggPj0gMCkge1xuICAgICAgICAgIGFzc2VydChsb29rdXBUYWJsZUluZGV4IDwgMjU2LCAnTWF4IGxvb2t1cCB0YWJsZSBpbmRleCBleGNlZWRlZCcpO1xuICAgICAgICAgIGxvb2t1cFRhYmxlSW5kZXhlcy5wdXNoKGxvb2t1cFRhYmxlSW5kZXgpO1xuICAgICAgICAgIGRyYWluZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICB0aGlzLmtleU1ldGFNYXAuZGVsZXRlKGFkZHJlc3MpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbbG9va3VwVGFibGVJbmRleGVzLCBkcmFpbmVkS2V5c107XG4gIH1cbn1cblxuY29uc3QgRU5EX09GX0JVRkZFUl9FUlJPUl9NRVNTQUdFID0gJ1JlYWNoZWQgZW5kIG9mIGJ1ZmZlciB1bmV4cGVjdGVkbHknO1xuXG4vKipcbiAqIERlbGVnYXRlcyB0byBgQXJyYXkjc2hpZnRgLCBidXQgdGhyb3dzIGlmIHRoZSBhcnJheSBpcyB6ZXJvLWxlbmd0aC5cbiAqL1xuZnVuY3Rpb24gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSkge1xuICBpZiAoYnl0ZUFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihFTkRfT0ZfQlVGRkVSX0VSUk9SX01FU1NBR0UpO1xuICB9XG4gIHJldHVybiBieXRlQXJyYXkuc2hpZnQoKTtcbn1cblxuLyoqXG4gKiBEZWxlZ2F0ZXMgdG8gYEFycmF5I3NwbGljZWAsIGJ1dCB0aHJvd3MgaWYgdGhlIHNlY3Rpb24gYmVpbmcgc3BsaWNlZCBvdXQgZXh0ZW5kcyBwYXN0IHRoZSBlbmQgb2ZcbiAqIHRoZSBhcnJheS5cbiAqL1xuZnVuY3Rpb24gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIC4uLmFyZ3MpIHtcbiAgY29uc3QgW3N0YXJ0XSA9IGFyZ3M7XG4gIGlmIChhcmdzLmxlbmd0aCA9PT0gMiAvLyBJbXBsaWVzIHRoYXQgYGRlbGV0ZUNvdW50YCB3YXMgc3VwcGxpZWRcbiAgPyBzdGFydCArIChhcmdzWzFdID8/IDApID4gYnl0ZUFycmF5Lmxlbmd0aCA6IHN0YXJ0ID49IGJ5dGVBcnJheS5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRU5EX09GX0JVRkZFUl9FUlJPUl9NRVNTQUdFKTtcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5LnNwbGljZSguLi5hcmdzKTtcbn1cblxuLyoqXG4gKiBBbiBpbnN0cnVjdGlvbiB0byBleGVjdXRlIGJ5IGEgcHJvZ3JhbVxuICpcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcm9ncmFtSWRJbmRleFxuICogQHByb3BlcnR5IHtudW1iZXJbXX0gYWNjb3VudHNcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkYXRhXG4gKi9cblxuLyoqXG4gKiBNZXNzYWdlIGNvbnN0cnVjdG9yIGFyZ3VtZW50c1xuICovXG5cbi8qKlxuICogTGlzdCBvZiBpbnN0cnVjdGlvbnMgdG8gYmUgcHJvY2Vzc2VkIGF0b21pY2FsbHlcbiAqL1xuY2xhc3MgTWVzc2FnZSB7XG4gIGNvbnN0cnVjdG9yKGFyZ3MpIHtcbiAgICB0aGlzLmhlYWRlciA9IHZvaWQgMDtcbiAgICB0aGlzLmFjY291bnRLZXlzID0gdm9pZCAwO1xuICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gdm9pZCAwO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gdm9pZCAwO1xuICAgIHRoaXMuaW5kZXhUb1Byb2dyYW1JZHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5oZWFkZXIgPSBhcmdzLmhlYWRlcjtcbiAgICB0aGlzLmFjY291bnRLZXlzID0gYXJncy5hY2NvdW50S2V5cy5tYXAoYWNjb3VudCA9PiBuZXcgUHVibGljS2V5KGFjY291bnQpKTtcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IGFyZ3MucmVjZW50QmxvY2toYXNoO1xuICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gYXJncy5pbnN0cnVjdGlvbnM7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMuZm9yRWFjaChpeCA9PiB0aGlzLmluZGV4VG9Qcm9ncmFtSWRzLnNldChpeC5wcm9ncmFtSWRJbmRleCwgdGhpcy5hY2NvdW50S2V5c1tpeC5wcm9ncmFtSWRJbmRleF0pKTtcbiAgfVxuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gJ2xlZ2FjeSc7XG4gIH1cbiAgZ2V0IHN0YXRpY0FjY291bnRLZXlzKCkge1xuICAgIHJldHVybiB0aGlzLmFjY291bnRLZXlzO1xuICB9XG4gIGdldCBjb21waWxlZEluc3RydWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnMubWFwKGl4ID0+ICh7XG4gICAgICBwcm9ncmFtSWRJbmRleDogaXgucHJvZ3JhbUlkSW5kZXgsXG4gICAgICBhY2NvdW50S2V5SW5kZXhlczogaXguYWNjb3VudHMsXG4gICAgICBkYXRhOiBiczU4LmRlY29kZShpeC5kYXRhKVxuICAgIH0pKTtcbiAgfVxuICBnZXQgYWRkcmVzc1RhYmxlTG9va3VwcygpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgZ2V0QWNjb3VudEtleXMoKSB7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlQWNjb3VudEtleXModGhpcy5zdGF0aWNBY2NvdW50S2V5cyk7XG4gIH1cbiAgc3RhdGljIGNvbXBpbGUoYXJncykge1xuICAgIGNvbnN0IGNvbXBpbGVkS2V5cyA9IENvbXBpbGVkS2V5cy5jb21waWxlKGFyZ3MuaW5zdHJ1Y3Rpb25zLCBhcmdzLnBheWVyS2V5KTtcbiAgICBjb25zdCBbaGVhZGVyLCBzdGF0aWNBY2NvdW50S2V5c10gPSBjb21waWxlZEtleXMuZ2V0TWVzc2FnZUNvbXBvbmVudHMoKTtcbiAgICBjb25zdCBhY2NvdW50S2V5cyA9IG5ldyBNZXNzYWdlQWNjb3VudEtleXMoc3RhdGljQWNjb3VudEtleXMpO1xuICAgIGNvbnN0IGluc3RydWN0aW9ucyA9IGFjY291bnRLZXlzLmNvbXBpbGVJbnN0cnVjdGlvbnMoYXJncy5pbnN0cnVjdGlvbnMpLm1hcChpeCA9PiAoe1xuICAgICAgcHJvZ3JhbUlkSW5kZXg6IGl4LnByb2dyYW1JZEluZGV4LFxuICAgICAgYWNjb3VudHM6IGl4LmFjY291bnRLZXlJbmRleGVzLFxuICAgICAgZGF0YTogYnM1OC5lbmNvZGUoaXguZGF0YSlcbiAgICB9KSk7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlKHtcbiAgICAgIGhlYWRlcixcbiAgICAgIGFjY291bnRLZXlzOiBzdGF0aWNBY2NvdW50S2V5cyxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYXJncy5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBpbnN0cnVjdGlvbnNcbiAgICB9KTtcbiAgfVxuICBpc0FjY291bnRTaWduZXIoaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPCB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gIH1cbiAgaXNBY2NvdW50V3JpdGFibGUoaW5kZXgpIHtcbiAgICBjb25zdCBudW1TaWduZWRBY2NvdW50cyA9IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgICBpZiAoaW5kZXggPj0gdGhpcy5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzKSB7XG4gICAgICBjb25zdCB1bnNpZ25lZEFjY291bnRJbmRleCA9IGluZGV4IC0gbnVtU2lnbmVkQWNjb3VudHM7XG4gICAgICBjb25zdCBudW1VbnNpZ25lZEFjY291bnRzID0gdGhpcy5hY2NvdW50S2V5cy5sZW5ndGggLSBudW1TaWduZWRBY2NvdW50cztcbiAgICAgIGNvbnN0IG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cyA9IG51bVVuc2lnbmVkQWNjb3VudHMgLSB0aGlzLmhlYWRlci5udW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM7XG4gICAgICByZXR1cm4gdW5zaWduZWRBY2NvdW50SW5kZXggPCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMgPSBudW1TaWduZWRBY2NvdW50cyAtIHRoaXMuaGVhZGVyLm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM7XG4gICAgICByZXR1cm4gaW5kZXggPCBudW1Xcml0YWJsZVNpZ25lZEFjY291bnRzO1xuICAgIH1cbiAgfVxuICBpc1Byb2dyYW1JZChpbmRleCkge1xuICAgIHJldHVybiB0aGlzLmluZGV4VG9Qcm9ncmFtSWRzLmhhcyhpbmRleCk7XG4gIH1cbiAgcHJvZ3JhbUlkcygpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMuaW5kZXhUb1Byb2dyYW1JZHMudmFsdWVzKCldO1xuICB9XG4gIG5vblByb2dyYW1JZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuYWNjb3VudEtleXMuZmlsdGVyKChfLCBpbmRleCkgPT4gIXRoaXMuaXNQcm9ncmFtSWQoaW5kZXgpKTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgY29uc3QgbnVtS2V5cyA9IHRoaXMuYWNjb3VudEtleXMubGVuZ3RoO1xuICAgIGxldCBrZXlDb3VudCA9IFtdO1xuICAgIGVuY29kZUxlbmd0aChrZXlDb3VudCwgbnVtS2V5cyk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gdGhpcy5pbnN0cnVjdGlvbnMubWFwKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWNjb3VudHMsXG4gICAgICAgIHByb2dyYW1JZEluZGV4XG4gICAgICB9ID0gaW5zdHJ1Y3Rpb247XG4gICAgICBjb25zdCBkYXRhID0gQXJyYXkuZnJvbShiczU4LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKSk7XG4gICAgICBsZXQga2V5SW5kaWNlc0NvdW50ID0gW107XG4gICAgICBlbmNvZGVMZW5ndGgoa2V5SW5kaWNlc0NvdW50LCBhY2NvdW50cy5sZW5ndGgpO1xuICAgICAgbGV0IGRhdGFDb3VudCA9IFtdO1xuICAgICAgZW5jb2RlTGVuZ3RoKGRhdGFDb3VudCwgZGF0YS5sZW5ndGgpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGtleUluZGljZXNDb3VudDogQnVmZmVyLmZyb20oa2V5SW5kaWNlc0NvdW50KSxcbiAgICAgICAga2V5SW5kaWNlczogYWNjb3VudHMsXG4gICAgICAgIGRhdGFMZW5ndGg6IEJ1ZmZlci5mcm9tKGRhdGFDb3VudCksXG4gICAgICAgIGRhdGFcbiAgICAgIH07XG4gICAgfSk7XG4gICAgbGV0IGluc3RydWN0aW9uQ291bnQgPSBbXTtcbiAgICBlbmNvZGVMZW5ndGgoaW5zdHJ1Y3Rpb25Db3VudCwgaW5zdHJ1Y3Rpb25zLmxlbmd0aCk7XG4gICAgbGV0IGluc3RydWN0aW9uQnVmZmVyID0gQnVmZmVyLmFsbG9jKFBBQ0tFVF9EQVRBX1NJWkUpO1xuICAgIEJ1ZmZlci5mcm9tKGluc3RydWN0aW9uQ291bnQpLmNvcHkoaW5zdHJ1Y3Rpb25CdWZmZXIpO1xuICAgIGxldCBpbnN0cnVjdGlvbkJ1ZmZlckxlbmd0aCA9IGluc3RydWN0aW9uQ291bnQubGVuZ3RoO1xuICAgIGluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdwcm9ncmFtSWRJbmRleCcpLCBCdWZmZXJMYXlvdXQuYmxvYihpbnN0cnVjdGlvbi5rZXlJbmRpY2VzQ291bnQubGVuZ3RoLCAna2V5SW5kaWNlc0NvdW50JyksIEJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnU4KCdrZXlJbmRleCcpLCBpbnN0cnVjdGlvbi5rZXlJbmRpY2VzLmxlbmd0aCwgJ2tleUluZGljZXMnKSwgQnVmZmVyTGF5b3V0LmJsb2IoaW5zdHJ1Y3Rpb24uZGF0YUxlbmd0aC5sZW5ndGgsICdkYXRhTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnU4KCd1c2VyZGF0dW0nKSwgaW5zdHJ1Y3Rpb24uZGF0YS5sZW5ndGgsICdkYXRhJyldKTtcbiAgICAgIGNvbnN0IGxlbmd0aCA9IGluc3RydWN0aW9uTGF5b3V0LmVuY29kZShpbnN0cnVjdGlvbiwgaW5zdHJ1Y3Rpb25CdWZmZXIsIGluc3RydWN0aW9uQnVmZmVyTGVuZ3RoKTtcbiAgICAgIGluc3RydWN0aW9uQnVmZmVyTGVuZ3RoICs9IGxlbmd0aDtcbiAgICB9KTtcbiAgICBpbnN0cnVjdGlvbkJ1ZmZlciA9IGluc3RydWN0aW9uQnVmZmVyLnNsaWNlKDAsIGluc3RydWN0aW9uQnVmZmVyTGVuZ3RoKTtcbiAgICBjb25zdCBzaWduRGF0YUxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5ibG9iKDEsICdudW1SZXF1aXJlZFNpZ25hdHVyZXMnKSwgQnVmZmVyTGF5b3V0LmJsb2IoMSwgJ251bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMnKSwgQnVmZmVyTGF5b3V0LmJsb2IoMSwgJ251bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cycpLCBCdWZmZXJMYXlvdXQuYmxvYihrZXlDb3VudC5sZW5ndGgsICdrZXlDb3VudCcpLCBCdWZmZXJMYXlvdXQuc2VxKHB1YmxpY0tleSgna2V5JyksIG51bUtleXMsICdrZXlzJyksIHB1YmxpY0tleSgncmVjZW50QmxvY2toYXNoJyldKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHtcbiAgICAgIG51bVJlcXVpcmVkU2lnbmF0dXJlczogQnVmZmVyLmZyb20oW3RoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlc10pLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogQnVmZmVyLmZyb20oW3RoaXMuaGVhZGVyLm51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHNdKSxcbiAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50czogQnVmZmVyLmZyb20oW3RoaXMuaGVhZGVyLm51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50c10pLFxuICAgICAga2V5Q291bnQ6IEJ1ZmZlci5mcm9tKGtleUNvdW50KSxcbiAgICAgIGtleXM6IHRoaXMuYWNjb3VudEtleXMubWFwKGtleSA9PiB0b0J1ZmZlcihrZXkudG9CeXRlcygpKSksXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGJzNTguZGVjb2RlKHRoaXMucmVjZW50QmxvY2toYXNoKVxuICAgIH07XG4gICAgbGV0IHNpZ25EYXRhID0gQnVmZmVyLmFsbG9jKDIwNDgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IHNpZ25EYXRhTGF5b3V0LmVuY29kZSh0cmFuc2FjdGlvbiwgc2lnbkRhdGEpO1xuICAgIGluc3RydWN0aW9uQnVmZmVyLmNvcHkoc2lnbkRhdGEsIGxlbmd0aCk7XG4gICAgcmV0dXJuIHNpZ25EYXRhLnNsaWNlKDAsIGxlbmd0aCArIGluc3RydWN0aW9uQnVmZmVyLmxlbmd0aCk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgY29tcGlsZWQgbWVzc2FnZSBpbnRvIGEgTWVzc2FnZSBvYmplY3QuXG4gICAqL1xuICBzdGF0aWMgZnJvbShidWZmZXIpIHtcbiAgICAvLyBTbGljZSB1cCB3aXJlIGRhdGFcbiAgICBsZXQgYnl0ZUFycmF5ID0gWy4uLmJ1ZmZlcl07XG4gICAgY29uc3QgbnVtUmVxdWlyZWRTaWduYXR1cmVzID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSk7XG4gICAgaWYgKG51bVJlcXVpcmVkU2lnbmF0dXJlcyAhPT0gKG51bVJlcXVpcmVkU2lnbmF0dXJlcyAmIFZFUlNJT05fUFJFRklYX01BU0spKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1ZlcnNpb25lZCBtZXNzYWdlcyBtdXN0IGJlIGRlc2VyaWFsaXplZCB3aXRoIFZlcnNpb25lZE1lc3NhZ2UuZGVzZXJpYWxpemUoKScpO1xuICAgIH1cbiAgICBjb25zdCBudW1SZWFkb25seVNpZ25lZEFjY291bnRzID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSk7XG4gICAgY29uc3QgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSk7XG4gICAgY29uc3QgYWNjb3VudENvdW50ID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgbGV0IGFjY291bnRLZXlzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhY2NvdW50Q291bnQ7IGkrKykge1xuICAgICAgY29uc3QgYWNjb3VudCA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCk7XG4gICAgICBhY2NvdW50S2V5cy5wdXNoKG5ldyBQdWJsaWNLZXkoQnVmZmVyLmZyb20oYWNjb3VudCkpKTtcbiAgICB9XG4gICAgY29uc3QgcmVjZW50QmxvY2toYXNoID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvbkNvdW50ID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgbGV0IGluc3RydWN0aW9ucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25Db3VudDsgaSsrKSB7XG4gICAgICBjb25zdCBwcm9ncmFtSWRJbmRleCA9IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgYWNjb3VudENvdW50ID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBhY2NvdW50cyA9IGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBhY2NvdW50Q291bnQpO1xuICAgICAgY29uc3QgZGF0YUxlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgZGF0YVNsaWNlID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIGRhdGFMZW5ndGgpO1xuICAgICAgY29uc3QgZGF0YSA9IGJzNTguZW5jb2RlKEJ1ZmZlci5mcm9tKGRhdGFTbGljZSkpO1xuICAgICAgaW5zdHJ1Y3Rpb25zLnB1c2goe1xuICAgICAgICBwcm9ncmFtSWRJbmRleCxcbiAgICAgICAgYWNjb3VudHMsXG4gICAgICAgIGRhdGFcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlQXJncyA9IHtcbiAgICAgIGhlYWRlcjoge1xuICAgICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXMsXG4gICAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMsXG4gICAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50c1xuICAgICAgfSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYnM1OC5lbmNvZGUoQnVmZmVyLmZyb20ocmVjZW50QmxvY2toYXNoKSksXG4gICAgICBhY2NvdW50S2V5cyxcbiAgICAgIGluc3RydWN0aW9uc1xuICAgIH07XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlKG1lc3NhZ2VBcmdzKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lc3NhZ2UgY29uc3RydWN0b3IgYXJndW1lbnRzXG4gKi9cblxuY2xhc3MgTWVzc2FnZVYwIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMuaGVhZGVyID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdGljQWNjb3VudEtleXMgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSB2b2lkIDA7XG4gICAgdGhpcy5jb21waWxlZEluc3RydWN0aW9ucyA9IHZvaWQgMDtcbiAgICB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMgPSB2b2lkIDA7XG4gICAgdGhpcy5oZWFkZXIgPSBhcmdzLmhlYWRlcjtcbiAgICB0aGlzLnN0YXRpY0FjY291bnRLZXlzID0gYXJncy5zdGF0aWNBY2NvdW50S2V5cztcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IGFyZ3MucmVjZW50QmxvY2toYXNoO1xuICAgIHRoaXMuY29tcGlsZWRJbnN0cnVjdGlvbnMgPSBhcmdzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zO1xuICAgIHRoaXMuYWRkcmVzc1RhYmxlTG9va3VwcyA9IGFyZ3MuYWRkcmVzc1RhYmxlTG9va3VwcztcbiAgfVxuICBnZXQgdmVyc2lvbigpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBnZXQgbnVtQWNjb3VudEtleXNGcm9tTG9va3VwcygpIHtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAoY29uc3QgbG9va3VwIG9mIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcykge1xuICAgICAgY291bnQgKz0gbG9va3VwLnJlYWRvbmx5SW5kZXhlcy5sZW5ndGggKyBsb29rdXAud3JpdGFibGVJbmRleGVzLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xuICB9XG4gIGdldEFjY291bnRLZXlzKGFyZ3MpIHtcbiAgICBsZXQgYWNjb3VudEtleXNGcm9tTG9va3VwcztcbiAgICBpZiAoYXJncyAmJiAnYWNjb3VudEtleXNGcm9tTG9va3VwcycgaW4gYXJncyAmJiBhcmdzLmFjY291bnRLZXlzRnJvbUxvb2t1cHMpIHtcbiAgICAgIGlmICh0aGlzLm51bUFjY291bnRLZXlzRnJvbUxvb2t1cHMgIT0gYXJncy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzLndyaXRhYmxlLmxlbmd0aCArIGFyZ3MuYWNjb3VudEtleXNGcm9tTG9va3Vwcy5yZWFkb25seS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IGFjY291bnQga2V5cyBiZWNhdXNlIG9mIGEgbWlzbWF0Y2ggaW4gdGhlIG51bWJlciBvZiBhY2NvdW50IGtleXMgZnJvbSBsb29rdXBzJyk7XG4gICAgICB9XG4gICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzID0gYXJncy5hY2NvdW50S2V5c0Zyb21Mb29rdXBzO1xuICAgIH0gZWxzZSBpZiAoYXJncyAmJiAnYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMnIGluIGFyZ3MgJiYgYXJncy5hZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cykge1xuICAgICAgYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IHRoaXMucmVzb2x2ZUFkZHJlc3NUYWJsZUxvb2t1cHMoYXJncy5hZGRyZXNzTG9va3VwVGFibGVBY2NvdW50cyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gZ2V0IGFjY291bnQga2V5cyBiZWNhdXNlIGFkZHJlc3MgdGFibGUgbG9va3VwcyB3ZXJlIG5vdCByZXNvbHZlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VBY2NvdW50S2V5cyh0aGlzLnN0YXRpY0FjY291bnRLZXlzLCBhY2NvdW50S2V5c0Zyb21Mb29rdXBzKTtcbiAgfVxuICBpc0FjY291bnRTaWduZXIoaW5kZXgpIHtcbiAgICByZXR1cm4gaW5kZXggPCB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXM7XG4gIH1cbiAgaXNBY2NvdW50V3JpdGFibGUoaW5kZXgpIHtcbiAgICBjb25zdCBudW1TaWduZWRBY2NvdW50cyA9IHRoaXMuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgICBjb25zdCBudW1TdGF0aWNBY2NvdW50S2V5cyA9IHRoaXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoO1xuICAgIGlmIChpbmRleCA+PSBudW1TdGF0aWNBY2NvdW50S2V5cykge1xuICAgICAgY29uc3QgbG9va3VwQWNjb3VudEtleXNJbmRleCA9IGluZGV4IC0gbnVtU3RhdGljQWNjb3VudEtleXM7XG4gICAgICBjb25zdCBudW1Xcml0YWJsZUxvb2t1cEFjY291bnRLZXlzID0gdGhpcy5hZGRyZXNzVGFibGVMb29rdXBzLnJlZHVjZSgoY291bnQsIGxvb2t1cCkgPT4gY291bnQgKyBsb29rdXAud3JpdGFibGVJbmRleGVzLmxlbmd0aCwgMCk7XG4gICAgICByZXR1cm4gbG9va3VwQWNjb3VudEtleXNJbmRleCA8IG51bVdyaXRhYmxlTG9va3VwQWNjb3VudEtleXM7XG4gICAgfSBlbHNlIGlmIChpbmRleCA+PSB0aGlzLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpIHtcbiAgICAgIGNvbnN0IHVuc2lnbmVkQWNjb3VudEluZGV4ID0gaW5kZXggLSBudW1TaWduZWRBY2NvdW50cztcbiAgICAgIGNvbnN0IG51bVVuc2lnbmVkQWNjb3VudHMgPSBudW1TdGF0aWNBY2NvdW50S2V5cyAtIG51bVNpZ25lZEFjY291bnRzO1xuICAgICAgY29uc3QgbnVtV3JpdGFibGVVbnNpZ25lZEFjY291bnRzID0gbnVtVW5zaWduZWRBY2NvdW50cyAtIHRoaXMuaGVhZGVyLm51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cztcbiAgICAgIHJldHVybiB1bnNpZ25lZEFjY291bnRJbmRleCA8IG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cyA9IG51bVNpZ25lZEFjY291bnRzIC0gdGhpcy5oZWFkZXIubnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cztcbiAgICAgIHJldHVybiBpbmRleCA8IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHM7XG4gICAgfVxuICB9XG4gIHJlc29sdmVBZGRyZXNzVGFibGVMb29rdXBzKGFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzKSB7XG4gICAgY29uc3QgYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IHtcbiAgICAgIHdyaXRhYmxlOiBbXSxcbiAgICAgIHJlYWRvbmx5OiBbXVxuICAgIH07XG4gICAgZm9yIChjb25zdCB0YWJsZUxvb2t1cCBvZiB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMpIHtcbiAgICAgIGNvbnN0IHRhYmxlQWNjb3VudCA9IGFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzLmZpbmQoYWNjb3VudCA9PiBhY2NvdW50LmtleS5lcXVhbHModGFibGVMb29rdXAuYWNjb3VudEtleSkpO1xuICAgICAgaWYgKCF0YWJsZUFjY291bnQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBhZGRyZXNzIGxvb2t1cCB0YWJsZSBhY2NvdW50IGZvciB0YWJsZSBrZXkgJHt0YWJsZUxvb2t1cC5hY2NvdW50S2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHRhYmxlTG9va3VwLndyaXRhYmxlSW5kZXhlcykge1xuICAgICAgICBpZiAoaW5kZXggPCB0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzLmxlbmd0aCkge1xuICAgICAgICAgIGFjY291bnRLZXlzRnJvbUxvb2t1cHMud3JpdGFibGUucHVzaCh0YWJsZUFjY291bnQuc3RhdGUuYWRkcmVzc2VzW2luZGV4XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBhZGRyZXNzIGZvciBpbmRleCAke2luZGV4fSBpbiBhZGRyZXNzIGxvb2t1cCB0YWJsZSAke3RhYmxlTG9va3VwLmFjY291bnRLZXkudG9CYXNlNTgoKX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBpbmRleCBvZiB0YWJsZUxvb2t1cC5yZWFkb25seUluZGV4ZXMpIHtcbiAgICAgICAgaWYgKGluZGV4IDwgdGFibGVBY2NvdW50LnN0YXRlLmFkZHJlc3Nlcy5sZW5ndGgpIHtcbiAgICAgICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5LnB1c2godGFibGVBY2NvdW50LnN0YXRlLmFkZHJlc3Nlc1tpbmRleF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgYWRkcmVzcyBmb3IgaW5kZXggJHtpbmRleH0gaW4gYWRkcmVzcyBsb29rdXAgdGFibGUgJHt0YWJsZUxvb2t1cC5hY2NvdW50S2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFjY291bnRLZXlzRnJvbUxvb2t1cHM7XG4gIH1cbiAgc3RhdGljIGNvbXBpbGUoYXJncykge1xuICAgIGNvbnN0IGNvbXBpbGVkS2V5cyA9IENvbXBpbGVkS2V5cy5jb21waWxlKGFyZ3MuaW5zdHJ1Y3Rpb25zLCBhcmdzLnBheWVyS2V5KTtcbiAgICBjb25zdCBhZGRyZXNzVGFibGVMb29rdXBzID0gbmV3IEFycmF5KCk7XG4gICAgY29uc3QgYWNjb3VudEtleXNGcm9tTG9va3VwcyA9IHtcbiAgICAgIHdyaXRhYmxlOiBuZXcgQXJyYXkoKSxcbiAgICAgIHJlYWRvbmx5OiBuZXcgQXJyYXkoKVxuICAgIH07XG4gICAgY29uc3QgbG9va3VwVGFibGVBY2NvdW50cyA9IGFyZ3MuYWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudHMgfHwgW107XG4gICAgZm9yIChjb25zdCBsb29rdXBUYWJsZSBvZiBsb29rdXBUYWJsZUFjY291bnRzKSB7XG4gICAgICBjb25zdCBleHRyYWN0UmVzdWx0ID0gY29tcGlsZWRLZXlzLmV4dHJhY3RUYWJsZUxvb2t1cChsb29rdXBUYWJsZSk7XG4gICAgICBpZiAoZXh0cmFjdFJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IFthZGRyZXNzVGFibGVMb29rdXAsIHtcbiAgICAgICAgICB3cml0YWJsZSxcbiAgICAgICAgICByZWFkb25seVxuICAgICAgICB9XSA9IGV4dHJhY3RSZXN1bHQ7XG4gICAgICAgIGFkZHJlc3NUYWJsZUxvb2t1cHMucHVzaChhZGRyZXNzVGFibGVMb29rdXApO1xuICAgICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzLndyaXRhYmxlLnB1c2goLi4ud3JpdGFibGUpO1xuICAgICAgICBhY2NvdW50S2V5c0Zyb21Mb29rdXBzLnJlYWRvbmx5LnB1c2goLi4ucmVhZG9ubHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBbaGVhZGVyLCBzdGF0aWNBY2NvdW50S2V5c10gPSBjb21waWxlZEtleXMuZ2V0TWVzc2FnZUNvbXBvbmVudHMoKTtcbiAgICBjb25zdCBhY2NvdW50S2V5cyA9IG5ldyBNZXNzYWdlQWNjb3VudEtleXMoc3RhdGljQWNjb3VudEtleXMsIGFjY291bnRLZXlzRnJvbUxvb2t1cHMpO1xuICAgIGNvbnN0IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gYWNjb3VudEtleXMuY29tcGlsZUluc3RydWN0aW9ucyhhcmdzLmluc3RydWN0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlVjAoe1xuICAgICAgaGVhZGVyLFxuICAgICAgc3RhdGljQWNjb3VudEtleXMsXG4gICAgICByZWNlbnRCbG9ja2hhc2g6IGFyZ3MucmVjZW50QmxvY2toYXNoLFxuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnMsXG4gICAgICBhZGRyZXNzVGFibGVMb29rdXBzXG4gICAgfSk7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIGNvbnN0IGVuY29kZWRTdGF0aWNBY2NvdW50S2V5c0xlbmd0aCA9IEFycmF5KCk7XG4gICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRTdGF0aWNBY2NvdW50S2V5c0xlbmd0aCwgdGhpcy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGgpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMgPSB0aGlzLnNlcmlhbGl6ZUluc3RydWN0aW9ucygpO1xuICAgIGNvbnN0IGVuY29kZWRJbnN0cnVjdGlvbnNMZW5ndGggPSBBcnJheSgpO1xuICAgIGVuY29kZUxlbmd0aChlbmNvZGVkSW5zdHJ1Y3Rpb25zTGVuZ3RoLCB0aGlzLmNvbXBpbGVkSW5zdHJ1Y3Rpb25zLmxlbmd0aCk7XG4gICAgY29uc3Qgc2VyaWFsaXplZEFkZHJlc3NUYWJsZUxvb2t1cHMgPSB0aGlzLnNlcmlhbGl6ZUFkZHJlc3NUYWJsZUxvb2t1cHMoKTtcbiAgICBjb25zdCBlbmNvZGVkQWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRBZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoLCB0aGlzLmFkZHJlc3NUYWJsZUxvb2t1cHMubGVuZ3RoKTtcbiAgICBjb25zdCBtZXNzYWdlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdwcmVmaXgnKSwgQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdudW1SZXF1aXJlZFNpZ25hdHVyZXMnKSwgQnVmZmVyTGF5b3V0LnU4KCdudW1SZWFkb25seVNpZ25lZEFjY291bnRzJyksIEJ1ZmZlckxheW91dC51OCgnbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzJyldLCAnaGVhZGVyJyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRTdGF0aWNBY2NvdW50S2V5c0xlbmd0aC5sZW5ndGgsICdzdGF0aWNBY2NvdW50S2V5c0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuc2VxKHB1YmxpY0tleSgpLCB0aGlzLnN0YXRpY0FjY291bnRLZXlzLmxlbmd0aCwgJ3N0YXRpY0FjY291bnRLZXlzJyksIHB1YmxpY0tleSgncmVjZW50QmxvY2toYXNoJyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRJbnN0cnVjdGlvbnNMZW5ndGgubGVuZ3RoLCAnaW5zdHJ1Y3Rpb25zTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5ibG9iKHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMubGVuZ3RoLCAnc2VyaWFsaXplZEluc3RydWN0aW9ucycpLCBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkQWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aC5sZW5ndGgsICdhZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5ibG9iKHNlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzLmxlbmd0aCwgJ3NlcmlhbGl6ZWRBZGRyZXNzVGFibGVMb29rdXBzJyldKTtcbiAgICBjb25zdCBzZXJpYWxpemVkTWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KFBBQ0tFVF9EQVRBX1NJWkUpO1xuICAgIGNvbnN0IE1FU1NBR0VfVkVSU0lPTl8wX1BSRUZJWCA9IDEgPDwgNztcbiAgICBjb25zdCBzZXJpYWxpemVkTWVzc2FnZUxlbmd0aCA9IG1lc3NhZ2VMYXlvdXQuZW5jb2RlKHtcbiAgICAgIHByZWZpeDogTUVTU0FHRV9WRVJTSU9OXzBfUFJFRklYLFxuICAgICAgaGVhZGVyOiB0aGlzLmhlYWRlcixcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkU3RhdGljQWNjb3VudEtleXNMZW5ndGgpLFxuICAgICAgc3RhdGljQWNjb3VudEtleXM6IHRoaXMuc3RhdGljQWNjb3VudEtleXMubWFwKGtleSA9PiBrZXkudG9CeXRlcygpKSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogYnM1OC5kZWNvZGUodGhpcy5yZWNlbnRCbG9ja2hhc2gpLFxuICAgICAgaW5zdHJ1Y3Rpb25zTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkSW5zdHJ1Y3Rpb25zTGVuZ3RoKSxcbiAgICAgIHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMsXG4gICAgICBhZGRyZXNzVGFibGVMb29rdXBzTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkQWRkcmVzc1RhYmxlTG9va3Vwc0xlbmd0aCksXG4gICAgICBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3Vwc1xuICAgIH0sIHNlcmlhbGl6ZWRNZXNzYWdlKTtcbiAgICByZXR1cm4gc2VyaWFsaXplZE1lc3NhZ2Uuc2xpY2UoMCwgc2VyaWFsaXplZE1lc3NhZ2VMZW5ndGgpO1xuICB9XG4gIHNlcmlhbGl6ZUluc3RydWN0aW9ucygpIHtcbiAgICBsZXQgc2VyaWFsaXplZExlbmd0aCA9IDA7XG4gICAgY29uc3Qgc2VyaWFsaXplZEluc3RydWN0aW9ucyA9IG5ldyBVaW50OEFycmF5KFBBQ0tFVF9EQVRBX1NJWkUpO1xuICAgIGZvciAoY29uc3QgaW5zdHJ1Y3Rpb24gb2YgdGhpcy5jb21waWxlZEluc3RydWN0aW9ucykge1xuICAgICAgY29uc3QgZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoID0gQXJyYXkoKTtcbiAgICAgIGVuY29kZUxlbmd0aChlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgsIGluc3RydWN0aW9uLmFjY291bnRLZXlJbmRleGVzLmxlbmd0aCk7XG4gICAgICBjb25zdCBlbmNvZGVkRGF0YUxlbmd0aCA9IEFycmF5KCk7XG4gICAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZERhdGFMZW5ndGgsIGluc3RydWN0aW9uLmRhdGEubGVuZ3RoKTtcbiAgICAgIGNvbnN0IGluc3RydWN0aW9uTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdwcm9ncmFtSWRJbmRleCcpLCBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnU4KCksIGluc3RydWN0aW9uLmFjY291bnRLZXlJbmRleGVzLmxlbmd0aCwgJ2FjY291bnRLZXlJbmRleGVzJyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWREYXRhTGVuZ3RoLmxlbmd0aCwgJ2VuY29kZWREYXRhTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5ibG9iKGluc3RydWN0aW9uLmRhdGEubGVuZ3RoLCAnZGF0YScpXSk7XG4gICAgICBzZXJpYWxpemVkTGVuZ3RoICs9IGluc3RydWN0aW9uTGF5b3V0LmVuY29kZSh7XG4gICAgICAgIHByb2dyYW1JZEluZGV4OiBpbnN0cnVjdGlvbi5wcm9ncmFtSWRJbmRleCxcbiAgICAgICAgZW5jb2RlZEFjY291bnRLZXlJbmRleGVzTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkQWNjb3VudEtleUluZGV4ZXNMZW5ndGgpLFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlczogaW5zdHJ1Y3Rpb24uYWNjb3VudEtleUluZGV4ZXMsXG4gICAgICAgIGVuY29kZWREYXRhTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkRGF0YUxlbmd0aCksXG4gICAgICAgIGRhdGE6IGluc3RydWN0aW9uLmRhdGFcbiAgICAgIH0sIHNlcmlhbGl6ZWRJbnN0cnVjdGlvbnMsIHNlcmlhbGl6ZWRMZW5ndGgpO1xuICAgIH1cbiAgICByZXR1cm4gc2VyaWFsaXplZEluc3RydWN0aW9ucy5zbGljZSgwLCBzZXJpYWxpemVkTGVuZ3RoKTtcbiAgfVxuICBzZXJpYWxpemVBZGRyZXNzVGFibGVMb29rdXBzKCkge1xuICAgIGxldCBzZXJpYWxpemVkTGVuZ3RoID0gMDtcbiAgICBjb25zdCBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3VwcyA9IG5ldyBVaW50OEFycmF5KFBBQ0tFVF9EQVRBX1NJWkUpO1xuICAgIGZvciAoY29uc3QgbG9va3VwIG9mIHRoaXMuYWRkcmVzc1RhYmxlTG9va3Vwcykge1xuICAgICAgY29uc3QgZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCwgbG9va3VwLndyaXRhYmxlSW5kZXhlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgICBlbmNvZGVMZW5ndGgoZW5jb2RlZFJlYWRvbmx5SW5kZXhlc0xlbmd0aCwgbG9va3VwLnJlYWRvbmx5SW5kZXhlcy5sZW5ndGgpO1xuICAgICAgY29uc3QgYWRkcmVzc1RhYmxlTG9va3VwTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbcHVibGljS2V5KCdhY2NvdW50S2V5JyksIEJ1ZmZlckxheW91dC5ibG9iKGVuY29kZWRXcml0YWJsZUluZGV4ZXNMZW5ndGgubGVuZ3RoLCAnZW5jb2RlZFdyaXRhYmxlSW5kZXhlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC51OCgpLCBsb29rdXAud3JpdGFibGVJbmRleGVzLmxlbmd0aCwgJ3dyaXRhYmxlSW5kZXhlcycpLCBCdWZmZXJMYXlvdXQuYmxvYihlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoLmxlbmd0aCwgJ2VuY29kZWRSZWFkb25seUluZGV4ZXNMZW5ndGgnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoKSwgbG9va3VwLnJlYWRvbmx5SW5kZXhlcy5sZW5ndGgsICdyZWFkb25seUluZGV4ZXMnKV0pO1xuICAgICAgc2VyaWFsaXplZExlbmd0aCArPSBhZGRyZXNzVGFibGVMb29rdXBMYXlvdXQuZW5jb2RlKHtcbiAgICAgICAgYWNjb3VudEtleTogbG9va3VwLmFjY291bnRLZXkudG9CeXRlcygpLFxuICAgICAgICBlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkV3JpdGFibGVJbmRleGVzTGVuZ3RoKSxcbiAgICAgICAgd3JpdGFibGVJbmRleGVzOiBsb29rdXAud3JpdGFibGVJbmRleGVzLFxuICAgICAgICBlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoOiBuZXcgVWludDhBcnJheShlbmNvZGVkUmVhZG9ubHlJbmRleGVzTGVuZ3RoKSxcbiAgICAgICAgcmVhZG9ubHlJbmRleGVzOiBsb29rdXAucmVhZG9ubHlJbmRleGVzXG4gICAgICB9LCBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3Vwcywgc2VyaWFsaXplZExlbmd0aCk7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkQWRkcmVzc1RhYmxlTG9va3Vwcy5zbGljZSgwLCBzZXJpYWxpemVkTGVuZ3RoKTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoc2VyaWFsaXplZE1lc3NhZ2UpIHtcbiAgICBsZXQgYnl0ZUFycmF5ID0gWy4uLnNlcmlhbGl6ZWRNZXNzYWdlXTtcbiAgICBjb25zdCBwcmVmaXggPSBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KTtcbiAgICBjb25zdCBtYXNrZWRQcmVmaXggPSBwcmVmaXggJiBWRVJTSU9OX1BSRUZJWF9NQVNLO1xuICAgIGFzc2VydChwcmVmaXggIT09IG1hc2tlZFByZWZpeCwgYEV4cGVjdGVkIHZlcnNpb25lZCBtZXNzYWdlIGJ1dCByZWNlaXZlZCBsZWdhY3kgbWVzc2FnZWApO1xuICAgIGNvbnN0IHZlcnNpb24gPSBtYXNrZWRQcmVmaXg7XG4gICAgYXNzZXJ0KHZlcnNpb24gPT09IDAsIGBFeHBlY3RlZCB2ZXJzaW9uZWQgbWVzc2FnZSB3aXRoIHZlcnNpb24gMCBidXQgZm91bmQgdmVyc2lvbiAke3ZlcnNpb259YCk7XG4gICAgY29uc3QgaGVhZGVyID0ge1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzOiBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KSxcbiAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM6IGd1YXJkZWRTaGlmdChieXRlQXJyYXkpLFxuICAgICAgbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzOiBndWFyZGVkU2hpZnQoYnl0ZUFycmF5KVxuICAgIH07XG4gICAgY29uc3Qgc3RhdGljQWNjb3VudEtleXMgPSBbXTtcbiAgICBjb25zdCBzdGF0aWNBY2NvdW50S2V5c0xlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhdGljQWNjb3VudEtleXNMZW5ndGg7IGkrKykge1xuICAgICAgc3RhdGljQWNjb3VudEtleXMucHVzaChuZXcgUHVibGljS2V5KGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCkpKTtcbiAgICB9XG4gICAgY29uc3QgcmVjZW50QmxvY2toYXNoID0gYnM1OC5lbmNvZGUoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFBVQkxJQ19LRVlfTEVOR1RIKSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25Db3VudCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGNvbnN0IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnN0cnVjdGlvbkNvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IHByb2dyYW1JZEluZGV4ID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCBhY2NvdW50S2V5SW5kZXhlc0xlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgYWNjb3VudEtleUluZGV4ZXMgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgYWNjb3VudEtleUluZGV4ZXNMZW5ndGgpO1xuICAgICAgY29uc3QgZGF0YUxlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgZGF0YSA9IG5ldyBVaW50OEFycmF5KGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBkYXRhTGVuZ3RoKSk7XG4gICAgICBjb21waWxlZEluc3RydWN0aW9ucy5wdXNoKHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXgsXG4gICAgICAgIGFjY291bnRLZXlJbmRleGVzLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYWRkcmVzc1RhYmxlTG9va3Vwc0NvdW50ID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgY29uc3QgYWRkcmVzc1RhYmxlTG9va3VwcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWRkcmVzc1RhYmxlTG9va3Vwc0NvdW50OyBpKyspIHtcbiAgICAgIGNvbnN0IGFjY291bnRLZXkgPSBuZXcgUHVibGljS2V5KGd1YXJkZWRTcGxpY2UoYnl0ZUFycmF5LCAwLCBQVUJMSUNfS0VZX0xFTkdUSCkpO1xuICAgICAgY29uc3Qgd3JpdGFibGVJbmRleGVzTGVuZ3RoID0gZGVjb2RlTGVuZ3RoKGJ5dGVBcnJheSk7XG4gICAgICBjb25zdCB3cml0YWJsZUluZGV4ZXMgPSBndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgd3JpdGFibGVJbmRleGVzTGVuZ3RoKTtcbiAgICAgIGNvbnN0IHJlYWRvbmx5SW5kZXhlc0xlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgICAgY29uc3QgcmVhZG9ubHlJbmRleGVzID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIHJlYWRvbmx5SW5kZXhlc0xlbmd0aCk7XG4gICAgICBhZGRyZXNzVGFibGVMb29rdXBzLnB1c2goe1xuICAgICAgICBhY2NvdW50S2V5LFxuICAgICAgICB3cml0YWJsZUluZGV4ZXMsXG4gICAgICAgIHJlYWRvbmx5SW5kZXhlc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTWVzc2FnZVYwKHtcbiAgICAgIGhlYWRlcixcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzLFxuICAgICAgcmVjZW50QmxvY2toYXNoLFxuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnMsXG4gICAgICBhZGRyZXNzVGFibGVMb29rdXBzXG4gICAgfSk7XG4gIH1cbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuY29uc3QgVmVyc2lvbmVkTWVzc2FnZSA9IHtcbiAgZGVzZXJpYWxpemVNZXNzYWdlVmVyc2lvbihzZXJpYWxpemVkTWVzc2FnZSkge1xuICAgIGNvbnN0IHByZWZpeCA9IHNlcmlhbGl6ZWRNZXNzYWdlWzBdO1xuICAgIGNvbnN0IG1hc2tlZFByZWZpeCA9IHByZWZpeCAmIFZFUlNJT05fUFJFRklYX01BU0s7XG5cbiAgICAvLyBpZiB0aGUgaGlnaGVzdCBiaXQgb2YgdGhlIHByZWZpeCBpcyBub3Qgc2V0LCB0aGUgbWVzc2FnZSBpcyBub3QgdmVyc2lvbmVkXG4gICAgaWYgKG1hc2tlZFByZWZpeCA9PT0gcHJlZml4KSB7XG4gICAgICByZXR1cm4gJ2xlZ2FjeSc7XG4gICAgfVxuXG4gICAgLy8gdGhlIGxvd2VyIDcgYml0cyBvZiB0aGUgcHJlZml4IGluZGljYXRlIHRoZSBtZXNzYWdlIHZlcnNpb25cbiAgICByZXR1cm4gbWFza2VkUHJlZml4O1xuICB9LFxuICBkZXNlcmlhbGl6ZTogc2VyaWFsaXplZE1lc3NhZ2UgPT4ge1xuICAgIGNvbnN0IHZlcnNpb24gPSBWZXJzaW9uZWRNZXNzYWdlLmRlc2VyaWFsaXplTWVzc2FnZVZlcnNpb24oc2VyaWFsaXplZE1lc3NhZ2UpO1xuICAgIGlmICh2ZXJzaW9uID09PSAnbGVnYWN5Jykge1xuICAgICAgcmV0dXJuIE1lc3NhZ2UuZnJvbShzZXJpYWxpemVkTWVzc2FnZSk7XG4gICAgfVxuICAgIGlmICh2ZXJzaW9uID09PSAwKSB7XG4gICAgICByZXR1cm4gTWVzc2FnZVYwLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRNZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiBtZXNzYWdlIHZlcnNpb24gJHt2ZXJzaW9ufSBkZXNlcmlhbGl6YXRpb24gaXMgbm90IHN1cHBvcnRlZGApO1xuICAgIH1cbiAgfVxufTtcblxuLyoqIEBpbnRlcm5hbCAqL1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIHNpZ25hdHVyZSBhcyBiYXNlLTU4IGVuY29kZWQgc3RyaW5nXG4gKi9cblxubGV0IFRyYW5zYWN0aW9uU3RhdHVzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChUcmFuc2FjdGlvblN0YXR1cykge1xuICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIkJMT0NLSEVJR0hUX0VYQ0VFREVEXCJdID0gMF0gPSBcIkJMT0NLSEVJR0hUX0VYQ0VFREVEXCI7XG4gIFRyYW5zYWN0aW9uU3RhdHVzW1RyYW5zYWN0aW9uU3RhdHVzW1wiUFJPQ0VTU0VEXCJdID0gMV0gPSBcIlBST0NFU1NFRFwiO1xuICBUcmFuc2FjdGlvblN0YXR1c1tUcmFuc2FjdGlvblN0YXR1c1tcIlRJTUVEX09VVFwiXSA9IDJdID0gXCJUSU1FRF9PVVRcIjtcbiAgVHJhbnNhY3Rpb25TdGF0dXNbVHJhbnNhY3Rpb25TdGF0dXNbXCJOT05DRV9JTlZBTElEXCJdID0gM10gPSBcIk5PTkNFX0lOVkFMSURcIjtcbiAgcmV0dXJuIFRyYW5zYWN0aW9uU3RhdHVzO1xufSh7fSk7XG5cbi8qKlxuICogRGVmYXVsdCAoZW1wdHkpIHNpZ25hdHVyZVxuICovXG5jb25zdCBERUZBVUxUX1NJR05BVFVSRSA9IEJ1ZmZlci5hbGxvYyhTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTKS5maWxsKDApO1xuXG4vKipcbiAqIEFjY291bnQgbWV0YWRhdGEgdXNlZCB0byBkZWZpbmUgaW5zdHJ1Y3Rpb25zXG4gKi9cblxuLyoqXG4gKiBMaXN0IG9mIFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24gb2JqZWN0IGZpZWxkcyB0aGF0IG1heSBiZSBpbml0aWFsaXplZCBhdCBjb25zdHJ1Y3Rpb25cbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBUcmFuc2FjdGlvbi5zZXJpYWxpemUoKVxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBJbnN0cnVjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBUcmFuc2FjdGlvbkluc3RydWN0aW9uIHtcbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIC8qKlxuICAgICAqIFB1YmxpYyBrZXlzIHRvIGluY2x1ZGUgaW4gdGhpcyB0cmFuc2FjdGlvblxuICAgICAqIEJvb2xlYW4gcmVwcmVzZW50cyB3aGV0aGVyIHRoaXMgcHVia2V5IG5lZWRzIHRvIHNpZ24gdGhlIHRyYW5zYWN0aW9uXG4gICAgICovXG4gICAgdGhpcy5rZXlzID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFByb2dyYW0gSWQgdG8gZXhlY3V0ZVxuICAgICAqL1xuICAgIHRoaXMucHJvZ3JhbUlkID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIFByb2dyYW0gaW5wdXRcbiAgICAgKi9cbiAgICB0aGlzLmRhdGEgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgdGhpcy5wcm9ncmFtSWQgPSBvcHRzLnByb2dyYW1JZDtcbiAgICB0aGlzLmtleXMgPSBvcHRzLmtleXM7XG4gICAgaWYgKG9wdHMuZGF0YSkge1xuICAgICAgdGhpcy5kYXRhID0gb3B0cy5kYXRhO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAga2V5czogdGhpcy5rZXlzLm1hcCgoe1xuICAgICAgICBwdWJrZXksXG4gICAgICAgIGlzU2lnbmVyLFxuICAgICAgICBpc1dyaXRhYmxlXG4gICAgICB9KSA9PiAoe1xuICAgICAgICBwdWJrZXk6IHB1YmtleS50b0pTT04oKSxcbiAgICAgICAgaXNTaWduZXIsXG4gICAgICAgIGlzV3JpdGFibGVcbiAgICAgIH0pKSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQudG9KU09OKCksXG4gICAgICBkYXRhOiBbLi4udGhpcy5kYXRhXVxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBQYWlyIG9mIHNpZ25hdHVyZSBhbmQgY29ycmVzcG9uZGluZyBwdWJsaWMga2V5XG4gKi9cblxuLyoqXG4gKiBMaXN0IG9mIFRyYW5zYWN0aW9uIG9iamVjdCBmaWVsZHMgdGhhdCBtYXkgYmUgaW5pdGlhbGl6ZWQgYXQgY29uc3RydWN0aW9uXG4gKi9cblxuLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk7IGFuIHVuZm9ydHVuYXRlIGNvbnNlcXVlbmNlIG9mIGJlaW5nXG4vLyBmb3JjZWQgdG8gb3Zlci1leHBvcnQgdHlwZXMgYnkgdGhlIGRvY3VtZW50YXRpb24gZ2VuZXJhdG9yLlxuLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvcHVsbC8yNTgyMFxuXG4vKipcbiAqIEJsb2NraGFzaC1iYXNlZCB0cmFuc2FjdGlvbnMgaGF2ZSBhIGxpZmV0aW1lIHRoYXQgYXJlIGRlZmluZWQgYnlcbiAqIHRoZSBibG9ja2hhc2ggdGhleSBpbmNsdWRlLiBBbnkgdHJhbnNhY3Rpb24gd2hvc2UgYmxvY2toYXNoIGlzXG4gKiB0b28gb2xkIHdpbGwgYmUgcmVqZWN0ZWQuXG4gKi9cblxuLyoqXG4gKiBVc2UgdGhlc2Ugb3B0aW9ucyB0byBjb25zdHJ1Y3QgYSBkdXJhYmxlIG5vbmNlIHRyYW5zYWN0aW9uLlxuICovXG5cbi8qKlxuICogTm9uY2UgaW5mb3JtYXRpb24gdG8gYmUgdXNlZCB0byBidWlsZCBhbiBvZmZsaW5lIFRyYW5zYWN0aW9uLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBUcmFuc2FjdGlvbiB7XG4gIC8qKlxuICAgKiBUaGUgZmlyc3QgKHBheWVyKSBUcmFuc2FjdGlvbiBzaWduYXR1cmVcbiAgICpcbiAgICogQHJldHVybnMge0J1ZmZlciB8IG51bGx9IEJ1ZmZlciBvZiBwYXllcidzIHNpZ25hdHVyZVxuICAgKi9cbiAgZ2V0IHNpZ25hdHVyZSgpIHtcbiAgICBpZiAodGhpcy5zaWduYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiB0aGlzLnNpZ25hdHVyZXNbMF0uc2lnbmF0dXJlO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgdHJhbnNhY3Rpb24gZmVlIHBheWVyXG4gICAqL1xuXG4gIC8vIENvbnN0cnVjdCBhIHRyYW5zYWN0aW9uIHdpdGggYSBibG9ja2hhc2ggYW5kIGxhc3RWYWxpZEJsb2NrSGVpZ2h0XG5cbiAgLy8gQ29uc3RydWN0IGEgdHJhbnNhY3Rpb24gdXNpbmcgYSBkdXJhYmxlIG5vbmNlXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIGBUcmFuc2FjdGlvbkN0b3JGaWVsZHNgIGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlxuICAgKiBQbGVhc2Ugc3VwcGx5IGEgYFRyYW5zYWN0aW9uQmxvY2toYXNoQ3RvcmAgaW5zdGVhZC5cbiAgICovXG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdCBhbiBlbXB0eSBUcmFuc2FjdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0cykge1xuICAgIC8qKlxuICAgICAqIFNpZ25hdHVyZXMgZm9yIHRoZSB0cmFuc2FjdGlvbi4gIFR5cGljYWxseSBjcmVhdGVkIGJ5IGludm9raW5nIHRoZVxuICAgICAqIGBzaWduKClgIG1ldGhvZFxuICAgICAqL1xuICAgIHRoaXMuc2lnbmF0dXJlcyA9IFtdO1xuICAgIHRoaXMuZmVlUGF5ZXIgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogVGhlIGluc3RydWN0aW9ucyB0byBhdG9taWNhbGx5IGV4ZWN1dGVcbiAgICAgKi9cbiAgICB0aGlzLmluc3RydWN0aW9ucyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEEgcmVjZW50IHRyYW5zYWN0aW9uIGlkLiBNdXN0IGJlIHBvcHVsYXRlZCBieSB0aGUgY2FsbGVyXG4gICAgICovXG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogdGhlIGxhc3QgYmxvY2sgY2hhaW4gY2FuIGFkdmFuY2UgdG8gYmVmb3JlIHR4IGlzIGRlY2xhcmVkIGV4cGlyZWRcbiAgICAgKiAqL1xuICAgIHRoaXMubGFzdFZhbGlkQmxvY2tIZWlnaHQgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogT3B0aW9uYWwgTm9uY2UgaW5mb3JtYXRpb24uIElmIHBvcHVsYXRlZCwgdHJhbnNhY3Rpb24gd2lsbCB1c2UgYSBkdXJhYmxlXG4gICAgICogTm9uY2UgaGFzaCBpbnN0ZWFkIG9mIGEgcmVjZW50QmxvY2toYXNoLiBNdXN0IGJlIHBvcHVsYXRlZCBieSB0aGUgY2FsbGVyXG4gICAgICovXG4gICAgdGhpcy5ub25jZUluZm8gPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBpcyBhIG5vbmNlIHRyYW5zYWN0aW9uIHRoaXMgcmVwcmVzZW50cyB0aGUgbWluaW11bSBzbG90IGZyb20gd2hpY2hcbiAgICAgKiB0byBldmFsdWF0ZSBpZiB0aGUgbm9uY2UgaGFzIGFkdmFuY2VkIHdoZW4gYXR0ZW1wdGluZyB0byBjb25maXJtIHRoZVxuICAgICAqIHRyYW5zYWN0aW9uLiBUaGlzIHByb3RlY3RzIGFnYWluc3QgYSBjYXNlIHdoZXJlIHRoZSB0cmFuc2FjdGlvbiBjb25maXJtYXRpb25cbiAgICAgKiBsb2dpYyBsb2FkcyB0aGUgbm9uY2UgYWNjb3VudCBmcm9tIGFuIG9sZCBzbG90IGFuZCBhc3N1bWVzIHRoZSBtaXNtYXRjaCBpblxuICAgICAqIG5vbmNlIHZhbHVlIGltcGxpZXMgdGhhdCB0aGUgbm9uY2UgaGFzIGJlZW4gYWR2YW5jZWQuXG4gICAgICovXG4gICAgdGhpcy5taW5Ob25jZUNvbnRleHRTbG90ID0gdm9pZCAwO1xuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHRoaXMuX21lc3NhZ2UgPSB2b2lkIDA7XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdGhpcy5fanNvbiA9IHZvaWQgMDtcbiAgICBpZiAoIW9wdHMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG9wdHMuZmVlUGF5ZXIpIHtcbiAgICAgIHRoaXMuZmVlUGF5ZXIgPSBvcHRzLmZlZVBheWVyO1xuICAgIH1cbiAgICBpZiAob3B0cy5zaWduYXR1cmVzKSB7XG4gICAgICB0aGlzLnNpZ25hdHVyZXMgPSBvcHRzLnNpZ25hdHVyZXM7XG4gICAgfVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0cywgJ25vbmNlSW5mbycpKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG1pbkNvbnRleHRTbG90LFxuICAgICAgICBub25jZUluZm9cbiAgICAgIH0gPSBvcHRzO1xuICAgICAgdGhpcy5taW5Ob25jZUNvbnRleHRTbG90ID0gbWluQ29udGV4dFNsb3Q7XG4gICAgICB0aGlzLm5vbmNlSW5mbyA9IG5vbmNlSW5mbztcbiAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvcHRzLCAnbGFzdFZhbGlkQmxvY2tIZWlnaHQnKSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBibG9ja2hhc2gsXG4gICAgICAgIGxhc3RWYWxpZEJsb2NrSGVpZ2h0XG4gICAgICB9ID0gb3B0cztcbiAgICAgIHRoaXMucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoO1xuICAgICAgdGhpcy5sYXN0VmFsaWRCbG9ja0hlaWdodCA9IGxhc3RWYWxpZEJsb2NrSGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlY2VudEJsb2NraGFzaCxcbiAgICAgICAgbm9uY2VJbmZvXG4gICAgICB9ID0gb3B0cztcbiAgICAgIGlmIChub25jZUluZm8pIHtcbiAgICAgICAgdGhpcy5ub25jZUluZm8gPSBub25jZUluZm87XG4gICAgICB9XG4gICAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IHJlY2VudEJsb2NraGFzaDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlY2VudEJsb2NraGFzaDogdGhpcy5yZWNlbnRCbG9ja2hhc2ggfHwgbnVsbCxcbiAgICAgIGZlZVBheWVyOiB0aGlzLmZlZVBheWVyID8gdGhpcy5mZWVQYXllci50b0pTT04oKSA6IG51bGwsXG4gICAgICBub25jZUluZm86IHRoaXMubm9uY2VJbmZvID8ge1xuICAgICAgICBub25jZTogdGhpcy5ub25jZUluZm8ubm9uY2UsXG4gICAgICAgIG5vbmNlSW5zdHJ1Y3Rpb246IHRoaXMubm9uY2VJbmZvLm5vbmNlSW5zdHJ1Y3Rpb24udG9KU09OKClcbiAgICAgIH0gOiBudWxsLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiB0aGlzLmluc3RydWN0aW9ucy5tYXAoaW5zdHJ1Y3Rpb24gPT4gaW5zdHJ1Y3Rpb24udG9KU09OKCkpLFxuICAgICAgc2lnbmVyczogdGhpcy5zaWduYXR1cmVzLm1hcCgoe1xuICAgICAgICBwdWJsaWNLZXlcbiAgICAgIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHB1YmxpY0tleS50b0pTT04oKTtcbiAgICAgIH0pXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgb25lIG9yIG1vcmUgaW5zdHJ1Y3Rpb25zIHRvIHRoaXMgVHJhbnNhY3Rpb25cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheTwgVHJhbnNhY3Rpb24gfCBUcmFuc2FjdGlvbkluc3RydWN0aW9uIHwgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbkN0b3JGaWVsZHMgPn0gaXRlbXMgLSBJbnN0cnVjdGlvbnMgdG8gYWRkIHRvIHRoZSBUcmFuc2FjdGlvblxuICAgKi9cbiAgYWRkKC4uLml0ZW1zKSB7XG4gICAgaWYgKGl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBpbnN0cnVjdGlvbnMnKTtcbiAgICB9XG4gICAgaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIGlmICgnaW5zdHJ1Y3Rpb25zJyBpbiBpdGVtKSB7XG4gICAgICAgIHRoaXMuaW5zdHJ1Y3Rpb25zID0gdGhpcy5pbnN0cnVjdGlvbnMuY29uY2F0KGl0ZW0uaW5zdHJ1Y3Rpb25zKTtcbiAgICAgIH0gZWxzZSBpZiAoJ2RhdGEnIGluIGl0ZW0gJiYgJ3Byb2dyYW1JZCcgaW4gaXRlbSAmJiAna2V5cycgaW4gaXRlbSkge1xuICAgICAgICB0aGlzLmluc3RydWN0aW9ucy5wdXNoKGl0ZW0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMucHVzaChuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbihpdGVtKSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogQ29tcGlsZSB0cmFuc2FjdGlvbiBkYXRhXG4gICAqL1xuICBjb21waWxlTWVzc2FnZSgpIHtcbiAgICBpZiAodGhpcy5fbWVzc2FnZSAmJiBKU09OLnN0cmluZ2lmeSh0aGlzLnRvSlNPTigpKSA9PT0gSlNPTi5zdHJpbmdpZnkodGhpcy5fanNvbikpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tZXNzYWdlO1xuICAgIH1cbiAgICBsZXQgcmVjZW50QmxvY2toYXNoO1xuICAgIGxldCBpbnN0cnVjdGlvbnM7XG4gICAgaWYgKHRoaXMubm9uY2VJbmZvKSB7XG4gICAgICByZWNlbnRCbG9ja2hhc2ggPSB0aGlzLm5vbmNlSW5mby5ub25jZTtcbiAgICAgIGlmICh0aGlzLmluc3RydWN0aW9uc1swXSAhPSB0aGlzLm5vbmNlSW5mby5ub25jZUluc3RydWN0aW9uKSB7XG4gICAgICAgIGluc3RydWN0aW9ucyA9IFt0aGlzLm5vbmNlSW5mby5ub25jZUluc3RydWN0aW9uLCAuLi50aGlzLmluc3RydWN0aW9uc107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmVjZW50QmxvY2toYXNoID0gdGhpcy5yZWNlbnRCbG9ja2hhc2g7XG4gICAgICBpbnN0cnVjdGlvbnMgPSB0aGlzLmluc3RydWN0aW9ucztcbiAgICB9XG4gICAgaWYgKCFyZWNlbnRCbG9ja2hhc2gpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gcmVjZW50QmxvY2toYXNoIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmIChpbnN0cnVjdGlvbnMubGVuZ3RoIDwgMSkge1xuICAgICAgY29uc29sZS53YXJuKCdObyBpbnN0cnVjdGlvbnMgcHJvdmlkZWQnKTtcbiAgICB9XG4gICAgbGV0IGZlZVBheWVyO1xuICAgIGlmICh0aGlzLmZlZVBheWVyKSB7XG4gICAgICBmZWVQYXllciA9IHRoaXMuZmVlUGF5ZXI7XG4gICAgfSBlbHNlIGlmICh0aGlzLnNpZ25hdHVyZXMubGVuZ3RoID4gMCAmJiB0aGlzLnNpZ25hdHVyZXNbMF0ucHVibGljS2V5KSB7XG4gICAgICAvLyBVc2UgaW1wbGljaXQgZmVlIHBheWVyXG4gICAgICBmZWVQYXllciA9IHRoaXMuc2lnbmF0dXJlc1swXS5wdWJsaWNLZXk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVHJhbnNhY3Rpb24gZmVlIHBheWVyIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5zdHJ1Y3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoaW5zdHJ1Y3Rpb25zW2ldLnByb2dyYW1JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gaW5kZXggJHtpfSBoYXMgdW5kZWZpbmVkIHByb2dyYW0gaWRgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgcHJvZ3JhbUlkcyA9IFtdO1xuICAgIGNvbnN0IGFjY291bnRNZXRhcyA9IFtdO1xuICAgIGluc3RydWN0aW9ucy5mb3JFYWNoKGluc3RydWN0aW9uID0+IHtcbiAgICAgIGluc3RydWN0aW9uLmtleXMuZm9yRWFjaChhY2NvdW50TWV0YSA9PiB7XG4gICAgICAgIGFjY291bnRNZXRhcy5wdXNoKHtcbiAgICAgICAgICAuLi5hY2NvdW50TWV0YVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcHJvZ3JhbUlkID0gaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkLnRvU3RyaW5nKCk7XG4gICAgICBpZiAoIXByb2dyYW1JZHMuaW5jbHVkZXMocHJvZ3JhbUlkKSkge1xuICAgICAgICBwcm9ncmFtSWRzLnB1c2gocHJvZ3JhbUlkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIEFwcGVuZCBwcm9ncmFtSUQgYWNjb3VudCBtZXRhc1xuICAgIHByb2dyYW1JZHMuZm9yRWFjaChwcm9ncmFtSWQgPT4ge1xuICAgICAgYWNjb3VudE1ldGFzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyBDdWxsIGR1cGxpY2F0ZSBhY2NvdW50IG1ldGFzXG4gICAgY29uc3QgdW5pcXVlTWV0YXMgPSBbXTtcbiAgICBhY2NvdW50TWV0YXMuZm9yRWFjaChhY2NvdW50TWV0YSA9PiB7XG4gICAgICBjb25zdCBwdWJrZXlTdHJpbmcgPSBhY2NvdW50TWV0YS5wdWJrZXkudG9TdHJpbmcoKTtcbiAgICAgIGNvbnN0IHVuaXF1ZUluZGV4ID0gdW5pcXVlTWV0YXMuZmluZEluZGV4KHggPT4ge1xuICAgICAgICByZXR1cm4geC5wdWJrZXkudG9TdHJpbmcoKSA9PT0gcHVia2V5U3RyaW5nO1xuICAgICAgfSk7XG4gICAgICBpZiAodW5pcXVlSW5kZXggPiAtMSkge1xuICAgICAgICB1bmlxdWVNZXRhc1t1bmlxdWVJbmRleF0uaXNXcml0YWJsZSA9IHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1dyaXRhYmxlIHx8IGFjY291bnRNZXRhLmlzV3JpdGFibGU7XG4gICAgICAgIHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1NpZ25lciA9IHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1NpZ25lciB8fCBhY2NvdW50TWV0YS5pc1NpZ25lcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVuaXF1ZU1ldGFzLnB1c2goYWNjb3VudE1ldGEpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gU29ydC4gUHJpb3JpdGl6aW5nIGZpcnN0IGJ5IHNpZ25lciwgdGhlbiBieSB3cml0YWJsZVxuICAgIHVuaXF1ZU1ldGFzLnNvcnQoZnVuY3Rpb24gKHgsIHkpIHtcbiAgICAgIGlmICh4LmlzU2lnbmVyICE9PSB5LmlzU2lnbmVyKSB7XG4gICAgICAgIC8vIFNpZ25lcnMgYWx3YXlzIGNvbWUgYmVmb3JlIG5vbi1zaWduZXJzXG4gICAgICAgIHJldHVybiB4LmlzU2lnbmVyID8gLTEgOiAxO1xuICAgICAgfVxuICAgICAgaWYgKHguaXNXcml0YWJsZSAhPT0geS5pc1dyaXRhYmxlKSB7XG4gICAgICAgIC8vIFdyaXRhYmxlIGFjY291bnRzIGFsd2F5cyBjb21lIGJlZm9yZSByZWFkLW9ubHkgYWNjb3VudHNcbiAgICAgICAgcmV0dXJuIHguaXNXcml0YWJsZSA/IC0xIDogMTtcbiAgICAgIH1cbiAgICAgIC8vIE90aGVyd2lzZSwgc29ydCBieSBwdWJrZXksIHN0cmluZ3dpc2UuXG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBsb2NhbGVNYXRjaGVyOiAnYmVzdCBmaXQnLFxuICAgICAgICB1c2FnZTogJ3NvcnQnLFxuICAgICAgICBzZW5zaXRpdml0eTogJ3ZhcmlhbnQnLFxuICAgICAgICBpZ25vcmVQdW5jdHVhdGlvbjogZmFsc2UsXG4gICAgICAgIG51bWVyaWM6IGZhbHNlLFxuICAgICAgICBjYXNlRmlyc3Q6ICdsb3dlcidcbiAgICAgIH07XG4gICAgICByZXR1cm4geC5wdWJrZXkudG9CYXNlNTgoKS5sb2NhbGVDb21wYXJlKHkucHVia2V5LnRvQmFzZTU4KCksICdlbicsIG9wdGlvbnMpO1xuICAgIH0pO1xuXG4gICAgLy8gTW92ZSBmZWUgcGF5ZXIgdG8gdGhlIGZyb250XG4gICAgY29uc3QgZmVlUGF5ZXJJbmRleCA9IHVuaXF1ZU1ldGFzLmZpbmRJbmRleCh4ID0+IHtcbiAgICAgIHJldHVybiB4LnB1YmtleS5lcXVhbHMoZmVlUGF5ZXIpO1xuICAgIH0pO1xuICAgIGlmIChmZWVQYXllckluZGV4ID4gLTEpIHtcbiAgICAgIGNvbnN0IFtwYXllck1ldGFdID0gdW5pcXVlTWV0YXMuc3BsaWNlKGZlZVBheWVySW5kZXgsIDEpO1xuICAgICAgcGF5ZXJNZXRhLmlzU2lnbmVyID0gdHJ1ZTtcbiAgICAgIHBheWVyTWV0YS5pc1dyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIHVuaXF1ZU1ldGFzLnVuc2hpZnQocGF5ZXJNZXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdW5pcXVlTWV0YXMudW5zaGlmdCh7XG4gICAgICAgIHB1YmtleTogZmVlUGF5ZXIsXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBEaXNhbGxvdyB1bmtub3duIHNpZ25lcnNcbiAgICBmb3IgKGNvbnN0IHNpZ25hdHVyZSBvZiB0aGlzLnNpZ25hdHVyZXMpIHtcbiAgICAgIGNvbnN0IHVuaXF1ZUluZGV4ID0gdW5pcXVlTWV0YXMuZmluZEluZGV4KHggPT4ge1xuICAgICAgICByZXR1cm4geC5wdWJrZXkuZXF1YWxzKHNpZ25hdHVyZS5wdWJsaWNLZXkpO1xuICAgICAgfSk7XG4gICAgICBpZiAodW5pcXVlSW5kZXggPiAtMSkge1xuICAgICAgICBpZiAoIXVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1NpZ25lcikge1xuICAgICAgICAgIHVuaXF1ZU1ldGFzW3VuaXF1ZUluZGV4XS5pc1NpZ25lciA9IHRydWU7XG4gICAgICAgICAgY29uc29sZS53YXJuKCdUcmFuc2FjdGlvbiByZWZlcmVuY2VzIGEgc2lnbmF0dXJlIHRoYXQgaXMgdW5uZWNlc3NhcnksICcgKyAnb25seSB0aGUgZmVlIHBheWVyIGFuZCBpbnN0cnVjdGlvbiBzaWduZXIgYWNjb3VudHMgc2hvdWxkIHNpZ24gYSB0cmFuc2FjdGlvbi4gJyArICdUaGlzIGJlaGF2aW9yIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgdGhyb3cgYW4gZXJyb3IgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiByZWxlYXNlLicpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHVua25vd24gc2lnbmVyOiAke3NpZ25hdHVyZS5wdWJsaWNLZXkudG9TdHJpbmcoKX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IG51bVJlcXVpcmVkU2lnbmF0dXJlcyA9IDA7XG4gICAgbGV0IG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMgPSAwO1xuICAgIGxldCBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHMgPSAwO1xuXG4gICAgLy8gU3BsaXQgb3V0IHNpZ25pbmcgZnJvbSBub24tc2lnbmluZyBrZXlzIGFuZCBjb3VudCBoZWFkZXIgdmFsdWVzXG4gICAgY29uc3Qgc2lnbmVkS2V5cyA9IFtdO1xuICAgIGNvbnN0IHVuc2lnbmVkS2V5cyA9IFtdO1xuICAgIHVuaXF1ZU1ldGFzLmZvckVhY2goKHtcbiAgICAgIHB1YmtleSxcbiAgICAgIGlzU2lnbmVyLFxuICAgICAgaXNXcml0YWJsZVxuICAgIH0pID0+IHtcbiAgICAgIGlmIChpc1NpZ25lcikge1xuICAgICAgICBzaWduZWRLZXlzLnB1c2gocHVia2V5LnRvU3RyaW5nKCkpO1xuICAgICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXMgKz0gMTtcbiAgICAgICAgaWYgKCFpc1dyaXRhYmxlKSB7XG4gICAgICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyArPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1bnNpZ25lZEtleXMucHVzaChwdWJrZXkudG9TdHJpbmcoKSk7XG4gICAgICAgIGlmICghaXNXcml0YWJsZSkge1xuICAgICAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50cyArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgYWNjb3VudEtleXMgPSBzaWduZWRLZXlzLmNvbmNhdCh1bnNpZ25lZEtleXMpO1xuICAgIGNvbnN0IGNvbXBpbGVkSW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zLm1hcChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHByb2dyYW1JZFxuICAgICAgfSA9IGluc3RydWN0aW9uO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGFjY291bnRLZXlzLmluZGV4T2YocHJvZ3JhbUlkLnRvU3RyaW5nKCkpLFxuICAgICAgICBhY2NvdW50czogaW5zdHJ1Y3Rpb24ua2V5cy5tYXAobWV0YSA9PiBhY2NvdW50S2V5cy5pbmRleE9mKG1ldGEucHVia2V5LnRvU3RyaW5nKCkpKSxcbiAgICAgICAgZGF0YTogYnM1OC5lbmNvZGUoZGF0YSlcbiAgICAgIH07XG4gICAgfSk7XG4gICAgY29tcGlsZWRJbnN0cnVjdGlvbnMuZm9yRWFjaChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBhc3NlcnQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkSW5kZXggPj0gMCk7XG4gICAgICBpbnN0cnVjdGlvbi5hY2NvdW50cy5mb3JFYWNoKGtleUluZGV4ID0+IGFzc2VydChrZXlJbmRleCA+PSAwKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlKHtcbiAgICAgIGhlYWRlcjoge1xuICAgICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXMsXG4gICAgICAgIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHMsXG4gICAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50c1xuICAgICAgfSxcbiAgICAgIGFjY291bnRLZXlzLFxuICAgICAgcmVjZW50QmxvY2toYXNoLFxuICAgICAgaW5zdHJ1Y3Rpb25zOiBjb21waWxlZEluc3RydWN0aW9uc1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2NvbXBpbGUoKSB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuY29tcGlsZU1lc3NhZ2UoKTtcbiAgICBjb25zdCBzaWduZWRLZXlzID0gbWVzc2FnZS5hY2NvdW50S2V5cy5zbGljZSgwLCBtZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMpO1xuICAgIGlmICh0aGlzLnNpZ25hdHVyZXMubGVuZ3RoID09PSBzaWduZWRLZXlzLmxlbmd0aCkge1xuICAgICAgY29uc3QgdmFsaWQgPSB0aGlzLnNpZ25hdHVyZXMuZXZlcnkoKHBhaXIsIGluZGV4KSA9PiB7XG4gICAgICAgIHJldHVybiBzaWduZWRLZXlzW2luZGV4XS5lcXVhbHMocGFpci5wdWJsaWNLZXkpO1xuICAgICAgfSk7XG4gICAgICBpZiAodmFsaWQpIHJldHVybiBtZXNzYWdlO1xuICAgIH1cbiAgICB0aGlzLnNpZ25hdHVyZXMgPSBzaWduZWRLZXlzLm1hcChwdWJsaWNLZXkgPT4gKHtcbiAgICAgIHNpZ25hdHVyZTogbnVsbCxcbiAgICAgIHB1YmxpY0tleVxuICAgIH0pKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBidWZmZXIgb2YgdGhlIFRyYW5zYWN0aW9uIGRhdGEgdGhhdCBuZWVkIHRvIGJlIGNvdmVyZWQgYnkgc2lnbmF0dXJlc1xuICAgKi9cbiAgc2VyaWFsaXplTWVzc2FnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcGlsZSgpLnNlcmlhbGl6ZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZXN0aW1hdGVkIGZlZSBhc3NvY2lhdGVkIHdpdGggYSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcGFyYW0ge0Nvbm5lY3Rpb259IGNvbm5lY3Rpb24gQ29ubmVjdGlvbiB0byBSUEMgRW5kcG9pbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPG51bWJlciB8IG51bGw+fSBUaGUgZXN0aW1hdGVkIGZlZSBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAqL1xuICBhc3luYyBnZXRFc3RpbWF0ZWRGZWUoY29ubmVjdGlvbikge1xuICAgIHJldHVybiAoYXdhaXQgY29ubmVjdGlvbi5nZXRGZWVGb3JNZXNzYWdlKHRoaXMuY29tcGlsZU1lc3NhZ2UoKSkpLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwZWNpZnkgdGhlIHB1YmxpYyBrZXlzIHdoaWNoIHdpbGwgYmUgdXNlZCB0byBzaWduIHRoZSBUcmFuc2FjdGlvbi5cbiAgICogVGhlIGZpcnN0IHNpZ25lciB3aWxsIGJlIHVzZWQgYXMgdGhlIHRyYW5zYWN0aW9uIGZlZSBwYXllciBhY2NvdW50LlxuICAgKlxuICAgKiBTaWduYXR1cmVzIGNhbiBiZSBhZGRlZCB3aXRoIGVpdGhlciBgcGFydGlhbFNpZ25gIG9yIGBhZGRTaWduYXR1cmVgXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgdjAuODQuMC4gT25seSB0aGUgZmVlIHBheWVyIG5lZWRzIHRvIGJlXG4gICAqIHNwZWNpZmllZCBhbmQgaXQgY2FuIGJlIHNldCBpbiB0aGUgVHJhbnNhY3Rpb24gY29uc3RydWN0b3Igb3Igd2l0aCB0aGVcbiAgICogYGZlZVBheWVyYCBwcm9wZXJ0eS5cbiAgICovXG4gIHNldFNpZ25lcnMoLi4uc2lnbmVycykge1xuICAgIGlmIChzaWduZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaWduZXJzJyk7XG4gICAgfVxuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5zaWduYXR1cmVzID0gc2lnbmVycy5maWx0ZXIocHVibGljS2V5ID0+IHtcbiAgICAgIGNvbnN0IGtleSA9IHB1YmxpY0tleS50b1N0cmluZygpO1xuICAgICAgaWYgKHNlZW4uaGFzKGtleSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSkubWFwKHB1YmxpY0tleSA9PiAoe1xuICAgICAgc2lnbmF0dXJlOiBudWxsLFxuICAgICAgcHVibGljS2V5XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpZ24gdGhlIFRyYW5zYWN0aW9uIHdpdGggdGhlIHNwZWNpZmllZCBzaWduZXJzLiBNdWx0aXBsZSBzaWduYXR1cmVzIG1heVxuICAgKiBiZSBhcHBsaWVkIHRvIGEgVHJhbnNhY3Rpb24uIFRoZSBmaXJzdCBzaWduYXR1cmUgaXMgY29uc2lkZXJlZCBcInByaW1hcnlcIlxuICAgKiBhbmQgaXMgdXNlZCBpZGVudGlmeSBhbmQgY29uZmlybSB0cmFuc2FjdGlvbnMuXG4gICAqXG4gICAqIElmIHRoZSBUcmFuc2FjdGlvbiBgZmVlUGF5ZXJgIGlzIG5vdCBzZXQsIHRoZSBmaXJzdCBzaWduZXIgd2lsbCBiZSB1c2VkXG4gICAqIGFzIHRoZSB0cmFuc2FjdGlvbiBmZWUgcGF5ZXIgYWNjb3VudC5cbiAgICpcbiAgICogVHJhbnNhY3Rpb24gZmllbGRzIHNob3VsZCBub3QgYmUgbW9kaWZpZWQgYWZ0ZXIgdGhlIGZpcnN0IGNhbGwgdG8gYHNpZ25gLFxuICAgKiBhcyBkb2luZyBzbyBtYXkgaW52YWxpZGF0ZSB0aGUgc2lnbmF0dXJlIGFuZCBjYXVzZSB0aGUgVHJhbnNhY3Rpb24gdG8gYmVcbiAgICogcmVqZWN0ZWQuXG4gICAqXG4gICAqIFRoZSBUcmFuc2FjdGlvbiBtdXN0IGJlIGFzc2lnbmVkIGEgdmFsaWQgYHJlY2VudEJsb2NraGFzaGAgYmVmb3JlIGludm9raW5nIHRoaXMgbWV0aG9kXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8U2lnbmVyPn0gc2lnbmVycyBBcnJheSBvZiBzaWduZXJzIHRoYXQgd2lsbCBzaWduIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgc2lnbiguLi5zaWduZXJzKSB7XG4gICAgaWYgKHNpZ25lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIHNpZ25lcnMnKTtcbiAgICB9XG5cbiAgICAvLyBEZWR1cGUgc2lnbmVyc1xuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgdW5pcXVlU2lnbmVycyA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2lnbmVyIG9mIHNpZ25lcnMpIHtcbiAgICAgIGNvbnN0IGtleSA9IHNpZ25lci5wdWJsaWNLZXkudG9TdHJpbmcoKTtcbiAgICAgIGlmIChzZWVuLmhhcyhrZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Vlbi5hZGQoa2V5KTtcbiAgICAgICAgdW5pcXVlU2lnbmVycy5wdXNoKHNpZ25lcik7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2lnbmF0dXJlcyA9IHVuaXF1ZVNpZ25lcnMubWFwKHNpZ25lciA9PiAoe1xuICAgICAgc2lnbmF0dXJlOiBudWxsLFxuICAgICAgcHVibGljS2V5OiBzaWduZXIucHVibGljS2V5XG4gICAgfSkpO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLl9jb21waWxlKCk7XG4gICAgdGhpcy5fcGFydGlhbFNpZ24obWVzc2FnZSwgLi4udW5pcXVlU2lnbmVycyk7XG4gIH1cblxuICAvKipcbiAgICogUGFydGlhbGx5IHNpZ24gYSB0cmFuc2FjdGlvbiB3aXRoIHRoZSBzcGVjaWZpZWQgYWNjb3VudHMuIEFsbCBhY2NvdW50cyBtdXN0XG4gICAqIGNvcnJlc3BvbmQgdG8gZWl0aGVyIHRoZSBmZWUgcGF5ZXIgb3IgYSBzaWduZXIgYWNjb3VudCBpbiB0aGUgdHJhbnNhY3Rpb25cbiAgICogaW5zdHJ1Y3Rpb25zLlxuICAgKlxuICAgKiBBbGwgdGhlIGNhdmVhdHMgZnJvbSB0aGUgYHNpZ25gIG1ldGhvZCBhcHBseSB0byBgcGFydGlhbFNpZ25gXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXk8U2lnbmVyPn0gc2lnbmVycyBBcnJheSBvZiBzaWduZXJzIHRoYXQgd2lsbCBzaWduIHRoZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgcGFydGlhbFNpZ24oLi4uc2lnbmVycykge1xuICAgIGlmIChzaWduZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBzaWduZXJzJyk7XG4gICAgfVxuXG4gICAgLy8gRGVkdXBlIHNpZ25lcnNcbiAgICBjb25zdCBzZWVuID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHVuaXF1ZVNpZ25lcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IHNpZ25lciBvZiBzaWduZXJzKSB7XG4gICAgICBjb25zdCBrZXkgPSBzaWduZXIucHVibGljS2V5LnRvU3RyaW5nKCk7XG4gICAgICBpZiAoc2Vlbi5oYXMoa2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlZW4uYWRkKGtleSk7XG4gICAgICAgIHVuaXF1ZVNpZ25lcnMucHVzaChzaWduZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5fY29tcGlsZSgpO1xuICAgIHRoaXMuX3BhcnRpYWxTaWduKG1lc3NhZ2UsIC4uLnVuaXF1ZVNpZ25lcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3BhcnRpYWxTaWduKG1lc3NhZ2UsIC4uLnNpZ25lcnMpIHtcbiAgICBjb25zdCBzaWduRGF0YSA9IG1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgc2lnbmVycy5mb3JFYWNoKHNpZ25lciA9PiB7XG4gICAgICBjb25zdCBzaWduYXR1cmUgPSBzaWduKHNpZ25EYXRhLCBzaWduZXIuc2VjcmV0S2V5KTtcbiAgICAgIHRoaXMuX2FkZFNpZ25hdHVyZShzaWduZXIucHVibGljS2V5LCB0b0J1ZmZlcihzaWduYXR1cmUpKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYW4gZXh0ZXJuYWxseSBjcmVhdGVkIHNpZ25hdHVyZSB0byBhIHRyYW5zYWN0aW9uLiBUaGUgcHVibGljIGtleVxuICAgKiBtdXN0IGNvcnJlc3BvbmQgdG8gZWl0aGVyIHRoZSBmZWUgcGF5ZXIgb3IgYSBzaWduZXIgYWNjb3VudCBpbiB0aGUgdHJhbnNhY3Rpb25cbiAgICogaW5zdHJ1Y3Rpb25zLlxuICAgKlxuICAgKiBAcGFyYW0ge1B1YmxpY0tleX0gcHVia2V5IFB1YmxpYyBrZXkgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZSB0cmFuc2FjdGlvbi5cbiAgICogQHBhcmFtIHtCdWZmZXJ9IHNpZ25hdHVyZSBBbiBleHRlcm5hbGx5IGNyZWF0ZWQgc2lnbmF0dXJlIHRvIGFkZCB0byB0aGUgdHJhbnNhY3Rpb24uXG4gICAqL1xuICBhZGRTaWduYXR1cmUocHVia2V5LCBzaWduYXR1cmUpIHtcbiAgICB0aGlzLl9jb21waWxlKCk7IC8vIEVuc3VyZSBzaWduYXR1cmVzIGFycmF5IGlzIHBvcHVsYXRlZFxuICAgIHRoaXMuX2FkZFNpZ25hdHVyZShwdWJrZXksIHNpZ25hdHVyZSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfYWRkU2lnbmF0dXJlKHB1YmtleSwgc2lnbmF0dXJlKSB7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZS5sZW5ndGggPT09IDY0KTtcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuc2lnbmF0dXJlcy5maW5kSW5kZXgoc2lncGFpciA9PiBwdWJrZXkuZXF1YWxzKHNpZ3BhaXIucHVibGljS2V5KSk7XG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIHNpZ25lcjogJHtwdWJrZXkudG9TdHJpbmcoKX1gKTtcbiAgICB9XG4gICAgdGhpcy5zaWduYXR1cmVzW2luZGV4XS5zaWduYXR1cmUgPSBCdWZmZXIuZnJvbShzaWduYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFZlcmlmeSBzaWduYXR1cmVzIG9mIGEgVHJhbnNhY3Rpb25cbiAgICogT3B0aW9uYWwgcGFyYW1ldGVyIHNwZWNpZmllcyBpZiB3ZSdyZSBleHBlY3RpbmcgYSBmdWxseSBzaWduZWQgVHJhbnNhY3Rpb24gb3IgYSBwYXJ0aWFsbHkgc2lnbmVkIG9uZS5cbiAgICogSWYgbm8gYm9vbGVhbiBpcyBwcm92aWRlZCwgd2UgZXhwZWN0IGEgZnVsbHkgc2lnbmVkIFRyYW5zYWN0aW9uIGJ5IGRlZmF1bHQuXG4gICAqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JlcXVpcmVBbGxTaWduYXR1cmVzPXRydWVdIFJlcXVpcmUgYSBmdWxseSBzaWduZWQgVHJhbnNhY3Rpb25cbiAgICovXG4gIHZlcmlmeVNpZ25hdHVyZXMocmVxdWlyZUFsbFNpZ25hdHVyZXMgPSB0cnVlKSB7XG4gICAgY29uc3Qgc2lnbmF0dXJlRXJyb3JzID0gdGhpcy5fZ2V0TWVzc2FnZVNpZ25lZG5lc3NFcnJvcnModGhpcy5zZXJpYWxpemVNZXNzYWdlKCksIHJlcXVpcmVBbGxTaWduYXR1cmVzKTtcbiAgICByZXR1cm4gIXNpZ25hdHVyZUVycm9ycztcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9nZXRNZXNzYWdlU2lnbmVkbmVzc0Vycm9ycyhtZXNzYWdlLCByZXF1aXJlQWxsU2lnbmF0dXJlcykge1xuICAgIGNvbnN0IGVycm9ycyA9IHt9O1xuICAgIGZvciAoY29uc3Qge1xuICAgICAgc2lnbmF0dXJlLFxuICAgICAgcHVibGljS2V5XG4gICAgfSBvZiB0aGlzLnNpZ25hdHVyZXMpIHtcbiAgICAgIGlmIChzaWduYXR1cmUgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKHJlcXVpcmVBbGxTaWduYXR1cmVzKSB7XG4gICAgICAgICAgKGVycm9ycy5taXNzaW5nIHx8PSBbXSkucHVzaChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleS50b0J5dGVzKCkpKSB7XG4gICAgICAgICAgKGVycm9ycy5pbnZhbGlkIHx8PSBbXSkucHVzaChwdWJsaWNLZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnMuaW52YWxpZCB8fCBlcnJvcnMubWlzc2luZyA/IGVycm9ycyA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIFRyYW5zYWN0aW9uIGluIHRoZSB3aXJlIGZvcm1hdC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtjb25maWddIENvbmZpZyBvZiB0cmFuc2FjdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge0J1ZmZlcn0gU2lnbmF0dXJlIG9mIHRyYW5zYWN0aW9uIGluIHdpcmUgZm9ybWF0LlxuICAgKi9cbiAgc2VyaWFsaXplKGNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzLFxuICAgICAgdmVyaWZ5U2lnbmF0dXJlc1xuICAgIH0gPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzOiB0cnVlLFxuICAgICAgdmVyaWZ5U2lnbmF0dXJlczogdHJ1ZVxuICAgIH0sIGNvbmZpZyk7XG4gICAgY29uc3Qgc2lnbkRhdGEgPSB0aGlzLnNlcmlhbGl6ZU1lc3NhZ2UoKTtcbiAgICBpZiAodmVyaWZ5U2lnbmF0dXJlcykge1xuICAgICAgY29uc3Qgc2lnRXJyb3JzID0gdGhpcy5fZ2V0TWVzc2FnZVNpZ25lZG5lc3NFcnJvcnMoc2lnbkRhdGEsIHJlcXVpcmVBbGxTaWduYXR1cmVzKTtcbiAgICAgIGlmIChzaWdFcnJvcnMpIHtcbiAgICAgICAgbGV0IGVycm9yTWVzc2FnZSA9ICdTaWduYXR1cmUgdmVyaWZpY2F0aW9uIGZhaWxlZC4nO1xuICAgICAgICBpZiAoc2lnRXJyb3JzLmludmFsaWQpIHtcbiAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gYFxcbkludmFsaWQgc2lnbmF0dXJlIGZvciBwdWJsaWMga2V5JHtzaWdFcnJvcnMuaW52YWxpZC5sZW5ndGggPT09IDEgPyAnJyA6ICcocyknfSBbXFxgJHtzaWdFcnJvcnMuaW52YWxpZC5tYXAocCA9PiBwLnRvQmFzZTU4KCkpLmpvaW4oJ2AsIGAnKX1cXGBdLmA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNpZ0Vycm9ycy5taXNzaW5nKSB7XG4gICAgICAgICAgZXJyb3JNZXNzYWdlICs9IGBcXG5NaXNzaW5nIHNpZ25hdHVyZSBmb3IgcHVibGljIGtleSR7c2lnRXJyb3JzLm1pc3NpbmcubGVuZ3RoID09PSAxID8gJycgOiAnKHMpJ30gW1xcYCR7c2lnRXJyb3JzLm1pc3NpbmcubWFwKHAgPT4gcC50b0Jhc2U1OCgpKS5qb2luKCdgLCBgJyl9XFxgXS5gO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc2VyaWFsaXplKHNpZ25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF9zZXJpYWxpemUoc2lnbkRhdGEpIHtcbiAgICBjb25zdCB7XG4gICAgICBzaWduYXR1cmVzXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2lnbmF0dXJlQ291bnQgPSBbXTtcbiAgICBlbmNvZGVMZW5ndGgoc2lnbmF0dXJlQ291bnQsIHNpZ25hdHVyZXMubGVuZ3RoKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkxlbmd0aCA9IHNpZ25hdHVyZUNvdW50Lmxlbmd0aCArIHNpZ25hdHVyZXMubGVuZ3RoICogNjQgKyBzaWduRGF0YS5sZW5ndGg7XG4gICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gQnVmZmVyLmFsbG9jKHRyYW5zYWN0aW9uTGVuZ3RoKTtcbiAgICBhc3NlcnQoc2lnbmF0dXJlcy5sZW5ndGggPCAyNTYpO1xuICAgIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZUNvdW50KS5jb3B5KHdpcmVUcmFuc2FjdGlvbiwgMCk7XG4gICAgc2lnbmF0dXJlcy5mb3JFYWNoKCh7XG4gICAgICBzaWduYXR1cmVcbiAgICB9LCBpbmRleCkgPT4ge1xuICAgICAgaWYgKHNpZ25hdHVyZSAhPT0gbnVsbCkge1xuICAgICAgICBhc3NlcnQoc2lnbmF0dXJlLmxlbmd0aCA9PT0gNjQsIGBzaWduYXR1cmUgaGFzIGludmFsaWQgbGVuZ3RoYCk7XG4gICAgICAgIEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSkuY29weSh3aXJlVHJhbnNhY3Rpb24sIHNpZ25hdHVyZUNvdW50Lmxlbmd0aCArIGluZGV4ICogNjQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHNpZ25EYXRhLmNvcHkod2lyZVRyYW5zYWN0aW9uLCBzaWduYXR1cmVDb3VudC5sZW5ndGggKyBzaWduYXR1cmVzLmxlbmd0aCAqIDY0KTtcbiAgICBhc3NlcnQod2lyZVRyYW5zYWN0aW9uLmxlbmd0aCA8PSBQQUNLRVRfREFUQV9TSVpFLCBgVHJhbnNhY3Rpb24gdG9vIGxhcmdlOiAke3dpcmVUcmFuc2FjdGlvbi5sZW5ndGh9ID4gJHtQQUNLRVRfREFUQV9TSVpFfWApO1xuICAgIHJldHVybiB3aXJlVHJhbnNhY3Rpb247XG4gIH1cblxuICAvKipcbiAgICogRGVwcmVjYXRlZCBtZXRob2RcbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXQga2V5cygpIHtcbiAgICBhc3NlcnQodGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoID09PSAxKTtcbiAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnNbMF0ua2V5cy5tYXAoa2V5T2JqID0+IGtleU9iai5wdWJrZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQgbWV0aG9kXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0IHByb2dyYW1JZCgpIHtcbiAgICBhc3NlcnQodGhpcy5pbnN0cnVjdGlvbnMubGVuZ3RoID09PSAxKTtcbiAgICByZXR1cm4gdGhpcy5pbnN0cnVjdGlvbnNbMF0ucHJvZ3JhbUlkO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcHJlY2F0ZWQgbWV0aG9kXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgYXNzZXJ0KHRoaXMuaW5zdHJ1Y3Rpb25zLmxlbmd0aCA9PT0gMSk7XG4gICAgcmV0dXJuIHRoaXMuaW5zdHJ1Y3Rpb25zWzBdLmRhdGE7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgYSB3aXJlIHRyYW5zYWN0aW9uIGludG8gYSBUcmFuc2FjdGlvbiBvYmplY3QuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyIHwgVWludDhBcnJheSB8IEFycmF5PG51bWJlcj59IGJ1ZmZlciBTaWduYXR1cmUgb2Ygd2lyZSBUcmFuc2FjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb259IFRyYW5zYWN0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgc2lnbmF0dXJlXG4gICAqL1xuICBzdGF0aWMgZnJvbShidWZmZXIpIHtcbiAgICAvLyBTbGljZSB1cCB3aXJlIGRhdGFcbiAgICBsZXQgYnl0ZUFycmF5ID0gWy4uLmJ1ZmZlcl07XG4gICAgY29uc3Qgc2lnbmF0dXJlQ291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBsZXQgc2lnbmF0dXJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmF0dXJlQ291bnQ7IGkrKykge1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpO1xuICAgICAgc2lnbmF0dXJlcy5wdXNoKGJzNTguZW5jb2RlKEJ1ZmZlci5mcm9tKHNpZ25hdHVyZSkpKTtcbiAgICB9XG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uLnBvcHVsYXRlKE1lc3NhZ2UuZnJvbShieXRlQXJyYXkpLCBzaWduYXR1cmVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQb3B1bGF0ZSBUcmFuc2FjdGlvbiBvYmplY3QgZnJvbSBtZXNzYWdlIGFuZCBzaWduYXR1cmVzXG4gICAqXG4gICAqIEBwYXJhbSB7TWVzc2FnZX0gbWVzc2FnZSBNZXNzYWdlIG9mIHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gc2lnbmF0dXJlcyBMaXN0IG9mIHNpZ25hdHVyZXMgdG8gYXNzaWduIHRvIHRoZSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAcmV0dXJucyB7VHJhbnNhY3Rpb259IFRoZSBwb3B1bGF0ZWQgVHJhbnNhY3Rpb25cbiAgICovXG4gIHN0YXRpYyBwb3B1bGF0ZShtZXNzYWdlLCBzaWduYXR1cmVzID0gW10pIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IG1lc3NhZ2UucmVjZW50QmxvY2toYXNoO1xuICAgIGlmIChtZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXMgPiAwKSB7XG4gICAgICB0cmFuc2FjdGlvbi5mZWVQYXllciA9IG1lc3NhZ2UuYWNjb3VudEtleXNbMF07XG4gICAgfVxuICAgIHNpZ25hdHVyZXMuZm9yRWFjaCgoc2lnbmF0dXJlLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3Qgc2lnUHVia2V5UGFpciA9IHtcbiAgICAgICAgc2lnbmF0dXJlOiBzaWduYXR1cmUgPT0gYnM1OC5lbmNvZGUoREVGQVVMVF9TSUdOQVRVUkUpID8gbnVsbCA6IGJzNTguZGVjb2RlKHNpZ25hdHVyZSksXG4gICAgICAgIHB1YmxpY0tleTogbWVzc2FnZS5hY2NvdW50S2V5c1tpbmRleF1cbiAgICAgIH07XG4gICAgICB0cmFuc2FjdGlvbi5zaWduYXR1cmVzLnB1c2goc2lnUHVia2V5UGFpcik7XG4gICAgfSk7XG4gICAgbWVzc2FnZS5pbnN0cnVjdGlvbnMuZm9yRWFjaChpbnN0cnVjdGlvbiA9PiB7XG4gICAgICBjb25zdCBrZXlzID0gaW5zdHJ1Y3Rpb24uYWNjb3VudHMubWFwKGFjY291bnQgPT4ge1xuICAgICAgICBjb25zdCBwdWJrZXkgPSBtZXNzYWdlLmFjY291bnRLZXlzW2FjY291bnRdO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHB1YmtleSxcbiAgICAgICAgICBpc1NpZ25lcjogdHJhbnNhY3Rpb24uc2lnbmF0dXJlcy5zb21lKGtleU9iaiA9PiBrZXlPYmoucHVibGljS2V5LnRvU3RyaW5nKCkgPT09IHB1YmtleS50b1N0cmluZygpKSB8fCBtZXNzYWdlLmlzQWNjb3VudFNpZ25lcihhY2NvdW50KSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBtZXNzYWdlLmlzQWNjb3VudFdyaXRhYmxlKGFjY291bnQpXG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICAgIHRyYW5zYWN0aW9uLmluc3RydWN0aW9ucy5wdXNoKG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgICAga2V5cyxcbiAgICAgICAgcHJvZ3JhbUlkOiBtZXNzYWdlLmFjY291bnRLZXlzW2luc3RydWN0aW9uLnByb2dyYW1JZEluZGV4XSxcbiAgICAgICAgZGF0YTogYnM1OC5kZWNvZGUoaW5zdHJ1Y3Rpb24uZGF0YSlcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgICB0cmFuc2FjdGlvbi5fbWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgdHJhbnNhY3Rpb24uX2pzb24gPSB0cmFuc2FjdGlvbi50b0pTT04oKTtcbiAgICByZXR1cm4gdHJhbnNhY3Rpb247XG4gIH1cbn1cblxuY2xhc3MgVHJhbnNhY3Rpb25NZXNzYWdlIHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMucGF5ZXJLZXkgPSB2b2lkIDA7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSB2b2lkIDA7XG4gICAgdGhpcy5yZWNlbnRCbG9ja2hhc2ggPSB2b2lkIDA7XG4gICAgdGhpcy5wYXllcktleSA9IGFyZ3MucGF5ZXJLZXk7XG4gICAgdGhpcy5pbnN0cnVjdGlvbnMgPSBhcmdzLmluc3RydWN0aW9ucztcbiAgICB0aGlzLnJlY2VudEJsb2NraGFzaCA9IGFyZ3MucmVjZW50QmxvY2toYXNoO1xuICB9XG4gIHN0YXRpYyBkZWNvbXBpbGUobWVzc2FnZSwgYXJncykge1xuICAgIGNvbnN0IHtcbiAgICAgIGhlYWRlcixcbiAgICAgIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zLFxuICAgICAgcmVjZW50QmxvY2toYXNoXG4gICAgfSA9IG1lc3NhZ2U7XG4gICAgY29uc3Qge1xuICAgICAgbnVtUmVxdWlyZWRTaWduYXR1cmVzLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50cyxcbiAgICAgIG51bVJlYWRvbmx5VW5zaWduZWRBY2NvdW50c1xuICAgIH0gPSBoZWFkZXI7XG4gICAgY29uc3QgbnVtV3JpdGFibGVTaWduZWRBY2NvdW50cyA9IG51bVJlcXVpcmVkU2lnbmF0dXJlcyAtIG51bVJlYWRvbmx5U2lnbmVkQWNjb3VudHM7XG4gICAgYXNzZXJ0KG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHMgPiAwLCAnTWVzc2FnZSBoZWFkZXIgaXMgaW52YWxpZCcpO1xuICAgIGNvbnN0IG51bVdyaXRhYmxlVW5zaWduZWRBY2NvdW50cyA9IG1lc3NhZ2Uuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoIC0gbnVtUmVxdWlyZWRTaWduYXR1cmVzIC0gbnVtUmVhZG9ubHlVbnNpZ25lZEFjY291bnRzO1xuICAgIGFzc2VydChudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHMgPj0gMCwgJ01lc3NhZ2UgaGVhZGVyIGlzIGludmFsaWQnKTtcbiAgICBjb25zdCBhY2NvdW50S2V5cyA9IG1lc3NhZ2UuZ2V0QWNjb3VudEtleXMoYXJncyk7XG4gICAgY29uc3QgcGF5ZXJLZXkgPSBhY2NvdW50S2V5cy5nZXQoMCk7XG4gICAgaWYgKHBheWVyS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGRlY29tcGlsZSBtZXNzYWdlIGJlY2F1c2Ugbm8gYWNjb3VudCBrZXlzIHdlcmUgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25zID0gW107XG4gICAgZm9yIChjb25zdCBjb21waWxlZEl4IG9mIGNvbXBpbGVkSW5zdHJ1Y3Rpb25zKSB7XG4gICAgICBjb25zdCBrZXlzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGtleUluZGV4IG9mIGNvbXBpbGVkSXguYWNjb3VudEtleUluZGV4ZXMpIHtcbiAgICAgICAgY29uc3QgcHVia2V5ID0gYWNjb3VudEtleXMuZ2V0KGtleUluZGV4KTtcbiAgICAgICAgaWYgKHB1YmtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gZmluZCBrZXkgZm9yIGFjY291bnQga2V5IGluZGV4ICR7a2V5SW5kZXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNTaWduZXIgPSBrZXlJbmRleCA8IG51bVJlcXVpcmVkU2lnbmF0dXJlcztcbiAgICAgICAgbGV0IGlzV3JpdGFibGU7XG4gICAgICAgIGlmIChpc1NpZ25lcikge1xuICAgICAgICAgIGlzV3JpdGFibGUgPSBrZXlJbmRleCA8IG51bVdyaXRhYmxlU2lnbmVkQWNjb3VudHM7XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5SW5kZXggPCBhY2NvdW50S2V5cy5zdGF0aWNBY2NvdW50S2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICBpc1dyaXRhYmxlID0ga2V5SW5kZXggLSBudW1SZXF1aXJlZFNpZ25hdHVyZXMgPCBudW1Xcml0YWJsZVVuc2lnbmVkQWNjb3VudHM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNXcml0YWJsZSA9IGtleUluZGV4IC0gYWNjb3VudEtleXMuc3RhdGljQWNjb3VudEtleXMubGVuZ3RoIDxcbiAgICAgICAgICAvLyBhY2NvdW50S2V5c0Zyb21Mb29rdXBzIGNhbm5vdCBiZSB1bmRlZmluZWQgYmVjYXVzZSB3ZSBhbHJlYWR5IGZvdW5kIGEgcHVia2V5IGZvciB0aGlzIGluZGV4IGFib3ZlXG4gICAgICAgICAgYWNjb3VudEtleXMuYWNjb3VudEtleXNGcm9tTG9va3Vwcy53cml0YWJsZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgICBwdWJrZXksXG4gICAgICAgICAgaXNTaWduZXI6IGtleUluZGV4IDwgaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyxcbiAgICAgICAgICBpc1dyaXRhYmxlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJvZ3JhbUlkID0gYWNjb3VudEtleXMuZ2V0KGNvbXBpbGVkSXgucHJvZ3JhbUlkSW5kZXgpO1xuICAgICAgaWYgKHByb2dyYW1JZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZpbmQgcHJvZ3JhbSBpZCBmb3IgcHJvZ3JhbSBpZCBpbmRleCAke2NvbXBpbGVkSXgucHJvZ3JhbUlkSW5kZXh9YCk7XG4gICAgICB9XG4gICAgICBpbnN0cnVjdGlvbnMucHVzaChuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICAgIHByb2dyYW1JZCxcbiAgICAgICAgZGF0YTogdG9CdWZmZXIoY29tcGlsZWRJeC5kYXRhKSxcbiAgICAgICAga2V5c1xuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uTWVzc2FnZSh7XG4gICAgICBwYXllcktleSxcbiAgICAgIGluc3RydWN0aW9ucyxcbiAgICAgIHJlY2VudEJsb2NraGFzaFxuICAgIH0pO1xuICB9XG4gIGNvbXBpbGVUb0xlZ2FjeU1lc3NhZ2UoKSB7XG4gICAgcmV0dXJuIE1lc3NhZ2UuY29tcGlsZSh7XG4gICAgICBwYXllcktleTogdGhpcy5wYXllcktleSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogdGhpcy5yZWNlbnRCbG9ja2hhc2gsXG4gICAgICBpbnN0cnVjdGlvbnM6IHRoaXMuaW5zdHJ1Y3Rpb25zXG4gICAgfSk7XG4gIH1cbiAgY29tcGlsZVRvVjBNZXNzYWdlKGFkZHJlc3NMb29rdXBUYWJsZUFjY291bnRzKSB7XG4gICAgcmV0dXJuIE1lc3NhZ2VWMC5jb21waWxlKHtcbiAgICAgIHBheWVyS2V5OiB0aGlzLnBheWVyS2V5LFxuICAgICAgcmVjZW50QmxvY2toYXNoOiB0aGlzLnJlY2VudEJsb2NraGFzaCxcbiAgICAgIGluc3RydWN0aW9uczogdGhpcy5pbnN0cnVjdGlvbnMsXG4gICAgICBhZGRyZXNzTG9va3VwVGFibGVBY2NvdW50c1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogVmVyc2lvbmVkIHRyYW5zYWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFZlcnNpb25lZFRyYW5zYWN0aW9uIHtcbiAgZ2V0IHZlcnNpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZS52ZXJzaW9uO1xuICB9XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHNpZ25hdHVyZXMpIHtcbiAgICB0aGlzLnNpZ25hdHVyZXMgPSB2b2lkIDA7XG4gICAgdGhpcy5tZXNzYWdlID0gdm9pZCAwO1xuICAgIGlmIChzaWduYXR1cmVzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGFzc2VydChzaWduYXR1cmVzLmxlbmd0aCA9PT0gbWVzc2FnZS5oZWFkZXIubnVtUmVxdWlyZWRTaWduYXR1cmVzLCAnRXhwZWN0ZWQgc2lnbmF0dXJlcyBsZW5ndGggdG8gYmUgZXF1YWwgdG8gdGhlIG51bWJlciBvZiByZXF1aXJlZCBzaWduYXR1cmVzJyk7XG4gICAgICB0aGlzLnNpZ25hdHVyZXMgPSBzaWduYXR1cmVzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkZWZhdWx0U2lnbmF0dXJlcyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtZXNzYWdlLmhlYWRlci5udW1SZXF1aXJlZFNpZ25hdHVyZXM7IGkrKykge1xuICAgICAgICBkZWZhdWx0U2lnbmF0dXJlcy5wdXNoKG5ldyBVaW50OEFycmF5KFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2lnbmF0dXJlcyA9IGRlZmF1bHRTaWduYXR1cmVzO1xuICAgIH1cbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkTWVzc2FnZSA9IHRoaXMubWVzc2FnZS5zZXJpYWxpemUoKTtcbiAgICBjb25zdCBlbmNvZGVkU2lnbmF0dXJlc0xlbmd0aCA9IEFycmF5KCk7XG4gICAgZW5jb2RlTGVuZ3RoKGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoLCB0aGlzLnNpZ25hdHVyZXMubGVuZ3RoKTtcbiAgICBjb25zdCB0cmFuc2FjdGlvbkxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5ibG9iKGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoLmxlbmd0aCwgJ2VuY29kZWRTaWduYXR1cmVzTGVuZ3RoJyksIEJ1ZmZlckxheW91dC5zZXEoc2lnbmF0dXJlKCksIHRoaXMuc2lnbmF0dXJlcy5sZW5ndGgsICdzaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dC5ibG9iKHNlcmlhbGl6ZWRNZXNzYWdlLmxlbmd0aCwgJ3NlcmlhbGl6ZWRNZXNzYWdlJyldKTtcbiAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSBuZXcgVWludDhBcnJheSgyMDQ4KTtcbiAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb25MZW5ndGggPSB0cmFuc2FjdGlvbkxheW91dC5lbmNvZGUoe1xuICAgICAgZW5jb2RlZFNpZ25hdHVyZXNMZW5ndGg6IG5ldyBVaW50OEFycmF5KGVuY29kZWRTaWduYXR1cmVzTGVuZ3RoKSxcbiAgICAgIHNpZ25hdHVyZXM6IHRoaXMuc2lnbmF0dXJlcyxcbiAgICAgIHNlcmlhbGl6ZWRNZXNzYWdlXG4gICAgfSwgc2VyaWFsaXplZFRyYW5zYWN0aW9uKTtcbiAgICByZXR1cm4gc2VyaWFsaXplZFRyYW5zYWN0aW9uLnNsaWNlKDAsIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbkxlbmd0aCk7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKHNlcmlhbGl6ZWRUcmFuc2FjdGlvbikge1xuICAgIGxldCBieXRlQXJyYXkgPSBbLi4uc2VyaWFsaXplZFRyYW5zYWN0aW9uXTtcbiAgICBjb25zdCBzaWduYXR1cmVzID0gW107XG4gICAgY29uc3Qgc2lnbmF0dXJlc0xlbmd0aCA9IGRlY29kZUxlbmd0aChieXRlQXJyYXkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2lnbmF0dXJlc0xlbmd0aDsgaSsrKSB7XG4gICAgICBzaWduYXR1cmVzLnB1c2gobmV3IFVpbnQ4QXJyYXkoZ3VhcmRlZFNwbGljZShieXRlQXJyYXksIDAsIFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpKSk7XG4gICAgfVxuICAgIGNvbnN0IG1lc3NhZ2UgPSBWZXJzaW9uZWRNZXNzYWdlLmRlc2VyaWFsaXplKG5ldyBVaW50OEFycmF5KGJ5dGVBcnJheSkpO1xuICAgIHJldHVybiBuZXcgVmVyc2lvbmVkVHJhbnNhY3Rpb24obWVzc2FnZSwgc2lnbmF0dXJlcyk7XG4gIH1cbiAgc2lnbihzaWduZXJzKSB7XG4gICAgY29uc3QgbWVzc2FnZURhdGEgPSB0aGlzLm1lc3NhZ2Uuc2VyaWFsaXplKCk7XG4gICAgY29uc3Qgc2lnbmVyUHVia2V5cyA9IHRoaXMubWVzc2FnZS5zdGF0aWNBY2NvdW50S2V5cy5zbGljZSgwLCB0aGlzLm1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyk7XG4gICAgZm9yIChjb25zdCBzaWduZXIgb2Ygc2lnbmVycykge1xuICAgICAgY29uc3Qgc2lnbmVySW5kZXggPSBzaWduZXJQdWJrZXlzLmZpbmRJbmRleChwdWJrZXkgPT4gcHVia2V5LmVxdWFscyhzaWduZXIucHVibGljS2V5KSk7XG4gICAgICBhc3NlcnQoc2lnbmVySW5kZXggPj0gMCwgYENhbm5vdCBzaWduIHdpdGggbm9uIHNpZ25lciBrZXkgJHtzaWduZXIucHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgICB0aGlzLnNpZ25hdHVyZXNbc2lnbmVySW5kZXhdID0gc2lnbihtZXNzYWdlRGF0YSwgc2lnbmVyLnNlY3JldEtleSk7XG4gICAgfVxuICB9XG4gIGFkZFNpZ25hdHVyZShwdWJsaWNLZXksIHNpZ25hdHVyZSkge1xuICAgIGFzc2VydChzaWduYXR1cmUuYnl0ZUxlbmd0aCA9PT0gNjQsICdTaWduYXR1cmUgbXVzdCBiZSA2NCBieXRlcyBsb25nJyk7XG4gICAgY29uc3Qgc2lnbmVyUHVia2V5cyA9IHRoaXMubWVzc2FnZS5zdGF0aWNBY2NvdW50S2V5cy5zbGljZSgwLCB0aGlzLm1lc3NhZ2UuaGVhZGVyLm51bVJlcXVpcmVkU2lnbmF0dXJlcyk7XG4gICAgY29uc3Qgc2lnbmVySW5kZXggPSBzaWduZXJQdWJrZXlzLmZpbmRJbmRleChwdWJrZXkgPT4gcHVia2V5LmVxdWFscyhwdWJsaWNLZXkpKTtcbiAgICBhc3NlcnQoc2lnbmVySW5kZXggPj0gMCwgYENhbiBub3QgYWRkIHNpZ25hdHVyZTsgXFxgJHtwdWJsaWNLZXkudG9CYXNlNTgoKX1cXGAgaXMgbm90IHJlcXVpcmVkIHRvIHNpZ24gdGhpcyB0cmFuc2FjdGlvbmApO1xuICAgIHRoaXMuc2lnbmF0dXJlc1tzaWduZXJJbmRleF0gPSBzaWduYXR1cmU7XG4gIH1cbn1cblxuLy8gVE9ETzogVGhlc2UgY29uc3RhbnRzIHNob3VsZCBiZSByZW1vdmVkIGluIGZhdm9yIG9mIHJlYWRpbmcgdGhlbSBvdXQgb2YgYVxuLy8gU3lzY2FsbCBhY2NvdW50XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IE5VTV9USUNLU19QRVJfU0VDT05EID0gMTYwO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBERUZBVUxUX1RJQ0tTX1BFUl9TTE9UID0gNjQ7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IE5VTV9TTE9UU19QRVJfU0VDT05EID0gTlVNX1RJQ0tTX1BFUl9TRUNPTkQgLyBERUZBVUxUX1RJQ0tTX1BFUl9TTE9UO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBNU19QRVJfU0xPVCA9IDEwMDAgLyBOVU1fU0xPVFNfUEVSX1NFQ09ORDtcblxuY29uc3QgU1lTVkFSX0NMT0NLX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhckMxb2NrMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9FUE9DSF9TQ0hFRFVMRV9QVUJLRVkgPSBuZXcgUHVibGljS2V5KCdTeXN2YXJFcG9jaFNjaGVkdTFlMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5jb25zdCBTWVNWQVJfSU5TVFJVQ1RJT05TX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhcjFuc3RydWN0aW9uczExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUmVjZW50QjFvY2tIYXNoZXMxMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1JFTlRfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUmVudDExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1JFV0FSRFNfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUmV3YXJkczExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1NMT1RfSEFTSEVTX1BVQktFWSA9IG5ldyBQdWJsaWNLZXkoJ1N5c3ZhclMxb3RIYXNoZXMxMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcbmNvbnN0IFNZU1ZBUl9TTE9UX0hJU1RPUllfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyUzFvdEhpc3RvcnkxMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuY29uc3QgU1lTVkFSX1NUQUtFX0hJU1RPUllfUFVCS0VZID0gbmV3IFB1YmxpY0tleSgnU3lzdmFyU3Rha2VIaXN0b3J5MTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIFNpZ24sIHNlbmQgYW5kIGNvbmZpcm0gYSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBJZiBgY29tbWl0bWVudGAgb3B0aW9uIGlzIG5vdCBzcGVjaWZpZWQsIGRlZmF1bHRzIHRvICdtYXgnIGNvbW1pdG1lbnQuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9ufSBjb25uZWN0aW9uXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtBcnJheTxTaWduZXI+fSBzaWduZXJzXG4gKiBAcGFyYW0ge0NvbmZpcm1PcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uU2lnbmF0dXJlPn1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbihjb25uZWN0aW9uLCB0cmFuc2FjdGlvbiwgc2lnbmVycywgb3B0aW9ucykge1xuICBjb25zdCBzZW5kT3B0aW9ucyA9IG9wdGlvbnMgJiYge1xuICAgIHNraXBQcmVmbGlnaHQ6IG9wdGlvbnMuc2tpcFByZWZsaWdodCxcbiAgICBwcmVmbGlnaHRDb21taXRtZW50OiBvcHRpb25zLnByZWZsaWdodENvbW1pdG1lbnQgfHwgb3B0aW9ucy5jb21taXRtZW50LFxuICAgIG1heFJldHJpZXM6IG9wdGlvbnMubWF4UmV0cmllcyxcbiAgICBtaW5Db250ZXh0U2xvdDogb3B0aW9ucy5taW5Db250ZXh0U2xvdFxuICB9O1xuICBjb25zdCBzaWduYXR1cmUgPSBhd2FpdCBjb25uZWN0aW9uLnNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgc2lnbmVycywgc2VuZE9wdGlvbnMpO1xuICBsZXQgc3RhdHVzO1xuICBpZiAodHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoICE9IG51bGwgJiYgdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHQgIT0gbnVsbCkge1xuICAgIHN0YXR1cyA9IChhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucz8uYWJvcnRTaWduYWwsXG4gICAgICBzaWduYXR1cmU6IHNpZ25hdHVyZSxcbiAgICAgIGJsb2NraGFzaDogdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoLFxuICAgICAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IHRyYW5zYWN0aW9uLmxhc3RWYWxpZEJsb2NrSGVpZ2h0XG4gICAgfSwgb3B0aW9ucyAmJiBvcHRpb25zLmNvbW1pdG1lbnQpKS52YWx1ZTtcbiAgfSBlbHNlIGlmICh0cmFuc2FjdGlvbi5taW5Ob25jZUNvbnRleHRTbG90ICE9IG51bGwgJiYgdHJhbnNhY3Rpb24ubm9uY2VJbmZvICE9IG51bGwpIHtcbiAgICBjb25zdCB7XG4gICAgICBub25jZUluc3RydWN0aW9uXG4gICAgfSA9IHRyYW5zYWN0aW9uLm5vbmNlSW5mbztcbiAgICBjb25zdCBub25jZUFjY291bnRQdWJrZXkgPSBub25jZUluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5O1xuICAgIHN0YXR1cyA9IChhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbih7XG4gICAgICBhYm9ydFNpZ25hbDogb3B0aW9ucz8uYWJvcnRTaWduYWwsXG4gICAgICBtaW5Db250ZXh0U2xvdDogdHJhbnNhY3Rpb24ubWluTm9uY2VDb250ZXh0U2xvdCxcbiAgICAgIG5vbmNlQWNjb3VudFB1YmtleSxcbiAgICAgIG5vbmNlVmFsdWU6IHRyYW5zYWN0aW9uLm5vbmNlSW5mby5ub25jZSxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH0sIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50KSkudmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG9wdGlvbnM/LmFib3J0U2lnbmFsICE9IG51bGwpIHtcbiAgICAgIGNvbnNvbGUud2Fybignc2VuZEFuZENvbmZpcm1UcmFuc2FjdGlvbigpOiBBIHRyYW5zYWN0aW9uIHdpdGggYSBkZXByZWNhdGVkIGNvbmZpcm1hdGlvbiBzdHJhdGVneSB3YXMgJyArICdzdXBwbGllZCBhbG9uZyB3aXRoIGFuIGBhYm9ydFNpZ25hbGAuIE9ubHkgdHJhbnNhY3Rpb25zIGhhdmluZyBgbGFzdFZhbGlkQmxvY2tIZWlnaHRgICcgKyAnb3IgYSBjb21iaW5hdGlvbiBvZiBgbm9uY2VJbmZvYCBhbmQgYG1pbk5vbmNlQ29udGV4dFNsb3RgIGFyZSBhYm9ydGFibGUuJyk7XG4gICAgfVxuICAgIHN0YXR1cyA9IChhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihzaWduYXR1cmUsIG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50KSkudmFsdWU7XG4gIH1cbiAgaWYgKHN0YXR1cy5lcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRyYW5zYWN0aW9uICR7c2lnbmF0dXJlfSBmYWlsZWQgKCR7SlNPTi5zdHJpbmdpZnkoc3RhdHVzKX0pYCk7XG4gIH1cbiAgcmV0dXJuIHNpZ25hdHVyZTtcbn1cblxuLy8genp6XG5mdW5jdGlvbiBzbGVlcChtcykge1xuICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cblxuLyoqXG4gKiBQb3B1bGF0ZSBhIGJ1ZmZlciBvZiBpbnN0cnVjdGlvbiBkYXRhIHVzaW5nIGFuIEluc3RydWN0aW9uVHlwZVxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGVuY29kZURhdGEodHlwZSwgZmllbGRzKSB7XG4gIGNvbnN0IGFsbG9jTGVuZ3RoID0gdHlwZS5sYXlvdXQuc3BhbiA+PSAwID8gdHlwZS5sYXlvdXQuc3BhbiA6IGdldEFsbG9jKHR5cGUsIGZpZWxkcyk7XG4gIGNvbnN0IGRhdGEgPSBCdWZmZXIuYWxsb2MoYWxsb2NMZW5ndGgpO1xuICBjb25zdCBsYXlvdXRGaWVsZHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICBpbnN0cnVjdGlvbjogdHlwZS5pbmRleFxuICB9LCBmaWVsZHMpO1xuICB0eXBlLmxheW91dC5lbmNvZGUobGF5b3V0RmllbGRzLCBkYXRhKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogRGVjb2RlIGluc3RydWN0aW9uIGRhdGEgYnVmZmVyIHVzaW5nIGFuIEluc3RydWN0aW9uVHlwZVxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGRlY29kZURhdGEkMSh0eXBlLCBidWZmZXIpIHtcbiAgbGV0IGRhdGE7XG4gIHRyeSB7XG4gICAgZGF0YSA9IHR5cGUubGF5b3V0LmRlY29kZShidWZmZXIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247ICcgKyBlcnIpO1xuICB9XG4gIGlmIChkYXRhLmluc3RydWN0aW9uICE9PSB0eXBlLmluZGV4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluc3RydWN0aW9uOyBpbnN0cnVjdGlvbiBpbmRleCBtaXNtYXRjaCAke2RhdGEuaW5zdHJ1Y3Rpb259ICE9ICR7dHlwZS5pbmRleH1gKTtcbiAgfVxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvOTBiZWRkN2UwNjdiNWI4ZjNkZGJiNDVkYTAwYTRlOWNhYmIyMmM2Mi9zZGsvc3JjL2ZlZV9jYWxjdWxhdG9yLnJzI0w3LUwxMVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBGZWVDYWxjdWxhdG9yTGF5b3V0ID0gQnVmZmVyTGF5b3V0Lm51NjQoJ2xhbXBvcnRzUGVyU2lnbmF0dXJlJyk7XG5cbi8qKlxuICogQ2FsY3VsYXRvciBmb3IgdHJhbnNhY3Rpb24gZmVlcy5cbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuXG4gKi9cblxuLyoqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9ibG9iLzBlYTI4NDNlYzljZGM1MTc1NzJiOGU2MmM5NTlmNDFiNTVjZjQ0NTMvc2RrL3NyYy9ub25jZV9zdGF0ZS5ycyNMMjktTDMyXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IE5vbmNlQWNjb3VudExheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ3ZlcnNpb24nKSwgQnVmZmVyTGF5b3V0LnUzMignc3RhdGUnKSwgcHVibGljS2V5KCdhdXRob3JpemVkUHVia2V5JyksIHB1YmxpY0tleSgnbm9uY2UnKSwgQnVmZmVyTGF5b3V0LnN0cnVjdChbRmVlQ2FsY3VsYXRvckxheW91dF0sICdmZWVDYWxjdWxhdG9yJyldKTtcbmNvbnN0IE5PTkNFX0FDQ09VTlRfTEVOR1RIID0gTm9uY2VBY2NvdW50TGF5b3V0LnNwYW47XG5cbi8qKlxuICogQSBkdXJhYmxlIG5vbmNlIGlzIGEgMzIgYnl0ZSB2YWx1ZSBlbmNvZGVkIGFzIGEgYmFzZTU4IHN0cmluZy5cbiAqL1xuXG4vKipcbiAqIE5vbmNlQWNjb3VudCBjbGFzc1xuICovXG5jbGFzcyBOb25jZUFjY291bnQge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5hdXRob3JpemVkUHVia2V5ID0gdm9pZCAwO1xuICAgIHRoaXMubm9uY2UgPSB2b2lkIDA7XG4gICAgdGhpcy5mZWVDYWxjdWxhdG9yID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFB1YmtleSA9IGFyZ3MuYXV0aG9yaXplZFB1YmtleTtcbiAgICB0aGlzLm5vbmNlID0gYXJncy5ub25jZTtcbiAgICB0aGlzLmZlZUNhbGN1bGF0b3IgPSBhcmdzLmZlZUNhbGN1bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgTm9uY2VBY2NvdW50IGZyb20gdGhlIGFjY291bnQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciBhY2NvdW50IGRhdGFcbiAgICogQHJldHVybiBOb25jZUFjY291bnRcbiAgICovXG4gIHN0YXRpYyBmcm9tQWNjb3VudERhdGEoYnVmZmVyKSB7XG4gICAgY29uc3Qgbm9uY2VBY2NvdW50ID0gTm9uY2VBY2NvdW50TGF5b3V0LmRlY29kZSh0b0J1ZmZlcihidWZmZXIpLCAwKTtcbiAgICByZXR1cm4gbmV3IE5vbmNlQWNjb3VudCh7XG4gICAgICBhdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5vbmNlQWNjb3VudC5hdXRob3JpemVkUHVia2V5KSxcbiAgICAgIG5vbmNlOiBuZXcgUHVibGljS2V5KG5vbmNlQWNjb3VudC5ub25jZSkudG9TdHJpbmcoKSxcbiAgICAgIGZlZUNhbGN1bGF0b3I6IG5vbmNlQWNjb3VudC5mZWVDYWxjdWxhdG9yXG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3QgZW5jb2RlRGVjb2RlID0gbGF5b3V0ID0+IHtcbiAgY29uc3QgZGVjb2RlID0gbGF5b3V0LmRlY29kZS5iaW5kKGxheW91dCk7XG4gIGNvbnN0IGVuY29kZSA9IGxheW91dC5lbmNvZGUuYmluZChsYXlvdXQpO1xuICByZXR1cm4ge1xuICAgIGRlY29kZSxcbiAgICBlbmNvZGVcbiAgfTtcbn07XG5jb25zdCBiaWdJbnQgPSBsZW5ndGggPT4gcHJvcGVydHkgPT4ge1xuICBjb25zdCBsYXlvdXQgPSBibG9iKGxlbmd0aCwgcHJvcGVydHkpO1xuICBjb25zdCB7XG4gICAgZW5jb2RlLFxuICAgIGRlY29kZVxuICB9ID0gZW5jb2RlRGVjb2RlKGxheW91dCk7XG4gIGNvbnN0IGJpZ0ludExheW91dCA9IGxheW91dDtcbiAgYmlnSW50TGF5b3V0LmRlY29kZSA9IChidWZmZXIsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IHNyYyA9IGRlY29kZShidWZmZXIsIG9mZnNldCk7XG4gICAgcmV0dXJuIHRvQmlnSW50TEUoQnVmZmVyLmZyb20oc3JjKSk7XG4gIH07XG4gIGJpZ0ludExheW91dC5lbmNvZGUgPSAoYmlnSW50LCBidWZmZXIsIG9mZnNldCkgPT4ge1xuICAgIGNvbnN0IHNyYyA9IHRvQnVmZmVyTEUoYmlnSW50LCBsZW5ndGgpO1xuICAgIHJldHVybiBlbmNvZGUoc3JjLCBidWZmZXIsIG9mZnNldCk7XG4gIH07XG4gIHJldHVybiBiaWdJbnRMYXlvdXQ7XG59O1xuY29uc3QgdTY0ID0gYmlnSW50KDgpO1xuXG4vKipcbiAqIENyZWF0ZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFRyYW5zZmVyIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFzc2lnbiBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBDcmVhdGUgYWNjb3VudCB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIG5vbmNlIGFjY291bnQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQ3JlYXRlIG5vbmNlIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEluaXRpYWxpemUgbm9uY2UgYWNjb3VudCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBZHZhbmNlIG5vbmNlIGFjY291bnQgc3lzdGVtIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogV2l0aGRyYXcgbm9uY2UgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBdXRob3JpemUgbm9uY2UgYWNjb3VudCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBbGxvY2F0ZSBhY2NvdW50IHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFsbG9jYXRlIGFjY291bnQgd2l0aCBzZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIEFzc2lnbiBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBUcmFuc2ZlciB3aXRoIHNlZWQgc3lzdGVtIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKiBEZWNvZGVkIHRyYW5zZmVyIHN5c3RlbSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiAqL1xuXG4vKiogRGVjb2RlZCB0cmFuc2ZlcldpdGhTZWVkIHN5c3RlbSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiAqL1xuXG4vKipcbiAqIFN5c3RlbSBJbnN0cnVjdGlvbiBjbGFzc1xuICovXG5jbGFzcyBTeXN0ZW1JbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gdHlwZUluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBpeFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdHJ1Y3Rpb24gdHlwZSBpbmNvcnJlY3Q7IG5vdCBhIFN5c3RlbUluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGNyZWF0ZSBhY2NvdW50IHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVDcmVhdGVBY2NvdW50KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHMsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgdHJhbnNmZXIgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVRyYW5zZmVyKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLlRyYW5zZmVyLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBsYW1wb3J0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgdHJhbnNmZXIgd2l0aCBzZWVkIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVUcmFuc2ZlcldpdGhTZWVkKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHMsXG4gICAgICBzZWVkLFxuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5UcmFuc2ZlcldpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIHRvUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc2VlZCxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYWxsb2NhdGUgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUFsbG9jYXRlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG4gICAgY29uc3Qge1xuICAgICAgc3BhY2VcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFsbG9jYXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgYWNjb3VudFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBzcGFjZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGFsbG9jYXRlIHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQWxsb2NhdGVXaXRoU2VlZChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDEpO1xuICAgIGNvbnN0IHtcbiAgICAgIGJhc2UsXG4gICAgICBzZWVkLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFsbG9jYXRlV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYmFzZSksXG4gICAgICBzZWVkLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IG5ldyBQdWJsaWNLZXkocHJvZ3JhbUlkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGFzc2lnbiBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXNzaWduKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMSk7XG4gICAgY29uc3Qge1xuICAgICAgcHJvZ3JhbUlkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Bc3NpZ24sIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYW4gYXNzaWduIHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXNzaWduV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAxKTtcbiAgICBjb25zdCB7XG4gICAgICBiYXNlLFxuICAgICAgc2VlZCxcbiAgICAgIHByb2dyYW1JZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXNzaWduV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBhY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYmFzZSksXG4gICAgICBzZWVkLFxuICAgICAgcHJvZ3JhbUlkOiBuZXcgUHVibGljS2V5KHByb2dyYW1JZClcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIGNyZWF0ZSBhY2NvdW50IHdpdGggc2VlZCBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQ3JlYXRlV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBiYXNlLFxuICAgICAgc2VlZCxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgc3BhY2UsXG4gICAgICBwcm9ncmFtSWRcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZVdpdGhTZWVkLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgZnJvbVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzFdLnB1YmtleSxcbiAgICAgIGJhc2VQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYmFzZSksXG4gICAgICBzZWVkLFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBzcGFjZSxcbiAgICAgIHByb2dyYW1JZDogbmV3IFB1YmxpY0tleShwcm9ncmFtSWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBub25jZSBpbml0aWFsaXplIHN5c3RlbSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVOb25jZUluaXRpYWxpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICBhdXRob3JpemVkXG4gICAgfSA9IGRlY29kZURhdGEkMShTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplTm9uY2VBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShhdXRob3JpemVkKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgbm9uY2UgYWR2YW5jZSBzeXN0ZW0gaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlTm9uY2VBZHZhbmNlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgZGVjb2RlRGF0YSQxKFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFkdmFuY2VOb25jZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBub25jZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgbm9uY2Ugd2l0aGRyYXcgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU5vbmNlV2l0aGRyYXcoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA1KTtcbiAgICBjb25zdCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXdOb25jZUFjY291bnQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBub25jZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzRdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBub25jZSBhdXRob3JpemUgc3lzdGVtIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZU5vbmNlQXV0aG9yaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMik7XG4gICAgY29uc3Qge1xuICAgICAgYXV0aG9yaXplZFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplTm9uY2VBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbm9uY2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoU3lzdGVtUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgU3lzdGVtUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja0tleUxlbmd0aChrZXlzLCBleHBlY3RlZExlbmd0aCkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgU3lzdGVtSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqL1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIHN5c3RlbSBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIENyZWF0ZToge1xuICAgIGluZGV4OiAwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyksIEJ1ZmZlckxheW91dC5uczY0KCdzcGFjZScpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgQXNzaWduOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ3Byb2dyYW1JZCcpXSlcbiAgfSxcbiAgVHJhbnNmZXI6IHtcbiAgICBpbmRleDogMixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHU2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIENyZWF0ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ2Jhc2UnKSwgcnVzdFN0cmluZygnc2VlZCcpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ3NwYWNlJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBBZHZhbmNlTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSlcbiAgfSxcbiAgV2l0aGRyYXdOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogNSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC5uczY0KCdsYW1wb3J0cycpXSlcbiAgfSxcbiAgSW5pdGlhbGl6ZU5vbmNlQWNjb3VudDoge1xuICAgIGluZGV4OiA2LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdhdXRob3JpemVkJyldKVxuICB9LFxuICBBdXRob3JpemVOb25jZUFjY291bnQ6IHtcbiAgICBpbmRleDogNyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZCcpXSlcbiAgfSxcbiAgQWxsb2NhdGU6IHtcbiAgICBpbmRleDogOCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC5uczY0KCdzcGFjZScpXSlcbiAgfSxcbiAgQWxsb2NhdGVXaXRoU2VlZDoge1xuICAgIGluZGV4OiA5LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgcHVibGljS2V5KCdiYXNlJyksIHJ1c3RTdHJpbmcoJ3NlZWQnKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ3NwYWNlJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBBc3NpZ25XaXRoU2VlZDoge1xuICAgIGluZGV4OiAxMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnYmFzZScpLCBydXN0U3RyaW5nKCdzZWVkJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBUcmFuc2ZlcldpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDExLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgdTY0KCdsYW1wb3J0cycpLCBydXN0U3RyaW5nKCdzZWVkJyksIHB1YmxpY0tleSgncHJvZ3JhbUlkJyldKVxuICB9LFxuICBVcGdyYWRlTm9uY2VBY2NvdW50OiB7XG4gICAgaW5kZXg6IDEyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH1cbn0pO1xuXG4vKipcbiAqIEZhY3RvcnkgY2xhc3MgZm9yIHRyYW5zYWN0aW9ucyB0byBpbnRlcmFjdCB3aXRoIHRoZSBTeXN0ZW0gcHJvZ3JhbVxuICovXG5jbGFzcyBTeXN0ZW1Qcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgU3lzdGVtIHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gaW5zdHJ1Y3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50KHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgIHNwYWNlOiBwYXJhbXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRvQnVmZmVyKHBhcmFtcy5wcm9ncmFtSWQudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubmV3QWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgdHJhbnNmZXJzIGxhbXBvcnRzIGZyb20gb25lIGFjY291bnQgdG8gYW5vdGhlclxuICAgKi9cbiAgc3RhdGljIHRyYW5zZmVyKHBhcmFtcykge1xuICAgIGxldCBkYXRhO1xuICAgIGxldCBrZXlzO1xuICAgIGlmICgnYmFzZVB1YmtleScgaW4gcGFyYW1zKSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuVHJhbnNmZXJXaXRoU2VlZDtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgbGFtcG9ydHM6IEJpZ0ludChwYXJhbXMubGFtcG9ydHMpLFxuICAgICAgICBzZWVkOiBwYXJhbXMuc2VlZCxcbiAgICAgICAgcHJvZ3JhbUlkOiB0b0J1ZmZlcihwYXJhbXMucHJvZ3JhbUlkLnRvQnVmZmVyKCkpXG4gICAgICB9KTtcbiAgICAgIGtleXMgPSBbe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLnRvUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB0eXBlID0gU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMuVHJhbnNmZXI7XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIGxhbXBvcnRzOiBCaWdJbnQocGFyYW1zLmxhbXBvcnRzKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMudG9QdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfV07XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgYXNzaWducyBhbiBhY2NvdW50IHRvIGEgcHJvZ3JhbVxuICAgKi9cbiAgc3RhdGljIGFzc2lnbihwYXJhbXMpIHtcbiAgICBsZXQgZGF0YTtcbiAgICBsZXQga2V5cztcbiAgICBpZiAoJ2Jhc2VQdWJrZXknIGluIHBhcmFtcykge1xuICAgICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFzc2lnbldpdGhTZWVkO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBiYXNlOiB0b0J1ZmZlcihwYXJhbXMuYmFzZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Bc3NpZ247XG4gICAgICBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgYWNjb3VudCBhdFxuICAgKiAgIGFuIGFkZHJlc3MgZ2VuZXJhdGVkIHdpdGggYGZyb21gLCBhIHNlZWQsIGFuZCBwcm9ncmFtSWRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50V2l0aFNlZWQocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkNyZWF0ZVdpdGhTZWVkO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGJhc2U6IHRvQnVmZmVyKHBhcmFtcy5iYXNlUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgIH0pO1xuICAgIGxldCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5uZXdBY2NvdW50UHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH1dO1xuICAgIGlmIChwYXJhbXMuYmFzZVB1YmtleSAhPSBwYXJhbXMuZnJvbVB1YmtleSkge1xuICAgICAga2V5cy5wdXNoKHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgdHJhbnNhY3Rpb24gdGhhdCBjcmVhdGVzIGEgbmV3IE5vbmNlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVOb25jZUFjY291bnQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICBpZiAoJ2Jhc2VQdWJrZXknIGluIHBhcmFtcyAmJiAnc2VlZCcgaW4gcGFyYW1zKSB7XG4gICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50V2l0aFNlZWQoe1xuICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuZnJvbVB1YmtleSxcbiAgICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgICBiYXNlUHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHMsXG4gICAgICAgIHNwYWNlOiBOT05DRV9BQ0NPVU5UX0xFTkdUSCxcbiAgICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5ub25jZVB1YmtleSxcbiAgICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgICAgc3BhY2U6IE5PTkNFX0FDQ09VTlRfTEVOR1RILFxuICAgICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGNvbnN0IGluaXRQYXJhbXMgPSB7XG4gICAgICBub25jZVB1YmtleTogcGFyYW1zLm5vbmNlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXlcbiAgICB9O1xuICAgIHRyYW5zYWN0aW9uLmFkZCh0aGlzLm5vbmNlSW5pdGlhbGl6ZShpbml0UGFyYW1zKSk7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGFuIGluc3RydWN0aW9uIHRvIGluaXRpYWxpemUgYSBOb25jZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgbm9uY2VJbml0aWFsaXplKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5Jbml0aWFsaXplTm9uY2VBY2NvdW50O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGF1dGhvcml6ZWQ6IHRvQnVmZmVyKHBhcmFtcy5hdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBpbnN0cnVjdGlvbiB0byBhZHZhbmNlIHRoZSBub25jZSBpbiBhIE5vbmNlIGFjY291bnRcbiAgICovXG4gIHN0YXRpYyBub25jZUFkdmFuY2UocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLkFkdmFuY2VOb25jZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9SRUNFTlRfQkxPQ0tIQVNIRVNfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IHdpdGhkcmF3cyBsYW1wb3J0cyBmcm9tIGEgTm9uY2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIG5vbmNlV2l0aGRyYXcocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IFNZU1RFTV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3Tm9uY2VBY2NvdW50O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzOiBwYXJhbXMubGFtcG9ydHNcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy50b1B1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFQ0VOVF9CTE9DS0hBU0hFU19QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfUkVOVF9QVUJLRVksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbiB0aGF0IGF1dGhvcml6ZXMgYSBuZXcgUHVibGljS2V5IGFzIHRoZSBhdXRob3JpdHlcbiAgICogb24gYSBOb25jZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIG5vbmNlQXV0aG9yaXplKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVOb25jZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgYXV0aG9yaXplZDogdG9CdWZmZXIocGFyYW1zLm5ld0F1dGhvcml6ZWRQdWJrZXkudG9CdWZmZXIoKSlcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMubm9uY2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uIHRoYXQgYWxsb2NhdGVzIHNwYWNlIGluIGFuIGFjY291bnQgd2l0aG91dCBmdW5kaW5nXG4gICAqL1xuICBzdGF0aWMgYWxsb2NhdGUocGFyYW1zKSB7XG4gICAgbGV0IGRhdGE7XG4gICAgbGV0IGtleXM7XG4gICAgaWYgKCdiYXNlUHVia2V5JyBpbiBwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BbGxvY2F0ZVdpdGhTZWVkO1xuICAgICAgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgICBiYXNlOiB0b0J1ZmZlcihwYXJhbXMuYmFzZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgc2VlZDogcGFyYW1zLnNlZWQsXG4gICAgICAgIHNwYWNlOiBwYXJhbXMuc3BhY2UsXG4gICAgICAgIHByb2dyYW1JZDogdG9CdWZmZXIocGFyYW1zLnByb2dyYW1JZC50b0J1ZmZlcigpKVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogcGFyYW1zLmJhc2VQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBTWVNURU1fSU5TVFJVQ1RJT05fTEFZT1VUUy5BbGxvY2F0ZTtcbiAgICAgIGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgICAgc3BhY2U6IHBhcmFtcy5zcGFjZVxuICAgICAgfSk7XG4gICAgICBrZXlzID0gW3tcbiAgICAgICAgcHVia2V5OiBwYXJhbXMuYWNjb3VudFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH1dO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbn1cblN5c3RlbVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLy8gS2VlcCBwcm9ncmFtIGNodW5rcyB1bmRlciBQQUNLRVRfREFUQV9TSVpFLCBsZWF2aW5nIGVub3VnaCByb29tIGZvciB0aGVcbi8vIHJlc3Qgb2YgdGhlIFRyYW5zYWN0aW9uIGZpZWxkc1xuLy9cbi8vIFRPRE86IHJlcGxhY2UgMzAwIHdpdGggYSBwcm9wZXIgY29uc3RhbnQgZm9yIHRoZSBzaXplIG9mIHRoZSBvdGhlclxuLy8gVHJhbnNhY3Rpb24gZmllbGRzXG5jb25zdCBDSFVOS19TSVpFID0gUEFDS0VUX0RBVEFfU0laRSAtIDMwMDtcblxuLyoqXG4gKiBQcm9ncmFtIGxvYWRlciBpbnRlcmZhY2VcbiAqL1xuY2xhc3MgTG9hZGVyIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBBbW91bnQgb2YgcHJvZ3JhbSBkYXRhIHBsYWNlZCBpbiBlYWNoIGxvYWQgVHJhbnNhY3Rpb25cbiAgICovXG5cbiAgLyoqXG4gICAqIE1pbmltdW0gbnVtYmVyIG9mIHNpZ25hdHVyZXMgcmVxdWlyZWQgdG8gbG9hZCBhIHByb2dyYW0gbm90IGluY2x1ZGluZ1xuICAgKiByZXRyaWVzXG4gICAqXG4gICAqIENhbiBiZSB1c2VkIHRvIGNhbGN1bGF0ZSB0cmFuc2FjdGlvbiBmZWVzXG4gICAqL1xuICBzdGF0aWMgZ2V0TWluTnVtU2lnbmF0dXJlcyhkYXRhTGVuZ3RoKSB7XG4gICAgcmV0dXJuIDIgKiAoXG4gICAgLy8gRXZlcnkgdHJhbnNhY3Rpb24gcmVxdWlyZXMgdHdvIHNpZ25hdHVyZXMgKHBheWVyICsgcHJvZ3JhbSlcbiAgICBNYXRoLmNlaWwoZGF0YUxlbmd0aCAvIExvYWRlci5jaHVua1NpemUpICsgMSArXG4gICAgLy8gQWRkIG9uZSBmb3IgQ3JlYXRlIHRyYW5zYWN0aW9uXG4gICAgMSkgLy8gQWRkIG9uZSBmb3IgRmluYWxpemUgdHJhbnNhY3Rpb25cbiAgICA7XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgYSBnZW5lcmljIHByb2dyYW1cbiAgICpcbiAgICogQHBhcmFtIGNvbm5lY3Rpb24gVGhlIGNvbm5lY3Rpb24gdG8gdXNlXG4gICAqIEBwYXJhbSBwYXllciBTeXN0ZW0gYWNjb3VudCB0aGF0IHBheXMgdG8gbG9hZCB0aGUgcHJvZ3JhbVxuICAgKiBAcGFyYW0gcHJvZ3JhbSBBY2NvdW50IHRvIGxvYWQgdGhlIHByb2dyYW0gaW50b1xuICAgKiBAcGFyYW0gcHJvZ3JhbUlkIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBsb2FkZXJcbiAgICogQHBhcmFtIGRhdGEgUHJvZ3JhbSBvY3RldHNcbiAgICogQHJldHVybiB0cnVlIGlmIHByb2dyYW0gd2FzIGxvYWRlZCBzdWNjZXNzZnVsbHksIGZhbHNlIGlmIHByb2dyYW0gd2FzIGFscmVhZHkgbG9hZGVkXG4gICAqL1xuICBzdGF0aWMgYXN5bmMgbG9hZChjb25uZWN0aW9uLCBwYXllciwgcHJvZ3JhbSwgcHJvZ3JhbUlkLCBkYXRhKSB7XG4gICAge1xuICAgICAgY29uc3QgYmFsYW5jZU5lZWRlZCA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uKGRhdGEubGVuZ3RoKTtcblxuICAgICAgLy8gRmV0Y2ggcHJvZ3JhbSBhY2NvdW50IGluZm8gdG8gY2hlY2sgaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBjcmVhdGVkXG4gICAgICBjb25zdCBwcm9ncmFtSW5mbyA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0QWNjb3VudEluZm8ocHJvZ3JhbS5wdWJsaWNLZXksICdjb25maXJtZWQnKTtcbiAgICAgIGxldCB0cmFuc2FjdGlvbiA9IG51bGw7XG4gICAgICBpZiAocHJvZ3JhbUluZm8gIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHByb2dyYW1JbmZvLmV4ZWN1dGFibGUpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdQcm9ncmFtIGxvYWQgZmFpbGVkLCBhY2NvdW50IGlzIGFscmVhZHkgZXhlY3V0YWJsZScpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvZ3JhbUluZm8uZGF0YS5sZW5ndGggIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbiB8fCBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5hbGxvY2F0ZSh7XG4gICAgICAgICAgICBhY2NvdW50UHVia2V5OiBwcm9ncmFtLnB1YmxpY0tleSxcbiAgICAgICAgICAgIHNwYWNlOiBkYXRhLmxlbmd0aFxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXByb2dyYW1JbmZvLm93bmVyLmVxdWFscyhwcm9ncmFtSWQpKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbiB8fCBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgICAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5hc3NpZ24oe1xuICAgICAgICAgICAgYWNjb3VudFB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgICBwcm9ncmFtSWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb2dyYW1JbmZvLmxhbXBvcnRzIDwgYmFsYW5jZU5lZWRlZCkge1xuICAgICAgICAgIHRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24gfHwgbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0udHJhbnNmZXIoe1xuICAgICAgICAgICAgZnJvbVB1YmtleTogcGF5ZXIucHVibGljS2V5LFxuICAgICAgICAgICAgdG9QdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgICAgbGFtcG9ydHM6IGJhbGFuY2VOZWVkZWQgLSBwcm9ncmFtSW5mby5sYW1wb3J0c1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgICAgICBmcm9tUHVia2V5OiBwYXllci5wdWJsaWNLZXksXG4gICAgICAgICAgbmV3QWNjb3VudFB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgbGFtcG9ydHM6IGJhbGFuY2VOZWVkZWQgPiAwID8gYmFsYW5jZU5lZWRlZCA6IDEsXG4gICAgICAgICAgc3BhY2U6IGRhdGEubGVuZ3RoLFxuICAgICAgICAgIHByb2dyYW1JZFxuICAgICAgICB9KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBhY2NvdW50IGlzIGFscmVhZHkgY3JlYXRlZCBjb3JyZWN0bHksIHNraXAgdGhpcyBzdGVwXG4gICAgICAvLyBhbmQgcHJvY2VlZCBkaXJlY3RseSB0byBsb2FkaW5nIGluc3RydWN0aW9uc1xuICAgICAgaWYgKHRyYW5zYWN0aW9uICE9PSBudWxsKSB7XG4gICAgICAgIGF3YWl0IHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oY29ubmVjdGlvbiwgdHJhbnNhY3Rpb24sIFtwYXllciwgcHJvZ3JhbV0sIHtcbiAgICAgICAgICBjb21taXRtZW50OiAnY29uZmlybWVkJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgZGF0YUxheW91dCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC51MzIoJ29mZnNldCcpLCBCdWZmZXJMYXlvdXQudTMyKCdieXRlc0xlbmd0aCcpLCBCdWZmZXJMYXlvdXQudTMyKCdieXRlc0xlbmd0aFBhZGRpbmcnKSwgQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQudTgoJ2J5dGUnKSwgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSwgJ2J5dGVzJyldKTtcbiAgICBjb25zdCBjaHVua1NpemUgPSBMb2FkZXIuY2h1bmtTaXplO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGxldCBhcnJheSA9IGRhdGE7XG4gICAgbGV0IHRyYW5zYWN0aW9ucyA9IFtdO1xuICAgIHdoaWxlIChhcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCBieXRlcyA9IGFycmF5LnNsaWNlKDAsIGNodW5rU2l6ZSk7XG4gICAgICBjb25zdCBkYXRhID0gQnVmZmVyLmFsbG9jKGNodW5rU2l6ZSArIDE2KTtcbiAgICAgIGRhdGFMYXlvdXQuZW5jb2RlKHtcbiAgICAgICAgaW5zdHJ1Y3Rpb246IDAsXG4gICAgICAgIC8vIExvYWQgaW5zdHJ1Y3Rpb25cbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICBieXRlczogYnl0ZXMsXG4gICAgICAgIGJ5dGVzTGVuZ3RoOiAwLFxuICAgICAgICBieXRlc0xlbmd0aFBhZGRpbmc6IDBcbiAgICAgIH0sIGRhdGEpO1xuICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAgICBrZXlzOiBbe1xuICAgICAgICAgIHB1YmtleTogcHJvZ3JhbS5wdWJsaWNLZXksXG4gICAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgICAgICB9XSxcbiAgICAgICAgcHJvZ3JhbUlkLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICAgIHRyYW5zYWN0aW9ucy5wdXNoKHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24oY29ubmVjdGlvbiwgdHJhbnNhY3Rpb24sIFtwYXllciwgcHJvZ3JhbV0sIHtcbiAgICAgICAgY29tbWl0bWVudDogJ2NvbmZpcm1lZCdcbiAgICAgIH0pKTtcblxuICAgICAgLy8gRGVsYXkgYmV0d2VlbiBzZW5kcyBpbiBhbiBhdHRlbXB0IHRvIHJlZHVjZSByYXRlIGxpbWl0IGVycm9yc1xuICAgICAgaWYgKGNvbm5lY3Rpb24uX3JwY0VuZHBvaW50LmluY2x1ZGVzKCdzb2xhbmEuY29tJykpIHtcbiAgICAgICAgY29uc3QgUkVRVUVTVFNfUEVSX1NFQ09ORCA9IDQ7XG4gICAgICAgIGF3YWl0IHNsZWVwKDEwMDAgLyBSRVFVRVNUU19QRVJfU0VDT05EKTtcbiAgICAgIH1cbiAgICAgIG9mZnNldCArPSBjaHVua1NpemU7XG4gICAgICBhcnJheSA9IGFycmF5LnNsaWNlKGNodW5rU2l6ZSk7XG4gICAgfVxuICAgIGF3YWl0IFByb21pc2UuYWxsKHRyYW5zYWN0aW9ucyk7XG5cbiAgICAvLyBGaW5hbGl6ZSB0aGUgYWNjb3VudCBsb2FkZWQgd2l0aCBwcm9ncmFtIGRhdGEgZm9yIGV4ZWN1dGlvblxuICAgIHtcbiAgICAgIGNvbnN0IGRhdGFMYXlvdXQgPSBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpXSk7XG4gICAgICBjb25zdCBkYXRhID0gQnVmZmVyLmFsbG9jKGRhdGFMYXlvdXQuc3Bhbik7XG4gICAgICBkYXRhTGF5b3V0LmVuY29kZSh7XG4gICAgICAgIGluc3RydWN0aW9uOiAxIC8vIEZpbmFsaXplIGluc3RydWN0aW9uXG4gICAgICB9LCBkYXRhKTtcbiAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgICAga2V5czogW3tcbiAgICAgICAgICBwdWJrZXk6IHByb2dyYW0ucHVibGljS2V5LFxuICAgICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgICAgfSwge1xuICAgICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9XSxcbiAgICAgICAgcHJvZ3JhbUlkLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRlcGxveUNvbW1pdG1lbnQgPSAncHJvY2Vzc2VkJztcbiAgICAgIGNvbnN0IGZpbmFsaXplU2lnbmF0dXJlID0gYXdhaXQgY29ubmVjdGlvbi5zZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIFtwYXllciwgcHJvZ3JhbV0sIHtcbiAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogZGVwbG95Q29tbWl0bWVudFxuICAgICAgfSk7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbnRleHQsXG4gICAgICAgIHZhbHVlXG4gICAgICB9ID0gYXdhaXQgY29ubmVjdGlvbi5jb25maXJtVHJhbnNhY3Rpb24oe1xuICAgICAgICBzaWduYXR1cmU6IGZpbmFsaXplU2lnbmF0dXJlLFxuICAgICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodDogdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHQsXG4gICAgICAgIGJsb2NraGFzaDogdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoXG4gICAgICB9LCBkZXBsb3lDb21taXRtZW50KTtcbiAgICAgIGlmICh2YWx1ZS5lcnIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUcmFuc2FjdGlvbiAke2ZpbmFsaXplU2lnbmF0dXJlfSBmYWlsZWQgKCR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSlgKTtcbiAgICAgIH1cbiAgICAgIC8vIFdlIHByZXZlbnQgcHJvZ3JhbXMgZnJvbSBiZWluZyB1c2FibGUgdW50aWwgdGhlIHNsb3QgYWZ0ZXIgdGhlaXIgZGVwbG95bWVudC5cbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL3B1bGwvMjk2NTRcbiAgICAgIHdoaWxlICh0cnVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICApIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBjdXJyZW50U2xvdCA9IGF3YWl0IGNvbm5lY3Rpb24uZ2V0U2xvdCh7XG4gICAgICAgICAgICBjb21taXRtZW50OiBkZXBsb3lDb21taXRtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaWYgKGN1cnJlbnRTbG90ID4gY29udGV4dC5zbG90KSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICAgIC8qIGVtcHR5ICovXG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIE1hdGgucm91bmQoTVNfUEVSX1NMT1QgLyAyKSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHN1Y2Nlc3NcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuTG9hZGVyLmNodW5rU2l6ZSA9IENIVU5LX1NJWkU7XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuMTcuMjAuXG4gKi9cbmNvbnN0IEJQRl9MT0FERVJfUFJPR1JBTV9JRCA9IG5ldyBQdWJsaWNLZXkoJ0JQRkxvYWRlcjIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCBhIHByb2dyYW0gbG9hZGVyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuMTcuMjAuXG4gKi9cbmNsYXNzIEJwZkxvYWRlciB7XG4gIC8qKlxuICAgKiBNaW5pbXVtIG51bWJlciBvZiBzaWduYXR1cmVzIHJlcXVpcmVkIHRvIGxvYWQgYSBwcm9ncmFtIG5vdCBpbmNsdWRpbmdcbiAgICogcmV0cmllc1xuICAgKlxuICAgKiBDYW4gYmUgdXNlZCB0byBjYWxjdWxhdGUgdHJhbnNhY3Rpb24gZmVlc1xuICAgKi9cbiAgc3RhdGljIGdldE1pbk51bVNpZ25hdHVyZXMoZGF0YUxlbmd0aCkge1xuICAgIHJldHVybiBMb2FkZXIuZ2V0TWluTnVtU2lnbmF0dXJlcyhkYXRhTGVuZ3RoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2FkIGEgU0JGIHByb2dyYW1cbiAgICpcbiAgICogQHBhcmFtIGNvbm5lY3Rpb24gVGhlIGNvbm5lY3Rpb24gdG8gdXNlXG4gICAqIEBwYXJhbSBwYXllciBBY2NvdW50IHRoYXQgd2lsbCBwYXkgcHJvZ3JhbSBsb2FkaW5nIGZlZXNcbiAgICogQHBhcmFtIHByb2dyYW0gQWNjb3VudCB0byBsb2FkIHRoZSBwcm9ncmFtIGludG9cbiAgICogQHBhcmFtIGVsZiBUaGUgZW50aXJlIEVMRiBjb250YWluaW5nIHRoZSBTQkYgcHJvZ3JhbVxuICAgKiBAcGFyYW0gbG9hZGVyUHJvZ3JhbUlkIFRoZSBwcm9ncmFtIGlkIG9mIHRoZSBCUEYgbG9hZGVyIHRvIHVzZVxuICAgKiBAcmV0dXJuIHRydWUgaWYgcHJvZ3JhbSB3YXMgbG9hZGVkIHN1Y2Nlc3NmdWxseSwgZmFsc2UgaWYgcHJvZ3JhbSB3YXMgYWxyZWFkeSBsb2FkZWRcbiAgICovXG4gIHN0YXRpYyBsb2FkKGNvbm5lY3Rpb24sIHBheWVyLCBwcm9ncmFtLCBlbGYsIGxvYWRlclByb2dyYW1JZCkge1xuICAgIHJldHVybiBMb2FkZXIubG9hZChjb25uZWN0aW9uLCBwYXllciwgcHJvZ3JhbSwgbG9hZGVyUHJvZ3JhbUlkLCBlbGYpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbnZhciBvYmpUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG52YXIgb2JqS2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uKG9iaikge1xuXHRcdHZhciBrZXlzID0gW107XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiBvYmopIHtcblx0XHRcdGtleXMucHVzaChuYW1lKTtcblx0XHR9XG5cdFx0cmV0dXJuIGtleXM7XG5cdH07XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeSh2YWwsIGlzQXJyYXlQcm9wKSB7XG5cdHZhciBpLCBtYXgsIHN0ciwga2V5cywga2V5LCBwcm9wVmFsLCB0b1N0cjtcblx0aWYgKHZhbCA9PT0gdHJ1ZSkge1xuXHRcdHJldHVybiBcInRydWVcIjtcblx0fVxuXHRpZiAodmFsID09PSBmYWxzZSkge1xuXHRcdHJldHVybiBcImZhbHNlXCI7XG5cdH1cblx0c3dpdGNoICh0eXBlb2YgdmFsKSB7XG5cdFx0Y2FzZSBcIm9iamVjdFwiOlxuXHRcdFx0aWYgKHZhbCA9PT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0gZWxzZSBpZiAodmFsLnRvSlNPTiAmJiB0eXBlb2YgdmFsLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiKSB7XG5cdFx0XHRcdHJldHVybiBzdHJpbmdpZnkodmFsLnRvSlNPTigpLCBpc0FycmF5UHJvcCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0b1N0ciA9IG9ialRvU3RyaW5nLmNhbGwodmFsKTtcblx0XHRcdFx0aWYgKHRvU3RyID09PSBcIltvYmplY3QgQXJyYXldXCIpIHtcblx0XHRcdFx0XHRzdHIgPSAnWyc7XG5cdFx0XHRcdFx0bWF4ID0gdmFsLmxlbmd0aCAtIDE7XG5cdFx0XHRcdFx0Zm9yKGkgPSAwOyBpIDwgbWF4OyBpKyspIHtcblx0XHRcdFx0XHRcdHN0ciArPSBzdHJpbmdpZnkodmFsW2ldLCB0cnVlKSArICcsJztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKG1heCA+IC0xKSB7XG5cdFx0XHRcdFx0XHRzdHIgKz0gc3RyaW5naWZ5KHZhbFtpXSwgdHJ1ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBzdHIgKyAnXSc7XG5cdFx0XHRcdH0gZWxzZSBpZiAodG9TdHIgPT09IFwiW29iamVjdCBPYmplY3RdXCIpIHtcblx0XHRcdFx0XHQvLyBvbmx5IG9iamVjdCBpcyBsZWZ0XG5cdFx0XHRcdFx0a2V5cyA9IG9iaktleXModmFsKS5zb3J0KCk7XG5cdFx0XHRcdFx0bWF4ID0ga2V5cy5sZW5ndGg7XG5cdFx0XHRcdFx0c3RyID0gXCJcIjtcblx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoaSA8IG1heCkge1xuXHRcdFx0XHRcdFx0a2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0XHRcdHByb3BWYWwgPSBzdHJpbmdpZnkodmFsW2tleV0sIGZhbHNlKTtcblx0XHRcdFx0XHRcdGlmIChwcm9wVmFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHN0cikge1xuXHRcdFx0XHRcdFx0XHRcdHN0ciArPSAnLCc7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0c3RyICs9IEpTT04uc3RyaW5naWZ5KGtleSkgKyAnOicgKyBwcm9wVmFsO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aSsrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gJ3snICsgc3RyICsgJ30nO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0Y2FzZSBcImZ1bmN0aW9uXCI6XG5cdFx0Y2FzZSBcInVuZGVmaW5lZFwiOlxuXHRcdFx0cmV0dXJuIGlzQXJyYXlQcm9wID8gbnVsbCA6IHVuZGVmaW5lZDtcblx0XHRjYXNlIFwic3RyaW5nXCI6XG5cdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsKTtcblx0XHRkZWZhdWx0OlxuXHRcdFx0cmV0dXJuIGlzRmluaXRlKHZhbCkgPyB2YWwgOiBudWxsO1xuXHR9XG59XG5cbnZhciBmYXN0U3RhYmxlU3RyaW5naWZ5ID0gZnVuY3Rpb24odmFsKSB7XG5cdHZhciByZXR1cm5WYWwgPSBzdHJpbmdpZnkodmFsLCBmYWxzZSk7XG5cdGlmIChyZXR1cm5WYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiAnJysgcmV0dXJuVmFsO1xuXHR9XG59O1xuXG52YXIgZmFzdFN0YWJsZVN0cmluZ2lmeSQxID0gLypAX19QVVJFX18qL2dldERlZmF1bHRFeHBvcnRGcm9tQ2pzKGZhc3RTdGFibGVTdHJpbmdpZnkpO1xuXG5jb25zdCBNSU5JTVVNX1NMT1RfUEVSX0VQT0NIID0gMzI7XG5cbi8vIFJldHVybnMgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBpbiB0aGUgYmluYXJ5IHJlcHJlc2VudGF0aW9uIG9mIHNlbGYuXG5mdW5jdGlvbiB0cmFpbGluZ1plcm9zKG4pIHtcbiAgbGV0IHRyYWlsaW5nWmVyb3MgPSAwO1xuICB3aGlsZSAobiA+IDEpIHtcbiAgICBuIC89IDI7XG4gICAgdHJhaWxpbmdaZXJvcysrO1xuICB9XG4gIHJldHVybiB0cmFpbGluZ1plcm9zO1xufVxuXG4vLyBSZXR1cm5zIHRoZSBzbWFsbGVzdCBwb3dlciBvZiB0d28gZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIG5cbmZ1bmN0aW9uIG5leHRQb3dlck9mVHdvKG4pIHtcbiAgaWYgKG4gPT09IDApIHJldHVybiAxO1xuICBuLS07XG4gIG4gfD0gbiA+PiAxO1xuICBuIHw9IG4gPj4gMjtcbiAgbiB8PSBuID4+IDQ7XG4gIG4gfD0gbiA+PiA4O1xuICBuIHw9IG4gPj4gMTY7XG4gIG4gfD0gbiA+PiAzMjtcbiAgcmV0dXJuIG4gKyAxO1xufVxuXG4vKipcbiAqIEVwb2NoIHNjaGVkdWxlXG4gKiAoc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL3Rlcm1pbm9sb2d5I2Vwb2NoKVxuICogQ2FuIGJlIHJldHJpZXZlZCB3aXRoIHRoZSB7QGxpbmsgQ29ubmVjdGlvbi5nZXRFcG9jaFNjaGVkdWxlfSBtZXRob2RcbiAqL1xuY2xhc3MgRXBvY2hTY2hlZHVsZSB7XG4gIGNvbnN0cnVjdG9yKHNsb3RzUGVyRXBvY2gsIGxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCwgd2FybXVwLCBmaXJzdE5vcm1hbEVwb2NoLCBmaXJzdE5vcm1hbFNsb3QpIHtcbiAgICAvKiogVGhlIG1heGltdW0gbnVtYmVyIG9mIHNsb3RzIGluIGVhY2ggZXBvY2ggKi9cbiAgICB0aGlzLnNsb3RzUGVyRXBvY2ggPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBudW1iZXIgb2Ygc2xvdHMgYmVmb3JlIGJlZ2lubmluZyBvZiBhbiBlcG9jaCB0byBjYWxjdWxhdGUgYSBsZWFkZXIgc2NoZWR1bGUgZm9yIHRoYXQgZXBvY2ggKi9cbiAgICB0aGlzLmxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCA9IHZvaWQgMDtcbiAgICAvKiogSW5kaWNhdGVzIHdoZXRoZXIgZXBvY2hzIHN0YXJ0IHNob3J0IGFuZCBncm93ICovXG4gICAgdGhpcy53YXJtdXAgPSB2b2lkIDA7XG4gICAgLyoqIFRoZSBmaXJzdCBlcG9jaCB3aXRoIGBzbG90c1BlckVwb2NoYCBzbG90cyAqL1xuICAgIHRoaXMuZmlyc3ROb3JtYWxFcG9jaCA9IHZvaWQgMDtcbiAgICAvKiogVGhlIGZpcnN0IHNsb3Qgb2YgYGZpcnN0Tm9ybWFsRXBvY2hgICovXG4gICAgdGhpcy5maXJzdE5vcm1hbFNsb3QgPSB2b2lkIDA7XG4gICAgdGhpcy5zbG90c1BlckVwb2NoID0gc2xvdHNQZXJFcG9jaDtcbiAgICB0aGlzLmxlYWRlclNjaGVkdWxlU2xvdE9mZnNldCA9IGxlYWRlclNjaGVkdWxlU2xvdE9mZnNldDtcbiAgICB0aGlzLndhcm11cCA9IHdhcm11cDtcbiAgICB0aGlzLmZpcnN0Tm9ybWFsRXBvY2ggPSBmaXJzdE5vcm1hbEVwb2NoO1xuICAgIHRoaXMuZmlyc3ROb3JtYWxTbG90ID0gZmlyc3ROb3JtYWxTbG90O1xuICB9XG4gIGdldEVwb2NoKHNsb3QpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRFcG9jaEFuZFNsb3RJbmRleChzbG90KVswXTtcbiAgfVxuICBnZXRFcG9jaEFuZFNsb3RJbmRleChzbG90KSB7XG4gICAgaWYgKHNsb3QgPCB0aGlzLmZpcnN0Tm9ybWFsU2xvdCkge1xuICAgICAgY29uc3QgZXBvY2ggPSB0cmFpbGluZ1plcm9zKG5leHRQb3dlck9mVHdvKHNsb3QgKyBNSU5JTVVNX1NMT1RfUEVSX0VQT0NIICsgMSkpIC0gdHJhaWxpbmdaZXJvcyhNSU5JTVVNX1NMT1RfUEVSX0VQT0NIKSAtIDE7XG4gICAgICBjb25zdCBlcG9jaExlbiA9IHRoaXMuZ2V0U2xvdHNJbkVwb2NoKGVwb2NoKTtcbiAgICAgIGNvbnN0IHNsb3RJbmRleCA9IHNsb3QgLSAoZXBvY2hMZW4gLSBNSU5JTVVNX1NMT1RfUEVSX0VQT0NIKTtcbiAgICAgIHJldHVybiBbZXBvY2gsIHNsb3RJbmRleF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5vcm1hbFNsb3RJbmRleCA9IHNsb3QgLSB0aGlzLmZpcnN0Tm9ybWFsU2xvdDtcbiAgICAgIGNvbnN0IG5vcm1hbEVwb2NoSW5kZXggPSBNYXRoLmZsb29yKG5vcm1hbFNsb3RJbmRleCAvIHRoaXMuc2xvdHNQZXJFcG9jaCk7XG4gICAgICBjb25zdCBlcG9jaCA9IHRoaXMuZmlyc3ROb3JtYWxFcG9jaCArIG5vcm1hbEVwb2NoSW5kZXg7XG4gICAgICBjb25zdCBzbG90SW5kZXggPSBub3JtYWxTbG90SW5kZXggJSB0aGlzLnNsb3RzUGVyRXBvY2g7XG4gICAgICByZXR1cm4gW2Vwb2NoLCBzbG90SW5kZXhdO1xuICAgIH1cbiAgfVxuICBnZXRGaXJzdFNsb3RJbkVwb2NoKGVwb2NoKSB7XG4gICAgaWYgKGVwb2NoIDw9IHRoaXMuZmlyc3ROb3JtYWxFcG9jaCkge1xuICAgICAgcmV0dXJuIChNYXRoLnBvdygyLCBlcG9jaCkgLSAxKSAqIE1JTklNVU1fU0xPVF9QRVJfRVBPQ0g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAoZXBvY2ggLSB0aGlzLmZpcnN0Tm9ybWFsRXBvY2gpICogdGhpcy5zbG90c1BlckVwb2NoICsgdGhpcy5maXJzdE5vcm1hbFNsb3Q7XG4gICAgfVxuICB9XG4gIGdldExhc3RTbG90SW5FcG9jaChlcG9jaCkge1xuICAgIHJldHVybiB0aGlzLmdldEZpcnN0U2xvdEluRXBvY2goZXBvY2gpICsgdGhpcy5nZXRTbG90c0luRXBvY2goZXBvY2gpIC0gMTtcbiAgfVxuICBnZXRTbG90c0luRXBvY2goZXBvY2gpIHtcbiAgICBpZiAoZXBvY2ggPCB0aGlzLmZpcnN0Tm9ybWFsRXBvY2gpIHtcbiAgICAgIHJldHVybiBNYXRoLnBvdygyLCBlcG9jaCArIHRyYWlsaW5nWmVyb3MoTUlOSU1VTV9TTE9UX1BFUl9FUE9DSCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5zbG90c1BlckVwb2NoO1xuICAgIH1cbiAgfVxufVxuXG5jbGFzcyBTZW5kVHJhbnNhY3Rpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgbG9ncykge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMubG9ncyA9IHZvaWQgMDtcbiAgICB0aGlzLmxvZ3MgPSBsb2dzO1xuICB9XG59XG5cbi8vIEtlZXAgaW4gc3luYyB3aXRoIGNsaWVudC9zcmMvcnBjX2N1c3RvbV9lcnJvcnMucnNcbi8vIFR5cGVzY3JpcHQgYGVudW1zYCB0aHdhcnQgdHJlZS1zaGFraW5nLiBTZWUgaHR0cHM6Ly9iYXJnc3Rlbi5vcmcvanN0cy9lbnVtcy9cbmNvbnN0IFNvbGFuYUpTT05SUENFcnJvckNvZGUgPSB7XG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9CTE9DS19DTEVBTkVEX1VQOiAtMzIwMDEsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9TRU5EX1RSQU5TQUNUSU9OX1BSRUZMSUdIVF9GQUlMVVJFOiAtMzIwMDIsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9TSUdOQVRVUkVfVkVSSUZJQ0FUSU9OX0ZBSUxVUkU6IC0zMjAwMyxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX05PVF9BVkFJTEFCTEU6IC0zMjAwNCxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX05PREVfVU5IRUFMVEhZOiAtMzIwMDUsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9UUkFOU0FDVElPTl9QUkVDT01QSUxFX1ZFUklGSUNBVElPTl9GQUlMVVJFOiAtMzIwMDYsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9TTE9UX1NLSVBQRUQ6IC0zMjAwNyxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX05PX1NOQVBTSE9UOiAtMzIwMDgsXG4gIEpTT05fUlBDX1NFUlZFUl9FUlJPUl9MT05HX1RFUk1fU1RPUkFHRV9TTE9UX1NLSVBQRUQ6IC0zMjAwOSxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX0tFWV9FWENMVURFRF9GUk9NX1NFQ09OREFSWV9JTkRFWDogLTMyMDEwLFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVFJBTlNBQ1RJT05fSElTVE9SWV9OT1RfQVZBSUxBQkxFOiAtMzIwMTEsXG4gIEpTT05fUlBDX1NDQU5fRVJST1I6IC0zMjAxMixcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX1RSQU5TQUNUSU9OX1NJR05BVFVSRV9MRU5fTUlTTUFUQ0g6IC0zMjAxMyxcbiAgSlNPTl9SUENfU0VSVkVSX0VSUk9SX0JMT0NLX1NUQVRVU19OT1RfQVZBSUxBQkxFX1lFVDogLTMyMDE0LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfVU5TVVBQT1JURURfVFJBTlNBQ1RJT05fVkVSU0lPTjogLTMyMDE1LFxuICBKU09OX1JQQ19TRVJWRVJfRVJST1JfTUlOX0NPTlRFWFRfU0xPVF9OT1RfUkVBQ0hFRDogLTMyMDE2XG59O1xuY2xhc3MgU29sYW5hSlNPTlJQQ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29kZSxcbiAgICBtZXNzYWdlLFxuICAgIGRhdGFcbiAgfSwgY3VzdG9tTWVzc2FnZSkge1xuICAgIHN1cGVyKGN1c3RvbU1lc3NhZ2UgIT0gbnVsbCA/IGAke2N1c3RvbU1lc3NhZ2V9OiAke21lc3NhZ2V9YCA6IG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRhdGEgPSB2b2lkIDA7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMubmFtZSA9ICdTb2xhbmFKU09OUlBDRXJyb3InO1xuICB9XG59XG5cbnZhciBmZXRjaEltcGwgPSBnbG9iYWxUaGlzLmZldGNoO1xuXG5jbGFzcyBScGNXZWJTb2NrZXRDbGllbnQgZXh0ZW5kcyBScGNXZWJTb2NrZXRDb21tb25DbGllbnQge1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBvcHRpb25zLCBnZW5lcmF0ZV9yZXF1ZXN0X2lkKSB7XG4gICAgY29uc3Qgd2ViU29ja2V0RmFjdG9yeSA9IHVybCA9PiB7XG4gICAgICBjb25zdCBycGMgPSBjcmVhdGVScGModXJsLCB7XG4gICAgICAgIGF1dG9jb25uZWN0OiB0cnVlLFxuICAgICAgICBtYXhfcmVjb25uZWN0czogNSxcbiAgICAgICAgcmVjb25uZWN0OiB0cnVlLFxuICAgICAgICByZWNvbm5lY3RfaW50ZXJ2YWw6IDEwMDAsXG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgaWYgKCdzb2NrZXQnIGluIHJwYykge1xuICAgICAgICB0aGlzLnVuZGVybHlpbmdTb2NrZXQgPSBycGMuc29ja2V0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy51bmRlcmx5aW5nU29ja2V0ID0gcnBjO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJwYztcbiAgICB9O1xuICAgIHN1cGVyKHdlYlNvY2tldEZhY3RvcnksIGFkZHJlc3MsIG9wdGlvbnMsIGdlbmVyYXRlX3JlcXVlc3RfaWQpO1xuICAgIHRoaXMudW5kZXJseWluZ1NvY2tldCA9IHZvaWQgMDtcbiAgfVxuICBjYWxsKC4uLmFyZ3MpIHtcbiAgICBjb25zdCByZWFkeVN0YXRlID0gdGhpcy51bmRlcmx5aW5nU29ja2V0Py5yZWFkeVN0YXRlO1xuICAgIGlmIChyZWFkeVN0YXRlID09PSAxIC8qIFdlYlNvY2tldC5PUEVOICovKSB7XG4gICAgICByZXR1cm4gc3VwZXIuY2FsbCguLi5hcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignVHJpZWQgdG8gY2FsbCBhIEpTT04tUlBDIG1ldGhvZCBgJyArIGFyZ3NbMF0gKyAnYCBidXQgdGhlIHNvY2tldCB3YXMgbm90IGBDT05ORUNUSU5HYCBvciBgT1BFTmAgKGByZWFkeVN0YXRlYCB3YXMgJyArIHJlYWR5U3RhdGUgKyAnKScpKTtcbiAgfVxuICBub3RpZnkoLi4uYXJncykge1xuICAgIGNvbnN0IHJlYWR5U3RhdGUgPSB0aGlzLnVuZGVybHlpbmdTb2NrZXQ/LnJlYWR5U3RhdGU7XG4gICAgaWYgKHJlYWR5U3RhdGUgPT09IDEgLyogV2ViU29ja2V0Lk9QRU4gKi8pIHtcbiAgICAgIHJldHVybiBzdXBlci5ub3RpZnkoLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ1RyaWVkIHRvIHNlbmQgYSBKU09OLVJQQyBub3RpZmljYXRpb24gYCcgKyBhcmdzWzBdICsgJ2AgYnV0IHRoZSBzb2NrZXQgd2FzIG5vdCBgQ09OTkVDVElOR2Agb3IgYE9QRU5gIChgcmVhZHlTdGF0ZWAgd2FzICcgKyByZWFkeVN0YXRlICsgJyknKSk7XG4gIH1cbn1cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIERlY29kZSBhY2NvdW50IGRhdGEgYnVmZmVyIHVzaW5nIGFuIEFjY291bnRUeXBlXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZGVjb2RlRGF0YSh0eXBlLCBkYXRhKSB7XG4gIGxldCBkZWNvZGVkO1xuICB0cnkge1xuICAgIGRlY29kZWQgPSB0eXBlLmxheW91dC5kZWNvZGUoZGF0YSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgJyArIGVycik7XG4gIH1cbiAgaWYgKGRlY29kZWQudHlwZUluZGV4ICE9PSB0eXBlLmluZGV4KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGFjY291bnQgZGF0YTsgYWNjb3VudCB0eXBlIG1pc21hdGNoICR7ZGVjb2RlZC50eXBlSW5kZXh9ICE9ICR7dHlwZS5pbmRleH1gKTtcbiAgfVxuICByZXR1cm4gZGVjb2RlZDtcbn1cblxuLy8vIFRoZSBzZXJpYWxpemVkIHNpemUgb2YgbG9va3VwIHRhYmxlIG1ldGFkYXRhXG5jb25zdCBMT09LVVBfVEFCTEVfTUVUQV9TSVpFID0gNTY7XG5jbGFzcyBBZGRyZXNzTG9va3VwVGFibGVBY2NvdW50IHtcbiAgY29uc3RydWN0b3IoYXJncykge1xuICAgIHRoaXMua2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuc3RhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBhcmdzLmtleTtcbiAgICB0aGlzLnN0YXRlID0gYXJncy5zdGF0ZTtcbiAgfVxuICBpc0FjdGl2ZSgpIHtcbiAgICBjb25zdCBVNjRfTUFYID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKTtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZS5kZWFjdGl2YXRpb25TbG90ID09PSBVNjRfTUFYO1xuICB9XG4gIHN0YXRpYyBkZXNlcmlhbGl6ZShhY2NvdW50RGF0YSkge1xuICAgIGNvbnN0IG1ldGEgPSBkZWNvZGVEYXRhKExvb2t1cFRhYmxlTWV0YUxheW91dCwgYWNjb3VudERhdGEpO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRBZGRyZXNzZXNMZW4gPSBhY2NvdW50RGF0YS5sZW5ndGggLSBMT09LVVBfVEFCTEVfTUVUQV9TSVpFO1xuICAgIGFzc2VydChzZXJpYWxpemVkQWRkcmVzc2VzTGVuID49IDAsICdsb29rdXAgdGFibGUgaXMgaW52YWxpZCcpO1xuICAgIGFzc2VydChzZXJpYWxpemVkQWRkcmVzc2VzTGVuICUgMzIgPT09IDAsICdsb29rdXAgdGFibGUgaXMgaW52YWxpZCcpO1xuICAgIGNvbnN0IG51bVNlcmlhbGl6ZWRBZGRyZXNzZXMgPSBzZXJpYWxpemVkQWRkcmVzc2VzTGVuIC8gMzI7XG4gICAgY29uc3Qge1xuICAgICAgYWRkcmVzc2VzXG4gICAgfSA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCksIG51bVNlcmlhbGl6ZWRBZGRyZXNzZXMsICdhZGRyZXNzZXMnKV0pLmRlY29kZShhY2NvdW50RGF0YS5zbGljZShMT09LVVBfVEFCTEVfTUVUQV9TSVpFKSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRlYWN0aXZhdGlvblNsb3Q6IG1ldGEuZGVhY3RpdmF0aW9uU2xvdCxcbiAgICAgIGxhc3RFeHRlbmRlZFNsb3Q6IG1ldGEubGFzdEV4dGVuZGVkU2xvdCxcbiAgICAgIGxhc3RFeHRlbmRlZFNsb3RTdGFydEluZGV4OiBtZXRhLmxhc3RFeHRlbmRlZFN0YXJ0SW5kZXgsXG4gICAgICBhdXRob3JpdHk6IG1ldGEuYXV0aG9yaXR5Lmxlbmd0aCAhPT0gMCA/IG5ldyBQdWJsaWNLZXkobWV0YS5hdXRob3JpdHlbMF0pIDogdW5kZWZpbmVkLFxuICAgICAgYWRkcmVzc2VzOiBhZGRyZXNzZXMubWFwKGFkZHJlc3MgPT4gbmV3IFB1YmxpY0tleShhZGRyZXNzKSlcbiAgICB9O1xuICB9XG59XG5jb25zdCBMb29rdXBUYWJsZU1ldGFMYXlvdXQgPSB7XG4gIGluZGV4OiAxLFxuICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ3R5cGVJbmRleCcpLCB1NjQoJ2RlYWN0aXZhdGlvblNsb3QnKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ2xhc3RFeHRlbmRlZFNsb3QnKSwgQnVmZmVyTGF5b3V0LnU4KCdsYXN0RXh0ZW5kZWRTdGFydEluZGV4JyksIEJ1ZmZlckxheW91dC51OCgpLFxuICAvLyBvcHRpb25cbiAgQnVmZmVyTGF5b3V0LnNlcShwdWJsaWNLZXkoKSwgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTgoKSwgLTEpLCAnYXV0aG9yaXR5JyldKVxufTtcblxuY29uc3QgVVJMX1JFID0gL15bXjpdKzpcXC9cXC8oW146W10rfFxcW1teXFxdXStcXF0pKDpcXGQrKT8oLiopL2k7XG5mdW5jdGlvbiBtYWtlV2Vic29ja2V0VXJsKGVuZHBvaW50KSB7XG4gIGNvbnN0IG1hdGNoZXMgPSBlbmRwb2ludC5tYXRjaChVUkxfUkUpO1xuICBpZiAobWF0Y2hlcyA9PSBudWxsKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKGBGYWlsZWQgdG8gdmFsaWRhdGUgZW5kcG9pbnQgVVJMIFxcYCR7ZW5kcG9pbnR9XFxgYCk7XG4gIH1cbiAgY29uc3QgW18sXG4gIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGhvc3Rpc2gsIHBvcnRXaXRoQ29sb24sIHJlc3RdID0gbWF0Y2hlcztcbiAgY29uc3QgcHJvdG9jb2wgPSBlbmRwb2ludC5zdGFydHNXaXRoKCdodHRwczonKSA/ICd3c3M6JyA6ICd3czonO1xuICBjb25zdCBzdGFydFBvcnQgPSBwb3J0V2l0aENvbG9uID09IG51bGwgPyBudWxsIDogcGFyc2VJbnQocG9ydFdpdGhDb2xvbi5zbGljZSgxKSwgMTApO1xuICBjb25zdCB3ZWJzb2NrZXRQb3J0ID1cbiAgLy8gT25seSBzaGlmdCB0aGUgcG9ydCBieSArMSBhcyBhIGNvbnZlbnRpb24gZm9yIHdzKHMpIG9ubHkgaWYgZ2l2ZW4gZW5kcG9pbnRcbiAgLy8gaXMgZXhwbGljaXRseSBzcGVjaWZ5aW5nIHRoZSBlbmRwb2ludCBwb3J0IChIVFRQLWJhc2VkIFJQQyksIGFzc3VtaW5nXG4gIC8vIHdlJ3JlIGRpcmVjdGx5IHRyeWluZyB0byBjb25uZWN0IHRvIHNvbGFuYS12YWxpZGF0b3IncyB3cyBsaXN0ZW5pbmcgcG9ydC5cbiAgLy8gV2hlbiB0aGUgZW5kcG9pbnQgb21pdHMgdGhlIHBvcnQsIHdlJ3JlIGNvbm5lY3RpbmcgdG8gdGhlIHByb3RvY29sXG4gIC8vIGRlZmF1bHQgcG9ydHM6IGh0dHAoODApIG9yIGh0dHBzKDQ0MykgYW5kIGl0J3MgYXNzdW1lZCB3ZSdyZSBiZWhpbmQgYSByZXZlcnNlXG4gIC8vIHByb3h5IHdoaWNoIG1hbmFnZXMgV2ViU29ja2V0IHVwZ3JhZGUgYW5kIGJhY2tlbmQgcG9ydCByZWRpcmVjdGlvbi5cbiAgc3RhcnRQb3J0ID09IG51bGwgPyAnJyA6IGA6JHtzdGFydFBvcnQgKyAxfWA7XG4gIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdGlzaH0ke3dlYnNvY2tldFBvcnR9JHtyZXN0fWA7XG59XG5cbmNvbnN0IFB1YmxpY0tleUZyb21TdHJpbmcgPSBjb2VyY2UoaW5zdGFuY2UoUHVibGljS2V5KSwgc3RyaW5nKCksIHZhbHVlID0+IG5ldyBQdWJsaWNLZXkodmFsdWUpKTtcbmNvbnN0IFJhd0FjY291bnREYXRhUmVzdWx0ID0gdHVwbGUoW3N0cmluZygpLCBsaXRlcmFsKCdiYXNlNjQnKV0pO1xuY29uc3QgQnVmZmVyRnJvbVJhd0FjY291bnREYXRhID0gY29lcmNlKGluc3RhbmNlKEJ1ZmZlciksIFJhd0FjY291bnREYXRhUmVzdWx0LCB2YWx1ZSA9PiBCdWZmZXIuZnJvbSh2YWx1ZVswXSwgJ2Jhc2U2NCcpKTtcblxuLyoqXG4gKiBBdHRlbXB0IHRvIHVzZSBhIHJlY2VudCBibG9ja2hhc2ggZm9yIHVwIHRvIDMwIHNlY29uZHNcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUyA9IDMwICogMTAwMDtcblxuLyoqXG4gKiBIQUNLLlxuICogQ29waWVkIGZyb20gcnBjLXdlYnNvY2tldHMvZGlzdC9saWIvY2xpZW50LlxuICogT3RoZXJ3aXNlLCBgeWFybiBidWlsZGAgZmFpbHMgd2l0aDpcbiAqIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL3N0ZXZlbHVzY2hlci9jMDU3ZWNhODFkNDc5ZWY3MDVjZGI1MzE2MmY5OTcxZFxuICovXG5cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKiBAaW50ZXJuYWwgKi9cbi8qKiBAaW50ZXJuYWwgKi9cblxuLyoqIEBpbnRlcm5hbCAqL1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqIEV2ZXJ5IHN1YnNjcmlwdGlvbiBjb250YWlucyB0aGUgYXJncyB1c2VkIHRvIG9wZW4gdGhlIHN1YnNjcmlwdGlvbiB3aXRoXG4gKiB0aGUgc2VydmVyLCBhbmQgYSBsaXN0IG9mIGNhbGxlcnMgaW50ZXJlc3RlZCBpbiBub3RpZmljYXRpb25zLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKiBBIHN1YnNjcmlwdGlvbiBtYXkgYmUgaW4gdmFyaW91cyBzdGF0ZXMgb2YgY29ubmVjdGVkbmVzcy4gT25seSB3aGVuIGl0IGlzXG4gKiBmdWxseSBjb25uZWN0ZWQgd2lsbCBpdCBoYXZlIGEgc2VydmVyIHN1YnNjcmlwdGlvbiBpZCBhc3NvY2lhdGVkIHdpdGggaXQuXG4gKiBUaGlzIGlkIGNhbiBiZSByZXR1cm5lZCB0byB0aGUgc2VydmVyIHRvIHVuc3Vic2NyaWJlIHRoZSBjbGllbnQgZW50aXJlbHkuXG4gKi9cblxuLyoqXG4gKiBBIHR5cGUgdGhhdCBlbmNhcHN1bGF0ZXMgYSBzdWJzY3JpcHRpb24ncyBSUEMgbWV0aG9kXG4gKiBuYW1lcyBhbmQgbm90aWZpY2F0aW9uIChjYWxsYmFjaykgc2lnbmF0dXJlLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKiBVdGlsaXR5IHR5cGUgdGhhdCBrZWVwcyB0YWdnZWQgdW5pb25zIGludGFjdCB3aGlsZSBvbWl0dGluZyBwcm9wZXJ0aWVzLlxuICovXG5cbi8qKlxuICogQGludGVybmFsXG4gKiBUaGlzIHR5cGUgcmVwcmVzZW50cyBhIHNpbmdsZSBzdWJzY3JpYmFibGUgJ3RvcGljLicgSXQncyBtYWRlIHVwIG9mOlxuICpcbiAqIC0gVGhlIGFyZ3MgdXNlZCB0byBvcGVuIHRoZSBzdWJzY3JpcHRpb24gd2l0aCB0aGUgc2VydmVyLFxuICogLSBUaGUgc3RhdGUgb2YgdGhlIHN1YnNjcmlwdGlvbiwgaW4gdGVybXMgb2YgaXRzIGNvbm5lY3RlZG5lc3MsIGFuZFxuICogLSBUaGUgc2V0IG9mIGNhbGxiYWNrcyB0byBjYWxsIHdoZW4gdGhlIHNlcnZlciBwdWJsaXNoZXMgbm90aWZpY2F0aW9uc1xuICpcbiAqIFRoaXMgcmVjb3JkIGdldHMgaW5kZXhlZCBieSBgU3Vic2NyaXB0aW9uQ29uZmlnSGFzaGAgYW5kIGlzIHVzZWQgdG9cbiAqIHNldCB1cCBzdWJzY3JpcHRpb25zLCBmYW4gb3V0IG5vdGlmaWNhdGlvbnMsIGFuZCB0cmFjayBzdWJzY3JpcHRpb24gc3RhdGUuXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG4vKipcbiAqIEV4dHJhIGNvbnRleHR1YWwgaW5mb3JtYXRpb24gZm9yIFJQQyByZXNwb25zZXNcbiAqL1xuXG4vKipcbiAqIE9wdGlvbnMgZm9yIHNlbmRpbmcgdHJhbnNhY3Rpb25zXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIGZvciBjb25maXJtaW5nIHRyYW5zYWN0aW9uc1xuICovXG5cbi8qKlxuICogT3B0aW9ucyBmb3IgZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyXG4gKi9cblxuLyoqXG4gKiBPcHRpb25zIGZvciBnZXRTaWduYXR1cmVzRm9yQWRkcmVzc1xuICovXG5cbi8qKlxuICogUlBDIFJlc3BvbnNlIHdpdGggZXh0cmEgY29udGV4dHVhbCBpbmZvcm1hdGlvblxuICovXG5cbi8qKlxuICogQSBzdHJhdGVneSBmb3IgY29uZmlybWluZyB0cmFuc2FjdGlvbnMgdGhhdCB1c2VzIHRoZSBsYXN0IHZhbGlkXG4gKiBibG9jayBoZWlnaHQgZm9yIGEgZ2l2ZW4gYmxvY2toYXNoIHRvIGNoZWNrIGZvciB0cmFuc2FjdGlvbiBleHBpcmF0aW9uLlxuICovXG5cbi8qKlxuICogQSBzdHJhdGVneSBmb3IgY29uZmlybWluZyBkdXJhYmxlIG5vbmNlIHRyYW5zYWN0aW9ucy5cbiAqL1xuXG4vKipcbiAqIFByb3BlcnRpZXMgc2hhcmVkIGJ5IGFsbCB0cmFuc2FjdGlvbiBjb25maXJtYXRpb24gc3RyYXRlZ2llc1xuICovXG5cbi8qKlxuICogVGhpcyB0eXBlIHJlcHJlc2VudHMgYWxsIHRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiBzdHJhdGVnaWVzXG4gKi9cblxuLyogQGludGVybmFsICovXG5mdW5jdGlvbiBhc3NlcnRFbmRwb2ludFVybChwdXRhdGl2ZVVybCkge1xuICBpZiAoL15odHRwcz86Ly50ZXN0KHB1dGF0aXZlVXJsKSA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmRwb2ludCBVUkwgbXVzdCBzdGFydCB3aXRoIGBodHRwOmAgb3IgYGh0dHBzOmAuJyk7XG4gIH1cbiAgcmV0dXJuIHB1dGF0aXZlVXJsO1xufVxuXG4vKiogQGludGVybmFsICovXG5mdW5jdGlvbiBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gIGxldCBjb21taXRtZW50O1xuICBsZXQgY29uZmlnO1xuICBpZiAodHlwZW9mIGNvbW1pdG1lbnRPckNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb21taXRtZW50ID0gY29tbWl0bWVudE9yQ29uZmlnO1xuICB9IGVsc2UgaWYgKGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQ6IHNwZWNpZmllZENvbW1pdG1lbnQsXG4gICAgICAuLi5zcGVjaWZpZWRDb25maWdcbiAgICB9ID0gY29tbWl0bWVudE9yQ29uZmlnO1xuICAgIGNvbW1pdG1lbnQgPSBzcGVjaWZpZWRDb21taXRtZW50O1xuICAgIGNvbmZpZyA9IHNwZWNpZmllZENvbmZpZztcbiAgfVxuICByZXR1cm4ge1xuICAgIGNvbW1pdG1lbnQsXG4gICAgY29uZmlnXG4gIH07XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJwY1Jlc3VsdChyZXN1bHQpIHtcbiAgcmV0dXJuIHVuaW9uKFt0eXBlKHtcbiAgICBqc29ucnBjOiBsaXRlcmFsKCcyLjAnKSxcbiAgICBpZDogc3RyaW5nKCksXG4gICAgcmVzdWx0XG4gIH0pLCB0eXBlKHtcbiAgICBqc29ucnBjOiBsaXRlcmFsKCcyLjAnKSxcbiAgICBpZDogc3RyaW5nKCksXG4gICAgZXJyb3I6IHR5cGUoe1xuICAgICAgY29kZTogdW5rbm93bigpLFxuICAgICAgbWVzc2FnZTogc3RyaW5nKCksXG4gICAgICBkYXRhOiBvcHRpb25hbChhbnkoKSlcbiAgICB9KVxuICB9KV0pO1xufVxuY29uc3QgVW5rbm93blJwY1Jlc3VsdCA9IGNyZWF0ZVJwY1Jlc3VsdCh1bmtub3duKCkpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBqc29uUnBjUmVzdWx0KHNjaGVtYSkge1xuICByZXR1cm4gY29lcmNlKGNyZWF0ZVJwY1Jlc3VsdChzY2hlbWEpLCBVbmtub3duUnBjUmVzdWx0LCB2YWx1ZSA9PiB7XG4gICAgaWYgKCdlcnJvcicgaW4gdmFsdWUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udmFsdWUsXG4gICAgICAgIHJlc3VsdDogY3JlYXRlKHZhbHVlLnJlc3VsdCwgc2NoZW1hKVxuICAgICAgfTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBqc29uUnBjUmVzdWx0QW5kQ29udGV4dCh2YWx1ZSkge1xuICByZXR1cm4ganNvblJwY1Jlc3VsdCh0eXBlKHtcbiAgICBjb250ZXh0OiB0eXBlKHtcbiAgICAgIHNsb3Q6IG51bWJlcigpXG4gICAgfSksXG4gICAgdmFsdWVcbiAgfSkpO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlKHtcbiAgICBjb250ZXh0OiB0eXBlKHtcbiAgICAgIHNsb3Q6IG51bWJlcigpXG4gICAgfSksXG4gICAgdmFsdWVcbiAgfSk7XG59XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UodmVyc2lvbiwgcmVzcG9uc2UpIHtcbiAgaWYgKHZlcnNpb24gPT09IDApIHtcbiAgICByZXR1cm4gbmV3IE1lc3NhZ2VWMCh7XG4gICAgICBoZWFkZXI6IHJlc3BvbnNlLmhlYWRlcixcbiAgICAgIHN0YXRpY0FjY291bnRLZXlzOiByZXNwb25zZS5hY2NvdW50S2V5cy5tYXAoYWNjb3VudEtleSA9PiBuZXcgUHVibGljS2V5KGFjY291bnRLZXkpKSxcbiAgICAgIHJlY2VudEJsb2NraGFzaDogcmVzcG9uc2UucmVjZW50QmxvY2toYXNoLFxuICAgICAgY29tcGlsZWRJbnN0cnVjdGlvbnM6IHJlc3BvbnNlLmluc3RydWN0aW9ucy5tYXAoaXggPT4gKHtcbiAgICAgICAgcHJvZ3JhbUlkSW5kZXg6IGl4LnByb2dyYW1JZEluZGV4LFxuICAgICAgICBhY2NvdW50S2V5SW5kZXhlczogaXguYWNjb3VudHMsXG4gICAgICAgIGRhdGE6IGJzNTguZGVjb2RlKGl4LmRhdGEpXG4gICAgICB9KSksXG4gICAgICBhZGRyZXNzVGFibGVMb29rdXBzOiByZXNwb25zZS5hZGRyZXNzVGFibGVMb29rdXBzXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBNZXNzYWdlKHJlc3BvbnNlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsZXZlbCBvZiBjb21taXRtZW50IGRlc2lyZWQgd2hlbiBxdWVyeWluZyBzdGF0ZVxuICogPHByZT5cbiAqICAgJ3Byb2Nlc3NlZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY29ubmVjdGVkIG5vZGVcbiAqICAgJ2NvbmZpcm1lZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY2x1c3RlclxuICogICAnZmluYWxpemVkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyBiZWVuIGZpbmFsaXplZCBieSB0aGUgY2x1c3RlclxuICogPC9wcmU+XG4gKi9cblxuLy8gRGVwcmVjYXRlZCBhcyBvZiB2MS41LjVcblxuLyoqXG4gKiBBIHN1YnNldCBvZiBDb21taXRtZW50IGxldmVscywgd2hpY2ggYXJlIGF0IGxlYXN0IG9wdGltaXN0aWNhbGx5IGNvbmZpcm1lZFxuICogPHByZT5cbiAqICAgJ2NvbmZpcm1lZCc6IFF1ZXJ5IHRoZSBtb3N0IHJlY2VudCBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY2x1c3RlclxuICogICAnZmluYWxpemVkJzogUXVlcnkgdGhlIG1vc3QgcmVjZW50IGJsb2NrIHdoaWNoIGhhcyBiZWVuIGZpbmFsaXplZCBieSB0aGUgY2x1c3RlclxuICogPC9wcmU+XG4gKi9cblxuLyoqXG4gKiBGaWx0ZXIgZm9yIGxhcmdlc3QgYWNjb3VudHMgcXVlcnlcbiAqIDxwcmU+XG4gKiAgICdjaXJjdWxhdGluZyc6ICAgIFJldHVybiB0aGUgbGFyZ2VzdCBhY2NvdW50cyB0aGF0IGFyZSBwYXJ0IG9mIHRoZSBjaXJjdWxhdGluZyBzdXBwbHlcbiAqICAgJ25vbkNpcmN1bGF0aW5nJzogUmV0dXJuIHRoZSBsYXJnZXN0IGFjY291bnRzIHRoYXQgYXJlIG5vdCBwYXJ0IG9mIHRoZSBjaXJjdWxhdGluZyBzdXBwbHlcbiAqIDwvcHJlPlxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRBY2NvdW50SW5mb2AgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QmFsYW5jZWAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0QmxvY2tgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldEJsb2NrYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRTdGFrZU1pbmltdW1EZWxlZ2F0aW9uYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRCbG9ja0hlaWdodGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0RXBvY2hJbmZvYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRJbmZsYXRpb25SZXdhcmRgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldExhdGVzdEJsb2NraGFzaGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgaXNCbG9ja2hhc2hWYWxpZGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U2xvdGAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0U2xvdExlYWRlcmAgcXVlcnkgYmVoYXZpb3JcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBjaGFuZ2luZyBgZ2V0VHJhbnNhY3Rpb25gIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFRyYW5zYWN0aW9uYCBxdWVyeSBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRMYXJnZXN0QWNjb3VudHNgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgY2hhbmdpbmcgYGdldFN1cHBseWAgcmVxdWVzdCBiZWhhdmlvclxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBkZXNjcmliaW5nIGEgY2x1c3RlciBub2RlXG4gKi9cblxuLyoqXG4gKiBJbmZvcm1hdGlvbiBkZXNjcmliaW5nIGEgdm90ZSBhY2NvdW50XG4gKi9cblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgY2x1c3RlciB2b3RlIGFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBOZXR3b3JrIEluZmxhdGlvblxuICogKHNlZSBodHRwczovL2RvY3Muc29sYW5hLmNvbS9pbXBsZW1lbnRlZC1wcm9wb3NhbHMvZWRfb3ZlcnZpZXcpXG4gKi9cblxuY29uc3QgR2V0SW5mbGF0aW9uR292ZXJub3JSZXN1bHQgPSB0eXBlKHtcbiAgZm91bmRhdGlvbjogbnVtYmVyKCksXG4gIGZvdW5kYXRpb25UZXJtOiBudW1iZXIoKSxcbiAgaW5pdGlhbDogbnVtYmVyKCksXG4gIHRhcGVyOiBudW1iZXIoKSxcbiAgdGVybWluYWw6IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBUaGUgaW5mbGF0aW9uIHJld2FyZCBmb3IgYW4gZXBvY2hcbiAqL1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRJbmZsYXRpb25SZXdhcmRcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEluZmxhdGlvblJld2FyZFJlc3VsdCA9IGpzb25ScGNSZXN1bHQoYXJyYXkobnVsbGFibGUodHlwZSh7XG4gIGVwb2NoOiBudW1iZXIoKSxcbiAgZWZmZWN0aXZlU2xvdDogbnVtYmVyKCksXG4gIGFtb3VudDogbnVtYmVyKCksXG4gIHBvc3RCYWxhbmNlOiBudW1iZXIoKSxcbiAgY29tbWlzc2lvbjogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKVxufSkpKSk7XG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGNoYW5naW5nIGBnZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNgIHF1ZXJ5IGJlaGF2aW9yXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNSZXN1bHQgPSBhcnJheSh0eXBlKHtcbiAgc2xvdDogbnVtYmVyKCksXG4gIHByaW9yaXRpemF0aW9uRmVlOiBudW1iZXIoKVxufSkpO1xuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uUmF0ZVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0SW5mbGF0aW9uUmF0ZVJlc3VsdCA9IHR5cGUoe1xuICB0b3RhbDogbnVtYmVyKCksXG4gIHZhbGlkYXRvcjogbnVtYmVyKCksXG4gIGZvdW5kYXRpb246IG51bWJlcigpLFxuICBlcG9jaDogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGVwb2NoXG4gKi9cblxuY29uc3QgR2V0RXBvY2hJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIGVwb2NoOiBudW1iZXIoKSxcbiAgc2xvdEluZGV4OiBudW1iZXIoKSxcbiAgc2xvdHNJbkVwb2NoOiBudW1iZXIoKSxcbiAgYWJzb2x1dGVTbG90OiBudW1iZXIoKSxcbiAgYmxvY2tIZWlnaHQ6IG9wdGlvbmFsKG51bWJlcigpKSxcbiAgdHJhbnNhY3Rpb25Db3VudDogb3B0aW9uYWwobnVtYmVyKCkpXG59KTtcbmNvbnN0IEdldEVwb2NoU2NoZWR1bGVSZXN1bHQgPSB0eXBlKHtcbiAgc2xvdHNQZXJFcG9jaDogbnVtYmVyKCksXG4gIGxlYWRlclNjaGVkdWxlU2xvdE9mZnNldDogbnVtYmVyKCksXG4gIHdhcm11cDogYm9vbGVhbigpLFxuICBmaXJzdE5vcm1hbEVwb2NoOiBudW1iZXIoKSxcbiAgZmlyc3ROb3JtYWxTbG90OiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogTGVhZGVyIHNjaGVkdWxlXG4gKiAoc2VlIGh0dHBzOi8vZG9jcy5zb2xhbmEuY29tL3Rlcm1pbm9sb2d5I2xlYWRlci1zY2hlZHVsZSlcbiAqL1xuXG5jb25zdCBHZXRMZWFkZXJTY2hlZHVsZVJlc3VsdCA9IHJlY29yZChzdHJpbmcoKSwgYXJyYXkobnVtYmVyKCkpKTtcblxuLyoqXG4gKiBUcmFuc2FjdGlvbiBlcnJvciBvciBudWxsXG4gKi9cbmNvbnN0IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQgPSBudWxsYWJsZSh1bmlvbihbdHlwZSh7fSksIHN0cmluZygpXSkpO1xuXG4vKipcbiAqIFNpZ25hdHVyZSBzdGF0dXMgZm9yIGEgdHJhbnNhY3Rpb25cbiAqL1xuY29uc3QgU2lnbmF0dXJlU3RhdHVzUmVzdWx0ID0gdHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdFxufSk7XG5cbi8qKlxuICogVHJhbnNhY3Rpb24gc2lnbmF0dXJlIHJlY2VpdmVkIG5vdGlmaWNhdGlvblxuICovXG5jb25zdCBTaWduYXR1cmVSZWNlaXZlZFJlc3VsdCA9IGxpdGVyYWwoJ3JlY2VpdmVkU2lnbmF0dXJlJyk7XG5cbi8qKlxuICogVmVyc2lvbiBpbmZvIGZvciBhIG5vZGVcbiAqL1xuXG5jb25zdCBWZXJzaW9uUmVzdWx0ID0gdHlwZSh7XG4gICdzb2xhbmEtY29yZSc6IHN0cmluZygpLFxuICAnZmVhdHVyZS1zZXQnOiBvcHRpb25hbChudW1iZXIoKSlcbn0pO1xuY29uc3QgU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHR5cGUoe1xuICBlcnI6IG51bGxhYmxlKHVuaW9uKFt0eXBlKHt9KSwgc3RyaW5nKCldKSksXG4gIGxvZ3M6IG51bGxhYmxlKGFycmF5KHN0cmluZygpKSksXG4gIGFjY291bnRzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShudWxsYWJsZSh0eXBlKHtcbiAgICBleGVjdXRhYmxlOiBib29sZWFuKCksXG4gICAgb3duZXI6IHN0cmluZygpLFxuICAgIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgICBkYXRhOiBhcnJheShzdHJpbmcoKSksXG4gICAgcmVudEVwb2NoOiBvcHRpb25hbChudW1iZXIoKSlcbiAgfSkpKSkpLFxuICB1bml0c0NvbnN1bWVkOiBvcHRpb25hbChudW1iZXIoKSksXG4gIHJldHVybkRhdGE6IG9wdGlvbmFsKG51bGxhYmxlKHR5cGUoe1xuICAgIHByb2dyYW1JZDogc3RyaW5nKCksXG4gICAgZGF0YTogdHVwbGUoW3N0cmluZygpLCBsaXRlcmFsKCdiYXNlNjQnKV0pXG4gIH0pKSlcbn0pKTtcblxuLyoqXG4gKiBNZXRhZGF0YSBmb3IgYSBwYXJzZWQgY29uZmlybWVkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIFBhcnNlZFRyYW5zYWN0aW9uTWV0YX0gaW5zdGVhZC5cbiAqL1xuXG4vKipcbiAqIENvbGxlY3Rpb24gb2YgYWRkcmVzc2VzIGxvYWRlZCBieSBhIHRyYW5zYWN0aW9uIHVzaW5nIGFkZHJlc3MgdGFibGUgbG9va3Vwc1xuICovXG5cbi8qKlxuICogTWV0YWRhdGEgZm9yIGEgcGFyc2VkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqL1xuXG4vKipcbiAqIE1ldGFkYXRhIGZvciBhIGNvbmZpcm1lZCB0cmFuc2FjdGlvbiBvbiB0aGUgbGVkZ2VyXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBSUEMgQVBJXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCB0cmFuc2FjdGlvbiBtZXNzYWdlIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgY29uZmlybWVkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXJcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuXG4gKi9cblxuLyoqXG4gKiBBIHBhcnRpYWxseSBkZWNvZGVkIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCB0cmFuc2FjdGlvbiBtZXNzYWdlIGFjY291bnRcbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uIGluc3RydWN0aW9uXG4gKi9cblxuLyoqXG4gKiBBIHBhcnNlZCBhZGRyZXNzIHRhYmxlIGxvb2t1cFxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb24gbWVzc2FnZVxuICovXG5cbi8qKlxuICogQSBwYXJzZWQgdHJhbnNhY3Rpb25cbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIGFuZCBjb25maXJtZWQgdHJhbnNhY3Rpb24gb24gdGhlIGxlZGdlclxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgUGFyc2VkVHJhbnNhY3Rpb25XaXRoTWV0YX0gaW5zdGVhZC5cbiAqL1xuXG4vKipcbiAqIEEgcGFyc2VkIHRyYW5zYWN0aW9uIG9uIHRoZSBsZWRnZXIgd2l0aCBtZXRhXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSSB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgYWNjb3VudHNgXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUEkgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYG5vbmVgXG4gKi9cblxuLyoqXG4gKiBBIGJsb2NrIHdpdGggcGFyc2VkIHRyYW5zYWN0aW9uc1xuICovXG5cbi8qKlxuICogQSBibG9jayB3aXRoIHBhcnNlZCB0cmFuc2FjdGlvbnMgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYGFjY291bnRzYFxuICovXG5cbi8qKlxuICogQSBibG9jayB3aXRoIHBhcnNlZCB0cmFuc2FjdGlvbnMgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYG5vbmVgXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUElcbiAqL1xuXG4vKipcbiAqIEEgcHJvY2Vzc2VkIGJsb2NrIGZldGNoZWQgZnJvbSB0aGUgUlBDIEFQSSB3aGVyZSB0aGUgYHRyYW5zYWN0aW9uRGV0YWlsc2AgbW9kZSBpcyBgYWNjb3VudHNgXG4gKi9cblxuLyoqXG4gKiBBIHByb2Nlc3NlZCBibG9jayBmZXRjaGVkIGZyb20gdGhlIFJQQyBBUEkgd2hlcmUgdGhlIGB0cmFuc2FjdGlvbkRldGFpbHNgIG1vZGUgaXMgYG5vbmVgXG4gKi9cblxuLyoqXG4gKiBBIGNvbmZpcm1lZCBibG9jayBvbiB0aGUgbGVkZ2VyXG4gKlxuICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLlxuICovXG5cbi8qKlxuICogQSBCbG9jayBvbiB0aGUgbGVkZ2VyIHdpdGggc2lnbmF0dXJlcyBvbmx5XG4gKi9cblxuLyoqXG4gKiByZWNlbnQgYmxvY2sgcHJvZHVjdGlvbiBpbmZvcm1hdGlvblxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrUHJvZHVjdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgQmxvY2tQcm9kdWN0aW9uUmVzcG9uc2VTdHJ1Y3QgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dCh0eXBlKHtcbiAgYnlJZGVudGl0eTogcmVjb3JkKHN0cmluZygpLCBhcnJheShudW1iZXIoKSkpLFxuICByYW5nZTogdHlwZSh7XG4gICAgZmlyc3RTbG90OiBudW1iZXIoKSxcbiAgICBsYXN0U2xvdDogbnVtYmVyKClcbiAgfSlcbn0pKTtcblxuLyoqXG4gKiBBIHBlcmZvcm1hbmNlIHNhbXBsZVxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZVJwY0NsaWVudCh1cmwsIGh0dHBIZWFkZXJzLCBjdXN0b21GZXRjaCwgZmV0Y2hNaWRkbGV3YXJlLCBkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCwgaHR0cEFnZW50KSB7XG4gIGNvbnN0IGZldGNoID0gY3VzdG9tRmV0Y2ggPyBjdXN0b21GZXRjaCA6IGZldGNoSW1wbDtcbiAgbGV0IGFnZW50O1xuICB7XG4gICAgaWYgKGh0dHBBZ2VudCAhPSBudWxsKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ1lvdSBoYXZlIHN1cHBsaWVkIGFuIGBodHRwQWdlbnRgIHdoZW4gY3JlYXRpbmcgYSBgQ29ubmVjdGlvbmAgaW4gYSBicm93c2VyIGVudmlyb25tZW50LicgKyAnSXQgaGFzIGJlZW4gaWdub3JlZDsgYGh0dHBBZ2VudGAgaXMgb25seSB1c2VkIGluIE5vZGUgZW52aXJvbm1lbnRzLicpO1xuICAgIH1cbiAgfVxuICBsZXQgZmV0Y2hXaXRoTWlkZGxld2FyZTtcbiAgaWYgKGZldGNoTWlkZGxld2FyZSkge1xuICAgIGZldGNoV2l0aE1pZGRsZXdhcmUgPSBhc3luYyAoaW5mbywgaW5pdCkgPT4ge1xuICAgICAgY29uc3QgbW9kaWZpZWRGZXRjaEFyZ3MgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZmV0Y2hNaWRkbGV3YXJlKGluZm8sIGluaXQsIChtb2RpZmllZEluZm8sIG1vZGlmaWVkSW5pdCkgPT4gcmVzb2x2ZShbbW9kaWZpZWRJbmZvLCBtb2RpZmllZEluaXRdKSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYXdhaXQgZmV0Y2goLi4ubW9kaWZpZWRGZXRjaEFyZ3MpO1xuICAgIH07XG4gIH1cbiAgY29uc3QgY2xpZW50QnJvd3NlciA9IG5ldyBScGNDbGllbnQoYXN5bmMgKHJlcXVlc3QsIGNhbGxiYWNrKSA9PiB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgYm9keTogcmVxdWVzdCxcbiAgICAgIGFnZW50LFxuICAgICAgaGVhZGVyczogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbidcbiAgICAgIH0sIGh0dHBIZWFkZXJzIHx8IHt9LCBDT01NT05fSFRUUF9IRUFERVJTKVxuICAgIH07XG4gICAgdHJ5IHtcbiAgICAgIGxldCB0b29fbWFueV9yZXF1ZXN0c19yZXRyaWVzID0gNTtcbiAgICAgIGxldCByZXM7XG4gICAgICBsZXQgd2FpdFRpbWUgPSA1MDA7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGlmIChmZXRjaFdpdGhNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgcmVzID0gYXdhaXQgZmV0Y2hXaXRoTWlkZGxld2FyZSh1cmwsIG9wdGlvbnMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlcyA9IGF3YWl0IGZldGNoKHVybCwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlcy5zdGF0dXMgIT09IDQyOSAvKiBUb28gbWFueSByZXF1ZXN0cyAqLykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMgLT0gMTtcbiAgICAgICAgaWYgKHRvb19tYW55X3JlcXVlc3RzX3JldHJpZXMgPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmVycm9yKGBTZXJ2ZXIgcmVzcG9uZGVkIHdpdGggJHtyZXMuc3RhdHVzfSAke3Jlcy5zdGF0dXNUZXh0fS4gIFJldHJ5aW5nIGFmdGVyICR7d2FpdFRpbWV9bXMgZGVsYXkuLi5gKTtcbiAgICAgICAgYXdhaXQgc2xlZXAod2FpdFRpbWUpO1xuICAgICAgICB3YWl0VGltZSAqPSAyO1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dCA9IGF3YWl0IHJlcy50ZXh0KCk7XG4gICAgICBpZiAocmVzLm9rKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHRleHQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FsbGJhY2sobmV3IEVycm9yKGAke3Jlcy5zdGF0dXN9ICR7cmVzLnN0YXR1c1RleHR9OiAke3RleHR9YCkpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSBjYWxsYmFjayhlcnIpO1xuICAgIH1cbiAgfSwge30pO1xuICByZXR1cm4gY2xpZW50QnJvd3Nlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJwY1JlcXVlc3QoY2xpZW50KSB7XG4gIHJldHVybiAobWV0aG9kLCBhcmdzKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGNsaWVudC5yZXF1ZXN0KG1ldGhvZCwgYXJncywgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUnBjQmF0Y2hSZXF1ZXN0KGNsaWVudCkge1xuICByZXR1cm4gcmVxdWVzdHMgPT4ge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAvLyBEbyBub3RoaW5nIGlmIHJlcXVlc3RzIGlzIGVtcHR5XG4gICAgICBpZiAocmVxdWVzdHMubGVuZ3RoID09PSAwKSByZXNvbHZlKFtdKTtcbiAgICAgIGNvbnN0IGJhdGNoID0gcmVxdWVzdHMubWFwKHBhcmFtcyA9PiB7XG4gICAgICAgIHJldHVybiBjbGllbnQucmVxdWVzdChwYXJhbXMubWV0aG9kTmFtZSwgcGFyYW1zLmFyZ3MpO1xuICAgICAgfSk7XG4gICAgICBjbGllbnQucmVxdWVzdChiYXRjaCwgKGVyciwgcmVzcG9uc2UpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKHJlc3BvbnNlKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9O1xufVxuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRJbmZsYXRpb25Hb3Zlcm5vclwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0SW5mbGF0aW9uR292ZXJub3JScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KEdldEluZmxhdGlvbkdvdmVybm9yUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0SW5mbGF0aW9uUmF0ZVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0SW5mbGF0aW9uUmF0ZVJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0SW5mbGF0aW9uUmF0ZVJlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlc1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChHZXRSZWNlbnRQcmlvcml0aXphdGlvbkZlZXNSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRFcG9jaEluZm9cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldEVwb2NoSW5mb1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0RXBvY2hJbmZvUmVzdWx0KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0RXBvY2hTY2hlZHVsZVwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0RXBvY2hTY2hlZHVsZVJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0RXBvY2hTY2hlZHVsZVJlc3VsdCk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldExlYWRlclNjaGVkdWxlXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRMZWFkZXJTY2hlZHVsZVJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoR2V0TGVhZGVyU2NoZWR1bGVSZXN1bHQpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJtaW5pbXVtTGVkZ2VyU2xvdFwiIGFuZCBcImdldEZpcnN0QXZhaWxhYmxlQmxvY2tcIiBtZXNzYWdlc1xuICovXG5jb25zdCBTbG90UnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudW1iZXIoKSk7XG5cbi8qKlxuICogU3VwcGx5XG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0U3VwcGx5XCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRTdXBwbHlScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dCh0eXBlKHtcbiAgdG90YWw6IG51bWJlcigpLFxuICBjaXJjdWxhdGluZzogbnVtYmVyKCksXG4gIG5vbkNpcmN1bGF0aW5nOiBudW1iZXIoKSxcbiAgbm9uQ2lyY3VsYXRpbmdBY2NvdW50czogYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZylcbn0pKTtcblxuLyoqXG4gKiBUb2tlbiBhbW91bnQgb2JqZWN0IHdoaWNoIHJldHVybnMgYSB0b2tlbiBhbW91bnQgaW4gZGlmZmVyZW50IGZvcm1hdHNcbiAqIGZvciB2YXJpb3VzIGNsaWVudCB1c2UgY2FzZXMuXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyBzdHJ1Y3R1cmUgZm9yIHRva2VuIGFtb3VudHNcbiAqL1xuY29uc3QgVG9rZW5BbW91bnRSZXN1bHQgPSB0eXBlKHtcbiAgYW1vdW50OiBzdHJpbmcoKSxcbiAgdWlBbW91bnQ6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgZGVjaW1hbHM6IG51bWJlcigpLFxuICB1aUFtb3VudFN0cmluZzogb3B0aW9uYWwoc3RyaW5nKCkpXG59KTtcblxuLyoqXG4gKiBUb2tlbiBhZGRyZXNzIGFuZCBiYWxhbmNlLlxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRva2VuTGFyZ2VzdEFjY291bnRzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRUb2tlbkxhcmdlc3RBY2NvdW50c1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KHR5cGUoe1xuICBhZGRyZXNzOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhbW91bnQ6IHN0cmluZygpLFxuICB1aUFtb3VudDogbnVsbGFibGUobnVtYmVyKCkpLFxuICBkZWNpbWFsczogbnVtYmVyKCksXG4gIHVpQW1vdW50U3RyaW5nOiBvcHRpb25hbChzdHJpbmcoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRva2VuQWNjb3VudHNCeU93bmVyXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRUb2tlbkFjY291bnRzQnlPd25lciA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KHR5cGUoe1xuICBwdWJrZXk6IFB1YmxpY0tleUZyb21TdHJpbmcsXG4gIGFjY291bnQ6IHR5cGUoe1xuICAgIGV4ZWN1dGFibGU6IGJvb2xlYW4oKSxcbiAgICBvd25lcjogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgICBsYW1wb3J0czogbnVtYmVyKCksXG4gICAgZGF0YTogQnVmZmVyRnJvbVJhd0FjY291bnREYXRhLFxuICAgIHJlbnRFcG9jaDogbnVtYmVyKClcbiAgfSlcbn0pKSk7XG5jb25zdCBQYXJzZWRBY2NvdW50RGF0YVJlc3VsdCA9IHR5cGUoe1xuICBwcm9ncmFtOiBzdHJpbmcoKSxcbiAgcGFyc2VkOiB1bmtub3duKCksXG4gIHNwYWNlOiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFRva2VuQWNjb3VudHNCeU93bmVyXCIgbWVzc2FnZSB3aXRoIHBhcnNlZCBkYXRhXG4gKi9cbmNvbnN0IEdldFBhcnNlZFRva2VuQWNjb3VudHNCeU93bmVyID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkodHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogdHlwZSh7XG4gICAgZXhlY3V0YWJsZTogYm9vbGVhbigpLFxuICAgIG93bmVyOiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICAgIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgICBkYXRhOiBQYXJzZWRBY2NvdW50RGF0YVJlc3VsdCxcbiAgICByZW50RXBvY2g6IG51bWJlcigpXG4gIH0pXG59KSkpO1xuXG4vKipcbiAqIFBhaXIgb2YgYW4gYWNjb3VudCBhZGRyZXNzIGFuZCBpdHMgYmFsYW5jZVxuICovXG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldExhcmdlc3RBY2NvdW50c1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0TGFyZ2VzdEFjY291bnRzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQoYXJyYXkodHlwZSh7XG4gIGxhbXBvcnRzOiBudW1iZXIoKSxcbiAgYWRkcmVzczogUHVibGljS2V5RnJvbVN0cmluZ1xufSkpKTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgZXhlY3V0YWJsZTogYm9vbGVhbigpLFxuICBvd25lcjogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgbGFtcG9ydHM6IG51bWJlcigpLFxuICBkYXRhOiBCdWZmZXJGcm9tUmF3QWNjb3VudERhdGEsXG4gIHJlbnRFcG9jaDogbnVtYmVyKClcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBLZXllZEFjY291bnRJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHB1YmtleTogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgYWNjb3VudDogQWNjb3VudEluZm9SZXN1bHRcbn0pO1xuY29uc3QgUGFyc2VkT3JSYXdBY2NvdW50RGF0YSA9IGNvZXJjZSh1bmlvbihbaW5zdGFuY2UoQnVmZmVyKSwgUGFyc2VkQWNjb3VudERhdGFSZXN1bHRdKSwgdW5pb24oW1Jhd0FjY291bnREYXRhUmVzdWx0LCBQYXJzZWRBY2NvdW50RGF0YVJlc3VsdF0pLCB2YWx1ZSA9PiB7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiBjcmVhdGUodmFsdWUsIEJ1ZmZlckZyb21SYXdBY2NvdW50RGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgUGFyc2VkQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgZXhlY3V0YWJsZTogYm9vbGVhbigpLFxuICBvd25lcjogUHVibGljS2V5RnJvbVN0cmluZyxcbiAgbGFtcG9ydHM6IG51bWJlcigpLFxuICBkYXRhOiBQYXJzZWRPclJhd0FjY291bnREYXRhLFxuICByZW50RXBvY2g6IG51bWJlcigpXG59KTtcbmNvbnN0IEtleWVkUGFyc2VkQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50OiBQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdFxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFN0YWtlQWN0aXZhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdGF0ZTogdW5pb24oW2xpdGVyYWwoJ2FjdGl2ZScpLCBsaXRlcmFsKCdpbmFjdGl2ZScpLCBsaXRlcmFsKCdhY3RpdmF0aW5nJyksIGxpdGVyYWwoJ2RlYWN0aXZhdGluZycpXSksXG4gIGFjdGl2ZTogbnVtYmVyKCksXG4gIGluYWN0aXZlOiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldENvbmZpcm1lZFNpZ25hdHVyZXNGb3JBZGRyZXNzMlwiIG1lc3NhZ2VcbiAqL1xuXG5jb25zdCBHZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KGFycmF5KHR5cGUoe1xuICBzaWduYXR1cmU6IHN0cmluZygpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBtZW1vOiBudWxsYWJsZShzdHJpbmcoKSksXG4gIGJsb2NrVGltZTogb3B0aW9uYWwobnVsbGFibGUobnVtYmVyKCkpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3NcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFNpZ25hdHVyZXNGb3JBZGRyZXNzUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChhcnJheSh0eXBlKHtcbiAgc2lnbmF0dXJlOiBzdHJpbmcoKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgbWVtbzogbnVsbGFibGUoc3RyaW5nKCkpLFxuICBibG9ja1RpbWU6IG9wdGlvbmFsKG51bGxhYmxlKG51bWJlcigpKSlcbn0pKSk7XG5cbi8qKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJhY2NvdW50Tm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBBY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogbm90aWZpY2F0aW9uUmVzdWx0QW5kQ29udGV4dChBY2NvdW50SW5mb1Jlc3VsdClcbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBQcm9ncmFtQWNjb3VudEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBhY2NvdW50OiBBY2NvdW50SW5mb1Jlc3VsdFxufSk7XG5cbi8qKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJwcm9ncmFtTm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBQcm9ncmFtQWNjb3VudE5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQoUHJvZ3JhbUFjY291bnRJbmZvUmVzdWx0KVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFNsb3RJbmZvUmVzdWx0ID0gdHlwZSh7XG4gIHBhcmVudDogbnVtYmVyKCksXG4gIHNsb3Q6IG51bWJlcigpLFxuICByb290OiBudW1iZXIoKVxufSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInNsb3ROb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFNsb3ROb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgc3Vic2NyaXB0aW9uOiBudW1iZXIoKSxcbiAgcmVzdWx0OiBTbG90SW5mb1Jlc3VsdFxufSk7XG5cbi8qKlxuICogU2xvdCB1cGRhdGVzIHdoaWNoIGNhbiBiZSB1c2VkIGZvciB0cmFja2luZyB0aGUgbGl2ZSBwcm9ncmVzcyBvZiBhIGNsdXN0ZXIuXG4gKiAtIGBcImZpcnN0U2hyZWRSZWNlaXZlZFwiYDogY29ubmVjdGVkIG5vZGUgcmVjZWl2ZWQgdGhlIGZpcnN0IHNocmVkIG9mIGEgYmxvY2suXG4gKiBJbmRpY2F0ZXMgdGhhdCBhIG5ldyBibG9jayB0aGF0IGlzIGJlaW5nIHByb2R1Y2VkLlxuICogLSBgXCJjb21wbGV0ZWRcImA6IGNvbm5lY3RlZCBub2RlIGhhcyByZWNlaXZlZCBhbGwgc2hyZWRzIG9mIGEgYmxvY2suIEluZGljYXRlc1xuICogYSBibG9jayB3YXMgcmVjZW50bHkgcHJvZHVjZWQuXG4gKiAtIGBcIm9wdGltaXN0aWNDb25maXJtYXRpb25cImA6IGJsb2NrIHdhcyBvcHRpbWlzdGljYWxseSBjb25maXJtZWQgYnkgdGhlXG4gKiBjbHVzdGVyLiBJdCBpcyBub3QgZ3VhcmFudGVlZCB0aGF0IGFuIG9wdGltaXN0aWMgY29uZmlybWF0aW9uIG5vdGlmaWNhdGlvblxuICogd2lsbCBiZSBzZW50IGZvciBldmVyeSBmaW5hbGl6ZWQgYmxvY2tzLlxuICogLSBgXCJyb290XCJgOiB0aGUgY29ubmVjdGVkIG5vZGUgcm9vdGVkIHRoaXMgYmxvY2suXG4gKiAtIGBcImNyZWF0ZWRCYW5rXCJgOiB0aGUgY29ubmVjdGVkIG5vZGUgaGFzIHN0YXJ0ZWQgdmFsaWRhdGluZyB0aGlzIGJsb2NrLlxuICogLSBgXCJmcm96ZW5cImA6IHRoZSBjb25uZWN0ZWQgbm9kZSBoYXMgdmFsaWRhdGVkIHRoaXMgYmxvY2suXG4gKiAtIGBcImRlYWRcImA6IHRoZSBjb25uZWN0ZWQgbm9kZSBmYWlsZWQgdG8gdmFsaWRhdGUgdGhpcyBibG9jay5cbiAqL1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTbG90VXBkYXRlUmVzdWx0ID0gdW5pb24oW3R5cGUoe1xuICB0eXBlOiB1bmlvbihbbGl0ZXJhbCgnZmlyc3RTaHJlZFJlY2VpdmVkJyksIGxpdGVyYWwoJ2NvbXBsZXRlZCcpLCBsaXRlcmFsKCdvcHRpbWlzdGljQ29uZmlybWF0aW9uJyksIGxpdGVyYWwoJ3Jvb3QnKV0pLFxuICBzbG90OiBudW1iZXIoKSxcbiAgdGltZXN0YW1wOiBudW1iZXIoKVxufSksIHR5cGUoe1xuICB0eXBlOiBsaXRlcmFsKCdjcmVhdGVkQmFuaycpLFxuICBwYXJlbnQ6IG51bWJlcigpLFxuICBzbG90OiBudW1iZXIoKSxcbiAgdGltZXN0YW1wOiBudW1iZXIoKVxufSksIHR5cGUoe1xuICB0eXBlOiBsaXRlcmFsKCdmcm96ZW4nKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIHRpbWVzdGFtcDogbnVtYmVyKCksXG4gIHN0YXRzOiB0eXBlKHtcbiAgICBudW1UcmFuc2FjdGlvbkVudHJpZXM6IG51bWJlcigpLFxuICAgIG51bVN1Y2Nlc3NmdWxUcmFuc2FjdGlvbnM6IG51bWJlcigpLFxuICAgIG51bUZhaWxlZFRyYW5zYWN0aW9uczogbnVtYmVyKCksXG4gICAgbWF4VHJhbnNhY3Rpb25zUGVyRW50cnk6IG51bWJlcigpXG4gIH0pXG59KSwgdHlwZSh7XG4gIHR5cGU6IGxpdGVyYWwoJ2RlYWQnKSxcbiAgc2xvdDogbnVtYmVyKCksXG4gIHRpbWVzdGFtcDogbnVtYmVyKCksXG4gIGVycjogc3RyaW5nKClcbn0pXSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInNsb3RzVXBkYXRlc05vdGlmaWNhdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgU2xvdFVwZGF0ZU5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IFNsb3RVcGRhdGVSZXN1bHRcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJzaWduYXR1cmVOb3RpZmljYXRpb25cIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFNpZ25hdHVyZU5vdGlmaWNhdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzdWJzY3JpcHRpb246IG51bWJlcigpLFxuICByZXN1bHQ6IG5vdGlmaWNhdGlvblJlc3VsdEFuZENvbnRleHQodW5pb24oW1NpZ25hdHVyZVN0YXR1c1Jlc3VsdCwgU2lnbmF0dXJlUmVjZWl2ZWRSZXN1bHRdKSlcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJyb290Tm90aWZpY2F0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBSb290Tm90aWZpY2F0aW9uUmVzdWx0ID0gdHlwZSh7XG4gIHN1YnNjcmlwdGlvbjogbnVtYmVyKCksXG4gIHJlc3VsdDogbnVtYmVyKClcbn0pO1xuY29uc3QgQ29udGFjdEluZm9SZXN1bHQgPSB0eXBlKHtcbiAgcHVia2V5OiBzdHJpbmcoKSxcbiAgZ29zc2lwOiBudWxsYWJsZShzdHJpbmcoKSksXG4gIHRwdTogbnVsbGFibGUoc3RyaW5nKCkpLFxuICBycGM6IG51bGxhYmxlKHN0cmluZygpKSxcbiAgdmVyc2lvbjogbnVsbGFibGUoc3RyaW5nKCkpXG59KTtcbmNvbnN0IFZvdGVBY2NvdW50SW5mb1Jlc3VsdCA9IHR5cGUoe1xuICB2b3RlUHVia2V5OiBzdHJpbmcoKSxcbiAgbm9kZVB1YmtleTogc3RyaW5nKCksXG4gIGFjdGl2YXRlZFN0YWtlOiBudW1iZXIoKSxcbiAgZXBvY2hWb3RlQWNjb3VudDogYm9vbGVhbigpLFxuICBlcG9jaENyZWRpdHM6IGFycmF5KHR1cGxlKFtudW1iZXIoKSwgbnVtYmVyKCksIG51bWJlcigpXSkpLFxuICBjb21taXNzaW9uOiBudW1iZXIoKSxcbiAgbGFzdFZvdGU6IG51bWJlcigpLFxuICByb290U2xvdDogbnVsbGFibGUobnVtYmVyKCkpXG59KTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0Vm90ZUFjY291bnRzXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRWb3RlQWNjb3VudHMgPSBqc29uUnBjUmVzdWx0KHR5cGUoe1xuICBjdXJyZW50OiBhcnJheShWb3RlQWNjb3VudEluZm9SZXN1bHQpLFxuICBkZWxpbnF1ZW50OiBhcnJheShWb3RlQWNjb3VudEluZm9SZXN1bHQpXG59KSk7XG5jb25zdCBDb25maXJtYXRpb25TdGF0dXMgPSB1bmlvbihbbGl0ZXJhbCgncHJvY2Vzc2VkJyksIGxpdGVyYWwoJ2NvbmZpcm1lZCcpLCBsaXRlcmFsKCdmaW5hbGl6ZWQnKV0pO1xuY29uc3QgU2lnbmF0dXJlU3RhdHVzUmVzcG9uc2UgPSB0eXBlKHtcbiAgc2xvdDogbnVtYmVyKCksXG4gIGNvbmZpcm1hdGlvbnM6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgZXJyOiBUcmFuc2FjdGlvbkVycm9yUmVzdWx0LFxuICBjb25maXJtYXRpb25TdGF0dXM6IG9wdGlvbmFsKENvbmZpcm1hdGlvblN0YXR1cylcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRTaWduYXR1cmVTdGF0dXNlc1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0U2lnbmF0dXJlU3RhdHVzZXNScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheShudWxsYWJsZShTaWduYXR1cmVTdGF0dXNSZXNwb25zZSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0TWluaW11bUJhbGFuY2VGb3JSZW50RXhlbXB0aW9uXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb25ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bWJlcigpKTtcbmNvbnN0IEFkZHJlc3NUYWJsZUxvb2t1cFN0cnVjdCA9IHR5cGUoe1xuICBhY2NvdW50S2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICB3cml0YWJsZUluZGV4ZXM6IGFycmF5KG51bWJlcigpKSxcbiAgcmVhZG9ubHlJbmRleGVzOiBhcnJheShudW1iZXIoKSlcbn0pO1xuY29uc3QgQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQgPSB0eXBlKHtcbiAgc2lnbmF0dXJlczogYXJyYXkoc3RyaW5nKCkpLFxuICBtZXNzYWdlOiB0eXBlKHtcbiAgICBhY2NvdW50S2V5czogYXJyYXkoc3RyaW5nKCkpLFxuICAgIGhlYWRlcjogdHlwZSh7XG4gICAgICBudW1SZXF1aXJlZFNpZ25hdHVyZXM6IG51bWJlcigpLFxuICAgICAgbnVtUmVhZG9ubHlTaWduZWRBY2NvdW50czogbnVtYmVyKCksXG4gICAgICBudW1SZWFkb25seVVuc2lnbmVkQWNjb3VudHM6IG51bWJlcigpXG4gICAgfSksXG4gICAgaW5zdHJ1Y3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICAgIGFjY291bnRzOiBhcnJheShudW1iZXIoKSksXG4gICAgICBkYXRhOiBzdHJpbmcoKSxcbiAgICAgIHByb2dyYW1JZEluZGV4OiBudW1iZXIoKVxuICAgIH0pKSxcbiAgICByZWNlbnRCbG9ja2hhc2g6IHN0cmluZygpLFxuICAgIGFkZHJlc3NUYWJsZUxvb2t1cHM6IG9wdGlvbmFsKGFycmF5KEFkZHJlc3NUYWJsZUxvb2t1cFN0cnVjdCkpXG4gIH0pXG59KTtcbmNvbnN0IEFubm90YXRlZEFjY291bnRLZXkgPSB0eXBlKHtcbiAgcHVia2V5OiBQdWJsaWNLZXlGcm9tU3RyaW5nLFxuICBzaWduZXI6IGJvb2xlYW4oKSxcbiAgd3JpdGFibGU6IGJvb2xlYW4oKSxcbiAgc291cmNlOiBvcHRpb25hbCh1bmlvbihbbGl0ZXJhbCgndHJhbnNhY3Rpb24nKSwgbGl0ZXJhbCgnbG9va3VwVGFibGUnKV0pKVxufSk7XG5jb25zdCBDb25maXJtZWRUcmFuc2FjdGlvbkFjY291bnRzTW9kZVJlc3VsdCA9IHR5cGUoe1xuICBhY2NvdW50S2V5czogYXJyYXkoQW5ub3RhdGVkQWNjb3VudEtleSksXG4gIHNpZ25hdHVyZXM6IGFycmF5KHN0cmluZygpKVxufSk7XG5jb25zdCBQYXJzZWRJbnN0cnVjdGlvblJlc3VsdCA9IHR5cGUoe1xuICBwYXJzZWQ6IHVua25vd24oKSxcbiAgcHJvZ3JhbTogc3RyaW5nKCksXG4gIHByb2dyYW1JZDogUHVibGljS2V5RnJvbVN0cmluZ1xufSk7XG5jb25zdCBSYXdJbnN0cnVjdGlvblJlc3VsdCA9IHR5cGUoe1xuICBhY2NvdW50czogYXJyYXkoUHVibGljS2V5RnJvbVN0cmluZyksXG4gIGRhdGE6IHN0cmluZygpLFxuICBwcm9ncmFtSWQ6IFB1YmxpY0tleUZyb21TdHJpbmdcbn0pO1xuY29uc3QgSW5zdHJ1Y3Rpb25SZXN1bHQgPSB1bmlvbihbUmF3SW5zdHJ1Y3Rpb25SZXN1bHQsIFBhcnNlZEluc3RydWN0aW9uUmVzdWx0XSk7XG5jb25zdCBVbmtub3duSW5zdHJ1Y3Rpb25SZXN1bHQgPSB1bmlvbihbdHlwZSh7XG4gIHBhcnNlZDogdW5rbm93bigpLFxuICBwcm9ncmFtOiBzdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBzdHJpbmcoKVxufSksIHR5cGUoe1xuICBhY2NvdW50czogYXJyYXkoc3RyaW5nKCkpLFxuICBkYXRhOiBzdHJpbmcoKSxcbiAgcHJvZ3JhbUlkOiBzdHJpbmcoKVxufSldKTtcbmNvbnN0IFBhcnNlZE9yUmF3SW5zdHJ1Y3Rpb24gPSBjb2VyY2UoSW5zdHJ1Y3Rpb25SZXN1bHQsIFVua25vd25JbnN0cnVjdGlvblJlc3VsdCwgdmFsdWUgPT4ge1xuICBpZiAoJ2FjY291bnRzJyBpbiB2YWx1ZSkge1xuICAgIHJldHVybiBjcmVhdGUodmFsdWUsIFJhd0luc3RydWN0aW9uUmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCBQYXJzZWRJbnN0cnVjdGlvblJlc3VsdCk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCA9IHR5cGUoe1xuICBzaWduYXR1cmVzOiBhcnJheShzdHJpbmcoKSksXG4gIG1lc3NhZ2U6IHR5cGUoe1xuICAgIGFjY291bnRLZXlzOiBhcnJheShBbm5vdGF0ZWRBY2NvdW50S2V5KSxcbiAgICBpbnN0cnVjdGlvbnM6IGFycmF5KFBhcnNlZE9yUmF3SW5zdHJ1Y3Rpb24pLFxuICAgIHJlY2VudEJsb2NraGFzaDogc3RyaW5nKCksXG4gICAgYWRkcmVzc1RhYmxlTG9va3Vwczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoQWRkcmVzc1RhYmxlTG9va3VwU3RydWN0KSkpXG4gIH0pXG59KTtcbmNvbnN0IFRva2VuQmFsYW5jZVJlc3VsdCA9IHR5cGUoe1xuICBhY2NvdW50SW5kZXg6IG51bWJlcigpLFxuICBtaW50OiBzdHJpbmcoKSxcbiAgb3duZXI6IG9wdGlvbmFsKHN0cmluZygpKSxcbiAgdWlUb2tlbkFtb3VudDogVG9rZW5BbW91bnRSZXN1bHRcbn0pO1xuY29uc3QgTG9hZGVkQWRkcmVzc2VzUmVzdWx0ID0gdHlwZSh7XG4gIHdyaXRhYmxlOiBhcnJheShQdWJsaWNLZXlGcm9tU3RyaW5nKSxcbiAgcmVhZG9ubHk6IGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpXG59KTtcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0ID0gdHlwZSh7XG4gIGVycjogVHJhbnNhY3Rpb25FcnJvclJlc3VsdCxcbiAgZmVlOiBudW1iZXIoKSxcbiAgaW5uZXJJbnN0cnVjdGlvbnM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KHR5cGUoe1xuICAgIGluZGV4OiBudW1iZXIoKSxcbiAgICBpbnN0cnVjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgICAgYWNjb3VudHM6IGFycmF5KG51bWJlcigpKSxcbiAgICAgIGRhdGE6IHN0cmluZygpLFxuICAgICAgcHJvZ3JhbUlkSW5kZXg6IG51bWJlcigpXG4gICAgfSkpXG4gIH0pKSkpLFxuICBwcmVCYWxhbmNlczogYXJyYXkobnVtYmVyKCkpLFxuICBwb3N0QmFsYW5jZXM6IGFycmF5KG51bWJlcigpKSxcbiAgbG9nTWVzc2FnZXM6IG9wdGlvbmFsKG51bGxhYmxlKGFycmF5KHN0cmluZygpKSkpLFxuICBwcmVUb2tlbkJhbGFuY2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIHBvc3RUb2tlbkJhbGFuY2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShUb2tlbkJhbGFuY2VSZXN1bHQpKSksXG4gIGxvYWRlZEFkZHJlc3Nlczogb3B0aW9uYWwoTG9hZGVkQWRkcmVzc2VzUmVzdWx0KSxcbiAgY29tcHV0ZVVuaXRzQ29uc3VtZWQ6IG9wdGlvbmFsKG51bWJlcigpKVxufSk7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uTWV0YVJlc3VsdCA9IHR5cGUoe1xuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIGZlZTogbnVtYmVyKCksXG4gIGlubmVySW5zdHJ1Y3Rpb25zOiBvcHRpb25hbChudWxsYWJsZShhcnJheSh0eXBlKHtcbiAgICBpbmRleDogbnVtYmVyKCksXG4gICAgaW5zdHJ1Y3Rpb25zOiBhcnJheShQYXJzZWRPclJhd0luc3RydWN0aW9uKVxuICB9KSkpKSxcbiAgcHJlQmFsYW5jZXM6IGFycmF5KG51bWJlcigpKSxcbiAgcG9zdEJhbGFuY2VzOiBhcnJheShudW1iZXIoKSksXG4gIGxvZ01lc3NhZ2VzOiBvcHRpb25hbChudWxsYWJsZShhcnJheShzdHJpbmcoKSkpKSxcbiAgcHJlVG9rZW5CYWxhbmNlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoVG9rZW5CYWxhbmNlUmVzdWx0KSkpLFxuICBwb3N0VG9rZW5CYWxhbmNlczogb3B0aW9uYWwobnVsbGFibGUoYXJyYXkoVG9rZW5CYWxhbmNlUmVzdWx0KSkpLFxuICBsb2FkZWRBZGRyZXNzZXM6IG9wdGlvbmFsKExvYWRlZEFkZHJlc3Nlc1Jlc3VsdCksXG4gIGNvbXB1dGVVbml0c0NvbnN1bWVkOiBvcHRpb25hbChudW1iZXIoKSlcbn0pO1xuY29uc3QgVHJhbnNhY3Rpb25WZXJzaW9uU3RydWN0ID0gdW5pb24oW2xpdGVyYWwoMCksIGxpdGVyYWwoJ2xlZ2FjeScpXSk7XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmNvbnN0IFJld2FyZHNSZXN1bHQgPSB0eXBlKHtcbiAgcHVia2V5OiBzdHJpbmcoKSxcbiAgbGFtcG9ydHM6IG51bWJlcigpLFxuICBwb3N0QmFsYW5jZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICByZXdhcmRUeXBlOiBudWxsYWJsZShzdHJpbmcoKSksXG4gIGNvbW1pc3Npb246IG9wdGlvbmFsKG51bGxhYmxlKG51bWJlcigpKSlcbn0pO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0QmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvblJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbiAgfSkpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRCbG9ja1wiIG1lc3NhZ2Ugd2hlbiBgdHJhbnNhY3Rpb25EZXRhaWxzYCBpcyBgbm9uZWBcbiAqL1xuY29uc3QgR2V0Tm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSB3aGVuIGB0cmFuc2FjdGlvbkRldGFpbHNgIGlzIGBhY2NvdW50c2BcbiAqL1xuY29uc3QgR2V0QWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICB0cmFuc2FjdGlvbnM6IGFycmF5KHR5cGUoe1xuICAgIHRyYW5zYWN0aW9uOiBDb25maXJtZWRUcmFuc2FjdGlvbkFjY291bnRzTW9kZVJlc3VsdCxcbiAgICBtZXRhOiBudWxsYWJsZShDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICAgIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbiAgfSkpLFxuICByZXdhcmRzOiBvcHRpb25hbChhcnJheShSZXdhcmRzUmVzdWx0KSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpLFxuICBibG9ja0hlaWdodDogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIHBhcnNlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0QmxvY2tcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFBhcnNlZEJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgdHJhbnNhY3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICB0cmFuc2FjdGlvbjogUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gICAgbWV0YTogbnVsbGFibGUoUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KSxcbiAgICB2ZXJzaW9uOiBvcHRpb25hbChUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QpXG4gIH0pKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBwYXJzZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSAgd2hlbiBgdHJhbnNhY3Rpb25EZXRhaWxzYCBpcyBgYWNjb3VudHNgXG4gKi9cbmNvbnN0IEdldFBhcnNlZEFjY291bnRzTW9kZUJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgdHJhbnNhY3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICB0cmFuc2FjdGlvbjogQ29uZmlybWVkVHJhbnNhY3Rpb25BY2NvdW50c01vZGVSZXN1bHQsXG4gICAgbWV0YTogbnVsbGFibGUoUGFyc2VkQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KSxcbiAgICB2ZXJzaW9uOiBvcHRpb25hbChUcmFuc2FjdGlvblZlcnNpb25TdHJ1Y3QpXG4gIH0pKSxcbiAgcmV3YXJkczogb3B0aW9uYWwoYXJyYXkoUmV3YXJkc1Jlc3VsdCkpLFxuICBibG9ja1RpbWU6IG51bGxhYmxlKG51bWJlcigpKSxcbiAgYmxvY2tIZWlnaHQ6IG51bGxhYmxlKG51bWJlcigpKVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBwYXJzZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZSAgd2hlbiBgdHJhbnNhY3Rpb25EZXRhaWxzYCBpcyBgbm9uZWBcbiAqL1xuY29uc3QgR2V0UGFyc2VkTm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQobnVsbGFibGUodHlwZSh7XG4gIGJsb2NraGFzaDogc3RyaW5nKCksXG4gIHByZXZpb3VzQmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcGFyZW50U2xvdDogbnVtYmVyKCksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSksXG4gIGJsb2NrSGVpZ2h0OiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldENvbmZpcm1lZEJsb2NrXCIgbWVzc2FnZVxuICpcbiAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgR2V0QmxvY2tScGNSZXN1bHR9IGluc3RlYWQuXG4gKi9cbmNvbnN0IEdldENvbmZpcm1lZEJsb2NrUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChudWxsYWJsZSh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgcHJldmlvdXNCbG9ja2hhc2g6IHN0cmluZygpLFxuICBwYXJlbnRTbG90OiBudW1iZXIoKSxcbiAgdHJhbnNhY3Rpb25zOiBhcnJheSh0eXBlKHtcbiAgICB0cmFuc2FjdGlvbjogQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gICAgbWV0YTogbnVsbGFibGUoQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KVxuICB9KSksXG4gIHJld2FyZHM6IG9wdGlvbmFsKGFycmF5KFJld2FyZHNSZXN1bHQpKSxcbiAgYmxvY2tUaW1lOiBudWxsYWJsZShudW1iZXIoKSlcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldEJsb2NrXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRCbG9ja1NpZ25hdHVyZXNScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBwcmV2aW91c0Jsb2NraGFzaDogc3RyaW5nKCksXG4gIHBhcmVudFNsb3Q6IG51bWJlcigpLFxuICBzaWduYXR1cmVzOiBhcnJheShzdHJpbmcoKSksXG4gIGJsb2NrVGltZTogbnVsbGFibGUobnVtYmVyKCkpXG59KSkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUcmFuc2FjdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBzbG90OiBudW1iZXIoKSxcbiAgbWV0YTogbnVsbGFibGUoQ29uZmlybWVkVHJhbnNhY3Rpb25NZXRhUmVzdWx0KSxcbiAgYmxvY2tUaW1lOiBvcHRpb25hbChudWxsYWJsZShudW1iZXIoKSkpLFxuICB0cmFuc2FjdGlvbjogQ29uZmlybWVkVHJhbnNhY3Rpb25SZXN1bHQsXG4gIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgcGFyc2VkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRUcmFuc2FjdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0KG51bGxhYmxlKHR5cGUoe1xuICBzbG90OiBudW1iZXIoKSxcbiAgdHJhbnNhY3Rpb246IFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9uUmVzdWx0LFxuICBtZXRhOiBudWxsYWJsZShQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbk1ldGFSZXN1bHQpLFxuICBibG9ja1RpbWU6IG9wdGlvbmFsKG51bGxhYmxlKG51bWJlcigpKSksXG4gIHZlcnNpb246IG9wdGlvbmFsKFRyYW5zYWN0aW9uVmVyc2lvblN0cnVjdClcbn0pKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImdldFJlY2VudEJsb2NraGFzaFwiIG1lc3NhZ2VcbiAqXG4gKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIEdldExhdGVzdEJsb2NraGFzaFJwY1Jlc3VsdH0gaW5zdGVhZC5cbiAqL1xuY29uc3QgR2V0UmVjZW50QmxvY2toYXNoQW5kQ29udGV4dFJwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KHR5cGUoe1xuICBibG9ja2hhc2g6IHN0cmluZygpLFxuICBmZWVDYWxjdWxhdG9yOiB0eXBlKHtcbiAgICBsYW1wb3J0c1BlclNpZ25hdHVyZTogbnVtYmVyKClcbiAgfSlcbn0pKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwiZ2V0TGF0ZXN0QmxvY2toYXNoXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRMYXRlc3RCbG9ja2hhc2hScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dCh0eXBlKHtcbiAgYmxvY2toYXNoOiBzdHJpbmcoKSxcbiAgbGFzdFZhbGlkQmxvY2tIZWlnaHQ6IG51bWJlcigpXG59KSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcImlzQmxvY2toYXNoVmFsaWRcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IElzQmxvY2toYXNoVmFsaWRScGNSZXN1bHQgPSBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChib29sZWFuKCkpO1xuY29uc3QgUGVyZlNhbXBsZVJlc3VsdCA9IHR5cGUoe1xuICBzbG90OiBudW1iZXIoKSxcbiAgbnVtVHJhbnNhY3Rpb25zOiBudW1iZXIoKSxcbiAgbnVtU2xvdHM6IG51bWJlcigpLFxuICBzYW1wbGVQZXJpb2RTZWNzOiBudW1iZXIoKVxufSk7XG5cbi8qXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgXCJnZXRSZWNlbnRQZXJmb3JtYW5jZVNhbXBsZXNcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IEdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1JwY1Jlc3VsdCA9IGpzb25ScGNSZXN1bHQoYXJyYXkoUGVyZlNhbXBsZVJlc3VsdCkpO1xuXG4vKipcbiAqIEV4cGVjdGVkIEpTT04gUlBDIHJlc3BvbnNlIGZvciB0aGUgXCJnZXRGZWVDYWxjdWxhdG9yRm9yQmxvY2toYXNoXCIgbWVzc2FnZVxuICovXG5jb25zdCBHZXRGZWVDYWxjdWxhdG9yUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVsbGFibGUodHlwZSh7XG4gIGZlZUNhbGN1bGF0b3I6IHR5cGUoe1xuICAgIGxhbXBvcnRzUGVyU2lnbmF0dXJlOiBudW1iZXIoKVxuICB9KVxufSkpKTtcblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwicmVxdWVzdEFpcmRyb3BcIiBtZXNzYWdlXG4gKi9cbmNvbnN0IFJlcXVlc3RBaXJkcm9wUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChzdHJpbmcoKSk7XG5cbi8qKlxuICogRXhwZWN0ZWQgSlNPTiBSUEMgcmVzcG9uc2UgZm9yIHRoZSBcInNlbmRUcmFuc2FjdGlvblwiIG1lc3NhZ2VcbiAqL1xuY29uc3QgU2VuZFRyYW5zYWN0aW9uUnBjUmVzdWx0ID0ganNvblJwY1Jlc3VsdChzdHJpbmcoKSk7XG5cbi8qKlxuICogSW5mb3JtYXRpb24gYWJvdXQgdGhlIGxhdGVzdCBzbG90IGJlaW5nIHByb2Nlc3NlZCBieSBhIG5vZGVcbiAqL1xuXG4vKipcbiAqIFBhcnNlZCBhY2NvdW50IGRhdGFcbiAqL1xuXG4vKipcbiAqIFN0YWtlIEFjdGl2YXRpb24gZGF0YVxuICovXG5cbi8qKlxuICogRGF0YSBzbGljZSBhcmd1bWVudCBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBNZW1vcnkgY29tcGFyaXNvbiBmaWx0ZXIgZm9yIGdldFByb2dyYW1BY2NvdW50c1xuICovXG5cbi8qKlxuICogRGF0YSBzaXplIGNvbXBhcmlzb24gZmlsdGVyIGZvciBnZXRQcm9ncmFtQWNjb3VudHNcbiAqL1xuXG4vKipcbiAqIEEgZmlsdGVyIG9iamVjdCBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgZ2V0UHJvZ3JhbUFjY291bnRzIHJlcXVlc3RzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgZ2V0UGFyc2VkUHJvZ3JhbUFjY291bnRzXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgZ2V0TXVsdGlwbGVBY2NvdW50c1xuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXRTdGFrZUFjdGl2YXRpb25gXG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIG9iamVjdCBmb3IgYGdldFN0YWtlQWN0aXZhdGlvbmBcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0U3Rha2VBY3RpdmF0aW9uYFxuICovXG5cbi8qKlxuICogQ29uZmlndXJhdGlvbiBvYmplY3QgZm9yIGBnZXROb25jZWBcbiAqL1xuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gb2JqZWN0IGZvciBgZ2V0Tm9uY2VBbmRDb250ZXh0YFxuICovXG5cbi8qKlxuICogSW5mb3JtYXRpb24gZGVzY3JpYmluZyBhbiBhY2NvdW50XG4gKi9cblxuLyoqXG4gKiBBY2NvdW50IGluZm9ybWF0aW9uIGlkZW50aWZpZWQgYnkgcHVia2V5XG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3IgYWNjb3VudCBjaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHByb2dyYW0gYWNjb3VudCBjaGFuZ2Ugbm90aWZpY2F0aW9uc1xuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNsb3QgY2hhbmdlIG5vdGlmaWNhdGlvbnNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciBzbG90IHVwZGF0ZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBDYWxsYmFjayBmdW5jdGlvbiBmb3Igc2lnbmF0dXJlIHN0YXR1cyBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgc3RhdHVzIG5vdGlmaWNhdGlvbiB3aXRoIHRyYW5zYWN0aW9uIHJlc3VsdFxuICovXG5cbi8qKlxuICogU2lnbmF0dXJlIHJlY2VpdmVkIG5vdGlmaWNhdGlvblxuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIHNpZ25hdHVyZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBTaWduYXR1cmUgc3Vic2NyaXB0aW9uIG9wdGlvbnNcbiAqL1xuXG4vKipcbiAqIENhbGxiYWNrIGZ1bmN0aW9uIGZvciByb290IGNoYW5nZSBub3RpZmljYXRpb25zXG4gKi9cblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgTG9nc1Jlc3VsdCA9IHR5cGUoe1xuICBlcnI6IFRyYW5zYWN0aW9uRXJyb3JSZXN1bHQsXG4gIGxvZ3M6IGFycmF5KHN0cmluZygpKSxcbiAgc2lnbmF0dXJlOiBzdHJpbmcoKVxufSk7XG5cbi8qKlxuICogTG9ncyByZXN1bHQuXG4gKi9cblxuLyoqXG4gKiBFeHBlY3RlZCBKU09OIFJQQyByZXNwb25zZSBmb3IgdGhlIFwibG9nc05vdGlmaWNhdGlvblwiIG1lc3NhZ2UuXG4gKi9cbmNvbnN0IExvZ3NOb3RpZmljYXRpb25SZXN1bHQgPSB0eXBlKHtcbiAgcmVzdWx0OiBub3RpZmljYXRpb25SZXN1bHRBbmRDb250ZXh0KExvZ3NSZXN1bHQpLFxuICBzdWJzY3JpcHRpb246IG51bWJlcigpXG59KTtcblxuLyoqXG4gKiBGaWx0ZXIgZm9yIGxvZyBzdWJzY3JpcHRpb25zLlxuICovXG5cbi8qKlxuICogQ2FsbGJhY2sgZnVuY3Rpb24gZm9yIGxvZyBub3RpZmljYXRpb25zLlxuICovXG5cbi8qKlxuICogU2lnbmF0dXJlIHJlc3VsdFxuICovXG5cbi8qKlxuICogVHJhbnNhY3Rpb24gZXJyb3JcbiAqL1xuXG4vKipcbiAqIFRyYW5zYWN0aW9uIGNvbmZpcm1hdGlvbiBzdGF0dXNcbiAqIDxwcmU+XG4gKiAgICdwcm9jZXNzZWQnOiBUcmFuc2FjdGlvbiBsYW5kZWQgaW4gYSBibG9jayB3aGljaCBoYXMgcmVhY2hlZCAxIGNvbmZpcm1hdGlvbiBieSB0aGUgY29ubmVjdGVkIG5vZGVcbiAqICAgJ2NvbmZpcm1lZCc6IFRyYW5zYWN0aW9uIGxhbmRlZCBpbiBhIGJsb2NrIHdoaWNoIGhhcyByZWFjaGVkIDEgY29uZmlybWF0aW9uIGJ5IHRoZSBjbHVzdGVyXG4gKiAgICdmaW5hbGl6ZWQnOiBUcmFuc2FjdGlvbiBsYW5kZWQgaW4gYSBibG9jayB3aGljaCBoYXMgYmVlbiBmaW5hbGl6ZWQgYnkgdGhlIGNsdXN0ZXJcbiAqIDwvcHJlPlxuICovXG5cbi8qKlxuICogU2lnbmF0dXJlIHN0YXR1c1xuICovXG5cbi8qKlxuICogQSBjb25maXJtZWQgc2lnbmF0dXJlIHdpdGggaXRzIHN0YXR1c1xuICovXG5cbi8qKlxuICogQW4gb2JqZWN0IGRlZmluaW5nIGhlYWRlcnMgdG8gYmUgcGFzc2VkIHRvIHRoZSBSUEMgc2VydmVyXG4gKi9cblxuLyoqXG4gKiBUaGUgdHlwZSBvZiB0aGUgSmF2YVNjcmlwdCBgZmV0Y2goKWAgQVBJXG4gKi9cblxuLyoqXG4gKiBBIGNhbGxiYWNrIHVzZWQgdG8gYXVnbWVudCB0aGUgb3V0Z29pbmcgSFRUUCByZXF1ZXN0XG4gKi9cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBpbnN0YW50aWF0aW5nIGEgQ29ubmVjdGlvblxuICovXG5cbi8qKiBAaW50ZXJuYWwgKi9cbmNvbnN0IENPTU1PTl9IVFRQX0hFQURFUlMgPSB7XG4gICdzb2xhbmEtY2xpZW50JzogYGpzLyR7XCIwLjAuMC1kZXZlbG9wbWVudFwiIH1gXG59O1xuXG4vKipcbiAqIEEgY29ubmVjdGlvbiB0byBhIGZ1bGxub2RlIEpTT04gUlBDIGVuZHBvaW50XG4gKi9cbmNsYXNzIENvbm5lY3Rpb24ge1xuICAvKipcbiAgICogRXN0YWJsaXNoIGEgSlNPTiBSUEMgY29ubmVjdGlvblxuICAgKlxuICAgKiBAcGFyYW0gZW5kcG9pbnQgVVJMIHRvIHRoZSBmdWxsbm9kZSBKU09OIFJQQyBlbmRwb2ludFxuICAgKiBAcGFyYW0gY29tbWl0bWVudE9yQ29uZmlnIG9wdGlvbmFsIGRlZmF1bHQgY29tbWl0bWVudCBsZXZlbCBvciBvcHRpb25hbCBDb25uZWN0aW9uQ29uZmlnIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gICAqL1xuICBjb25zdHJ1Y3RvcihlbmRwb2ludCwgX2NvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9jb21taXRtZW50ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjRW5kcG9pbnQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dzRW5kcG9pbnQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY0NsaWVudCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjUmVxdWVzdCA9IHZvaWQgMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcnBjQmF0Y2hSZXF1ZXN0ID0gdm9pZCAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQgPSB2b2lkIDA7XG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQgPSBudWxsO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IG51bGw7XG4gICAgLyoqIEBpbnRlcm5hbFxuICAgICAqIEEgbnVtYmVyIHRoYXQgd2UgaW5jcmVtZW50IGV2ZXJ5IHRpbWUgYW4gYWN0aXZlIGNvbm5lY3Rpb24gY2xvc2VzLlxuICAgICAqIFVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIHNhbWUgc29ja2V0IGNvbm5lY3Rpb24gdGhhdCB3YXMgb3BlblxuICAgICAqIHdoZW4gYW4gYXN5bmMgb3BlcmF0aW9uIHN0YXJ0ZWQgaXMgdGhlIHNhbWUgb25lIHRoYXQncyBhY3RpdmUgd2hlblxuICAgICAqIGl0cyBjb250aW51YXRpb24gZmlyZXMuXG4gICAgICpcbiAgICAgKi9cbiAgICB0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uID0gMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fZGlzYWJsZUJsb2NraGFzaENhY2hpbmcgPSBmYWxzZTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fcG9sbGluZ0Jsb2NraGFzaCA9IGZhbHNlO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9ibG9ja2hhc2hJbmZvID0ge1xuICAgICAgbGF0ZXN0QmxvY2toYXNoOiBudWxsLFxuICAgICAgbGFzdEZldGNoOiAwLFxuICAgICAgdHJhbnNhY3Rpb25TaWduYXR1cmVzOiBbXSxcbiAgICAgIHNpbXVsYXRlZFNpZ25hdHVyZXM6IFtdXG4gICAgfTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fbmV4dENsaWVudFN1YnNjcmlwdGlvbklkID0gMDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWQgPSB7fTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uSGFzaEJ5Q2xpZW50U3Vic2NyaXB0aW9uSWQgPSB7fTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2ggPSB7fTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZCA9IHt9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoID0ge307XG4gICAgLyoqXG4gICAgICogU3BlY2lhbCBjYXNlLlxuICAgICAqIEFmdGVyIGEgc2lnbmF0dXJlIGlzIHByb2Nlc3NlZCwgUlBDcyBhdXRvbWF0aWNhbGx5IGRpc3Bvc2Ugb2YgdGhlXG4gICAgICogc3Vic2NyaXB0aW9uIG9uIHRoZSBzZXJ2ZXIgc2lkZS4gV2UgbmVlZCB0byB0cmFjayB3aGljaCBvZiB0aGVzZVxuICAgICAqIHN1YnNjcmlwdGlvbnMgaGF2ZSBiZWVuIGRpc3Bvc2VkIGluIHN1Y2ggYSB3YXksIHNvIHRoYXQgd2Uga25vd1xuICAgICAqIHdoZXRoZXIgdGhlIGNsaWVudCBpcyBkZWFsaW5nIHdpdGggYSBub3QteWV0LXByb2Nlc3NlZCBzaWduYXR1cmVcbiAgICAgKiAoaW4gd2hpY2ggY2FzZSB3ZSBtdXN0IHRlYXIgZG93biB0aGUgc2VydmVyIHN1YnNjcmlwdGlvbikgb3IgYW5cbiAgICAgKiBhbHJlYWR5LXByb2Nlc3NlZCBzaWduYXR1cmUgKGluIHdoaWNoIGNhc2UgdGhlIGNsaWVudCBjYW4gc2ltcGx5XG4gICAgICogY2xlYXIgb3V0IHRoZSBzdWJzY3JpcHRpb24gbG9jYWxseSB3aXRob3V0IHRlbGxpbmcgdGhlIHNlcnZlcikuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGVyZSBpcyBhIHByb3Bvc2FsIHRvIGVsaW1pbmF0ZSB0aGlzIHNwZWNpYWwgY2FzZSwgaGVyZTpcbiAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8xODg5MlxuICAgICAqL1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zQXV0b0Rpc3Bvc2VkQnlScGMgPSBuZXcgU2V0KCk7XG4gICAgLypcbiAgICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IGJsb2NrIGhlaWdodCBvZiB0aGUgbm9kZVxuICAgICAqL1xuICAgIHRoaXMuZ2V0QmxvY2tIZWlnaHQgPSAoKCkgPT4ge1xuICAgICAgY29uc3QgcmVxdWVzdFByb21pc2VzID0ge307XG4gICAgICByZXR1cm4gYXN5bmMgY29tbWl0bWVudE9yQ29uZmlnID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGNvbW1pdG1lbnQsXG4gICAgICAgICAgY29uZmlnXG4gICAgICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgICAgICBjb25zdCByZXF1ZXN0SGFzaCA9IGZhc3RTdGFibGVTdHJpbmdpZnkkMShhcmdzKTtcbiAgICAgICAgcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXSA9IHJlcXVlc3RQcm9taXNlc1tyZXF1ZXN0SGFzaF0gPz8gKGFzeW5jICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tIZWlnaHQnLCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVtYmVyKCkpKTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgYmxvY2sgaGVpZ2h0IGluZm9ybWF0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZGVsZXRlIHJlcXVlc3RQcm9taXNlc1tyZXF1ZXN0SGFzaF07XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgICByZXR1cm4gYXdhaXQgcmVxdWVzdFByb21pc2VzW3JlcXVlc3RIYXNoXTtcbiAgICAgIH07XG4gICAgfSkoKTtcbiAgICBsZXQgd3NFbmRwb2ludDtcbiAgICBsZXQgaHR0cEhlYWRlcnM7XG4gICAgbGV0IGZldGNoO1xuICAgIGxldCBmZXRjaE1pZGRsZXdhcmU7XG4gICAgbGV0IGRpc2FibGVSZXRyeU9uUmF0ZUxpbWl0O1xuICAgIGxldCBodHRwQWdlbnQ7XG4gICAgaWYgKF9jb21taXRtZW50T3JDb25maWcgJiYgdHlwZW9mIF9jb21taXRtZW50T3JDb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aGlzLl9jb21taXRtZW50ID0gX2NvbW1pdG1lbnRPckNvbmZpZztcbiAgICB9IGVsc2UgaWYgKF9jb21taXRtZW50T3JDb25maWcpIHtcbiAgICAgIHRoaXMuX2NvbW1pdG1lbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnLmNvbW1pdG1lbnQ7XG4gICAgICB0aGlzLl9jb25maXJtVHJhbnNhY3Rpb25Jbml0aWFsVGltZW91dCA9IF9jb21taXRtZW50T3JDb25maWcuY29uZmlybVRyYW5zYWN0aW9uSW5pdGlhbFRpbWVvdXQ7XG4gICAgICB3c0VuZHBvaW50ID0gX2NvbW1pdG1lbnRPckNvbmZpZy53c0VuZHBvaW50O1xuICAgICAgaHR0cEhlYWRlcnMgPSBfY29tbWl0bWVudE9yQ29uZmlnLmh0dHBIZWFkZXJzO1xuICAgICAgZmV0Y2ggPSBfY29tbWl0bWVudE9yQ29uZmlnLmZldGNoO1xuICAgICAgZmV0Y2hNaWRkbGV3YXJlID0gX2NvbW1pdG1lbnRPckNvbmZpZy5mZXRjaE1pZGRsZXdhcmU7XG4gICAgICBkaXNhYmxlUmV0cnlPblJhdGVMaW1pdCA9IF9jb21taXRtZW50T3JDb25maWcuZGlzYWJsZVJldHJ5T25SYXRlTGltaXQ7XG4gICAgICBodHRwQWdlbnQgPSBfY29tbWl0bWVudE9yQ29uZmlnLmh0dHBBZ2VudDtcbiAgICB9XG4gICAgdGhpcy5fcnBjRW5kcG9pbnQgPSBhc3NlcnRFbmRwb2ludFVybChlbmRwb2ludCk7XG4gICAgdGhpcy5fcnBjV3NFbmRwb2ludCA9IHdzRW5kcG9pbnQgfHwgbWFrZVdlYnNvY2tldFVybChlbmRwb2ludCk7XG4gICAgdGhpcy5fcnBjQ2xpZW50ID0gY3JlYXRlUnBjQ2xpZW50KGVuZHBvaW50LCBodHRwSGVhZGVycywgZmV0Y2gsIGZldGNoTWlkZGxld2FyZSwgZGlzYWJsZVJldHJ5T25SYXRlTGltaXQsIGh0dHBBZ2VudCk7XG4gICAgdGhpcy5fcnBjUmVxdWVzdCA9IGNyZWF0ZVJwY1JlcXVlc3QodGhpcy5fcnBjQ2xpZW50KTtcbiAgICB0aGlzLl9ycGNCYXRjaFJlcXVlc3QgPSBjcmVhdGVScGNCYXRjaFJlcXVlc3QodGhpcy5fcnBjQ2xpZW50KTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQgPSBuZXcgUnBjV2ViU29ja2V0Q2xpZW50KHRoaXMuX3JwY1dzRW5kcG9pbnQsIHtcbiAgICAgIGF1dG9jb25uZWN0OiBmYWxzZSxcbiAgICAgIG1heF9yZWNvbm5lY3RzOiBJbmZpbml0eVxuICAgIH0pO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignb3BlbicsIHRoaXMuX3dzT25PcGVuLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignZXJyb3InLCB0aGlzLl93c09uRXJyb3IuYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdjbG9zZScsIHRoaXMuX3dzT25DbG9zZS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ2FjY291bnROb3RpZmljYXRpb24nLCB0aGlzLl93c09uQWNjb3VudE5vdGlmaWNhdGlvbi5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLl9ycGNXZWJTb2NrZXQub24oJ3Byb2dyYW1Ob3RpZmljYXRpb24nLCB0aGlzLl93c09uUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdzbG90Tm90aWZpY2F0aW9uJywgdGhpcy5fd3NPblNsb3ROb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdzbG90c1VwZGF0ZXNOb3RpZmljYXRpb24nLCB0aGlzLl93c09uU2xvdFVwZGF0ZXNOb3RpZmljYXRpb24uYmluZCh0aGlzKSk7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0Lm9uKCdzaWduYXR1cmVOb3RpZmljYXRpb24nLCB0aGlzLl93c09uU2lnbmF0dXJlTm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbigncm9vdE5vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25Sb290Tm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldC5vbignbG9nc05vdGlmaWNhdGlvbicsIHRoaXMuX3dzT25Mb2dzTm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBkZWZhdWx0IGNvbW1pdG1lbnQgdXNlZCBmb3IgcmVxdWVzdHNcbiAgICovXG4gIGdldCBjb21taXRtZW50KCkge1xuICAgIHJldHVybiB0aGlzLl9jb21taXRtZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBSUEMgZW5kcG9pbnRcbiAgICovXG4gIGdldCBycGNFbmRwb2ludCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcnBjRW5kcG9pbnQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGJhbGFuY2UgZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleSwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0QmFsYW5jZUFuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwdWJsaWNLZXkudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCYWxhbmNlJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBiYWxhbmNlIGZvciAke3B1YmxpY0tleS50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgYmFsYW5jZSBmb3IgdGhlIHNwZWNpZmllZCBwdWJsaWMga2V5XG4gICAqL1xuICBhc3luYyBnZXRCYWxhbmNlKHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuZ2V0QmFsYW5jZUFuZENvbnRleHQocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpLnRoZW4oeCA9PiB4LnZhbHVlKS5jYXRjaChlID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGdldCBiYWxhbmNlIG9mIGFjY291bnQgJyArIHB1YmxpY0tleS50b0Jhc2U1OCgpICsgJzogJyArIGUpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBlc3RpbWF0ZWQgcHJvZHVjdGlvbiB0aW1lIG9mIGEgYmxvY2tcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrVGltZShzbG90KSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2tUaW1lJywgW3Nsb3RdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KG51bGxhYmxlKG51bWJlcigpKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IGJsb2NrIHRpbWUgZm9yIHNsb3QgJHtzbG90fWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgbG93ZXN0IHNsb3QgdGhhdCB0aGUgbm9kZSBoYXMgaW5mb3JtYXRpb24gYWJvdXQgaW4gaXRzIGxlZGdlci5cbiAgICogVGhpcyB2YWx1ZSBtYXkgaW5jcmVhc2Ugb3ZlciB0aW1lIGlmIHRoZSBub2RlIGlzIGNvbmZpZ3VyZWQgdG8gcHVyZ2Ugb2xkZXIgbGVkZ2VyIGRhdGFcbiAgICovXG4gIGFzeW5jIGdldE1pbmltdW1MZWRnZXJTbG90KCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ21pbmltdW1MZWRnZXJTbG90JywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQobnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBtaW5pbXVtIGxlZGdlciBzbG90Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBzbG90IG9mIHRoZSBsb3dlc3QgY29uZmlybWVkIGJsb2NrIHRoYXQgaGFzIG5vdCBiZWVuIHB1cmdlZCBmcm9tIHRoZSBsZWRnZXJcbiAgICovXG4gIGFzeW5jIGdldEZpcnN0QXZhaWxhYmxlQmxvY2soKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Rmlyc3RBdmFpbGFibGVCbG9jaycsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBTbG90UnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBmaXJzdCBhdmFpbGFibGUgYmxvY2snKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggaW5mb3JtYXRpb24gYWJvdXQgdGhlIGN1cnJlbnQgc3VwcGx5XG4gICAqL1xuICBhc3luYyBnZXRTdXBwbHkoY29uZmlnKSB7XG4gICAgbGV0IGNvbmZpZ0FyZyA9IHt9O1xuICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgY29uZmlnQXJnID0ge1xuICAgICAgICBjb21taXRtZW50OiBjb25maWdcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChjb25maWcpIHtcbiAgICAgIGNvbmZpZ0FyZyA9IHtcbiAgICAgICAgLi4uY29uZmlnLFxuICAgICAgICBjb21taXRtZW50OiBjb25maWcgJiYgY29uZmlnLmNvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25maWdBcmcgPSB7XG4gICAgICAgIGNvbW1pdG1lbnQ6IHRoaXMuY29tbWl0bWVudFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U3VwcGx5JywgW2NvbmZpZ0FyZ10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFN1cHBseVJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc3VwcGx5Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHN1cHBseSBvZiBhIHRva2VuIG1pbnRcbiAgICovXG4gIGFzeW5jIGdldFRva2VuU3VwcGx5KHRva2VuTWludEFkZHJlc3MsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFt0b2tlbk1pbnRBZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRUb2tlblN1cHBseScsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KFRva2VuQW1vdW50UmVzdWx0KSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdG9rZW4gc3VwcGx5Jyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IGJhbGFuY2Ugb2YgYSB0b2tlbiBhY2NvdW50XG4gICAqL1xuICBhc3luYyBnZXRUb2tlbkFjY291bnRCYWxhbmNlKHRva2VuQWRkcmVzcywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Rva2VuQWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5BY2NvdW50QmFsYW5jZScsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KFRva2VuQW1vdW50UmVzdWx0KSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdG9rZW4gYWNjb3VudCBiYWxhbmNlJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCBhY2NvdW50XG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PEdldFByb2dyYW1BY2NvdW50c1Jlc3BvbnNlPn1cbiAgICovXG4gIGFzeW5jIGdldFRva2VuQWNjb3VudHNCeU93bmVyKG93bmVyQWRkcmVzcywgZmlsdGVyLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGxldCBfYXJncyA9IFtvd25lckFkZHJlc3MudG9CYXNlNTgoKV07XG4gICAgaWYgKCdtaW50JyBpbiBmaWx0ZXIpIHtcbiAgICAgIF9hcmdzLnB1c2goe1xuICAgICAgICBtaW50OiBmaWx0ZXIubWludC50b0Jhc2U1OCgpXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgX2FyZ3MucHVzaCh7XG4gICAgICAgIHByb2dyYW1JZDogZmlsdGVyLnByb2dyYW1JZC50b0Jhc2U1OCgpXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhfYXJncywgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VG9rZW5BY2NvdW50c0J5T3duZXInLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRUb2tlbkFjY291bnRzQnlPd25lcik7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgYWNjb3VudCAke293bmVyQWRkcmVzcy50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBwYXJzZWQgdG9rZW4gYWNjb3VudHMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCBhY2NvdW50XG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PEFycmF5PHtwdWJrZXk6IFB1YmxpY0tleSwgYWNjb3VudDogQWNjb3VudEluZm88UGFyc2VkQWNjb3VudERhdGE+fT4+Pn1cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZFRva2VuQWNjb3VudHNCeU93bmVyKG93bmVyQWRkcmVzcywgZmlsdGVyLCBjb21taXRtZW50KSB7XG4gICAgbGV0IF9hcmdzID0gW293bmVyQWRkcmVzcy50b0Jhc2U1OCgpXTtcbiAgICBpZiAoJ21pbnQnIGluIGZpbHRlcikge1xuICAgICAgX2FyZ3MucHVzaCh7XG4gICAgICAgIG1pbnQ6IGZpbHRlci5taW50LnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBfYXJncy5wdXNoKHtcbiAgICAgICAgcHJvZ3JhbUlkOiBmaWx0ZXIucHJvZ3JhbUlkLnRvQmFzZTU4KClcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKF9hcmdzLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuQWNjb3VudHNCeU93bmVyJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkVG9rZW5BY2NvdW50c0J5T3duZXIpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBmYWlsZWQgdG8gZ2V0IHRva2VuIGFjY291bnRzIG93bmVkIGJ5IGFjY291bnQgJHtvd25lckFkZHJlc3MudG9CYXNlNTgoKX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIDIwIGxhcmdlc3QgYWNjb3VudHMgd2l0aCB0aGVpciBjdXJyZW50IGJhbGFuY2VzXG4gICAqL1xuICBhc3luYyBnZXRMYXJnZXN0QWNjb3VudHMoY29uZmlnKSB7XG4gICAgY29uc3QgYXJnID0ge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgY29tbWl0bWVudDogY29uZmlnICYmIGNvbmZpZy5jb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudFxuICAgIH07XG4gICAgY29uc3QgYXJncyA9IGFyZy5maWx0ZXIgfHwgYXJnLmNvbW1pdG1lbnQgPyBbYXJnXSA6IFtdO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldExhcmdlc3RBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldExhcmdlc3RBY2NvdW50c1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgbGFyZ2VzdCBhY2NvdW50cycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgMjAgbGFyZ2VzdCB0b2tlbiBhY2NvdW50cyB3aXRoIHRoZWlyIGN1cnJlbnQgYmFsYW5jZXNcbiAgICogZm9yIGEgZ2l2ZW4gbWludC5cbiAgICovXG4gIGFzeW5jIGdldFRva2VuTGFyZ2VzdEFjY291bnRzKG1pbnRBZGRyZXNzLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbbWludEFkZHJlc3MudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRva2VuTGFyZ2VzdEFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0VG9rZW5MYXJnZXN0QWNjb3VudHNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRva2VuIGxhcmdlc3QgYWNjb3VudHMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYWxsIHRoZSBhY2NvdW50IGluZm8gZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleSwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0KHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwdWJsaWNLZXkudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsICdiYXNlNjQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEFjY291bnRJbmZvJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVsbGFibGUoQWNjb3VudEluZm9SZXN1bHQpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgaW5mbyBhYm91dCBhY2NvdW50ICR7cHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCBhY2NvdW50IGluZm8gZm9yIHRoZSBzcGVjaWZpZWQgcHVibGljIGtleVxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkQWNjb3VudEluZm8ocHVibGljS2V5LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEFjY291bnRJbmZvJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVsbGFibGUoUGFyc2VkQWNjb3VudEluZm9SZXN1bHQpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgaW5mbyBhYm91dCBhY2NvdW50ICR7cHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciB0aGUgc3BlY2lmaWVkIHB1YmxpYyBrZXlcbiAgICovXG4gIGFzeW5jIGdldEFjY291bnRJbmZvKHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0QWNjb3VudEluZm9BbmRDb250ZXh0KHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICAgIHJldHVybiByZXMudmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IGluZm8gYWJvdXQgYWNjb3VudCAnICsgcHVibGljS2V5LnRvQmFzZTU4KCkgKyAnOiAnICsgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciBtdWx0aXBsZSBhY2NvdW50cyBzcGVjaWZpZWQgYnkgYW4gYXJyYXkgb2YgcHVibGljIGtleXMsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldE11bHRpcGxlUGFyc2VkQWNjb3VudHMocHVibGljS2V5cywgcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBrZXlzID0gcHVibGljS2V5cy5tYXAoa2V5ID0+IGtleS50b0Jhc2U1OCgpKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtrZXlzXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldE11bHRpcGxlQWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChhcnJheShudWxsYWJsZShQYXJzZWRBY2NvdW50SW5mb1Jlc3VsdCkpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgaW5mbyBmb3IgYWNjb3VudHMgJHtrZXlzfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhbGwgdGhlIGFjY291bnQgaW5mbyBmb3IgbXVsdGlwbGUgYWNjb3VudHMgc3BlY2lmaWVkIGJ5IGFuIGFycmF5IG9mIHB1YmxpYyBrZXlzLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqL1xuICBhc3luYyBnZXRNdWx0aXBsZUFjY291bnRzSW5mb0FuZENvbnRleHQocHVibGljS2V5cywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBrZXlzID0gcHVibGljS2V5cy5tYXAoa2V5ID0+IGtleS50b0Jhc2U1OCgpKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtrZXlzXSwgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0TXVsdGlwbGVBY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHRBbmRDb250ZXh0KGFycmF5KG51bGxhYmxlKEFjY291bnRJbmZvUmVzdWx0KSkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBpbmZvIGZvciBhY2NvdW50cyAke2tleXN9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudCBpbmZvIGZvciBtdWx0aXBsZSBhY2NvdW50cyBzcGVjaWZpZWQgYnkgYW4gYXJyYXkgb2YgcHVibGljIGtleXNcbiAgICovXG4gIGFzeW5jIGdldE11bHRpcGxlQWNjb3VudHNJbmZvKHB1YmxpY0tleXMsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuZ2V0TXVsdGlwbGVBY2NvdW50c0luZm9BbmRDb250ZXh0KHB1YmxpY0tleXMsIGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgcmV0dXJuIHJlcy52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGVwb2NoIGFjdGl2YXRpb24gaW5mb3JtYXRpb24gZm9yIGEgc3Rha2UgYWNjb3VudCB0aGF0IGhhcyBiZWVuIGRlbGVnYXRlZFxuICAgKi9cbiAgYXN5bmMgZ2V0U3Rha2VBY3RpdmF0aW9uKHB1YmxpY0tleSwgY29tbWl0bWVudE9yQ29uZmlnLCBlcG9jaCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbcHVibGljS2V5LnRvQmFzZTU4KCldLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIHtcbiAgICAgIC4uLmNvbmZpZyxcbiAgICAgIGVwb2NoOiBlcG9jaCAhPSBudWxsID8gZXBvY2ggOiBjb25maWc/LmVwb2NoXG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U3Rha2VBY3RpdmF0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChTdGFrZUFjdGl2YXRpb25SZXN1bHQpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBTdGFrZSBBY3RpdmF0aW9uICR7cHVibGljS2V5LnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFsbCB0aGUgYWNjb3VudHMgb3duZWQgYnkgdGhlIHNwZWNpZmllZCBwcm9ncmFtIGlkXG4gICAqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8e3B1YmtleTogUHVibGljS2V5LCBhY2NvdW50OiBBY2NvdW50SW5mbzxCdWZmZXI+fT4+fVxuICAgKi9cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRQcm9ncmFtQWNjb3VudHMocHJvZ3JhbUlkLCBjb25maWdPckNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb25maWdPckNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHtcbiAgICAgIGVuY29kaW5nLFxuICAgICAgLi4uY29uZmlnV2l0aG91dEVuY29kaW5nXG4gICAgfSA9IGNvbmZpZyB8fCB7fTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwcm9ncmFtSWQudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsIGVuY29kaW5nIHx8ICdiYXNlNjQnLCBjb25maWdXaXRob3V0RW5jb2RpbmcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFByb2dyYW1BY2NvdW50cycsIGFyZ3MpO1xuICAgIGNvbnN0IGJhc2VTY2hlbWEgPSBhcnJheShLZXllZEFjY291bnRJbmZvUmVzdWx0KTtcbiAgICBjb25zdCByZXMgPSBjb25maWdXaXRob3V0RW5jb2Rpbmcud2l0aENvbnRleHQgPT09IHRydWUgPyBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0QW5kQ29udGV4dChiYXNlU2NoZW1hKSkgOiBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGJhc2VTY2hlbWEpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBhY2NvdW50cyBvd25lZCBieSBwcm9ncmFtICR7cHJvZ3JhbUlkLnRvQmFzZTU4KCl9YCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGFuZCBwYXJzZSBhbGwgdGhlIGFjY291bnRzIG93bmVkIGJ5IHRoZSBzcGVjaWZpZWQgcHJvZ3JhbSBpZFxuICAgKlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PHtwdWJrZXk6IFB1YmxpY0tleSwgYWNjb3VudDogQWNjb3VudEluZm88QnVmZmVyIHwgUGFyc2VkQWNjb3VudERhdGE+fT4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0UGFyc2VkUHJvZ3JhbUFjY291bnRzKHByb2dyYW1JZCwgY29uZmlnT3JDb21taXRtZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29uZmlnT3JDb21taXRtZW50KTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtwcm9ncmFtSWQudG9CYXNlNTgoKV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRQcm9ncmFtQWNjb3VudHMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGFycmF5KEtleWVkUGFyc2VkQWNjb3VudEluZm9SZXN1bHQpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgYGZhaWxlZCB0byBnZXQgYWNjb3VudHMgb3duZWQgYnkgcHJvZ3JhbSAke3Byb2dyYW1JZC50b0Jhc2U1OCgpfWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBjb25maXJtVHJhbnNhY3Rpb25gIGFuZCBwYXNzIGluIHtAbGluayBUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblN0cmF0ZWd5fSAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBjb25maXJtVHJhbnNhY3Rpb24oc3RyYXRlZ3ksIGNvbW1pdG1lbnQpIHtcbiAgICBsZXQgcmF3U2lnbmF0dXJlO1xuICAgIGlmICh0eXBlb2Ygc3RyYXRlZ3kgPT0gJ3N0cmluZycpIHtcbiAgICAgIHJhd1NpZ25hdHVyZSA9IHN0cmF0ZWd5O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjb25maWcgPSBzdHJhdGVneTtcbiAgICAgIGlmIChjb25maWcuYWJvcnRTaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGNvbmZpZy5hYm9ydFNpZ25hbC5yZWFzb24pO1xuICAgICAgfVxuICAgICAgcmF3U2lnbmF0dXJlID0gY29uZmlnLnNpZ25hdHVyZTtcbiAgICB9XG4gICAgbGV0IGRlY29kZWRTaWduYXR1cmU7XG4gICAgdHJ5IHtcbiAgICAgIGRlY29kZWRTaWduYXR1cmUgPSBiczU4LmRlY29kZShyYXdTaWduYXR1cmUpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduYXR1cmUgbXVzdCBiZSBiYXNlNTggZW5jb2RlZDogJyArIHJhd1NpZ25hdHVyZSk7XG4gICAgfVxuICAgIGFzc2VydChkZWNvZGVkU2lnbmF0dXJlLmxlbmd0aCA9PT0gNjQsICdzaWduYXR1cmUgaGFzIGludmFsaWQgbGVuZ3RoJyk7XG4gICAgaWYgKHR5cGVvZiBzdHJhdGVneSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbmZpcm1UcmFuc2FjdGlvblVzaW5nTGVnYWN5VGltZW91dFN0cmF0ZWd5KHtcbiAgICAgICAgY29tbWl0bWVudDogY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQsXG4gICAgICAgIHNpZ25hdHVyZTogcmF3U2lnbmF0dXJlXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKCdsYXN0VmFsaWRCbG9ja0hlaWdodCcgaW4gc3RyYXRlZ3kpIHtcbiAgICAgIHJldHVybiBhd2FpdCB0aGlzLmNvbmZpcm1UcmFuc2FjdGlvblVzaW5nQmxvY2tIZWlnaHRFeGNlZWRhbmNlU3RyYXRlZ3koe1xuICAgICAgICBjb21taXRtZW50OiBjb21taXRtZW50IHx8IHRoaXMuY29tbWl0bWVudCxcbiAgICAgICAgc3RyYXRlZ3lcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5jb25maXJtVHJhbnNhY3Rpb25Vc2luZ0R1cmFibGVOb25jZVN0cmF0ZWd5KHtcbiAgICAgICAgY29tbWl0bWVudDogY29tbWl0bWVudCB8fCB0aGlzLmNvbW1pdG1lbnQsXG4gICAgICAgIHN0cmF0ZWd5XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZShzaWduYWwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKF8sIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHNpZ25hbCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzaWduYWwuYWJvcnRlZCkge1xuICAgICAgICByZWplY3Qoc2lnbmFsLnJlYXNvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiB7XG4gICAgICAgICAgcmVqZWN0KHNpZ25hbC5yZWFzb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXRUcmFuc2FjdGlvbkNvbmZpcm1hdGlvblByb21pc2Uoe1xuICAgIGNvbW1pdG1lbnQsXG4gICAgc2lnbmF0dXJlXG4gIH0pIHtcbiAgICBsZXQgc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQ7XG4gICAgbGV0IGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyO1xuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgY29uc3QgY29uZmlybWF0aW9uUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID0gdGhpcy5vblNpZ25hdHVyZShzaWduYXR1cmUsIChyZXN1bHQsIGNvbnRleHQpID0+IHtcbiAgICAgICAgICBzaWduYXR1cmVTdWJzY3JpcHRpb25JZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZTogcmVzdWx0XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VELFxuICAgICAgICAgICAgcmVzcG9uc2VcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgY29tbWl0bWVudCk7XG4gICAgICAgIGNvbnN0IHN1YnNjcmlwdGlvblNldHVwUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCA9PiB7XG4gICAgICAgICAgaWYgKHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwb3NlU2lnbmF0dXJlU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VPYnNlcnZlciA9IHRoaXMuX29uU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2Uoc2lnbmF0dXJlU3Vic2NyaXB0aW9uSWQsIG5leHRTdGF0ZSA9PiB7XG4gICAgICAgICAgICAgIGlmIChuZXh0U3RhdGUgPT09ICdzdWJzY3JpYmVkJykge1xuICAgICAgICAgICAgICAgIHJlc29sdmVTdWJzY3JpcHRpb25TZXR1cCgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgIGF3YWl0IHN1YnNjcmlwdGlvblNldHVwUHJvbWlzZTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRTaWduYXR1cmVTdGF0dXMoc2lnbmF0dXJlKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGlmIChyZXNwb25zZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSByZXNwb25zZTtcbiAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodmFsdWU/LmVycikge1xuICAgICAgICAgICAgcmVqZWN0KHZhbHVlLmVycik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29tbWl0bWVudCkge1xuICAgICAgICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICAgICAgICBjYXNlICdzaW5nbGVHb3NzaXAnOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5jb25maXJtYXRpb25TdGF0dXMgPT09ICdwcm9jZXNzZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2FzZSAnZmluYWxpemVkJzpcbiAgICAgICAgICAgICAgY2FzZSAnbWF4JzpcbiAgICAgICAgICAgICAgY2FzZSAncm9vdCc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlLmNvbmZpcm1hdGlvblN0YXR1cyA9PT0gJ3Byb2Nlc3NlZCcgfHwgdmFsdWUuY29uZmlybWF0aW9uU3RhdHVzID09PSAnY29uZmlybWVkJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIGV4aGF1c3QgZW51bXMgdG8gZW5zdXJlIGZ1bGwgY292ZXJhZ2VcbiAgICAgICAgICAgICAgY2FzZSAncHJvY2Vzc2VkJzpcbiAgICAgICAgICAgICAgY2FzZSAncmVjZW50JzpcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuUFJPQ0VTU0VELFxuICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgIGNvbnRleHQsXG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGFib3J0Q29uZmlybWF0aW9uID0gKCkgPT4ge1xuICAgICAgaWYgKGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyKSB7XG4gICAgICAgIGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyKCk7XG4gICAgICAgIGRpc3Bvc2VTaWduYXR1cmVTdWJzY3JpcHRpb25TdGF0ZUNoYW5nZU9ic2VydmVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihzaWduYXR1cmVTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgIHNpZ25hdHVyZVN1YnNjcmlwdGlvbklkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH07XG4gIH1cbiAgYXN5bmMgY29uZmlybVRyYW5zYWN0aW9uVXNpbmdCbG9ja0hlaWdodEV4Y2VlZGFuY2VTdHJhdGVneSh7XG4gICAgY29tbWl0bWVudCxcbiAgICBzdHJhdGVneToge1xuICAgICAgYWJvcnRTaWduYWwsXG4gICAgICBsYXN0VmFsaWRCbG9ja0hlaWdodCxcbiAgICAgIHNpZ25hdHVyZVxuICAgIH1cbiAgfSkge1xuICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgY29uc3QgZXhwaXJ5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgY29uc3QgY2hlY2tCbG9ja0hlaWdodCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBibG9ja0hlaWdodCA9IGF3YWl0IHRoaXMuZ2V0QmxvY2tIZWlnaHQoY29tbWl0bWVudCk7XG4gICAgICAgICAgcmV0dXJuIGJsb2NrSGVpZ2h0O1xuICAgICAgICB9IGNhdGNoIChfZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIChhc3luYyAoKSA9PiB7XG4gICAgICAgIGxldCBjdXJyZW50QmxvY2tIZWlnaHQgPSBhd2FpdCBjaGVja0Jsb2NrSGVpZ2h0KCk7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIHdoaWxlIChjdXJyZW50QmxvY2tIZWlnaHQgPD0gbGFzdFZhbGlkQmxvY2tIZWlnaHQpIHtcbiAgICAgICAgICBhd2FpdCBzbGVlcCgxMDAwKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGN1cnJlbnRCbG9ja0hlaWdodCA9IGF3YWl0IGNoZWNrQmxvY2tIZWlnaHQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuQkxPQ0tIRUlHSFRfRVhDRUVERURcbiAgICAgICAgfSk7XG4gICAgICB9KSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH0gPSB0aGlzLmdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgc2lnbmF0dXJlXG4gICAgfSk7XG4gICAgY29uc3QgY2FuY2VsbGF0aW9uUHJvbWlzZSA9IHRoaXMuZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZShhYm9ydFNpZ25hbCk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0Y29tZSA9IGF3YWl0IFByb21pc2UucmFjZShbY2FuY2VsbGF0aW9uUHJvbWlzZSwgY29uZmlybWF0aW9uUHJvbWlzZSwgZXhwaXJ5UHJvbWlzZV0pO1xuICAgICAgaWYgKG91dGNvbWUuX190eXBlID09PSBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQpIHtcbiAgICAgICAgcmVzdWx0ID0gb3V0Y29tZS5yZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWRCbG9ja2hlaWdodEV4Y2VlZGVkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgZG9uZSA9IHRydWU7XG4gICAgICBhYm9ydENvbmZpcm1hdGlvbigpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGFzeW5jIGNvbmZpcm1UcmFuc2FjdGlvblVzaW5nRHVyYWJsZU5vbmNlU3RyYXRlZ3koe1xuICAgIGNvbW1pdG1lbnQsXG4gICAgc3RyYXRlZ3k6IHtcbiAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgbWluQ29udGV4dFNsb3QsXG4gICAgICBub25jZUFjY291bnRQdWJrZXksXG4gICAgICBub25jZVZhbHVlLFxuICAgICAgc2lnbmF0dXJlXG4gICAgfVxuICB9KSB7XG4gICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICBjb25zdCBleHBpcnlQcm9taXNlID0gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XG4gICAgICBsZXQgY3VycmVudE5vbmNlVmFsdWUgPSBub25jZVZhbHVlO1xuICAgICAgbGV0IGxhc3RDaGVja2VkU2xvdCA9IG51bGw7XG4gICAgICBjb25zdCBnZXRDdXJyZW50Tm9uY2VWYWx1ZSA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBjb250ZXh0LFxuICAgICAgICAgICAgdmFsdWU6IG5vbmNlQWNjb3VudFxuICAgICAgICAgIH0gPSBhd2FpdCB0aGlzLmdldE5vbmNlQW5kQ29udGV4dChub25jZUFjY291bnRQdWJrZXksIHtcbiAgICAgICAgICAgIGNvbW1pdG1lbnQsXG4gICAgICAgICAgICBtaW5Db250ZXh0U2xvdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGxhc3RDaGVja2VkU2xvdCA9IGNvbnRleHQuc2xvdDtcbiAgICAgICAgICByZXR1cm4gbm9uY2VBY2NvdW50Py5ub25jZTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIC8vIElmIGZvciB3aGF0ZXZlciByZWFzb24gd2UgY2FuJ3QgcmVhY2gvcmVhZCB0aGUgbm9uY2VcbiAgICAgICAgICAvLyBhY2NvdW50LCBqdXN0IGtlZXAgdXNpbmcgdGhlIGxhc3Qta25vd24gdmFsdWUuXG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnROb25jZVZhbHVlO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgKGFzeW5jICgpID0+IHtcbiAgICAgICAgY3VycmVudE5vbmNlVmFsdWUgPSBhd2FpdCBnZXRDdXJyZW50Tm9uY2VWYWx1ZSgpO1xuICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB3aGlsZSAodHJ1ZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnN0YW50LWNvbmRpdGlvblxuICAgICAgICApIHtcbiAgICAgICAgICBpZiAobm9uY2VWYWx1ZSAhPT0gY3VycmVudE5vbmNlVmFsdWUpIHtcbiAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICBfX3R5cGU6IFRyYW5zYWN0aW9uU3RhdHVzLk5PTkNFX0lOVkFMSUQsXG4gICAgICAgICAgICAgIHNsb3RJbldoaWNoTm9uY2VEaWRBZHZhbmNlOiBsYXN0Q2hlY2tlZFNsb3RcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCBzbGVlcCgyMDAwKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICAgIGN1cnJlbnROb25jZVZhbHVlID0gYXdhaXQgZ2V0Q3VycmVudE5vbmNlVmFsdWUoKTtcbiAgICAgICAgICBpZiAoZG9uZSkgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9KSgpO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH0gPSB0aGlzLmdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgc2lnbmF0dXJlXG4gICAgfSk7XG4gICAgY29uc3QgY2FuY2VsbGF0aW9uUHJvbWlzZSA9IHRoaXMuZ2V0Q2FuY2VsbGF0aW9uUHJvbWlzZShhYm9ydFNpZ25hbCk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0Y29tZSA9IGF3YWl0IFByb21pc2UucmFjZShbY2FuY2VsbGF0aW9uUHJvbWlzZSwgY29uZmlybWF0aW9uUHJvbWlzZSwgZXhwaXJ5UHJvbWlzZV0pO1xuICAgICAgaWYgKG91dGNvbWUuX190eXBlID09PSBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQpIHtcbiAgICAgICAgcmVzdWx0ID0gb3V0Y29tZS5yZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERvdWJsZSBjaGVjayB0aGF0IHRoZSB0cmFuc2FjdGlvbiBpcyBpbmRlZWQgdW5jb25maXJtZWQuXG4gICAgICAgIGxldCBzaWduYXR1cmVTdGF0dXM7XG4gICAgICAgIHdoaWxlICh0cnVlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IHRoaXMuZ2V0U2lnbmF0dXJlU3RhdHVzKHNpZ25hdHVyZSk7XG4gICAgICAgICAgaWYgKHN0YXR1cyA9PSBudWxsKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHN0YXR1cy5jb250ZXh0LnNsb3QgPCAob3V0Y29tZS5zbG90SW5XaGljaE5vbmNlRGlkQWR2YW5jZSA/PyBtaW5Db250ZXh0U2xvdCkpIHtcbiAgICAgICAgICAgIGF3YWl0IHNsZWVwKDQwMCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2lnbmF0dXJlU3RhdHVzID0gc3RhdHVzO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaWduYXR1cmVTdGF0dXM/LnZhbHVlKSB7XG4gICAgICAgICAgY29uc3QgY29tbWl0bWVudEZvclN0YXR1cyA9IGNvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCc7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgY29uZmlybWF0aW9uU3RhdHVzXG4gICAgICAgICAgfSA9IHNpZ25hdHVyZVN0YXR1cy52YWx1ZTtcbiAgICAgICAgICBzd2l0Y2ggKGNvbW1pdG1lbnRGb3JTdGF0dXMpIHtcbiAgICAgICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgICAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9uU3RhdHVzICE9PSAncHJvY2Vzc2VkJyAmJiBjb25maXJtYXRpb25TdGF0dXMgIT09ICdjb25maXJtZWQnICYmIGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2ZpbmFsaXplZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NvbmZpcm1lZCc6XG4gICAgICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICAgICAgY2FzZSAnc2luZ2xlR29zc2lwJzpcbiAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2NvbmZpcm1lZCcgJiYgY29uZmlybWF0aW9uU3RhdHVzICE9PSAnZmluYWxpemVkJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZmluYWxpemVkJzpcbiAgICAgICAgICAgIGNhc2UgJ21heCc6XG4gICAgICAgICAgICBjYXNlICdyb290JzpcbiAgICAgICAgICAgICAgaWYgKGNvbmZpcm1hdGlvblN0YXR1cyAhPT0gJ2ZpbmFsaXplZCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhbnNhY3Rpb25FeHBpcmVkTm9uY2VJbnZhbGlkRXJyb3Ioc2lnbmF0dXJlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgIC8vIEV4aGF1c3RpdmUgc3dpdGNoLlxuICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgICAgICAgIChfID0+IHt9KShjb21taXRtZW50Rm9yU3RhdHVzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgY29udGV4dDogc2lnbmF0dXJlU3RhdHVzLmNvbnRleHQsXG4gICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICBlcnI6IHNpZ25hdHVyZVN0YXR1cy52YWx1ZS5lcnJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvcihzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgYWJvcnRDb25maXJtYXRpb24oKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBhc3luYyBjb25maXJtVHJhbnNhY3Rpb25Vc2luZ0xlZ2FjeVRpbWVvdXRTdHJhdGVneSh7XG4gICAgY29tbWl0bWVudCxcbiAgICBzaWduYXR1cmVcbiAgfSkge1xuICAgIGxldCB0aW1lb3V0SWQ7XG4gICAgY29uc3QgZXhwaXJ5UHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgbGV0IHRpbWVvdXRNcyA9IHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IHx8IDYwICogMTAwMDtcbiAgICAgIHN3aXRjaCAoY29tbWl0bWVudCkge1xuICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICBjYXNlICdzaW5nbGVHb3NzaXAnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRpbWVvdXRNcyA9IHRoaXMuX2NvbmZpcm1UcmFuc2FjdGlvbkluaXRpYWxUaW1lb3V0IHx8IDMwICogMTAwMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSh7XG4gICAgICAgIF9fdHlwZTogVHJhbnNhY3Rpb25TdGF0dXMuVElNRURfT1VULFxuICAgICAgICB0aW1lb3V0TXNcbiAgICAgIH0pLCB0aW1lb3V0TXMpO1xuICAgIH0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uLFxuICAgICAgY29uZmlybWF0aW9uUHJvbWlzZVxuICAgIH0gPSB0aGlzLmdldFRyYW5zYWN0aW9uQ29uZmlybWF0aW9uUHJvbWlzZSh7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgc2lnbmF0dXJlXG4gICAgfSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgb3V0Y29tZSA9IGF3YWl0IFByb21pc2UucmFjZShbY29uZmlybWF0aW9uUHJvbWlzZSwgZXhwaXJ5UHJvbWlzZV0pO1xuICAgICAgaWYgKG91dGNvbWUuX190eXBlID09PSBUcmFuc2FjdGlvblN0YXR1cy5QUk9DRVNTRUQpIHtcbiAgICAgICAgcmVzdWx0ID0gb3V0Y29tZS5yZXNwb25zZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFuc2FjdGlvbkV4cGlyZWRUaW1lb3V0RXJyb3Ioc2lnbmF0dXJlLCBvdXRjb21lLnRpbWVvdXRNcyAvIDEwMDApO1xuICAgICAgfVxuICAgIH0gZmluYWxseSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgIGFib3J0Q29uZmlybWF0aW9uKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBsaXN0IG9mIG5vZGVzIHRoYXQgYXJlIGN1cnJlbnRseSBwYXJ0aWNpcGF0aW5nIGluIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXRDbHVzdGVyTm9kZXMoKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Q2x1c3Rlck5vZGVzJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoYXJyYXkoQ29udGFjdEluZm9SZXN1bHQpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgY2x1c3RlciBub2RlcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIGxpc3Qgb2Ygbm9kZXMgdGhhdCBhcmUgY3VycmVudGx5IHBhcnRpY2lwYXRpbmcgaW4gdGhlIGNsdXN0ZXJcbiAgICovXG4gIGFzeW5jIGdldFZvdGVBY2NvdW50cyhjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Vm90ZUFjY291bnRzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0Vm90ZUFjY291bnRzKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB2b3RlIGFjY291bnRzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHNsb3QgdGhhdCB0aGUgbm9kZSBpcyBwcm9jZXNzaW5nXG4gICAqL1xuICBhc3luYyBnZXRTbG90KGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNsb3QnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KG51bWJlcigpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2xvdCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY3VycmVudCBzbG90IGxlYWRlciBvZiB0aGUgY2x1c3RlclxuICAgKi9cbiAgYXN5bmMgZ2V0U2xvdExlYWRlcihjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTbG90TGVhZGVyJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdChzdHJpbmcoKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNsb3QgbGVhZGVyJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGBsaW1pdGAgbnVtYmVyIG9mIHNsb3QgbGVhZGVycyBzdGFydGluZyBmcm9tIGBzdGFydFNsb3RgXG4gICAqXG4gICAqIEBwYXJhbSBzdGFydFNsb3QgZmV0Y2ggc2xvdCBsZWFkZXJzIHN0YXJ0aW5nIGZyb20gdGhpcyBzbG90XG4gICAqIEBwYXJhbSBsaW1pdCBudW1iZXIgb2Ygc2xvdCBsZWFkZXJzIHRvIHJldHVyblxuICAgKi9cbiAgYXN5bmMgZ2V0U2xvdExlYWRlcnMoc3RhcnRTbG90LCBsaW1pdCkge1xuICAgIGNvbnN0IGFyZ3MgPSBbc3RhcnRTbG90LCBsaW1pdF07XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2xvdExlYWRlcnMnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGFycmF5KFB1YmxpY0tleUZyb21TdHJpbmcpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgc2xvdCBsZWFkZXJzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHN0YXR1cyBvZiBhIHNpZ25hdHVyZVxuICAgKi9cbiAgYXN5bmMgZ2V0U2lnbmF0dXJlU3RhdHVzKHNpZ25hdHVyZSwgY29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiB2YWx1ZXNcbiAgICB9ID0gYXdhaXQgdGhpcy5nZXRTaWduYXR1cmVTdGF0dXNlcyhbc2lnbmF0dXJlXSwgY29uZmlnKTtcbiAgICBhc3NlcnQodmFsdWVzLmxlbmd0aCA9PT0gMSk7XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbMF07XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgc3RhdHVzZXMgb2YgYSBiYXRjaCBvZiBzaWduYXR1cmVzXG4gICAqL1xuICBhc3luYyBnZXRTaWduYXR1cmVTdGF0dXNlcyhzaWduYXR1cmVzLCBjb25maWcpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBbc2lnbmF0dXJlc107XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgcGFyYW1zLnB1c2goY29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0U2lnbmF0dXJlU3RhdHVzZXMnLCBwYXJhbXMpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFNpZ25hdHVyZVN0YXR1c2VzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBzaWduYXR1cmUgc3RhdHVzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjdXJyZW50IHRyYW5zYWN0aW9uIGNvdW50IG9mIHRoZSBjbHVzdGVyXG4gICAqL1xuICBhc3luYyBnZXRUcmFuc2FjdGlvbkNvdW50KGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRyYW5zYWN0aW9uQ291bnQnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KG51bWJlcigpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24gY291bnQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGN1cnJlbnQgdG90YWwgY3VycmVuY3kgc3VwcGx5IG9mIHRoZSBjbHVzdGVyIGluIGxhbXBvcnRzXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgdjEuMi44LiBQbGVhc2UgdXNlIHtAbGluayBnZXRTdXBwbHl9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRUb3RhbFN1cHBseShjb21taXRtZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5nZXRTdXBwbHkoe1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGV4Y2x1ZGVOb25DaXJjdWxhdGluZ0FjY291bnRzTGlzdDogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQudmFsdWUudG90YWw7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGNsdXN0ZXIgSW5mbGF0aW9uR292ZXJub3IgcGFyYW1ldGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0SW5mbGF0aW9uR292ZXJub3IoY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW10sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEluZmxhdGlvbkdvdmVybm9yJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0SW5mbGF0aW9uR292ZXJub3JScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGluZmxhdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgaW5mbGF0aW9uIHJld2FyZCBmb3IgYSBsaXN0IG9mIGFkZHJlc3NlcyBmb3IgYW4gZXBvY2hcbiAgICovXG4gIGFzeW5jIGdldEluZmxhdGlvblJld2FyZChhZGRyZXNzZXMsIGVwb2NoLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2FkZHJlc3Nlcy5tYXAocHVia2V5ID0+IHB1YmtleS50b0Jhc2U1OCgpKV0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywge1xuICAgICAgLi4uY29uZmlnLFxuICAgICAgZXBvY2g6IGVwb2NoICE9IG51bGwgPyBlcG9jaCA6IGNvbmZpZz8uZXBvY2hcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRJbmZsYXRpb25SZXdhcmQnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRJbmZsYXRpb25SZXdhcmRSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGluZmxhdGlvbiByZXdhcmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIHNwZWNpZmljIGluZmxhdGlvbiB2YWx1ZXMgZm9yIHRoZSBjdXJyZW50IGVwb2NoXG4gICAqL1xuICBhc3luYyBnZXRJbmZsYXRpb25SYXRlKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEluZmxhdGlvblJhdGUnLCBbXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0SW5mbGF0aW9uUmF0ZVJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgaW5mbGF0aW9uIHJhdGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIEVwb2NoIEluZm8gcGFyYW1ldGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0RXBvY2hJbmZvKGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEVwb2NoSW5mbycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEVwb2NoSW5mb1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZXBvY2ggaW5mbycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgRXBvY2ggU2NoZWR1bGUgcGFyYW1ldGVyc1xuICAgKi9cbiAgYXN5bmMgZ2V0RXBvY2hTY2hlZHVsZSgpIHtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRFcG9jaFNjaGVkdWxlJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldEVwb2NoU2NoZWR1bGVScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGVwb2NoIHNjaGVkdWxlJyk7XG4gICAgfVxuICAgIGNvbnN0IGVwb2NoU2NoZWR1bGUgPSByZXMucmVzdWx0O1xuICAgIHJldHVybiBuZXcgRXBvY2hTY2hlZHVsZShlcG9jaFNjaGVkdWxlLnNsb3RzUGVyRXBvY2gsIGVwb2NoU2NoZWR1bGUubGVhZGVyU2NoZWR1bGVTbG90T2Zmc2V0LCBlcG9jaFNjaGVkdWxlLndhcm11cCwgZXBvY2hTY2hlZHVsZS5maXJzdE5vcm1hbEVwb2NoLCBlcG9jaFNjaGVkdWxlLmZpcnN0Tm9ybWFsU2xvdCk7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGxlYWRlciBzY2hlZHVsZSBmb3IgdGhlIGN1cnJlbnQgZXBvY2hcbiAgICogQHJldHVybiB7UHJvbWlzZTxScGNSZXNwb25zZUFuZENvbnRleHQ8TGVhZGVyU2NoZWR1bGU+Pn1cbiAgICovXG4gIGFzeW5jIGdldExlYWRlclNjaGVkdWxlKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldExlYWRlclNjaGVkdWxlJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldExlYWRlclNjaGVkdWxlUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBsZWFkZXIgc2NoZWR1bGUnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIG1pbmltdW0gYmFsYW5jZSBuZWVkZWQgdG8gZXhlbXB0IGFuIGFjY291bnQgb2YgYGRhdGFMZW5ndGhgXG4gICAqIHNpemUgZnJvbSByZW50XG4gICAqL1xuICBhc3luYyBnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24oZGF0YUxlbmd0aCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2RhdGFMZW5ndGhdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRNaW5pbXVtQmFsYW5jZUZvclJlbnRFeGVtcHRpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgY29uc29sZS53YXJuKCdVbmFibGUgdG8gZmV0Y2ggbWluaW11bSBiYWxhbmNlIGZvciByZW50IGV4ZW1wdGlvbicpO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgcmVjZW50IGJsb2NraGFzaCBmcm9tIHRoZSBjbHVzdGVyLCByZXR1cm4gd2l0aCBjb250ZXh0XG4gICAqIEByZXR1cm4ge1Byb21pc2U8UnBjUmVzcG9uc2VBbmRDb250ZXh0PHtibG9ja2hhc2g6IEJsb2NraGFzaCwgZmVlQ2FsY3VsYXRvcjogRmVlQ2FsY3VsYXRvcn0+Pn1cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRMYXRlc3RCbG9ja2hhc2h9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0KGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRSZWNlbnRCbG9ja2hhc2gnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRSZWNlbnRCbG9ja2hhc2hBbmRDb250ZXh0UnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCByZWNlbnQgYmxvY2toYXNoJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHJlY2VudCBwZXJmb3JtYW5jZSBzYW1wbGVzXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk8UGVyZlNhbXBsZT4+fVxuICAgKi9cbiAgYXN5bmMgZ2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzKGxpbWl0KSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0UmVjZW50UGVyZm9ybWFuY2VTYW1wbGVzJywgbGltaXQgPyBbbGltaXRdIDogW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFJlY2VudFBlcmZvcm1hbmNlU2FtcGxlc1JwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgcmVjZW50IHBlcmZvcm1hbmNlIHNhbXBsZXMnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGZlZSBjYWxjdWxhdG9yIGZvciBhIHJlY2VudCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlciwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldEZlZUZvck1lc3NhZ2V9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRGZWVDYWxjdWxhdG9yRm9yQmxvY2toYXNoKGJsb2NraGFzaCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW2Jsb2NraGFzaF0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEZlZUNhbGN1bGF0b3JGb3JCbG9ja2hhc2gnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRGZWVDYWxjdWxhdG9yUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBmZWUgY2FsY3VsYXRvcicpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWVcbiAgICB9ID0gcmVzLnJlc3VsdDtcbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlOiB2YWx1ZSAhPT0gbnVsbCA/IHZhbHVlLmZlZUNhbGN1bGF0b3IgOiBudWxsXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgZmVlIGZvciBhIG1lc3NhZ2UgZnJvbSB0aGUgY2x1c3RlciwgcmV0dXJuIHdpdGggY29udGV4dFxuICAgKi9cbiAgYXN5bmMgZ2V0RmVlRm9yTWVzc2FnZShtZXNzYWdlLCBjb21taXRtZW50KSB7XG4gICAgY29uc3Qgd2lyZU1lc3NhZ2UgPSB0b0J1ZmZlcihtZXNzYWdlLnNlcmlhbGl6ZSgpKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbd2lyZU1lc3NhZ2VdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRGZWVGb3JNZXNzYWdlJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVsbGFibGUobnVtYmVyKCkpKSk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgZmVlIGZvciBtZXNzYWdlJyk7XG4gICAgfVxuICAgIGlmIChyZXMucmVzdWx0ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgYmxvY2toYXNoJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBwcmlvcml0aXphdGlvbiBmZWVzIGZyb20gcmVjZW50IGJsb2Nrcy5cbiAgICovXG4gIGFzeW5jIGdldFJlY2VudFByaW9yaXRpemF0aW9uRmVlcyhjb25maWcpIHtcbiAgICBjb25zdCBhY2NvdW50cyA9IGNvbmZpZz8ubG9ja2VkV3JpdGFibGVBY2NvdW50cz8ubWFwKGtleSA9PiBrZXkudG9CYXNlNTgoKSk7XG4gICAgY29uc3QgYXJncyA9IGFjY291bnRzPy5sZW5ndGggPyBbYWNjb3VudHNdIDogW107XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UmVjZW50UHJpb3JpdGl6YXRpb25GZWVzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCByZWNlbnQgcHJpb3JpdGl6YXRpb24gZmVlcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuICAvKipcbiAgICogRmV0Y2ggYSByZWNlbnQgYmxvY2toYXNoIGZyb20gdGhlIGNsdXN0ZXJcbiAgICogQHJldHVybiB7UHJvbWlzZTx7YmxvY2toYXNoOiBCbG9ja2hhc2gsIGZlZUNhbGN1bGF0b3I6IEZlZUNhbGN1bGF0b3J9Pn1cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRMYXRlc3RCbG9ja2hhc2h9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRSZWNlbnRCbG9ja2hhc2goY29tbWl0bWVudCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldFJlY2VudEJsb2NraGFzaEFuZENvbnRleHQoY29tbWl0bWVudCk7XG4gICAgICByZXR1cm4gcmVzLnZhbHVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGdldCByZWNlbnQgYmxvY2toYXNoOiAnICsgZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBsYXRlc3QgYmxvY2toYXNoIGZyb20gdGhlIGNsdXN0ZXJcbiAgICogQHJldHVybiB7UHJvbWlzZTxCbG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQ+fVxuICAgKi9cbiAgYXN5bmMgZ2V0TGF0ZXN0QmxvY2toYXNoKGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLmdldExhdGVzdEJsb2NraGFzaEFuZENvbnRleHQoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICAgIHJldHVybiByZXMudmFsdWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gZ2V0IHJlY2VudCBibG9ja2hhc2g6ICcgKyBlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdGhlIGxhdGVzdCBibG9ja2hhc2ggZnJvbSB0aGUgY2x1c3RlclxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEJsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodD59XG4gICAqL1xuICBhc3luYyBnZXRMYXRlc3RCbG9ja2hhc2hBbmRDb250ZXh0KGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKGNvbW1pdG1lbnRPckNvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldExhdGVzdEJsb2NraGFzaCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldExhdGVzdEJsb2NraGFzaFJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgbGF0ZXN0IGJsb2NraGFzaCcpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgYSBibG9ja2hhc2ggaXMgc3RpbGwgdmFsaWQgb3Igbm90XG4gICAqL1xuICBhc3luYyBpc0Jsb2NraGFzaFZhbGlkKGJsb2NraGFzaCwgcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtibG9ja2hhc2hdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnaXNCbG9ja2hhc2hWYWxpZCcsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIElzQmxvY2toYXNoVmFsaWRScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZGV0ZXJtaW5lIGlmIHRoZSBibG9ja2hhc2ggYCcgKyBibG9ja2hhc2ggKyAnYGlzIHZhbGlkJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBub2RlIHZlcnNpb25cbiAgICovXG4gIGFzeW5jIGdldFZlcnNpb24oKSB7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VmVyc2lvbicsIFtdKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KFZlcnNpb25SZXN1bHQpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB2ZXJzaW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBnZW5lc2lzIGhhc2hcbiAgICovXG4gIGFzeW5jIGdldEdlbmVzaXNIYXNoKCkge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEdlbmVzaXNIYXNoJywgW10pO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIGpzb25ScGNSZXN1bHQoc3RyaW5nKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBnZW5lc2lzIGhhc2gnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBwcm9jZXNzZWQgYmxvY2sgZnJvbSB0aGUgY2x1c3Rlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0QmxvY2tgIHVzaW5nIGEgYEdldFZlcnNpb25lZEJsb2NrQ29uZmlnYCBieVxuICAgKiBzZXR0aW5nIHRoZSBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldEJsb2NrYCB1c2luZyBhIGBHZXRWZXJzaW9uZWRCbG9ja0NvbmZpZ2AgYnlcbiAgICogc2V0dGluZyB0aGUgYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwgYGdldEJsb2NrYCB1c2luZyBhIGBHZXRWZXJzaW9uZWRCbG9ja0NvbmZpZ2AgYnlcbiAgICogc2V0dGluZyB0aGUgYG1heFN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbmAgcHJvcGVydHkuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIEZldGNoIGEgcHJvY2Vzc2VkIGJsb2NrIGZyb20gdGhlIGNsdXN0ZXIuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogRmV0Y2ggYSBwcm9jZXNzZWQgYmxvY2sgZnJvbSB0aGUgY2x1c3Rlci5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0QmxvY2soc2xvdCwgcmF3Q29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcocmF3Q29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCAvKiBlbmNvZGluZyAqLywgY29uZmlnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9jaycsIGFyZ3MpO1xuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKGNvbmZpZz8udHJhbnNhY3Rpb25EZXRhaWxzKSB7XG4gICAgICAgIGNhc2UgJ2FjY291bnRzJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRBY2NvdW50c01vZGVCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXROb25lTW9kZUJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0QmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgcmVzdWx0XG4gICAgICAgICAgICB9ID0gcmVzO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHtcbiAgICAgICAgICAgICAgLi4ucmVzdWx0LFxuICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IHJlc3VsdC50cmFuc2FjdGlvbnMubWFwKCh7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgbWV0YSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgICAgICAgIH0pID0+ICh7XG4gICAgICAgICAgICAgICAgbWV0YSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjoge1xuICAgICAgICAgICAgICAgICAgLi4udHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlOiB2ZXJzaW9uZWRNZXNzYWdlRnJvbVJlc3BvbnNlKHZlcnNpb24sIHRyYW5zYWN0aW9uLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uXG4gICAgICAgICAgICAgIH0pKVxuICAgICAgICAgICAgfSA6IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IoZSwgJ2ZhaWxlZCB0byBnZXQgY29uZmlybWVkIGJsb2NrJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGNvbmZpcm1lZCBvciBmaW5hbGl6ZWQgYmxvY2tcbiAgICovXG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIGdldFBhcnNlZEJsb2NrKHNsb3QsIHJhd0NvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWdcbiAgICB9ID0gZXh0cmFjdENvbW1pdG1lbnRGcm9tQ29uZmlnKHJhd0NvbmZpZyk7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0QmxvY2snLCBhcmdzKTtcbiAgICB0cnkge1xuICAgICAgc3dpdGNoIChjb25maWc/LnRyYW5zYWN0aW9uRGV0YWlscykge1xuICAgICAgICBjYXNlICdhY2NvdW50cyc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkQWNjb3VudHNNb2RlQmxvY2tScGNSZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgICAgICAgIHRocm93IHJlcy5lcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAnbm9uZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkTm9uZU1vZGVCbG9ja1JwY1Jlc3VsdCk7XG4gICAgICAgICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgICAgICAgdGhyb3cgcmVzLmVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZEJsb2NrUnBjUmVzdWx0KTtcbiAgICAgICAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICAgICAgICB0aHJvdyByZXMuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihlLCAnZmFpbGVkIHRvIGdldCBibG9jaycpO1xuICAgIH1cbiAgfVxuICAvKlxuICAgKiBSZXR1cm5zIHJlY2VudCBibG9jayBwcm9kdWN0aW9uIGluZm9ybWF0aW9uIGZyb20gdGhlIGN1cnJlbnQgb3IgcHJldmlvdXMgZXBvY2hcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrUHJvZHVjdGlvbihjb25maWdPckNvbW1pdG1lbnQpIHtcbiAgICBsZXQgZXh0cmE7XG4gICAgbGV0IGNvbW1pdG1lbnQ7XG4gICAgaWYgKHR5cGVvZiBjb25maWdPckNvbW1pdG1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb21taXRtZW50ID0gY29uZmlnT3JDb21taXRtZW50O1xuICAgIH0gZWxzZSBpZiAoY29uZmlnT3JDb21taXRtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvbW1pdG1lbnQ6IGMsXG4gICAgICAgIC4uLnJlc3RcbiAgICAgIH0gPSBjb25maWdPckNvbW1pdG1lbnQ7XG4gICAgICBjb21taXRtZW50ID0gYztcbiAgICAgIGV4dHJhID0gcmVzdDtcbiAgICB9XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbXSwgY29tbWl0bWVudCwgJ2Jhc2U2NCcsIGV4dHJhKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9ja1Byb2R1Y3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBCbG9ja1Byb2R1Y3Rpb25SZXNwb25zZVN0cnVjdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgYmxvY2sgcHJvZHVjdGlvbiBpbmZvcm1hdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGNvbmZpcm1lZCBvciBmaW5hbGl6ZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgY2x1c3Rlci5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgSW5zdGVhZCwgY2FsbCBgZ2V0VHJhbnNhY3Rpb25gIHVzaW5nIGFcbiAgICogYEdldFZlcnNpb25lZFRyYW5zYWN0aW9uQ29uZmlnYCBieSBzZXR0aW5nIHRoZVxuICAgKiBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEZldGNoIGEgY29uZmlybWVkIG9yIGZpbmFsaXplZCB0cmFuc2FjdGlvbiBmcm9tIHRoZSBjbHVzdGVyLlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGNvbmZpcm1lZCBvciBmaW5hbGl6ZWQgdHJhbnNhY3Rpb24gZnJvbSB0aGUgY2x1c3Rlci5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgZ2V0VHJhbnNhY3Rpb24oc2lnbmF0dXJlLCByYXdDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhyYXdDb25maWcpO1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGNvbmZpZyk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0VHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRUcmFuc2FjdGlvblJwY1Jlc3VsdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXR1cm4ge1xuICAgICAgLi4ucmVzdWx0LFxuICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgLi4ucmVzdWx0LnRyYW5zYWN0aW9uLFxuICAgICAgICBtZXNzYWdlOiB2ZXJzaW9uZWRNZXNzYWdlRnJvbVJlc3BvbnNlKHJlc3VsdC52ZXJzaW9uLCByZXN1bHQudHJhbnNhY3Rpb24ubWVzc2FnZSlcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGNvbmZpcm1lZCBvciBmaW5hbGl6ZWQgdHJhbnNhY3Rpb25cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZFRyYW5zYWN0aW9uKHNpZ25hdHVyZSwgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnLCBjb25maWcpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHBhcnNlZCB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGJhdGNoIG9mIGNvbmZpcm1lZCB0cmFuc2FjdGlvbnNcbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZFRyYW5zYWN0aW9ucyhzaWduYXR1cmVzLCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb21taXRtZW50LFxuICAgICAgY29uZmlnXG4gICAgfSA9IGV4dHJhY3RDb21taXRtZW50RnJvbUNvbmZpZyhjb21taXRtZW50T3JDb25maWcpO1xuICAgIGNvbnN0IGJhdGNoID0gc2lnbmF0dXJlcy5tYXAoc2lnbmF0dXJlID0+IHtcbiAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCAnanNvblBhcnNlZCcsIGNvbmZpZyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXRob2ROYW1lOiAnZ2V0VHJhbnNhY3Rpb24nLFxuICAgICAgICBhcmdzXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY0JhdGNoUmVxdWVzdChiYXRjaCk7XG4gICAgY29uc3QgcmVzID0gdW5zYWZlUmVzLm1hcCh1bnNhZmVSZXMgPT4ge1xuICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCB0cmFuc2FjdGlvbnMnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXMucmVzdWx0O1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBiYXRjaCBvZiBjb25maXJtZWQgdHJhbnNhY3Rpb25zLlxuICAgKiBTaW1pbGFyIHRvIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbnN9IGJ1dCByZXR1cm5zIGEge0BsaW5rIFRyYW5zYWN0aW9uUmVzcG9uc2V9LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIGBnZXRUcmFuc2FjdGlvbnNgIHVzaW5nIGFcbiAgICogYEdldFZlcnNpb25lZFRyYW5zYWN0aW9uQ29uZmlnYCBieSBzZXR0aW5nIHRoZVxuICAgKiBgbWF4U3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9uYCBwcm9wZXJ0eS5cbiAgICovXG5cbiAgLyoqXG4gICAqIEZldGNoIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9ucy5cbiAgICogU2ltaWxhciB0byB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb25zfSBidXQgcmV0dXJucyBhIHtAbGlua1xuICAgKiBWZXJzaW9uZWRUcmFuc2FjdGlvblJlc3BvbnNlfS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogRmV0Y2ggdHJhbnNhY3Rpb24gZGV0YWlscyBmb3IgYSBiYXRjaCBvZiBjb25maXJtZWQgdHJhbnNhY3Rpb25zLlxuICAgKiBTaW1pbGFyIHRvIHtAbGluayBnZXRQYXJzZWRUcmFuc2FjdGlvbnN9IGJ1dCByZXR1cm5zIGEge0BsaW5rXG4gICAqIFZlcnNpb25lZFRyYW5zYWN0aW9uUmVzcG9uc2V9LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWR1cGUtY2xhc3MtbWVtYmVyc1xuICBhc3luYyBnZXRUcmFuc2FjdGlvbnMoc2lnbmF0dXJlcywgY29tbWl0bWVudE9yQ29uZmlnKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIGNvbmZpZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29tbWl0bWVudE9yQ29uZmlnKTtcbiAgICBjb25zdCBiYXRjaCA9IHNpZ25hdHVyZXMubWFwKHNpZ25hdHVyZSA9PiB7XG4gICAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkIC8qIGVuY29kaW5nICovLCBjb25maWcpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWV0aG9kTmFtZTogJ2dldFRyYW5zYWN0aW9uJyxcbiAgICAgICAgYXJnc1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNCYXRjaFJlcXVlc3QoYmF0Y2gpO1xuICAgIGNvbnN0IHJlcyA9IHVuc2FmZVJlcy5tYXAodW5zYWZlUmVzID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hSlNPTlJQQ0Vycm9yKHJlcy5lcnJvciwgJ2ZhaWxlZCB0byBnZXQgdHJhbnNhY3Rpb25zJyk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgICAgaWYgKCFyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXN1bHQsXG4gICAgICAgIHRyYW5zYWN0aW9uOiB7XG4gICAgICAgICAgLi4ucmVzdWx0LnRyYW5zYWN0aW9uLFxuICAgICAgICAgIG1lc3NhZ2U6IHZlcnNpb25lZE1lc3NhZ2VGcm9tUmVzcG9uc2UocmVzdWx0LnZlcnNpb24sIHJlc3VsdC50cmFuc2FjdGlvbi5tZXNzYWdlKVxuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiByZXM7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSBsaXN0IG9mIFRyYW5zYWN0aW9ucyBhbmQgdHJhbnNhY3Rpb24gc3RhdHVzZXMgZnJvbSB0aGUgY2x1c3RlclxuICAgKiBmb3IgYSBjb25maXJtZWQgYmxvY2suXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgdjEuMTMuMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0QmxvY2t9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRCbG9jayhzbG90LCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3Nsb3RdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRDb25maXJtZWRCbG9jaycsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldENvbmZpcm1lZEJsb2NrUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgYmxvY2snKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gcmVzLnJlc3VsdDtcbiAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25maXJtZWQgYmxvY2sgJyArIHNsb3QgKyAnIG5vdCBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBibG9jayA9IHtcbiAgICAgIC4uLnJlc3VsdCxcbiAgICAgIHRyYW5zYWN0aW9uczogcmVzdWx0LnRyYW5zYWN0aW9ucy5tYXAoKHtcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIG1ldGFcbiAgICAgIH0pID0+IHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IG5ldyBNZXNzYWdlKHRyYW5zYWN0aW9uLm1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgdHJhbnNhY3Rpb246IHtcbiAgICAgICAgICAgIC4uLnRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uYmxvY2ssXG4gICAgICB0cmFuc2FjdGlvbnM6IGJsb2NrLnRyYW5zYWN0aW9ucy5tYXAoKHtcbiAgICAgICAgdHJhbnNhY3Rpb24sXG4gICAgICAgIG1ldGFcbiAgICAgIH0pID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBtZXRhLFxuICAgICAgICAgIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbi5wb3B1bGF0ZSh0cmFuc2FjdGlvbi5tZXNzYWdlLCB0cmFuc2FjdGlvbi5zaWduYXR1cmVzKVxuICAgICAgICB9O1xuICAgICAgfSlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGNvbmZpcm1lZCBibG9ja3MgYmV0d2VlbiB0d28gc2xvdHNcbiAgICovXG4gIGFzeW5jIGdldEJsb2NrcyhzdGFydFNsb3QsIGVuZFNsb3QsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChlbmRTbG90ICE9PSB1bmRlZmluZWQgPyBbc3RhcnRTbG90LCBlbmRTbG90XSA6IFtzdGFydFNsb3RdLCBjb21taXRtZW50KTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRCbG9ja3MnLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBqc29uUnBjUmVzdWx0KGFycmF5KG51bWJlcigpKSkpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGJsb2NrcycpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgU2lnbmF0dXJlcyBmcm9tIHRoZSBjbHVzdGVyIGZvciBhIGJsb2NrLCBleGNsdWRpbmcgcmV3YXJkc1xuICAgKi9cbiAgYXN5bmMgZ2V0QmxvY2tTaWduYXR1cmVzKHNsb3QsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2xvdF0sIGNvbW1pdG1lbnQsIHVuZGVmaW5lZCwge1xuICAgICAgdHJhbnNhY3Rpb25EZXRhaWxzOiAnc2lnbmF0dXJlcycsXG4gICAgICByZXdhcmRzOiBmYWxzZVxuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldEJsb2NrJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0QmxvY2tTaWduYXR1cmVzUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBibG9jaycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jsb2NrICcgKyBzbG90ICsgJyBub3QgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCBhIGxpc3Qgb2YgU2lnbmF0dXJlcyBmcm9tIHRoZSBjbHVzdGVyIGZvciBhIGNvbmZpcm1lZCBibG9jaywgZXhjbHVkaW5nIHJld2FyZHNcbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSBTb2xhbmEgdjEuOC4wLiBQbGVhc2UgdXNlIHtAbGluayBnZXRCbG9ja1NpZ25hdHVyZXN9IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRCbG9ja1NpZ25hdHVyZXMoc2xvdCwgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFtzbG90XSwgY29tbWl0bWVudCwgdW5kZWZpbmVkLCB7XG4gICAgICB0cmFuc2FjdGlvbkRldGFpbHM6ICdzaWduYXR1cmVzJyxcbiAgICAgIHJld2FyZHM6IGZhbHNlXG4gICAgfSk7XG4gICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnZ2V0Q29uZmlybWVkQmxvY2snLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRCbG9ja1NpZ25hdHVyZXNScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCBibG9jaycpO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSByZXMucmVzdWx0O1xuICAgIGlmICghcmVzdWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbmZpcm1lZCBibG9jayAnICsgc2xvdCArICcgbm90IGZvdW5kJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggYSB0cmFuc2FjdGlvbiBkZXRhaWxzIGZvciBhIGNvbmZpcm1lZCB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldFRyYW5zYWN0aW9ufSBpbnN0ZWFkLlxuICAgKi9cbiAgYXN5bmMgZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb24oc2lnbmF0dXJlLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldENvbmZpcm1lZFRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0VHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHRyYW5zYWN0aW9uJyk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHJlcy5yZXN1bHQ7XG4gICAgaWYgKCFyZXN1bHQpIHJldHVybiByZXN1bHQ7XG4gICAgY29uc3QgbWVzc2FnZSA9IG5ldyBNZXNzYWdlKHJlc3VsdC50cmFuc2FjdGlvbi5tZXNzYWdlKTtcbiAgICBjb25zdCBzaWduYXR1cmVzID0gcmVzdWx0LnRyYW5zYWN0aW9uLnNpZ25hdHVyZXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnJlc3VsdCxcbiAgICAgIHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvbi5wb3B1bGF0ZShtZXNzYWdlLCBzaWduYXR1cmVzKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgY29uZmlybWVkIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgc2luY2UgU29sYW5hIHYxLjguMC4gUGxlYXNlIHVzZSB7QGxpbmsgZ2V0UGFyc2VkVHJhbnNhY3Rpb259IGluc3RlYWQuXG4gICAqL1xuICBhc3luYyBnZXRQYXJzZWRDb25maXJtZWRUcmFuc2FjdGlvbihzaWduYXR1cmUsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbc2lnbmF0dXJlXSwgY29tbWl0bWVudCwgJ2pzb25QYXJzZWQnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRDb25maXJtZWRUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgIGNvbnN0IHJlcyA9IGNyZWF0ZSh1bnNhZmVSZXMsIEdldFBhcnNlZFRyYW5zYWN0aW9uUnBjUmVzdWx0KTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgdHJhbnNhY3Rpb24nKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRmV0Y2ggcGFyc2VkIHRyYW5zYWN0aW9uIGRldGFpbHMgZm9yIGEgYmF0Y2ggb2YgY29uZmlybWVkIHRyYW5zYWN0aW9uc1xuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIHNpbmNlIFNvbGFuYSB2MS44LjAuIFBsZWFzZSB1c2Uge0BsaW5rIGdldFBhcnNlZFRyYW5zYWN0aW9uc30gaW5zdGVhZC5cbiAgICovXG4gIGFzeW5jIGdldFBhcnNlZENvbmZpcm1lZFRyYW5zYWN0aW9ucyhzaWduYXR1cmVzLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYmF0Y2ggPSBzaWduYXR1cmVzLm1hcChzaWduYXR1cmUgPT4ge1xuICAgICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJnc0F0TGVhc3RDb25maXJtZWQoW3NpZ25hdHVyZV0sIGNvbW1pdG1lbnQsICdqc29uUGFyc2VkJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXRob2ROYW1lOiAnZ2V0Q29uZmlybWVkVHJhbnNhY3Rpb24nLFxuICAgICAgICBhcmdzXG4gICAgICB9O1xuICAgIH0pO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY0JhdGNoUmVxdWVzdChiYXRjaCk7XG4gICAgY29uc3QgcmVzID0gdW5zYWZlUmVzLm1hcCh1bnNhZmVSZXMgPT4ge1xuICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0UGFyc2VkVHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCAnZmFpbGVkIHRvIGdldCBjb25maXJtZWQgdHJhbnNhY3Rpb25zJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIGEgbGlzdCBvZiBhbGwgdGhlIGNvbmZpcm1lZCBzaWduYXR1cmVzIGZvciB0cmFuc2FjdGlvbnMgaW52b2x2aW5nIGFuIGFkZHJlc3NcbiAgICogd2l0aGluIGEgc3BlY2lmaWVkIHNsb3QgcmFuZ2UuIE1heCByYW5nZSBhbGxvd2VkIGlzIDEwLDAwMCBzbG90cy5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBzaW5jZSB2MS4zLiBQbGVhc2UgdXNlIHtAbGluayBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJ9IGluc3RlYWQuXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHF1ZXJpZWQgYWRkcmVzc1xuICAgKiBAcGFyYW0gc3RhcnRTbG90IHN0YXJ0IHNsb3QsIGluY2x1c2l2ZVxuICAgKiBAcGFyYW0gZW5kU2xvdCBlbmQgc2xvdCwgaW5jbHVzaXZlXG4gICAqL1xuICBhc3luYyBnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzcyhhZGRyZXNzLCBzdGFydFNsb3QsIGVuZFNsb3QpIHtcbiAgICBsZXQgb3B0aW9ucyA9IHt9O1xuICAgIGxldCBmaXJzdEF2YWlsYWJsZUJsb2NrID0gYXdhaXQgdGhpcy5nZXRGaXJzdEF2YWlsYWJsZUJsb2NrKCk7XG4gICAgd2hpbGUgKCEoJ3VudGlsJyBpbiBvcHRpb25zKSkge1xuICAgICAgc3RhcnRTbG90LS07XG4gICAgICBpZiAoc3RhcnRTbG90IDw9IDAgfHwgc3RhcnRTbG90IDwgZmlyc3RBdmFpbGFibGVCbG9jaykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGJsb2NrID0gYXdhaXQgdGhpcy5nZXRDb25maXJtZWRCbG9ja1NpZ25hdHVyZXMoc3RhcnRTbG90LCAnZmluYWxpemVkJyk7XG4gICAgICAgIGlmIChibG9jay5zaWduYXR1cmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBvcHRpb25zLnVudGlsID0gYmxvY2suc2lnbmF0dXJlc1tibG9jay5zaWduYXR1cmVzLmxlbmd0aCAtIDFdLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ3NraXBwZWQnKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBsZXQgaGlnaGVzdENvbmZpcm1lZFJvb3QgPSBhd2FpdCB0aGlzLmdldFNsb3QoJ2ZpbmFsaXplZCcpO1xuICAgIHdoaWxlICghKCdiZWZvcmUnIGluIG9wdGlvbnMpKSB7XG4gICAgICBlbmRTbG90Kys7XG4gICAgICBpZiAoZW5kU2xvdCA+IGhpZ2hlc3RDb25maXJtZWRSb290KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYmxvY2sgPSBhd2FpdCB0aGlzLmdldENvbmZpcm1lZEJsb2NrU2lnbmF0dXJlcyhlbmRTbG90KTtcbiAgICAgICAgaWYgKGJsb2NrLnNpZ25hdHVyZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIG9wdGlvbnMuYmVmb3JlID0gYmxvY2suc2lnbmF0dXJlc1tibG9jay5zaWduYXR1cmVzLmxlbmd0aCAtIDFdLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyLm1lc3NhZ2UuaW5jbHVkZXMoJ3NraXBwZWQnKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb25maXJtZWRTaWduYXR1cmVJbmZvID0gYXdhaXQgdGhpcy5nZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczIoYWRkcmVzcywgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGNvbmZpcm1lZFNpZ25hdHVyZUluZm8ubWFwKGluZm8gPT4gaW5mby5zaWduYXR1cmUpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29uZmlybWVkIHNpZ25hdHVyZXMgZm9yIHRyYW5zYWN0aW9ucyBpbnZvbHZpbmcgYW5cbiAgICogYWRkcmVzcyBiYWNrd2FyZHMgaW4gdGltZSBmcm9tIHRoZSBwcm92aWRlZCBzaWduYXR1cmUgb3IgbW9zdCByZWNlbnQgY29uZmlybWVkIGJsb2NrXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHF1ZXJpZWQgYWRkcmVzc1xuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgZ2V0Q29uZmlybWVkU2lnbmF0dXJlc0ZvckFkZHJlc3MyKGFkZHJlc3MsIG9wdGlvbnMsIGNvbW1pdG1lbnQpIHtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChbYWRkcmVzcy50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCwgdW5kZWZpbmVkLCBvcHRpb25zKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczInLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBHZXRDb25maXJtZWRTaWduYXR1cmVzRm9yQWRkcmVzczJScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IGNvbmZpcm1lZCBzaWduYXR1cmVzIGZvciBhZGRyZXNzJyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgY29uZmlybWVkIHNpZ25hdHVyZXMgZm9yIHRyYW5zYWN0aW9ucyBpbnZvbHZpbmcgYW5cbiAgICogYWRkcmVzcyBiYWNrd2FyZHMgaW4gdGltZSBmcm9tIHRoZSBwcm92aWRlZCBzaWduYXR1cmUgb3IgbW9zdCByZWNlbnQgY29uZmlybWVkIGJsb2NrXG4gICAqXG4gICAqXG4gICAqIEBwYXJhbSBhZGRyZXNzIHF1ZXJpZWQgYWRkcmVzc1xuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9cbiAgYXN5bmMgZ2V0U2lnbmF0dXJlc0ZvckFkZHJlc3MoYWRkcmVzcywgb3B0aW9ucywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3NBdExlYXN0Q29uZmlybWVkKFthZGRyZXNzLnRvQmFzZTU4KCldLCBjb21taXRtZW50LCB1bmRlZmluZWQsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ2dldFNpZ25hdHVyZXNGb3JBZGRyZXNzJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgR2V0U2lnbmF0dXJlc0ZvckFkZHJlc3NScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsICdmYWlsZWQgdG8gZ2V0IHNpZ25hdHVyZXMgZm9yIGFkZHJlc3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cbiAgYXN5bmMgZ2V0QWRkcmVzc0xvb2t1cFRhYmxlKGFjY291bnRLZXksIGNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZTogYWNjb3VudEluZm9cbiAgICB9ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50SW5mb0FuZENvbnRleHQoYWNjb3VudEtleSwgY29uZmlnKTtcbiAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgIGlmIChhY2NvdW50SW5mbyAhPT0gbnVsbCkge1xuICAgICAgdmFsdWUgPSBuZXcgQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCh7XG4gICAgICAgIGtleTogYWNjb3VudEtleSxcbiAgICAgICAgc3RhdGU6IEFkZHJlc3NMb29rdXBUYWJsZUFjY291bnQuZGVzZXJpYWxpemUoYWNjb3VudEluZm8uZGF0YSlcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY29udGV4dCxcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGZXRjaCB0aGUgY29udGVudHMgb2YgYSBOb25jZSBhY2NvdW50IGZyb20gdGhlIGNsdXN0ZXIsIHJldHVybiB3aXRoIGNvbnRleHRcbiAgICovXG4gIGFzeW5jIGdldE5vbmNlQW5kQ29udGV4dChub25jZUFjY291bnQsIGNvbW1pdG1lbnRPckNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRleHQsXG4gICAgICB2YWx1ZTogYWNjb3VudEluZm9cbiAgICB9ID0gYXdhaXQgdGhpcy5nZXRBY2NvdW50SW5mb0FuZENvbnRleHQobm9uY2VBY2NvdW50LCBjb21taXRtZW50T3JDb25maWcpO1xuICAgIGxldCB2YWx1ZSA9IG51bGw7XG4gICAgaWYgKGFjY291bnRJbmZvICE9PSBudWxsKSB7XG4gICAgICB2YWx1ZSA9IE5vbmNlQWNjb3VudC5mcm9tQWNjb3VudERhdGEoYWNjb3VudEluZm8uZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0LFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEZldGNoIHRoZSBjb250ZW50cyBvZiBhIE5vbmNlIGFjY291bnQgZnJvbSB0aGUgY2x1c3RlclxuICAgKi9cbiAgYXN5bmMgZ2V0Tm9uY2Uobm9uY2VBY2NvdW50LCBjb21taXRtZW50T3JDb25maWcpIHtcbiAgICByZXR1cm4gYXdhaXQgdGhpcy5nZXROb25jZUFuZENvbnRleHQobm9uY2VBY2NvdW50LCBjb21taXRtZW50T3JDb25maWcpLnRoZW4oeCA9PiB4LnZhbHVlKS5jYXRjaChlID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZmFpbGVkIHRvIGdldCBub25jZSBmb3IgYWNjb3VudCAnICsgbm9uY2VBY2NvdW50LnRvQmFzZTU4KCkgKyAnOiAnICsgZSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVxdWVzdCBhbiBhbGxvY2F0aW9uIG9mIGxhbXBvcnRzIHRvIHRoZSBzcGVjaWZpZWQgYWRkcmVzc1xuICAgKlxuICAgKiBgYGB0eXBlc2NyaXB0XG4gICAqIGltcG9ydCB7IENvbm5lY3Rpb24sIFB1YmxpY0tleSwgTEFNUE9SVFNfUEVSX1NPTCB9IGZyb20gXCJAc29sYW5hL3dlYjMuanNcIjtcbiAgICpcbiAgICogKGFzeW5jICgpID0+IHtcbiAgICogICBjb25zdCBjb25uZWN0aW9uID0gbmV3IENvbm5lY3Rpb24oXCJodHRwczovL2FwaS50ZXN0bmV0LnNvbGFuYS5jb21cIiwgXCJjb25maXJtZWRcIik7XG4gICAqICAgY29uc3QgbXlBZGRyZXNzID0gbmV3IFB1YmxpY0tleShcIjJucjFiSEZUODZXOXRHbnl2bVlXNHZjSEtzUUIzc1ZRZm5kZGFzejRrRXhNXCIpO1xuICAgKiAgIGNvbnN0IHNpZ25hdHVyZSA9IGF3YWl0IGNvbm5lY3Rpb24ucmVxdWVzdEFpcmRyb3AobXlBZGRyZXNzLCBMQU1QT1JUU19QRVJfU09MKTtcbiAgICogICBhd2FpdCBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihzaWduYXR1cmUpO1xuICAgKiB9KSgpO1xuICAgKiBgYGBcbiAgICovXG4gIGFzeW5jIHJlcXVlc3RBaXJkcm9wKHRvLCBsYW1wb3J0cykge1xuICAgIGNvbnN0IHVuc2FmZVJlcyA9IGF3YWl0IHRoaXMuX3JwY1JlcXVlc3QoJ3JlcXVlc3RBaXJkcm9wJywgW3RvLnRvQmFzZTU4KCksIGxhbXBvcnRzXSk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgUmVxdWVzdEFpcmRyb3BScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgdGhyb3cgbmV3IFNvbGFuYUpTT05SUENFcnJvcihyZXMuZXJyb3IsIGBhaXJkcm9wIHRvICR7dG8udG9CYXNlNTgoKX0gZmFpbGVkYCk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgYXN5bmMgX2Jsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodChkaXNhYmxlQ2FjaGUpIHtcbiAgICBpZiAoIWRpc2FibGVDYWNoZSkge1xuICAgICAgLy8gV2FpdCBmb3IgcG9sbGluZyB0byBmaW5pc2hcbiAgICAgIHdoaWxlICh0aGlzLl9wb2xsaW5nQmxvY2toYXNoKSB7XG4gICAgICAgIGF3YWl0IHNsZWVwKDEwMCk7XG4gICAgICB9XG4gICAgICBjb25zdCB0aW1lU2luY2VGZXRjaCA9IERhdGUubm93KCkgLSB0aGlzLl9ibG9ja2hhc2hJbmZvLmxhc3RGZXRjaDtcbiAgICAgIGNvbnN0IGV4cGlyZWQgPSB0aW1lU2luY2VGZXRjaCA+PSBCTE9DS0hBU0hfQ0FDSEVfVElNRU9VVF9NUztcbiAgICAgIGlmICh0aGlzLl9ibG9ja2hhc2hJbmZvLmxhdGVzdEJsb2NraGFzaCAhPT0gbnVsbCAmJiAhZXhwaXJlZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYmxvY2toYXNoSW5mby5sYXRlc3RCbG9ja2hhc2g7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhd2FpdCB0aGlzLl9wb2xsTmV3QmxvY2toYXNoKCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBfcG9sbE5ld0Jsb2NraGFzaCgpIHtcbiAgICB0aGlzLl9wb2xsaW5nQmxvY2toYXNoID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGNvbnN0IGNhY2hlZExhdGVzdEJsb2NraGFzaCA9IHRoaXMuX2Jsb2NraGFzaEluZm8ubGF0ZXN0QmxvY2toYXNoO1xuICAgICAgY29uc3QgY2FjaGVkQmxvY2toYXNoID0gY2FjaGVkTGF0ZXN0QmxvY2toYXNoID8gY2FjaGVkTGF0ZXN0QmxvY2toYXNoLmJsb2NraGFzaCA6IG51bGw7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDUwOyBpKyspIHtcbiAgICAgICAgY29uc3QgbGF0ZXN0QmxvY2toYXNoID0gYXdhaXQgdGhpcy5nZXRMYXRlc3RCbG9ja2hhc2goJ2ZpbmFsaXplZCcpO1xuICAgICAgICBpZiAoY2FjaGVkQmxvY2toYXNoICE9PSBsYXRlc3RCbG9ja2hhc2guYmxvY2toYXNoKSB7XG4gICAgICAgICAgdGhpcy5fYmxvY2toYXNoSW5mbyA9IHtcbiAgICAgICAgICAgIGxhdGVzdEJsb2NraGFzaCxcbiAgICAgICAgICAgIGxhc3RGZXRjaDogRGF0ZS5ub3coKSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uU2lnbmF0dXJlczogW10sXG4gICAgICAgICAgICBzaW11bGF0ZWRTaWduYXR1cmVzOiBbXVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuIGxhdGVzdEJsb2NraGFzaDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNsZWVwIGZvciBhcHByb3hpbWF0ZWx5IGhhbGYgYSBzbG90XG4gICAgICAgIGF3YWl0IHNsZWVwKE1TX1BFUl9TTE9UIC8gMik7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuYWJsZSB0byBvYnRhaW4gYSBuZXcgYmxvY2toYXNoIGFmdGVyICR7RGF0ZS5ub3coKSAtIHN0YXJ0VGltZX1tc2ApO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0aGlzLl9wb2xsaW5nQmxvY2toYXNoID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIGdldCB0aGUgc3Rha2UgbWluaW11bSBkZWxlZ2F0aW9uXG4gICAqL1xuICBhc3luYyBnZXRTdGFrZU1pbmltdW1EZWxlZ2F0aW9uKGNvbmZpZykge1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbW1pdG1lbnQsXG4gICAgICBjb25maWc6IGNvbmZpZ0FyZ1xuICAgIH0gPSBleHRyYWN0Q29tbWl0bWVudEZyb21Db25maWcoY29uZmlnKTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtdLCBjb21taXRtZW50LCAnYmFzZTY0JywgY29uZmlnQXJnKTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdnZXRTdGFrZU1pbmltdW1EZWxlZ2F0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywganNvblJwY1Jlc3VsdEFuZENvbnRleHQobnVtYmVyKCkpKTtcbiAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgIHRocm93IG5ldyBTb2xhbmFKU09OUlBDRXJyb3IocmVzLmVycm9yLCBgZmFpbGVkIHRvIGdldCBzdGFrZSBtaW5pbXVtIGRlbGVnYXRpb25gKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogU2ltdWxhdGUgYSB0cmFuc2FjdGlvblxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBJbnN0ZWFkLCBjYWxsIHtAbGluayBzaW11bGF0ZVRyYW5zYWN0aW9ufSB3aXRoIHtAbGlua1xuICAgKiBWZXJzaW9uZWRUcmFuc2FjdGlvbn0gYW5kIHtAbGluayBTaW11bGF0ZVRyYW5zYWN0aW9uQ29uZmlnfSBwYXJhbWV0ZXJzXG4gICAqL1xuXG4gIC8qKlxuICAgKiBTaW11bGF0ZSBhIHRyYW5zYWN0aW9uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG5cbiAgLyoqXG4gICAqIFNpbXVsYXRlIGEgdHJhbnNhY3Rpb25cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcbiAgYXN5bmMgc2ltdWxhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbk9yTWVzc2FnZSwgY29uZmlnT3JTaWduZXJzLCBpbmNsdWRlQWNjb3VudHMpIHtcbiAgICBpZiAoJ21lc3NhZ2UnIGluIHRyYW5zYWN0aW9uT3JNZXNzYWdlKSB7XG4gICAgICBjb25zdCB2ZXJzaW9uZWRUeCA9IHRyYW5zYWN0aW9uT3JNZXNzYWdlO1xuICAgICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gdmVyc2lvbmVkVHguc2VyaWFsaXplKCk7XG4gICAgICBjb25zdCBlbmNvZGVkVHJhbnNhY3Rpb24gPSBCdWZmZXIuZnJvbSh3aXJlVHJhbnNhY3Rpb24pLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZ09yU2lnbmVycykgfHwgaW5jbHVkZUFjY291bnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgICAgfVxuICAgICAgY29uc3QgY29uZmlnID0gY29uZmlnT3JTaWduZXJzIHx8IHt9O1xuICAgICAgY29uZmlnLmVuY29kaW5nID0gJ2Jhc2U2NCc7XG4gICAgICBpZiAoISgnY29tbWl0bWVudCcgaW4gY29uZmlnKSkge1xuICAgICAgICBjb25maWcuY29tbWl0bWVudCA9IHRoaXMuY29tbWl0bWVudDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFyZ3MgPSBbZW5jb2RlZFRyYW5zYWN0aW9uLCBjb25maWddO1xuICAgICAgY29uc3QgdW5zYWZlUmVzID0gYXdhaXQgdGhpcy5fcnBjUmVxdWVzdCgnc2ltdWxhdGVUcmFuc2FjdGlvbicsIGFyZ3MpO1xuICAgICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCk7XG4gICAgICBpZiAoJ2Vycm9yJyBpbiByZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmYWlsZWQgdG8gc2ltdWxhdGUgdHJhbnNhY3Rpb246ICcgKyByZXMuZXJyb3IubWVzc2FnZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzLnJlc3VsdDtcbiAgICB9XG4gICAgbGV0IHRyYW5zYWN0aW9uO1xuICAgIGlmICh0cmFuc2FjdGlvbk9yTWVzc2FnZSBpbnN0YW5jZW9mIFRyYW5zYWN0aW9uKSB7XG4gICAgICBsZXQgb3JpZ2luYWxUeCA9IHRyYW5zYWN0aW9uT3JNZXNzYWdlO1xuICAgICAgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyID0gb3JpZ2luYWxUeC5mZWVQYXllcjtcbiAgICAgIHRyYW5zYWN0aW9uLmluc3RydWN0aW9ucyA9IHRyYW5zYWN0aW9uT3JNZXNzYWdlLmluc3RydWN0aW9ucztcbiAgICAgIHRyYW5zYWN0aW9uLm5vbmNlSW5mbyA9IG9yaWdpbmFsVHgubm9uY2VJbmZvO1xuICAgICAgdHJhbnNhY3Rpb24uc2lnbmF0dXJlcyA9IG9yaWdpbmFsVHguc2lnbmF0dXJlcztcbiAgICB9IGVsc2Uge1xuICAgICAgdHJhbnNhY3Rpb24gPSBUcmFuc2FjdGlvbi5wb3B1bGF0ZSh0cmFuc2FjdGlvbk9yTWVzc2FnZSk7XG4gICAgICAvLyBIQUNLOiB0aGlzIGZ1bmN0aW9uIHJlbGllcyBvbiBtdXRhdGluZyB0aGUgcG9wdWxhdGVkIHRyYW5zYWN0aW9uXG4gICAgICB0cmFuc2FjdGlvbi5fbWVzc2FnZSA9IHRyYW5zYWN0aW9uLl9qc29uID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoY29uZmlnT3JTaWduZXJzICE9PSB1bmRlZmluZWQgJiYgIUFycmF5LmlzQXJyYXkoY29uZmlnT3JTaWduZXJzKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICBjb25zdCBzaWduZXJzID0gY29uZmlnT3JTaWduZXJzO1xuICAgIGlmICh0cmFuc2FjdGlvbi5ub25jZUluZm8gJiYgc2lnbmVycykge1xuICAgICAgdHJhbnNhY3Rpb24uc2lnbiguLi5zaWduZXJzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGRpc2FibGVDYWNoZSA9IHRoaXMuX2Rpc2FibGVCbG9ja2hhc2hDYWNoaW5nO1xuICAgICAgZm9yICg7Oykge1xuICAgICAgICBjb25zdCBsYXRlc3RCbG9ja2hhc2ggPSBhd2FpdCB0aGlzLl9ibG9ja2hhc2hXaXRoRXhwaXJ5QmxvY2tIZWlnaHQoZGlzYWJsZUNhY2hlKTtcbiAgICAgICAgdHJhbnNhY3Rpb24ubGFzdFZhbGlkQmxvY2tIZWlnaHQgPSBsYXRlc3RCbG9ja2hhc2gubGFzdFZhbGlkQmxvY2tIZWlnaHQ7XG4gICAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCA9IGxhdGVzdEJsb2NraGFzaC5ibG9ja2hhc2g7XG4gICAgICAgIGlmICghc2lnbmVycykgYnJlYWs7XG4gICAgICAgIHRyYW5zYWN0aW9uLnNpZ24oLi4uc2lnbmVycyk7XG4gICAgICAgIGlmICghdHJhbnNhY3Rpb24uc2lnbmF0dXJlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCchc2lnbmF0dXJlJyk7IC8vIHNob3VsZCBuZXZlciBoYXBwZW5cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB0cmFuc2FjdGlvbi5zaWduYXR1cmUudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgICAgICBpZiAoIXRoaXMuX2Jsb2NraGFzaEluZm8uc2ltdWxhdGVkU2lnbmF0dXJlcy5pbmNsdWRlcyhzaWduYXR1cmUpICYmICF0aGlzLl9ibG9ja2hhc2hJbmZvLnRyYW5zYWN0aW9uU2lnbmF0dXJlcy5pbmNsdWRlcyhzaWduYXR1cmUpKSB7XG4gICAgICAgICAgLy8gVGhlIHNpZ25hdHVyZSBvZiB0aGlzIHRyYW5zYWN0aW9uIGhhcyBub3QgYmVlbiBzZWVuIGJlZm9yZSB3aXRoIHRoZVxuICAgICAgICAgIC8vIGN1cnJlbnQgcmVjZW50QmxvY2toYXNoLCBhbGwgZG9uZS4gTGV0J3MgYnJlYWtcbiAgICAgICAgICB0aGlzLl9ibG9ja2hhc2hJbmZvLnNpbXVsYXRlZFNpZ25hdHVyZXMucHVzaChzaWduYXR1cmUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgdHJhbnNhY3Rpb24gd291bGQgYmUgdHJlYXRlZCBhcyBkdXBsaWNhdGUgKGl0cyBkZXJpdmVkIHNpZ25hdHVyZVxuICAgICAgICAgIC8vIG1hdGNoZWQgdG8gb25lIG9mIGFscmVhZHkgcmVjb3JkZWQgc2lnbmF0dXJlcykuXG4gICAgICAgICAgLy8gU28sIHdlIG11c3QgZmV0Y2ggYSBuZXcgYmxvY2toYXNoIGZvciBhIGRpZmZlcmVudCBzaWduYXR1cmUgYnkgZGlzYWJsaW5nXG4gICAgICAgICAgLy8gb3VyIGNhY2hlIG5vdCB0byB3YWl0IGZvciB0aGUgY2FjaGUgZXhwaXJhdGlvbiAoQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMpLlxuICAgICAgICAgIGRpc2FibGVDYWNoZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWVzc2FnZSA9IHRyYW5zYWN0aW9uLl9jb21waWxlKCk7XG4gICAgY29uc3Qgc2lnbkRhdGEgPSBtZXNzYWdlLnNlcmlhbGl6ZSgpO1xuICAgIGNvbnN0IHdpcmVUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLl9zZXJpYWxpemUoc2lnbkRhdGEpO1xuICAgIGNvbnN0IGVuY29kZWRUcmFuc2FjdGlvbiA9IHdpcmVUcmFuc2FjdGlvbi50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgZW5jb2Rpbmc6ICdiYXNlNjQnLFxuICAgICAgY29tbWl0bWVudDogdGhpcy5jb21taXRtZW50XG4gICAgfTtcbiAgICBpZiAoaW5jbHVkZUFjY291bnRzKSB7XG4gICAgICBjb25zdCBhZGRyZXNzZXMgPSAoQXJyYXkuaXNBcnJheShpbmNsdWRlQWNjb3VudHMpID8gaW5jbHVkZUFjY291bnRzIDogbWVzc2FnZS5ub25Qcm9ncmFtSWRzKCkpLm1hcChrZXkgPT4ga2V5LnRvQmFzZTU4KCkpO1xuICAgICAgY29uZmlnWydhY2NvdW50cyddID0ge1xuICAgICAgICBlbmNvZGluZzogJ2Jhc2U2NCcsXG4gICAgICAgIGFkZHJlc3Nlc1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHNpZ25lcnMpIHtcbiAgICAgIGNvbmZpZy5zaWdWZXJpZnkgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gW2VuY29kZWRUcmFuc2FjdGlvbiwgY29uZmlnXTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdzaW11bGF0ZVRyYW5zYWN0aW9uJywgYXJncyk7XG4gICAgY29uc3QgcmVzID0gY3JlYXRlKHVuc2FmZVJlcywgU2ltdWxhdGVkVHJhbnNhY3Rpb25SZXNwb25zZVN0cnVjdCk7XG4gICAgaWYgKCdlcnJvcicgaW4gcmVzKSB7XG4gICAgICBsZXQgbG9ncztcbiAgICAgIGlmICgnZGF0YScgaW4gcmVzLmVycm9yKSB7XG4gICAgICAgIGxvZ3MgPSByZXMuZXJyb3IuZGF0YS5sb2dzO1xuICAgICAgICBpZiAobG9ncyAmJiBBcnJheS5pc0FycmF5KGxvZ3MpKSB7XG4gICAgICAgICAgY29uc3QgdHJhY2VJbmRlbnQgPSAnXFxuICAgICc7XG4gICAgICAgICAgY29uc3QgbG9nVHJhY2UgPSB0cmFjZUluZGVudCArIGxvZ3Muam9pbih0cmFjZUluZGVudCk7XG4gICAgICAgICAgY29uc29sZS5lcnJvcihyZXMuZXJyb3IubWVzc2FnZSwgbG9nVHJhY2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgU2VuZFRyYW5zYWN0aW9uRXJyb3IoJ2ZhaWxlZCB0byBzaW11bGF0ZSB0cmFuc2FjdGlvbjogJyArIHJlcy5lcnJvci5tZXNzYWdlLCBsb2dzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5yZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogU2lnbiBhbmQgc2VuZCBhIHRyYW5zYWN0aW9uXG4gICAqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwge0BsaW5rIHNlbmRUcmFuc2FjdGlvbn0gd2l0aCBhIHtAbGlua1xuICAgKiBWZXJzaW9uZWRUcmFuc2FjdGlvbn1cbiAgICovXG5cbiAgLyoqXG4gICAqIFNlbmQgYSBzaWduZWQgdHJhbnNhY3Rpb25cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1kdXBlLWNsYXNzLW1lbWJlcnNcblxuICAvKipcbiAgICogU2lnbiBhbmQgc2VuZCBhIHRyYW5zYWN0aW9uXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZHVwZS1jbGFzcy1tZW1iZXJzXG4gIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgc2lnbmVyc09yT3B0aW9ucywgb3B0aW9ucykge1xuICAgIGlmICgndmVyc2lvbicgaW4gdHJhbnNhY3Rpb24pIHtcbiAgICAgIGlmIChzaWduZXJzT3JPcHRpb25zICYmIEFycmF5LmlzQXJyYXkoc2lnbmVyc09yT3B0aW9ucykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgICAgfVxuICAgICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24uc2VyaWFsaXplKCk7XG4gICAgICByZXR1cm4gYXdhaXQgdGhpcy5zZW5kUmF3VHJhbnNhY3Rpb24od2lyZVRyYW5zYWN0aW9uLCBzaWduZXJzT3JPcHRpb25zKTtcbiAgICB9XG4gICAgaWYgKHNpZ25lcnNPck9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fCAhQXJyYXkuaXNBcnJheShzaWduZXJzT3JPcHRpb25zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cycpO1xuICAgIH1cbiAgICBjb25zdCBzaWduZXJzID0gc2lnbmVyc09yT3B0aW9ucztcbiAgICBpZiAodHJhbnNhY3Rpb24ubm9uY2VJbmZvKSB7XG4gICAgICB0cmFuc2FjdGlvbi5zaWduKC4uLnNpZ25lcnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgZGlzYWJsZUNhY2hlID0gdGhpcy5fZGlzYWJsZUJsb2NraGFzaENhY2hpbmc7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGNvbnN0IGxhdGVzdEJsb2NraGFzaCA9IGF3YWl0IHRoaXMuX2Jsb2NraGFzaFdpdGhFeHBpcnlCbG9ja0hlaWdodChkaXNhYmxlQ2FjaGUpO1xuICAgICAgICB0cmFuc2FjdGlvbi5sYXN0VmFsaWRCbG9ja0hlaWdodCA9IGxhdGVzdEJsb2NraGFzaC5sYXN0VmFsaWRCbG9ja0hlaWdodDtcbiAgICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gbGF0ZXN0QmxvY2toYXNoLmJsb2NraGFzaDtcbiAgICAgICAgdHJhbnNhY3Rpb24uc2lnbiguLi5zaWduZXJzKTtcbiAgICAgICAgaWYgKCF0cmFuc2FjdGlvbi5zaWduYXR1cmUpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJyFzaWduYXR1cmUnKTsgLy8gc2hvdWxkIG5ldmVyIGhhcHBlblxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHRyYW5zYWN0aW9uLnNpZ25hdHVyZS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgICAgIGlmICghdGhpcy5fYmxvY2toYXNoSW5mby50cmFuc2FjdGlvblNpZ25hdHVyZXMuaW5jbHVkZXMoc2lnbmF0dXJlKSkge1xuICAgICAgICAgIC8vIFRoZSBzaWduYXR1cmUgb2YgdGhpcyB0cmFuc2FjdGlvbiBoYXMgbm90IGJlZW4gc2VlbiBiZWZvcmUgd2l0aCB0aGVcbiAgICAgICAgICAvLyBjdXJyZW50IHJlY2VudEJsb2NraGFzaCwgYWxsIGRvbmUuIExldCdzIGJyZWFrXG4gICAgICAgICAgdGhpcy5fYmxvY2toYXNoSW5mby50cmFuc2FjdGlvblNpZ25hdHVyZXMucHVzaChzaWduYXR1cmUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgdHJhbnNhY3Rpb24gd291bGQgYmUgdHJlYXRlZCBhcyBkdXBsaWNhdGUgKGl0cyBkZXJpdmVkIHNpZ25hdHVyZVxuICAgICAgICAgIC8vIG1hdGNoZWQgdG8gb25lIG9mIGFscmVhZHkgcmVjb3JkZWQgc2lnbmF0dXJlcykuXG4gICAgICAgICAgLy8gU28sIHdlIG11c3QgZmV0Y2ggYSBuZXcgYmxvY2toYXNoIGZvciBhIGRpZmZlcmVudCBzaWduYXR1cmUgYnkgZGlzYWJsaW5nXG4gICAgICAgICAgLy8gb3VyIGNhY2hlIG5vdCB0byB3YWl0IGZvciB0aGUgY2FjaGUgZXhwaXJhdGlvbiAoQkxPQ0tIQVNIX0NBQ0hFX1RJTUVPVVRfTVMpLlxuICAgICAgICAgIGRpc2FibGVDYWNoZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgd2lyZVRyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24uc2VyaWFsaXplKCk7XG4gICAgcmV0dXJuIGF3YWl0IHRoaXMuc2VuZFJhd1RyYW5zYWN0aW9uKHdpcmVUcmFuc2FjdGlvbiwgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHRyYW5zYWN0aW9uIHRoYXQgaGFzIGFscmVhZHkgYmVlbiBzaWduZWQgYW5kIHNlcmlhbGl6ZWQgaW50byB0aGVcbiAgICogd2lyZSBmb3JtYXRcbiAgICovXG4gIGFzeW5jIHNlbmRSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGVuY29kZWRUcmFuc2FjdGlvbiA9IHRvQnVmZmVyKHJhd1RyYW5zYWN0aW9uKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5zZW5kRW5jb2RlZFRyYW5zYWN0aW9uKGVuY29kZWRUcmFuc2FjdGlvbiwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgdHJhbnNhY3Rpb24gdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHNpZ25lZCwgc2VyaWFsaXplZCBpbnRvIHRoZVxuICAgKiB3aXJlIGZvcm1hdCwgYW5kIGVuY29kZWQgYXMgYSBiYXNlNjQgc3RyaW5nXG4gICAqL1xuICBhc3luYyBzZW5kRW5jb2RlZFRyYW5zYWN0aW9uKGVuY29kZWRUcmFuc2FjdGlvbiwgb3B0aW9ucykge1xuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIGVuY29kaW5nOiAnYmFzZTY0J1xuICAgIH07XG4gICAgY29uc3Qgc2tpcFByZWZsaWdodCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5za2lwUHJlZmxpZ2h0O1xuICAgIGNvbnN0IHByZWZsaWdodENvbW1pdG1lbnQgPSBza2lwUHJlZmxpZ2h0ID09PSB0cnVlID8gJ3Byb2Nlc3NlZCcgLy8gRklYTUUgUmVtb3ZlIHdoZW4gaHR0cHM6Ly9naXRodWIuY29tL2FuemEteHl6L2FnYXZlL3B1bGwvNDgzIGlzIGRlcGxveWVkLlxuICAgIDogb3B0aW9ucyAmJiBvcHRpb25zLnByZWZsaWdodENvbW1pdG1lbnQgfHwgdGhpcy5jb21taXRtZW50O1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMubWF4UmV0cmllcyAhPSBudWxsKSB7XG4gICAgICBjb25maWcubWF4UmV0cmllcyA9IG9wdGlvbnMubWF4UmV0cmllcztcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5taW5Db250ZXh0U2xvdCAhPSBudWxsKSB7XG4gICAgICBjb25maWcubWluQ29udGV4dFNsb3QgPSBvcHRpb25zLm1pbkNvbnRleHRTbG90O1xuICAgIH1cbiAgICBpZiAoc2tpcFByZWZsaWdodCkge1xuICAgICAgY29uZmlnLnNraXBQcmVmbGlnaHQgPSBza2lwUHJlZmxpZ2h0O1xuICAgIH1cbiAgICBpZiAocHJlZmxpZ2h0Q29tbWl0bWVudCkge1xuICAgICAgY29uZmlnLnByZWZsaWdodENvbW1pdG1lbnQgPSBwcmVmbGlnaHRDb21taXRtZW50O1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gW2VuY29kZWRUcmFuc2FjdGlvbiwgY29uZmlnXTtcbiAgICBjb25zdCB1bnNhZmVSZXMgPSBhd2FpdCB0aGlzLl9ycGNSZXF1ZXN0KCdzZW5kVHJhbnNhY3Rpb24nLCBhcmdzKTtcbiAgICBjb25zdCByZXMgPSBjcmVhdGUodW5zYWZlUmVzLCBTZW5kVHJhbnNhY3Rpb25ScGNSZXN1bHQpO1xuICAgIGlmICgnZXJyb3InIGluIHJlcykge1xuICAgICAgbGV0IGxvZ3M7XG4gICAgICBpZiAoJ2RhdGEnIGluIHJlcy5lcnJvcikge1xuICAgICAgICBsb2dzID0gcmVzLmVycm9yLmRhdGEubG9ncztcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBTZW5kVHJhbnNhY3Rpb25FcnJvcignZmFpbGVkIHRvIHNlbmQgdHJhbnNhY3Rpb246ICcgKyByZXMuZXJyb3IubWVzc2FnZSwgbG9ncyk7XG4gICAgfVxuICAgIHJldHVybiByZXMucmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25PcGVuKCkge1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IHRydWU7XG4gICAgdGhpcy5fcnBjV2ViU29ja2V0SGVhcnRiZWF0ID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgLy8gUGluZyBzZXJ2ZXIgZXZlcnkgNXMgdG8gcHJldmVudCBpZGxlIHRpbWVvdXRzXG4gICAgICAoYXN5bmMgKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGF3YWl0IHRoaXMuX3JwY1dlYlNvY2tldC5ub3RpZnkoJ3BpbmcnKTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgfSBjYXRjaCB7fVxuICAgICAgfSkoKTtcbiAgICB9LCA1MDAwKTtcbiAgICB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbkVycm9yKGVycikge1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgIGNvbnNvbGUuZXJyb3IoJ3dzIGVycm9yOicsIGVyci5tZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uQ2xvc2UoY29kZSkge1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JwY1dlYlNvY2tldEdlbmVyYXRpb24gPSAodGhpcy5fcnBjV2ViU29ja2V0R2VuZXJhdGlvbiArIDEpICUgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVI7XG4gICAgaWYgKHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQpO1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0SGVhcnRiZWF0KSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMuX3JwY1dlYlNvY2tldEhlYXJ0YmVhdCk7XG4gICAgICB0aGlzLl9ycGNXZWJTb2NrZXRIZWFydGJlYXQgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoY29kZSA9PT0gMTAwMCkge1xuICAgICAgLy8gZXhwbGljaXQgY2xvc2UsIGNoZWNrIGlmIGFueSBzdWJzY3JpcHRpb25zIGhhdmUgYmVlbiBtYWRlIHNpbmNlIGNsb3NlXG4gICAgICB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaW1wbGljaXQgY2xvc2UsIHByZXBhcmUgc3Vic2NyaXB0aW9ucyBmb3IgYXV0by1yZWNvbm5lY3RcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25DYWxsYmFja3NCeVNlcnZlclN1YnNjcmlwdGlvbklkID0ge307XG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaCkuZm9yRWFjaCgoW2hhc2gsIHN1YnNjcmlwdGlvbl0pID0+IHtcbiAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgc3RhdGU6ICdwZW5kaW5nJ1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfc2V0U3Vic2NyaXB0aW9uKGhhc2gsIG5leHRTdWJzY3JpcHRpb24pIHtcbiAgICBjb25zdCBwcmV2U3RhdGUgPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdPy5zdGF0ZTtcbiAgICB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdID0gbmV4dFN1YnNjcmlwdGlvbjtcbiAgICBpZiAocHJldlN0YXRlICE9PSBuZXh0U3Vic2NyaXB0aW9uLnN0YXRlKSB7XG4gICAgICBjb25zdCBzdGF0ZUNoYW5nZUNhbGxiYWNrcyA9IHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2tzQnlIYXNoW2hhc2hdO1xuICAgICAgaWYgKHN0YXRlQ2hhbmdlQ2FsbGJhY2tzKSB7XG4gICAgICAgIHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLmZvckVhY2goY2IgPT4ge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjYihuZXh0U3Vic2NyaXB0aW9uLnN0YXRlKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICAgIH0gY2F0Y2gge31cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX29uU3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2UoY2xpZW50U3Vic2NyaXB0aW9uSWQsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgaGFzaCA9IHRoaXMuX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICBpZiAoaGFzaCA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gKCkgPT4ge307XG4gICAgfVxuICAgIGNvbnN0IHN0YXRlQ2hhbmdlQ2FsbGJhY2tzID0gdGhpcy5fc3Vic2NyaXB0aW9uU3RhdGVDaGFuZ2VDYWxsYmFja3NCeUhhc2hbaGFzaF0gfHw9IG5ldyBTZXQoKTtcbiAgICBzdGF0ZUNoYW5nZUNhbGxiYWNrcy5hZGQoY2FsbGJhY2spO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBzdGF0ZUNoYW5nZUNhbGxiYWNrcy5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgaWYgKHN0YXRlQ2hhbmdlQ2FsbGJhY2tzLnNpemUgPT09IDApIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvblN0YXRlQ2hhbmdlQ2FsbGJhY2tzQnlIYXNoW2hhc2hdO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBhc3luYyBfdXBkYXRlU3Vic2NyaXB0aW9ucygpIHtcbiAgICBpZiAoT2JqZWN0LmtleXModGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaCkubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkKSB7XG4gICAgICAgIHRoaXMuX3JwY1dlYlNvY2tldENvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9ycGNXZWJTb2NrZXRJZGxlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fcnBjV2ViU29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAvLyBzd2FsbG93IGVycm9yIGlmIHNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgRXJyb3Igd2hlbiBjbG9zaW5nIHNvY2tldCBjb25uZWN0aW9uOiAke2Vyci5tZXNzYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JwY1dlYlNvY2tldElkbGVUaW1lb3V0ICE9PSBudWxsKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQpO1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0SWRsZVRpbWVvdXQgPSBudWxsO1xuICAgICAgdGhpcy5fcnBjV2ViU29ja2V0Q29ubmVjdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9ycGNXZWJTb2NrZXRDb25uZWN0ZWQpIHtcbiAgICAgIHRoaXMuX3JwY1dlYlNvY2tldC5jb25uZWN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZVdlYlNvY2tldEdlbmVyYXRpb24gPSB0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uO1xuICAgIGNvbnN0IGlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSA9ICgpID0+IHtcbiAgICAgIHJldHVybiBhY3RpdmVXZWJTb2NrZXRHZW5lcmF0aW9uID09PSB0aGlzLl9ycGNXZWJTb2NrZXRHZW5lcmF0aW9uO1xuICAgIH07XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgLy8gRG9uJ3QgYmUgdGVtcHRlZCB0byBjaGFuZ2UgdGhpcyB0byBgT2JqZWN0LmVudHJpZXNgLiBXZSBjYWxsXG4gICAgLy8gYF91cGRhdGVTdWJzY3JpcHRpb25zYCByZWN1cnNpdmVseSB3aGVuIHByb2Nlc3NpbmcgdGhlIHN0YXRlLFxuICAgIC8vIHNvIGl0J3MgaW1wb3J0YW50IHRoYXQgd2UgbG9vayB1cCB0aGUgKmN1cnJlbnQqIHZlcnNpb24gb2ZcbiAgICAvLyBlYWNoIHN1YnNjcmlwdGlvbiwgZXZlcnkgdGltZSB3ZSBwcm9jZXNzIGEgaGFzaC5cbiAgICBPYmplY3Qua2V5cyh0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoKS5tYXAoYXN5bmMgaGFzaCA9PiB7XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgICAgaWYgKHN1YnNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIFRoaXMgZW50cnkgaGFzIHNpbmNlIGJlZW4gZGVsZXRlZC4gU2tpcC5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChzdWJzY3JpcHRpb24uc3RhdGUpIHtcbiAgICAgICAgY2FzZSAncGVuZGluZyc6XG4gICAgICAgIGNhc2UgJ3Vuc3Vic2NyaWJlZCc6XG4gICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5jYWxsYmFja3Muc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBZb3UgY2FuIGVuZCB1cCBoZXJlIHdoZW46XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogLSBhIHN1YnNjcmlwdGlvbiBoYXMgcmVjZW50bHkgdW5zdWJzY3JpYmVkXG4gICAgICAgICAgICAgKiAgIHdpdGhvdXQgaGF2aW5nIG5ldyBjYWxsYmFja3MgYWRkZWQgdG8gaXRcbiAgICAgICAgICAgICAqICAgd2hpbGUgdGhlIHVuc3Vic2NyaWJlIHdhcyBpbiBmbGlnaHQsIG9yXG4gICAgICAgICAgICAgKiAtIHdoZW4gYSBwZW5kaW5nIHN1YnNjcmlwdGlvbiBoYXMgaXRzXG4gICAgICAgICAgICAgKiAgIGxpc3RlbmVycyByZW1vdmVkIGJlZm9yZSBhIHJlcXVlc3Qgd2FzXG4gICAgICAgICAgICAgKiAgIHNlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBCZWluZyB0aGF0IG5vYm9keSBpcyBpbnRlcmVzdGVkIGluIHRoaXNcbiAgICAgICAgICAgICAqIHN1YnNjcmlwdGlvbiBhbnkgbG9uZ2VyLCBkZWxldGUgaXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgICAgICAgICAgaWYgKHN1YnNjcmlwdGlvbi5zdGF0ZSA9PT0gJ3Vuc3Vic2NyaWJlZCcpIHtcbiAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbkNhbGxiYWNrc0J5U2VydmVyU3Vic2NyaXB0aW9uSWRbc3Vic2NyaXB0aW9uLnNlcnZlclN1YnNjcmlwdGlvbklkXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3VwZGF0ZVN1YnNjcmlwdGlvbnMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXdhaXQgKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgICAgbWV0aG9kXG4gICAgICAgICAgICB9ID0gc3Vic2NyaXB0aW9uO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdzdWJzY3JpYmluZydcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IHNlcnZlclN1YnNjcmlwdGlvbklkID0gYXdhaXQgdGhpcy5fcnBjV2ViU29ja2V0LmNhbGwobWV0aG9kLCBhcmdzKTtcbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc2VydmVyU3Vic2NyaXB0aW9uSWQsXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdzdWJzY3JpYmVkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZFtzZXJ2ZXJTdWJzY3JpcHRpb25JZF0gPSBzdWJzY3JpcHRpb24uY2FsbGJhY2tzO1xuICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGAke21ldGhvZH0gZXJyb3IgZm9yIGFyZ3VtZW50YCwgYXJncywgZS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIC8vIFRPRE86IE1heWJlIGFkZCBhbiAnZXJyb3JlZCcgc3RhdGUgb3IgYSByZXRyeSBsaW1pdD9cbiAgICAgICAgICAgICAgdGhpcy5fc2V0U3Vic2NyaXB0aW9uKGhhc2gsIHtcbiAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgc3RhdGU6ICdwZW5kaW5nJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N1YnNjcmliZWQnOlxuICAgICAgICAgIGlmIChzdWJzY3JpcHRpb24uY2FsbGJhY2tzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIC8vIEJ5IHRoZSB0aW1lIHdlIHN1Y2Nlc3NmdWxseSBzZXQgdXAgYSBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgIC8vIHdpdGggdGhlIHNlcnZlciwgdGhlIGNsaWVudCBzdG9wcGVkIGNhcmluZyBhYm91dCBpdC5cbiAgICAgICAgICAgIC8vIFRlYXIgaXQgZG93biBub3cuXG4gICAgICAgICAgICBhd2FpdCAoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgc2VydmVyU3Vic2NyaXB0aW9uSWQsXG4gICAgICAgICAgICAgICAgdW5zdWJzY3JpYmVNZXRob2RcbiAgICAgICAgICAgICAgfSA9IHN1YnNjcmlwdGlvbjtcbiAgICAgICAgICAgICAgaWYgKHRoaXMuX3N1YnNjcmlwdGlvbnNBdXRvRGlzcG9zZWRCeVJwYy5oYXMoc2VydmVyU3Vic2NyaXB0aW9uSWQpKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogU3BlY2lhbCBjYXNlLlxuICAgICAgICAgICAgICAgICAqIElmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIHN1YnNjcmlwdGlvbiB0aGF0IGhhcyBiZWVuIGF1dG8tXG4gICAgICAgICAgICAgICAgICogZGlzcG9zZWQgYnkgdGhlIFJQQywgdGhlbiB3ZSBjYW4gc2tpcCB0aGUgUlBDIGNhbGwgdG9cbiAgICAgICAgICAgICAgICAgKiB0ZWFyIGRvd24gdGhlIHN1YnNjcmlwdGlvbiBoZXJlLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogTk9URTogVGhlcmUgaXMgYSBwcm9wb3NhbCB0byBlbGltaW5hdGUgdGhpcyBzcGVjaWFsIGNhc2UsIGhlcmU6XG4gICAgICAgICAgICAgICAgICogaHR0cHM6Ly9naXRodWIuY29tL3NvbGFuYS1sYWJzL3NvbGFuYS9pc3N1ZXMvMTg4OTJcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpcHRpb25zQXV0b0Rpc3Bvc2VkQnlScGMuZGVsZXRlKHNlcnZlclN1YnNjcmlwdGlvbklkKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRTdWJzY3JpcHRpb24oaGFzaCwge1xuICAgICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgc3RhdGU6ICd1bnN1YnNjcmliaW5nJ1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgICAuLi5zdWJzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICBzdGF0ZTogJ3Vuc3Vic2NyaWJpbmcnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3JwY1dlYlNvY2tldC5jYWxsKHVuc3Vic2NyaWJlTWV0aG9kLCBbc2VydmVyU3Vic2NyaXB0aW9uSWRdKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYCR7dW5zdWJzY3JpYmVNZXRob2R9IGVycm9yOmAsIGUubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAoIWlzQ3VycmVudENvbm5lY3Rpb25TdGlsbEFjdGl2ZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIC8vIFRPRE86IE1heWJlIGFkZCBhbiAnZXJyb3JlZCcgc3RhdGUgb3IgYSByZXRyeSBsaW1pdD9cbiAgICAgICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgICAgIC4uLnN1YnNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc3RhdGU6ICdzdWJzY3JpYmVkJ1xuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRoaXMuX3NldFN1YnNjcmlwdGlvbihoYXNoLCB7XG4gICAgICAgICAgICAgICAgLi4uc3Vic2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgIHN0YXRlOiAndW5zdWJzY3JpYmVkJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBkYXRlU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzZXJ2ZXJTdWJzY3JpcHRpb25JZCwgY2FsbGJhY2tBcmdzKSB7XG4gICAgY29uc3QgY2FsbGJhY2tzID0gdGhpcy5fc3Vic2NyaXB0aW9uQ2FsbGJhY2tzQnlTZXJ2ZXJTdWJzY3JpcHRpb25JZFtzZXJ2ZXJTdWJzY3JpcHRpb25JZF07XG4gICAgaWYgKGNhbGxiYWNrcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrcy5mb3JFYWNoKGNiID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNiKFxuICAgICAgICAvLyBJIGZhaWxlZCB0byBmaW5kIGEgd2F5IHRvIGNvbnZpbmNlIFR5cGVTY3JpcHQgdGhhdCBgY2JgIGlzIG9mIHR5cGVcbiAgICAgICAgLy8gYFRDYWxsYmFja2Agd2hpY2ggaXMgY2VydGFpbmx5IGNvbXBhdGlibGUgd2l0aCBgUGFyYW1ldGVyczxUQ2FsbGJhY2s+YC5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9taWNyb3NvZnQvVHlwZVNjcmlwdC9pc3N1ZXMvNDc2MTVcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAuLi5jYWxsYmFja0FyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX3dzT25BY2NvdW50Tm90aWZpY2F0aW9uKG5vdGlmaWNhdGlvbikge1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN1YnNjcmlwdGlvblxuICAgIH0gPSBjcmVhdGUobm90aWZpY2F0aW9uLCBBY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbcmVzdWx0LnZhbHVlLCByZXN1bHQuY29udGV4dF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgX21ha2VTdWJzY3JpcHRpb24oc3Vic2NyaXB0aW9uQ29uZmlnLFxuICAvKipcbiAgICogV2hlbiBwcmVwYXJpbmcgYGFyZ3NgIGZvciBhIGNhbGwgdG8gYF9tYWtlU3Vic2NyaXB0aW9uYCwgYmUgc3VyZVxuICAgKiB0byBjYXJlZnVsbHkgYXBwbHkgYSBkZWZhdWx0IGBjb21taXRtZW50YCBwcm9wZXJ0eSwgaWYgbmVjZXNzYXJ5LlxuICAgKlxuICAgKiAtIElmIHRoZSB1c2VyIHN1cHBsaWVkIGEgYGNvbW1pdG1lbnRgIHVzZSB0aGF0LlxuICAgKiAtIE90aGVyd2lzZSwgaWYgdGhlIGBDb25uZWN0aW9uOjpjb21taXRtZW50YCBpcyBzZXQsIHVzZSB0aGF0LlxuICAgKiAtIE90aGVyd2lzZSwgc2V0IGl0IHRvIHRoZSBSUEMgc2VydmVyIGRlZmF1bHQ6IGBmaW5hbGl6ZWRgLlxuICAgKlxuICAgKiBUaGlzIGlzIGV4dHJlbWVseSBpbXBvcnRhbnQgdG8gZW5zdXJlIHRoYXQgdGhlc2UgdHdvIGZ1bmRhbWVudGFsbHlcbiAgICogaWRlbnRpY2FsIHN1YnNjcmlwdGlvbnMgcHJvZHVjZSB0aGUgc2FtZSBpZGVudGlmeWluZyBoYXNoOlxuICAgKlxuICAgKiAtIEEgc3Vic2NyaXB0aW9uIG1hZGUgd2l0aG91dCBzcGVjaWZ5aW5nIGEgY29tbWl0bWVudC5cbiAgICogLSBBIHN1YnNjcmlwdGlvbiBtYWRlIHdoZXJlIHRoZSBjb21taXRtZW50IHNwZWNpZmllZCBpcyB0aGUgc2FtZVxuICAgKiAgIGFzIHRoZSBkZWZhdWx0IGFwcGxpZWQgdG8gdGhlIHN1YnNjcmlwdGlvbiBhYm92ZS5cbiAgICpcbiAgICogRXhhbXBsZTsgdGhlc2UgdHdvIHN1YnNjcmlwdGlvbnMgbXVzdCBwcm9kdWNlIHRoZSBzYW1lIGhhc2g6XG4gICAqXG4gICAqIC0gQW4gYGFjY291bnRTdWJzY3JpYmVgIHN1YnNjcmlwdGlvbiBmb3IgYCdQVUJLRVknYFxuICAgKiAtIEFuIGBhY2NvdW50U3Vic2NyaWJlYCBzdWJzY3JpcHRpb24gZm9yIGAnUFVCS0VZJ2Agd2l0aCBjb21taXRtZW50XG4gICAqICAgYCdmaW5hbGl6ZWQnYC5cbiAgICpcbiAgICogU2VlIHRoZSAnbWFraW5nIGEgc3Vic2NyaXB0aW9uIHdpdGggZGVmYXVsdGVkIHBhcmFtcyBvbWl0dGVkJyB0ZXN0XG4gICAqIGluIGBjb25uZWN0aW9uLXN1YnNjcmlwdGlvbnMudHNgIGZvciBtb3JlLlxuICAgKi9cbiAgYXJncykge1xuICAgIGNvbnN0IGNsaWVudFN1YnNjcmlwdGlvbklkID0gdGhpcy5fbmV4dENsaWVudFN1YnNjcmlwdGlvbklkKys7XG4gICAgY29uc3QgaGFzaCA9IGZhc3RTdGFibGVTdHJpbmdpZnkkMShbc3Vic2NyaXB0aW9uQ29uZmlnLm1ldGhvZCwgYXJnc10pO1xuICAgIGNvbnN0IGV4aXN0aW5nU3Vic2NyaXB0aW9uID0gdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXTtcbiAgICBpZiAoZXhpc3RpbmdTdWJzY3JpcHRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fc3Vic2NyaXB0aW9uc0J5SGFzaFtoYXNoXSA9IHtcbiAgICAgICAgLi4uc3Vic2NyaXB0aW9uQ29uZmlnLFxuICAgICAgICBhcmdzLFxuICAgICAgICBjYWxsYmFja3M6IG5ldyBTZXQoW3N1YnNjcmlwdGlvbkNvbmZpZy5jYWxsYmFja10pLFxuICAgICAgICBzdGF0ZTogJ3BlbmRpbmcnXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZ1N1YnNjcmlwdGlvbi5jYWxsYmFja3MuYWRkKHN1YnNjcmlwdGlvbkNvbmZpZy5jYWxsYmFjayk7XG4gICAgfVxuICAgIHRoaXMuX3N1YnNjcmlwdGlvbkhhc2hCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXSA9IGhhc2g7XG4gICAgdGhpcy5fc3Vic2NyaXB0aW9uRGlzcG9zZUZ1bmN0aW9uc0J5Q2xpZW50U3Vic2NyaXB0aW9uSWRbY2xpZW50U3Vic2NyaXB0aW9uSWRdID0gYXN5bmMgKCkgPT4ge1xuICAgICAgZGVsZXRlIHRoaXMuX3N1YnNjcmlwdGlvbkRpc3Bvc2VGdW5jdGlvbnNCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICAgIGRlbGV0ZSB0aGlzLl9zdWJzY3JpcHRpb25IYXNoQnlDbGllbnRTdWJzY3JpcHRpb25JZFtjbGllbnRTdWJzY3JpcHRpb25JZF07XG4gICAgICBjb25zdCBzdWJzY3JpcHRpb24gPSB0aGlzLl9zdWJzY3JpcHRpb25zQnlIYXNoW2hhc2hdO1xuICAgICAgYXNzZXJ0KHN1YnNjcmlwdGlvbiAhPT0gdW5kZWZpbmVkLCBgQ291bGQgbm90IGZpbmQgYSBcXGBTdWJzY3JpcHRpb25cXGAgd2hlbiB0ZWFyaW5nIGRvd24gY2xpZW50IHN1YnNjcmlwdGlvbiAjJHtjbGllbnRTdWJzY3JpcHRpb25JZH1gKTtcbiAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFja3MuZGVsZXRlKHN1YnNjcmlwdGlvbkNvbmZpZy5jYWxsYmFjayk7XG4gICAgICBhd2FpdCB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgfTtcbiAgICB0aGlzLl91cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgcmV0dXJuIGNsaWVudFN1YnNjcmlwdGlvbklkO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuZXZlciB0aGUgc3BlY2lmaWVkIGFjY291bnQgY2hhbmdlc1xuICAgKlxuICAgKiBAcGFyYW0gcHVibGljS2V5IFB1YmxpYyBrZXkgb2YgdGhlIGFjY291bnQgdG8gbW9uaXRvclxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSBhY2NvdW50IGlzIGNoYW5nZWRcbiAgICogQHBhcmFtIGNvbW1pdG1lbnQgU3BlY2lmeSB0aGUgY29tbWl0bWVudCBsZXZlbCBhY2NvdW50IGNoYW5nZXMgbXVzdCByZWFjaCBiZWZvcmUgbm90aWZpY2F0aW9uXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvbkFjY291bnRDaGFuZ2UocHVibGljS2V5LCBjYWxsYmFjaywgY29tbWl0bWVudCkge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3B1YmxpY0tleS50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnLFxuICAgIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgJ2Jhc2U2NCcpO1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAnYWNjb3VudFN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ2FjY291bnRVbnN1YnNjcmliZSdcbiAgICB9LCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGFuIGFjY291bnQgbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBjbGllbnRTdWJzY3JpcHRpb25JZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICovXG4gIGFzeW5jIHJlbW92ZUFjY291bnRDaGFuZ2VMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnYWNjb3VudCBjaGFuZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uUHJvZ3JhbUFjY291bnROb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIFByb2dyYW1BY2NvdW50Tm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICB0aGlzLl9oYW5kbGVTZXJ2ZXJOb3RpZmljYXRpb24oc3Vic2NyaXB0aW9uLCBbe1xuICAgICAgYWNjb3VudElkOiByZXN1bHQudmFsdWUucHVia2V5LFxuICAgICAgYWNjb3VudEluZm86IHJlc3VsdC52YWx1ZS5hY2NvdW50XG4gICAgfSwgcmVzdWx0LmNvbnRleHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbmV2ZXIgYWNjb3VudHMgb3duZWQgYnkgdGhlXG4gICAqIHNwZWNpZmllZCBwcm9ncmFtIGNoYW5nZVxuICAgKlxuICAgKiBAcGFyYW0gcHJvZ3JhbUlkIFB1YmxpYyBrZXkgb2YgdGhlIHByb2dyYW0gdG8gbW9uaXRvclxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSBhY2NvdW50IGlzIGNoYW5nZWRcbiAgICogQHBhcmFtIGNvbW1pdG1lbnQgU3BlY2lmeSB0aGUgY29tbWl0bWVudCBsZXZlbCBhY2NvdW50IGNoYW5nZXMgbXVzdCByZWFjaCBiZWZvcmUgbm90aWZpY2F0aW9uXG4gICAqIEBwYXJhbSBmaWx0ZXJzIFRoZSBwcm9ncmFtIGFjY291bnQgZmlsdGVycyB0byBwYXNzIGludG8gdGhlIFJQQyBtZXRob2RcbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uUHJvZ3JhbUFjY291bnRDaGFuZ2UocHJvZ3JhbUlkLCBjYWxsYmFjaywgY29tbWl0bWVudCwgZmlsdGVycykge1xuICAgIGNvbnN0IGFyZ3MgPSB0aGlzLl9idWlsZEFyZ3MoW3Byb2dyYW1JZC50b0Jhc2U1OCgpXSwgY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnLFxuICAgIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgJ2Jhc2U2NCcgLyogZW5jb2RpbmcgKi8sIGZpbHRlcnMgPyB7XG4gICAgICBmaWx0ZXJzOiBmaWx0ZXJzXG4gICAgfSA6IHVuZGVmaW5lZCAvKiBleHRyYSAqLyk7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdwcm9ncmFtU3Vic2NyaWJlJyxcbiAgICAgIHVuc3Vic2NyaWJlTWV0aG9kOiAncHJvZ3JhbVVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXIgYW4gYWNjb3VudCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlUHJvZ3JhbUFjY291bnRDaGFuZ2VMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAncHJvZ3JhbSBhY2NvdW50IGNoYW5nZScpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbmV2ZXIgbG9ncyBhcmUgZW1pdHRlZC5cbiAgICovXG4gIG9uTG9ncyhmaWx0ZXIsIGNhbGxiYWNrLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbdHlwZW9mIGZpbHRlciA9PT0gJ29iamVjdCcgPyB7XG4gICAgICBtZW50aW9uczogW2ZpbHRlci50b1N0cmluZygpXVxuICAgIH0gOiBmaWx0ZXJdLCBjb21taXRtZW50IHx8IHRoaXMuX2NvbW1pdG1lbnQgfHwgJ2ZpbmFsaXplZCcgLy8gQXBwbHkgY29ubmVjdGlvbi9zZXJ2ZXIgZGVmYXVsdC5cbiAgICApO1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAnbG9nc1N1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ2xvZ3NVbnN1YnNjcmliZSdcbiAgICB9LCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgbG9ncyBjYWxsYmFjay5cbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3Rlci5cbiAgICovXG4gIGFzeW5jIHJlbW92ZU9uTG9nc0xpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdsb2dzJyk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPbkxvZ3NOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIExvZ3NOb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHQudmFsdWUsIHJlc3VsdC5jb250ZXh0XSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPblNsb3ROb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIFNsb3ROb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgdXBvbiBzbG90IGNoYW5nZXNcbiAgICpcbiAgICogQHBhcmFtIGNhbGxiYWNrIEZ1bmN0aW9uIHRvIGludm9rZSB3aGVuZXZlciB0aGUgc2xvdCBjaGFuZ2VzXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNsb3RDaGFuZ2UoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gdGhpcy5fbWFrZVN1YnNjcmlwdGlvbih7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG1ldGhvZDogJ3Nsb3RTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzbG90VW5zdWJzY3JpYmUnXG4gICAgfSwgW10gLyogYXJncyAqLyk7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhIHNsb3Qgbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBjbGllbnRTdWJzY3JpcHRpb25JZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICovXG4gIGFzeW5jIHJlbW92ZVNsb3RDaGFuZ2VMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnc2xvdCBjaGFuZ2UnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uU2xvdFVwZGF0ZXNOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgcmVzdWx0LFxuICAgICAgc3Vic2NyaXB0aW9uXG4gICAgfSA9IGNyZWF0ZShub3RpZmljYXRpb24sIFNsb3RVcGRhdGVOb3RpZmljYXRpb25SZXN1bHQpO1xuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIFtyZXN1bHRdKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgdXBvbiBzbG90IHVwZGF0ZXMuIHtAbGluayBTbG90VXBkYXRlfSdzXG4gICAqIG1heSBiZSB1c2VmdWwgdG8gdHJhY2sgbGl2ZSBwcm9ncmVzcyBvZiBhIGNsdXN0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugd2hlbmV2ZXIgdGhlIHNsb3QgdXBkYXRlc1xuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25TbG90VXBkYXRlKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2ssXG4gICAgICBtZXRob2Q6ICdzbG90c1VwZGF0ZXNTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzbG90c1VwZGF0ZXNVbnN1YnNjcmliZSdcbiAgICB9LCBbXSAvKiBhcmdzICovKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgc2xvdCB1cGRhdGUgbm90aWZpY2F0aW9uIGNhbGxiYWNrXG4gICAqXG4gICAqIEBwYXJhbSBjbGllbnRTdWJzY3JpcHRpb25JZCBjbGllbnQgc3Vic2NyaXB0aW9uIGlkIHRvIGRlcmVnaXN0ZXJcbiAgICovXG4gIGFzeW5jIHJlbW92ZVNsb3RVcGRhdGVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCkge1xuICAgIGF3YWl0IHRoaXMuX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCAnc2xvdCB1cGRhdGUnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgYXN5bmMgX3Vuc3Vic2NyaWJlQ2xpZW50U3Vic2NyaXB0aW9uKGNsaWVudFN1YnNjcmlwdGlvbklkLCBzdWJzY3JpcHRpb25OYW1lKSB7XG4gICAgY29uc3QgZGlzcG9zZSA9IHRoaXMuX3N1YnNjcmlwdGlvbkRpc3Bvc2VGdW5jdGlvbnNCeUNsaWVudFN1YnNjcmlwdGlvbklkW2NsaWVudFN1YnNjcmlwdGlvbklkXTtcbiAgICBpZiAoZGlzcG9zZSkge1xuICAgICAgYXdhaXQgZGlzcG9zZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLndhcm4oJ0lnbm9yZWQgdW5zdWJzY3JpYmUgcmVxdWVzdCBiZWNhdXNlIGFuIGFjdGl2ZSBzdWJzY3JpcHRpb24gd2l0aCBpZCAnICsgYFxcYCR7Y2xpZW50U3Vic2NyaXB0aW9uSWR9XFxgIGZvciAnJHtzdWJzY3JpcHRpb25OYW1lfScgZXZlbnRzIGAgKyAnY291bGQgbm90IGJlIGZvdW5kLicpO1xuICAgIH1cbiAgfVxuICBfYnVpbGRBcmdzKGFyZ3MsIG92ZXJyaWRlLCBlbmNvZGluZywgZXh0cmEpIHtcbiAgICBjb25zdCBjb21taXRtZW50ID0gb3ZlcnJpZGUgfHwgdGhpcy5fY29tbWl0bWVudDtcbiAgICBpZiAoY29tbWl0bWVudCB8fCBlbmNvZGluZyB8fCBleHRyYSkge1xuICAgICAgbGV0IG9wdGlvbnMgPSB7fTtcbiAgICAgIGlmIChlbmNvZGluZykge1xuICAgICAgICBvcHRpb25zLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICB9XG4gICAgICBpZiAoY29tbWl0bWVudCkge1xuICAgICAgICBvcHRpb25zLmNvbW1pdG1lbnQgPSBjb21taXRtZW50O1xuICAgICAgfVxuICAgICAgaWYgKGV4dHJhKSB7XG4gICAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKG9wdGlvbnMsIGV4dHJhKTtcbiAgICAgIH1cbiAgICAgIGFyZ3MucHVzaChvcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfYnVpbGRBcmdzQXRMZWFzdENvbmZpcm1lZChhcmdzLCBvdmVycmlkZSwgZW5jb2RpbmcsIGV4dHJhKSB7XG4gICAgY29uc3QgY29tbWl0bWVudCA9IG92ZXJyaWRlIHx8IHRoaXMuX2NvbW1pdG1lbnQ7XG4gICAgaWYgKGNvbW1pdG1lbnQgJiYgIVsnY29uZmlybWVkJywgJ2ZpbmFsaXplZCddLmluY2x1ZGVzKGNvbW1pdG1lbnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VzaW5nIENvbm5lY3Rpb24gd2l0aCBkZWZhdWx0IGNvbW1pdG1lbnQ6IGAnICsgdGhpcy5fY29tbWl0bWVudCArICdgLCBidXQgbWV0aG9kIHJlcXVpcmVzIGF0IGxlYXN0IGBjb25maXJtZWRgJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9idWlsZEFyZ3MoYXJncywgb3ZlcnJpZGUsIGVuY29kaW5nLCBleHRyYSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBfd3NPblNpZ25hdHVyZU5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgU2lnbmF0dXJlTm90aWZpY2F0aW9uUmVzdWx0KTtcbiAgICBpZiAocmVzdWx0LnZhbHVlICE9PSAncmVjZWl2ZWRTaWduYXR1cmUnKSB7XG4gICAgICAvKipcbiAgICAgICAqIFNwZWNpYWwgY2FzZS5cbiAgICAgICAqIEFmdGVyIGEgc2lnbmF0dXJlIGlzIHByb2Nlc3NlZCwgUlBDcyBhdXRvbWF0aWNhbGx5IGRpc3Bvc2Ugb2YgdGhlXG4gICAgICAgKiBzdWJzY3JpcHRpb24gb24gdGhlIHNlcnZlciBzaWRlLiBXZSBuZWVkIHRvIHRyYWNrIHdoaWNoIG9mIHRoZXNlXG4gICAgICAgKiBzdWJzY3JpcHRpb25zIGhhdmUgYmVlbiBkaXNwb3NlZCBpbiBzdWNoIGEgd2F5LCBzbyB0aGF0IHdlIGtub3dcbiAgICAgICAqIHdoZXRoZXIgdGhlIGNsaWVudCBpcyBkZWFsaW5nIHdpdGggYSBub3QteWV0LXByb2Nlc3NlZCBzaWduYXR1cmVcbiAgICAgICAqIChpbiB3aGljaCBjYXNlIHdlIG11c3QgdGVhciBkb3duIHRoZSBzZXJ2ZXIgc3Vic2NyaXB0aW9uKSBvciBhblxuICAgICAgICogYWxyZWFkeS1wcm9jZXNzZWQgc2lnbmF0dXJlIChpbiB3aGljaCBjYXNlIHRoZSBjbGllbnQgY2FuIHNpbXBseVxuICAgICAgICogY2xlYXIgb3V0IHRoZSBzdWJzY3JpcHRpb24gbG9jYWxseSB3aXRob3V0IHRlbGxpbmcgdGhlIHNlcnZlcikuXG4gICAgICAgKlxuICAgICAgICogTk9URTogVGhlcmUgaXMgYSBwcm9wb3NhbCB0byBlbGltaW5hdGUgdGhpcyBzcGVjaWFsIGNhc2UsIGhlcmU6XG4gICAgICAgKiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2lzc3Vlcy8xODg5MlxuICAgICAgICovXG4gICAgICB0aGlzLl9zdWJzY3JpcHRpb25zQXV0b0Rpc3Bvc2VkQnlScGMuYWRkKHN1YnNjcmlwdGlvbik7XG4gICAgfVxuICAgIHRoaXMuX2hhbmRsZVNlcnZlck5vdGlmaWNhdGlvbihzdWJzY3JpcHRpb24sIHJlc3VsdC52YWx1ZSA9PT0gJ3JlY2VpdmVkU2lnbmF0dXJlJyA/IFt7XG4gICAgICB0eXBlOiAncmVjZWl2ZWQnXG4gICAgfSwgcmVzdWx0LmNvbnRleHRdIDogW3tcbiAgICAgIHR5cGU6ICdzdGF0dXMnLFxuICAgICAgcmVzdWx0OiByZXN1bHQudmFsdWVcbiAgICB9LCByZXN1bHQuY29udGV4dF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHNpZ25hdHVyZSB1cGRhdGVzXG4gICAqXG4gICAqIEBwYXJhbSBzaWduYXR1cmUgVHJhbnNhY3Rpb24gc2lnbmF0dXJlIHN0cmluZyBpbiBiYXNlIDU4XG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugb24gc2lnbmF0dXJlIG5vdGlmaWNhdGlvbnNcbiAgICogQHBhcmFtIGNvbW1pdG1lbnQgU3BlY2lmeSB0aGUgY29tbWl0bWVudCBsZXZlbCBzaWduYXR1cmUgbXVzdCByZWFjaCBiZWZvcmUgbm90aWZpY2F0aW9uXG4gICAqIEByZXR1cm4gc3Vic2NyaXB0aW9uIGlkXG4gICAqL1xuICBvblNpZ25hdHVyZShzaWduYXR1cmUsIGNhbGxiYWNrLCBjb21taXRtZW50KSB7XG4gICAgY29uc3QgYXJncyA9IHRoaXMuX2J1aWxkQXJncyhbc2lnbmF0dXJlXSwgY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgKTtcbiAgICBjb25zdCBjbGllbnRTdWJzY3JpcHRpb25JZCA9IHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2s6IChub3RpZmljYXRpb24sIGNvbnRleHQpID0+IHtcbiAgICAgICAgaWYgKG5vdGlmaWNhdGlvbi50eXBlID09PSAnc3RhdHVzJykge1xuICAgICAgICAgIGNhbGxiYWNrKG5vdGlmaWNhdGlvbi5yZXN1bHQsIGNvbnRleHQpO1xuICAgICAgICAgIC8vIFNpZ25hdHVyZXMgc3Vic2NyaXB0aW9ucyBhcmUgYXV0by1yZW1vdmVkIGJ5IHRoZSBSUEMgc2VydmljZVxuICAgICAgICAgIC8vIHNvIG5vIG5lZWQgdG8gZXhwbGljaXRseSBzZW5kIGFuIHVuc3Vic2NyaWJlIG1lc3NhZ2UuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgfSBjYXRjaCAoX2Vycikge1xuICAgICAgICAgICAgLy8gQWxyZWFkeSByZW1vdmVkLlxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG1ldGhvZDogJ3NpZ25hdHVyZVN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3NpZ25hdHVyZVVuc3Vic2NyaWJlJ1xuICAgIH0sIGFyZ3MpO1xuICAgIHJldHVybiBjbGllbnRTdWJzY3JpcHRpb25JZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIGJlIGludm9rZWQgd2hlbiBhIHRyYW5zYWN0aW9uIGlzXG4gICAqIHJlY2VpdmVkIGFuZC9vciBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzaWduYXR1cmUgVHJhbnNhY3Rpb24gc2lnbmF0dXJlIHN0cmluZyBpbiBiYXNlIDU4XG4gICAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBpbnZva2Ugb24gc2lnbmF0dXJlIG5vdGlmaWNhdGlvbnNcbiAgICogQHBhcmFtIG9wdGlvbnMgRW5hYmxlIHJlY2VpdmVkIG5vdGlmaWNhdGlvbnMgYW5kIHNldCB0aGUgY29tbWl0bWVudFxuICAgKiAgIGxldmVsIHRoYXQgc2lnbmF0dXJlIG11c3QgcmVhY2ggYmVmb3JlIG5vdGlmaWNhdGlvblxuICAgKiBAcmV0dXJuIHN1YnNjcmlwdGlvbiBpZFxuICAgKi9cbiAgb25TaWduYXR1cmVXaXRoT3B0aW9ucyhzaWduYXR1cmUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgY29tbWl0bWVudCxcbiAgICAgIC4uLmV4dHJhXG4gICAgfSA9IHtcbiAgICAgIC4uLm9wdGlvbnMsXG4gICAgICBjb21taXRtZW50OiBvcHRpb25zICYmIG9wdGlvbnMuY29tbWl0bWVudCB8fCB0aGlzLl9jb21taXRtZW50IHx8ICdmaW5hbGl6ZWQnIC8vIEFwcGx5IGNvbm5lY3Rpb24vc2VydmVyIGRlZmF1bHQuXG4gICAgfTtcbiAgICBjb25zdCBhcmdzID0gdGhpcy5fYnVpbGRBcmdzKFtzaWduYXR1cmVdLCBjb21taXRtZW50LCB1bmRlZmluZWQgLyogZW5jb2RpbmcgKi8sIGV4dHJhKTtcbiAgICBjb25zdCBjbGllbnRTdWJzY3JpcHRpb25JZCA9IHRoaXMuX21ha2VTdWJzY3JpcHRpb24oe1xuICAgICAgY2FsbGJhY2s6IChub3RpZmljYXRpb24sIGNvbnRleHQpID0+IHtcbiAgICAgICAgY2FsbGJhY2sobm90aWZpY2F0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgLy8gU2lnbmF0dXJlcyBzdWJzY3JpcHRpb25zIGFyZSBhdXRvLXJlbW92ZWQgYnkgdGhlIFJQQyBzZXJ2aWNlXG4gICAgICAgIC8vIHNvIG5vIG5lZWQgdG8gZXhwbGljaXRseSBzZW5kIGFuIHVuc3Vic2NyaWJlIG1lc3NhZ2UuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVTaWduYXR1cmVMaXN0ZW5lcihjbGllbnRTdWJzY3JpcHRpb25JZCk7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgIH0gY2F0Y2ggKF9lcnIpIHtcbiAgICAgICAgICAvLyBBbHJlYWR5IHJlbW92ZWQuXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtZXRob2Q6ICdzaWduYXR1cmVTdWJzY3JpYmUnLFxuICAgICAgdW5zdWJzY3JpYmVNZXRob2Q6ICdzaWduYXR1cmVVbnN1YnNjcmliZSdcbiAgICB9LCBhcmdzKTtcbiAgICByZXR1cm4gY2xpZW50U3Vic2NyaXB0aW9uSWQ7XG4gIH1cblxuICAvKipcbiAgICogRGVyZWdpc3RlciBhIHNpZ25hdHVyZSBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlU2lnbmF0dXJlTGlzdGVuZXIoY2xpZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICBhd2FpdCB0aGlzLl91bnN1YnNjcmliZUNsaWVudFN1YnNjcmlwdGlvbihjbGllbnRTdWJzY3JpcHRpb25JZCwgJ3NpZ25hdHVyZSByZXN1bHQnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF93c09uUm9vdE5vdGlmaWNhdGlvbihub3RpZmljYXRpb24pIHtcbiAgICBjb25zdCB7XG4gICAgICByZXN1bHQsXG4gICAgICBzdWJzY3JpcHRpb25cbiAgICB9ID0gY3JlYXRlKG5vdGlmaWNhdGlvbiwgUm9vdE5vdGlmaWNhdGlvblJlc3VsdCk7XG4gICAgdGhpcy5faGFuZGxlU2VydmVyTm90aWZpY2F0aW9uKHN1YnNjcmlwdGlvbiwgW3Jlc3VsdF0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB1cG9uIHJvb3QgY2hhbmdlc1xuICAgKlxuICAgKiBAcGFyYW0gY2FsbGJhY2sgRnVuY3Rpb24gdG8gaW52b2tlIHdoZW5ldmVyIHRoZSByb290IGNoYW5nZXNcbiAgICogQHJldHVybiBzdWJzY3JpcHRpb24gaWRcbiAgICovXG4gIG9uUm9vdENoYW5nZShjYWxsYmFjaykge1xuICAgIHJldHVybiB0aGlzLl9tYWtlU3Vic2NyaXB0aW9uKHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgbWV0aG9kOiAncm9vdFN1YnNjcmliZScsXG4gICAgICB1bnN1YnNjcmliZU1ldGhvZDogJ3Jvb3RVbnN1YnNjcmliZSdcbiAgICB9LCBbXSAvKiBhcmdzICovKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVyIGEgcm9vdCBub3RpZmljYXRpb24gY2FsbGJhY2tcbiAgICpcbiAgICogQHBhcmFtIGNsaWVudFN1YnNjcmlwdGlvbklkIGNsaWVudCBzdWJzY3JpcHRpb24gaWQgdG8gZGVyZWdpc3RlclxuICAgKi9cbiAgYXN5bmMgcmVtb3ZlUm9vdENoYW5nZUxpc3RlbmVyKGNsaWVudFN1YnNjcmlwdGlvbklkKSB7XG4gICAgYXdhaXQgdGhpcy5fdW5zdWJzY3JpYmVDbGllbnRTdWJzY3JpcHRpb24oY2xpZW50U3Vic2NyaXB0aW9uSWQsICdyb290IGNoYW5nZScpO1xuICB9XG59XG5cbi8qKlxuICogS2V5cGFpciBzaWduZXIgaW50ZXJmYWNlXG4gKi9cblxuLyoqXG4gKiBBbiBhY2NvdW50IGtleXBhaXIgdXNlZCBmb3Igc2lnbmluZyB0cmFuc2FjdGlvbnMuXG4gKi9cbmNsYXNzIEtleXBhaXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGtleXBhaXIgaW5zdGFuY2UuXG4gICAqIEdlbmVyYXRlIHJhbmRvbSBrZXlwYWlyIGlmIG5vIHtAbGluayBFZDI1NTE5S2V5cGFpcn0gaXMgcHJvdmlkZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7RWQyNTUxOUtleXBhaXJ9IGtleXBhaXIgZWQyNTUxOSBrZXlwYWlyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihrZXlwYWlyKSB7XG4gICAgdGhpcy5fa2V5cGFpciA9IHZvaWQgMDtcbiAgICB0aGlzLl9rZXlwYWlyID0ga2V5cGFpciA/PyBnZW5lcmF0ZUtleXBhaXIoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIG5ldyByYW5kb20ga2V5cGFpclxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5cGFpcn0gS2V5cGFpclxuICAgKi9cbiAgc3RhdGljIGdlbmVyYXRlKCkge1xuICAgIHJldHVybiBuZXcgS2V5cGFpcihnZW5lcmF0ZUtleXBhaXIoKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEga2V5cGFpciBmcm9tIGEgcmF3IHNlY3JldCBrZXkgYnl0ZSBhcnJheS5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIG9ubHkgYmUgdXNlZCB0byByZWNyZWF0ZSBhIGtleXBhaXIgZnJvbSBhIHByZXZpb3VzbHlcbiAgICogZ2VuZXJhdGVkIHNlY3JldCBrZXkuIEdlbmVyYXRpbmcga2V5cGFpcnMgZnJvbSBhIHJhbmRvbSBzZWVkIHNob3VsZCBiZSBkb25lXG4gICAqIHdpdGggdGhlIHtAbGluayBLZXlwYWlyLmZyb21TZWVkfSBtZXRob2QuXG4gICAqXG4gICAqIEB0aHJvd3MgZXJyb3IgaWYgdGhlIHByb3ZpZGVkIHNlY3JldCBrZXkgaXMgaW52YWxpZCBhbmQgdmFsaWRhdGlvbiBpcyBub3Qgc2tpcHBlZC5cbiAgICpcbiAgICogQHBhcmFtIHNlY3JldEtleSBzZWNyZXQga2V5IGJ5dGUgYXJyYXlcbiAgICogQHBhcmFtIG9wdGlvbnMgc2tpcCBzZWNyZXQga2V5IHZhbGlkYXRpb25cbiAgICpcbiAgICogQHJldHVybnMge0tleXBhaXJ9IEtleXBhaXJcbiAgICovXG4gIHN0YXRpYyBmcm9tU2VjcmV0S2V5KHNlY3JldEtleSwgb3B0aW9ucykge1xuICAgIGlmIChzZWNyZXRLZXkuYnl0ZUxlbmd0aCAhPT0gNjQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHNlY3JldCBrZXkgc2l6ZScpO1xuICAgIH1cbiAgICBjb25zdCBwdWJsaWNLZXkgPSBzZWNyZXRLZXkuc2xpY2UoMzIsIDY0KTtcbiAgICBpZiAoIW9wdGlvbnMgfHwgIW9wdGlvbnMuc2tpcFZhbGlkYXRpb24pIHtcbiAgICAgIGNvbnN0IHByaXZhdGVTY2FsYXIgPSBzZWNyZXRLZXkuc2xpY2UoMCwgMzIpO1xuICAgICAgY29uc3QgY29tcHV0ZWRQdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXkocHJpdmF0ZVNjYWxhcik7XG4gICAgICBmb3IgKGxldCBpaSA9IDA7IGlpIDwgMzI7IGlpKyspIHtcbiAgICAgICAgaWYgKHB1YmxpY0tleVtpaV0gIT09IGNvbXB1dGVkUHVibGljS2V5W2lpXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncHJvdmlkZWQgc2VjcmV0S2V5IGlzIGludmFsaWQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3IEtleXBhaXIoe1xuICAgICAgcHVibGljS2V5LFxuICAgICAgc2VjcmV0S2V5XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBrZXlwYWlyIGZyb20gYSAzMiBieXRlIHNlZWQuXG4gICAqXG4gICAqIEBwYXJhbSBzZWVkIHNlZWQgYnl0ZSBhcnJheVxuICAgKlxuICAgKiBAcmV0dXJucyB7S2V5cGFpcn0gS2V5cGFpclxuICAgKi9cbiAgc3RhdGljIGZyb21TZWVkKHNlZWQpIHtcbiAgICBjb25zdCBwdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXkoc2VlZCk7XG4gICAgY29uc3Qgc2VjcmV0S2V5ID0gbmV3IFVpbnQ4QXJyYXkoNjQpO1xuICAgIHNlY3JldEtleS5zZXQoc2VlZCk7XG4gICAgc2VjcmV0S2V5LnNldChwdWJsaWNLZXksIDMyKTtcbiAgICByZXR1cm4gbmV3IEtleXBhaXIoe1xuICAgICAgcHVibGljS2V5LFxuICAgICAgc2VjcmV0S2V5XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHB1YmxpYyBrZXkgZm9yIHRoaXMga2V5cGFpclxuICAgKlxuICAgKiBAcmV0dXJucyB7UHVibGljS2V5fSBQdWJsaWNLZXlcbiAgICovXG4gIGdldCBwdWJsaWNLZXkoKSB7XG4gICAgcmV0dXJuIG5ldyBQdWJsaWNLZXkodGhpcy5fa2V5cGFpci5wdWJsaWNLZXkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByYXcgc2VjcmV0IGtleSBmb3IgdGhpcyBrZXlwYWlyXG4gICAqIEByZXR1cm5zIHtVaW50OEFycmF5fSBTZWNyZXQga2V5IGluIGFuIGFycmF5IG9mIFVpbnQ4IGJ5dGVzXG4gICAqL1xuICBnZXQgc2VjcmV0S2V5KCkge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLl9rZXlwYWlyLnNlY3JldEtleSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBMb29rdXBUYWJsZUluc3RydWN0aW9uVHlwZSdzXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBhZGRyZXNzIGxvb2t1cCB0YWJsZSBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIENyZWF0ZUxvb2t1cFRhYmxlOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB1NjQoJ3JlY2VudFNsb3QnKSwgQnVmZmVyTGF5b3V0LnU4KCdidW1wU2VlZCcpXSlcbiAgfSxcbiAgRnJlZXplTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBFeHRlbmRMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgdTY0KCksIEJ1ZmZlckxheW91dC5zZXEocHVibGljS2V5KCksIEJ1ZmZlckxheW91dC5vZmZzZXQoQnVmZmVyTGF5b3V0LnUzMigpLCAtOCksICdhZGRyZXNzZXMnKV0pXG4gIH0sXG4gIERlYWN0aXZhdGVMb29rdXBUYWJsZToge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIENsb3NlTG9va3VwVGFibGU6IHtcbiAgICBpbmRleDogNCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9XG59KTtcbmNsYXNzIEFkZHJlc3NMb29rdXBUYWJsZUluc3RydWN0aW9uIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgaW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2xheW91dFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMpKSB7XG4gICAgICBpZiAobGF5b3V0LmluZGV4ID09IGluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBsYXlvdXRUeXBlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgSW5zdHJ1Y3Rpb24uIFNob3VsZCBiZSBhIExvb2t1cFRhYmxlIEluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG4gIHN0YXRpYyBkZWNvZGVDcmVhdGVMb29rdXBUYWJsZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5c0xlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA0KTtcbiAgICBjb25zdCB7XG4gICAgICByZWNlbnRTbG90XG4gICAgfSA9IGRlY29kZURhdGEkMShMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5DcmVhdGVMb29rdXBUYWJsZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBwYXllcjogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICByZWNlbnRTbG90OiBOdW1iZXIocmVjZW50U2xvdClcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBkZWNvZGVFeHRlbmRMb29rdXBUYWJsZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPCAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7aW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0IDJgKTtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgYWRkcmVzc2VzXG4gICAgfSA9IGRlY29kZURhdGEkMShMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5FeHRlbmRMb29rdXBUYWJsZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvb2t1cFRhYmxlOiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBwYXllcjogaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiAyID8gaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXkgOiB1bmRlZmluZWQsXG4gICAgICBhZGRyZXNzZXM6IGFkZHJlc3Nlcy5tYXAoYnVmZmVyID0+IG5ldyBQdWJsaWNLZXkoYnVmZmVyKSlcbiAgICB9O1xuICB9XG4gIHN0YXRpYyBkZWNvZGVDbG9zZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIHJldHVybiB7XG4gICAgICBsb29rdXBUYWJsZTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgcmVjaXBpZW50OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleVxuICAgIH07XG4gIH1cbiAgc3RhdGljIGRlY29kZUZyZWV6ZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIHJldHVybiB7XG4gICAgICBsb29rdXBUYWJsZTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5XG4gICAgfTtcbiAgfVxuICBzdGF0aWMgZGVjb2RlRGVhY3RpdmF0ZUxvb2t1cFRhYmxlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlzTGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDIpO1xuICAgIHJldHVybiB7XG4gICAgICBsb29rdXBUYWJsZTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpdHk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja1Byb2dyYW1JZChwcm9ncmFtSWQpIHtcbiAgICBpZiAoIXByb2dyYW1JZC5lcXVhbHMoQWRkcmVzc0xvb2t1cFRhYmxlUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgQWRkcmVzc0xvb2t1cFRhYmxlIFByb2dyYW0nKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrS2V5c0xlbmd0aChrZXlzLCBleHBlY3RlZExlbmd0aCkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBBZGRyZXNzTG9va3VwVGFibGVQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuICBzdGF0aWMgY3JlYXRlTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgW2xvb2t1cFRhYmxlQWRkcmVzcywgYnVtcFNlZWRdID0gUHVibGljS2V5LmZpbmRQcm9ncmFtQWRkcmVzc1N5bmMoW3BhcmFtcy5hdXRob3JpdHkudG9CdWZmZXIoKSwgdG9CdWZmZXJMRShCaWdJbnQocGFyYW1zLnJlY2VudFNsb3QpLCA4KV0sIHRoaXMucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB0eXBlID0gTE9PS1VQX1RBQkxFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQ3JlYXRlTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgcmVjZW50U2xvdDogQmlnSW50KHBhcmFtcy5yZWNlbnRTbG90KSxcbiAgICAgIGJ1bXBTZWVkOiBidW1wU2VlZFxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBsb29rdXBUYWJsZUFkZHJlc3MsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLnBheWVyLFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIFtuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSwgbG9va3VwVGFibGVBZGRyZXNzXTtcbiAgfVxuICBzdGF0aWMgZnJlZXplTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkZyZWV6ZUxvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZXh0ZW5kTG9va3VwVGFibGUocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IExPT0tVUF9UQUJMRV9JTlNUUlVDVElPTl9MQVlPVVRTLkV4dGVuZExvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGFkZHJlc3NlczogcGFyYW1zLmFkZHJlc3Nlcy5tYXAoYWRkciA9PiBhZGRyLnRvQnl0ZXMoKSlcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogcGFyYW1zLmxvb2t1cFRhYmxlLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLmF1dGhvcml0eSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9XTtcbiAgICBpZiAocGFyYW1zLnBheWVyKSB7XG4gICAgICBrZXlzLnB1c2goe1xuICAgICAgICBwdWJrZXk6IHBhcmFtcy5wYXllcixcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTeXN0ZW1Qcm9ncmFtLnByb2dyYW1JZCxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAga2V5czoga2V5cyxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZGVhY3RpdmF0ZUxvb2t1cFRhYmxlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWFjdGl2YXRlTG9va3VwVGFibGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5sb29rdXBUYWJsZSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHBhcmFtcy5hdXRob3JpdHksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBrZXlzOiBrZXlzLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyBjbG9zZUxvb2t1cFRhYmxlKHBhcmFtcykge1xuICAgIGNvbnN0IHR5cGUgPSBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5DbG9zZUxvb2t1cFRhYmxlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUpO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBwYXJhbXMubG9va3VwVGFibGUsXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBwYXJhbXMuYXV0aG9yaXR5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogcGFyYW1zLnJlY2lwaWVudCxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9XTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGtleXM6IGtleXMsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH1cbn1cbkFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnQWRkcmVzc0xvb2t1cFRhYjFlMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIENvbXB1dGUgQnVkZ2V0IEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiB0eXBlLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluc3RydWN0aW9uVHlwZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCBpbnN0cnVjdGlvblR5cGVMYXlvdXQgPSBCdWZmZXJMYXlvdXQudTgoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgdHlwZUluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBsZXQgdHlwZTtcbiAgICBmb3IgKGNvbnN0IFtpeFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUykpIHtcbiAgICAgIGlmIChsYXlvdXQuaW5kZXggPT0gdHlwZUluZGV4KSB7XG4gICAgICAgIHR5cGUgPSBpeFR5cGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXR5cGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW5zdHJ1Y3Rpb24gdHlwZSBpbmNvcnJlY3Q7IG5vdCBhIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgcmVxdWVzdCB1bml0cyBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVSZXF1ZXN0VW5pdHMoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3Qge1xuICAgICAgdW5pdHMsXG4gICAgICBhZGRpdGlvbmFsRmVlXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RVbml0cywgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHVuaXRzLFxuICAgICAgYWRkaXRpb25hbEZlZVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHJlcXVlc3QgaGVhcCBmcmFtZSBjb21wdXRlIGJ1ZGdldCBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVSZXF1ZXN0SGVhcEZyYW1lKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IHtcbiAgICAgIGJ5dGVzXG4gICAgfSA9IGRlY29kZURhdGEkMShDT01QVVRFX0JVREdFVF9JTlNUUlVDVElPTl9MQVlPVVRTLlJlcXVlc3RIZWFwRnJhbWUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBieXRlc1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIHNldCBjb21wdXRlIHVuaXQgbGltaXQgY29tcHV0ZSBidWRnZXQgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlU2V0Q29tcHV0ZVVuaXRMaW1pdChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICBjb25zdCB7XG4gICAgICB1bml0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdExpbWl0LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdW5pdHNcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBzZXQgY29tcHV0ZSB1bml0IHByaWNlIGNvbXB1dGUgYnVkZ2V0IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVNldENvbXB1dGVVbml0UHJpY2UoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3Qge1xuICAgICAgbWljcm9MYW1wb3J0c1xuICAgIH0gPSBkZWNvZGVEYXRhJDEoQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdFByaWNlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgbWljcm9MYW1wb3J0c1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tQcm9ncmFtSWQocHJvZ3JhbUlkKSB7XG4gICAgaWYgKCFwcm9ncmFtSWQuZXF1YWxzKENvbXB1dGVCdWRnZXRQcm9ncmFtLnByb2dyYW1JZCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbnN0cnVjdGlvbjsgcHJvZ3JhbUlkIGlzIG5vdCBDb21wdXRlQnVkZ2V0UHJvZ3JhbScpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKlxuICogUmVxdWVzdCB1bml0cyBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFJlcXVlc3QgaGVhcCBmcmFtZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFNldCBjb21wdXRlIHVuaXQgbGltaXQgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBTZXQgY29tcHV0ZSB1bml0IHByaWNlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgQ29tcHV0ZUJ1ZGdldCBJbnN0cnVjdGlvblR5cGUnc1xuICogQGludGVybmFsXG4gKi9cbmNvbnN0IENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMgPSBPYmplY3QuZnJlZXplKHtcbiAgUmVxdWVzdFVuaXRzOiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTgoJ2luc3RydWN0aW9uJyksIEJ1ZmZlckxheW91dC51MzIoJ3VuaXRzJyksIEJ1ZmZlckxheW91dC51MzIoJ2FkZGl0aW9uYWxGZWUnKV0pXG4gIH0sXG4gIFJlcXVlc3RIZWFwRnJhbWU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0LnUzMignYnl0ZXMnKV0pXG4gIH0sXG4gIFNldENvbXB1dGVVbml0TGltaXQ6IHtcbiAgICBpbmRleDogMixcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0LnUzMigndW5pdHMnKV0pXG4gIH0sXG4gIFNldENvbXB1dGVVbml0UHJpY2U6IHtcbiAgICBpbmRleDogMyxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnaW5zdHJ1Y3Rpb24nKSwgdTY0KCdtaWNyb0xhbXBvcnRzJyldKVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbiBpbnN0cnVjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgQ29tcHV0ZSBCdWRnZXQgcHJvZ3JhbVxuICovXG5jbGFzcyBDb21wdXRlQnVkZ2V0UHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIENvbXB1dGUgQnVkZ2V0IHByb2dyYW1cbiAgICovXG5cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIEluc3RlYWQsIGNhbGwge0BsaW5rIHNldENvbXB1dGVVbml0TGltaXR9IGFuZC9vciB7QGxpbmsgc2V0Q29tcHV0ZVVuaXRQcmljZX1cbiAgICovXG4gIHN0YXRpYyByZXF1ZXN0VW5pdHMocGFyYW1zKSB7XG4gICAgY29uc3QgdHlwZSA9IENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMuUmVxdWVzdFVuaXRzO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgcmVxdWVzdEhlYXBGcmFtZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5SZXF1ZXN0SGVhcEZyYW1lO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgc2V0Q29tcHV0ZVVuaXRMaW1pdChwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdExpbWl0O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHBhcmFtcyk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgc2V0Q29tcHV0ZVVuaXRQcmljZShwYXJhbXMpIHtcbiAgICBjb25zdCB0eXBlID0gQ09NUFVURV9CVURHRVRfSU5TVFJVQ1RJT05fTEFZT1VUUy5TZXRDb21wdXRlVW5pdFByaWNlO1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIG1pY3JvTGFtcG9ydHM6IEJpZ0ludChwYXJhbXMubWljcm9MYW1wb3J0cylcbiAgICB9KTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG59XG5Db21wdXRlQnVkZ2V0UHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdDb21wdXRlQnVkZ2V0MTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbmNvbnN0IFBSSVZBVEVfS0VZX0JZVEVTJDEgPSA2NDtcbmNvbnN0IFBVQkxJQ19LRVlfQllURVMkMSA9IDMyO1xuY29uc3QgU0lHTkFUVVJFX0JZVEVTID0gNjQ7XG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHVzaW5nIGEgcHVibGljIGtleVxuICovXG5cbi8qKlxuICogUGFyYW1zIGZvciBjcmVhdGluZyBhbiBlZDI1NTE5IGluc3RydWN0aW9uIHVzaW5nIGEgcHJpdmF0ZSBrZXlcbiAqL1xuXG5jb25zdCBFRDI1NTE5X0lOU1RSVUNUSU9OX0xBWU9VVCA9IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51OCgnbnVtU2lnbmF0dXJlcycpLCBCdWZmZXJMYXlvdXQudTgoJ3BhZGRpbmcnKSwgQnVmZmVyTGF5b3V0LnUxNignc2lnbmF0dXJlT2Zmc2V0JyksIEJ1ZmZlckxheW91dC51MTYoJ3NpZ25hdHVyZUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LnUxNigncHVibGljS2V5T2Zmc2V0JyksIEJ1ZmZlckxheW91dC51MTYoJ3B1YmxpY0tleUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZURhdGFPZmZzZXQnKSwgQnVmZmVyTGF5b3V0LnUxNignbWVzc2FnZURhdGFTaXplJyksIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VJbnN0cnVjdGlvbkluZGV4JyldKTtcbmNsYXNzIEVkMjU1MTlQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgZWQyNTUxOSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZWQyNTUxOSBpbnN0cnVjdGlvbiB3aXRoIGEgcHVibGljIGtleSBhbmQgc2lnbmF0dXJlLiBUaGVcbiAgICogcHVibGljIGtleSBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgMzIgYnl0ZXMgbG9uZywgYW5kIHRoZSBzaWduYXR1cmVcbiAgICogbXVzdCBiZSBhIGJ1ZmZlciBvZiA2NCBieXRlcy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHVibGljS2V5LFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIGluc3RydWN0aW9uSW5kZXhcbiAgICB9ID0gcGFyYW1zO1xuICAgIGFzc2VydChwdWJsaWNLZXkubGVuZ3RoID09PSBQVUJMSUNfS0VZX0JZVEVTJDEsIGBQdWJsaWMgS2V5IG11c3QgYmUgJHtQVUJMSUNfS0VZX0JZVEVTJDF9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3B1YmxpY0tleS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgYXNzZXJ0KHNpZ25hdHVyZS5sZW5ndGggPT09IFNJR05BVFVSRV9CWVRFUywgYFNpZ25hdHVyZSBtdXN0IGJlICR7U0lHTkFUVVJFX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtzaWduYXR1cmUubGVuZ3RofSBieXRlc2ApO1xuICAgIGNvbnN0IHB1YmxpY0tleU9mZnNldCA9IEVEMjU1MTlfSU5TVFJVQ1RJT05fTEFZT1VULnNwYW47XG4gICAgY29uc3Qgc2lnbmF0dXJlT2Zmc2V0ID0gcHVibGljS2V5T2Zmc2V0ICsgcHVibGljS2V5Lmxlbmd0aDtcbiAgICBjb25zdCBtZXNzYWdlRGF0YU9mZnNldCA9IHNpZ25hdHVyZU9mZnNldCArIHNpZ25hdHVyZS5sZW5ndGg7XG4gICAgY29uc3QgbnVtU2lnbmF0dXJlcyA9IDE7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmFsbG9jKG1lc3NhZ2VEYXRhT2Zmc2V0ICsgbWVzc2FnZS5sZW5ndGgpO1xuICAgIGNvbnN0IGluZGV4ID0gaW5zdHJ1Y3Rpb25JbmRleCA9PSBudWxsID8gMHhmZmZmIC8vIEFuIGluZGV4IG9mIGB1MTY6Ok1BWGAgbWFrZXMgaXQgZGVmYXVsdCB0byB0aGUgY3VycmVudCBpbnN0cnVjdGlvbi5cbiAgICA6IGluc3RydWN0aW9uSW5kZXg7XG4gICAgRUQyNTUxOV9JTlNUUlVDVElPTl9MQVlPVVQuZW5jb2RlKHtcbiAgICAgIG51bVNpZ25hdHVyZXMsXG4gICAgICBwYWRkaW5nOiAwLFxuICAgICAgc2lnbmF0dXJlT2Zmc2V0LFxuICAgICAgc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleDogaW5kZXgsXG4gICAgICBwdWJsaWNLZXlPZmZzZXQsXG4gICAgICBwdWJsaWNLZXlJbnN0cnVjdGlvbkluZGV4OiBpbmRleCxcbiAgICAgIG1lc3NhZ2VEYXRhT2Zmc2V0LFxuICAgICAgbWVzc2FnZURhdGFTaXplOiBtZXNzYWdlLmxlbmd0aCxcbiAgICAgIG1lc3NhZ2VJbnN0cnVjdGlvbkluZGV4OiBpbmRleFxuICAgIH0sIGluc3RydWN0aW9uRGF0YSk7XG4gICAgaW5zdHJ1Y3Rpb25EYXRhLmZpbGwocHVibGljS2V5LCBwdWJsaWNLZXlPZmZzZXQpO1xuICAgIGluc3RydWN0aW9uRGF0YS5maWxsKHNpZ25hdHVyZSwgc2lnbmF0dXJlT2Zmc2V0KTtcbiAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbChtZXNzYWdlLCBtZXNzYWdlRGF0YU9mZnNldCk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKHtcbiAgICAgIGtleXM6IFtdLFxuICAgICAgcHJvZ3JhbUlkOiBFZDI1NTE5UHJvZ3JhbS5wcm9ncmFtSWQsXG4gICAgICBkYXRhOiBpbnN0cnVjdGlvbkRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZWQyNTUxOSBpbnN0cnVjdGlvbiB3aXRoIGEgcHJpdmF0ZSBrZXkuIFRoZSBwcml2YXRlIGtleVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgNjQgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVLZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0gPSBwYXJhbXM7XG4gICAgYXNzZXJ0KHByaXZhdGVLZXkubGVuZ3RoID09PSBQUklWQVRFX0tFWV9CWVRFUyQxLCBgUHJpdmF0ZSBrZXkgbXVzdCBiZSAke1BSSVZBVEVfS0VZX0JZVEVTJDF9IGJ5dGVzIGJ1dCByZWNlaXZlZCAke3ByaXZhdGVLZXkubGVuZ3RofSBieXRlc2ApO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBrZXlwYWlyID0gS2V5cGFpci5mcm9tU2VjcmV0S2V5KHByaXZhdGVLZXkpO1xuICAgICAgY29uc3QgcHVibGljS2V5ID0ga2V5cGFpci5wdWJsaWNLZXkudG9CeXRlcygpO1xuICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbihtZXNzYWdlLCBrZXlwYWlyLnNlY3JldEtleSk7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkoe1xuICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY3JlYXRpbmcgaW5zdHJ1Y3Rpb247ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG59XG5FZDI1NTE5UHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdFZDI1NTE5U2lnVmVyaWZ5MTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbmNvbnN0IGVjZHNhU2lnbiA9IChtc2dIYXNoLCBwcml2S2V5KSA9PiB7XG4gIGNvbnN0IHNpZ25hdHVyZSA9IHNlY3AyNTZrMS5zaWduKG1zZ0hhc2gsIHByaXZLZXkpO1xuICByZXR1cm4gW3NpZ25hdHVyZS50b0NvbXBhY3RSYXdCeXRlcygpLCBzaWduYXR1cmUucmVjb3ZlcnldO1xufTtcbnNlY3AyNTZrMS51dGlscy5pc1ZhbGlkUHJpdmF0ZUtleTtcbmNvbnN0IHB1YmxpY0tleUNyZWF0ZSA9IHNlY3AyNTZrMS5nZXRQdWJsaWNLZXk7XG5cbmNvbnN0IFBSSVZBVEVfS0VZX0JZVEVTID0gMzI7XG5jb25zdCBFVEhFUkVVTV9BRERSRVNTX0JZVEVTID0gMjA7XG5jb25zdCBQVUJMSUNfS0VZX0JZVEVTID0gNjQ7XG5jb25zdCBTSUdOQVRVUkVfT0ZGU0VUU19TRVJJQUxJWkVEX1NJWkUgPSAxMTtcblxuLyoqXG4gKiBQYXJhbXMgZm9yIGNyZWF0aW5nIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB1c2luZyBhIHB1YmxpYyBrZXlcbiAqL1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGFuIEV0aGVyZXVtIGFkZHJlc3NcbiAqL1xuXG4vKipcbiAqIFBhcmFtcyBmb3IgY3JlYXRpbmcgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHVzaW5nIGEgcHJpdmF0ZSBrZXlcbiAqL1xuXG5jb25zdCBTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VUID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnU4KCdudW1TaWduYXR1cmVzJyksIEJ1ZmZlckxheW91dC51MTYoJ3NpZ25hdHVyZU9mZnNldCcpLCBCdWZmZXJMYXlvdXQudTgoJ3NpZ25hdHVyZUluc3RydWN0aW9uSW5kZXgnKSwgQnVmZmVyTGF5b3V0LnUxNignZXRoQWRkcmVzc09mZnNldCcpLCBCdWZmZXJMYXlvdXQudTgoJ2V0aEFkZHJlc3NJbnN0cnVjdGlvbkluZGV4JyksIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VEYXRhT2Zmc2V0JyksIEJ1ZmZlckxheW91dC51MTYoJ21lc3NhZ2VEYXRhU2l6ZScpLCBCdWZmZXJMYXlvdXQudTgoJ21lc3NhZ2VJbnN0cnVjdGlvbkluZGV4JyksIEJ1ZmZlckxheW91dC5ibG9iKDIwLCAnZXRoQWRkcmVzcycpLCBCdWZmZXJMYXlvdXQuYmxvYig2NCwgJ3NpZ25hdHVyZScpLCBCdWZmZXJMYXlvdXQudTgoJ3JlY292ZXJ5SWQnKV0pO1xuY2xhc3MgU2VjcDI1NmsxUHJvZ3JhbSB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUHVibGljIGtleSB0aGF0IGlkZW50aWZpZXMgdGhlIHNlY3AyNTZrMSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3QgYW4gRXRoZXJldW0gYWRkcmVzcyBmcm9tIGEgc2VjcDI1NmsxIHB1YmxpYyBrZXkgYnVmZmVyLlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gcHVibGljS2V5IGEgNjQgYnl0ZSBzZWNwMjU2azEgcHVibGljIGtleSBidWZmZXJcbiAgICovXG4gIHN0YXRpYyBwdWJsaWNLZXlUb0V0aEFkZHJlc3MocHVibGljS2V5KSB7XG4gICAgYXNzZXJ0KHB1YmxpY0tleS5sZW5ndGggPT09IFBVQkxJQ19LRVlfQllURVMsIGBQdWJsaWMga2V5IG11c3QgYmUgJHtQVUJMSUNfS0VZX0JZVEVTfSBieXRlcyBidXQgcmVjZWl2ZWQgJHtwdWJsaWNLZXkubGVuZ3RofSBieXRlc2ApO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oa2VjY2FrXzI1Nih0b0J1ZmZlcihwdWJsaWNLZXkpKSkuc2xpY2UoLUVUSEVSRVVNX0FERFJFU1NfQllURVMpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGNvbnN0cnVjdGluZyBFdGhlcmV1bSBhZGRyZXNzOiAke2Vycm9yfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHdpdGggYSBwdWJsaWMga2V5LiBUaGUgcHVibGljIGtleVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgNjQgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgcHVibGljS2V5LFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNpZ25hdHVyZSxcbiAgICAgIHJlY292ZXJ5SWQsXG4gICAgICBpbnN0cnVjdGlvbkluZGV4XG4gICAgfSA9IHBhcmFtcztcbiAgICByZXR1cm4gU2VjcDI1NmsxUHJvZ3JhbS5jcmVhdGVJbnN0cnVjdGlvbldpdGhFdGhBZGRyZXNzKHtcbiAgICAgIGV0aEFkZHJlc3M6IFNlY3AyNTZrMVByb2dyYW0ucHVibGljS2V5VG9FdGhBZGRyZXNzKHB1YmxpY0tleSksXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2lnbmF0dXJlLFxuICAgICAgcmVjb3ZlcnlJZCxcbiAgICAgIGluc3RydWN0aW9uSW5kZXhcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gc2VjcDI1NmsxIGluc3RydWN0aW9uIHdpdGggYW4gRXRoZXJldW0gYWRkcmVzcy4gVGhlIGFkZHJlc3NcbiAgICogbXVzdCBiZSBhIGhleCBzdHJpbmcgb3IgYSBidWZmZXIgdGhhdCBpcyAyMCBieXRlcyBsb25nLlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUluc3RydWN0aW9uV2l0aEV0aEFkZHJlc3MocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgZXRoQWRkcmVzczogcmF3QWRkcmVzcyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBzaWduYXR1cmUsXG4gICAgICByZWNvdmVyeUlkLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleCA9IDBcbiAgICB9ID0gcGFyYW1zO1xuICAgIGxldCBldGhBZGRyZXNzO1xuICAgIGlmICh0eXBlb2YgcmF3QWRkcmVzcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChyYXdBZGRyZXNzLnN0YXJ0c1dpdGgoJzB4JykpIHtcbiAgICAgICAgZXRoQWRkcmVzcyA9IEJ1ZmZlci5mcm9tKHJhd0FkZHJlc3Muc3Vic3RyKDIpLCAnaGV4Jyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBldGhBZGRyZXNzID0gQnVmZmVyLmZyb20ocmF3QWRkcmVzcywgJ2hleCcpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBldGhBZGRyZXNzID0gcmF3QWRkcmVzcztcbiAgICB9XG4gICAgYXNzZXJ0KGV0aEFkZHJlc3MubGVuZ3RoID09PSBFVEhFUkVVTV9BRERSRVNTX0JZVEVTLCBgQWRkcmVzcyBtdXN0IGJlICR7RVRIRVJFVU1fQUREUkVTU19CWVRFU30gYnl0ZXMgYnV0IHJlY2VpdmVkICR7ZXRoQWRkcmVzcy5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgY29uc3QgZGF0YVN0YXJ0ID0gMSArIFNJR05BVFVSRV9PRkZTRVRTX1NFUklBTElaRURfU0laRTtcbiAgICBjb25zdCBldGhBZGRyZXNzT2Zmc2V0ID0gZGF0YVN0YXJ0O1xuICAgIGNvbnN0IHNpZ25hdHVyZU9mZnNldCA9IGRhdGFTdGFydCArIGV0aEFkZHJlc3MubGVuZ3RoO1xuICAgIGNvbnN0IG1lc3NhZ2VEYXRhT2Zmc2V0ID0gc2lnbmF0dXJlT2Zmc2V0ICsgc2lnbmF0dXJlLmxlbmd0aCArIDE7XG4gICAgY29uc3QgbnVtU2lnbmF0dXJlcyA9IDE7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0gQnVmZmVyLmFsbG9jKFNFQ1AyNTZLMV9JTlNUUlVDVElPTl9MQVlPVVQuc3BhbiArIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICBTRUNQMjU2SzFfSU5TVFJVQ1RJT05fTEFZT1VULmVuY29kZSh7XG4gICAgICBudW1TaWduYXR1cmVzLFxuICAgICAgc2lnbmF0dXJlT2Zmc2V0LFxuICAgICAgc2lnbmF0dXJlSW5zdHJ1Y3Rpb25JbmRleDogaW5zdHJ1Y3Rpb25JbmRleCxcbiAgICAgIGV0aEFkZHJlc3NPZmZzZXQsXG4gICAgICBldGhBZGRyZXNzSW5zdHJ1Y3Rpb25JbmRleDogaW5zdHJ1Y3Rpb25JbmRleCxcbiAgICAgIG1lc3NhZ2VEYXRhT2Zmc2V0LFxuICAgICAgbWVzc2FnZURhdGFTaXplOiBtZXNzYWdlLmxlbmd0aCxcbiAgICAgIG1lc3NhZ2VJbnN0cnVjdGlvbkluZGV4OiBpbnN0cnVjdGlvbkluZGV4LFxuICAgICAgc2lnbmF0dXJlOiB0b0J1ZmZlcihzaWduYXR1cmUpLFxuICAgICAgZXRoQWRkcmVzczogdG9CdWZmZXIoZXRoQWRkcmVzcyksXG4gICAgICByZWNvdmVyeUlkXG4gICAgfSwgaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgICBpbnN0cnVjdGlvbkRhdGEuZmlsbCh0b0J1ZmZlcihtZXNzYWdlKSwgU0VDUDI1NksxX0lOU1RSVUNUSU9OX0xBWU9VVC5zcGFuKTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oe1xuICAgICAga2V5czogW10sXG4gICAgICBwcm9ncmFtSWQ6IFNlY3AyNTZrMVByb2dyYW0ucHJvZ3JhbUlkLFxuICAgICAgZGF0YTogaW5zdHJ1Y3Rpb25EYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIHNlY3AyNTZrMSBpbnN0cnVjdGlvbiB3aXRoIGEgcHJpdmF0ZSBrZXkuIFRoZSBwcml2YXRlIGtleVxuICAgKiBtdXN0IGJlIGEgYnVmZmVyIHRoYXQgaXMgMzIgYnl0ZXMgbG9uZy5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVJbnN0cnVjdGlvbldpdGhQcml2YXRlS2V5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHByaXZhdGVLZXk6IHBrZXksXG4gICAgICBtZXNzYWdlLFxuICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgIH0gPSBwYXJhbXM7XG4gICAgYXNzZXJ0KHBrZXkubGVuZ3RoID09PSBQUklWQVRFX0tFWV9CWVRFUywgYFByaXZhdGUga2V5IG11c3QgYmUgJHtQUklWQVRFX0tFWV9CWVRFU30gYnl0ZXMgYnV0IHJlY2VpdmVkICR7cGtleS5sZW5ndGh9IGJ5dGVzYCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHByaXZhdGVLZXkgPSB0b0J1ZmZlcihwa2V5KTtcbiAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHB1YmxpY0tleUNyZWF0ZShwcml2YXRlS2V5LCBmYWxzZSAvKiBpc0NvbXByZXNzZWQgKi8pLnNsaWNlKDEpOyAvLyB0aHJvdyBhd2F5IGxlYWRpbmcgYnl0ZVxuICAgICAgY29uc3QgbWVzc2FnZUhhc2ggPSBCdWZmZXIuZnJvbShrZWNjYWtfMjU2KHRvQnVmZmVyKG1lc3NhZ2UpKSk7XG4gICAgICBjb25zdCBbc2lnbmF0dXJlLCByZWNvdmVyeUlkXSA9IGVjZHNhU2lnbihtZXNzYWdlSGFzaCwgcHJpdmF0ZUtleSk7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVJbnN0cnVjdGlvbldpdGhQdWJsaWNLZXkoe1xuICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgIG1lc3NhZ2UsXG4gICAgICAgIHNpZ25hdHVyZSxcbiAgICAgICAgcmVjb3ZlcnlJZCxcbiAgICAgICAgaW5zdHJ1Y3Rpb25JbmRleFxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgY3JlYXRpbmcgaW5zdHJ1Y3Rpb247ICR7ZXJyb3J9YCk7XG4gICAgfVxuICB9XG59XG5TZWNwMjU2azFQcm9ncmFtLnByb2dyYW1JZCA9IG5ldyBQdWJsaWNLZXkoJ0tlY2Nha1NlY3AyNTZrMTExMTExMTExMTExMTExMTExMTExMTExMTExMTEnKTtcblxudmFyIF9Mb2NrdXA7XG5cbi8qKlxuICogQWRkcmVzcyBvZiB0aGUgc3Rha2UgY29uZmlnIGFjY291bnQgd2hpY2ggY29uZmlndXJlcyB0aGUgcmF0ZVxuICogb2Ygc3Rha2Ugd2FybXVwIGFuZCBjb29sZG93biBhcyB3ZWxsIGFzIHRoZSBzbGFzaGluZyBwZW5hbHR5LlxuICovXG5jb25zdCBTVEFLRV9DT05GSUdfSUQgPSBuZXcgUHVibGljS2V5KCdTdGFrZUNvbmZpZzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogU3Rha2UgYWNjb3VudCBhdXRob3JpdHkgaW5mb1xuICovXG5jbGFzcyBBdXRob3JpemVkIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBBdXRob3JpemVkIG9iamVjdFxuICAgKiBAcGFyYW0gc3Rha2VyIHRoZSBzdGFrZSBhdXRob3JpdHlcbiAgICogQHBhcmFtIHdpdGhkcmF3ZXIgdGhlIHdpdGhkcmF3IGF1dGhvcml0eVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc3Rha2VyLCB3aXRoZHJhd2VyKSB7XG4gICAgLyoqIHN0YWtlIGF1dGhvcml0eSAqL1xuICAgIHRoaXMuc3Rha2VyID0gdm9pZCAwO1xuICAgIC8qKiB3aXRoZHJhdyBhdXRob3JpdHkgKi9cbiAgICB0aGlzLndpdGhkcmF3ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5zdGFrZXIgPSBzdGFrZXI7XG4gICAgdGhpcy53aXRoZHJhd2VyID0gd2l0aGRyYXdlcjtcbiAgfVxufVxuLyoqXG4gKiBTdGFrZSBhY2NvdW50IGxvY2t1cCBpbmZvXG4gKi9cbmNsYXNzIExvY2t1cCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgTG9ja3VwIG9iamVjdFxuICAgKi9cbiAgY29uc3RydWN0b3IodW5peFRpbWVzdGFtcCwgZXBvY2gsIGN1c3RvZGlhbikge1xuICAgIC8qKiBVbml4IHRpbWVzdGFtcCBvZiBsb2NrdXAgZXhwaXJhdGlvbiAqL1xuICAgIHRoaXMudW5peFRpbWVzdGFtcCA9IHZvaWQgMDtcbiAgICAvKiogRXBvY2ggb2YgbG9ja3VwIGV4cGlyYXRpb24gKi9cbiAgICB0aGlzLmVwb2NoID0gdm9pZCAwO1xuICAgIC8qKiBMb2NrdXAgY3VzdG9kaWFuIGF1dGhvcml0eSAqL1xuICAgIHRoaXMuY3VzdG9kaWFuID0gdm9pZCAwO1xuICAgIHRoaXMudW5peFRpbWVzdGFtcCA9IHVuaXhUaW1lc3RhbXA7XG4gICAgdGhpcy5lcG9jaCA9IGVwb2NoO1xuICAgIHRoaXMuY3VzdG9kaWFuID0gY3VzdG9kaWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmF1bHQsIGluYWN0aXZlIExvY2t1cCB2YWx1ZVxuICAgKi9cbn1cbl9Mb2NrdXAgPSBMb2NrdXA7XG5Mb2NrdXAuZGVmYXVsdCA9IG5ldyBfTG9ja3VwKDAsIDAsIFB1YmxpY0tleS5kZWZhdWx0KTtcbi8qKlxuICogQ3JlYXRlIHN0YWtlIGFjY291bnQgdHJhbnNhY3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogQ3JlYXRlIHN0YWtlIGFjY291bnQgd2l0aCBzZWVkIHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIEluaXRpYWxpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogRGVsZWdhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cbi8qKlxuICogQXV0aG9yaXplIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIEF1dGhvcml6ZSBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXMgdXNpbmcgYSBkZXJpdmVkIGtleVxuICovXG4vKipcbiAqIFNwbGl0IHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIFNwbGl0IHdpdGggc2VlZCB0cmFuc2FjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBXaXRoZHJhdyBzdGFrZSBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuLyoqXG4gKiBEZWFjdGl2YXRlIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIE1lcmdlIHN0YWtlIGluc3RydWN0aW9uIHBhcmFtc1xuICovXG4vKipcbiAqIFN0YWtlIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFN0YWtlSW5zdHJ1Y3Rpb24ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gdHlwZS5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVJbnN0cnVjdGlvblR5cGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0ID0gQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKTtcbiAgICBjb25zdCB0eXBlSW5kZXggPSBpbnN0cnVjdGlvblR5cGVMYXlvdXQuZGVjb2RlKGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGxldCB0eXBlO1xuICAgIGZvciAoY29uc3QgW2l4VHlwZSwgbGF5b3V0XSBvZiBPYmplY3QuZW50cmllcyhTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGl4VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0cnVjdGlvbiB0eXBlIGluY29ycmVjdDsgbm90IGEgU3Rha2VJbnN0cnVjdGlvbicpO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBpbml0aWFsaXplIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZUluaXRpYWxpemUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSA9IGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemUsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkOiBuZXcgQXV0aG9yaXplZChuZXcgUHVibGljS2V5KGF1dGhvcml6ZWQuc3Rha2VyKSwgbmV3IFB1YmxpY0tleShhdXRob3JpemVkLndpdGhkcmF3ZXIpKSxcbiAgICAgIGxvY2t1cDogbmV3IExvY2t1cChsb2NrdXAudW5peFRpbWVzdGFtcCwgbG9ja3VwLmVwb2NoLCBuZXcgUHVibGljS2V5KGxvY2t1cC5jdXN0b2RpYW4pKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGEgZGVsZWdhdGUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlRGVsZWdhdGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA2KTtcbiAgICBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWxlZ2F0ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1s1XS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhdXRob3JpemUgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbmV3QXV0aG9yaXplZCxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGVcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBjb25zdCBvID0ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5ld0F1dGhvcml6ZWQpLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZToge1xuICAgICAgICBpbmRleDogc3Rha2VBdXRob3JpemF0aW9uVHlwZVxuICAgICAgfVxuICAgIH07XG4gICAgaWYgKGluc3RydWN0aW9uLmtleXMubGVuZ3RoID4gMykge1xuICAgICAgby5jdXN0b2RpYW5QdWJrZXkgPSBpbnN0cnVjdGlvbi5rZXlzWzNdLnB1YmtleTtcbiAgICB9XG4gICAgcmV0dXJuIG87XG4gIH1cblxuICAvKipcbiAgICogRGVjb2RlIGFuIGF1dGhvcml6ZS13aXRoLXNlZWQgc3Rha2UgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAyKTtcbiAgICBjb25zdCB7XG4gICAgICBuZXdBdXRob3JpemVkLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIGF1dGhvcml0eVNlZWQsXG4gICAgICBhdXRob3JpdHlPd25lclxuICAgIH0gPSBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemVXaXRoU2VlZCwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgY29uc3QgbyA9IHtcbiAgICAgIHN0YWtlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzBdLnB1YmtleSxcbiAgICAgIGF1dGhvcml0eUJhc2U6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXR5U2VlZDogYXV0aG9yaXR5U2VlZCxcbiAgICAgIGF1dGhvcml0eU93bmVyOiBuZXcgUHVibGljS2V5KGF1dGhvcml0eU93bmVyKSxcbiAgICAgIG5ld0F1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkobmV3QXV0aG9yaXplZCksXG4gICAgICBzdGFrZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiBzdGFrZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiAzKSB7XG4gICAgICBvLmN1c3RvZGlhblB1YmtleSA9IGluc3RydWN0aW9uLmtleXNbM10ucHVia2V5O1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBzcGxpdCBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVTcGxpdChpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGNvbnN0IHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLlNwbGl0LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgc3BsaXRTdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzJdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBtZXJnZSBzdGFrZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHBhcmFtcy5cbiAgICovXG4gIHN0YXRpYyBkZWNvZGVNZXJnZShpbnN0cnVjdGlvbikge1xuICAgIHRoaXMuY2hlY2tQcm9ncmFtSWQoaW5zdHJ1Y3Rpb24ucHJvZ3JhbUlkKTtcbiAgICB0aGlzLmNoZWNrS2V5TGVuZ3RoKGluc3RydWN0aW9uLmtleXMsIDMpO1xuICAgIGRlY29kZURhdGEkMShTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLk1lcmdlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgc291cmNlU3Rha2VQdWJLZXk6IGluc3RydWN0aW9uLmtleXNbMV0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1s0XS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHdpdGhkcmF3IHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVdpdGhkcmF3KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgNSk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXcsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIGNvbnN0IG8gPSB7XG4gICAgICBzdGFrZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzRdLnB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfTtcbiAgICBpZiAoaW5zdHJ1Y3Rpb24ua2V5cy5sZW5ndGggPiA1KSB7XG4gICAgICBvLmN1c3RvZGlhblB1YmtleSA9IGluc3RydWN0aW9uLmtleXNbNV0ucHVia2V5O1xuICAgIH1cbiAgICByZXR1cm4gbztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvZGUgYSBkZWFjdGl2YXRlIHN0YWtlIGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZURlYWN0aXZhdGUoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBkZWNvZGVEYXRhJDEoU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5EZWFjdGl2YXRlLCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3Rha2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhTdGFrZVByb2dyYW0ucHJvZ3JhbUlkKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluc3RydWN0aW9uOyBwcm9ncmFtSWQgaXMgbm90IFN0YWtlUHJvZ3JhbScpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBjaGVja0tleUxlbmd0aChrZXlzLCBleHBlY3RlZExlbmd0aCkge1xuICAgIGlmIChrZXlzLmxlbmd0aCA8IGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgaW5zdHJ1Y3Rpb247IGZvdW5kICR7a2V5cy5sZW5ndGh9IGtleXMsIGV4cGVjdGVkIGF0IGxlYXN0ICR7ZXhwZWN0ZWRMZW5ndGh9YCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgU3Rha2VJbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgc3Rha2UgSW5zdHJ1Y3Rpb25UeXBlJ3NcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEluaXRpYWxpemU6IHtcbiAgICBpbmRleDogMCxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIGF1dGhvcml6ZWQoKSwgbG9ja3VwKCldKVxuICB9LFxuICBBdXRob3JpemU6IHtcbiAgICBpbmRleDogMSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyksIHB1YmxpY0tleSgnbmV3QXV0aG9yaXplZCcpLCBCdWZmZXJMYXlvdXQudTMyKCdzdGFrZUF1dGhvcml6YXRpb25UeXBlJyldKVxuICB9LFxuICBEZWxlZ2F0ZToge1xuICAgIGluZGV4OiAyLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIFNwbGl0OiB7XG4gICAgaW5kZXg6IDMsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIFdpdGhkcmF3OiB7XG4gICAgaW5kZXg6IDQsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBCdWZmZXJMYXlvdXQubnM2NCgnbGFtcG9ydHMnKV0pXG4gIH0sXG4gIERlYWN0aXZhdGU6IHtcbiAgICBpbmRleDogNSxcbiAgICBsYXlvdXQ6IEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyldKVxuICB9LFxuICBNZXJnZToge1xuICAgIGluZGV4OiA3LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIEF1dGhvcml6ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDgsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKSwgQnVmZmVyTGF5b3V0LnUzMignc3Rha2VBdXRob3JpemF0aW9uVHlwZScpLCBydXN0U3RyaW5nKCdhdXRob3JpdHlTZWVkJyksIHB1YmxpY0tleSgnYXV0aG9yaXR5T3duZXInKV0pXG4gIH1cbn0pO1xuXG4vKipcbiAqIFN0YWtlIGF1dGhvcml6YXRpb24gdHlwZVxuICovXG5cbi8qKlxuICogQW4gZW51bWVyYXRpb24gb2YgdmFsaWQgU3Rha2VBdXRob3JpemF0aW9uTGF5b3V0J3NcbiAqL1xuY29uc3QgU3Rha2VBdXRob3JpemF0aW9uTGF5b3V0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gIFN0YWtlcjoge1xuICAgIGluZGV4OiAwXG4gIH0sXG4gIFdpdGhkcmF3ZXI6IHtcbiAgICBpbmRleDogMVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgU3Rha2UgcHJvZ3JhbVxuICovXG5jbGFzcyBTdGFrZVByb2dyYW0ge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHt9XG5cbiAgLyoqXG4gICAqIFB1YmxpYyBrZXkgdGhhdCBpZGVudGlmaWVzIHRoZSBTdGFrZSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBJbml0aWFsaXplIGluc3RydWN0aW9uIHRvIGFkZCB0byBhIFN0YWtlIENyZWF0ZSB0cmFuc2FjdGlvblxuICAgKi9cbiAgc3RhdGljIGluaXRpYWxpemUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwOiBtYXliZUxvY2t1cFxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgbG9ja3VwID0gbWF5YmVMb2NrdXAgfHwgTG9ja3VwLmRlZmF1bHQ7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBhdXRob3JpemVkOiB7XG4gICAgICAgIHN0YWtlcjogdG9CdWZmZXIoYXV0aG9yaXplZC5zdGFrZXIudG9CdWZmZXIoKSksXG4gICAgICAgIHdpdGhkcmF3ZXI6IHRvQnVmZmVyKGF1dGhvcml6ZWQud2l0aGRyYXdlci50b0J1ZmZlcigpKVxuICAgICAgfSxcbiAgICAgIGxvY2t1cDoge1xuICAgICAgICB1bml4VGltZXN0YW1wOiBsb2NrdXAudW5peFRpbWVzdGFtcCxcbiAgICAgICAgZXBvY2g6IGxvY2t1cC5lcG9jaCxcbiAgICAgICAgY3VzdG9kaWFuOiB0b0J1ZmZlcihsb2NrdXAuY3VzdG9kaWFuLnRvQnVmZmVyKCkpXG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3QgaW5zdHJ1Y3Rpb25EYXRhID0ge1xuICAgICAga2V5czogW3tcbiAgICAgICAgcHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uSW5zdHJ1Y3Rpb24oaW5zdHJ1Y3Rpb25EYXRhKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBTdGFrZSBhY2NvdW50IGF0XG4gICAqICAgYW4gYWRkcmVzcyBnZW5lcmF0ZWQgd2l0aCBgZnJvbWAsIGEgc2VlZCwgYW5kIHRoZSBTdGFrZSBwcm9ncmFtSWRcbiAgICovXG4gIHN0YXRpYyBjcmVhdGVBY2NvdW50V2l0aFNlZWQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50V2l0aFNlZWQoe1xuICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMuc3Rha2VQdWJrZXksXG4gICAgICBiYXNlUHVia2V5OiBwYXJhbXMuYmFzZVB1YmtleSxcbiAgICAgIHNlZWQ6IHBhcmFtcy5zZWVkLFxuICAgICAgbGFtcG9ydHM6IHBhcmFtcy5sYW1wb3J0cyxcbiAgICAgIHNwYWNlOiB0aGlzLnNwYWNlLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZFxuICAgIH0pKTtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWQsXG4gICAgICBsb2NrdXBcbiAgICB9ID0gcGFyYW1zO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5pbml0aWFsaXplKHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cFxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgY3JlYXRlcyBhIG5ldyBTdGFrZSBhY2NvdW50XG4gICAqL1xuICBzdGF0aWMgY3JlYXRlQWNjb3VudChwYXJhbXMpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IG5ldyBUcmFuc2FjdGlvbigpO1xuICAgIHRyYW5zYWN0aW9uLmFkZChTeXN0ZW1Qcm9ncmFtLmNyZWF0ZUFjY291bnQoe1xuICAgICAgZnJvbVB1YmtleTogcGFyYW1zLmZyb21QdWJrZXksXG4gICAgICBuZXdBY2NvdW50UHVia2V5OiBwYXJhbXMuc3Rha2VQdWJrZXksXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZCxcbiAgICAgIGxvY2t1cFxuICAgIH0gPSBwYXJhbXM7XG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLmFkZCh0aGlzLmluaXRpYWxpemUoe1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkLFxuICAgICAgbG9ja3VwXG4gICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBkZWxlZ2F0ZXMgU3Rha2UgdG9rZW5zIHRvIGEgdmFsaWRhdG9yXG4gICAqIFZvdGUgUHVibGljS2V5LiBUaGlzIHRyYW5zYWN0aW9uIGNhbiBhbHNvIGJlIHVzZWQgdG8gcmVkZWxlZ2F0ZSBTdGFrZVxuICAgKiB0byBhIG5ldyB2YWxpZGF0b3IgVm90ZSBQdWJsaWNLZXkuXG4gICAqL1xuICBzdGF0aWMgZGVsZWdhdGUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgdm90ZVB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuRGVsZWdhdGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiB2b3RlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNUQUtFX0NPTkZJR19JRCxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFB1YmxpY0tleSBhcyBTdGFrZXJcbiAgICogb3IgV2l0aGRyYXdlciBvbiB0aGUgU3Rha2UgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemUocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGUsXG4gICAgICBjdXN0b2RpYW5QdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZTtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBuZXdBdXRob3JpemVkOiB0b0J1ZmZlcihuZXdBdXRob3JpemVkUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZTogc3Rha2VBdXRob3JpemF0aW9uVHlwZS5pbmRleFxuICAgIH0pO1xuICAgIGNvbnN0IGtleXMgPSBbe1xuICAgICAgcHVia2V5OiBzdGFrZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChjdXN0b2RpYW5QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBhdXRob3JpemVzIGEgbmV3IFB1YmxpY0tleSBhcyBTdGFrZXJcbiAgICogb3IgV2l0aGRyYXdlciBvbiB0aGUgU3Rha2UgYWNjb3VudC5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemVXaXRoU2VlZChwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml0eUJhc2UsXG4gICAgICBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXIsXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5LFxuICAgICAgc3Rha2VBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIGN1c3RvZGlhblB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgIHN0YWtlQXV0aG9yaXphdGlvblR5cGU6IHN0YWtlQXV0aG9yaXphdGlvblR5cGUuaW5kZXgsXG4gICAgICBhdXRob3JpdHlTZWVkOiBhdXRob3JpdHlTZWVkLFxuICAgICAgYXV0aG9yaXR5T3duZXI6IHRvQnVmZmVyKGF1dGhvcml0eU93bmVyLnRvQnVmZmVyKCkpXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXR5QmFzZSxcbiAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChjdXN0b2RpYW5QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIHNwbGl0SW5zdHJ1Y3Rpb24ocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgc3Rha2VQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgc3BsaXRTdGFrZVB1YmtleSxcbiAgICAgIGxhbXBvcnRzXG4gICAgfSA9IHBhcmFtcztcbiAgICBjb25zdCB0eXBlID0gU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUy5TcGxpdDtcbiAgICBjb25zdCBkYXRhID0gZW5jb2RlRGF0YSh0eXBlLCB7XG4gICAgICBsYW1wb3J0c1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25JbnN0cnVjdGlvbih7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH1dLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIFRyYW5zYWN0aW9uIHRoYXQgc3BsaXRzIFN0YWtlIHRva2VucyBpbnRvIGFub3RoZXIgc3Rha2UgYWNjb3VudFxuICAgKi9cbiAgc3RhdGljIHNwbGl0KHBhcmFtcyxcbiAgLy8gQ29tcHV0ZSB0aGUgY29zdCBvZiBhbGxvY2F0aW5nIHRoZSBuZXcgc3Rha2UgYWNjb3VudCBpbiBsYW1wb3J0c1xuICByZW50RXhlbXB0UmVzZXJ2ZSkge1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gbmV3IFRyYW5zYWN0aW9uKCk7XG4gICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0uY3JlYXRlQWNjb3VudCh7XG4gICAgICBmcm9tUHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIG5ld0FjY291bnRQdWJrZXk6IHBhcmFtcy5zcGxpdFN0YWtlUHVia2V5LFxuICAgICAgbGFtcG9ydHM6IHJlbnRFeGVtcHRSZXNlcnZlLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5zcGxpdEluc3RydWN0aW9uKHBhcmFtcykpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBzcGxpdHMgU3Rha2UgdG9rZW5zIGludG8gYW5vdGhlciBhY2NvdW50XG4gICAqIGRlcml2ZWQgZnJvbSBhIGJhc2UgcHVibGljIGtleSBhbmQgc2VlZFxuICAgKi9cbiAgc3RhdGljIHNwbGl0V2l0aFNlZWQocGFyYW1zLFxuICAvLyBJZiB0aGlzIHN0YWtlIGFjY291bnQgaXMgbmV3LCBjb21wdXRlIHRoZSBjb3N0IG9mIGFsbG9jYXRpbmcgaXQgaW4gbGFtcG9ydHNcbiAgcmVudEV4ZW1wdFJlc2VydmUpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgYmFzZVB1YmtleSxcbiAgICAgIHNlZWQsXG4gICAgICBsYW1wb3J0c1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5hbGxvY2F0ZSh7XG4gICAgICBhY2NvdW50UHVia2V5OiBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgYmFzZVB1YmtleSxcbiAgICAgIHNlZWQsXG4gICAgICBzcGFjZTogdGhpcy5zcGFjZSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWRcbiAgICB9KSk7XG4gICAgaWYgKHJlbnRFeGVtcHRSZXNlcnZlICYmIHJlbnRFeGVtcHRSZXNlcnZlID4gMCkge1xuICAgICAgdHJhbnNhY3Rpb24uYWRkKFN5c3RlbVByb2dyYW0udHJhbnNmZXIoe1xuICAgICAgICBmcm9tUHVia2V5OiBwYXJhbXMuYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgdG9QdWJrZXk6IHNwbGl0U3Rha2VQdWJrZXksXG4gICAgICAgIGxhbXBvcnRzOiByZW50RXhlbXB0UmVzZXJ2ZVxuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNhY3Rpb24uYWRkKHRoaXMuc3BsaXRJbnN0cnVjdGlvbih7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBzcGxpdFN0YWtlUHVia2V5LFxuICAgICAgbGFtcG9ydHNcbiAgICB9KSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSBUcmFuc2FjdGlvbiB0aGF0IG1lcmdlcyBTdGFrZSBhY2NvdW50cy5cbiAgICovXG4gIHN0YXRpYyBtZXJnZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIHNvdXJjZVN0YWtlUHViS2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFNUQUtFX0lOU1RSVUNUSU9OX0xBWU9VVFMuTWVyZ2U7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBzb3VyY2VTdGFrZVB1YktleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCB3aXRoZHJhd3MgZGVhY3RpdmF0ZWQgU3Rha2UgdG9rZW5zLlxuICAgKi9cbiAgc3RhdGljIHdpdGhkcmF3KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHN0YWtlUHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHRvUHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICBjdXN0b2RpYW5QdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLldpdGhkcmF3O1xuICAgIGNvbnN0IGRhdGEgPSBlbmNvZGVEYXRhKHR5cGUsIHtcbiAgICAgIGxhbXBvcnRzXG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogdG9QdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9TVEFLRV9ISVNUT1JZX1BVQktFWSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBhdXRob3JpemVkUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIGlmIChjdXN0b2RpYW5QdWJrZXkpIHtcbiAgICAgIGtleXMucHVzaCh7XG4gICAgICAgIHB1YmtleTogY3VzdG9kaWFuUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uKCkuYWRkKHtcbiAgICAgIGtleXMsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlIGEgVHJhbnNhY3Rpb24gdGhhdCBkZWFjdGl2YXRlcyBTdGFrZSB0b2tlbnMuXG4gICAqL1xuICBzdGF0aWMgZGVhY3RpdmF0ZShwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdGFrZVB1YmtleSxcbiAgICAgIGF1dGhvcml6ZWRQdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBTVEFLRV9JTlNUUlVDVElPTl9MQVlPVVRTLkRlYWN0aXZhdGU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzOiBbe1xuICAgICAgICBwdWJrZXk6IHN0YWtlUHVia2V5LFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogYXV0aG9yaXplZFB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9XSxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cbn1cblN0YWtlUHJvZ3JhbS5wcm9ncmFtSWQgPSBuZXcgUHVibGljS2V5KCdTdGFrZTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG4vKipcbiAqIE1heCBzcGFjZSBvZiBhIFN0YWtlIGFjY291bnRcbiAqXG4gKiBUaGlzIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBzb2xhbmEtc3Rha2UtcHJvZ3JhbSBTdGFrZVN0YXRlIHN0cnVjdCBhc1xuICogYFN0YWtlU3RhdGVWMjo6c2l6ZV9vZigpYDpcbiAqIGh0dHBzOi8vZG9jcy5ycy9zb2xhbmEtc3Rha2UtcHJvZ3JhbS9sYXRlc3Qvc29sYW5hX3N0YWtlX3Byb2dyYW0vc3Rha2Vfc3RhdGUvZW51bS5TdGFrZVN0YXRlVjIuaHRtbFxuICovXG5TdGFrZVByb2dyYW0uc3BhY2UgPSAyMDA7XG5cbi8qKlxuICogVm90ZSBhY2NvdW50IGluZm9cbiAqL1xuY2xhc3MgVm90ZUluaXQge1xuICAvKiogWzAsIDEwMF0gKi9cblxuICBjb25zdHJ1Y3Rvcihub2RlUHVia2V5LCBhdXRob3JpemVkVm90ZXIsIGF1dGhvcml6ZWRXaXRoZHJhd2VyLCBjb21taXNzaW9uKSB7XG4gICAgdGhpcy5ub2RlUHVia2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFZvdGVyID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFdpdGhkcmF3ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb21taXNzaW9uID0gdm9pZCAwO1xuICAgIHRoaXMubm9kZVB1YmtleSA9IG5vZGVQdWJrZXk7XG4gICAgdGhpcy5hdXRob3JpemVkVm90ZXIgPSBhdXRob3JpemVkVm90ZXI7XG4gICAgdGhpcy5hdXRob3JpemVkV2l0aGRyYXdlciA9IGF1dGhvcml6ZWRXaXRoZHJhd2VyO1xuICAgIHRoaXMuY29tbWlzc2lvbiA9IGNvbW1pc3Npb247XG4gIH1cbn1cblxuLyoqXG4gKiBDcmVhdGUgdm90ZSBhY2NvdW50IHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogSW5pdGlhbGl6ZUFjY291bnQgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBdXRob3JpemUgaW5zdHJ1Y3Rpb24gcGFyYW1zXG4gKi9cblxuLyoqXG4gKiBBdXRob3JpemVXaXRoU2VlZCBpbnN0cnVjdGlvbiBwYXJhbXNcbiAqL1xuXG4vKipcbiAqIFdpdGhkcmF3IGZyb20gdm90ZSBhY2NvdW50IHRyYW5zYWN0aW9uIHBhcmFtc1xuICovXG5cbi8qKlxuICogVXBkYXRlIHZhbGlkYXRvciBpZGVudGl0eSAobm9kZSBwdWJrZXkpIHZvdGUgYWNjb3VudCBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gKi9cblxuLyoqXG4gKiBWb3RlIEluc3RydWN0aW9uIGNsYXNzXG4gKi9cbmNsYXNzIFZvdGVJbnN0cnVjdGlvbiB7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogRGVjb2RlIGEgdm90ZSBpbnN0cnVjdGlvbiBhbmQgcmV0cmlldmUgdGhlIGluc3RydWN0aW9uIHR5cGUuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5zdHJ1Y3Rpb25UeXBlKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIGNvbnN0IGluc3RydWN0aW9uVHlwZUxheW91dCA9IEJ1ZmZlckxheW91dC51MzIoJ2luc3RydWN0aW9uJyk7XG4gICAgY29uc3QgdHlwZUluZGV4ID0gaW5zdHJ1Y3Rpb25UeXBlTGF5b3V0LmRlY29kZShpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICBsZXQgdHlwZTtcbiAgICBmb3IgKGNvbnN0IFtpeFR5cGUsIGxheW91dF0gb2YgT2JqZWN0LmVudHJpZXMoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTKSkge1xuICAgICAgaWYgKGxheW91dC5pbmRleCA9PSB0eXBlSW5kZXgpIHtcbiAgICAgICAgdHlwZSA9IGl4VHlwZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdHlwZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnN0cnVjdGlvbiB0eXBlIGluY29ycmVjdDsgbm90IGEgVm90ZUluc3RydWN0aW9uJyk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBpbml0aWFsaXplIHZvdGUgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlSW5pdGlhbGl6ZUFjY291bnQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCA0KTtcbiAgICBjb25zdCB7XG4gICAgICB2b3RlSW5pdFxuICAgIH0gPSBkZWNvZGVEYXRhJDEoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkluaXRpYWxpemVBY2NvdW50LCBpbnN0cnVjdGlvbi5kYXRhKTtcbiAgICByZXR1cm4ge1xuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXksXG4gICAgICBub2RlUHVia2V5OiBpbnN0cnVjdGlvbi5rZXlzWzNdLnB1YmtleSxcbiAgICAgIHZvdGVJbml0OiBuZXcgVm90ZUluaXQobmV3IFB1YmxpY0tleSh2b3RlSW5pdC5ub2RlUHVia2V5KSwgbmV3IFB1YmxpY0tleSh2b3RlSW5pdC5hdXRob3JpemVkVm90ZXIpLCBuZXcgUHVibGljS2V5KHZvdGVJbml0LmF1dGhvcml6ZWRXaXRoZHJhd2VyKSwgdm90ZUluaXQuY29tbWlzc2lvbilcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhdXRob3JpemUgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplKGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbmV3QXV0aG9yaXplZCxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZVxuICAgIH0gPSBkZWNvZGVEYXRhJDEoVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTLkF1dGhvcml6ZSwgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1syXS5wdWJrZXksXG4gICAgICBuZXdBdXRob3JpemVkUHVia2V5OiBuZXcgUHVibGljS2V5KG5ld0F1dGhvcml6ZWQpLFxuICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB7XG4gICAgICAgIGluZGV4OiB2b3RlQXV0aG9yaXphdGlvblR5cGVcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhbiBhdXRob3JpemUgaW5zdHJ1Y3Rpb24gYW5kIHJldHJpZXZlIHRoZSBpbnN0cnVjdGlvbiBwYXJhbXMuXG4gICAqL1xuICBzdGF0aWMgZGVjb2RlQXV0aG9yaXplV2l0aFNlZWQoaW5zdHJ1Y3Rpb24pIHtcbiAgICB0aGlzLmNoZWNrUHJvZ3JhbUlkKGluc3RydWN0aW9uLnByb2dyYW1JZCk7XG4gICAgdGhpcy5jaGVja0tleUxlbmd0aChpbnN0cnVjdGlvbi5rZXlzLCAzKTtcbiAgICBjb25zdCB7XG4gICAgICB2b3RlQXV0aG9yaXplV2l0aFNlZWRBcmdzOiB7XG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5T3duZXJQdWJrZXksXG4gICAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCxcbiAgICAgICAgbmV3QXV0aG9yaXplZCxcbiAgICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9XG4gICAgfSA9IGRlY29kZURhdGEkMShWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQsIGluc3RydWN0aW9uLmRhdGEpO1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleUJhc2VQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlPd25lclB1YmtleTogbmV3IFB1YmxpY0tleShjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5KSxcbiAgICAgIGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZDogY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleTogbmV3IFB1YmxpY0tleShuZXdBdXRob3JpemVkKSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZToge1xuICAgICAgICBpbmRleDogdm90ZUF1dGhvcml6YXRpb25UeXBlXG4gICAgICB9LFxuICAgICAgdm90ZVB1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1swXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29kZSBhIHdpdGhkcmF3IGluc3RydWN0aW9uIGFuZCByZXRyaWV2ZSB0aGUgaW5zdHJ1Y3Rpb24gcGFyYW1zLlxuICAgKi9cbiAgc3RhdGljIGRlY29kZVdpdGhkcmF3KGluc3RydWN0aW9uKSB7XG4gICAgdGhpcy5jaGVja1Byb2dyYW1JZChpbnN0cnVjdGlvbi5wcm9ncmFtSWQpO1xuICAgIHRoaXMuY2hlY2tLZXlMZW5ndGgoaW5zdHJ1Y3Rpb24ua2V5cywgMyk7XG4gICAgY29uc3Qge1xuICAgICAgbGFtcG9ydHNcbiAgICB9ID0gZGVjb2RlRGF0YSQxKFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5XaXRoZHJhdywgaW5zdHJ1Y3Rpb24uZGF0YSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZvdGVQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMF0ucHVia2V5LFxuICAgICAgYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXk6IGluc3RydWN0aW9uLmtleXNbMl0ucHVia2V5LFxuICAgICAgbGFtcG9ydHMsXG4gICAgICB0b1B1YmtleTogaW5zdHJ1Y3Rpb24ua2V5c1sxXS5wdWJrZXlcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGNoZWNrUHJvZ3JhbUlkKHByb2dyYW1JZCkge1xuICAgIGlmICghcHJvZ3JhbUlkLmVxdWFscyhWb3RlUHJvZ3JhbS5wcm9ncmFtSWQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5zdHJ1Y3Rpb247IHByb2dyYW1JZCBpcyBub3QgVm90ZVByb2dyYW0nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzdGF0aWMgY2hlY2tLZXlMZW5ndGgoa2V5cywgZXhwZWN0ZWRMZW5ndGgpIHtcbiAgICBpZiAoa2V5cy5sZW5ndGggPCBleHBlY3RlZExlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluc3RydWN0aW9uOyBmb3VuZCAke2tleXMubGVuZ3RofSBrZXlzLCBleHBlY3RlZCBhdCBsZWFzdCAke2V4cGVjdGVkTGVuZ3RofWApO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHZhbGlkIFZvdGVJbnN0cnVjdGlvblR5cGUnc1xuICovXG5cbi8qKiBAaW50ZXJuYWwgKi9cblxuY29uc3QgVk9URV9JTlNUUlVDVElPTl9MQVlPVVRTID0gT2JqZWN0LmZyZWV6ZSh7XG4gIEluaXRpYWxpemVBY2NvdW50OiB7XG4gICAgaW5kZXg6IDAsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCB2b3RlSW5pdCgpXSlcbiAgfSxcbiAgQXV0aG9yaXplOiB7XG4gICAgaW5kZXg6IDEsXG4gICAgbGF5b3V0OiBCdWZmZXJMYXlvdXQuc3RydWN0KFtCdWZmZXJMYXlvdXQudTMyKCdpbnN0cnVjdGlvbicpLCBwdWJsaWNLZXkoJ25ld0F1dGhvcml6ZWQnKSwgQnVmZmVyTGF5b3V0LnUzMigndm90ZUF1dGhvcml6YXRpb25UeXBlJyldKVxuICB9LFxuICBXaXRoZHJhdzoge1xuICAgIGluZGV4OiAzLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgQnVmZmVyTGF5b3V0Lm5zNjQoJ2xhbXBvcnRzJyldKVxuICB9LFxuICBVcGRhdGVWYWxpZGF0b3JJZGVudGl0eToge1xuICAgIGluZGV4OiA0LFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKV0pXG4gIH0sXG4gIEF1dGhvcml6ZVdpdGhTZWVkOiB7XG4gICAgaW5kZXg6IDEwLFxuICAgIGxheW91dDogQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnUzMignaW5zdHJ1Y3Rpb24nKSwgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJncygpXSlcbiAgfVxufSk7XG5cbi8qKlxuICogVm90ZUF1dGhvcml6ZSB0eXBlXG4gKi9cblxuLyoqXG4gKiBBbiBlbnVtZXJhdGlvbiBvZiB2YWxpZCBWb3RlQXV0aG9yaXphdGlvbiBsYXlvdXRzLlxuICovXG5jb25zdCBWb3RlQXV0aG9yaXphdGlvbkxheW91dCA9IE9iamVjdC5mcmVlemUoe1xuICBWb3Rlcjoge1xuICAgIGluZGV4OiAwXG4gIH0sXG4gIFdpdGhkcmF3ZXI6IHtcbiAgICBpbmRleDogMVxuICB9XG59KTtcblxuLyoqXG4gKiBGYWN0b3J5IGNsYXNzIGZvciB0cmFuc2FjdGlvbnMgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgVm90ZSBwcm9ncmFtXG4gKi9cbmNsYXNzIFZvdGVQcm9ncmFtIHtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0b3IoKSB7fVxuXG4gIC8qKlxuICAgKiBQdWJsaWMga2V5IHRoYXQgaWRlbnRpZmllcyB0aGUgVm90ZSBwcm9ncmFtXG4gICAqL1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhbiBJbml0aWFsaXplIGluc3RydWN0aW9uLlxuICAgKi9cbiAgc3RhdGljIGluaXRpYWxpemVBY2NvdW50KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBub2RlUHVia2V5LFxuICAgICAgdm90ZUluaXRcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuSW5pdGlhbGl6ZUFjY291bnQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgdm90ZUluaXQ6IHtcbiAgICAgICAgbm9kZVB1YmtleTogdG9CdWZmZXIodm90ZUluaXQubm9kZVB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgYXV0aG9yaXplZFZvdGVyOiB0b0J1ZmZlcih2b3RlSW5pdC5hdXRob3JpemVkVm90ZXIudG9CdWZmZXIoKSksXG4gICAgICAgIGF1dGhvcml6ZWRXaXRoZHJhd2VyOiB0b0J1ZmZlcih2b3RlSW5pdC5hdXRob3JpemVkV2l0aGRyYXdlci50b0J1ZmZlcigpKSxcbiAgICAgICAgY29tbWlzc2lvbjogdm90ZUluaXQuY29tbWlzc2lvblxuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGluc3RydWN0aW9uRGF0YSA9IHtcbiAgICAgIGtleXM6IFt7XG4gICAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX1JFTlRfUFVCS0VZLFxuICAgICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgICB9LCB7XG4gICAgICAgIHB1YmtleTogU1lTVkFSX0NMT0NLX1BVQktFWSxcbiAgICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfSwge1xuICAgICAgICBwdWJrZXk6IG5vZGVQdWJrZXksXG4gICAgICAgIGlzU2lnbmVyOiB0cnVlLFxuICAgICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgICAgfV0sXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkLFxuICAgICAgZGF0YVxuICAgIH07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbkluc3RydWN0aW9uKGluc3RydWN0aW9uRGF0YSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0aGF0IGNyZWF0ZXMgYSBuZXcgVm90ZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIGNyZWF0ZUFjY291bnQocGFyYW1zKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBuZXcgVHJhbnNhY3Rpb24oKTtcbiAgICB0cmFuc2FjdGlvbi5hZGQoU3lzdGVtUHJvZ3JhbS5jcmVhdGVBY2NvdW50KHtcbiAgICAgIGZyb21QdWJrZXk6IHBhcmFtcy5mcm9tUHVia2V5LFxuICAgICAgbmV3QWNjb3VudFB1YmtleTogcGFyYW1zLnZvdGVQdWJrZXksXG4gICAgICBsYW1wb3J0czogcGFyYW1zLmxhbXBvcnRzLFxuICAgICAgc3BhY2U6IHRoaXMuc3BhY2UsXG4gICAgICBwcm9ncmFtSWQ6IHRoaXMucHJvZ3JhbUlkXG4gICAgfSkpO1xuICAgIHJldHVybiB0cmFuc2FjdGlvbi5hZGQodGhpcy5pbml0aWFsaXplQWNjb3VudCh7XG4gICAgICB2b3RlUHVia2V5OiBwYXJhbXMudm90ZVB1YmtleSxcbiAgICAgIG5vZGVQdWJrZXk6IHBhcmFtcy52b3RlSW5pdC5ub2RlUHVia2V5LFxuICAgICAgdm90ZUluaXQ6IHBhcmFtcy52b3RlSW5pdFxuICAgIH0pKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRoYXQgYXV0aG9yaXplcyBhIG5ldyBWb3RlciBvciBXaXRoZHJhd2VyIG9uIHRoZSBWb3RlIGFjY291bnQuXG4gICAqL1xuICBzdGF0aWMgYXV0aG9yaXplKHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBhdXRob3JpemVkUHVia2V5LFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZVxuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZSA9IFZPVEVfSU5TVFJVQ1RJT05fTEFZT1VUUy5BdXRob3JpemU7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZTogdm90ZUF1dGhvcml6YXRpb25UeXBlLmluZGV4XG4gICAgfSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBTWVNWQVJfQ0xPQ0tfUFVCS0VZLFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogZmFsc2VcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IGF1dGhvcml6ZWRQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRoYXQgYXV0aG9yaXplcyBhIG5ldyBWb3RlciBvciBXaXRoZHJhd2VyIG9uIHRoZSBWb3RlIGFjY291bnRcbiAgICogd2hlcmUgdGhlIGN1cnJlbnQgVm90ZXIgb3IgV2l0aGRyYXdlciBhdXRob3JpdHkgaXMgYSBkZXJpdmVkIGtleS5cbiAgICovXG4gIHN0YXRpYyBhdXRob3JpemVXaXRoU2VlZChwYXJhbXMpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleUJhc2VQdWJrZXksXG4gICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5LFxuICAgICAgY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlTZWVkLFxuICAgICAgbmV3QXV0aG9yaXplZFB1YmtleSxcbiAgICAgIHZvdGVBdXRob3JpemF0aW9uVHlwZSxcbiAgICAgIHZvdGVQdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuQXV0aG9yaXplV2l0aFNlZWQ7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgdm90ZUF1dGhvcml6ZVdpdGhTZWVkQXJnczoge1xuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5OiB0b0J1ZmZlcihjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleU93bmVyUHVia2V5LnRvQnVmZmVyKCkpLFxuICAgICAgICBjdXJyZW50QXV0aG9yaXR5RGVyaXZlZEtleVNlZWQ6IGN1cnJlbnRBdXRob3JpdHlEZXJpdmVkS2V5U2VlZCxcbiAgICAgICAgbmV3QXV0aG9yaXplZDogdG9CdWZmZXIobmV3QXV0aG9yaXplZFB1YmtleS50b0J1ZmZlcigpKSxcbiAgICAgICAgdm90ZUF1dGhvcml6YXRpb25UeXBlOiB2b3RlQXV0aG9yaXphdGlvblR5cGUuaW5kZXhcbiAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IFNZU1ZBUl9DTE9DS19QVUJLRVksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogY3VycmVudEF1dGhvcml0eURlcml2ZWRLZXlCYXNlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH1dO1xuICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb24oKS5hZGQoe1xuICAgICAga2V5cyxcbiAgICAgIHByb2dyYW1JZDogdGhpcy5wcm9ncmFtSWQsXG4gICAgICBkYXRhXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0byB3aXRoZHJhdyBmcm9tIGEgVm90ZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIHdpdGhkcmF3KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSxcbiAgICAgIGxhbXBvcnRzLFxuICAgICAgdG9QdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuV2l0aGRyYXc7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSwge1xuICAgICAgbGFtcG9ydHNcbiAgICB9KTtcbiAgICBjb25zdCBrZXlzID0gW3tcbiAgICAgIHB1YmtleTogdm90ZVB1YmtleSxcbiAgICAgIGlzU2lnbmVyOiBmYWxzZSxcbiAgICAgIGlzV3JpdGFibGU6IHRydWVcbiAgICB9LCB7XG4gICAgICBwdWJrZXk6IHRvUHVia2V5LFxuICAgICAgaXNTaWduZXI6IGZhbHNlLFxuICAgICAgaXNXcml0YWJsZTogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHRyYW5zYWN0aW9uIHRvIHdpdGhkcmF3IHNhZmVseSBmcm9tIGEgVm90ZSBhY2NvdW50LlxuICAgKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHdhcyBjcmVhdGVkIGFzIGEgc2FmZWd1YXJkIGZvciB2b3RlIGFjY291bnRzIHJ1bm5pbmcgdmFsaWRhdG9ycywgYHNhZmVXaXRoZHJhd2BcbiAgICogY2hlY2tzIHRoYXQgdGhlIHdpdGhkcmF3IGFtb3VudCB3aWxsIG5vdCBleGNlZWQgdGhlIHNwZWNpZmllZCBiYWxhbmNlIHdoaWxlIGxlYXZpbmcgZW5vdWdoIGxlZnRcbiAgICogdG8gY292ZXIgcmVudC4gSWYgeW91IHdpc2ggdG8gY2xvc2UgdGhlIHZvdGUgYWNjb3VudCBieSB3aXRoZHJhd2luZyB0aGUgZnVsbCBhbW91bnQsIGNhbGwgdGhlXG4gICAqIGB3aXRoZHJhd2AgbWV0aG9kIGRpcmVjdGx5LlxuICAgKi9cbiAgc3RhdGljIHNhZmVXaXRoZHJhdyhwYXJhbXMsIGN1cnJlbnRWb3RlQWNjb3VudEJhbGFuY2UsIHJlbnRFeGVtcHRNaW5pbXVtKSB7XG4gICAgaWYgKHBhcmFtcy5sYW1wb3J0cyA+IGN1cnJlbnRWb3RlQWNjb3VudEJhbGFuY2UgLSByZW50RXhlbXB0TWluaW11bSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXaXRoZHJhdyB3aWxsIGxlYXZlIHZvdGUgYWNjb3VudCB3aXRoIGluc3VmZmljaWVudCBmdW5kcy4nKTtcbiAgICB9XG4gICAgcmV0dXJuIFZvdGVQcm9ncmFtLndpdGhkcmF3KHBhcmFtcyk7XG4gIH1cblxuICAvKipcbiAgICogR2VuZXJhdGUgYSB0cmFuc2FjdGlvbiB0byB1cGRhdGUgdGhlIHZhbGlkYXRvciBpZGVudGl0eSAobm9kZSBwdWJrZXkpIG9mIGEgVm90ZSBhY2NvdW50LlxuICAgKi9cbiAgc3RhdGljIHVwZGF0ZVZhbGlkYXRvcklkZW50aXR5KHBhcmFtcykge1xuICAgIGNvbnN0IHtcbiAgICAgIHZvdGVQdWJrZXksXG4gICAgICBhdXRob3JpemVkV2l0aGRyYXdlclB1YmtleSxcbiAgICAgIG5vZGVQdWJrZXlcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IHR5cGUgPSBWT1RFX0lOU1RSVUNUSU9OX0xBWU9VVFMuVXBkYXRlVmFsaWRhdG9ySWRlbnRpdHk7XG4gICAgY29uc3QgZGF0YSA9IGVuY29kZURhdGEodHlwZSk7XG4gICAgY29uc3Qga2V5cyA9IFt7XG4gICAgICBwdWJrZXk6IHZvdGVQdWJrZXksXG4gICAgICBpc1NpZ25lcjogZmFsc2UsXG4gICAgICBpc1dyaXRhYmxlOiB0cnVlXG4gICAgfSwge1xuICAgICAgcHVia2V5OiBub2RlUHVia2V5LFxuICAgICAgaXNTaWduZXI6IHRydWUsXG4gICAgICBpc1dyaXRhYmxlOiBmYWxzZVxuICAgIH0sIHtcbiAgICAgIHB1YmtleTogYXV0aG9yaXplZFdpdGhkcmF3ZXJQdWJrZXksXG4gICAgICBpc1NpZ25lcjogdHJ1ZSxcbiAgICAgIGlzV3JpdGFibGU6IGZhbHNlXG4gICAgfV07XG4gICAgcmV0dXJuIG5ldyBUcmFuc2FjdGlvbigpLmFkZCh7XG4gICAgICBrZXlzLFxuICAgICAgcHJvZ3JhbUlkOiB0aGlzLnByb2dyYW1JZCxcbiAgICAgIGRhdGFcbiAgICB9KTtcbiAgfVxufVxuVm90ZVByb2dyYW0ucHJvZ3JhbUlkID0gbmV3IFB1YmxpY0tleSgnVm90ZTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuLyoqXG4gKiBNYXggc3BhY2Ugb2YgYSBWb3RlIGFjY291bnRcbiAqXG4gKiBUaGlzIGlzIGdlbmVyYXRlZCBmcm9tIHRoZSBzb2xhbmEtdm90ZS1wcm9ncmFtIFZvdGVTdGF0ZSBzdHJ1Y3QgYXNcbiAqIGBWb3RlU3RhdGU6OnNpemVfb2YoKWA6XG4gKiBodHRwczovL2RvY3MucnMvc29sYW5hLXZvdGUtcHJvZ3JhbS8xLjkuNS9zb2xhbmFfdm90ZV9wcm9ncmFtL3ZvdGVfc3RhdGUvc3RydWN0LlZvdGVTdGF0ZS5odG1sI21ldGhvZC5zaXplX29mXG4gKlxuICogS0VFUCBJTiBTWU5DIFdJVEggYFZvdGVTdGF0ZTo6c2l6ZV9vZigpYCBpbiBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvYTQ3NGNiMjRiOTIzOGY1ZWRjYzk4MmY2NWMwYjM3ZDRhMTA0NmY3ZS9zZGsvcHJvZ3JhbS9zcmMvdm90ZS9zdGF0ZS9tb2QucnMjTDM0MC1MMzQyXG4gKi9cblZvdGVQcm9ncmFtLnNwYWNlID0gMzc2MjtcblxuY29uc3QgVkFMSURBVE9SX0lORk9fS0VZID0gbmV3IFB1YmxpY0tleSgnVmExaWRhdG9yMW5mbzExMTExMTExMTExMTExMTExMTExMTExMTExMTExMScpO1xuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5cbi8qKlxuICogSW5mbyB1c2VkIHRvIGlkZW50aXR5IHZhbGlkYXRvcnMuXG4gKi9cblxuY29uc3QgSW5mb1N0cmluZyA9IHR5cGUoe1xuICBuYW1lOiBzdHJpbmcoKSxcbiAgd2Vic2l0ZTogb3B0aW9uYWwoc3RyaW5nKCkpLFxuICBkZXRhaWxzOiBvcHRpb25hbChzdHJpbmcoKSksXG4gIGtleWJhc2VVc2VybmFtZTogb3B0aW9uYWwoc3RyaW5nKCkpXG59KTtcblxuLyoqXG4gKiBWYWxpZGF0b3JJbmZvIGNsYXNzXG4gKi9cbmNsYXNzIFZhbGlkYXRvckluZm8ge1xuICAvKipcbiAgICogQ29uc3RydWN0IGEgdmFsaWQgVmFsaWRhdG9ySW5mb1xuICAgKlxuICAgKiBAcGFyYW0ga2V5IHZhbGlkYXRvciBwdWJsaWMga2V5XG4gICAqIEBwYXJhbSBpbmZvIHZhbGlkYXRvciBpbmZvcm1hdGlvblxuICAgKi9cbiAgY29uc3RydWN0b3Ioa2V5LCBpbmZvKSB7XG4gICAgLyoqXG4gICAgICogdmFsaWRhdG9yIHB1YmxpYyBrZXlcbiAgICAgKi9cbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICAvKipcbiAgICAgKiB2YWxpZGF0b3IgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICB0aGlzLmluZm8gPSB2b2lkIDA7XG4gICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgdGhpcy5pbmZvID0gaW5mbztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZXNlcmlhbGl6ZSBWYWxpZGF0b3JJbmZvIGZyb20gdGhlIGNvbmZpZyBhY2NvdW50IGRhdGEuIEV4YWN0bHkgdHdvIGNvbmZpZ1xuICAgKiBrZXlzIGFyZSByZXF1aXJlZCBpbiB0aGUgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIGJ1ZmZlciBjb25maWcgYWNjb3VudCBkYXRhXG4gICAqIEByZXR1cm4gbnVsbCBpZiBpbmZvIHdhcyBub3QgZm91bmRcbiAgICovXG4gIHN0YXRpYyBmcm9tQ29uZmlnRGF0YShidWZmZXIpIHtcbiAgICBsZXQgYnl0ZUFycmF5ID0gWy4uLmJ1ZmZlcl07XG4gICAgY29uc3QgY29uZmlnS2V5Q291bnQgPSBkZWNvZGVMZW5ndGgoYnl0ZUFycmF5KTtcbiAgICBpZiAoY29uZmlnS2V5Q291bnQgIT09IDIpIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGNvbmZpZ0tleXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgY29uc3QgcHVibGljS2V5ID0gbmV3IFB1YmxpY0tleShndWFyZGVkU3BsaWNlKGJ5dGVBcnJheSwgMCwgUFVCTElDX0tFWV9MRU5HVEgpKTtcbiAgICAgIGNvbnN0IGlzU2lnbmVyID0gZ3VhcmRlZFNoaWZ0KGJ5dGVBcnJheSkgPT09IDE7XG4gICAgICBjb25maWdLZXlzLnB1c2goe1xuICAgICAgICBwdWJsaWNLZXksXG4gICAgICAgIGlzU2lnbmVyXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZ0tleXNbMF0ucHVibGljS2V5LmVxdWFscyhWQUxJREFUT1JfSU5GT19LRVkpKSB7XG4gICAgICBpZiAoY29uZmlnS2V5c1sxXS5pc1NpZ25lcikge1xuICAgICAgICBjb25zdCByYXdJbmZvID0gcnVzdFN0cmluZygpLmRlY29kZShCdWZmZXIuZnJvbShieXRlQXJyYXkpKTtcbiAgICAgICAgY29uc3QgaW5mbyA9IEpTT04ucGFyc2UocmF3SW5mbyk7XG4gICAgICAgIGFzc2VydCQxKGluZm8sIEluZm9TdHJpbmcpO1xuICAgICAgICByZXR1cm4gbmV3IFZhbGlkYXRvckluZm8oY29uZmlnS2V5c1sxXS5wdWJsaWNLZXksIGluZm8pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5jb25zdCBWT1RFX1BST0dSQU1fSUQgPSBuZXcgUHVibGljS2V5KCdWb3RlMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExMTExJyk7XG5cbi8qKlxuICogSGlzdG9yeSBvZiBob3cgbWFueSBjcmVkaXRzIGVhcm5lZCBieSB0aGUgZW5kIG9mIGVhY2ggZXBvY2hcbiAqL1xuXG4vKipcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvOGExMmVkMDI5Y2ZhMzhkNGE0NTQwMDkxNmMyNDYzZmI4MmJiZWM4Yy9wcm9ncmFtcy92b3RlX2FwaS9zcmMvdm90ZV9zdGF0ZS5ycyNMNjgtTDg4XG4gKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IFZvdGVBY2NvdW50TGF5b3V0ID0gQnVmZmVyTGF5b3V0LnN0cnVjdChbcHVibGljS2V5KCdub2RlUHVia2V5JyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFdpdGhkcmF3ZXInKSwgQnVmZmVyTGF5b3V0LnU4KCdjb21taXNzaW9uJyksIEJ1ZmZlckxheW91dC5udTY0KCksXG4vLyB2b3Rlcy5sZW5ndGhcbkJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm51NjQoJ3Nsb3QnKSwgQnVmZmVyTGF5b3V0LnUzMignY29uZmlybWF0aW9uQ291bnQnKV0pLCBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLCAndm90ZXMnKSwgQnVmZmVyTGF5b3V0LnU4KCdyb290U2xvdFZhbGlkJyksIEJ1ZmZlckxheW91dC5udTY0KCdyb290U2xvdCcpLCBCdWZmZXJMYXlvdXQubnU2NCgpLFxuLy8gYXV0aG9yaXplZFZvdGVycy5sZW5ndGhcbkJ1ZmZlckxheW91dC5zZXEoQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0Lm51NjQoJ2Vwb2NoJyksIHB1YmxpY0tleSgnYXV0aG9yaXplZFZvdGVyJyldKSwgQnVmZmVyTGF5b3V0Lm9mZnNldChCdWZmZXJMYXlvdXQudTMyKCksIC04KSwgJ2F1dGhvcml6ZWRWb3RlcnMnKSwgQnVmZmVyTGF5b3V0LnN0cnVjdChbQnVmZmVyTGF5b3V0LnNlcShCdWZmZXJMYXlvdXQuc3RydWN0KFtwdWJsaWNLZXkoJ2F1dGhvcml6ZWRQdWJrZXknKSwgQnVmZmVyTGF5b3V0Lm51NjQoJ2Vwb2NoT2ZMYXN0QXV0aG9yaXplZFN3aXRjaCcpLCBCdWZmZXJMYXlvdXQubnU2NCgndGFyZ2V0RXBvY2gnKV0pLCAzMiwgJ2J1ZicpLCBCdWZmZXJMYXlvdXQubnU2NCgnaWR4JyksIEJ1ZmZlckxheW91dC51OCgnaXNFbXB0eScpXSwgJ3ByaW9yVm90ZXJzJyksIEJ1ZmZlckxheW91dC5udTY0KCksXG4vLyBlcG9jaENyZWRpdHMubGVuZ3RoXG5CdWZmZXJMYXlvdXQuc2VxKEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5udTY0KCdlcG9jaCcpLCBCdWZmZXJMYXlvdXQubnU2NCgnY3JlZGl0cycpLCBCdWZmZXJMYXlvdXQubnU2NCgncHJldkNyZWRpdHMnKV0pLCBCdWZmZXJMYXlvdXQub2Zmc2V0KEJ1ZmZlckxheW91dC51MzIoKSwgLTgpLCAnZXBvY2hDcmVkaXRzJyksIEJ1ZmZlckxheW91dC5zdHJ1Y3QoW0J1ZmZlckxheW91dC5udTY0KCdzbG90JyksIEJ1ZmZlckxheW91dC5udTY0KCd0aW1lc3RhbXAnKV0sICdsYXN0VGltZXN0YW1wJyldKTtcbi8qKlxuICogVm90ZUFjY291bnQgY2xhc3NcbiAqL1xuY2xhc3MgVm90ZUFjY291bnQge1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhcmdzKSB7XG4gICAgdGhpcy5ub2RlUHVia2V5ID0gdm9pZCAwO1xuICAgIHRoaXMuYXV0aG9yaXplZFdpdGhkcmF3ZXIgPSB2b2lkIDA7XG4gICAgdGhpcy5jb21taXNzaW9uID0gdm9pZCAwO1xuICAgIHRoaXMucm9vdFNsb3QgPSB2b2lkIDA7XG4gICAgdGhpcy52b3RlcyA9IHZvaWQgMDtcbiAgICB0aGlzLmF1dGhvcml6ZWRWb3RlcnMgPSB2b2lkIDA7XG4gICAgdGhpcy5wcmlvclZvdGVycyA9IHZvaWQgMDtcbiAgICB0aGlzLmVwb2NoQ3JlZGl0cyA9IHZvaWQgMDtcbiAgICB0aGlzLmxhc3RUaW1lc3RhbXAgPSB2b2lkIDA7XG4gICAgdGhpcy5ub2RlUHVia2V5ID0gYXJncy5ub2RlUHVia2V5O1xuICAgIHRoaXMuYXV0aG9yaXplZFdpdGhkcmF3ZXIgPSBhcmdzLmF1dGhvcml6ZWRXaXRoZHJhd2VyO1xuICAgIHRoaXMuY29tbWlzc2lvbiA9IGFyZ3MuY29tbWlzc2lvbjtcbiAgICB0aGlzLnJvb3RTbG90ID0gYXJncy5yb290U2xvdDtcbiAgICB0aGlzLnZvdGVzID0gYXJncy52b3RlcztcbiAgICB0aGlzLmF1dGhvcml6ZWRWb3RlcnMgPSBhcmdzLmF1dGhvcml6ZWRWb3RlcnM7XG4gICAgdGhpcy5wcmlvclZvdGVycyA9IGFyZ3MucHJpb3JWb3RlcnM7XG4gICAgdGhpcy5lcG9jaENyZWRpdHMgPSBhcmdzLmVwb2NoQ3JlZGl0cztcbiAgICB0aGlzLmxhc3RUaW1lc3RhbXAgPSBhcmdzLmxhc3RUaW1lc3RhbXA7XG4gIH1cblxuICAvKipcbiAgICogRGVzZXJpYWxpemUgVm90ZUFjY291bnQgZnJvbSB0aGUgYWNjb3VudCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0gYnVmZmVyIGFjY291bnQgZGF0YVxuICAgKiBAcmV0dXJuIFZvdGVBY2NvdW50XG4gICAqL1xuICBzdGF0aWMgZnJvbUFjY291bnREYXRhKGJ1ZmZlcikge1xuICAgIGNvbnN0IHZlcnNpb25PZmZzZXQgPSA0O1xuICAgIGNvbnN0IHZhID0gVm90ZUFjY291bnRMYXlvdXQuZGVjb2RlKHRvQnVmZmVyKGJ1ZmZlciksIHZlcnNpb25PZmZzZXQpO1xuICAgIGxldCByb290U2xvdCA9IHZhLnJvb3RTbG90O1xuICAgIGlmICghdmEucm9vdFNsb3RWYWxpZCkge1xuICAgICAgcm9vdFNsb3QgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFZvdGVBY2NvdW50KHtcbiAgICAgIG5vZGVQdWJrZXk6IG5ldyBQdWJsaWNLZXkodmEubm9kZVB1YmtleSksXG4gICAgICBhdXRob3JpemVkV2l0aGRyYXdlcjogbmV3IFB1YmxpY0tleSh2YS5hdXRob3JpemVkV2l0aGRyYXdlciksXG4gICAgICBjb21taXNzaW9uOiB2YS5jb21taXNzaW9uLFxuICAgICAgdm90ZXM6IHZhLnZvdGVzLFxuICAgICAgcm9vdFNsb3QsXG4gICAgICBhdXRob3JpemVkVm90ZXJzOiB2YS5hdXRob3JpemVkVm90ZXJzLm1hcChwYXJzZUF1dGhvcml6ZWRWb3RlciksXG4gICAgICBwcmlvclZvdGVyczogZ2V0UHJpb3JWb3RlcnModmEucHJpb3JWb3RlcnMpLFxuICAgICAgZXBvY2hDcmVkaXRzOiB2YS5lcG9jaENyZWRpdHMsXG4gICAgICBsYXN0VGltZXN0YW1wOiB2YS5sYXN0VGltZXN0YW1wXG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlQXV0aG9yaXplZFZvdGVyKHtcbiAgYXV0aG9yaXplZFZvdGVyLFxuICBlcG9jaFxufSkge1xuICByZXR1cm4ge1xuICAgIGVwb2NoLFxuICAgIGF1dGhvcml6ZWRWb3RlcjogbmV3IFB1YmxpY0tleShhdXRob3JpemVkVm90ZXIpXG4gIH07XG59XG5mdW5jdGlvbiBwYXJzZVByaW9yVm90ZXJzKHtcbiAgYXV0aG9yaXplZFB1YmtleSxcbiAgZXBvY2hPZkxhc3RBdXRob3JpemVkU3dpdGNoLFxuICB0YXJnZXRFcG9jaFxufSkge1xuICByZXR1cm4ge1xuICAgIGF1dGhvcml6ZWRQdWJrZXk6IG5ldyBQdWJsaWNLZXkoYXV0aG9yaXplZFB1YmtleSksXG4gICAgZXBvY2hPZkxhc3RBdXRob3JpemVkU3dpdGNoLFxuICAgIHRhcmdldEVwb2NoXG4gIH07XG59XG5mdW5jdGlvbiBnZXRQcmlvclZvdGVycyh7XG4gIGJ1ZixcbiAgaWR4LFxuICBpc0VtcHR5XG59KSB7XG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiBbLi4uYnVmLnNsaWNlKGlkeCArIDEpLm1hcChwYXJzZVByaW9yVm90ZXJzKSwgLi4uYnVmLnNsaWNlKDAsIGlkeCkubWFwKHBhcnNlUHJpb3JWb3RlcnMpXTtcbn1cblxuY29uc3QgZW5kcG9pbnQgPSB7XG4gIGh0dHA6IHtcbiAgICBkZXZuZXQ6ICdodHRwOi8vYXBpLmRldm5ldC5zb2xhbmEuY29tJyxcbiAgICB0ZXN0bmV0OiAnaHR0cDovL2FwaS50ZXN0bmV0LnNvbGFuYS5jb20nLFxuICAgICdtYWlubmV0LWJldGEnOiAnaHR0cDovL2FwaS5tYWlubmV0LWJldGEuc29sYW5hLmNvbS8nXG4gIH0sXG4gIGh0dHBzOiB7XG4gICAgZGV2bmV0OiAnaHR0cHM6Ly9hcGkuZGV2bmV0LnNvbGFuYS5jb20nLFxuICAgIHRlc3RuZXQ6ICdodHRwczovL2FwaS50ZXN0bmV0LnNvbGFuYS5jb20nLFxuICAgICdtYWlubmV0LWJldGEnOiAnaHR0cHM6Ly9hcGkubWFpbm5ldC1iZXRhLnNvbGFuYS5jb20vJ1xuICB9XG59O1xuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIFJQQyBBUEkgVVJMIGZvciB0aGUgc3BlY2lmaWVkIGNsdXN0ZXJcbiAqIEBwYXJhbSB7Q2x1c3Rlcn0gW2NsdXN0ZXI9XCJkZXZuZXRcIl0gLSBUaGUgY2x1c3RlciBuYW1lIG9mIHRoZSBSUEMgQVBJIFVSTCB0byB1c2UuIFBvc3NpYmxlIG9wdGlvbnM6ICdkZXZuZXQnIHwgJ3Rlc3RuZXQnIHwgJ21haW5uZXQtYmV0YSdcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3Rscz1cImh0dHBcIl0gLSBVc2UgVExTIHdoZW4gY29ubmVjdGluZyB0byBjbHVzdGVyLlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFVSTCBzdHJpbmcgb2YgdGhlIFJQQyBlbmRwb2ludFxuICovXG5mdW5jdGlvbiBjbHVzdGVyQXBpVXJsKGNsdXN0ZXIsIHRscykge1xuICBjb25zdCBrZXkgPSB0bHMgPT09IGZhbHNlID8gJ2h0dHAnIDogJ2h0dHBzJztcbiAgaWYgKCFjbHVzdGVyKSB7XG4gICAgcmV0dXJuIGVuZHBvaW50W2tleV1bJ2Rldm5ldCddO1xuICB9XG4gIGNvbnN0IHVybCA9IGVuZHBvaW50W2tleV1bY2x1c3Rlcl07XG4gIGlmICghdXJsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duICR7a2V5fSBjbHVzdGVyOiAke2NsdXN0ZXJ9YCk7XG4gIH1cbiAgcmV0dXJuIHVybDtcbn1cblxuLyoqXG4gKiBTZW5kIGFuZCBjb25maXJtIGEgcmF3IHRyYW5zYWN0aW9uXG4gKlxuICogSWYgYGNvbW1pdG1lbnRgIG9wdGlvbiBpcyBub3Qgc3BlY2lmaWVkLCBkZWZhdWx0cyB0byAnbWF4JyBjb21taXRtZW50LlxuICpcbiAqIEBwYXJhbSB7Q29ubmVjdGlvbn0gY29ubmVjdGlvblxuICogQHBhcmFtIHtCdWZmZXJ9IHJhd1RyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge1RyYW5zYWN0aW9uQ29uZmlybWF0aW9uU3RyYXRlZ3l9IGNvbmZpcm1hdGlvblN0cmF0ZWd5XG4gKiBAcGFyYW0ge0NvbmZpcm1PcHRpb25zfSBbb3B0aW9uc11cbiAqIEByZXR1cm5zIHtQcm9taXNlPFRyYW5zYWN0aW9uU2lnbmF0dXJlPn1cbiAqL1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIENhbGxpbmcgYHNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb24oKWAgd2l0aG91dCBhIGBjb25maXJtYXRpb25TdHJhdGVneWBcbiAqIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSB2ZXJzaW9uLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbmFzeW5jIGZ1bmN0aW9uIHNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb24oY29ubmVjdGlvbiwgcmF3VHJhbnNhY3Rpb24sIGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucywgbWF5YmVDb25maXJtT3B0aW9ucykge1xuICBsZXQgY29uZmlybWF0aW9uU3RyYXRlZ3k7XG4gIGxldCBvcHRpb25zO1xuICBpZiAoY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMsICdsYXN0VmFsaWRCbG9ja0hlaWdodCcpKSB7XG4gICAgY29uZmlybWF0aW9uU3RyYXRlZ3kgPSBjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnM7XG4gICAgb3B0aW9ucyA9IG1heWJlQ29uZmlybU9wdGlvbnM7XG4gIH0gZWxzZSBpZiAoY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb25maXJtYXRpb25TdHJhdGVneU9yQ29uZmlybU9wdGlvbnMsICdub25jZVZhbHVlJykpIHtcbiAgICBjb25maXJtYXRpb25TdHJhdGVneSA9IGNvbmZpcm1hdGlvblN0cmF0ZWd5T3JDb25maXJtT3B0aW9ucztcbiAgICBvcHRpb25zID0gbWF5YmVDb25maXJtT3B0aW9ucztcbiAgfSBlbHNlIHtcbiAgICBvcHRpb25zID0gY29uZmlybWF0aW9uU3RyYXRlZ3lPckNvbmZpcm1PcHRpb25zO1xuICB9XG4gIGNvbnN0IHNlbmRPcHRpb25zID0gb3B0aW9ucyAmJiB7XG4gICAgc2tpcFByZWZsaWdodDogb3B0aW9ucy5za2lwUHJlZmxpZ2h0LFxuICAgIHByZWZsaWdodENvbW1pdG1lbnQ6IG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCB8fCBvcHRpb25zLmNvbW1pdG1lbnQsXG4gICAgbWluQ29udGV4dFNsb3Q6IG9wdGlvbnMubWluQ29udGV4dFNsb3RcbiAgfTtcbiAgY29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb24sIHNlbmRPcHRpb25zKTtcbiAgY29uc3QgY29tbWl0bWVudCA9IG9wdGlvbnMgJiYgb3B0aW9ucy5jb21taXRtZW50O1xuICBjb25zdCBjb25maXJtYXRpb25Qcm9taXNlID0gY29uZmlybWF0aW9uU3RyYXRlZ3kgPyBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihjb25maXJtYXRpb25TdHJhdGVneSwgY29tbWl0bWVudCkgOiBjb25uZWN0aW9uLmNvbmZpcm1UcmFuc2FjdGlvbihzaWduYXR1cmUsIGNvbW1pdG1lbnQpO1xuICBjb25zdCBzdGF0dXMgPSAoYXdhaXQgY29uZmlybWF0aW9uUHJvbWlzZSkudmFsdWU7XG4gIGlmIChzdGF0dXMuZXJyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBSYXcgdHJhbnNhY3Rpb24gJHtzaWduYXR1cmV9IGZhaWxlZCAoJHtKU09OLnN0cmluZ2lmeShzdGF0dXMpfSlgKTtcbiAgfVxuICByZXR1cm4gc2lnbmF0dXJlO1xufVxuXG4vKipcbiAqIFRoZXJlIGFyZSAxLWJpbGxpb24gbGFtcG9ydHMgaW4gb25lIFNPTFxuICovXG5jb25zdCBMQU1QT1JUU19QRVJfU09MID0gMTAwMDAwMDAwMDtcblxuZXhwb3J0IHsgQWNjb3VudCwgQWRkcmVzc0xvb2t1cFRhYmxlQWNjb3VudCwgQWRkcmVzc0xvb2t1cFRhYmxlSW5zdHJ1Y3Rpb24sIEFkZHJlc3NMb29rdXBUYWJsZVByb2dyYW0sIEF1dGhvcml6ZWQsIEJMT0NLSEFTSF9DQUNIRV9USU1FT1VUX01TLCBCUEZfTE9BREVSX0RFUFJFQ0FURURfUFJPR1JBTV9JRCwgQlBGX0xPQURFUl9QUk9HUkFNX0lELCBCcGZMb2FkZXIsIENPTVBVVEVfQlVER0VUX0lOU1RSVUNUSU9OX0xBWU9VVFMsIENvbXB1dGVCdWRnZXRJbnN0cnVjdGlvbiwgQ29tcHV0ZUJ1ZGdldFByb2dyYW0sIENvbm5lY3Rpb24sIEVkMjU1MTlQcm9ncmFtLCBFbnVtLCBFcG9jaFNjaGVkdWxlLCBGZWVDYWxjdWxhdG9yTGF5b3V0LCBLZXlwYWlyLCBMQU1QT1JUU19QRVJfU09MLCBMT09LVVBfVEFCTEVfSU5TVFJVQ1RJT05fTEFZT1VUUywgTG9hZGVyLCBMb2NrdXAsIE1BWF9TRUVEX0xFTkdUSCwgTWVzc2FnZSwgTWVzc2FnZUFjY291bnRLZXlzLCBNZXNzYWdlVjAsIE5PTkNFX0FDQ09VTlRfTEVOR1RILCBOb25jZUFjY291bnQsIFBBQ0tFVF9EQVRBX1NJWkUsIFBVQkxJQ19LRVlfTEVOR1RILCBQdWJsaWNLZXksIFNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMsIFNPTEFOQV9TQ0hFTUEsIFNUQUtFX0NPTkZJR19JRCwgU1RBS0VfSU5TVFJVQ1RJT05fTEFZT1VUUywgU1lTVEVNX0lOU1RSVUNUSU9OX0xBWU9VVFMsIFNZU1ZBUl9DTE9DS19QVUJLRVksIFNZU1ZBUl9FUE9DSF9TQ0hFRFVMRV9QVUJLRVksIFNZU1ZBUl9JTlNUUlVDVElPTlNfUFVCS0VZLCBTWVNWQVJfUkVDRU5UX0JMT0NLSEFTSEVTX1BVQktFWSwgU1lTVkFSX1JFTlRfUFVCS0VZLCBTWVNWQVJfUkVXQVJEU19QVUJLRVksIFNZU1ZBUl9TTE9UX0hBU0hFU19QVUJLRVksIFNZU1ZBUl9TTE9UX0hJU1RPUllfUFVCS0VZLCBTWVNWQVJfU1RBS0VfSElTVE9SWV9QVUJLRVksIFNlY3AyNTZrMVByb2dyYW0sIFNlbmRUcmFuc2FjdGlvbkVycm9yLCBTb2xhbmFKU09OUlBDRXJyb3IsIFNvbGFuYUpTT05SUENFcnJvckNvZGUsIFN0YWtlQXV0aG9yaXphdGlvbkxheW91dCwgU3Rha2VJbnN0cnVjdGlvbiwgU3Rha2VQcm9ncmFtLCBTdHJ1Y3QsIFN5c3RlbUluc3RydWN0aW9uLCBTeXN0ZW1Qcm9ncmFtLCBUcmFuc2FjdGlvbiwgVHJhbnNhY3Rpb25FeHBpcmVkQmxvY2toZWlnaHRFeGNlZWRlZEVycm9yLCBUcmFuc2FjdGlvbkV4cGlyZWROb25jZUludmFsaWRFcnJvciwgVHJhbnNhY3Rpb25FeHBpcmVkVGltZW91dEVycm9yLCBUcmFuc2FjdGlvbkluc3RydWN0aW9uLCBUcmFuc2FjdGlvbk1lc3NhZ2UsIFRyYW5zYWN0aW9uU3RhdHVzLCBWQUxJREFUT1JfSU5GT19LRVksIFZFUlNJT05fUFJFRklYX01BU0ssIFZPVEVfUFJPR1JBTV9JRCwgVmFsaWRhdG9ySW5mbywgVmVyc2lvbmVkTWVzc2FnZSwgVmVyc2lvbmVkVHJhbnNhY3Rpb24sIFZvdGVBY2NvdW50LCBWb3RlQXV0aG9yaXphdGlvbkxheW91dCwgVm90ZUluaXQsIFZvdGVJbnN0cnVjdGlvbiwgVm90ZVByb2dyYW0sIGNsdXN0ZXJBcGlVcmwsIHNlbmRBbmRDb25maXJtUmF3VHJhbnNhY3Rpb24sIHNlbmRBbmRDb25maXJtVHJhbnNhY3Rpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmJyb3dzZXIuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/bn.js/lib/bn.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/bn.js/lib/bn.js ***!
  \*******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* module decorator */ module = __webpack_require__.nmd(module);\n(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {\n      Buffer = window.Buffer;\n    } else {\n      Buffer = (__webpack_require__(/*! buffer */ \"?e082\").Buffer);\n    }\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n      this.negative = 1;\n    }\n\n    if (start < number.length) {\n      if (base === 16) {\n        this._parseHex(number, start, endian);\n      } else {\n        this._parseBase(number, base, start);\n        if (endian === 'le') {\n          this._initArray(this.toArray(), base, endian);\n        }\n      }\n    }\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [number & 0x3ffffff];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [0];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this._strip();\n  };\n\n  function parseHex4Bits (string, index) {\n    var c = string.charCodeAt(index);\n    // '0' - '9'\n    if (c >= 48 && c <= 57) {\n      return c - 48;\n    // 'A' - 'F'\n    } else if (c >= 65 && c <= 70) {\n      return c - 55;\n    // 'a' - 'f'\n    } else if (c >= 97 && c <= 102) {\n      return c - 87;\n    } else {\n      assert(false, 'Invalid character in ' + string);\n    }\n  }\n\n  function parseHexByte (string, lowerBound, index) {\n    var r = parseHex4Bits(string, index);\n    if (index - 1 >= lowerBound) {\n      r |= parseHex4Bits(string, index - 1) << 4;\n    }\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start, endian) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    // 24-bits chunks\n    var off = 0;\n    var j = 0;\n\n    var w;\n    if (endian === 'be') {\n      for (i = number.length - 1; i >= start; i -= 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    } else {\n      var parseLength = number.length - start;\n      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    }\n\n    this._strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var b = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        b = c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        b = c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        b = c;\n      }\n      assert(c >= 0 && b < mul, 'Invalid character');\n      r += b;\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [0];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    this._strip();\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  function move (dest, src) {\n    dest.words = src.words;\n    dest.length = src.length;\n    dest.negative = src.negative;\n    dest.red = src.red;\n  }\n\n  BN.prototype._move = function _move (dest) {\n    move(dest, this);\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype._strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  // Check Symbol.for because not everywhere where Symbol defined\n  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility\n  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {\n    try {\n      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;\n    } catch (e) {\n      BN.prototype.inspect = inspect;\n    }\n  } else {\n    BN.prototype.inspect = inspect;\n  }\n\n  function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  }\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modrn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16, 2);\n  };\n\n  if (Buffer) {\n    BN.prototype.toBuffer = function toBuffer (endian, length) {\n      return this.toArrayLike(Buffer, endian, length);\n    };\n  }\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  var allocate = function allocate (ArrayType, size) {\n    if (ArrayType.allocUnsafe) {\n      return ArrayType.allocUnsafe(size);\n    }\n    return new ArrayType(size);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    this._strip();\n\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    var res = allocate(ArrayType, reqLength);\n    var postfix = endian === 'le' ? 'LE' : 'BE';\n    this['_toArrayLike' + postfix](res, byteLength);\n    return res;\n  };\n\n  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {\n    var position = 0;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position++] = word & 0xff;\n      if (position < res.length) {\n        res[position++] = (word >> 8) & 0xff;\n      }\n      if (position < res.length) {\n        res[position++] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position < res.length) {\n          res[position++] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position < res.length) {\n      res[position++] = carry;\n\n      while (position < res.length) {\n        res[position++] = 0;\n      }\n    }\n  };\n\n  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {\n    var position = res.length - 1;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position--] = word & 0xff;\n      if (position >= 0) {\n        res[position--] = (word >> 8) & 0xff;\n      }\n      if (position >= 0) {\n        res[position--] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position >= 0) {\n          res[position--] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position >= 0) {\n      res[position--] = carry;\n\n      while (position >= 0) {\n        res[position--] = 0;\n      }\n    }\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] >>> wbit) & 0x01;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this._strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this._strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this._strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    // Temporary disable, see https://github.com/indutny/bn.js/issues/211\n    // var fftm = new FFTM();\n    // return fftm.mulp(self, num, out);\n    return bigMulTo(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out._strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this._strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) <= num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this._strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this._strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q._strip();\n    }\n    a._strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modrn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modrn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modrn = function modrn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return isNegNum ? -acc : acc;\n  };\n\n  // WARNING: DEPRECATED\n  BN.prototype.modn = function modn (num) {\n    return this.modrn(num);\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    this._strip();\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this._strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      if (r.strip !== undefined) {\n        // r is a BN v4 instance\n        r.strip();\n      } else {\n        // r is a BN v5 instance\n        r._strip();\n      }\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n\n    move(a, a.umod(this.m)._forceRed(this));\n    return a;\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})( false || module, this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL2JuLmpzL2xpYi9ibi5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixlQUFlLG1EQUF3QjtBQUN2QztBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix5QkFBeUIsbUJBQW1CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQ0FBa0MsWUFBWTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMERBQTBELG1CQUFtQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVDQUF1QyxzQkFBc0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCLGlCQUFpQjtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsaUJBQWlCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Y0FBYztBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsV0FBVztBQUNoRTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTs7QUFF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akM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGNBQWM7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBLE1BQU07O0FBRU47QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixnQ0FBZ0M7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQyxRQUFRO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixrQkFBa0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBLDhCQUE4QixRQUFRO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUUsTUFBNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzPzVjNjEiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIC8vIFV0aWxzXG4gIGZ1bmN0aW9uIGFzc2VydCAodmFsLCBtc2cpIHtcbiAgICBpZiAoIXZhbCkgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAnQXNzZXJ0aW9uIGZhaWxlZCcpO1xuICB9XG5cbiAgLy8gQ291bGQgdXNlIGBpbmhlcml0c2AgbW9kdWxlLCBidXQgZG9uJ3Qgd2FudCB0byBtb3ZlIGZyb20gc2luZ2xlIGZpbGVcbiAgLy8gYXJjaGl0ZWN0dXJlIHlldC5cbiAgZnVuY3Rpb24gaW5oZXJpdHMgKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9O1xuICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKTtcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3I7XG4gIH1cblxuICAvLyBCTlxuXG4gIGZ1bmN0aW9uIEJOIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChCTi5pc0JOKG51bWJlcikpIHtcbiAgICAgIHJldHVybiBudW1iZXI7XG4gICAgfVxuXG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgdGhpcy53b3JkcyA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuXG4gICAgLy8gUmVkdWN0aW9uIGNvbnRleHRcbiAgICB0aGlzLnJlZCA9IG51bGw7XG5cbiAgICBpZiAobnVtYmVyICE9PSBudWxsKSB7XG4gICAgICBpZiAoYmFzZSA9PT0gJ2xlJyB8fCBiYXNlID09PSAnYmUnKSB7XG4gICAgICAgIGVuZGlhbiA9IGJhc2U7XG4gICAgICAgIGJhc2UgPSAxMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5faW5pdChudW1iZXIgfHwgMCwgYmFzZSB8fCAxMCwgZW5kaWFuIHx8ICdiZScpO1xuICAgIH1cbiAgfVxuICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IEJOO1xuICB9IGVsc2Uge1xuICAgIGV4cG9ydHMuQk4gPSBCTjtcbiAgfVxuXG4gIEJOLkJOID0gQk47XG4gIEJOLndvcmRTaXplID0gMjY7XG5cbiAgdmFyIEJ1ZmZlcjtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHdpbmRvdy5CdWZmZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBCdWZmZXIgPSB3aW5kb3cuQnVmZmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gIH1cblxuICBCTi5pc0JOID0gZnVuY3Rpb24gaXNCTiAobnVtKSB7XG4gICAgaWYgKG51bSBpbnN0YW5jZW9mIEJOKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVtICE9PSBudWxsICYmIHR5cGVvZiBudW0gPT09ICdvYmplY3QnICYmXG4gICAgICBudW0uY29uc3RydWN0b3Iud29yZFNpemUgPT09IEJOLndvcmRTaXplICYmIEFycmF5LmlzQXJyYXkobnVtLndvcmRzKTtcbiAgfTtcblxuICBCTi5tYXggPSBmdW5jdGlvbiBtYXggKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA+IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5taW4gPSBmdW5jdGlvbiBtaW4gKGxlZnQsIHJpZ2h0KSB7XG4gICAgaWYgKGxlZnQuY21wKHJpZ2h0KSA8IDApIHJldHVybiBsZWZ0O1xuICAgIHJldHVybiByaWdodDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXROdW1iZXIobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbnVtYmVyID09PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuIHRoaXMuX2luaXRBcnJheShudW1iZXIsIGJhc2UsIGVuZGlhbik7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBiYXNlID0gMTY7XG4gICAgfVxuICAgIGFzc2VydChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KTtcblxuICAgIG51bWJlciA9IG51bWJlci50b1N0cmluZygpLnJlcGxhY2UoL1xccysvZywgJycpO1xuICAgIHZhciBzdGFydCA9IDA7XG4gICAgaWYgKG51bWJlclswXSA9PT0gJy0nKSB7XG4gICAgICBzdGFydCsrO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgaWYgKHN0YXJ0IDwgbnVtYmVyLmxlbmd0aCkge1xuICAgICAgaWYgKGJhc2UgPT09IDE2KSB7XG4gICAgICAgIHRoaXMuX3BhcnNlSGV4KG51bWJlciwgc3RhcnQsIGVuZGlhbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9wYXJzZUJhc2UobnVtYmVyLCBiYXNlLCBzdGFydCk7XG4gICAgICAgIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICAgICAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0TnVtYmVyID0gZnVuY3Rpb24gX2luaXROdW1iZXIgKG51bWJlciwgYmFzZSwgZW5kaWFuKSB7XG4gICAgaWYgKG51bWJlciA8IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgbnVtYmVyID0gLW51bWJlcjtcbiAgICB9XG4gICAgaWYgKG51bWJlciA8IDB4NDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFtudW1iZXIgJiAweDNmZmZmZmZdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgMHgxMDAwMDAwMDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZlxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG51bWJlciA8IDB4MjAwMDAwMDAwMDAwMDApOyAvLyAyIF4gNTMgKHVuc2FmZSlcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmYsXG4gICAgICAgIDFcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDM7XG4gICAgfVxuXG4gICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG4gICAgLy8gUmV2ZXJzZSB0aGUgYnl0ZXNcbiAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0QXJyYXkgPSBmdW5jdGlvbiBfaW5pdEFycmF5IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIC8vIFBlcmhhcHMgYSBVaW50OEFycmF5XG4gICAgYXNzZXJ0KHR5cGVvZiBudW1iZXIubGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgaWYgKG51bWJlci5sZW5ndGggPD0gMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFswXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKG51bWJlci5sZW5ndGggLyAzKTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIHZhciBqLCB3O1xuICAgIHZhciBvZmYgPSAwO1xuICAgIGlmIChlbmRpYW4gPT09ICdiZScpIHtcbiAgICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSAxLCBqID0gMDsgaSA+PSAwOyBpIC09IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSAtIDFdIDw8IDgpIHwgKG51bWJlcltpIC0gMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbmRpYW4gPT09ICdsZScpIHtcbiAgICAgIGZvciAoaSA9IDAsIGogPSAwOyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgKyAxXSA8PCA4KSB8IChudW1iZXJbaSArIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUhleDRCaXRzIChzdHJpbmcsIGluZGV4KSB7XG4gICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpbmRleCk7XG4gICAgLy8gJzAnIC0gJzknXG4gICAgaWYgKGMgPj0gNDggJiYgYyA8PSA1Nykge1xuICAgICAgcmV0dXJuIGMgLSA0ODtcbiAgICAvLyAnQScgLSAnRidcbiAgICB9IGVsc2UgaWYgKGMgPj0gNjUgJiYgYyA8PSA3MCkge1xuICAgICAgcmV0dXJuIGMgLSA1NTtcbiAgICAvLyAnYScgLSAnZidcbiAgICB9IGVsc2UgaWYgKGMgPj0gOTcgJiYgYyA8PSAxMDIpIHtcbiAgICAgIHJldHVybiBjIC0gODc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ0ludmFsaWQgY2hhcmFjdGVyIGluICcgKyBzdHJpbmcpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlSGV4Qnl0ZSAoc3RyaW5nLCBsb3dlckJvdW5kLCBpbmRleCkge1xuICAgIHZhciByID0gcGFyc2VIZXg0Qml0cyhzdHJpbmcsIGluZGV4KTtcbiAgICBpZiAoaW5kZXggLSAxID49IGxvd2VyQm91bmQpIHtcbiAgICAgIHIgfD0gcGFyc2VIZXg0Qml0cyhzdHJpbmcsIGluZGV4IC0gMSkgPDwgNDtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlSGV4ID0gZnVuY3Rpb24gX3BhcnNlSGV4IChudW1iZXIsIHN0YXJ0LCBlbmRpYW4pIHtcbiAgICAvLyBDcmVhdGUgcG9zc2libHkgYmlnZ2VyIGFycmF5IHRvIGVuc3VyZSB0aGF0IGl0IGZpdHMgdGhlIG51bWJlclxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5jZWlsKChudW1iZXIubGVuZ3RoIC0gc3RhcnQpIC8gNik7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICAvLyAyNC1iaXRzIGNodW5rc1xuICAgIHZhciBvZmYgPSAwO1xuICAgIHZhciBqID0gMDtcblxuICAgIHZhciB3O1xuICAgIGlmIChlbmRpYW4gPT09ICdiZScpIHtcbiAgICAgIGZvciAoaSA9IG51bWJlci5sZW5ndGggLSAxOyBpID49IHN0YXJ0OyBpIC09IDIpIHtcbiAgICAgICAgdyA9IHBhcnNlSGV4Qnl0ZShudW1iZXIsIHN0YXJ0LCBpKSA8PCBvZmY7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gdyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgaWYgKG9mZiA+PSAxOCkge1xuICAgICAgICAgIG9mZiAtPSAxODtcbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ID4+PiAyNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmYgKz0gODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFyc2VMZW5ndGggPSBudW1iZXIubGVuZ3RoIC0gc3RhcnQ7XG4gICAgICBmb3IgKGkgPSBwYXJzZUxlbmd0aCAlIDIgPT09IDAgPyBzdGFydCArIDEgOiBzdGFydDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICB3ID0gcGFyc2VIZXhCeXRlKG51bWJlciwgc3RhcnQsIGkpIDw8IG9mZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ICYgMHgzZmZmZmZmO1xuICAgICAgICBpZiAob2ZmID49IDE4KSB7XG4gICAgICAgICAgb2ZmIC09IDE4O1xuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgPj4+IDI2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZiArPSA4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBmdW5jdGlvbiBwYXJzZUJhc2UgKHN0ciwgc3RhcnQsIGVuZCwgbXVsKSB7XG4gICAgdmFyIHIgPSAwO1xuICAgIHZhciBiID0gMDtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG4gICAgICByICo9IG11bDtcblxuICAgICAgLy8gJ2EnXG4gICAgICBpZiAoYyA+PSA0OSkge1xuICAgICAgICBiID0gYyAtIDQ5ICsgMHhhO1xuXG4gICAgICAvLyAnQSdcbiAgICAgIH0gZWxzZSBpZiAoYyA+PSAxNykge1xuICAgICAgICBiID0gYyAtIDE3ICsgMHhhO1xuXG4gICAgICAvLyAnMCcgLSAnOSdcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGIgPSBjO1xuICAgICAgfVxuICAgICAgYXNzZXJ0KGMgPj0gMCAmJiBiIDwgbXVsLCAnSW52YWxpZCBjaGFyYWN0ZXInKTtcbiAgICAgIHIgKz0gYjtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3BhcnNlQmFzZSA9IGZ1bmN0aW9uIF9wYXJzZUJhc2UgKG51bWJlciwgYmFzZSwgc3RhcnQpIHtcbiAgICAvLyBJbml0aWFsaXplIGFzIHplcm9cbiAgICB0aGlzLndvcmRzID0gWzBdO1xuICAgIHRoaXMubGVuZ3RoID0gMTtcblxuICAgIC8vIEZpbmQgbGVuZ3RoIG9mIGxpbWIgaW4gYmFzZVxuICAgIGZvciAodmFyIGxpbWJMZW4gPSAwLCBsaW1iUG93ID0gMTsgbGltYlBvdyA8PSAweDNmZmZmZmY7IGxpbWJQb3cgKj0gYmFzZSkge1xuICAgICAgbGltYkxlbisrO1xuICAgIH1cbiAgICBsaW1iTGVuLS07XG4gICAgbGltYlBvdyA9IChsaW1iUG93IC8gYmFzZSkgfCAwO1xuXG4gICAgdmFyIHRvdGFsID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgIHZhciBtb2QgPSB0b3RhbCAlIGxpbWJMZW47XG4gICAgdmFyIGVuZCA9IE1hdGgubWluKHRvdGFsLCB0b3RhbCAtIG1vZCkgKyBzdGFydDtcblxuICAgIHZhciB3b3JkID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gbGltYkxlbikge1xuICAgICAgd29yZCA9IHBhcnNlQmFzZShudW1iZXIsIGksIGkgKyBsaW1iTGVuLCBiYXNlKTtcblxuICAgICAgdGhpcy5pbXVsbihsaW1iUG93KTtcbiAgICAgIGlmICh0aGlzLndvcmRzWzBdICsgd29yZCA8IDB4NDAwMDAwMCkge1xuICAgICAgICB0aGlzLndvcmRzWzBdICs9IHdvcmQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pYWRkbih3b3JkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobW9kICE9PSAwKSB7XG4gICAgICB2YXIgcG93ID0gMTtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBudW1iZXIubGVuZ3RoLCBiYXNlKTtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG1vZDsgaSsrKSB7XG4gICAgICAgIHBvdyAqPSBiYXNlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmltdWxuKHBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRlc3QpIHtcbiAgICBkZXN0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc3Qud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgIH1cbiAgICBkZXN0Lmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIGRlc3QubmVnYXRpdmUgPSB0aGlzLm5lZ2F0aXZlO1xuICAgIGRlc3QucmVkID0gdGhpcy5yZWQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gbW92ZSAoZGVzdCwgc3JjKSB7XG4gICAgZGVzdC53b3JkcyA9IHNyYy53b3JkcztcbiAgICBkZXN0Lmxlbmd0aCA9IHNyYy5sZW5ndGg7XG4gICAgZGVzdC5uZWdhdGl2ZSA9IHNyYy5uZWdhdGl2ZTtcbiAgICBkZXN0LnJlZCA9IHNyYy5yZWQ7XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX21vdmUgPSBmdW5jdGlvbiBfbW92ZSAoZGVzdCkge1xuICAgIG1vdmUoZGVzdCwgdGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciByID0gbmV3IEJOKG51bGwpO1xuICAgIHRoaXMuY29weShyKTtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2V4cGFuZCA9IGZ1bmN0aW9uIF9leHBhbmQgKHNpemUpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBzaXplKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIGxlYWRpbmcgYDBgIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5fc3RyaXAgPSBmdW5jdGlvbiBzdHJpcCAoKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoID4gMSAmJiB0aGlzLndvcmRzW3RoaXMubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgIHRoaXMubGVuZ3RoLS07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fbm9ybVNpZ24gPSBmdW5jdGlvbiBfbm9ybVNpZ24gKCkge1xuICAgIC8vIC0wID0gMFxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gQ2hlY2sgU3ltYm9sLmZvciBiZWNhdXNlIG5vdCBldmVyeXdoZXJlIHdoZXJlIFN5bWJvbCBkZWZpbmVkXG4gIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TeW1ib2wjQnJvd3Nlcl9jb21wYXRpYmlsaXR5XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgU3ltYm9sLmZvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICBCTi5wcm90b3R5cGVbU3ltYm9sLmZvcignbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKV0gPSBpbnNwZWN0O1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgQk4ucHJvdG90eXBlLmluc3BlY3QgPSBpbnNwZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLnJlZCA/ICc8Qk4tUjogJyA6ICc8Qk46ICcpICsgdGhpcy50b1N0cmluZygxNikgKyAnPic7XG4gIH1cblxuICAvKlxuXG4gIHZhciB6ZXJvcyA9IFtdO1xuICB2YXIgZ3JvdXBTaXplcyA9IFtdO1xuICB2YXIgZ3JvdXBCYXNlcyA9IFtdO1xuXG4gIHZhciBzID0gJyc7XG4gIHZhciBpID0gLTE7XG4gIHdoaWxlICgrK2kgPCBCTi53b3JkU2l6ZSkge1xuICAgIHplcm9zW2ldID0gcztcbiAgICBzICs9ICcwJztcbiAgfVxuICBncm91cFNpemVzWzBdID0gMDtcbiAgZ3JvdXBTaXplc1sxXSA9IDA7XG4gIGdyb3VwQmFzZXNbMF0gPSAwO1xuICBncm91cEJhc2VzWzFdID0gMDtcbiAgdmFyIGJhc2UgPSAyIC0gMTtcbiAgd2hpbGUgKCsrYmFzZSA8IDM2ICsgMSkge1xuICAgIHZhciBncm91cFNpemUgPSAwO1xuICAgIHZhciBncm91cEJhc2UgPSAxO1xuICAgIHdoaWxlIChncm91cEJhc2UgPCAoMSA8PCBCTi53b3JkU2l6ZSkgLyBiYXNlKSB7XG4gICAgICBncm91cEJhc2UgKj0gYmFzZTtcbiAgICAgIGdyb3VwU2l6ZSArPSAxO1xuICAgIH1cbiAgICBncm91cFNpemVzW2Jhc2VdID0gZ3JvdXBTaXplO1xuICAgIGdyb3VwQmFzZXNbYmFzZV0gPSBncm91cEJhc2U7XG4gIH1cblxuICAqL1xuXG4gIHZhciB6ZXJvcyA9IFtcbiAgICAnJyxcbiAgICAnMCcsXG4gICAgJzAwJyxcbiAgICAnMDAwJyxcbiAgICAnMDAwMCcsXG4gICAgJzAwMDAwJyxcbiAgICAnMDAwMDAwJyxcbiAgICAnMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCdcbiAgXTtcblxuICB2YXIgZ3JvdXBTaXplcyA9IFtcbiAgICAwLCAwLFxuICAgIDI1LCAxNiwgMTIsIDExLCAxMCwgOSwgOCxcbiAgICA4LCA3LCA3LCA3LCA3LCA2LCA2LFxuICAgIDYsIDYsIDYsIDYsIDYsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1XG4gIF07XG5cbiAgdmFyIGdyb3VwQmFzZXMgPSBbXG4gICAgMCwgMCxcbiAgICAzMzU1NDQzMiwgNDMwNDY3MjEsIDE2Nzc3MjE2LCA0ODgyODEyNSwgNjA0NjYxNzYsIDQwMzUzNjA3LCAxNjc3NzIxNixcbiAgICA0MzA0NjcyMSwgMTAwMDAwMDAsIDE5NDg3MTcxLCAzNTgzMTgwOCwgNjI3NDg1MTcsIDc1Mjk1MzYsIDExMzkwNjI1LFxuICAgIDE2Nzc3MjE2LCAyNDEzNzU2OSwgMzQwMTIyMjQsIDQ3MDQ1ODgxLCA2NDAwMDAwMCwgNDA4NDEwMSwgNTE1MzYzMixcbiAgICA2NDM2MzQzLCA3OTYyNjI0LCA5NzY1NjI1LCAxMTg4MTM3NiwgMTQzNDg5MDcsIDE3MjEwMzY4LCAyMDUxMTE0OSxcbiAgICAyNDMwMDAwMCwgMjg2MjkxNTEsIDMzNTU0NDMyLCAzOTEzNTM5MywgNDU0MzU0MjQsIDUyNTIxODc1LCA2MDQ2NjE3NlxuICBdO1xuXG4gIEJOLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nIChiYXNlLCBwYWRkaW5nKSB7XG4gICAgYmFzZSA9IGJhc2UgfHwgMTA7XG4gICAgcGFkZGluZyA9IHBhZGRpbmcgfCAwIHx8IDE7XG5cbiAgICB2YXIgb3V0O1xuICAgIGlmIChiYXNlID09PSAxNiB8fCBiYXNlID09PSAnaGV4Jykge1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgb2ZmID0gMDtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldO1xuICAgICAgICB2YXIgd29yZCA9ICgoKHcgPDwgb2ZmKSB8IGNhcnJ5KSAmIDB4ZmZmZmZmKS50b1N0cmluZygxNik7XG4gICAgICAgIGNhcnJ5ID0gKHcgPj4+ICgyNCAtIG9mZikpICYgMHhmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyO1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FycnkgIT09IDAgfHwgaSAhPT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgb3V0ID0gemVyb3NbNiAtIHdvcmQubGVuZ3RoXSArIHdvcmQgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gd29yZCArIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICAgIG91dCA9IGNhcnJ5LnRvU3RyaW5nKDE2KSArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAoYmFzZSB8IDApICYmIGJhc2UgPj0gMiAmJiBiYXNlIDw9IDM2KSB7XG4gICAgICAvLyB2YXIgZ3JvdXBTaXplID0gTWF0aC5mbG9vcihCTi53b3JkU2l6ZSAqIE1hdGguTE4yIC8gTWF0aC5sb2coYmFzZSkpO1xuICAgICAgdmFyIGdyb3VwU2l6ZSA9IGdyb3VwU2l6ZXNbYmFzZV07XG4gICAgICAvLyB2YXIgZ3JvdXBCYXNlID0gTWF0aC5wb3coYmFzZSwgZ3JvdXBTaXplKTtcbiAgICAgIHZhciBncm91cEJhc2UgPSBncm91cEJhc2VzW2Jhc2VdO1xuICAgICAgb3V0ID0gJyc7XG4gICAgICB2YXIgYyA9IHRoaXMuY2xvbmUoKTtcbiAgICAgIGMubmVnYXRpdmUgPSAwO1xuICAgICAgd2hpbGUgKCFjLmlzWmVybygpKSB7XG4gICAgICAgIHZhciByID0gYy5tb2Rybihncm91cEJhc2UpLnRvU3RyaW5nKGJhc2UpO1xuICAgICAgICBjID0gYy5pZGl2bihncm91cEJhc2UpO1xuXG4gICAgICAgIGlmICghYy5pc1plcm8oKSkge1xuICAgICAgICAgIG91dCA9IHplcm9zW2dyb3VwU2l6ZSAtIHIubGVuZ3RoXSArIHIgKyBvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0ID0gciArIG91dDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGZhbHNlLCAnQmFzZSBzaG91bGQgYmUgYmV0d2VlbiAyIGFuZCAzNicpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b051bWJlciA9IGZ1bmN0aW9uIHRvTnVtYmVyICgpIHtcbiAgICB2YXIgcmV0ID0gdGhpcy53b3Jkc1swXTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIHJldCArPSB0aGlzLndvcmRzWzFdICogMHg0MDAwMDAwO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPT09IDMgJiYgdGhpcy53b3Jkc1syXSA9PT0gMHgwMSkge1xuICAgICAgLy8gTk9URTogYXQgdGhpcyBzdGFnZSBpdCBpcyBrbm93biB0aGF0IHRoZSB0b3AgYml0IGlzIHNldFxuICAgICAgcmV0ICs9IDB4MTAwMDAwMDAwMDAwMDAgKyAodGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMCk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IDIpIHtcbiAgICAgIGFzc2VydChmYWxzZSwgJ051bWJlciBjYW4gb25seSBzYWZlbHkgc3RvcmUgdXAgdG8gNTMgYml0cycpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMubmVnYXRpdmUgIT09IDApID8gLXJldCA6IHJldDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgICByZXR1cm4gdGhpcy50b1N0cmluZygxNiwgMik7XG4gIH07XG5cbiAgaWYgKEJ1ZmZlcikge1xuICAgIEJOLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIHRvQnVmZmVyIChlbmRpYW4sIGxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQnVmZmVyLCBlbmRpYW4sIGxlbmd0aCk7XG4gICAgfTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS50b0FycmF5ID0gZnVuY3Rpb24gdG9BcnJheSAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy50b0FycmF5TGlrZShBcnJheSwgZW5kaWFuLCBsZW5ndGgpO1xuICB9O1xuXG4gIHZhciBhbGxvY2F0ZSA9IGZ1bmN0aW9uIGFsbG9jYXRlIChBcnJheVR5cGUsIHNpemUpIHtcbiAgICBpZiAoQXJyYXlUeXBlLmFsbG9jVW5zYWZlKSB7XG4gICAgICByZXR1cm4gQXJyYXlUeXBlLmFsbG9jVW5zYWZlKHNpemUpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEFycmF5VHlwZShzaXplKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9BcnJheUxpa2UgPSBmdW5jdGlvbiB0b0FycmF5TGlrZSAoQXJyYXlUeXBlLCBlbmRpYW4sIGxlbmd0aCkge1xuICAgIHRoaXMuX3N0cmlwKCk7XG5cbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRoaXMuYnl0ZUxlbmd0aCgpO1xuICAgIHZhciByZXFMZW5ndGggPSBsZW5ndGggfHwgTWF0aC5tYXgoMSwgYnl0ZUxlbmd0aCk7XG4gICAgYXNzZXJ0KGJ5dGVMZW5ndGggPD0gcmVxTGVuZ3RoLCAnYnl0ZSBhcnJheSBsb25nZXIgdGhhbiBkZXNpcmVkIGxlbmd0aCcpO1xuICAgIGFzc2VydChyZXFMZW5ndGggPiAwLCAnUmVxdWVzdGVkIGFycmF5IGxlbmd0aCA8PSAwJyk7XG5cbiAgICB2YXIgcmVzID0gYWxsb2NhdGUoQXJyYXlUeXBlLCByZXFMZW5ndGgpO1xuICAgIHZhciBwb3N0Zml4ID0gZW5kaWFuID09PSAnbGUnID8gJ0xFJyA6ICdCRSc7XG4gICAgdGhpc1snX3RvQXJyYXlMaWtlJyArIHBvc3RmaXhdKHJlcywgYnl0ZUxlbmd0aCk7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3RvQXJyYXlMaWtlTEUgPSBmdW5jdGlvbiBfdG9BcnJheUxpa2VMRSAocmVzLCBieXRlTGVuZ3RoKSB7XG4gICAgdmFyIHBvc2l0aW9uID0gMDtcbiAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIHNoaWZ0ID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3b3JkID0gKHRoaXMud29yZHNbaV0gPDwgc2hpZnQpIHwgY2Fycnk7XG5cbiAgICAgIHJlc1twb3NpdGlvbisrXSA9IHdvcmQgJiAweGZmO1xuICAgICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICByZXNbcG9zaXRpb24rK10gPSAod29yZCA+PiA4KSAmIDB4ZmY7XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbisrXSA9ICh3b3JkID4+IDE2KSAmIDB4ZmY7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaGlmdCA9PT0gNikge1xuICAgICAgICBpZiAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gKHdvcmQgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gd29yZCA+Pj4gMjQ7XG4gICAgICAgIHNoaWZ0ICs9IDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgcmVzW3Bvc2l0aW9uKytdID0gY2Fycnk7XG5cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gMDtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl90b0FycmF5TGlrZUJFID0gZnVuY3Rpb24gX3RvQXJyYXlMaWtlQkUgKHJlcywgYnl0ZUxlbmd0aCkge1xuICAgIHZhciBwb3NpdGlvbiA9IHJlcy5sZW5ndGggLSAxO1xuICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgc2hpZnQgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHdvcmQgPSAodGhpcy53b3Jkc1tpXSA8PCBzaGlmdCkgfCBjYXJyeTtcblxuICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gd29yZCAmIDB4ZmY7XG4gICAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAod29yZCA+PiA4KSAmIDB4ZmY7XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAod29yZCA+PiAxNikgJiAweGZmO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hpZnQgPT09IDYpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAod29yZCA+PiAyNCkgJiAweGZmO1xuICAgICAgICB9XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgICAgc2hpZnQgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3b3JkID4+PiAyNDtcbiAgICAgICAgc2hpZnQgKz0gMjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPj0gMCkge1xuICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gY2Fycnk7XG5cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbi0tXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGlmIChNYXRoLmNsejMyKSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICByZXR1cm4gMzIgLSBNYXRoLmNsejMyKHcpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgQk4ucHJvdG90eXBlLl9jb3VudEJpdHMgPSBmdW5jdGlvbiBfY291bnRCaXRzICh3KSB7XG4gICAgICB2YXIgdCA9IHc7XG4gICAgICB2YXIgciA9IDA7XG4gICAgICBpZiAodCA+PSAweDEwMDApIHtcbiAgICAgICAgciArPSAxMztcbiAgICAgICAgdCA+Pj49IDEzO1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg0MCkge1xuICAgICAgICByICs9IDc7XG4gICAgICAgIHQgPj4+PSA3O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHg4KSB7XG4gICAgICAgIHIgKz0gNDtcbiAgICAgICAgdCA+Pj49IDQ7XG4gICAgICB9XG4gICAgICBpZiAodCA+PSAweDAyKSB7XG4gICAgICAgIHIgKz0gMjtcbiAgICAgICAgdCA+Pj49IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gciArIHQ7XG4gICAgfTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5femVyb0JpdHMgPSBmdW5jdGlvbiBfemVyb0JpdHMgKHcpIHtcbiAgICAvLyBTaG9ydC1jdXRcbiAgICBpZiAodyA9PT0gMCkgcmV0dXJuIDI2O1xuXG4gICAgdmFyIHQgPSB3O1xuICAgIHZhciByID0gMDtcbiAgICBpZiAoKHQgJiAweDFmZmYpID09PSAwKSB7XG4gICAgICByICs9IDEzO1xuICAgICAgdCA+Pj49IDEzO1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDdmKSA9PT0gMCkge1xuICAgICAgciArPSA3O1xuICAgICAgdCA+Pj49IDc7XG4gICAgfVxuICAgIGlmICgodCAmIDB4ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNDtcbiAgICAgIHQgPj4+PSA0O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweDMpID09PSAwKSB7XG4gICAgICByICs9IDI7XG4gICAgICB0ID4+Pj0gMjtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgxKSA9PT0gMCkge1xuICAgICAgcisrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICAvLyBSZXR1cm4gbnVtYmVyIG9mIHVzZWQgYml0cyBpbiBhIEJOXG4gIEJOLnByb3RvdHlwZS5iaXRMZW5ndGggPSBmdW5jdGlvbiBiaXRMZW5ndGggKCkge1xuICAgIHZhciB3ID0gdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdO1xuICAgIHZhciBoaSA9IHRoaXMuX2NvdW50Qml0cyh3KTtcbiAgICByZXR1cm4gKHRoaXMubGVuZ3RoIC0gMSkgKiAyNiArIGhpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHRvQml0QXJyYXkgKG51bSkge1xuICAgIHZhciB3ID0gbmV3IEFycmF5KG51bS5iaXRMZW5ndGgoKSk7XG5cbiAgICBmb3IgKHZhciBiaXQgPSAwOyBiaXQgPCB3Lmxlbmd0aDsgYml0KyspIHtcbiAgICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICAgIHdbYml0XSA9IChudW0ud29yZHNbb2ZmXSA+Pj4gd2JpdCkgJiAweDAxO1xuICAgIH1cblxuICAgIHJldHVybiB3O1xuICB9XG5cbiAgLy8gTnVtYmVyIG9mIHRyYWlsaW5nIHplcm8gYml0c1xuICBCTi5wcm90b3R5cGUuemVyb0JpdHMgPSBmdW5jdGlvbiB6ZXJvQml0cyAoKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiAwO1xuXG4gICAgdmFyIHIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGIgPSB0aGlzLl96ZXJvQml0cyh0aGlzLndvcmRzW2ldKTtcbiAgICAgIHIgKz0gYjtcbiAgICAgIGlmIChiICE9PSAyNikgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gYnl0ZUxlbmd0aCAoKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbCh0aGlzLmJpdExlbmd0aCgpIC8gOCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvVHdvcyA9IGZ1bmN0aW9uIHRvVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWJzKCkuaW5vdG4od2lkdGgpLmlhZGRuKDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mcm9tVHdvcyA9IGZ1bmN0aW9uIGZyb21Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLnRlc3RuKHdpZHRoIC0gMSkpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vdG4od2lkdGgpLmlhZGRuKDEpLmluZWcoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNOZWcgPSBmdW5jdGlvbiBpc05lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubmVnYXRpdmUgIT09IDA7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG5lZ2F0aXZlIGNsb25lIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmluZWcoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW5lZyA9IGZ1bmN0aW9uIGluZWcgKCkge1xuICAgIGlmICghdGhpcy5pc1plcm8oKSkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIE9yIGBudW1gIHdpdGggYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdW9yID0gZnVuY3Rpb24gaXVvciAobnVtKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgbnVtLmxlbmd0aCkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldIHwgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pb3IgPSBmdW5jdGlvbiBpb3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1b3IobnVtKTtcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUub3IgPSBmdW5jdGlvbiBvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pb3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaW9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51b3IgPSBmdW5jdGlvbiB1b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXVvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdW9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIEFuZCBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVhbmQgPSBmdW5jdGlvbiBpdWFuZCAobnVtKSB7XG4gICAgLy8gYiA9IG1pbi1sZW5ndGgobnVtLCB0aGlzKVxuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gJiBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBiLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYW5kID0gZnVuY3Rpb24gaWFuZCAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVhbmQobnVtKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhbmQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVhbmQgPSBmdW5jdGlvbiB1YW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1YW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1YW5kKHRoaXMpO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXV4b3IgPSBmdW5jdGlvbiBpdXhvciAobnVtKSB7XG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhO1xuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV0gXiBiLndvcmRzW2ldO1xuICAgIH1cblxuICAgIGlmICh0aGlzICE9PSBhKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5peG9yID0gZnVuY3Rpb24gaXhvciAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXV4b3IobnVtKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnhvciA9IGZ1bmN0aW9uIHhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5peG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml4b3IodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnV4b3IgPSBmdW5jdGlvbiB1eG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1eG9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1eG9yKHRoaXMpO1xuICB9O1xuXG4gIC8vIE5vdCBgYHRoaXNgYCB3aXRoIGBgd2lkdGhgYCBiaXR3aWR0aFxuICBCTi5wcm90b3R5cGUuaW5vdG4gPSBmdW5jdGlvbiBpbm90biAod2lkdGgpIHtcbiAgICBhc3NlcnQodHlwZW9mIHdpZHRoID09PSAnbnVtYmVyJyAmJiB3aWR0aCA+PSAwKTtcblxuICAgIHZhciBieXRlc05lZWRlZCA9IE1hdGguY2VpbCh3aWR0aCAvIDI2KSB8IDA7XG4gICAgdmFyIGJpdHNMZWZ0ID0gd2lkdGggJSAyNjtcblxuICAgIC8vIEV4dGVuZCB0aGUgYnVmZmVyIHdpdGggbGVhZGluZyB6ZXJvZXNcbiAgICB0aGlzLl9leHBhbmQoYnl0ZXNOZWVkZWQpO1xuXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgYnl0ZXNOZWVkZWQtLTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgY29tcGxldGUgd29yZHNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ5dGVzTmVlZGVkOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgdGhlIHJlc2lkdWVcbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAoMHgzZmZmZmZmID4+ICgyNiAtIGJpdHNMZWZ0KSk7XG4gICAgfVxuXG4gICAgLy8gQW5kIHJlbW92ZSBsZWFkaW5nIHplcm9lc1xuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ub3RuID0gZnVuY3Rpb24gbm90biAod2lkdGgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlub3RuKHdpZHRoKTtcbiAgfTtcblxuICAvLyBTZXQgYGJpdGAgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zZXRuID0gZnVuY3Rpb24gc2V0biAoYml0LCB2YWwpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuXG4gICAgdmFyIG9mZiA9IChiaXQgLyAyNikgfCAwO1xuICAgIHZhciB3Yml0ID0gYml0ICUgMjY7XG5cbiAgICB0aGlzLl9leHBhbmQob2ZmICsgMSk7XG5cbiAgICBpZiAodmFsKSB7XG4gICAgICB0aGlzLndvcmRzW29mZl0gPSB0aGlzLndvcmRzW29mZl0gfCAoMSA8PCB3Yml0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdICYgfigxIDw8IHdiaXQpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChudW0pIHtcbiAgICB2YXIgcjtcblxuICAgIC8vIG5lZ2F0aXZlICsgcG9zaXRpdmVcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG5cbiAgICAvLyBwb3NpdGl2ZSArIG5lZ2F0aXZlXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGhdID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIC8vIENvcHkgdGhlIHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgfSBlbHNlIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChudW0pIHtcbiAgICB2YXIgcmVzO1xuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDAgJiYgdGhpcy5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IHRoaXMuc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIGlmIChudW0ubmVnYXRpdmUgPT09IDAgJiYgdGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSBudW0uc3ViKHRoaXMpO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZChudW0pO1xuXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhZGQodGhpcyk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChudW0pIHtcbiAgICAvLyB0aGlzIC0gKC1udW0pID0gdGhpcyArIG51bVxuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICB2YXIgciA9IHRoaXMuaWFkZChudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gLXRoaXMgLSBudW0gPSAtKHRoaXMgKyBudW0pXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZChudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmVcbiAgICB2YXIgY21wID0gdGhpcy5jbXAobnVtKTtcblxuICAgIC8vIE9wdGltaXphdGlvbiAtIHplcm9pZnlcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gYSA+IGJcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoY21wID4gMCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApIC0gKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIENvcHkgcmVzdCBvZiB0aGUgd29yZHNcbiAgICBpZiAoY2FycnkgPT09IDAgJiYgaSA8IGEubGVuZ3RoICYmIGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpKTtcblxuICAgIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzdWIobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBzbWFsbE11bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIG91dC5uZWdhdGl2ZSA9IG51bS5uZWdhdGl2ZSBeIHNlbGYubmVnYXRpdmU7XG4gICAgdmFyIGxlbiA9IChzZWxmLmxlbmd0aCArIG51bS5sZW5ndGgpIHwgMDtcbiAgICBvdXQubGVuZ3RoID0gbGVuO1xuICAgIGxlbiA9IChsZW4gLSAxKSB8IDA7XG5cbiAgICAvLyBQZWVsIG9uZSBpdGVyYXRpb24gKGNvbXBpbGVyIGNhbid0IGRvIGl0LCBiZWNhdXNlIG9mIGNvZGUgY29tcGxleGl0eSlcbiAgICB2YXIgYSA9IHNlbGYud29yZHNbMF0gfCAwO1xuICAgIHZhciBiID0gbnVtLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgdmFyIGxvID0gciAmIDB4M2ZmZmZmZjtcbiAgICB2YXIgY2FycnkgPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgIG91dC53b3Jkc1swXSA9IGxvO1xuXG4gICAgZm9yICh2YXIgayA9IDE7IGsgPCBsZW47IGsrKykge1xuICAgICAgLy8gU3VtIGFsbCB3b3JkcyB3aXRoIHRoZSBzYW1lIGBpICsgaiA9IGtgIGFuZCBhY2N1bXVsYXRlIGBuY2FycnlgLFxuICAgICAgLy8gbm90ZSB0aGF0IG5jYXJyeSBjb3VsZCBiZSA+PSAweDNmZmZmZmZcbiAgICAgIHZhciBuY2FycnkgPSBjYXJyeSA+Pj4gMjY7XG4gICAgICB2YXIgcndvcmQgPSBjYXJyeSAmIDB4M2ZmZmZmZjtcbiAgICAgIHZhciBtYXhKID0gTWF0aC5taW4oaywgbnVtLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaiA9IE1hdGgubWF4KDAsIGsgLSBzZWxmLmxlbmd0aCArIDEpOyBqIDw9IG1heEo7IGorKykge1xuICAgICAgICB2YXIgaSA9IChrIC0gaikgfCAwO1xuICAgICAgICBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICByID0gYSAqIGIgKyByd29yZDtcbiAgICAgICAgbmNhcnJ5ICs9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAgIHJ3b3JkID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIH1cbiAgICAgIG91dC53b3Jkc1trXSA9IHJ3b3JkIHwgMDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5IHwgMDtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeSB8IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0Ll9zdHJpcCgpO1xuICB9XG5cbiAgLy8gVE9ETyhpbmR1dG55KTogaXQgbWF5IGJlIHJlYXNvbmFibGUgdG8gb21pdCBpdCBmb3IgdXNlcnMgd2hvIGRvbid0IG5lZWRcbiAgLy8gdG8gd29yayB3aXRoIDI1Ni1iaXQgbnVtYmVycywgb3RoZXJ3aXNlIGl0IGdpdmVzIDIwJSBpbXByb3ZlbWVudCBmb3IgMjU2LWJpdFxuICAvLyBtdWx0aXBsaWNhdGlvbiAobGlrZSBlbGxpcHRpYyBzZWNwMjU2azEpLlxuICB2YXIgY29tYjEwTXVsVG8gPSBmdW5jdGlvbiBjb21iMTBNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICB2YXIgYSA9IHNlbGYud29yZHM7XG4gICAgdmFyIGIgPSBudW0ud29yZHM7XG4gICAgdmFyIG8gPSBvdXQud29yZHM7XG4gICAgdmFyIGMgPSAwO1xuICAgIHZhciBsbztcbiAgICB2YXIgbWlkO1xuICAgIHZhciBoaTtcbiAgICB2YXIgYTAgPSBhWzBdIHwgMDtcbiAgICB2YXIgYWwwID0gYTAgJiAweDFmZmY7XG4gICAgdmFyIGFoMCA9IGEwID4+PiAxMztcbiAgICB2YXIgYTEgPSBhWzFdIHwgMDtcbiAgICB2YXIgYWwxID0gYTEgJiAweDFmZmY7XG4gICAgdmFyIGFoMSA9IGExID4+PiAxMztcbiAgICB2YXIgYTIgPSBhWzJdIHwgMDtcbiAgICB2YXIgYWwyID0gYTIgJiAweDFmZmY7XG4gICAgdmFyIGFoMiA9IGEyID4+PiAxMztcbiAgICB2YXIgYTMgPSBhWzNdIHwgMDtcbiAgICB2YXIgYWwzID0gYTMgJiAweDFmZmY7XG4gICAgdmFyIGFoMyA9IGEzID4+PiAxMztcbiAgICB2YXIgYTQgPSBhWzRdIHwgMDtcbiAgICB2YXIgYWw0ID0gYTQgJiAweDFmZmY7XG4gICAgdmFyIGFoNCA9IGE0ID4+PiAxMztcbiAgICB2YXIgYTUgPSBhWzVdIHwgMDtcbiAgICB2YXIgYWw1ID0gYTUgJiAweDFmZmY7XG4gICAgdmFyIGFoNSA9IGE1ID4+PiAxMztcbiAgICB2YXIgYTYgPSBhWzZdIHwgMDtcbiAgICB2YXIgYWw2ID0gYTYgJiAweDFmZmY7XG4gICAgdmFyIGFoNiA9IGE2ID4+PiAxMztcbiAgICB2YXIgYTcgPSBhWzddIHwgMDtcbiAgICB2YXIgYWw3ID0gYTcgJiAweDFmZmY7XG4gICAgdmFyIGFoNyA9IGE3ID4+PiAxMztcbiAgICB2YXIgYTggPSBhWzhdIHwgMDtcbiAgICB2YXIgYWw4ID0gYTggJiAweDFmZmY7XG4gICAgdmFyIGFoOCA9IGE4ID4+PiAxMztcbiAgICB2YXIgYTkgPSBhWzldIHwgMDtcbiAgICB2YXIgYWw5ID0gYTkgJiAweDFmZmY7XG4gICAgdmFyIGFoOSA9IGE5ID4+PiAxMztcbiAgICB2YXIgYjAgPSBiWzBdIHwgMDtcbiAgICB2YXIgYmwwID0gYjAgJiAweDFmZmY7XG4gICAgdmFyIGJoMCA9IGIwID4+PiAxMztcbiAgICB2YXIgYjEgPSBiWzFdIHwgMDtcbiAgICB2YXIgYmwxID0gYjEgJiAweDFmZmY7XG4gICAgdmFyIGJoMSA9IGIxID4+PiAxMztcbiAgICB2YXIgYjIgPSBiWzJdIHwgMDtcbiAgICB2YXIgYmwyID0gYjIgJiAweDFmZmY7XG4gICAgdmFyIGJoMiA9IGIyID4+PiAxMztcbiAgICB2YXIgYjMgPSBiWzNdIHwgMDtcbiAgICB2YXIgYmwzID0gYjMgJiAweDFmZmY7XG4gICAgdmFyIGJoMyA9IGIzID4+PiAxMztcbiAgICB2YXIgYjQgPSBiWzRdIHwgMDtcbiAgICB2YXIgYmw0ID0gYjQgJiAweDFmZmY7XG4gICAgdmFyIGJoNCA9IGI0ID4+PiAxMztcbiAgICB2YXIgYjUgPSBiWzVdIHwgMDtcbiAgICB2YXIgYmw1ID0gYjUgJiAweDFmZmY7XG4gICAgdmFyIGJoNSA9IGI1ID4+PiAxMztcbiAgICB2YXIgYjYgPSBiWzZdIHwgMDtcbiAgICB2YXIgYmw2ID0gYjYgJiAweDFmZmY7XG4gICAgdmFyIGJoNiA9IGI2ID4+PiAxMztcbiAgICB2YXIgYjcgPSBiWzddIHwgMDtcbiAgICB2YXIgYmw3ID0gYjcgJiAweDFmZmY7XG4gICAgdmFyIGJoNyA9IGI3ID4+PiAxMztcbiAgICB2YXIgYjggPSBiWzhdIHwgMDtcbiAgICB2YXIgYmw4ID0gYjggJiAweDFmZmY7XG4gICAgdmFyIGJoOCA9IGI4ID4+PiAxMztcbiAgICB2YXIgYjkgPSBiWzldIHwgMDtcbiAgICB2YXIgYmw5ID0gYjkgJiAweDFmZmY7XG4gICAgdmFyIGJoOSA9IGI5ID4+PiAxMztcblxuICAgIG91dC5uZWdhdGl2ZSA9IHNlbGYubmVnYXRpdmUgXiBudW0ubmVnYXRpdmU7XG4gICAgb3V0Lmxlbmd0aCA9IDE5O1xuICAgIC8qIGsgPSAwICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwwLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDAsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDAsIGJoMCk7XG4gICAgdmFyIHcwID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MCA+Pj4gMjYpKSB8IDA7XG4gICAgdzAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwxLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDEsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDEsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgxKSkgfCAwO1xuICAgIHZhciB3MSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEgPj4+IDI2KSkgfCAwO1xuICAgIHcxICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwyLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgyLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDIpKSB8IDA7XG4gICAgdmFyIHcyID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MiA+Pj4gMjYpKSB8IDA7XG4gICAgdzIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAzICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWwzLCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDMsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDMsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDMpKSB8IDA7XG4gICAgdmFyIHczID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MyA+Pj4gMjYpKSB8IDA7XG4gICAgdzMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA0ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw0LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDQsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDQsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg0KSkgfCAwO1xuICAgIHZhciB3NCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzQgPj4+IDI2KSkgfCAwO1xuICAgIHc0ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw1LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg1LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDUpKSB8IDA7XG4gICAgdmFyIHc1ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NSA+Pj4gMjYpKSB8IDA7XG4gICAgdzUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA2ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw2LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDYsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDYsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDYpKSB8IDA7XG4gICAgdmFyIHc2ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3NiA+Pj4gMjYpKSB8IDA7XG4gICAgdzYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA3ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw3LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDcsIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDcsIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg3KSkgfCAwO1xuICAgIHZhciB3NyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzcgPj4+IDI2KSkgfCAwO1xuICAgIHc3ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw4LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg4LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDgpKSB8IDA7XG4gICAgdmFyIHc4ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OCA+Pj4gMjYpKSB8IDA7XG4gICAgdzggJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSA5ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDApO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMCk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMCkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMCk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwxKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmgxKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwyLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDIsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwxLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDEsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDEsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDAsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgwLCBiaDkpKSB8IDA7XG4gICAgdmFyIHc5ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3OSA+Pj4gMjYpKSB8IDA7XG4gICAgdzkgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwxKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDEpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDEpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDEpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEwID4+PiAyNikpIHwgMDtcbiAgICB3MTAgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwyKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDIpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDIpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDIpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzExID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTEgPj4+IDI2KSkgfCAwO1xuICAgIHcxMSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDEyICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDMpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoMyk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsMykpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoMyk7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw1LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDUsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNSwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw0LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDQsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDQsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDMsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgzLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEyID4+PiAyNikpIHwgMDtcbiAgICB3MTIgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw0KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDQpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDQpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDQpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzEzID4+PiAyNikpIHwgMDtcbiAgICB3MTMgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw1KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDUpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDUpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDUpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg4KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE0ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTQgPj4+IDI2KSkgfCAwO1xuICAgIHcxNCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE1ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDYpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoNik7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsNikpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoNik7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw4LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDgsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoOCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw3LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDcsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDcsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDYsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg2LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE1ID4+PiAyNikpIHwgMDtcbiAgICB3MTUgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw3KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDcpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDcpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDcpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE2ID4+PiAyNikpIHwgMDtcbiAgICB3MTYgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw4KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDgpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDgpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDgpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsOSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoOSkpIHwgMDtcbiAgICB2YXIgdzE3ID0gKCgoYyArIGxvKSB8IDApICsgKChtaWQgJiAweDFmZmYpIDw8IDEzKSkgfCAwO1xuICAgIGMgPSAoKChoaSArIChtaWQgPj4+IDEzKSkgfCAwKSArICh3MTcgPj4+IDI2KSkgfCAwO1xuICAgIHcxNyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDE4ICovXG4gICAgbG8gPSBNYXRoLmltdWwoYWw5LCBibDkpO1xuICAgIG1pZCA9IE1hdGguaW11bChhbDksIGJoOSk7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDksIGJsOSkpIHwgMDtcbiAgICBoaSA9IE1hdGguaW11bChhaDksIGJoOSk7XG4gICAgdmFyIHcxOCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE4ID4+PiAyNikpIHwgMDtcbiAgICB3MTggJj0gMHgzZmZmZmZmO1xuICAgIG9bMF0gPSB3MDtcbiAgICBvWzFdID0gdzE7XG4gICAgb1syXSA9IHcyO1xuICAgIG9bM10gPSB3MztcbiAgICBvWzRdID0gdzQ7XG4gICAgb1s1XSA9IHc1O1xuICAgIG9bNl0gPSB3NjtcbiAgICBvWzddID0gdzc7XG4gICAgb1s4XSA9IHc4O1xuICAgIG9bOV0gPSB3OTtcbiAgICBvWzEwXSA9IHcxMDtcbiAgICBvWzExXSA9IHcxMTtcbiAgICBvWzEyXSA9IHcxMjtcbiAgICBvWzEzXSA9IHcxMztcbiAgICBvWzE0XSA9IHcxNDtcbiAgICBvWzE1XSA9IHcxNTtcbiAgICBvWzE2XSA9IHcxNjtcbiAgICBvWzE3XSA9IHcxNztcbiAgICBvWzE4XSA9IHcxODtcbiAgICBpZiAoYyAhPT0gMCkge1xuICAgICAgb1sxOV0gPSBjO1xuICAgICAgb3V0Lmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9O1xuXG4gIC8vIFBvbHlmaWxsIGNvbWJcbiAgaWYgKCFNYXRoLmltdWwpIHtcbiAgICBjb21iMTBNdWxUbyA9IHNtYWxsTXVsVG87XG4gIH1cblxuICBmdW5jdGlvbiBiaWdNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSBzZWxmLmxlbmd0aCArIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIHZhciBobmNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBrID0gMDsgayA8IG91dC5sZW5ndGggLSAxOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICAgIGhuY2FycnkgPSAwO1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSBrIC0gajtcbiAgICAgICAgdmFyIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgdmFyIGIgPSBudW0ud29yZHNbal0gfCAwO1xuICAgICAgICB2YXIgciA9IGEgKiBiO1xuXG4gICAgICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgICAgIG5jYXJyeSA9IChuY2FycnkgKyAoKHIgLyAweDQwMDAwMDApIHwgMCkpIHwgMDtcbiAgICAgICAgbG8gPSAobG8gKyByd29yZCkgfCAwO1xuICAgICAgICByd29yZCA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKGxvID4+PiAyNikpIHwgMDtcblxuICAgICAgICBobmNhcnJ5ICs9IG5jYXJyeSA+Pj4gMjY7XG4gICAgICAgIG5jYXJyeSAmPSAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZDtcbiAgICAgIGNhcnJ5ID0gbmNhcnJ5O1xuICAgICAgbmNhcnJ5ID0gaG5jYXJyeTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBvdXQud29yZHNba10gPSBjYXJyeTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuX3N0cmlwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBqdW1ib011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIC8vIFRlbXBvcmFyeSBkaXNhYmxlLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2luZHV0bnkvYm4uanMvaXNzdWVzLzIxMVxuICAgIC8vIHZhciBmZnRtID0gbmV3IEZGVE0oKTtcbiAgICAvLyByZXR1cm4gZmZ0bS5tdWxwKHNlbGYsIG51bSwgb3V0KTtcbiAgICByZXR1cm4gYmlnTXVsVG8oc2VsZiwgbnVtLCBvdXQpO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLm11bFRvID0gZnVuY3Rpb24gbXVsVG8gKG51bSwgb3V0KSB7XG4gICAgdmFyIHJlcztcbiAgICB2YXIgbGVuID0gdGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoO1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMTAgJiYgbnVtLmxlbmd0aCA9PT0gMTApIHtcbiAgICAgIHJlcyA9IGNvbWIxME11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDYzKSB7XG4gICAgICByZXMgPSBzbWFsbE11bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2UgaWYgKGxlbiA8IDEwMjQpIHtcbiAgICAgIHJlcyA9IGJpZ011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzID0ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb29sZXktVHVrZXkgYWxnb3JpdGhtIGZvciBGRlRcbiAgLy8gc2xpZ2h0bHkgcmV2aXNpdGVkIHRvIHJlbHkgb24gbG9vcGluZyBpbnN0ZWFkIG9mIHJlY3Vyc2lvblxuXG4gIGZ1bmN0aW9uIEZGVE0gKHgsIHkpIHtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gIH1cblxuICBGRlRNLnByb3RvdHlwZS5tYWtlUkJUID0gZnVuY3Rpb24gbWFrZVJCVCAoTikge1xuICAgIHZhciB0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBsID0gQk4ucHJvdG90eXBlLl9jb3VudEJpdHMoTikgLSAxO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB0W2ldID0gdGhpcy5yZXZCaW4oaSwgbCwgTik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBiaW5hcnktcmV2ZXJzZWQgcmVwcmVzZW50YXRpb24gb2YgYHhgXG4gIEZGVE0ucHJvdG90eXBlLnJldkJpbiA9IGZ1bmN0aW9uIHJldkJpbiAoeCwgbCwgTikge1xuICAgIGlmICh4ID09PSAwIHx8IHggPT09IE4gLSAxKSByZXR1cm4geDtcblxuICAgIHZhciByYiA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHJiIHw9ICh4ICYgMSkgPDwgKGwgLSBpIC0gMSk7XG4gICAgICB4ID4+PSAxO1xuICAgIH1cblxuICAgIHJldHVybiByYjtcbiAgfTtcblxuICAvLyBQZXJmb3JtcyBcInR3ZWVkbGluZ1wiIHBoYXNlLCB0aGVyZWZvcmUgJ2VtdWxhdGluZydcbiAgLy8gYmVoYXZpb3VyIG9mIHRoZSByZWN1cnNpdmUgYWxnb3JpdGhtXG4gIEZGVE0ucHJvdG90eXBlLnBlcm11dGUgPSBmdW5jdGlvbiBwZXJtdXRlIChyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHJ0d3NbaV0gPSByd3NbcmJ0W2ldXTtcbiAgICAgIGl0d3NbaV0gPSBpd3NbcmJ0W2ldXTtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUudHJhbnNmb3JtID0gZnVuY3Rpb24gdHJhbnNmb3JtIChyd3MsIGl3cywgcnR3cywgaXR3cywgTiwgcmJ0KSB7XG4gICAgdGhpcy5wZXJtdXRlKHJidCwgcndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4pO1xuXG4gICAgZm9yICh2YXIgcyA9IDE7IHMgPCBOOyBzIDw8PSAxKSB7XG4gICAgICB2YXIgbCA9IHMgPDwgMTtcblxuICAgICAgdmFyIHJ0d2RmID0gTWF0aC5jb3MoMiAqIE1hdGguUEkgLyBsKTtcbiAgICAgIHZhciBpdHdkZiA9IE1hdGguc2luKDIgKiBNYXRoLlBJIC8gbCk7XG5cbiAgICAgIGZvciAodmFyIHAgPSAwOyBwIDwgTjsgcCArPSBsKSB7XG4gICAgICAgIHZhciBydHdkZl8gPSBydHdkZjtcbiAgICAgICAgdmFyIGl0d2RmXyA9IGl0d2RmO1xuXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgczsgaisrKSB7XG4gICAgICAgICAgdmFyIHJlID0gcnR3c1twICsgal07XG4gICAgICAgICAgdmFyIGllID0gaXR3c1twICsgal07XG5cbiAgICAgICAgICB2YXIgcm8gPSBydHdzW3AgKyBqICsgc107XG4gICAgICAgICAgdmFyIGlvID0gaXR3c1twICsgaiArIHNdO1xuXG4gICAgICAgICAgdmFyIHJ4ID0gcnR3ZGZfICogcm8gLSBpdHdkZl8gKiBpbztcblxuICAgICAgICAgIGlvID0gcnR3ZGZfICogaW8gKyBpdHdkZl8gKiBybztcbiAgICAgICAgICBybyA9IHJ4O1xuXG4gICAgICAgICAgcnR3c1twICsgal0gPSByZSArIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGpdID0gaWUgKyBpbztcblxuICAgICAgICAgIHJ0d3NbcCArIGogKyBzXSA9IHJlIC0gcm87XG4gICAgICAgICAgaXR3c1twICsgaiArIHNdID0gaWUgLSBpbztcblxuICAgICAgICAgIC8qIGpzaGludCBtYXhkZXB0aCA6IGZhbHNlICovXG4gICAgICAgICAgaWYgKGogIT09IGwpIHtcbiAgICAgICAgICAgIHJ4ID0gcnR3ZGYgKiBydHdkZl8gLSBpdHdkZiAqIGl0d2RmXztcblxuICAgICAgICAgICAgaXR3ZGZfID0gcnR3ZGYgKiBpdHdkZl8gKyBpdHdkZiAqIHJ0d2RmXztcbiAgICAgICAgICAgIHJ0d2RmXyA9IHJ4O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ndWVzc0xlbjEzYiA9IGZ1bmN0aW9uIGd1ZXNzTGVuMTNiIChuLCBtKSB7XG4gICAgdmFyIE4gPSBNYXRoLm1heChtLCBuKSB8IDE7XG4gICAgdmFyIG9kZCA9IE4gJiAxO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKE4gPSBOIC8gMiB8IDA7IE47IE4gPSBOID4+PiAxKSB7XG4gICAgICBpKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIDEgPDwgaSArIDEgKyBvZGQ7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29uanVnYXRlID0gZnVuY3Rpb24gY29uanVnYXRlIChyd3MsIGl3cywgTikge1xuICAgIGlmIChOIDw9IDEpIHJldHVybjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTiAvIDI7IGkrKykge1xuICAgICAgdmFyIHQgPSByd3NbaV07XG5cbiAgICAgIHJ3c1tpXSA9IHJ3c1tOIC0gaSAtIDFdO1xuICAgICAgcndzW04gLSBpIC0gMV0gPSB0O1xuXG4gICAgICB0ID0gaXdzW2ldO1xuXG4gICAgICBpd3NbaV0gPSAtaXdzW04gLSBpIC0gMV07XG4gICAgICBpd3NbTiAtIGkgLSAxXSA9IC10O1xuICAgIH1cbiAgfTtcblxuICBGRlRNLnByb3RvdHlwZS5ub3JtYWxpemUxM2IgPSBmdW5jdGlvbiBub3JtYWxpemUxM2IgKHdzLCBOKSB7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB3ID0gTWF0aC5yb3VuZCh3c1syICogaSArIDFdIC8gTikgKiAweDIwMDAgK1xuICAgICAgICBNYXRoLnJvdW5kKHdzWzIgKiBpXSAvIE4pICtcbiAgICAgICAgY2Fycnk7XG5cbiAgICAgIHdzW2ldID0gdyAmIDB4M2ZmZmZmZjtcblxuICAgICAgaWYgKHcgPCAweDQwMDAwMDApIHtcbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FycnkgPSB3IC8gMHg0MDAwMDAwIHwgMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gd3M7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuY29udmVydDEzYiA9IGZ1bmN0aW9uIGNvbnZlcnQxM2IgKHdzLCBsZW4sIHJ3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgY2FycnkgPSBjYXJyeSArICh3c1tpXSB8IDApO1xuXG4gICAgICByd3NbMiAqIGldID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgICAgcndzWzIgKiBpICsgMV0gPSBjYXJyeSAmIDB4MWZmZjsgY2FycnkgPSBjYXJyeSA+Pj4gMTM7XG4gICAgfVxuXG4gICAgLy8gUGFkIHdpdGggemVyb2VzXG4gICAgZm9yIChpID0gMiAqIGxlbjsgaSA8IE47ICsraSkge1xuICAgICAgcndzW2ldID0gMDtcbiAgICB9XG5cbiAgICBhc3NlcnQoY2FycnkgPT09IDApO1xuICAgIGFzc2VydCgoY2FycnkgJiB+MHgxZmZmKSA9PT0gMCk7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuc3R1YiA9IGZ1bmN0aW9uIHN0dWIgKE4pIHtcbiAgICB2YXIgcGggPSBuZXcgQXJyYXkoTik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHBoW2ldID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4gcGg7XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubXVscCA9IGZ1bmN0aW9uIG11bHAgKHgsIHksIG91dCkge1xuICAgIHZhciBOID0gMiAqIHRoaXMuZ3Vlc3NMZW4xM2IoeC5sZW5ndGgsIHkubGVuZ3RoKTtcblxuICAgIHZhciByYnQgPSB0aGlzLm1ha2VSQlQoTik7XG5cbiAgICB2YXIgXyA9IHRoaXMuc3R1YihOKTtcblxuICAgIHZhciByd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIHJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIGl3c3QgPSBuZXcgQXJyYXkoTik7XG5cbiAgICB2YXIgbnJ3cyA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbnJ3c3QgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5pd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIHJtd3MgPSBvdXQud29yZHM7XG4gICAgcm13cy5sZW5ndGggPSBOO1xuXG4gICAgdGhpcy5jb252ZXJ0MTNiKHgud29yZHMsIHgubGVuZ3RoLCByd3MsIE4pO1xuICAgIHRoaXMuY29udmVydDEzYih5LndvcmRzLCB5Lmxlbmd0aCwgbnJ3cywgTik7XG5cbiAgICB0aGlzLnRyYW5zZm9ybShyd3MsIF8sIHJ3c3QsIGl3c3QsIE4sIHJidCk7XG4gICAgdGhpcy50cmFuc2Zvcm0obnJ3cywgXywgbnJ3c3QsIG5pd3N0LCBOLCByYnQpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOOyBpKyspIHtcbiAgICAgIHZhciByeCA9IHJ3c3RbaV0gKiBucndzdFtpXSAtIGl3c3RbaV0gKiBuaXdzdFtpXTtcbiAgICAgIGl3c3RbaV0gPSByd3N0W2ldICogbml3c3RbaV0gKyBpd3N0W2ldICogbnJ3c3RbaV07XG4gICAgICByd3N0W2ldID0gcng7XG4gICAgfVxuXG4gICAgdGhpcy5jb25qdWdhdGUocndzdCwgaXdzdCwgTik7XG4gICAgdGhpcy50cmFuc2Zvcm0ocndzdCwgaXdzdCwgcm13cywgXywgTiwgcmJ0KTtcbiAgICB0aGlzLmNvbmp1Z2F0ZShybXdzLCBfLCBOKTtcbiAgICB0aGlzLm5vcm1hbGl6ZTEzYihybXdzLCBOKTtcblxuICAgIG91dC5uZWdhdGl2ZSA9IHgubmVnYXRpdmUgXiB5Lm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSB4Lmxlbmd0aCArIHkubGVuZ3RoO1xuICAgIHJldHVybiBvdXQuX3N0cmlwKCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgYHRoaXNgIGJ5IGBudW1gXG4gIEJOLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXMubXVsVG8obnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGVtcGxveWluZyBGRlRcbiAgQk4ucHJvdG90eXBlLm11bGYgPSBmdW5jdGlvbiBtdWxmIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBNdWx0aXBsaWNhdGlvblxuICBCTi5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkubXVsVG8obnVtLCB0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW11bG4gPSBmdW5jdGlvbiBpbXVsbiAobnVtKSB7XG4gICAgdmFyIGlzTmVnTnVtID0gbnVtIDwgMDtcbiAgICBpZiAoaXNOZWdOdW0pIG51bSA9IC1udW07XG5cbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuXG4gICAgLy8gQ2FycnlcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICogbnVtO1xuICAgICAgdmFyIGxvID0gKHcgJiAweDNmZmZmZmYpICsgKGNhcnJ5ICYgMHgzZmZmZmZmKTtcbiAgICAgIGNhcnJ5ID4+PSAyNjtcbiAgICAgIGNhcnJ5ICs9ICh3IC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgICAvLyBOT1RFOiBsbyBpcyAyN2JpdCBtYXhpbXVtXG4gICAgICBjYXJyeSArPSBsbyA+Pj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cblxuICAgIHJldHVybiBpc05lZ051bSA/IHRoaXMuaW5lZygpIDogdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubXVsbiA9IGZ1bmN0aW9uIG11bG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4obnVtKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKHRoaXMpO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLmltdWwodGhpcy5jbG9uZSgpKTtcbiAgfTtcblxuICAvLyBNYXRoLnBvdyhgdGhpc2AsIGBudW1gKVxuICBCTi5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChudW0pIHtcbiAgICB2YXIgdyA9IHRvQml0QXJyYXkobnVtKTtcbiAgICBpZiAody5sZW5ndGggPT09IDApIHJldHVybiBuZXcgQk4oMSk7XG5cbiAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzXG4gICAgdmFyIHJlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3Lmxlbmd0aDsgaSsrLCByZXMgPSByZXMuc3FyKCkpIHtcbiAgICAgIGlmICh3W2ldICE9PSAwKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoKytpIDwgdy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIHEgPSByZXMuc3FyKCk7IGkgPCB3Lmxlbmd0aDsgaSsrLCBxID0gcS5zcXIoKSkge1xuICAgICAgICBpZiAod1tpXSA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gcmVzLm11bChxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnQgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1c2hsbiA9IGZ1bmN0aW9uIGl1c2hsbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcbiAgICB2YXIgY2FycnlNYXNrID0gKDB4M2ZmZmZmZiA+Pj4gKDI2IC0gcikpIDw8ICgyNiAtIHIpO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuZXdDYXJyeSA9IHRoaXMud29yZHNbaV0gJiBjYXJyeU1hc2s7XG4gICAgICAgIHZhciBjID0gKCh0aGlzLndvcmRzW2ldIHwgMCkgLSBuZXdDYXJyeSkgPDwgcjtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGMgfCBjYXJyeTtcbiAgICAgICAgY2FycnkgPSBuZXdDYXJyeSA+Pj4gKDI2IC0gcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYXJyeSkge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHMgIT09IDApIHtcbiAgICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgc10gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCArPSBzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc2hsbiA9IGZ1bmN0aW9uIGlzaGxuIChiaXRzKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodCBpbi1wbGFjZVxuICAvLyBOT1RFOiBgaGludGAgaXMgYSBsb3dlc3QgYml0IGJlZm9yZSB0cmFpbGluZyB6ZXJvZXNcbiAgLy8gTk9URTogaWYgYGV4dGVuZGVkYCBpcyBwcmVzZW50IC0gaXQgd2lsbCBiZSBmaWxsZWQgd2l0aCBkZXN0cm95ZWQgYml0c1xuICBCTi5wcm90b3R5cGUuaXVzaHJuID0gZnVuY3Rpb24gaXVzaHJuIChiaXRzLCBoaW50LCBleHRlbmRlZCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgaDtcbiAgICBpZiAoaGludCkge1xuICAgICAgaCA9IChoaW50IC0gKGhpbnQgJSAyNikpIC8gMjY7XG4gICAgfSBlbHNlIHtcbiAgICAgIGggPSAwO1xuICAgIH1cblxuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gTWF0aC5taW4oKGJpdHMgLSByKSAvIDI2LCB0aGlzLmxlbmd0aCk7XG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZmYgXiAoKDB4M2ZmZmZmZiA+Pj4gcikgPDwgcik7XG4gICAgdmFyIG1hc2tlZFdvcmRzID0gZXh0ZW5kZWQ7XG5cbiAgICBoIC09IHM7XG4gICAgaCA9IE1hdGgubWF4KDAsIGgpO1xuXG4gICAgLy8gRXh0ZW5kZWQgbW9kZSwgY29weSBtYXNrZWQgcGFydFxuICAgIGlmIChtYXNrZWRXb3Jkcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzOyBpKyspIHtcbiAgICAgICAgbWFza2VkV29yZHMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuICAgICAgbWFza2VkV29yZHMubGVuZ3RoID0gcztcbiAgICB9XG5cbiAgICBpZiAocyA9PT0gMCkge1xuICAgICAgLy8gTm8tb3AsIHdlIHNob3VsZCBub3QgbW92ZSBhbnl0aGluZyBhdCBhbGxcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID4gcykge1xuICAgICAgdGhpcy5sZW5ndGggLT0gcztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2kgKyBzXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAoY2FycnkgIT09IDAgfHwgaSA+PSBoKTsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IChjYXJyeSA8PCAoMjYgLSByKSkgfCAod29yZCA+Pj4gcik7XG4gICAgICBjYXJyeSA9IHdvcmQgJiBtYXNrO1xuICAgIH1cblxuICAgIC8vIFB1c2ggY2FycmllZCBiaXRzIGFzIGEgbWFza1xuICAgIGlmIChtYXNrZWRXb3JkcyAmJiBjYXJyeSAhPT0gMCkge1xuICAgICAgbWFza2VkV29yZHMud29yZHNbbWFza2VkV29yZHMubGVuZ3RoKytdID0gY2Fycnk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNocm4gPSBmdW5jdGlvbiBpc2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaHJuKGJpdHMsIGhpbnQsIGV4dGVuZGVkKTtcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0XG4gIEJOLnByb3RvdHlwZS5zaGxuID0gZnVuY3Rpb24gc2hsbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXNobG4oYml0cyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVzaGxuID0gZnVuY3Rpb24gdXNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLml1c2hsbihiaXRzKTtcbiAgfTtcblxuICAvLyBTaGlmdC1yaWdodFxuICBCTi5wcm90b3R5cGUuc2hybiA9IGZ1bmN0aW9uIHNocm4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaHJuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hybiA9IGZ1bmN0aW9uIHVzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNocm4oYml0cyk7XG4gIH07XG5cbiAgLy8gVGVzdCBpZiBuIGJpdCBpcyBzZXRcbiAgQk4ucHJvdG90eXBlLnRlc3RuID0gZnVuY3Rpb24gdGVzdG4gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyAmJiBiaXQgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gQ2hlY2sgYml0IGFuZCByZXR1cm5cbiAgICB2YXIgdyA9IHRoaXMud29yZHNbc107XG5cbiAgICByZXR1cm4gISEodyAmIHEpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlciAoaW4tcGxhY2UpXG4gIEJOLnByb3RvdHlwZS5pbWFza24gPSBmdW5jdGlvbiBpbWFza24gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG5cbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ2ltYXNrbiB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmUgbnVtYmVycycpO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICBzKys7XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5taW4ocywgdGhpcy5sZW5ndGgpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdICY9IG1hc2s7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uIG1hc2tuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyk7XG4gIH07XG5cbiAgLy8gQWRkIHBsYWluIG51bWJlciBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlhZGRuID0gZnVuY3Rpb24gaWFkZG4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlzdWJuKC1udW0pO1xuXG4gICAgLy8gUG9zc2libGUgc2lnbiBjaGFuZ2VcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmICh0aGlzLndvcmRzWzBdIHwgMCkgPD0gbnVtKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gPSBudW0gLSAodGhpcy53b3Jkc1swXSB8IDApO1xuICAgICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pc3VibihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aG91dCBjaGVja3NcbiAgICByZXR1cm4gdGhpcy5faWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lhZGRuID0gZnVuY3Rpb24gX2lhZGRuIChudW0pIHtcbiAgICB0aGlzLndvcmRzWzBdICs9IG51bTtcblxuICAgIC8vIENhcnJ5XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldID49IDB4NDAwMDAwMDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldIC09IDB4NDAwMDAwMDtcbiAgICAgIGlmIChpID09PSB0aGlzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0rKztcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSArIDEpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgcGxhaW4gbnVtYmVyIGBudW1gIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5pc3VibiA9IGZ1bmN0aW9uIGlzdWJuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pYWRkbigtbnVtKTtcblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZG4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy53b3Jkc1swXSAtPSBudW07XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA8IDApIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAtdGhpcy53b3Jkc1swXTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDYXJyeVxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAmJiB0aGlzLndvcmRzW2ldIDwgMDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gKz0gMHg0MDAwMDAwO1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSAtPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5hZGRuID0gZnVuY3Rpb24gYWRkbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5zdWJuID0gZnVuY3Rpb24gc3VibiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3VibihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYWJzID0gZnVuY3Rpb24gaWFicyAoKSB7XG4gICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWJzID0gZnVuY3Rpb24gYWJzICgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlhYnMoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2lzaGxuc3VibXVsID0gZnVuY3Rpb24gX2lzaGxuc3VibXVsIChudW0sIG11bCwgc2hpZnQpIHtcbiAgICB2YXIgbGVuID0gbnVtLmxlbmd0aCArIHNoaWZ0O1xuICAgIHZhciBpO1xuXG4gICAgdGhpcy5fZXhwYW5kKGxlbik7XG5cbiAgICB2YXIgdztcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIHZhciByaWdodCA9IChudW0ud29yZHNbaV0gfCAwKSAqIG11bDtcbiAgICAgIHcgLT0gcmlnaHQgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9ICh3ID4+IDI2KSAtICgocmlnaHQgLyAweDQwMDAwMDApIHwgMCk7XG4gICAgICB0aGlzLndvcmRzW2kgKyBzaGlmdF0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgaSA8IHRoaXMubGVuZ3RoIC0gc2hpZnQ7IGkrKykge1xuICAgICAgdyA9ICh0aGlzLndvcmRzW2kgKyBzaGlmdF0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICBpZiAoY2FycnkgPT09IDApIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuXG4gICAgLy8gU3VidHJhY3Rpb24gb3ZlcmZsb3dcbiAgICBhc3NlcnQoY2FycnkgPT09IC0xKTtcbiAgICBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAtKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl93b3JkRGl2ID0gZnVuY3Rpb24gX3dvcmREaXYgKG51bSwgbW9kZSkge1xuICAgIHZhciBzaGlmdCA9IHRoaXMubGVuZ3RoIC0gbnVtLmxlbmd0aDtcblxuICAgIHZhciBhID0gdGhpcy5jbG9uZSgpO1xuICAgIHZhciBiID0gbnVtO1xuXG4gICAgLy8gTm9ybWFsaXplXG4gICAgdmFyIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gICAgdmFyIGJoaUJpdHMgPSB0aGlzLl9jb3VudEJpdHMoYmhpKTtcbiAgICBzaGlmdCA9IDI2IC0gYmhpQml0cztcbiAgICBpZiAoc2hpZnQgIT09IDApIHtcbiAgICAgIGIgPSBiLnVzaGxuKHNoaWZ0KTtcbiAgICAgIGEuaXVzaGxuKHNoaWZ0KTtcbiAgICAgIGJoaSA9IGIud29yZHNbYi5sZW5ndGggLSAxXSB8IDA7XG4gICAgfVxuXG4gICAgLy8gSW5pdGlhbGl6ZSBxdW90aWVudFxuICAgIHZhciBtID0gYS5sZW5ndGggLSBiLmxlbmd0aDtcbiAgICB2YXIgcTtcblxuICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgcSA9IG5ldyBCTihudWxsKTtcbiAgICAgIHEubGVuZ3RoID0gbSArIDE7XG4gICAgICBxLndvcmRzID0gbmV3IEFycmF5KHEubGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcS5sZW5ndGg7IGkrKykge1xuICAgICAgICBxLndvcmRzW2ldID0gMDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGlmZiA9IGEuY2xvbmUoKS5faXNobG5zdWJtdWwoYiwgMSwgbSk7XG4gICAgaWYgKGRpZmYubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIGEgPSBkaWZmO1xuICAgICAgaWYgKHEpIHtcbiAgICAgICAgcS53b3Jkc1ttXSA9IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IG0gLSAxOyBqID49IDA7IGotLSkge1xuICAgICAgdmFyIHFqID0gKGEud29yZHNbYi5sZW5ndGggKyBqXSB8IDApICogMHg0MDAwMDAwICtcbiAgICAgICAgKGEud29yZHNbYi5sZW5ndGggKyBqIC0gMV0gfCAwKTtcblxuICAgICAgLy8gTk9URTogKHFqIC8gYmhpKSBpcyAoMHgzZmZmZmZmICogMHg0MDAwMDAwICsgMHgzZmZmZmZmKSAvIDB4MjAwMDAwMCBtYXhcbiAgICAgIC8vICgweDdmZmZmZmYpXG4gICAgICBxaiA9IE1hdGgubWluKChxaiAvIGJoaSkgfCAwLCAweDNmZmZmZmYpO1xuXG4gICAgICBhLl9pc2hsbnN1Ym11bChiLCBxaiwgaik7XG4gICAgICB3aGlsZSAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBxai0tO1xuICAgICAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICAgICAgYS5faXNobG5zdWJtdWwoYiwgMSwgaik7XG4gICAgICAgIGlmICghYS5pc1plcm8oKSkge1xuICAgICAgICAgIGEubmVnYXRpdmUgXj0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHEpIHtcbiAgICAgICAgcS53b3Jkc1tqXSA9IHFqO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocSkge1xuICAgICAgcS5fc3RyaXAoKTtcbiAgICB9XG4gICAgYS5fc3RyaXAoKTtcblxuICAgIC8vIERlbm9ybWFsaXplXG4gICAgaWYgKG1vZGUgIT09ICdkaXYnICYmIHNoaWZ0ICE9PSAwKSB7XG4gICAgICBhLml1c2hybihzaGlmdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpdjogcSB8fCBudWxsLFxuICAgICAgbW9kOiBhXG4gICAgfTtcbiAgfTtcblxuICAvLyBOT1RFOiAxKSBgbW9kZWAgY2FuIGJlIHNldCB0byBgbW9kYCB0byByZXF1ZXN0IG1vZCBvbmx5LFxuICAvLyAgICAgICB0byBgZGl2YCB0byByZXF1ZXN0IGRpdiBvbmx5LCBvciBiZSBhYnNlbnQgdG9cbiAgLy8gICAgICAgcmVxdWVzdCBib3RoIGRpdiAmIG1vZFxuICAvLyAgICAgICAyKSBgcG9zaXRpdmVgIGlzIHRydWUgaWYgdW5zaWduZWQgbW9kIGlzIHJlcXVlc3RlZFxuICBCTi5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gZGl2bW9kIChudW0sIG1vZGUsIHBvc2l0aXZlKSB7XG4gICAgYXNzZXJ0KCFudW0uaXNaZXJvKCkpO1xuXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IG5ldyBCTigwKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGl2LCBtb2QsIHJlcztcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pYWRkKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IHJlcy5tb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCh0aGlzLm5lZ2F0aXZlICYgbnVtLm5lZ2F0aXZlKSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaXN1YihudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogcmVzLmRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZSBhdCB0aGlzIHBvaW50XG5cbiAgICAvLyBTdHJpcCBib3RoIG51bWJlcnMgdG8gYXBwcm94aW1hdGUgc2hpZnQgdmFsdWVcbiAgICBpZiAobnVtLmxlbmd0aCA+IHRoaXMubGVuZ3RoIHx8IHRoaXMuY21wKG51bSkgPCAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiB0aGlzXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFZlcnkgc2hvcnQgcmVkdWN0aW9uXG4gICAgaWYgKG51bS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChtb2RlID09PSAnZGl2Jykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgICAgbW9kOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlID09PSAnbW9kJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogbnVsbCxcbiAgICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZHJuKG51bS53b3Jkc1swXSkpXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgIG1vZDogbmV3IEJOKHRoaXMubW9kcm4obnVtLndvcmRzWzBdKSlcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dvcmREaXYobnVtLCBtb2RlKTtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAvIGBudW1gXG4gIEJOLnByb3RvdHlwZS5kaXYgPSBmdW5jdGlvbiBkaXYgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdkaXYnLCBmYWxzZSkuZGl2O1xuICB9O1xuXG4gIC8vIEZpbmQgYHRoaXNgICUgYG51bWBcbiAgQk4ucHJvdG90eXBlLm1vZCA9IGZ1bmN0aW9uIG1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIGZhbHNlKS5tb2Q7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVtb2QgPSBmdW5jdGlvbiB1bW9kIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnbW9kJywgdHJ1ZSkubW9kO1xuICB9O1xuXG4gIC8vIEZpbmQgUm91bmQoYHRoaXNgIC8gYG51bWApXG4gIEJOLnByb3RvdHlwZS5kaXZSb3VuZCA9IGZ1bmN0aW9uIGRpdlJvdW5kIChudW0pIHtcbiAgICB2YXIgZG0gPSB0aGlzLmRpdm1vZChudW0pO1xuXG4gICAgLy8gRmFzdCBjYXNlIC0gZXhhY3QgZGl2aXNpb25cbiAgICBpZiAoZG0ubW9kLmlzWmVybygpKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgdmFyIG1vZCA9IGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLm1vZC5pc3ViKG51bSkgOiBkbS5tb2Q7XG5cbiAgICB2YXIgaGFsZiA9IG51bS51c2hybigxKTtcbiAgICB2YXIgcjIgPSBudW0uYW5kbG4oMSk7XG4gICAgdmFyIGNtcCA9IG1vZC5jbXAoaGFsZik7XG5cbiAgICAvLyBSb3VuZCBkb3duXG4gICAgaWYgKGNtcCA8IDAgfHwgKHIyID09PSAxICYmIGNtcCA9PT0gMCkpIHJldHVybiBkbS5kaXY7XG5cbiAgICAvLyBSb3VuZCB1cFxuICAgIHJldHVybiBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5kaXYuaXN1Ym4oMSkgOiBkbS5kaXYuaWFkZG4oMSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm1vZHJuID0gZnVuY3Rpb24gbW9kcm4gKG51bSkge1xuICAgIHZhciBpc05lZ051bSA9IG51bSA8IDA7XG4gICAgaWYgKGlzTmVnTnVtKSBudW0gPSAtbnVtO1xuXG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuICAgIHZhciBwID0gKDEgPDwgMjYpICUgbnVtO1xuXG4gICAgdmFyIGFjYyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGFjYyA9IChwICogYWNjICsgKHRoaXMud29yZHNbaV0gfCAwKSkgJSBudW07XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzTmVnTnVtID8gLWFjYyA6IGFjYztcbiAgfTtcblxuICAvLyBXQVJOSU5HOiBERVBSRUNBVEVEXG4gIEJOLnByb3RvdHlwZS5tb2RuID0gZnVuY3Rpb24gbW9kbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMubW9kcm4obnVtKTtcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBkaXZpc2lvbiBieSBudW1iZXJcbiAgQk4ucHJvdG90eXBlLmlkaXZuID0gZnVuY3Rpb24gaWRpdm4gKG51bSkge1xuICAgIHZhciBpc05lZ051bSA9IG51bSA8IDA7XG4gICAgaWYgKGlzTmVnTnVtKSBudW0gPSAtbnVtO1xuXG4gICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYpO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIHcgPSAodGhpcy53b3Jkc1tpXSB8IDApICsgY2FycnkgKiAweDQwMDAwMDA7XG4gICAgICB0aGlzLndvcmRzW2ldID0gKHcgLyBudW0pIHwgMDtcbiAgICAgIGNhcnJ5ID0gdyAlIG51bTtcbiAgICB9XG5cbiAgICB0aGlzLl9zdHJpcCgpO1xuICAgIHJldHVybiBpc05lZ051bSA/IHRoaXMuaW5lZygpIDogdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZGl2biA9IGZ1bmN0aW9uIGRpdm4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWRpdm4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZWdjZCA9IGZ1bmN0aW9uIGVnY2QgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciB4ID0gdGhpcztcbiAgICB2YXIgeSA9IHAuY2xvbmUoKTtcblxuICAgIGlmICh4Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB4ID0geC51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geC5jbG9uZSgpO1xuICAgIH1cblxuICAgIC8vIEEgKiB4ICsgQiAqIHkgPSB4XG4gICAgdmFyIEEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIEIgPSBuZXcgQk4oMCk7XG5cbiAgICAvLyBDICogeCArIEQgKiB5ID0geVxuICAgIHZhciBDID0gbmV3IEJOKDApO1xuICAgIHZhciBEID0gbmV3IEJOKDEpO1xuXG4gICAgdmFyIGcgPSAwO1xuXG4gICAgd2hpbGUgKHguaXNFdmVuKCkgJiYgeS5pc0V2ZW4oKSkge1xuICAgICAgeC5pdXNocm4oMSk7XG4gICAgICB5Lml1c2hybigxKTtcbiAgICAgICsrZztcbiAgICB9XG5cbiAgICB2YXIgeXAgPSB5LmNsb25lKCk7XG4gICAgdmFyIHhwID0geC5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKCF4LmlzWmVybygpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoeC53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIHguaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmIChBLmlzT2RkKCkgfHwgQi5pc09kZCgpKSB7XG4gICAgICAgICAgICBBLmlhZGQoeXApO1xuICAgICAgICAgICAgQi5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBBLml1c2hybigxKTtcbiAgICAgICAgICBCLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBqID0gMCwgam0gPSAxOyAoeS53b3Jkc1swXSAmIGptKSA9PT0gMCAmJiBqIDwgMjY7ICsraiwgam0gPDw9IDEpO1xuICAgICAgaWYgKGogPiAwKSB7XG4gICAgICAgIHkuaXVzaHJuKGopO1xuICAgICAgICB3aGlsZSAoai0tID4gMCkge1xuICAgICAgICAgIGlmIChDLmlzT2RkKCkgfHwgRC5pc09kZCgpKSB7XG4gICAgICAgICAgICBDLmlhZGQoeXApO1xuICAgICAgICAgICAgRC5pc3ViKHhwKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBDLml1c2hybigxKTtcbiAgICAgICAgICBELml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoeC5jbXAoeSkgPj0gMCkge1xuICAgICAgICB4LmlzdWIoeSk7XG4gICAgICAgIEEuaXN1YihDKTtcbiAgICAgICAgQi5pc3ViKEQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeS5pc3ViKHgpO1xuICAgICAgICBDLmlzdWIoQSk7XG4gICAgICAgIEQuaXN1YihCKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgYTogQyxcbiAgICAgIGI6IEQsXG4gICAgICBnY2Q6IHkuaXVzaGxuKGcpXG4gICAgfTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIHJlZHVjZWQgaW5jYXJuYXRpb24gb2YgdGhlIGJpbmFyeSBFRUFcbiAgLy8gYWJvdmUsIGRlc2lnbmF0ZWQgdG8gaW52ZXJ0IG1lbWJlcnMgb2YgdGhlXG4gIC8vIF9wcmltZV8gZmllbGRzIEYocCkgYXQgYSBtYXhpbWFsIHNwZWVkXG4gIEJOLnByb3RvdHlwZS5faW52bXAgPSBmdW5jdGlvbiBfaW52bXAgKHApIHtcbiAgICBhc3NlcnQocC5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgYXNzZXJ0KCFwLmlzWmVybygpKTtcblxuICAgIHZhciBhID0gdGhpcztcbiAgICB2YXIgYiA9IHAuY2xvbmUoKTtcblxuICAgIGlmIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBhID0gYS51bW9kKHApO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHZhciB4MSA9IG5ldyBCTigxKTtcbiAgICB2YXIgeDIgPSBuZXcgQk4oMCk7XG5cbiAgICB2YXIgZGVsdGEgPSBiLmNsb25lKCk7XG5cbiAgICB3aGlsZSAoYS5jbXBuKDEpID4gMCAmJiBiLmNtcG4oMSkgPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMCwgaW0gPSAxOyAoYS53b3Jkc1swXSAmIGltKSA9PT0gMCAmJiBpIDwgMjY7ICsraSwgaW0gPDw9IDEpO1xuICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgIGEuaXVzaHJuKGkpO1xuICAgICAgICB3aGlsZSAoaS0tID4gMCkge1xuICAgICAgICAgIGlmICh4MS5pc09kZCgpKSB7XG4gICAgICAgICAgICB4MS5pYWRkKGRlbHRhKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB4MS5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKGIud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICBiLml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDIuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDIuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDIuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChhLmNtcChiKSA+PSAwKSB7XG4gICAgICAgIGEuaXN1YihiKTtcbiAgICAgICAgeDEuaXN1Yih4Mik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiLmlzdWIoYSk7XG4gICAgICAgIHgyLmlzdWIoeDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXM7XG4gICAgaWYgKGEuY21wbigxKSA9PT0gMCkge1xuICAgICAgcmVzID0geDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IHgyO1xuICAgIH1cblxuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHApO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmdjZCA9IGZ1bmN0aW9uIGdjZCAobnVtKSB7XG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHJldHVybiBudW0uYWJzKCk7XG4gICAgaWYgKG51bS5pc1plcm8oKSkgcmV0dXJuIHRoaXMuYWJzKCk7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bS5jbG9uZSgpO1xuICAgIGEubmVnYXRpdmUgPSAwO1xuICAgIGIubmVnYXRpdmUgPSAwO1xuXG4gICAgLy8gUmVtb3ZlIGNvbW1vbiBmYWN0b3Igb2YgdHdvXG4gICAgZm9yICh2YXIgc2hpZnQgPSAwOyBhLmlzRXZlbigpICYmIGIuaXNFdmVuKCk7IHNoaWZ0KyspIHtcbiAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgYi5pdXNocm4oMSk7XG4gICAgfVxuXG4gICAgZG8ge1xuICAgICAgd2hpbGUgKGEuaXNFdmVuKCkpIHtcbiAgICAgICAgYS5pdXNocm4oMSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoYi5pc0V2ZW4oKSkge1xuICAgICAgICBiLml1c2hybigxKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHIgPSBhLmNtcChiKTtcbiAgICAgIGlmIChyIDwgMCkge1xuICAgICAgICAvLyBTd2FwIGBhYCBhbmQgYGJgIHRvIG1ha2UgYGFgIGFsd2F5cyBiaWdnZXIgdGhhbiBgYmBcbiAgICAgICAgdmFyIHQgPSBhO1xuICAgICAgICBhID0gYjtcbiAgICAgICAgYiA9IHQ7XG4gICAgICB9IGVsc2UgaWYgKHIgPT09IDAgfHwgYi5jbXBuKDEpID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBhLmlzdWIoYik7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICByZXR1cm4gYi5pdXNobG4oc2hpZnQpO1xuICB9O1xuXG4gIC8vIEludmVydCBudW1iZXIgaW4gdGhlIGZpZWxkIEYobnVtKVxuICBCTi5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmVnY2QobnVtKS5hLnVtb2QobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNFdmVuID0gZnVuY3Rpb24gaXNFdmVuICgpIHtcbiAgICByZXR1cm4gKHRoaXMud29yZHNbMF0gJiAxKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNPZGQgPSBmdW5jdGlvbiBpc09kZCAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDE7XG4gIH07XG5cbiAgLy8gQW5kIGZpcnN0IHdvcmQgYW5kIG51bVxuICBCTi5wcm90b3R5cGUuYW5kbG4gPSBmdW5jdGlvbiBhbmRsbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMud29yZHNbMF0gJiBudW07XG4gIH07XG5cbiAgLy8gSW5jcmVtZW50IGF0IHRoZSBiaXQgcG9zaXRpb24gaW4tbGluZVxuICBCTi5wcm90b3R5cGUuYmluY24gPSBmdW5jdGlvbiBiaW5jbiAoYml0KSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInKTtcbiAgICB2YXIgciA9IGJpdCAlIDI2O1xuICAgIHZhciBzID0gKGJpdCAtIHIpIC8gMjY7XG4gICAgdmFyIHEgPSAxIDw8IHI7XG5cbiAgICAvLyBGYXN0IGNhc2U6IGJpdCBpcyBtdWNoIGhpZ2hlciB0aGFuIGFsbCBleGlzdGluZyB3b3Jkc1xuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICB0aGlzLl9leHBhbmQocyArIDEpO1xuICAgICAgdGhpcy53b3Jkc1tzXSB8PSBxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIGJpdCBhbmQgcHJvcGFnYXRlLCBpZiBuZWVkZWRcbiAgICB2YXIgY2FycnkgPSBxO1xuICAgIGZvciAodmFyIGkgPSBzOyBjYXJyeSAhPT0gMCAmJiBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHcgKz0gY2Fycnk7XG4gICAgICBjYXJyeSA9IHcgPj4+IDI2O1xuICAgICAgdyAmPSAweDNmZmZmZmY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdztcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNaZXJvID0gZnVuY3Rpb24gaXNaZXJvICgpIHtcbiAgICByZXR1cm4gdGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY21wbiA9IGZ1bmN0aW9uIGNtcG4gKG51bSkge1xuICAgIHZhciBuZWdhdGl2ZSA9IG51bSA8IDA7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiAhbmVnYXRpdmUpIHJldHVybiAtMTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBuZWdhdGl2ZSkgcmV0dXJuIDE7XG5cbiAgICB0aGlzLl9zdHJpcCgpO1xuXG4gICAgdmFyIHJlcztcbiAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgbnVtID0gLW51bTtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYsICdOdW1iZXIgaXMgdG9vIGJpZycpO1xuXG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbMF0gfCAwO1xuICAgICAgcmVzID0gdyA9PT0gbnVtID8gMCA6IHcgPCBudW0gPyAtMSA6IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb21wYXJlIHR3byBudW1iZXJzIGFuZCByZXR1cm46XG4gIC8vIDEgLSBpZiBgdGhpc2AgPiBgbnVtYFxuICAvLyAwIC0gaWYgYHRoaXNgID09IGBudW1gXG4gIC8vIC0xIC0gaWYgYHRoaXNgIDwgYG51bWBcbiAgQk4ucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uIGNtcCAobnVtKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gMTtcblxuICAgIHZhciByZXMgPSB0aGlzLnVjbXAobnVtKTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gVW5zaWduZWQgY29tcGFyaXNvblxuICBCTi5wcm90b3R5cGUudWNtcCA9IGZ1bmN0aW9uIHVjbXAgKG51bSkge1xuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGhhdmUgdGhlIHNhbWUgc2lnblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiAxO1xuICAgIGlmICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHJldHVybiAtMTtcblxuICAgIHZhciByZXMgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYSA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdmFyIGIgPSBudW0ud29yZHNbaV0gfCAwO1xuXG4gICAgICBpZiAoYSA9PT0gYikgY29udGludWU7XG4gICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmVzID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJlcyA9IDE7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RuID0gZnVuY3Rpb24gZ3RuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gZ3QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGVuID0gZnVuY3Rpb24gZ3RlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZSA9IGZ1bmN0aW9uIGd0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRuID0gZnVuY3Rpb24gbHRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdCA9IGZ1bmN0aW9uIGx0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZW4gPSBmdW5jdGlvbiBsdGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlID0gZnVuY3Rpb24gbHRlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcW4gPSBmdW5jdGlvbiBlcW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDA7XG4gIH07XG5cbiAgLy9cbiAgLy8gQSByZWR1Y2UgY29udGV4dCwgY291bGQgYmUgdXNpbmcgbW9udGdvbWVyeSBvciBzb21ldGhpbmcgYmV0dGVyLCBkZXBlbmRpbmdcbiAgLy8gb24gdGhlIGBtYCBpdHNlbGYuXG4gIC8vXG4gIEJOLnJlZCA9IGZ1bmN0aW9uIHJlZCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBSZWQobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9SZWQgPSBmdW5jdGlvbiB0b1JlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgcmV0dXJuIGN0eC5jb252ZXJ0VG8odGhpcykuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21SZWQgPSBmdW5jdGlvbiBmcm9tUmVkICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmNvbnZlcnRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbiBfZm9yY2VSZWQgKGN0eCkge1xuICAgIHRoaXMucmVkID0gY3R4O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mb3JjZVJlZCA9IGZ1bmN0aW9uIGZvcmNlUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRBZGQgPSBmdW5jdGlvbiByZWRBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbiByZWRJQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFN1YiA9IGZ1bmN0aW9uIHJlZFN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uIHJlZElTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU2hsID0gZnVuY3Rpb24gcmVkU2hsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNobCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbiByZWRNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5tdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSU11bCA9IGZ1bmN0aW9uIHJlZElNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNxciA9IGZ1bmN0aW9uIHJlZFNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXIodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTcXIgPSBmdW5jdGlvbiByZWRJU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3FyKHRoaXMpO1xuICB9O1xuXG4gIC8vIFNxdWFyZSByb290IG92ZXIgcFxuICBCTi5wcm90b3R5cGUucmVkU3FydCA9IGZ1bmN0aW9uIHJlZFNxcnQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcnQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEludm0gPSBmdW5jdGlvbiByZWRJbnZtICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbnZtKHRoaXMpO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2AgJSBgcmVkIG1vZHVsb2BcbiAgQk4ucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uIHJlZE5lZyAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5uZWcodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFBvdyA9IGZ1bmN0aW9uIHJlZFBvdyAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkICYmICFudW0ucmVkLCAncmVkUG93KG5vcm1hbE51bSknKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQucG93KHRoaXMsIG51bSk7XG4gIH07XG5cbiAgLy8gUHJpbWUgbnVtYmVycyB3aXRoIGVmZmljaWVudCByZWR1Y3Rpb25cbiAgdmFyIHByaW1lcyA9IHtcbiAgICBrMjU2OiBudWxsLFxuICAgIHAyMjQ6IG51bGwsXG4gICAgcDE5MjogbnVsbCxcbiAgICBwMjU1MTk6IG51bGxcbiAgfTtcblxuICAvLyBQc2V1ZG8tTWVyc2VubmUgcHJpbWVcbiAgZnVuY3Rpb24gTVByaW1lIChuYW1lLCBwKSB7XG4gICAgLy8gUCA9IDIgXiBOIC0gS1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wID0gbmV3IEJOKHAsIDE2KTtcbiAgICB0aGlzLm4gPSB0aGlzLnAuYml0TGVuZ3RoKCk7XG4gICAgdGhpcy5rID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLm4pLmlzdWIodGhpcy5wKTtcblxuICAgIHRoaXMudG1wID0gdGhpcy5fdG1wKCk7XG4gIH1cblxuICBNUHJpbWUucHJvdG90eXBlLl90bXAgPSBmdW5jdGlvbiBfdG1wICgpIHtcbiAgICB2YXIgdG1wID0gbmV3IEJOKG51bGwpO1xuICAgIHRtcC53b3JkcyA9IG5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uIC8gMTMpKTtcbiAgICByZXR1cm4gdG1wO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaXJlZHVjZSA9IGZ1bmN0aW9uIGlyZWR1Y2UgKG51bSkge1xuICAgIC8vIEFzc3VtZXMgdGhhdCBgbnVtYCBpcyBsZXNzIHRoYW4gYFBeMmBcbiAgICAvLyBudW0gPSBISSAqICgyIF4gTiAtIEspICsgSEkgKiBLICsgTE8gPSBISSAqIEsgKyBMTyAobW9kIFApXG4gICAgdmFyIHIgPSBudW07XG4gICAgdmFyIHJsZW47XG5cbiAgICBkbyB7XG4gICAgICB0aGlzLnNwbGl0KHIsIHRoaXMudG1wKTtcbiAgICAgIHIgPSB0aGlzLmltdWxLKHIpO1xuICAgICAgciA9IHIuaWFkZCh0aGlzLnRtcCk7XG4gICAgICBybGVuID0gci5iaXRMZW5ndGgoKTtcbiAgICB9IHdoaWxlIChybGVuID4gdGhpcy5uKTtcblxuICAgIHZhciBjbXAgPSBybGVuIDwgdGhpcy5uID8gLTEgOiByLnVjbXAodGhpcy5wKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICByLndvcmRzWzBdID0gMDtcbiAgICAgIHIubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIHIuaXN1Yih0aGlzLnApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoci5zdHJpcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHIgaXMgYSBCTiB2NCBpbnN0YW5jZVxuICAgICAgICByLnN0cmlwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByIGlzIGEgQk4gdjUgaW5zdGFuY2VcbiAgICAgICAgci5fc3RyaXAoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXQpIHtcbiAgICBpbnB1dC5pdXNocm4odGhpcy5uLCAwLCBvdXQpO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgcmV0dXJuIG51bS5pbXVsKHRoaXMuayk7XG4gIH07XG5cbiAgZnVuY3Rpb24gSzI1NiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ2syNTYnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmYzJmJyk7XG4gIH1cbiAgaW5oZXJpdHMoSzI1NiwgTVByaW1lKTtcblxuICBLMjU2LnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0cHV0KSB7XG4gICAgLy8gMjU2ID0gOSAqIDI2ICsgMjJcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmO1xuXG4gICAgdmFyIG91dExlbiA9IE1hdGgubWluKGlucHV0Lmxlbmd0aCwgOSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBvdXRMZW47IGkrKykge1xuICAgICAgb3V0cHV0LndvcmRzW2ldID0gaW5wdXQud29yZHNbaV07XG4gICAgfVxuICAgIG91dHB1dC5sZW5ndGggPSBvdXRMZW47XG5cbiAgICBpZiAoaW5wdXQubGVuZ3RoIDw9IDkpIHtcbiAgICAgIGlucHV0LndvcmRzWzBdID0gMDtcbiAgICAgIGlucHV0Lmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gU2hpZnQgYnkgOSBsaW1ic1xuICAgIHZhciBwcmV2ID0gaW5wdXQud29yZHNbOV07XG4gICAgb3V0cHV0LndvcmRzW291dHB1dC5sZW5ndGgrK10gPSBwcmV2ICYgbWFzaztcblxuICAgIGZvciAoaSA9IDEwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBuZXh0ID0gaW5wdXQud29yZHNbaV0gfCAwO1xuICAgICAgaW5wdXQud29yZHNbaSAtIDEwXSA9ICgobmV4dCAmIG1hc2spIDw8IDQpIHwgKHByZXYgPj4+IDIyKTtcbiAgICAgIHByZXYgPSBuZXh0O1xuICAgIH1cbiAgICBwcmV2ID4+Pj0gMjI7XG4gICAgaW5wdXQud29yZHNbaSAtIDEwXSA9IHByZXY7XG4gICAgaWYgKHByZXYgPT09IDAgJiYgaW5wdXQubGVuZ3RoID4gMTApIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSAxMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDk7XG4gICAgfVxuICB9O1xuXG4gIEsyNTYucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEwMDAwMDNkMSA9IFsgMHg0MCwgMHgzZDEgXVxuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoXSA9IDA7XG4gICAgbnVtLndvcmRzW251bS5sZW5ndGggKyAxXSA9IDA7XG4gICAgbnVtLmxlbmd0aCArPSAyO1xuXG4gICAgLy8gYm91bmRlZCBhdDogMHg0MCAqIDB4M2ZmZmZmZiArIDB4M2QwID0gMHgxMDAwMDAzOTBcbiAgICB2YXIgbG8gPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdyA9IG51bS53b3Jkc1tpXSB8IDA7XG4gICAgICBsbyArPSB3ICogMHgzZDE7XG4gICAgICBudW0ud29yZHNbaV0gPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgIGxvID0gdyAqIDB4NDAgKyAoKGxvIC8gMHg0MDAwMDAwKSB8IDApO1xuICAgIH1cblxuICAgIC8vIEZhc3QgbGVuZ3RoIHJlZHVjdGlvblxuICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICBudW0ubGVuZ3RoLS07XG4gICAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgICBudW0ubGVuZ3RoLS07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgZnVuY3Rpb24gUDIyNCAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AyMjQnLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDIyNCwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMTkyICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDE5MicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZmZmYgZmZmZmZmZmYnKTtcbiAgfVxuICBpbmhlcml0cyhQMTkyLCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAyNTUxOSAoKSB7XG4gICAgLy8gMiBeIDI1NSAtIDE5XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJzI1NTE5JyxcbiAgICAgICc3ZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmVkJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDI1NTE5LCBNUHJpbWUpO1xuXG4gIFAyNTUxOS5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTNcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGkgPSAobnVtLndvcmRzW2ldIHwgMCkgKiAweDEzICsgY2Fycnk7XG4gICAgICB2YXIgbG8gPSBoaSAmIDB4M2ZmZmZmZjtcbiAgICAgIGhpID4+Pj0gMjY7XG5cbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvO1xuICAgICAgY2FycnkgPSBoaTtcbiAgICB9XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICBudW0ud29yZHNbbnVtLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIC8vIEV4cG9ydGVkIG1vc3RseSBmb3IgdGVzdGluZyBwdXJwb3NlcywgdXNlIHBsYWluIG5hbWUgaW5zdGVhZFxuICBCTi5fcHJpbWUgPSBmdW5jdGlvbiBwcmltZSAobmFtZSkge1xuICAgIC8vIENhY2hlZCB2ZXJzaW9uIG9mIHByaW1lXG4gICAgaWYgKHByaW1lc1tuYW1lXSkgcmV0dXJuIHByaW1lc1tuYW1lXTtcblxuICAgIHZhciBwcmltZTtcbiAgICBpZiAobmFtZSA9PT0gJ2syNTYnKSB7XG4gICAgICBwcmltZSA9IG5ldyBLMjU2KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDIyNCcpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyMjQoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMTkyJykge1xuICAgICAgcHJpbWUgPSBuZXcgUDE5MigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyNTUxOScpIHtcbiAgICAgIHByaW1lID0gbmV3IFAyNTUxOSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcHJpbWUgJyArIG5hbWUpO1xuICAgIH1cbiAgICBwcmltZXNbbmFtZV0gPSBwcmltZTtcblxuICAgIHJldHVybiBwcmltZTtcbiAgfTtcblxuICAvL1xuICAvLyBCYXNlIHJlZHVjdGlvbiBlbmdpbmVcbiAgLy9cbiAgZnVuY3Rpb24gUmVkIChtKSB7XG4gICAgaWYgKHR5cGVvZiBtID09PSAnc3RyaW5nJykge1xuICAgICAgdmFyIHByaW1lID0gQk4uX3ByaW1lKG0pO1xuICAgICAgdGhpcy5tID0gcHJpbWUucDtcbiAgICAgIHRoaXMucHJpbWUgPSBwcmltZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG0uZ3RuKDEpLCAnbW9kdWx1cyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxJyk7XG4gICAgICB0aGlzLm0gPSBtO1xuICAgICAgdGhpcy5wcmltZSA9IG51bGw7XG4gICAgfVxuICB9XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MSA9IGZ1bmN0aW9uIF92ZXJpZnkxIChhKSB7XG4gICAgYXNzZXJ0KGEubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkyID0gZnVuY3Rpb24gX3ZlcmlmeTIgKGEsIGIpIHtcbiAgICBhc3NlcnQoKGEubmVnYXRpdmUgfCBiLm5lZ2F0aXZlKSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkICYmIGEucmVkID09PSBiLnJlZCxcbiAgICAgICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbW9kID0gZnVuY3Rpb24gaW1vZCAoYSkge1xuICAgIGlmICh0aGlzLnByaW1lKSByZXR1cm4gdGhpcy5wcmltZS5pcmVkdWNlKGEpLl9mb3JjZVJlZCh0aGlzKTtcblxuICAgIG1vdmUoYSwgYS51bW9kKHRoaXMubSkuX2ZvcmNlUmVkKHRoaXMpKTtcbiAgICByZXR1cm4gYTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoYSkge1xuICAgIGlmIChhLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4gYS5jbG9uZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLm0uc3ViKGEpLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5hZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlhZGQoYik7XG4gICAgaWYgKHJlcy5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMuaXN1Yih0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24gc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLnN1YihiKTtcbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZCh0aGlzLm0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcblxuICAgIHZhciByZXMgPSBhLmlzdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNobCA9IGZ1bmN0aW9uIHNobCAoYSwgbnVtKSB7XG4gICAgdGhpcy5fdmVyaWZ5MShhKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEudXNobG4obnVtKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLmltdWwoYikpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChhLCBiKSB7XG4gICAgdGhpcy5fdmVyaWZ5MihhLCBiKTtcbiAgICByZXR1cm4gdGhpcy5pbW9kKGEubXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMuaW11bChhLCBhLmNsb25lKCkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FyID0gZnVuY3Rpb24gc3FyIChhKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKGEsIGEpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuc3FydCA9IGZ1bmN0aW9uIHNxcnQgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciBtb2QzID0gdGhpcy5tLmFuZGxuKDMpO1xuICAgIGFzc2VydChtb2QzICUgMiA9PT0gMSk7XG5cbiAgICAvLyBGYXN0IGNhc2VcbiAgICBpZiAobW9kMyA9PT0gMykge1xuICAgICAgdmFyIHBvdyA9IHRoaXMubS5hZGQobmV3IEJOKDEpKS5pdXNocm4oMik7XG4gICAgICByZXR1cm4gdGhpcy5wb3coYSwgcG93KTtcbiAgICB9XG5cbiAgICAvLyBUb25lbGxpLVNoYW5rcyBhbGdvcml0aG0gKFRvdGFsbHkgdW5vcHRpbWl6ZWQgYW5kIHNsb3cpXG4gICAgLy9cbiAgICAvLyBGaW5kIFEgYW5kIFMsIHRoYXQgUSAqIDIgXiBTID0gKFAgLSAxKVxuICAgIHZhciBxID0gdGhpcy5tLnN1Ym4oMSk7XG4gICAgdmFyIHMgPSAwO1xuICAgIHdoaWxlICghcS5pc1plcm8oKSAmJiBxLmFuZGxuKDEpID09PSAwKSB7XG4gICAgICBzKys7XG4gICAgICBxLml1c2hybigxKTtcbiAgICB9XG4gICAgYXNzZXJ0KCFxLmlzWmVybygpKTtcblxuICAgIHZhciBvbmUgPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgdmFyIG5PbmUgPSBvbmUucmVkTmVnKCk7XG5cbiAgICAvLyBGaW5kIHF1YWRyYXRpYyBub24tcmVzaWR1ZVxuICAgIC8vIE5PVEU6IE1heCBpcyBzdWNoIGJlY2F1c2Ugb2YgZ2VuZXJhbGl6ZWQgUmllbWFubiBoeXBvdGhlc2lzLlxuICAgIHZhciBscG93ID0gdGhpcy5tLnN1Ym4oMSkuaXVzaHJuKDEpO1xuICAgIHZhciB6ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIHogPSBuZXcgQk4oMiAqIHogKiB6KS50b1JlZCh0aGlzKTtcblxuICAgIHdoaWxlICh0aGlzLnBvdyh6LCBscG93KS5jbXAobk9uZSkgIT09IDApIHtcbiAgICAgIHoucmVkSUFkZChuT25lKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHRoaXMucG93KHosIHEpO1xuICAgIHZhciByID0gdGhpcy5wb3coYSwgcS5hZGRuKDEpLml1c2hybigxKSk7XG4gICAgdmFyIHQgPSB0aGlzLnBvdyhhLCBxKTtcbiAgICB2YXIgbSA9IHM7XG4gICAgd2hpbGUgKHQuY21wKG9uZSkgIT09IDApIHtcbiAgICAgIHZhciB0bXAgPSB0O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IHRtcC5jbXAob25lKSAhPT0gMDsgaSsrKSB7XG4gICAgICAgIHRtcCA9IHRtcC5yZWRTcXIoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydChpIDwgbSk7XG4gICAgICB2YXIgYiA9IHRoaXMucG93KGMsIG5ldyBCTigxKS5pdXNobG4obSAtIGkgLSAxKSk7XG5cbiAgICAgIHIgPSByLnJlZE11bChiKTtcbiAgICAgIGMgPSBiLnJlZFNxcigpO1xuICAgICAgdCA9IHQucmVkTXVsKGMpO1xuICAgICAgbSA9IGk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIHZhciBpbnYgPSBhLl9pbnZtcCh0aGlzLm0pO1xuICAgIGlmIChpbnYubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGludi5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludikucmVkTmVnKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLmltb2QoaW52KTtcbiAgICB9XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5wb3cgPSBmdW5jdGlvbiBwb3cgKGEsIG51bSkge1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgaWYgKG51bS5jbXBuKDEpID09PSAwKSByZXR1cm4gYS5jbG9uZSgpO1xuXG4gICAgdmFyIHdpbmRvd1NpemUgPSA0O1xuICAgIHZhciB3bmQgPSBuZXcgQXJyYXkoMSA8PCB3aW5kb3dTaXplKTtcbiAgICB3bmRbMF0gPSBuZXcgQk4oMSkudG9SZWQodGhpcyk7XG4gICAgd25kWzFdID0gYTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IHduZC5sZW5ndGg7IGkrKykge1xuICAgICAgd25kW2ldID0gdGhpcy5tdWwod25kW2kgLSAxXSwgYSk7XG4gICAgfVxuXG4gICAgdmFyIHJlcyA9IHduZFswXTtcbiAgICB2YXIgY3VycmVudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRMZW4gPSAwO1xuICAgIHZhciBzdGFydCA9IG51bS5iaXRMZW5ndGgoKSAlIDI2O1xuICAgIGlmIChzdGFydCA9PT0gMCkge1xuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSBudW0ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gbnVtLndvcmRzW2ldO1xuICAgICAgZm9yICh2YXIgaiA9IHN0YXJ0IC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgICAgdmFyIGJpdCA9ICh3b3JkID4+IGopICYgMTtcbiAgICAgICAgaWYgKHJlcyAhPT0gd25kWzBdKSB7XG4gICAgICAgICAgcmVzID0gdGhpcy5zcXIocmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiaXQgPT09IDAgJiYgY3VycmVudCA9PT0gMCkge1xuICAgICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudCA8PD0gMTtcbiAgICAgICAgY3VycmVudCB8PSBiaXQ7XG4gICAgICAgIGN1cnJlbnRMZW4rKztcbiAgICAgICAgaWYgKGN1cnJlbnRMZW4gIT09IHdpbmRvd1NpemUgJiYgKGkgIT09IDAgfHwgaiAhPT0gMCkpIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHRoaXMubXVsKHJlcywgd25kW2N1cnJlbnRdKTtcbiAgICAgICAgY3VycmVudExlbiA9IDA7XG4gICAgICAgIGN1cnJlbnQgPSAwO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSAyNjtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICB2YXIgciA9IG51bS51bW9kKHRoaXMubSk7XG5cbiAgICByZXR1cm4gciA9PT0gbnVtID8gci5jbG9uZSgpIDogcjtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRGcm9tID0gZnVuY3Rpb24gY29udmVydEZyb20gKG51bSkge1xuICAgIHZhciByZXMgPSBudW0uY2xvbmUoKTtcbiAgICByZXMucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vXG4gIC8vIE1vbnRnb21lcnkgbWV0aG9kIGVuZ2luZVxuICAvL1xuXG4gIEJOLm1vbnQgPSBmdW5jdGlvbiBtb250IChudW0pIHtcbiAgICByZXR1cm4gbmV3IE1vbnQobnVtKTtcbiAgfTtcblxuICBmdW5jdGlvbiBNb250IChtKSB7XG4gICAgUmVkLmNhbGwodGhpcywgbSk7XG5cbiAgICB0aGlzLnNoaWZ0ID0gdGhpcy5tLmJpdExlbmd0aCgpO1xuICAgIGlmICh0aGlzLnNoaWZ0ICUgMjYgIT09IDApIHtcbiAgICAgIHRoaXMuc2hpZnQgKz0gMjYgLSAodGhpcy5zaGlmdCAlIDI2KTtcbiAgICB9XG5cbiAgICB0aGlzLnIgPSBuZXcgQk4oMSkuaXVzaGxuKHRoaXMuc2hpZnQpO1xuICAgIHRoaXMucjIgPSB0aGlzLmltb2QodGhpcy5yLnNxcigpKTtcbiAgICB0aGlzLnJpbnYgPSB0aGlzLnIuX2ludm1wKHRoaXMubSk7XG5cbiAgICB0aGlzLm1pbnYgPSB0aGlzLnJpbnYubXVsKHRoaXMucikuaXN1Ym4oMSkuZGl2KHRoaXMubSk7XG4gICAgdGhpcy5taW52ID0gdGhpcy5taW52LnVtb2QodGhpcy5yKTtcbiAgICB0aGlzLm1pbnYgPSB0aGlzLnIuc3ViKHRoaXMubWludik7XG4gIH1cbiAgaW5oZXJpdHMoTW9udCwgUmVkKTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0VG8gPSBmdW5jdGlvbiBjb252ZXJ0VG8gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmltb2QobnVtLnVzaGxuKHRoaXMuc2hpZnQpKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgciA9IHRoaXMuaW1vZChudW0ubXVsKHRoaXMucmludikpO1xuICAgIHIucmVkID0gbnVsbDtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbXVsID0gZnVuY3Rpb24gaW11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHtcbiAgICAgIGEud29yZHNbMF0gPSAwO1xuICAgICAgYS5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuXG4gICAgdmFyIHQgPSBhLmltdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG5cbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIGlmIChhLmlzWmVybygpIHx8IGIuaXNaZXJvKCkpIHJldHVybiBuZXcgQk4oMCkuX2ZvcmNlUmVkKHRoaXMpO1xuXG4gICAgdmFyIHQgPSBhLm11bChiKTtcbiAgICB2YXIgYyA9IHQubWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubWludikuaW1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm0pO1xuICAgIHZhciB1ID0gdC5pc3ViKGMpLml1c2hybih0aGlzLnNoaWZ0KTtcbiAgICB2YXIgcmVzID0gdTtcbiAgICBpZiAodS5jbXAodGhpcy5tKSA+PSAwKSB7XG4gICAgICByZXMgPSB1LmlzdWIodGhpcy5tKTtcbiAgICB9IGVsc2UgaWYgKHUuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcyA9IHUuaWFkZCh0aGlzLm0pO1xuICAgIH1cblxuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xuXG4gIE1vbnQucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChhKSB7XG4gICAgLy8gKEFSKV4tMSAqIFJeMiA9IChBXi0xICogUl4tMSkgKiBSXjIgPSBBXi0xICogUlxuICAgIHZhciByZXMgPSB0aGlzLmltb2QoYS5faW52bXAodGhpcy5tKS5tdWwodGhpcy5yMikpO1xuICAgIHJldHVybiByZXMuX2ZvcmNlUmVkKHRoaXMpO1xuICB9O1xufSkodHlwZW9mIG1vZHVsZSA9PT0gJ3VuZGVmaW5lZCcgfHwgbW9kdWxlLCB0aGlzKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/bn.js/lib/bn.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/bs58/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/bs58/index.js ***!
  \*****************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var basex = __webpack_require__(/*! base-x */ \"(app-pages-browser)/./node_modules/base-x/src/index.js\")\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL2JzNTgvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUEsWUFBWSxtQkFBTyxDQUFDLHNFQUFRO0FBQzVCOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL2JzNTgvaW5kZXguanM/MjI3YiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgYmFzZXggPSByZXF1aXJlKCdiYXNlLXgnKVxudmFyIEFMUEhBQkVUID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZXgoQUxQSEFCRVQpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/bs58/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/base-x/src/index.js":
/*!******************************************!*\
  !*** ./node_modules/base-x/src/index.js ***!
  \******************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n// @ts-ignore\nvar _Buffer = (__webpack_require__(/*! safe-buffer */ \"(app-pages-browser)/./node_modules/safe-buffer/index.js\").Buffer)\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (Array.isArray(source) || source instanceof Uint8Array) { source = _Buffer.from(source) }\n    if (!_Buffer.isBuffer(source)) { throw new TypeError('Expected Buffer') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return _Buffer.alloc(0) }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = _Buffer.allocUnsafe(zeroes + (size - it4))\n    vch.fill(0x00, 0, zeroes)\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwR0FBNkI7QUFDM0M7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakUscUNBQXFDO0FBQ3JDLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDZDQUE2QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsWUFBWSxTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSwrQkFBK0IsNkNBQTZDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2Jhc2UteC9zcmMvaW5kZXguanM/YzQwNiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbi8vIGJhc2UteCBlbmNvZGluZyAvIGRlY29kaW5nXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTggYmFzZS14IGNvbnRyaWJ1dG9yc1xuLy8gQ29weXJpZ2h0IChjKSAyMDE0LTIwMTggVGhlIEJpdGNvaW4gQ29yZSBkZXZlbG9wZXJzIChiYXNlNTguY3BwKVxuLy8gRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBzb2Z0d2FyZSBsaWNlbnNlLCBzZWUgdGhlIGFjY29tcGFueWluZ1xuLy8gZmlsZSBMSUNFTlNFIG9yIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwLlxuLy8gQHRzLWlnbm9yZVxudmFyIF9CdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlclxuZnVuY3Rpb24gYmFzZSAoQUxQSEFCRVQpIHtcbiAgaWYgKEFMUEhBQkVULmxlbmd0aCA+PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignQWxwaGFiZXQgdG9vIGxvbmcnKSB9XG4gIHZhciBCQVNFX01BUCA9IG5ldyBVaW50OEFycmF5KDI1NilcbiAgZm9yICh2YXIgaiA9IDA7IGogPCBCQVNFX01BUC5sZW5ndGg7IGorKykge1xuICAgIEJBU0VfTUFQW2pdID0gMjU1XG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBBTFBIQUJFVC5sZW5ndGg7IGkrKykge1xuICAgIHZhciB4ID0gQUxQSEFCRVQuY2hhckF0KGkpXG4gICAgdmFyIHhjID0geC5jaGFyQ29kZUF0KDApXG4gICAgaWYgKEJBU0VfTUFQW3hjXSAhPT0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoeCArICcgaXMgYW1iaWd1b3VzJykgfVxuICAgIEJBU0VfTUFQW3hjXSA9IGlcbiAgfVxuICB2YXIgQkFTRSA9IEFMUEhBQkVULmxlbmd0aFxuICB2YXIgTEVBREVSID0gQUxQSEFCRVQuY2hhckF0KDApXG4gIHZhciBGQUNUT1IgPSBNYXRoLmxvZyhCQVNFKSAvIE1hdGgubG9nKDI1NikgLy8gbG9nKEJBU0UpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXBcbiAgdmFyIGlGQUNUT1IgPSBNYXRoLmxvZygyNTYpIC8gTWF0aC5sb2coQkFTRSkgLy8gbG9nKDI1NikgLyBsb2coQkFTRSksIHJvdW5kZWQgdXBcbiAgZnVuY3Rpb24gZW5jb2RlIChzb3VyY2UpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpIHx8IHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHsgc291cmNlID0gX0J1ZmZlci5mcm9tKHNvdXJjZSkgfVxuICAgIGlmICghX0J1ZmZlci5pc0J1ZmZlcihzb3VyY2UpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIEJ1ZmZlcicpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gJycgfVxuICAgICAgICAvLyBTa2lwICYgY291bnQgbGVhZGluZyB6ZXJvZXMuXG4gICAgdmFyIHplcm9lcyA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIHZhciBwYmVnaW4gPSAwXG4gICAgdmFyIHBlbmQgPSBzb3VyY2UubGVuZ3RoXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCAmJiBzb3VyY2VbcGJlZ2luXSA9PT0gMCkge1xuICAgICAgcGJlZ2luKytcbiAgICAgIHplcm9lcysrXG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlNTggcmVwcmVzZW50YXRpb24uXG4gICAgdmFyIHNpemUgPSAoKHBlbmQgLSBwYmVnaW4pICogaUZBQ1RPUiArIDEpID4+PiAwXG4gICAgdmFyIGI1OCA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGJ5dGVzLlxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQpIHtcbiAgICAgIHZhciBjYXJyeSA9IHNvdXJjZVtwYmVnaW5dXG4gICAgICAgICAgICAvLyBBcHBseSBcImI1OCA9IGI1OCAqIDI1NiArIGNoXCIuXG4gICAgICB2YXIgaSA9IDBcbiAgICAgIGZvciAodmFyIGl0MSA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MSAhPT0gLTEpOyBpdDEtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9ICgyNTYgKiBiNThbaXQxXSkgPj4+IDBcbiAgICAgICAgYjU4W2l0MV0gPSAoY2FycnkgJSBCQVNFKSA+Pj4gMFxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIEJBU0UpID4+PiAwXG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGlcbiAgICAgIHBiZWdpbisrXG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGJhc2U1OCByZXN1bHQuXG4gICAgdmFyIGl0MiA9IHNpemUgLSBsZW5ndGhcbiAgICB3aGlsZSAoaXQyICE9PSBzaXplICYmIGI1OFtpdDJdID09PSAwKSB7XG4gICAgICBpdDIrK1xuICAgIH1cbiAgICAgICAgLy8gVHJhbnNsYXRlIHRoZSByZXN1bHQgaW50byBhIHN0cmluZy5cbiAgICB2YXIgc3RyID0gTEVBREVSLnJlcGVhdCh6ZXJvZXMpXG4gICAgZm9yICg7IGl0MiA8IHNpemU7ICsraXQyKSB7IHN0ciArPSBBTFBIQUJFVC5jaGFyQXQoYjU4W2l0Ml0pIH1cbiAgICByZXR1cm4gc3RyXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlIChzb3VyY2UpIHtcbiAgICBpZiAodHlwZW9mIHNvdXJjZSAhPT0gJ3N0cmluZycpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgU3RyaW5nJykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiBfQnVmZmVyLmFsbG9jKDApIH1cbiAgICB2YXIgcHN6ID0gMFxuICAgICAgICAvLyBTa2lwIGFuZCBjb3VudCBsZWFkaW5nICcxJ3MuXG4gICAgdmFyIHplcm9lcyA9IDBcbiAgICB2YXIgbGVuZ3RoID0gMFxuICAgIHdoaWxlIChzb3VyY2VbcHN6XSA9PT0gTEVBREVSKSB7XG4gICAgICB6ZXJvZXMrK1xuICAgICAgcHN6KytcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2UyNTYgcmVwcmVzZW50YXRpb24uXG4gICAgdmFyIHNpemUgPSAoKChzb3VyY2UubGVuZ3RoIC0gcHN6KSAqIEZBQ1RPUikgKyAxKSA+Pj4gMCAvLyBsb2coNTgpIC8gbG9nKDI1NiksIHJvdW5kZWQgdXAuXG4gICAgdmFyIGIyNTYgPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBjaGFyYWN0ZXJzLlxuICAgIHdoaWxlIChzb3VyY2VbcHN6XSkge1xuICAgICAgICAgICAgLy8gRGVjb2RlIGNoYXJhY3RlclxuICAgICAgdmFyIGNhcnJ5ID0gQkFTRV9NQVBbc291cmNlLmNoYXJDb2RlQXQocHN6KV1cbiAgICAgICAgICAgIC8vIEludmFsaWQgY2hhcmFjdGVyXG4gICAgICBpZiAoY2FycnkgPT09IDI1NSkgeyByZXR1cm4gfVxuICAgICAgdmFyIGkgPSAwXG4gICAgICBmb3IgKHZhciBpdDMgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDMgIT09IC0xKTsgaXQzLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoQkFTRSAqIGIyNTZbaXQzXSkgPj4+IDBcbiAgICAgICAgYjI1NltpdDNdID0gKGNhcnJ5ICUgMjU2KSA+Pj4gMFxuICAgICAgICBjYXJyeSA9IChjYXJyeSAvIDI1NikgPj4+IDBcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaVxuICAgICAgcHN6KytcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYjI1Ni5cbiAgICB2YXIgaXQ0ID0gc2l6ZSAtIGxlbmd0aFxuICAgIHdoaWxlIChpdDQgIT09IHNpemUgJiYgYjI1NltpdDRdID09PSAwKSB7XG4gICAgICBpdDQrK1xuICAgIH1cbiAgICB2YXIgdmNoID0gX0J1ZmZlci5hbGxvY1Vuc2FmZSh6ZXJvZXMgKyAoc2l6ZSAtIGl0NCkpXG4gICAgdmNoLmZpbGwoMHgwMCwgMCwgemVyb2VzKVxuICAgIHZhciBqID0gemVyb2VzXG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSkge1xuICAgICAgdmNoW2orK10gPSBiMjU2W2l0NCsrXVxuICAgIH1cbiAgICByZXR1cm4gdmNoXG4gIH1cbiAgZnVuY3Rpb24gZGVjb2RlIChzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gZGVjb2RlVW5zYWZlKHN0cmluZylcbiAgICBpZiAoYnVmZmVyKSB7IHJldHVybiBidWZmZXIgfVxuICAgIHRocm93IG5ldyBFcnJvcignTm9uLWJhc2UnICsgQkFTRSArICcgY2hhcmFjdGVyJylcbiAgfVxuICByZXR1cm4ge1xuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZVVuc2FmZTogZGVjb2RlVW5zYWZlLFxuICAgIGRlY29kZTogZGVjb2RlXG4gIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gYmFzZVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/base-x/src/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosa0JBQWtCO0FBQ2xCLG1CQUFtQjtBQUNuQixxQkFBcUI7O0FBRXJCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1DQUFtQyxTQUFTO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanM/N2ExOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/base64-js/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/bigint-buffer/dist/browser.js":
/*!****************************************************!*\
  !*** ./node_modules/bigint-buffer/dist/browser.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nlet converter;\n/**\n * Convert a little-endian buffer into a BigInt.\n * @param buf The little-endian buffer to convert\n * @returns A BigInt with the little-endian representation of buf.\n */\nfunction toBigIntLE(buf) {\n    {\n        const reversed = Buffer.from(buf);\n        reversed.reverse();\n        const hex = reversed.toString('hex');\n        if (hex.length === 0) {\n            return BigInt(0);\n        }\n        return BigInt(`0x${hex}`);\n    }\n    return converter.toBigInt(buf, false);\n}\nexports.toBigIntLE = toBigIntLE;\n/**\n * Convert a big-endian buffer into a BigInt\n * @param buf The big-endian buffer to convert.\n * @returns A BigInt with the big-endian representation of buf.\n */\nfunction toBigIntBE(buf) {\n    {\n        const hex = buf.toString('hex');\n        if (hex.length === 0) {\n            return BigInt(0);\n        }\n        return BigInt(`0x${hex}`);\n    }\n    return converter.toBigInt(buf, true);\n}\nexports.toBigIntBE = toBigIntBE;\n/**\n * Convert a BigInt to a little-endian buffer.\n * @param num   The BigInt to convert.\n * @param width The number of bytes that the resulting buffer should be.\n * @returns A little-endian buffer representation of num.\n */\nfunction toBufferLE(num, width) {\n    {\n        const hex = num.toString(16);\n        const buffer = Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');\n        buffer.reverse();\n        return buffer;\n    }\n    // Allocation is done here, since it is slower using napi in C\n    return converter.fromBigInt(num, Buffer.allocUnsafe(width), false);\n}\nexports.toBufferLE = toBufferLE;\n/**\n * Convert a BigInt to a big-endian buffer.\n * @param num   The BigInt to convert.\n * @param width The number of bytes that the resulting buffer should be.\n * @returns A big-endian buffer representation of num.\n */\nfunction toBufferBE(num, width) {\n    {\n        const hex = num.toString(16);\n        return Buffer.from(hex.padStart(width * 2, '0').slice(0, width * 2), 'hex');\n    }\n    return converter.fromBigInt(num, Buffer.allocUnsafe(width), true);\n}\nexports.toBufferBE = toBufferBE;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iaWdpbnQtYnVmZmVyL2Rpc3QvYnJvd3Nlci5qcyIsIm1hcHBpbmdzIjoiO0FBQWE7O0FBRWIsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsTUFBTTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLElBQUk7QUFDL0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsSUFBSTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE1BQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsTUFBTTtBQUMzQztBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQSxxQ0FBcUMsTUFBTTtBQUMzQztBQUNBLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmlnaW50LWJ1ZmZlci9kaXN0L2Jyb3dzZXIuanM/NzE0OCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmxldCBjb252ZXJ0ZXI7XG4vKipcbiAqIENvbnZlcnQgYSBsaXR0bGUtZW5kaWFuIGJ1ZmZlciBpbnRvIGEgQmlnSW50LlxuICogQHBhcmFtIGJ1ZiBUaGUgbGl0dGxlLWVuZGlhbiBidWZmZXIgdG8gY29udmVydFxuICogQHJldHVybnMgQSBCaWdJbnQgd2l0aCB0aGUgbGl0dGxlLWVuZGlhbiByZXByZXNlbnRhdGlvbiBvZiBidWYuXG4gKi9cbmZ1bmN0aW9uIHRvQmlnSW50TEUoYnVmKSB7XG4gICAge1xuICAgICAgICBjb25zdCByZXZlcnNlZCA9IEJ1ZmZlci5mcm9tKGJ1Zik7XG4gICAgICAgIHJldmVyc2VkLnJldmVyc2UoKTtcbiAgICAgICAgY29uc3QgaGV4ID0gcmV2ZXJzZWQudG9TdHJpbmcoJ2hleCcpO1xuICAgICAgICBpZiAoaGV4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIEJpZ0ludCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnSW50KGAweCR7aGV4fWApO1xuICAgIH1cbiAgICByZXR1cm4gY29udmVydGVyLnRvQmlnSW50KGJ1ZiwgZmFsc2UpO1xufVxuZXhwb3J0cy50b0JpZ0ludExFID0gdG9CaWdJbnRMRTtcbi8qKlxuICogQ29udmVydCBhIGJpZy1lbmRpYW4gYnVmZmVyIGludG8gYSBCaWdJbnRcbiAqIEBwYXJhbSBidWYgVGhlIGJpZy1lbmRpYW4gYnVmZmVyIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyBBIEJpZ0ludCB3aXRoIHRoZSBiaWctZW5kaWFuIHJlcHJlc2VudGF0aW9uIG9mIGJ1Zi5cbiAqL1xuZnVuY3Rpb24gdG9CaWdJbnRCRShidWYpIHtcbiAgICB7XG4gICAgICAgIGNvbnN0IGhleCA9IGJ1Zi50b1N0cmluZygnaGV4Jyk7XG4gICAgICAgIGlmIChoZXgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gQmlnSW50KDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBCaWdJbnQoYDB4JHtoZXh9YCk7XG4gICAgfVxuICAgIHJldHVybiBjb252ZXJ0ZXIudG9CaWdJbnQoYnVmLCB0cnVlKTtcbn1cbmV4cG9ydHMudG9CaWdJbnRCRSA9IHRvQmlnSW50QkU7XG4vKipcbiAqIENvbnZlcnQgYSBCaWdJbnQgdG8gYSBsaXR0bGUtZW5kaWFuIGJ1ZmZlci5cbiAqIEBwYXJhbSBudW0gICBUaGUgQmlnSW50IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gd2lkdGggVGhlIG51bWJlciBvZiBieXRlcyB0aGF0IHRoZSByZXN1bHRpbmcgYnVmZmVyIHNob3VsZCBiZS5cbiAqIEByZXR1cm5zIEEgbGl0dGxlLWVuZGlhbiBidWZmZXIgcmVwcmVzZW50YXRpb24gb2YgbnVtLlxuICovXG5mdW5jdGlvbiB0b0J1ZmZlckxFKG51bSwgd2lkdGgpIHtcbiAgICB7XG4gICAgICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5mcm9tKGhleC5wYWRTdGFydCh3aWR0aCAqIDIsICcwJykuc2xpY2UoMCwgd2lkdGggKiAyKSwgJ2hleCcpO1xuICAgICAgICBidWZmZXIucmV2ZXJzZSgpO1xuICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgIH1cbiAgICAvLyBBbGxvY2F0aW9uIGlzIGRvbmUgaGVyZSwgc2luY2UgaXQgaXMgc2xvd2VyIHVzaW5nIG5hcGkgaW4gQ1xuICAgIHJldHVybiBjb252ZXJ0ZXIuZnJvbUJpZ0ludChudW0sIEJ1ZmZlci5hbGxvY1Vuc2FmZSh3aWR0aCksIGZhbHNlKTtcbn1cbmV4cG9ydHMudG9CdWZmZXJMRSA9IHRvQnVmZmVyTEU7XG4vKipcbiAqIENvbnZlcnQgYSBCaWdJbnQgdG8gYSBiaWctZW5kaWFuIGJ1ZmZlci5cbiAqIEBwYXJhbSBudW0gICBUaGUgQmlnSW50IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gd2lkdGggVGhlIG51bWJlciBvZiBieXRlcyB0aGF0IHRoZSByZXN1bHRpbmcgYnVmZmVyIHNob3VsZCBiZS5cbiAqIEByZXR1cm5zIEEgYmlnLWVuZGlhbiBidWZmZXIgcmVwcmVzZW50YXRpb24gb2YgbnVtLlxuICovXG5mdW5jdGlvbiB0b0J1ZmZlckJFKG51bSwgd2lkdGgpIHtcbiAgICB7XG4gICAgICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgIHJldHVybiBCdWZmZXIuZnJvbShoZXgucGFkU3RhcnQod2lkdGggKiAyLCAnMCcpLnNsaWNlKDAsIHdpZHRoICogMiksICdoZXgnKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnZlcnRlci5mcm9tQmlnSW50KG51bSwgQnVmZmVyLmFsbG9jVW5zYWZlKHdpZHRoKSwgdHJ1ZSk7XG59XG5leHBvcnRzLnRvQnVmZmVyQkUgPSB0b0J1ZmZlckJFO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/bigint-buffer/dist/browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/borsh/lib/index.js":
/*!*****************************************!*\
  !*** ./node_modules/borsh/lib/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.deserializeUnchecked = exports.deserialize = exports.serialize = exports.BinaryReader = exports.BinaryWriter = exports.BorshError = exports.baseDecode = exports.baseEncode = void 0;\nconst bn_js_1 = __importDefault(__webpack_require__(/*! bn.js */ \"(app-pages-browser)/./node_modules/borsh/node_modules/bn.js/lib/bn.js\"));\nconst bs58_1 = __importDefault(__webpack_require__(/*! bs58 */ \"(app-pages-browser)/./node_modules/borsh/node_modules/bs58/index.js\"));\n// TODO: Make sure this polyfill not included when not required\nconst encoding = __importStar(__webpack_require__(/*! text-encoding-utf-8 */ \"(app-pages-browser)/./node_modules/text-encoding-utf-8/lib/encoding.lib.js\"));\nconst ResolvedTextDecoder = typeof TextDecoder !== \"function\" ? encoding.TextDecoder : TextDecoder;\nconst textDecoder = new ResolvedTextDecoder(\"utf-8\", { fatal: true });\nfunction baseEncode(value) {\n    if (typeof value === \"string\") {\n        value = Buffer.from(value, \"utf8\");\n    }\n    return bs58_1.default.encode(Buffer.from(value));\n}\nexports.baseEncode = baseEncode;\nfunction baseDecode(value) {\n    return Buffer.from(bs58_1.default.decode(value));\n}\nexports.baseDecode = baseDecode;\nconst INITIAL_LENGTH = 1024;\nclass BorshError extends Error {\n    constructor(message) {\n        super(message);\n        this.fieldPath = [];\n        this.originalMessage = message;\n    }\n    addToFieldPath(fieldName) {\n        this.fieldPath.splice(0, 0, fieldName);\n        // NOTE: Modifying message directly as jest doesn't use .toString()\n        this.message = this.originalMessage + \": \" + this.fieldPath.join(\".\");\n    }\n}\nexports.BorshError = BorshError;\n/// Binary encoder.\nclass BinaryWriter {\n    constructor() {\n        this.buf = Buffer.alloc(INITIAL_LENGTH);\n        this.length = 0;\n    }\n    maybeResize() {\n        if (this.buf.length < 16 + this.length) {\n            this.buf = Buffer.concat([this.buf, Buffer.alloc(INITIAL_LENGTH)]);\n        }\n    }\n    writeU8(value) {\n        this.maybeResize();\n        this.buf.writeUInt8(value, this.length);\n        this.length += 1;\n    }\n    writeU16(value) {\n        this.maybeResize();\n        this.buf.writeUInt16LE(value, this.length);\n        this.length += 2;\n    }\n    writeU32(value) {\n        this.maybeResize();\n        this.buf.writeUInt32LE(value, this.length);\n        this.length += 4;\n    }\n    writeU64(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 8)));\n    }\n    writeU128(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 16)));\n    }\n    writeU256(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 32)));\n    }\n    writeU512(value) {\n        this.maybeResize();\n        this.writeBuffer(Buffer.from(new bn_js_1.default(value).toArray(\"le\", 64)));\n    }\n    writeBuffer(buffer) {\n        // Buffer.from is needed as this.buf.subarray can return plain Uint8Array in browser\n        this.buf = Buffer.concat([\n            Buffer.from(this.buf.subarray(0, this.length)),\n            buffer,\n            Buffer.alloc(INITIAL_LENGTH),\n        ]);\n        this.length += buffer.length;\n    }\n    writeString(str) {\n        this.maybeResize();\n        const b = Buffer.from(str, \"utf8\");\n        this.writeU32(b.length);\n        this.writeBuffer(b);\n    }\n    writeFixedArray(array) {\n        this.writeBuffer(Buffer.from(array));\n    }\n    writeArray(array, fn) {\n        this.maybeResize();\n        this.writeU32(array.length);\n        for (const elem of array) {\n            this.maybeResize();\n            fn(elem);\n        }\n    }\n    toArray() {\n        return this.buf.subarray(0, this.length);\n    }\n}\nexports.BinaryWriter = BinaryWriter;\nfunction handlingRangeError(target, propertyKey, propertyDescriptor) {\n    const originalMethod = propertyDescriptor.value;\n    propertyDescriptor.value = function (...args) {\n        try {\n            return originalMethod.apply(this, args);\n        }\n        catch (e) {\n            if (e instanceof RangeError) {\n                const code = e.code;\n                if ([\"ERR_BUFFER_OUT_OF_BOUNDS\", \"ERR_OUT_OF_RANGE\"].indexOf(code) >= 0) {\n                    throw new BorshError(\"Reached the end of buffer when deserializing\");\n                }\n            }\n            throw e;\n        }\n    };\n}\nclass BinaryReader {\n    constructor(buf) {\n        this.buf = buf;\n        this.offset = 0;\n    }\n    readU8() {\n        const value = this.buf.readUInt8(this.offset);\n        this.offset += 1;\n        return value;\n    }\n    readU16() {\n        const value = this.buf.readUInt16LE(this.offset);\n        this.offset += 2;\n        return value;\n    }\n    readU32() {\n        const value = this.buf.readUInt32LE(this.offset);\n        this.offset += 4;\n        return value;\n    }\n    readU64() {\n        const buf = this.readBuffer(8);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU128() {\n        const buf = this.readBuffer(16);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU256() {\n        const buf = this.readBuffer(32);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readU512() {\n        const buf = this.readBuffer(64);\n        return new bn_js_1.default(buf, \"le\");\n    }\n    readBuffer(len) {\n        if (this.offset + len > this.buf.length) {\n            throw new BorshError(`Expected buffer length ${len} isn't within bounds`);\n        }\n        const result = this.buf.slice(this.offset, this.offset + len);\n        this.offset += len;\n        return result;\n    }\n    readString() {\n        const len = this.readU32();\n        const buf = this.readBuffer(len);\n        try {\n            // NOTE: Using TextDecoder to fail on invalid UTF-8\n            return textDecoder.decode(buf);\n        }\n        catch (e) {\n            throw new BorshError(`Error decoding UTF-8 string: ${e}`);\n        }\n    }\n    readFixedArray(len) {\n        return new Uint8Array(this.readBuffer(len));\n    }\n    readArray(fn) {\n        const len = this.readU32();\n        const result = Array();\n        for (let i = 0; i < len; ++i) {\n            result.push(fn());\n        }\n        return result;\n    }\n}\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU8\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU16\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU32\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU64\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU128\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU256\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readU512\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readString\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readFixedArray\", null);\n__decorate([\n    handlingRangeError\n], BinaryReader.prototype, \"readArray\", null);\nexports.BinaryReader = BinaryReader;\nfunction capitalizeFirstLetter(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\nfunction serializeField(schema, fieldName, value, fieldType, writer) {\n    try {\n        // TODO: Handle missing values properly (make sure they never result in just skipped write)\n        if (typeof fieldType === \"string\") {\n            writer[`write${capitalizeFirstLetter(fieldType)}`](value);\n        }\n        else if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === \"number\") {\n                if (value.length !== fieldType[0]) {\n                    throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);\n                }\n                writer.writeFixedArray(value);\n            }\n            else if (fieldType.length === 2 && typeof fieldType[1] === \"number\") {\n                if (value.length !== fieldType[1]) {\n                    throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);\n                }\n                for (let i = 0; i < fieldType[1]; i++) {\n                    serializeField(schema, null, value[i], fieldType[0], writer);\n                }\n            }\n            else {\n                writer.writeArray(value, (item) => {\n                    serializeField(schema, fieldName, item, fieldType[0], writer);\n                });\n            }\n        }\n        else if (fieldType.kind !== undefined) {\n            switch (fieldType.kind) {\n                case \"option\": {\n                    if (value === null || value === undefined) {\n                        writer.writeU8(0);\n                    }\n                    else {\n                        writer.writeU8(1);\n                        serializeField(schema, fieldName, value, fieldType.type, writer);\n                    }\n                    break;\n                }\n                case \"map\": {\n                    writer.writeU32(value.size);\n                    value.forEach((val, key) => {\n                        serializeField(schema, fieldName, key, fieldType.key, writer);\n                        serializeField(schema, fieldName, val, fieldType.value, writer);\n                    });\n                    break;\n                }\n                default:\n                    throw new BorshError(`FieldType ${fieldType} unrecognized`);\n            }\n        }\n        else {\n            serializeStruct(schema, value, writer);\n        }\n    }\n    catch (error) {\n        if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n        }\n        throw error;\n    }\n}\nfunction serializeStruct(schema, obj, writer) {\n    if (typeof obj.borshSerialize === \"function\") {\n        obj.borshSerialize(writer);\n        return;\n    }\n    const structSchema = schema.get(obj.constructor);\n    if (!structSchema) {\n        throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);\n    }\n    if (structSchema.kind === \"struct\") {\n        structSchema.fields.map(([fieldName, fieldType]) => {\n            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n        });\n    }\n    else if (structSchema.kind === \"enum\") {\n        const name = obj[structSchema.field];\n        for (let idx = 0; idx < structSchema.values.length; ++idx) {\n            const [fieldName, fieldType] = structSchema.values[idx];\n            if (fieldName === name) {\n                writer.writeU8(idx);\n                serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n                break;\n            }\n        }\n    }\n    else {\n        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);\n    }\n}\n/// Serialize given object using schema of the form:\n/// { class_name -> [ [field_name, field_type], .. ], .. }\nfunction serialize(schema, obj, Writer = BinaryWriter) {\n    const writer = new Writer();\n    serializeStruct(schema, obj, writer);\n    return writer.toArray();\n}\nexports.serialize = serialize;\nfunction deserializeField(schema, fieldName, fieldType, reader) {\n    try {\n        if (typeof fieldType === \"string\") {\n            return reader[`read${capitalizeFirstLetter(fieldType)}`]();\n        }\n        if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === \"number\") {\n                return reader.readFixedArray(fieldType[0]);\n            }\n            else if (typeof fieldType[1] === \"number\") {\n                const arr = [];\n                for (let i = 0; i < fieldType[1]; i++) {\n                    arr.push(deserializeField(schema, null, fieldType[0], reader));\n                }\n                return arr;\n            }\n            else {\n                return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));\n            }\n        }\n        if (fieldType.kind === \"option\") {\n            const option = reader.readU8();\n            if (option) {\n                return deserializeField(schema, fieldName, fieldType.type, reader);\n            }\n            return undefined;\n        }\n        if (fieldType.kind === \"map\") {\n            let map = new Map();\n            const length = reader.readU32();\n            for (let i = 0; i < length; i++) {\n                const key = deserializeField(schema, fieldName, fieldType.key, reader);\n                const val = deserializeField(schema, fieldName, fieldType.value, reader);\n                map.set(key, val);\n            }\n            return map;\n        }\n        return deserializeStruct(schema, fieldType, reader);\n    }\n    catch (error) {\n        if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n        }\n        throw error;\n    }\n}\nfunction deserializeStruct(schema, classType, reader) {\n    if (typeof classType.borshDeserialize === \"function\") {\n        return classType.borshDeserialize(reader);\n    }\n    const structSchema = schema.get(classType);\n    if (!structSchema) {\n        throw new BorshError(`Class ${classType.name} is missing in schema`);\n    }\n    if (structSchema.kind === \"struct\") {\n        const result = {};\n        for (const [fieldName, fieldType] of schema.get(classType).fields) {\n            result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);\n        }\n        return new classType(result);\n    }\n    if (structSchema.kind === \"enum\") {\n        const idx = reader.readU8();\n        if (idx >= structSchema.values.length) {\n            throw new BorshError(`Enum index: ${idx} is out of range`);\n        }\n        const [fieldName, fieldType] = structSchema.values[idx];\n        const fieldValue = deserializeField(schema, fieldName, fieldType, reader);\n        return new classType({ [fieldName]: fieldValue });\n    }\n    throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);\n}\n/// Deserializes object from bytes using schema.\nfunction deserialize(schema, classType, buffer, Reader = BinaryReader) {\n    const reader = new Reader(buffer);\n    const result = deserializeStruct(schema, classType, reader);\n    if (reader.offset < buffer.length) {\n        throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);\n    }\n    return result;\n}\nexports.deserialize = deserialize;\n/// Deserializes object from bytes using schema, without checking the length read\nfunction deserializeUnchecked(schema, classType, buffer, Reader = BinaryReader) {\n    const reader = new Reader(buffer);\n    return deserializeStruct(schema, classType, reader);\n}\nexports.deserializeUnchecked = deserializeUnchecked;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ib3JzaC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFhO0FBQ2I7QUFDQTtBQUNBLG1DQUFtQyxvQ0FBb0MsZ0JBQWdCO0FBQ3ZGLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLFFBQVE7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsbUJBQW1CLEdBQUcsaUJBQWlCLEdBQUcsb0JBQW9CLEdBQUcsb0JBQW9CLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsa0JBQWtCO0FBQ25MLGdDQUFnQyxtQkFBTyxDQUFDLG9GQUFPO0FBQy9DLCtCQUErQixtQkFBTyxDQUFDLGlGQUFNO0FBQzdDO0FBQ0EsOEJBQThCLG1CQUFPLENBQUMsdUdBQXFCO0FBQzNEO0FBQ0EsdURBQXVELGFBQWE7QUFDcEU7QUFDQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLE1BQU07QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsTUFBTSxtQkFBbUIsTUFBTTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGdCQUFnQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELEtBQUs7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlCQUF5QjtBQUN4RDtBQUNBLG9EQUFvRCxtQkFBbUIsTUFBTSwyQkFBMkI7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLCtCQUErQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYm9yc2gvbGliL2luZGV4LmpzP2FlMDIiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19kZWNvcmF0ZSA9ICh0aGlzICYmIHRoaXMuX19kZWNvcmF0ZSkgfHwgZnVuY3Rpb24gKGRlY29yYXRvcnMsIHRhcmdldCwga2V5LCBkZXNjKSB7XG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xuICAgIGVsc2UgZm9yICh2YXIgaSA9IGRlY29yYXRvcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGlmIChkID0gZGVjb3JhdG9yc1tpXSkgciA9IChjIDwgMyA/IGQocikgOiBjID4gMyA/IGQodGFyZ2V0LCBrZXksIHIpIDogZCh0YXJnZXQsIGtleSkpIHx8IHI7XG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcbn07XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZXNlcmlhbGl6ZVVuY2hlY2tlZCA9IGV4cG9ydHMuZGVzZXJpYWxpemUgPSBleHBvcnRzLnNlcmlhbGl6ZSA9IGV4cG9ydHMuQmluYXJ5UmVhZGVyID0gZXhwb3J0cy5CaW5hcnlXcml0ZXIgPSBleHBvcnRzLkJvcnNoRXJyb3IgPSBleHBvcnRzLmJhc2VEZWNvZGUgPSBleHBvcnRzLmJhc2VFbmNvZGUgPSB2b2lkIDA7XG5jb25zdCBibl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibi5qc1wiKSk7XG5jb25zdCBiczU4XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJzNThcIikpO1xuLy8gVE9ETzogTWFrZSBzdXJlIHRoaXMgcG9seWZpbGwgbm90IGluY2x1ZGVkIHdoZW4gbm90IHJlcXVpcmVkXG5jb25zdCBlbmNvZGluZyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwidGV4dC1lbmNvZGluZy11dGYtOFwiKSk7XG5jb25zdCBSZXNvbHZlZFRleHREZWNvZGVyID0gdHlwZW9mIFRleHREZWNvZGVyICE9PSBcImZ1bmN0aW9uXCIgPyBlbmNvZGluZy5UZXh0RGVjb2RlciA6IFRleHREZWNvZGVyO1xuY29uc3QgdGV4dERlY29kZXIgPSBuZXcgUmVzb2x2ZWRUZXh0RGVjb2RlcihcInV0Zi04XCIsIHsgZmF0YWw6IHRydWUgfSk7XG5mdW5jdGlvbiBiYXNlRW5jb2RlKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWx1ZSA9IEJ1ZmZlci5mcm9tKHZhbHVlLCBcInV0ZjhcIik7XG4gICAgfVxuICAgIHJldHVybiBiczU4XzEuZGVmYXVsdC5lbmNvZGUoQnVmZmVyLmZyb20odmFsdWUpKTtcbn1cbmV4cG9ydHMuYmFzZUVuY29kZSA9IGJhc2VFbmNvZGU7XG5mdW5jdGlvbiBiYXNlRGVjb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJzNThfMS5kZWZhdWx0LmRlY29kZSh2YWx1ZSkpO1xufVxuZXhwb3J0cy5iYXNlRGVjb2RlID0gYmFzZURlY29kZTtcbmNvbnN0IElOSVRJQUxfTEVOR1RIID0gMTAyNDtcbmNsYXNzIEJvcnNoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5maWVsZFBhdGggPSBbXTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIH1cbiAgICBhZGRUb0ZpZWxkUGF0aChmaWVsZE5hbWUpIHtcbiAgICAgICAgdGhpcy5maWVsZFBhdGguc3BsaWNlKDAsIDAsIGZpZWxkTmFtZSk7XG4gICAgICAgIC8vIE5PVEU6IE1vZGlmeWluZyBtZXNzYWdlIGRpcmVjdGx5IGFzIGplc3QgZG9lc24ndCB1c2UgLnRvU3RyaW5nKClcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5vcmlnaW5hbE1lc3NhZ2UgKyBcIjogXCIgKyB0aGlzLmZpZWxkUGF0aC5qb2luKFwiLlwiKTtcbiAgICB9XG59XG5leHBvcnRzLkJvcnNoRXJyb3IgPSBCb3JzaEVycm9yO1xuLy8vIEJpbmFyeSBlbmNvZGVyLlxuY2xhc3MgQmluYXJ5V3JpdGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5idWYgPSBCdWZmZXIuYWxsb2MoSU5JVElBTF9MRU5HVEgpO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIG1heWJlUmVzaXplKCkge1xuICAgICAgICBpZiAodGhpcy5idWYubGVuZ3RoIDwgMTYgKyB0aGlzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5idWYgPSBCdWZmZXIuY29uY2F0KFt0aGlzLmJ1ZiwgQnVmZmVyLmFsbG9jKElOSVRJQUxfTEVOR1RIKV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdyaXRlVTgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICB0aGlzLmJ1Zi53cml0ZVVJbnQ4KHZhbHVlLCB0aGlzLmxlbmd0aCk7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IDE7XG4gICAgfVxuICAgIHdyaXRlVTE2KHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgdGhpcy5idWYud3JpdGVVSW50MTZMRSh2YWx1ZSwgdGhpcy5sZW5ndGgpO1xuICAgICAgICB0aGlzLmxlbmd0aCArPSAyO1xuICAgIH1cbiAgICB3cml0ZVUzMih2YWx1ZSkge1xuICAgICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICAgIHRoaXMuYnVmLndyaXRlVUludDMyTEUodmFsdWUsIHRoaXMubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5sZW5ndGggKz0gNDtcbiAgICB9XG4gICAgd3JpdGVVNjQodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyKEJ1ZmZlci5mcm9tKG5ldyBibl9qc18xLmRlZmF1bHQodmFsdWUpLnRvQXJyYXkoXCJsZVwiLCA4KSkpO1xuICAgIH1cbiAgICB3cml0ZVUxMjgodmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXliZVJlc2l6ZSgpO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyKEJ1ZmZlci5mcm9tKG5ldyBibl9qc18xLmRlZmF1bHQodmFsdWUpLnRvQXJyYXkoXCJsZVwiLCAxNikpKTtcbiAgICB9XG4gICAgd3JpdGVVMjU2KHZhbHVlKSB7XG4gICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcihCdWZmZXIuZnJvbShuZXcgYm5fanNfMS5kZWZhdWx0KHZhbHVlKS50b0FycmF5KFwibGVcIiwgMzIpKSk7XG4gICAgfVxuICAgIHdyaXRlVTUxMih2YWx1ZSkge1xuICAgICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIoQnVmZmVyLmZyb20obmV3IGJuX2pzXzEuZGVmYXVsdCh2YWx1ZSkudG9BcnJheShcImxlXCIsIDY0KSkpO1xuICAgIH1cbiAgICB3cml0ZUJ1ZmZlcihidWZmZXIpIHtcbiAgICAgICAgLy8gQnVmZmVyLmZyb20gaXMgbmVlZGVkIGFzIHRoaXMuYnVmLnN1YmFycmF5IGNhbiByZXR1cm4gcGxhaW4gVWludDhBcnJheSBpbiBicm93c2VyXG4gICAgICAgIHRoaXMuYnVmID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgICAgICBCdWZmZXIuZnJvbSh0aGlzLmJ1Zi5zdWJhcnJheSgwLCB0aGlzLmxlbmd0aCkpLFxuICAgICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgICAgQnVmZmVyLmFsbG9jKElOSVRJQUxfTEVOR1RIKSxcbiAgICAgICAgXSk7XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgfVxuICAgIHdyaXRlU3RyaW5nKHN0cikge1xuICAgICAgICB0aGlzLm1heWJlUmVzaXplKCk7XG4gICAgICAgIGNvbnN0IGIgPSBCdWZmZXIuZnJvbShzdHIsIFwidXRmOFwiKTtcbiAgICAgICAgdGhpcy53cml0ZVUzMihiLmxlbmd0aCk7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIoYik7XG4gICAgfVxuICAgIHdyaXRlRml4ZWRBcnJheShhcnJheSkge1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyKEJ1ZmZlci5mcm9tKGFycmF5KSk7XG4gICAgfVxuICAgIHdyaXRlQXJyYXkoYXJyYXksIGZuKSB7XG4gICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgdGhpcy53cml0ZVUzMihhcnJheS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW0gb2YgYXJyYXkpIHtcbiAgICAgICAgICAgIHRoaXMubWF5YmVSZXNpemUoKTtcbiAgICAgICAgICAgIGZuKGVsZW0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1Zi5zdWJhcnJheSgwLCB0aGlzLmxlbmd0aCk7XG4gICAgfVxufVxuZXhwb3J0cy5CaW5hcnlXcml0ZXIgPSBCaW5hcnlXcml0ZXI7XG5mdW5jdGlvbiBoYW5kbGluZ1JhbmdlRXJyb3IodGFyZ2V0LCBwcm9wZXJ0eUtleSwgcHJvcGVydHlEZXNjcmlwdG9yKSB7XG4gICAgY29uc3Qgb3JpZ2luYWxNZXRob2QgPSBwcm9wZXJ0eURlc2NyaXB0b3IudmFsdWU7XG4gICAgcHJvcGVydHlEZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbE1ldGhvZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBSYW5nZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29kZSA9IGUuY29kZTtcbiAgICAgICAgICAgICAgICBpZiAoW1wiRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTXCIsIFwiRVJSX09VVF9PRl9SQU5HRVwiXS5pbmRleE9mKGNvZGUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoXCJSZWFjaGVkIHRoZSBlbmQgb2YgYnVmZmVyIHdoZW4gZGVzZXJpYWxpemluZ1wiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmNsYXNzIEJpbmFyeVJlYWRlciB7XG4gICAgY29uc3RydWN0b3IoYnVmKSB7XG4gICAgICAgIHRoaXMuYnVmID0gYnVmO1xuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgfVxuICAgIHJlYWRVOCgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmJ1Zi5yZWFkVUludDgodGhpcy5vZmZzZXQpO1xuICAgICAgICB0aGlzLm9mZnNldCArPSAxO1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIHJlYWRVMTYoKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5idWYucmVhZFVJbnQxNkxFKHRoaXMub2Zmc2V0KTtcbiAgICAgICAgdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZWFkVTMyKCkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuYnVmLnJlYWRVSW50MzJMRSh0aGlzLm9mZnNldCk7XG4gICAgICAgIHRoaXMub2Zmc2V0ICs9IDQ7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmVhZFU2NCgpIHtcbiAgICAgICAgY29uc3QgYnVmID0gdGhpcy5yZWFkQnVmZmVyKDgpO1xuICAgICAgICByZXR1cm4gbmV3IGJuX2pzXzEuZGVmYXVsdChidWYsIFwibGVcIik7XG4gICAgfVxuICAgIHJlYWRVMTI4KCkge1xuICAgICAgICBjb25zdCBidWYgPSB0aGlzLnJlYWRCdWZmZXIoMTYpO1xuICAgICAgICByZXR1cm4gbmV3IGJuX2pzXzEuZGVmYXVsdChidWYsIFwibGVcIik7XG4gICAgfVxuICAgIHJlYWRVMjU2KCkge1xuICAgICAgICBjb25zdCBidWYgPSB0aGlzLnJlYWRCdWZmZXIoMzIpO1xuICAgICAgICByZXR1cm4gbmV3IGJuX2pzXzEuZGVmYXVsdChidWYsIFwibGVcIik7XG4gICAgfVxuICAgIHJlYWRVNTEyKCkge1xuICAgICAgICBjb25zdCBidWYgPSB0aGlzLnJlYWRCdWZmZXIoNjQpO1xuICAgICAgICByZXR1cm4gbmV3IGJuX2pzXzEuZGVmYXVsdChidWYsIFwibGVcIik7XG4gICAgfVxuICAgIHJlYWRCdWZmZXIobGVuKSB7XG4gICAgICAgIGlmICh0aGlzLm9mZnNldCArIGxlbiA+IHRoaXMuYnVmLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYEV4cGVjdGVkIGJ1ZmZlciBsZW5ndGggJHtsZW59IGlzbid0IHdpdGhpbiBib3VuZHNgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmJ1Zi5zbGljZSh0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKyBsZW4pO1xuICAgICAgICB0aGlzLm9mZnNldCArPSBsZW47XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlYWRTdHJpbmcoKSB7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMucmVhZFUzMigpO1xuICAgICAgICBjb25zdCBidWYgPSB0aGlzLnJlYWRCdWZmZXIobGVuKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIE5PVEU6IFVzaW5nIFRleHREZWNvZGVyIHRvIGZhaWwgb24gaW52YWxpZCBVVEYtOFxuICAgICAgICAgICAgcmV0dXJuIHRleHREZWNvZGVyLmRlY29kZShidWYpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgRXJyb3IgZGVjb2RpbmcgVVRGLTggc3RyaW5nOiAke2V9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZEZpeGVkQXJyYXkobGVuKSB7XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLnJlYWRCdWZmZXIobGVuKSk7XG4gICAgfVxuICAgIHJlYWRBcnJheShmbikge1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLnJlYWRVMzIoKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gQXJyYXkoKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goZm4oKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFU4XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgaGFuZGxpbmdSYW5nZUVycm9yXG5dLCBCaW5hcnlSZWFkZXIucHJvdG90eXBlLCBcInJlYWRVMTZcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZFUzMlwiLCBudWxsKTtcbl9fZGVjb3JhdGUoW1xuICAgIGhhbmRsaW5nUmFuZ2VFcnJvclxuXSwgQmluYXJ5UmVhZGVyLnByb3RvdHlwZSwgXCJyZWFkVTY0XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgaGFuZGxpbmdSYW5nZUVycm9yXG5dLCBCaW5hcnlSZWFkZXIucHJvdG90eXBlLCBcInJlYWRVMTI4XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgaGFuZGxpbmdSYW5nZUVycm9yXG5dLCBCaW5hcnlSZWFkZXIucHJvdG90eXBlLCBcInJlYWRVMjU2XCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgaGFuZGxpbmdSYW5nZUVycm9yXG5dLCBCaW5hcnlSZWFkZXIucHJvdG90eXBlLCBcInJlYWRVNTEyXCIsIG51bGwpO1xuX19kZWNvcmF0ZShbXG4gICAgaGFuZGxpbmdSYW5nZUVycm9yXG5dLCBCaW5hcnlSZWFkZXIucHJvdG90eXBlLCBcInJlYWRTdHJpbmdcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZEZpeGVkQXJyYXlcIiwgbnVsbCk7XG5fX2RlY29yYXRlKFtcbiAgICBoYW5kbGluZ1JhbmdlRXJyb3Jcbl0sIEJpbmFyeVJlYWRlci5wcm90b3R5cGUsIFwicmVhZEFycmF5XCIsIG51bGwpO1xuZXhwb3J0cy5CaW5hcnlSZWFkZXIgPSBCaW5hcnlSZWFkZXI7XG5mdW5jdGlvbiBjYXBpdGFsaXplRmlyc3RMZXR0ZXIoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCB2YWx1ZSwgZmllbGRUeXBlLCB3cml0ZXIpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBUT0RPOiBIYW5kbGUgbWlzc2luZyB2YWx1ZXMgcHJvcGVybHkgKG1ha2Ugc3VyZSB0aGV5IG5ldmVyIHJlc3VsdCBpbiBqdXN0IHNraXBwZWQgd3JpdGUpXG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB3cml0ZXJbYHdyaXRlJHtjYXBpdGFsaXplRmlyc3RMZXR0ZXIoZmllbGRUeXBlKX1gXSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGRUeXBlIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZmllbGRUeXBlWzBdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAhPT0gZmllbGRUeXBlWzBdKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBFeHBlY3RpbmcgYnl0ZSBhcnJheSBvZiBsZW5ndGggJHtmaWVsZFR5cGVbMF19LCBidXQgZ290ICR7dmFsdWUubGVuZ3RofSBieXRlc2ApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVGaXhlZEFycmF5KHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkVHlwZS5sZW5ndGggPT09IDIgJiYgdHlwZW9mIGZpZWxkVHlwZVsxXSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IGZpZWxkVHlwZVsxXSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgRXhwZWN0aW5nIGJ5dGUgYXJyYXkgb2YgbGVuZ3RoICR7ZmllbGRUeXBlWzFdfSwgYnV0IGdvdCAke3ZhbHVlLmxlbmd0aH0gYnl0ZXNgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZFR5cGVbMV07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVGaWVsZChzY2hlbWEsIG51bGwsIHZhbHVlW2ldLCBmaWVsZFR5cGVbMF0sIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlQXJyYXkodmFsdWUsIChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBpdGVtLCBmaWVsZFR5cGVbMF0sIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZmllbGRUeXBlLmtpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3dpdGNoIChmaWVsZFR5cGUua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJvcHRpb25cIjoge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd3JpdGVyLndyaXRlVTgoMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVVOCgxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCB2YWx1ZSwgZmllbGRUeXBlLnR5cGUsIHdyaXRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJtYXBcIjoge1xuICAgICAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVVMzIodmFsdWUuc2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goKHZhbCwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwga2V5LCBmaWVsZFR5cGUua2V5LCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIHZhbCwgZmllbGRUeXBlLnZhbHVlLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBGaWVsZFR5cGUgJHtmaWVsZFR5cGV9IHVucmVjb2duaXplZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VyaWFsaXplU3RydWN0KHNjaGVtYSwgdmFsdWUsIHdyaXRlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEJvcnNoRXJyb3IpIHtcbiAgICAgICAgICAgIGVycm9yLmFkZFRvRmllbGRQYXRoKGZpZWxkTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxufVxuZnVuY3Rpb24gc2VyaWFsaXplU3RydWN0KHNjaGVtYSwgb2JqLCB3cml0ZXIpIHtcbiAgICBpZiAodHlwZW9mIG9iai5ib3JzaFNlcmlhbGl6ZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9iai5ib3JzaFNlcmlhbGl6ZSh3cml0ZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0cnVjdFNjaGVtYSA9IHNjaGVtYS5nZXQob2JqLmNvbnN0cnVjdG9yKTtcbiAgICBpZiAoIXN0cnVjdFNjaGVtYSkge1xuICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgQ2xhc3MgJHtvYmouY29uc3RydWN0b3IubmFtZX0gaXMgbWlzc2luZyBpbiBzY2hlbWFgKTtcbiAgICB9XG4gICAgaWYgKHN0cnVjdFNjaGVtYS5raW5kID09PSBcInN0cnVjdFwiKSB7XG4gICAgICAgIHN0cnVjdFNjaGVtYS5maWVsZHMubWFwKChbZmllbGROYW1lLCBmaWVsZFR5cGVdKSA9PiB7XG4gICAgICAgICAgICBzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgb2JqW2ZpZWxkTmFtZV0sIGZpZWxkVHlwZSwgd3JpdGVyKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0cnVjdFNjaGVtYS5raW5kID09PSBcImVudW1cIikge1xuICAgICAgICBjb25zdCBuYW1lID0gb2JqW3N0cnVjdFNjaGVtYS5maWVsZF07XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHN0cnVjdFNjaGVtYS52YWx1ZXMubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRUeXBlXSA9IHN0cnVjdFNjaGVtYS52YWx1ZXNbaWR4XTtcbiAgICAgICAgICAgIGlmIChmaWVsZE5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICB3cml0ZXIud3JpdGVVOChpZHgpO1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBvYmpbZmllbGROYW1lXSwgZmllbGRUeXBlLCB3cml0ZXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgVW5leHBlY3RlZCBzY2hlbWEga2luZDogJHtzdHJ1Y3RTY2hlbWEua2luZH0gZm9yICR7b2JqLmNvbnN0cnVjdG9yLm5hbWV9YCk7XG4gICAgfVxufVxuLy8vIFNlcmlhbGl6ZSBnaXZlbiBvYmplY3QgdXNpbmcgc2NoZW1hIG9mIHRoZSBmb3JtOlxuLy8vIHsgY2xhc3NfbmFtZSAtPiBbIFtmaWVsZF9uYW1lLCBmaWVsZF90eXBlXSwgLi4gXSwgLi4gfVxuZnVuY3Rpb24gc2VyaWFsaXplKHNjaGVtYSwgb2JqLCBXcml0ZXIgPSBCaW5hcnlXcml0ZXIpIHtcbiAgICBjb25zdCB3cml0ZXIgPSBuZXcgV3JpdGVyKCk7XG4gICAgc2VyaWFsaXplU3RydWN0KHNjaGVtYSwgb2JqLCB3cml0ZXIpO1xuICAgIHJldHVybiB3cml0ZXIudG9BcnJheSgpO1xufVxuZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBmaWVsZFR5cGUsIHJlYWRlcikge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgZmllbGRUeXBlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVhZGVyW2ByZWFkJHtjYXBpdGFsaXplRmlyc3RMZXR0ZXIoZmllbGRUeXBlKX1gXSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZFR5cGUgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaWVsZFR5cGVbMF0gPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVhZGVyLnJlYWRGaXhlZEFycmF5KGZpZWxkVHlwZVswXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgZmllbGRUeXBlWzFdID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWVsZFR5cGVbMV07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChkZXNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgbnVsbCwgZmllbGRUeXBlWzBdLCByZWFkZXIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiByZWFkZXIucmVhZEFycmF5KCgpID0+IGRlc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIGZpZWxkVHlwZVswXSwgcmVhZGVyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZpZWxkVHlwZS5raW5kID09PSBcIm9wdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb24gPSByZWFkZXIucmVhZFU4KCk7XG4gICAgICAgICAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIGZpZWxkVHlwZS50eXBlLCByZWFkZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGRUeXBlLmtpbmQgPT09IFwibWFwXCIpIHtcbiAgICAgICAgICAgIGxldCBtYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSByZWFkZXIucmVhZFUzMigpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGRlc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIGZpZWxkVHlwZS5rZXksIHJlYWRlcik7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gZGVzZXJpYWxpemVGaWVsZChzY2hlbWEsIGZpZWxkTmFtZSwgZmllbGRUeXBlLnZhbHVlLCByZWFkZXIpO1xuICAgICAgICAgICAgICAgIG1hcC5zZXQoa2V5LCB2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVTdHJ1Y3Qoc2NoZW1hLCBmaWVsZFR5cGUsIHJlYWRlcik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBCb3JzaEVycm9yKSB7XG4gICAgICAgICAgICBlcnJvci5hZGRUb0ZpZWxkUGF0aChmaWVsZE5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplU3RydWN0KHNjaGVtYSwgY2xhc3NUeXBlLCByZWFkZXIpIHtcbiAgICBpZiAodHlwZW9mIGNsYXNzVHlwZS5ib3JzaERlc2VyaWFsaXplID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIGNsYXNzVHlwZS5ib3JzaERlc2VyaWFsaXplKHJlYWRlcik7XG4gICAgfVxuICAgIGNvbnN0IHN0cnVjdFNjaGVtYSA9IHNjaGVtYS5nZXQoY2xhc3NUeXBlKTtcbiAgICBpZiAoIXN0cnVjdFNjaGVtYSkge1xuICAgICAgICB0aHJvdyBuZXcgQm9yc2hFcnJvcihgQ2xhc3MgJHtjbGFzc1R5cGUubmFtZX0gaXMgbWlzc2luZyBpbiBzY2hlbWFgKTtcbiAgICB9XG4gICAgaWYgKHN0cnVjdFNjaGVtYS5raW5kID09PSBcInN0cnVjdFwiKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtmaWVsZE5hbWUsIGZpZWxkVHlwZV0gb2Ygc2NoZW1hLmdldChjbGFzc1R5cGUpLmZpZWxkcykge1xuICAgICAgICAgICAgcmVzdWx0W2ZpZWxkTmFtZV0gPSBkZXNlcmlhbGl6ZUZpZWxkKHNjaGVtYSwgZmllbGROYW1lLCBmaWVsZFR5cGUsIHJlYWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBjbGFzc1R5cGUocmVzdWx0KTtcbiAgICB9XG4gICAgaWYgKHN0cnVjdFNjaGVtYS5raW5kID09PSBcImVudW1cIikge1xuICAgICAgICBjb25zdCBpZHggPSByZWFkZXIucmVhZFU4KCk7XG4gICAgICAgIGlmIChpZHggPj0gc3RydWN0U2NoZW1hLnZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBFbnVtIGluZGV4OiAke2lkeH0gaXMgb3V0IG9mIHJhbmdlYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW2ZpZWxkTmFtZSwgZmllbGRUeXBlXSA9IHN0cnVjdFNjaGVtYS52YWx1ZXNbaWR4XTtcbiAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IGRlc2VyaWFsaXplRmllbGQoc2NoZW1hLCBmaWVsZE5hbWUsIGZpZWxkVHlwZSwgcmVhZGVyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBjbGFzc1R5cGUoeyBbZmllbGROYW1lXTogZmllbGRWYWx1ZSB9KTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEJvcnNoRXJyb3IoYFVuZXhwZWN0ZWQgc2NoZW1hIGtpbmQ6ICR7c3RydWN0U2NoZW1hLmtpbmR9IGZvciAke2NsYXNzVHlwZS5jb25zdHJ1Y3Rvci5uYW1lfWApO1xufVxuLy8vIERlc2VyaWFsaXplcyBvYmplY3QgZnJvbSBieXRlcyB1c2luZyBzY2hlbWEuXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShzY2hlbWEsIGNsYXNzVHlwZSwgYnVmZmVyLCBSZWFkZXIgPSBCaW5hcnlSZWFkZXIpIHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUmVhZGVyKGJ1ZmZlcik7XG4gICAgY29uc3QgcmVzdWx0ID0gZGVzZXJpYWxpemVTdHJ1Y3Qoc2NoZW1hLCBjbGFzc1R5cGUsIHJlYWRlcik7XG4gICAgaWYgKHJlYWRlci5vZmZzZXQgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBCb3JzaEVycm9yKGBVbmV4cGVjdGVkICR7YnVmZmVyLmxlbmd0aCAtIHJlYWRlci5vZmZzZXR9IGJ5dGVzIGFmdGVyIGRlc2VyaWFsaXplZCBkYXRhYCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmRlc2VyaWFsaXplID0gZGVzZXJpYWxpemU7XG4vLy8gRGVzZXJpYWxpemVzIG9iamVjdCBmcm9tIGJ5dGVzIHVzaW5nIHNjaGVtYSwgd2l0aG91dCBjaGVja2luZyB0aGUgbGVuZ3RoIHJlYWRcbmZ1bmN0aW9uIGRlc2VyaWFsaXplVW5jaGVja2VkKHNjaGVtYSwgY2xhc3NUeXBlLCBidWZmZXIsIFJlYWRlciA9IEJpbmFyeVJlYWRlcikge1xuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBSZWFkZXIoYnVmZmVyKTtcbiAgICByZXR1cm4gZGVzZXJpYWxpemVTdHJ1Y3Qoc2NoZW1hLCBjbGFzc1R5cGUsIHJlYWRlcik7XG59XG5leHBvcnRzLmRlc2VyaWFsaXplVW5jaGVja2VkID0gZGVzZXJpYWxpemVVbmNoZWNrZWQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/borsh/lib/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/borsh/node_modules/bn.js/lib/bn.js":
/*!*********************************************************!*\
  !*** ./node_modules/borsh/node_modules/bn.js/lib/bn.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* module decorator */ module = __webpack_require__.nmd(module);\n(function (module, exports) {\n  'use strict';\n\n  // Utils\n  function assert (val, msg) {\n    if (!val) throw new Error(msg || 'Assertion failed');\n  }\n\n  // Could use `inherits` module, but don't want to move from single file\n  // architecture yet.\n  function inherits (ctor, superCtor) {\n    ctor.super_ = superCtor;\n    var TempCtor = function () {};\n    TempCtor.prototype = superCtor.prototype;\n    ctor.prototype = new TempCtor();\n    ctor.prototype.constructor = ctor;\n  }\n\n  // BN\n\n  function BN (number, base, endian) {\n    if (BN.isBN(number)) {\n      return number;\n    }\n\n    this.negative = 0;\n    this.words = null;\n    this.length = 0;\n\n    // Reduction context\n    this.red = null;\n\n    if (number !== null) {\n      if (base === 'le' || base === 'be') {\n        endian = base;\n        base = 10;\n      }\n\n      this._init(number || 0, base || 10, endian || 'be');\n    }\n  }\n  if (typeof module === 'object') {\n    module.exports = BN;\n  } else {\n    exports.BN = BN;\n  }\n\n  BN.BN = BN;\n  BN.wordSize = 26;\n\n  var Buffer;\n  try {\n    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {\n      Buffer = window.Buffer;\n    } else {\n      Buffer = (__webpack_require__(/*! buffer */ \"?dced\").Buffer);\n    }\n  } catch (e) {\n  }\n\n  BN.isBN = function isBN (num) {\n    if (num instanceof BN) {\n      return true;\n    }\n\n    return num !== null && typeof num === 'object' &&\n      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);\n  };\n\n  BN.max = function max (left, right) {\n    if (left.cmp(right) > 0) return left;\n    return right;\n  };\n\n  BN.min = function min (left, right) {\n    if (left.cmp(right) < 0) return left;\n    return right;\n  };\n\n  BN.prototype._init = function init (number, base, endian) {\n    if (typeof number === 'number') {\n      return this._initNumber(number, base, endian);\n    }\n\n    if (typeof number === 'object') {\n      return this._initArray(number, base, endian);\n    }\n\n    if (base === 'hex') {\n      base = 16;\n    }\n    assert(base === (base | 0) && base >= 2 && base <= 36);\n\n    number = number.toString().replace(/\\s+/g, '');\n    var start = 0;\n    if (number[0] === '-') {\n      start++;\n      this.negative = 1;\n    }\n\n    if (start < number.length) {\n      if (base === 16) {\n        this._parseHex(number, start, endian);\n      } else {\n        this._parseBase(number, base, start);\n        if (endian === 'le') {\n          this._initArray(this.toArray(), base, endian);\n        }\n      }\n    }\n  };\n\n  BN.prototype._initNumber = function _initNumber (number, base, endian) {\n    if (number < 0) {\n      this.negative = 1;\n      number = -number;\n    }\n    if (number < 0x4000000) {\n      this.words = [number & 0x3ffffff];\n      this.length = 1;\n    } else if (number < 0x10000000000000) {\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff\n      ];\n      this.length = 2;\n    } else {\n      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)\n      this.words = [\n        number & 0x3ffffff,\n        (number / 0x4000000) & 0x3ffffff,\n        1\n      ];\n      this.length = 3;\n    }\n\n    if (endian !== 'le') return;\n\n    // Reverse the bytes\n    this._initArray(this.toArray(), base, endian);\n  };\n\n  BN.prototype._initArray = function _initArray (number, base, endian) {\n    // Perhaps a Uint8Array\n    assert(typeof number.length === 'number');\n    if (number.length <= 0) {\n      this.words = [0];\n      this.length = 1;\n      return this;\n    }\n\n    this.length = Math.ceil(number.length / 3);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    var j, w;\n    var off = 0;\n    if (endian === 'be') {\n      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {\n        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    } else if (endian === 'le') {\n      for (i = 0, j = 0; i < number.length; i += 3) {\n        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);\n        this.words[j] |= (w << off) & 0x3ffffff;\n        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;\n        off += 24;\n        if (off >= 26) {\n          off -= 26;\n          j++;\n        }\n      }\n    }\n    return this._strip();\n  };\n\n  function parseHex4Bits (string, index) {\n    var c = string.charCodeAt(index);\n    // '0' - '9'\n    if (c >= 48 && c <= 57) {\n      return c - 48;\n    // 'A' - 'F'\n    } else if (c >= 65 && c <= 70) {\n      return c - 55;\n    // 'a' - 'f'\n    } else if (c >= 97 && c <= 102) {\n      return c - 87;\n    } else {\n      assert(false, 'Invalid character in ' + string);\n    }\n  }\n\n  function parseHexByte (string, lowerBound, index) {\n    var r = parseHex4Bits(string, index);\n    if (index - 1 >= lowerBound) {\n      r |= parseHex4Bits(string, index - 1) << 4;\n    }\n    return r;\n  }\n\n  BN.prototype._parseHex = function _parseHex (number, start, endian) {\n    // Create possibly bigger array to ensure that it fits the number\n    this.length = Math.ceil((number.length - start) / 6);\n    this.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      this.words[i] = 0;\n    }\n\n    // 24-bits chunks\n    var off = 0;\n    var j = 0;\n\n    var w;\n    if (endian === 'be') {\n      for (i = number.length - 1; i >= start; i -= 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    } else {\n      var parseLength = number.length - start;\n      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {\n        w = parseHexByte(number, start, i) << off;\n        this.words[j] |= w & 0x3ffffff;\n        if (off >= 18) {\n          off -= 18;\n          j += 1;\n          this.words[j] |= w >>> 26;\n        } else {\n          off += 8;\n        }\n      }\n    }\n\n    this._strip();\n  };\n\n  function parseBase (str, start, end, mul) {\n    var r = 0;\n    var b = 0;\n    var len = Math.min(str.length, end);\n    for (var i = start; i < len; i++) {\n      var c = str.charCodeAt(i) - 48;\n\n      r *= mul;\n\n      // 'a'\n      if (c >= 49) {\n        b = c - 49 + 0xa;\n\n      // 'A'\n      } else if (c >= 17) {\n        b = c - 17 + 0xa;\n\n      // '0' - '9'\n      } else {\n        b = c;\n      }\n      assert(c >= 0 && b < mul, 'Invalid character');\n      r += b;\n    }\n    return r;\n  }\n\n  BN.prototype._parseBase = function _parseBase (number, base, start) {\n    // Initialize as zero\n    this.words = [0];\n    this.length = 1;\n\n    // Find length of limb in base\n    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {\n      limbLen++;\n    }\n    limbLen--;\n    limbPow = (limbPow / base) | 0;\n\n    var total = number.length - start;\n    var mod = total % limbLen;\n    var end = Math.min(total, total - mod) + start;\n\n    var word = 0;\n    for (var i = start; i < end; i += limbLen) {\n      word = parseBase(number, i, i + limbLen, base);\n\n      this.imuln(limbPow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    if (mod !== 0) {\n      var pow = 1;\n      word = parseBase(number, i, number.length, base);\n\n      for (i = 0; i < mod; i++) {\n        pow *= base;\n      }\n\n      this.imuln(pow);\n      if (this.words[0] + word < 0x4000000) {\n        this.words[0] += word;\n      } else {\n        this._iaddn(word);\n      }\n    }\n\n    this._strip();\n  };\n\n  BN.prototype.copy = function copy (dest) {\n    dest.words = new Array(this.length);\n    for (var i = 0; i < this.length; i++) {\n      dest.words[i] = this.words[i];\n    }\n    dest.length = this.length;\n    dest.negative = this.negative;\n    dest.red = this.red;\n  };\n\n  function move (dest, src) {\n    dest.words = src.words;\n    dest.length = src.length;\n    dest.negative = src.negative;\n    dest.red = src.red;\n  }\n\n  BN.prototype._move = function _move (dest) {\n    move(dest, this);\n  };\n\n  BN.prototype.clone = function clone () {\n    var r = new BN(null);\n    this.copy(r);\n    return r;\n  };\n\n  BN.prototype._expand = function _expand (size) {\n    while (this.length < size) {\n      this.words[this.length++] = 0;\n    }\n    return this;\n  };\n\n  // Remove leading `0` from `this`\n  BN.prototype._strip = function strip () {\n    while (this.length > 1 && this.words[this.length - 1] === 0) {\n      this.length--;\n    }\n    return this._normSign();\n  };\n\n  BN.prototype._normSign = function _normSign () {\n    // -0 = 0\n    if (this.length === 1 && this.words[0] === 0) {\n      this.negative = 0;\n    }\n    return this;\n  };\n\n  // Check Symbol.for because not everywhere where Symbol defined\n  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility\n  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {\n    try {\n      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;\n    } catch (e) {\n      BN.prototype.inspect = inspect;\n    }\n  } else {\n    BN.prototype.inspect = inspect;\n  }\n\n  function inspect () {\n    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';\n  }\n\n  /*\n\n  var zeros = [];\n  var groupSizes = [];\n  var groupBases = [];\n\n  var s = '';\n  var i = -1;\n  while (++i < BN.wordSize) {\n    zeros[i] = s;\n    s += '0';\n  }\n  groupSizes[0] = 0;\n  groupSizes[1] = 0;\n  groupBases[0] = 0;\n  groupBases[1] = 0;\n  var base = 2 - 1;\n  while (++base < 36 + 1) {\n    var groupSize = 0;\n    var groupBase = 1;\n    while (groupBase < (1 << BN.wordSize) / base) {\n      groupBase *= base;\n      groupSize += 1;\n    }\n    groupSizes[base] = groupSize;\n    groupBases[base] = groupBase;\n  }\n\n  */\n\n  var zeros = [\n    '',\n    '0',\n    '00',\n    '000',\n    '0000',\n    '00000',\n    '000000',\n    '0000000',\n    '00000000',\n    '000000000',\n    '0000000000',\n    '00000000000',\n    '000000000000',\n    '0000000000000',\n    '00000000000000',\n    '000000000000000',\n    '0000000000000000',\n    '00000000000000000',\n    '000000000000000000',\n    '0000000000000000000',\n    '00000000000000000000',\n    '000000000000000000000',\n    '0000000000000000000000',\n    '00000000000000000000000',\n    '000000000000000000000000',\n    '0000000000000000000000000'\n  ];\n\n  var groupSizes = [\n    0, 0,\n    25, 16, 12, 11, 10, 9, 8,\n    8, 7, 7, 7, 7, 6, 6,\n    6, 6, 6, 6, 6, 5, 5,\n    5, 5, 5, 5, 5, 5, 5,\n    5, 5, 5, 5, 5, 5, 5\n  ];\n\n  var groupBases = [\n    0, 0,\n    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,\n    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,\n    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,\n    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,\n    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176\n  ];\n\n  BN.prototype.toString = function toString (base, padding) {\n    base = base || 10;\n    padding = padding | 0 || 1;\n\n    var out;\n    if (base === 16 || base === 'hex') {\n      out = '';\n      var off = 0;\n      var carry = 0;\n      for (var i = 0; i < this.length; i++) {\n        var w = this.words[i];\n        var word = (((w << off) | carry) & 0xffffff).toString(16);\n        carry = (w >>> (24 - off)) & 0xffffff;\n        off += 2;\n        if (off >= 26) {\n          off -= 26;\n          i--;\n        }\n        if (carry !== 0 || i !== this.length - 1) {\n          out = zeros[6 - word.length] + word + out;\n        } else {\n          out = word + out;\n        }\n      }\n      if (carry !== 0) {\n        out = carry.toString(16) + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    if (base === (base | 0) && base >= 2 && base <= 36) {\n      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));\n      var groupSize = groupSizes[base];\n      // var groupBase = Math.pow(base, groupSize);\n      var groupBase = groupBases[base];\n      out = '';\n      var c = this.clone();\n      c.negative = 0;\n      while (!c.isZero()) {\n        var r = c.modrn(groupBase).toString(base);\n        c = c.idivn(groupBase);\n\n        if (!c.isZero()) {\n          out = zeros[groupSize - r.length] + r + out;\n        } else {\n          out = r + out;\n        }\n      }\n      if (this.isZero()) {\n        out = '0' + out;\n      }\n      while (out.length % padding !== 0) {\n        out = '0' + out;\n      }\n      if (this.negative !== 0) {\n        out = '-' + out;\n      }\n      return out;\n    }\n\n    assert(false, 'Base should be between 2 and 36');\n  };\n\n  BN.prototype.toNumber = function toNumber () {\n    var ret = this.words[0];\n    if (this.length === 2) {\n      ret += this.words[1] * 0x4000000;\n    } else if (this.length === 3 && this.words[2] === 0x01) {\n      // NOTE: at this stage it is known that the top bit is set\n      ret += 0x10000000000000 + (this.words[1] * 0x4000000);\n    } else if (this.length > 2) {\n      assert(false, 'Number can only safely store up to 53 bits');\n    }\n    return (this.negative !== 0) ? -ret : ret;\n  };\n\n  BN.prototype.toJSON = function toJSON () {\n    return this.toString(16, 2);\n  };\n\n  if (Buffer) {\n    BN.prototype.toBuffer = function toBuffer (endian, length) {\n      return this.toArrayLike(Buffer, endian, length);\n    };\n  }\n\n  BN.prototype.toArray = function toArray (endian, length) {\n    return this.toArrayLike(Array, endian, length);\n  };\n\n  var allocate = function allocate (ArrayType, size) {\n    if (ArrayType.allocUnsafe) {\n      return ArrayType.allocUnsafe(size);\n    }\n    return new ArrayType(size);\n  };\n\n  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {\n    this._strip();\n\n    var byteLength = this.byteLength();\n    var reqLength = length || Math.max(1, byteLength);\n    assert(byteLength <= reqLength, 'byte array longer than desired length');\n    assert(reqLength > 0, 'Requested array length <= 0');\n\n    var res = allocate(ArrayType, reqLength);\n    var postfix = endian === 'le' ? 'LE' : 'BE';\n    this['_toArrayLike' + postfix](res, byteLength);\n    return res;\n  };\n\n  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {\n    var position = 0;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position++] = word & 0xff;\n      if (position < res.length) {\n        res[position++] = (word >> 8) & 0xff;\n      }\n      if (position < res.length) {\n        res[position++] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position < res.length) {\n          res[position++] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position < res.length) {\n      res[position++] = carry;\n\n      while (position < res.length) {\n        res[position++] = 0;\n      }\n    }\n  };\n\n  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {\n    var position = res.length - 1;\n    var carry = 0;\n\n    for (var i = 0, shift = 0; i < this.length; i++) {\n      var word = (this.words[i] << shift) | carry;\n\n      res[position--] = word & 0xff;\n      if (position >= 0) {\n        res[position--] = (word >> 8) & 0xff;\n      }\n      if (position >= 0) {\n        res[position--] = (word >> 16) & 0xff;\n      }\n\n      if (shift === 6) {\n        if (position >= 0) {\n          res[position--] = (word >> 24) & 0xff;\n        }\n        carry = 0;\n        shift = 0;\n      } else {\n        carry = word >>> 24;\n        shift += 2;\n      }\n    }\n\n    if (position >= 0) {\n      res[position--] = carry;\n\n      while (position >= 0) {\n        res[position--] = 0;\n      }\n    }\n  };\n\n  if (Math.clz32) {\n    BN.prototype._countBits = function _countBits (w) {\n      return 32 - Math.clz32(w);\n    };\n  } else {\n    BN.prototype._countBits = function _countBits (w) {\n      var t = w;\n      var r = 0;\n      if (t >= 0x1000) {\n        r += 13;\n        t >>>= 13;\n      }\n      if (t >= 0x40) {\n        r += 7;\n        t >>>= 7;\n      }\n      if (t >= 0x8) {\n        r += 4;\n        t >>>= 4;\n      }\n      if (t >= 0x02) {\n        r += 2;\n        t >>>= 2;\n      }\n      return r + t;\n    };\n  }\n\n  BN.prototype._zeroBits = function _zeroBits (w) {\n    // Short-cut\n    if (w === 0) return 26;\n\n    var t = w;\n    var r = 0;\n    if ((t & 0x1fff) === 0) {\n      r += 13;\n      t >>>= 13;\n    }\n    if ((t & 0x7f) === 0) {\n      r += 7;\n      t >>>= 7;\n    }\n    if ((t & 0xf) === 0) {\n      r += 4;\n      t >>>= 4;\n    }\n    if ((t & 0x3) === 0) {\n      r += 2;\n      t >>>= 2;\n    }\n    if ((t & 0x1) === 0) {\n      r++;\n    }\n    return r;\n  };\n\n  // Return number of used bits in a BN\n  BN.prototype.bitLength = function bitLength () {\n    var w = this.words[this.length - 1];\n    var hi = this._countBits(w);\n    return (this.length - 1) * 26 + hi;\n  };\n\n  function toBitArray (num) {\n    var w = new Array(num.bitLength());\n\n    for (var bit = 0; bit < w.length; bit++) {\n      var off = (bit / 26) | 0;\n      var wbit = bit % 26;\n\n      w[bit] = (num.words[off] >>> wbit) & 0x01;\n    }\n\n    return w;\n  }\n\n  // Number of trailing zero bits\n  BN.prototype.zeroBits = function zeroBits () {\n    if (this.isZero()) return 0;\n\n    var r = 0;\n    for (var i = 0; i < this.length; i++) {\n      var b = this._zeroBits(this.words[i]);\n      r += b;\n      if (b !== 26) break;\n    }\n    return r;\n  };\n\n  BN.prototype.byteLength = function byteLength () {\n    return Math.ceil(this.bitLength() / 8);\n  };\n\n  BN.prototype.toTwos = function toTwos (width) {\n    if (this.negative !== 0) {\n      return this.abs().inotn(width).iaddn(1);\n    }\n    return this.clone();\n  };\n\n  BN.prototype.fromTwos = function fromTwos (width) {\n    if (this.testn(width - 1)) {\n      return this.notn(width).iaddn(1).ineg();\n    }\n    return this.clone();\n  };\n\n  BN.prototype.isNeg = function isNeg () {\n    return this.negative !== 0;\n  };\n\n  // Return negative clone of `this`\n  BN.prototype.neg = function neg () {\n    return this.clone().ineg();\n  };\n\n  BN.prototype.ineg = function ineg () {\n    if (!this.isZero()) {\n      this.negative ^= 1;\n    }\n\n    return this;\n  };\n\n  // Or `num` with `this` in-place\n  BN.prototype.iuor = function iuor (num) {\n    while (this.length < num.length) {\n      this.words[this.length++] = 0;\n    }\n\n    for (var i = 0; i < num.length; i++) {\n      this.words[i] = this.words[i] | num.words[i];\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ior = function ior (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuor(num);\n  };\n\n  // Or `num` with `this`\n  BN.prototype.or = function or (num) {\n    if (this.length > num.length) return this.clone().ior(num);\n    return num.clone().ior(this);\n  };\n\n  BN.prototype.uor = function uor (num) {\n    if (this.length > num.length) return this.clone().iuor(num);\n    return num.clone().iuor(this);\n  };\n\n  // And `num` with `this` in-place\n  BN.prototype.iuand = function iuand (num) {\n    // b = min-length(num, this)\n    var b;\n    if (this.length > num.length) {\n      b = num;\n    } else {\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = this.words[i] & num.words[i];\n    }\n\n    this.length = b.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.iand = function iand (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuand(num);\n  };\n\n  // And `num` with `this`\n  BN.prototype.and = function and (num) {\n    if (this.length > num.length) return this.clone().iand(num);\n    return num.clone().iand(this);\n  };\n\n  BN.prototype.uand = function uand (num) {\n    if (this.length > num.length) return this.clone().iuand(num);\n    return num.clone().iuand(this);\n  };\n\n  // Xor `num` with `this` in-place\n  BN.prototype.iuxor = function iuxor (num) {\n    // a.length > b.length\n    var a;\n    var b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    for (var i = 0; i < b.length; i++) {\n      this.words[i] = a.words[i] ^ b.words[i];\n    }\n\n    if (this !== a) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = a.length;\n\n    return this._strip();\n  };\n\n  BN.prototype.ixor = function ixor (num) {\n    assert((this.negative | num.negative) === 0);\n    return this.iuxor(num);\n  };\n\n  // Xor `num` with `this`\n  BN.prototype.xor = function xor (num) {\n    if (this.length > num.length) return this.clone().ixor(num);\n    return num.clone().ixor(this);\n  };\n\n  BN.prototype.uxor = function uxor (num) {\n    if (this.length > num.length) return this.clone().iuxor(num);\n    return num.clone().iuxor(this);\n  };\n\n  // Not ``this`` with ``width`` bitwidth\n  BN.prototype.inotn = function inotn (width) {\n    assert(typeof width === 'number' && width >= 0);\n\n    var bytesNeeded = Math.ceil(width / 26) | 0;\n    var bitsLeft = width % 26;\n\n    // Extend the buffer with leading zeroes\n    this._expand(bytesNeeded);\n\n    if (bitsLeft > 0) {\n      bytesNeeded--;\n    }\n\n    // Handle complete words\n    for (var i = 0; i < bytesNeeded; i++) {\n      this.words[i] = ~this.words[i] & 0x3ffffff;\n    }\n\n    // Handle the residue\n    if (bitsLeft > 0) {\n      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));\n    }\n\n    // And remove leading zeroes\n    return this._strip();\n  };\n\n  BN.prototype.notn = function notn (width) {\n    return this.clone().inotn(width);\n  };\n\n  // Set `bit` of `this`\n  BN.prototype.setn = function setn (bit, val) {\n    assert(typeof bit === 'number' && bit >= 0);\n\n    var off = (bit / 26) | 0;\n    var wbit = bit % 26;\n\n    this._expand(off + 1);\n\n    if (val) {\n      this.words[off] = this.words[off] | (1 << wbit);\n    } else {\n      this.words[off] = this.words[off] & ~(1 << wbit);\n    }\n\n    return this._strip();\n  };\n\n  // Add `num` to `this` in-place\n  BN.prototype.iadd = function iadd (num) {\n    var r;\n\n    // negative + positive\n    if (this.negative !== 0 && num.negative === 0) {\n      this.negative = 0;\n      r = this.isub(num);\n      this.negative ^= 1;\n      return this._normSign();\n\n    // positive + negative\n    } else if (this.negative === 0 && num.negative !== 0) {\n      num.negative = 0;\n      r = this.isub(num);\n      num.negative = 1;\n      return r._normSign();\n    }\n\n    // a.length > b.length\n    var a, b;\n    if (this.length > num.length) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      this.words[i] = r & 0x3ffffff;\n      carry = r >>> 26;\n    }\n\n    this.length = a.length;\n    if (carry !== 0) {\n      this.words[this.length] = carry;\n      this.length++;\n    // Copy the rest of the words\n    } else if (a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    return this;\n  };\n\n  // Add `num` to `this`\n  BN.prototype.add = function add (num) {\n    var res;\n    if (num.negative !== 0 && this.negative === 0) {\n      num.negative = 0;\n      res = this.sub(num);\n      num.negative ^= 1;\n      return res;\n    } else if (num.negative === 0 && this.negative !== 0) {\n      this.negative = 0;\n      res = num.sub(this);\n      this.negative = 1;\n      return res;\n    }\n\n    if (this.length > num.length) return this.clone().iadd(num);\n\n    return num.clone().iadd(this);\n  };\n\n  // Subtract `num` from `this` in-place\n  BN.prototype.isub = function isub (num) {\n    // this - (-num) = this + num\n    if (num.negative !== 0) {\n      num.negative = 0;\n      var r = this.iadd(num);\n      num.negative = 1;\n      return r._normSign();\n\n    // -this - num = -(this + num)\n    } else if (this.negative !== 0) {\n      this.negative = 0;\n      this.iadd(num);\n      this.negative = 1;\n      return this._normSign();\n    }\n\n    // At this point both numbers are positive\n    var cmp = this.cmp(num);\n\n    // Optimization - zeroify\n    if (cmp === 0) {\n      this.negative = 0;\n      this.length = 1;\n      this.words[0] = 0;\n      return this;\n    }\n\n    // a > b\n    var a, b;\n    if (cmp > 0) {\n      a = this;\n      b = num;\n    } else {\n      a = num;\n      b = this;\n    }\n\n    var carry = 0;\n    for (var i = 0; i < b.length; i++) {\n      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n    for (; carry !== 0 && i < a.length; i++) {\n      r = (a.words[i] | 0) + carry;\n      carry = r >> 26;\n      this.words[i] = r & 0x3ffffff;\n    }\n\n    // Copy rest of the words\n    if (carry === 0 && i < a.length && a !== this) {\n      for (; i < a.length; i++) {\n        this.words[i] = a.words[i];\n      }\n    }\n\n    this.length = Math.max(this.length, i);\n\n    if (a !== this) {\n      this.negative = 1;\n    }\n\n    return this._strip();\n  };\n\n  // Subtract `num` from `this`\n  BN.prototype.sub = function sub (num) {\n    return this.clone().isub(num);\n  };\n\n  function smallMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    var len = (self.length + num.length) | 0;\n    out.length = len;\n    len = (len - 1) | 0;\n\n    // Peel one iteration (compiler can't do it, because of code complexity)\n    var a = self.words[0] | 0;\n    var b = num.words[0] | 0;\n    var r = a * b;\n\n    var lo = r & 0x3ffffff;\n    var carry = (r / 0x4000000) | 0;\n    out.words[0] = lo;\n\n    for (var k = 1; k < len; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = carry >>> 26;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = (k - j) | 0;\n        a = self.words[i] | 0;\n        b = num.words[j] | 0;\n        r = a * b + rword;\n        ncarry += (r / 0x4000000) | 0;\n        rword = r & 0x3ffffff;\n      }\n      out.words[k] = rword | 0;\n      carry = ncarry | 0;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry | 0;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  // TODO(indutny): it may be reasonable to omit it for users who don't need\n  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit\n  // multiplication (like elliptic secp256k1).\n  var comb10MulTo = function comb10MulTo (self, num, out) {\n    var a = self.words;\n    var b = num.words;\n    var o = out.words;\n    var c = 0;\n    var lo;\n    var mid;\n    var hi;\n    var a0 = a[0] | 0;\n    var al0 = a0 & 0x1fff;\n    var ah0 = a0 >>> 13;\n    var a1 = a[1] | 0;\n    var al1 = a1 & 0x1fff;\n    var ah1 = a1 >>> 13;\n    var a2 = a[2] | 0;\n    var al2 = a2 & 0x1fff;\n    var ah2 = a2 >>> 13;\n    var a3 = a[3] | 0;\n    var al3 = a3 & 0x1fff;\n    var ah3 = a3 >>> 13;\n    var a4 = a[4] | 0;\n    var al4 = a4 & 0x1fff;\n    var ah4 = a4 >>> 13;\n    var a5 = a[5] | 0;\n    var al5 = a5 & 0x1fff;\n    var ah5 = a5 >>> 13;\n    var a6 = a[6] | 0;\n    var al6 = a6 & 0x1fff;\n    var ah6 = a6 >>> 13;\n    var a7 = a[7] | 0;\n    var al7 = a7 & 0x1fff;\n    var ah7 = a7 >>> 13;\n    var a8 = a[8] | 0;\n    var al8 = a8 & 0x1fff;\n    var ah8 = a8 >>> 13;\n    var a9 = a[9] | 0;\n    var al9 = a9 & 0x1fff;\n    var ah9 = a9 >>> 13;\n    var b0 = b[0] | 0;\n    var bl0 = b0 & 0x1fff;\n    var bh0 = b0 >>> 13;\n    var b1 = b[1] | 0;\n    var bl1 = b1 & 0x1fff;\n    var bh1 = b1 >>> 13;\n    var b2 = b[2] | 0;\n    var bl2 = b2 & 0x1fff;\n    var bh2 = b2 >>> 13;\n    var b3 = b[3] | 0;\n    var bl3 = b3 & 0x1fff;\n    var bh3 = b3 >>> 13;\n    var b4 = b[4] | 0;\n    var bl4 = b4 & 0x1fff;\n    var bh4 = b4 >>> 13;\n    var b5 = b[5] | 0;\n    var bl5 = b5 & 0x1fff;\n    var bh5 = b5 >>> 13;\n    var b6 = b[6] | 0;\n    var bl6 = b6 & 0x1fff;\n    var bh6 = b6 >>> 13;\n    var b7 = b[7] | 0;\n    var bl7 = b7 & 0x1fff;\n    var bh7 = b7 >>> 13;\n    var b8 = b[8] | 0;\n    var bl8 = b8 & 0x1fff;\n    var bh8 = b8 >>> 13;\n    var b9 = b[9] | 0;\n    var bl9 = b9 & 0x1fff;\n    var bh9 = b9 >>> 13;\n\n    out.negative = self.negative ^ num.negative;\n    out.length = 19;\n    /* k = 0 */\n    lo = Math.imul(al0, bl0);\n    mid = Math.imul(al0, bh0);\n    mid = (mid + Math.imul(ah0, bl0)) | 0;\n    hi = Math.imul(ah0, bh0);\n    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;\n    w0 &= 0x3ffffff;\n    /* k = 1 */\n    lo = Math.imul(al1, bl0);\n    mid = Math.imul(al1, bh0);\n    mid = (mid + Math.imul(ah1, bl0)) | 0;\n    hi = Math.imul(ah1, bh0);\n    lo = (lo + Math.imul(al0, bl1)) | 0;\n    mid = (mid + Math.imul(al0, bh1)) | 0;\n    mid = (mid + Math.imul(ah0, bl1)) | 0;\n    hi = (hi + Math.imul(ah0, bh1)) | 0;\n    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;\n    w1 &= 0x3ffffff;\n    /* k = 2 */\n    lo = Math.imul(al2, bl0);\n    mid = Math.imul(al2, bh0);\n    mid = (mid + Math.imul(ah2, bl0)) | 0;\n    hi = Math.imul(ah2, bh0);\n    lo = (lo + Math.imul(al1, bl1)) | 0;\n    mid = (mid + Math.imul(al1, bh1)) | 0;\n    mid = (mid + Math.imul(ah1, bl1)) | 0;\n    hi = (hi + Math.imul(ah1, bh1)) | 0;\n    lo = (lo + Math.imul(al0, bl2)) | 0;\n    mid = (mid + Math.imul(al0, bh2)) | 0;\n    mid = (mid + Math.imul(ah0, bl2)) | 0;\n    hi = (hi + Math.imul(ah0, bh2)) | 0;\n    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;\n    w2 &= 0x3ffffff;\n    /* k = 3 */\n    lo = Math.imul(al3, bl0);\n    mid = Math.imul(al3, bh0);\n    mid = (mid + Math.imul(ah3, bl0)) | 0;\n    hi = Math.imul(ah3, bh0);\n    lo = (lo + Math.imul(al2, bl1)) | 0;\n    mid = (mid + Math.imul(al2, bh1)) | 0;\n    mid = (mid + Math.imul(ah2, bl1)) | 0;\n    hi = (hi + Math.imul(ah2, bh1)) | 0;\n    lo = (lo + Math.imul(al1, bl2)) | 0;\n    mid = (mid + Math.imul(al1, bh2)) | 0;\n    mid = (mid + Math.imul(ah1, bl2)) | 0;\n    hi = (hi + Math.imul(ah1, bh2)) | 0;\n    lo = (lo + Math.imul(al0, bl3)) | 0;\n    mid = (mid + Math.imul(al0, bh3)) | 0;\n    mid = (mid + Math.imul(ah0, bl3)) | 0;\n    hi = (hi + Math.imul(ah0, bh3)) | 0;\n    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;\n    w3 &= 0x3ffffff;\n    /* k = 4 */\n    lo = Math.imul(al4, bl0);\n    mid = Math.imul(al4, bh0);\n    mid = (mid + Math.imul(ah4, bl0)) | 0;\n    hi = Math.imul(ah4, bh0);\n    lo = (lo + Math.imul(al3, bl1)) | 0;\n    mid = (mid + Math.imul(al3, bh1)) | 0;\n    mid = (mid + Math.imul(ah3, bl1)) | 0;\n    hi = (hi + Math.imul(ah3, bh1)) | 0;\n    lo = (lo + Math.imul(al2, bl2)) | 0;\n    mid = (mid + Math.imul(al2, bh2)) | 0;\n    mid = (mid + Math.imul(ah2, bl2)) | 0;\n    hi = (hi + Math.imul(ah2, bh2)) | 0;\n    lo = (lo + Math.imul(al1, bl3)) | 0;\n    mid = (mid + Math.imul(al1, bh3)) | 0;\n    mid = (mid + Math.imul(ah1, bl3)) | 0;\n    hi = (hi + Math.imul(ah1, bh3)) | 0;\n    lo = (lo + Math.imul(al0, bl4)) | 0;\n    mid = (mid + Math.imul(al0, bh4)) | 0;\n    mid = (mid + Math.imul(ah0, bl4)) | 0;\n    hi = (hi + Math.imul(ah0, bh4)) | 0;\n    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;\n    w4 &= 0x3ffffff;\n    /* k = 5 */\n    lo = Math.imul(al5, bl0);\n    mid = Math.imul(al5, bh0);\n    mid = (mid + Math.imul(ah5, bl0)) | 0;\n    hi = Math.imul(ah5, bh0);\n    lo = (lo + Math.imul(al4, bl1)) | 0;\n    mid = (mid + Math.imul(al4, bh1)) | 0;\n    mid = (mid + Math.imul(ah4, bl1)) | 0;\n    hi = (hi + Math.imul(ah4, bh1)) | 0;\n    lo = (lo + Math.imul(al3, bl2)) | 0;\n    mid = (mid + Math.imul(al3, bh2)) | 0;\n    mid = (mid + Math.imul(ah3, bl2)) | 0;\n    hi = (hi + Math.imul(ah3, bh2)) | 0;\n    lo = (lo + Math.imul(al2, bl3)) | 0;\n    mid = (mid + Math.imul(al2, bh3)) | 0;\n    mid = (mid + Math.imul(ah2, bl3)) | 0;\n    hi = (hi + Math.imul(ah2, bh3)) | 0;\n    lo = (lo + Math.imul(al1, bl4)) | 0;\n    mid = (mid + Math.imul(al1, bh4)) | 0;\n    mid = (mid + Math.imul(ah1, bl4)) | 0;\n    hi = (hi + Math.imul(ah1, bh4)) | 0;\n    lo = (lo + Math.imul(al0, bl5)) | 0;\n    mid = (mid + Math.imul(al0, bh5)) | 0;\n    mid = (mid + Math.imul(ah0, bl5)) | 0;\n    hi = (hi + Math.imul(ah0, bh5)) | 0;\n    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;\n    w5 &= 0x3ffffff;\n    /* k = 6 */\n    lo = Math.imul(al6, bl0);\n    mid = Math.imul(al6, bh0);\n    mid = (mid + Math.imul(ah6, bl0)) | 0;\n    hi = Math.imul(ah6, bh0);\n    lo = (lo + Math.imul(al5, bl1)) | 0;\n    mid = (mid + Math.imul(al5, bh1)) | 0;\n    mid = (mid + Math.imul(ah5, bl1)) | 0;\n    hi = (hi + Math.imul(ah5, bh1)) | 0;\n    lo = (lo + Math.imul(al4, bl2)) | 0;\n    mid = (mid + Math.imul(al4, bh2)) | 0;\n    mid = (mid + Math.imul(ah4, bl2)) | 0;\n    hi = (hi + Math.imul(ah4, bh2)) | 0;\n    lo = (lo + Math.imul(al3, bl3)) | 0;\n    mid = (mid + Math.imul(al3, bh3)) | 0;\n    mid = (mid + Math.imul(ah3, bl3)) | 0;\n    hi = (hi + Math.imul(ah3, bh3)) | 0;\n    lo = (lo + Math.imul(al2, bl4)) | 0;\n    mid = (mid + Math.imul(al2, bh4)) | 0;\n    mid = (mid + Math.imul(ah2, bl4)) | 0;\n    hi = (hi + Math.imul(ah2, bh4)) | 0;\n    lo = (lo + Math.imul(al1, bl5)) | 0;\n    mid = (mid + Math.imul(al1, bh5)) | 0;\n    mid = (mid + Math.imul(ah1, bl5)) | 0;\n    hi = (hi + Math.imul(ah1, bh5)) | 0;\n    lo = (lo + Math.imul(al0, bl6)) | 0;\n    mid = (mid + Math.imul(al0, bh6)) | 0;\n    mid = (mid + Math.imul(ah0, bl6)) | 0;\n    hi = (hi + Math.imul(ah0, bh6)) | 0;\n    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;\n    w6 &= 0x3ffffff;\n    /* k = 7 */\n    lo = Math.imul(al7, bl0);\n    mid = Math.imul(al7, bh0);\n    mid = (mid + Math.imul(ah7, bl0)) | 0;\n    hi = Math.imul(ah7, bh0);\n    lo = (lo + Math.imul(al6, bl1)) | 0;\n    mid = (mid + Math.imul(al6, bh1)) | 0;\n    mid = (mid + Math.imul(ah6, bl1)) | 0;\n    hi = (hi + Math.imul(ah6, bh1)) | 0;\n    lo = (lo + Math.imul(al5, bl2)) | 0;\n    mid = (mid + Math.imul(al5, bh2)) | 0;\n    mid = (mid + Math.imul(ah5, bl2)) | 0;\n    hi = (hi + Math.imul(ah5, bh2)) | 0;\n    lo = (lo + Math.imul(al4, bl3)) | 0;\n    mid = (mid + Math.imul(al4, bh3)) | 0;\n    mid = (mid + Math.imul(ah4, bl3)) | 0;\n    hi = (hi + Math.imul(ah4, bh3)) | 0;\n    lo = (lo + Math.imul(al3, bl4)) | 0;\n    mid = (mid + Math.imul(al3, bh4)) | 0;\n    mid = (mid + Math.imul(ah3, bl4)) | 0;\n    hi = (hi + Math.imul(ah3, bh4)) | 0;\n    lo = (lo + Math.imul(al2, bl5)) | 0;\n    mid = (mid + Math.imul(al2, bh5)) | 0;\n    mid = (mid + Math.imul(ah2, bl5)) | 0;\n    hi = (hi + Math.imul(ah2, bh5)) | 0;\n    lo = (lo + Math.imul(al1, bl6)) | 0;\n    mid = (mid + Math.imul(al1, bh6)) | 0;\n    mid = (mid + Math.imul(ah1, bl6)) | 0;\n    hi = (hi + Math.imul(ah1, bh6)) | 0;\n    lo = (lo + Math.imul(al0, bl7)) | 0;\n    mid = (mid + Math.imul(al0, bh7)) | 0;\n    mid = (mid + Math.imul(ah0, bl7)) | 0;\n    hi = (hi + Math.imul(ah0, bh7)) | 0;\n    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;\n    w7 &= 0x3ffffff;\n    /* k = 8 */\n    lo = Math.imul(al8, bl0);\n    mid = Math.imul(al8, bh0);\n    mid = (mid + Math.imul(ah8, bl0)) | 0;\n    hi = Math.imul(ah8, bh0);\n    lo = (lo + Math.imul(al7, bl1)) | 0;\n    mid = (mid + Math.imul(al7, bh1)) | 0;\n    mid = (mid + Math.imul(ah7, bl1)) | 0;\n    hi = (hi + Math.imul(ah7, bh1)) | 0;\n    lo = (lo + Math.imul(al6, bl2)) | 0;\n    mid = (mid + Math.imul(al6, bh2)) | 0;\n    mid = (mid + Math.imul(ah6, bl2)) | 0;\n    hi = (hi + Math.imul(ah6, bh2)) | 0;\n    lo = (lo + Math.imul(al5, bl3)) | 0;\n    mid = (mid + Math.imul(al5, bh3)) | 0;\n    mid = (mid + Math.imul(ah5, bl3)) | 0;\n    hi = (hi + Math.imul(ah5, bh3)) | 0;\n    lo = (lo + Math.imul(al4, bl4)) | 0;\n    mid = (mid + Math.imul(al4, bh4)) | 0;\n    mid = (mid + Math.imul(ah4, bl4)) | 0;\n    hi = (hi + Math.imul(ah4, bh4)) | 0;\n    lo = (lo + Math.imul(al3, bl5)) | 0;\n    mid = (mid + Math.imul(al3, bh5)) | 0;\n    mid = (mid + Math.imul(ah3, bl5)) | 0;\n    hi = (hi + Math.imul(ah3, bh5)) | 0;\n    lo = (lo + Math.imul(al2, bl6)) | 0;\n    mid = (mid + Math.imul(al2, bh6)) | 0;\n    mid = (mid + Math.imul(ah2, bl6)) | 0;\n    hi = (hi + Math.imul(ah2, bh6)) | 0;\n    lo = (lo + Math.imul(al1, bl7)) | 0;\n    mid = (mid + Math.imul(al1, bh7)) | 0;\n    mid = (mid + Math.imul(ah1, bl7)) | 0;\n    hi = (hi + Math.imul(ah1, bh7)) | 0;\n    lo = (lo + Math.imul(al0, bl8)) | 0;\n    mid = (mid + Math.imul(al0, bh8)) | 0;\n    mid = (mid + Math.imul(ah0, bl8)) | 0;\n    hi = (hi + Math.imul(ah0, bh8)) | 0;\n    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;\n    w8 &= 0x3ffffff;\n    /* k = 9 */\n    lo = Math.imul(al9, bl0);\n    mid = Math.imul(al9, bh0);\n    mid = (mid + Math.imul(ah9, bl0)) | 0;\n    hi = Math.imul(ah9, bh0);\n    lo = (lo + Math.imul(al8, bl1)) | 0;\n    mid = (mid + Math.imul(al8, bh1)) | 0;\n    mid = (mid + Math.imul(ah8, bl1)) | 0;\n    hi = (hi + Math.imul(ah8, bh1)) | 0;\n    lo = (lo + Math.imul(al7, bl2)) | 0;\n    mid = (mid + Math.imul(al7, bh2)) | 0;\n    mid = (mid + Math.imul(ah7, bl2)) | 0;\n    hi = (hi + Math.imul(ah7, bh2)) | 0;\n    lo = (lo + Math.imul(al6, bl3)) | 0;\n    mid = (mid + Math.imul(al6, bh3)) | 0;\n    mid = (mid + Math.imul(ah6, bl3)) | 0;\n    hi = (hi + Math.imul(ah6, bh3)) | 0;\n    lo = (lo + Math.imul(al5, bl4)) | 0;\n    mid = (mid + Math.imul(al5, bh4)) | 0;\n    mid = (mid + Math.imul(ah5, bl4)) | 0;\n    hi = (hi + Math.imul(ah5, bh4)) | 0;\n    lo = (lo + Math.imul(al4, bl5)) | 0;\n    mid = (mid + Math.imul(al4, bh5)) | 0;\n    mid = (mid + Math.imul(ah4, bl5)) | 0;\n    hi = (hi + Math.imul(ah4, bh5)) | 0;\n    lo = (lo + Math.imul(al3, bl6)) | 0;\n    mid = (mid + Math.imul(al3, bh6)) | 0;\n    mid = (mid + Math.imul(ah3, bl6)) | 0;\n    hi = (hi + Math.imul(ah3, bh6)) | 0;\n    lo = (lo + Math.imul(al2, bl7)) | 0;\n    mid = (mid + Math.imul(al2, bh7)) | 0;\n    mid = (mid + Math.imul(ah2, bl7)) | 0;\n    hi = (hi + Math.imul(ah2, bh7)) | 0;\n    lo = (lo + Math.imul(al1, bl8)) | 0;\n    mid = (mid + Math.imul(al1, bh8)) | 0;\n    mid = (mid + Math.imul(ah1, bl8)) | 0;\n    hi = (hi + Math.imul(ah1, bh8)) | 0;\n    lo = (lo + Math.imul(al0, bl9)) | 0;\n    mid = (mid + Math.imul(al0, bh9)) | 0;\n    mid = (mid + Math.imul(ah0, bl9)) | 0;\n    hi = (hi + Math.imul(ah0, bh9)) | 0;\n    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;\n    w9 &= 0x3ffffff;\n    /* k = 10 */\n    lo = Math.imul(al9, bl1);\n    mid = Math.imul(al9, bh1);\n    mid = (mid + Math.imul(ah9, bl1)) | 0;\n    hi = Math.imul(ah9, bh1);\n    lo = (lo + Math.imul(al8, bl2)) | 0;\n    mid = (mid + Math.imul(al8, bh2)) | 0;\n    mid = (mid + Math.imul(ah8, bl2)) | 0;\n    hi = (hi + Math.imul(ah8, bh2)) | 0;\n    lo = (lo + Math.imul(al7, bl3)) | 0;\n    mid = (mid + Math.imul(al7, bh3)) | 0;\n    mid = (mid + Math.imul(ah7, bl3)) | 0;\n    hi = (hi + Math.imul(ah7, bh3)) | 0;\n    lo = (lo + Math.imul(al6, bl4)) | 0;\n    mid = (mid + Math.imul(al6, bh4)) | 0;\n    mid = (mid + Math.imul(ah6, bl4)) | 0;\n    hi = (hi + Math.imul(ah6, bh4)) | 0;\n    lo = (lo + Math.imul(al5, bl5)) | 0;\n    mid = (mid + Math.imul(al5, bh5)) | 0;\n    mid = (mid + Math.imul(ah5, bl5)) | 0;\n    hi = (hi + Math.imul(ah5, bh5)) | 0;\n    lo = (lo + Math.imul(al4, bl6)) | 0;\n    mid = (mid + Math.imul(al4, bh6)) | 0;\n    mid = (mid + Math.imul(ah4, bl6)) | 0;\n    hi = (hi + Math.imul(ah4, bh6)) | 0;\n    lo = (lo + Math.imul(al3, bl7)) | 0;\n    mid = (mid + Math.imul(al3, bh7)) | 0;\n    mid = (mid + Math.imul(ah3, bl7)) | 0;\n    hi = (hi + Math.imul(ah3, bh7)) | 0;\n    lo = (lo + Math.imul(al2, bl8)) | 0;\n    mid = (mid + Math.imul(al2, bh8)) | 0;\n    mid = (mid + Math.imul(ah2, bl8)) | 0;\n    hi = (hi + Math.imul(ah2, bh8)) | 0;\n    lo = (lo + Math.imul(al1, bl9)) | 0;\n    mid = (mid + Math.imul(al1, bh9)) | 0;\n    mid = (mid + Math.imul(ah1, bl9)) | 0;\n    hi = (hi + Math.imul(ah1, bh9)) | 0;\n    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;\n    w10 &= 0x3ffffff;\n    /* k = 11 */\n    lo = Math.imul(al9, bl2);\n    mid = Math.imul(al9, bh2);\n    mid = (mid + Math.imul(ah9, bl2)) | 0;\n    hi = Math.imul(ah9, bh2);\n    lo = (lo + Math.imul(al8, bl3)) | 0;\n    mid = (mid + Math.imul(al8, bh3)) | 0;\n    mid = (mid + Math.imul(ah8, bl3)) | 0;\n    hi = (hi + Math.imul(ah8, bh3)) | 0;\n    lo = (lo + Math.imul(al7, bl4)) | 0;\n    mid = (mid + Math.imul(al7, bh4)) | 0;\n    mid = (mid + Math.imul(ah7, bl4)) | 0;\n    hi = (hi + Math.imul(ah7, bh4)) | 0;\n    lo = (lo + Math.imul(al6, bl5)) | 0;\n    mid = (mid + Math.imul(al6, bh5)) | 0;\n    mid = (mid + Math.imul(ah6, bl5)) | 0;\n    hi = (hi + Math.imul(ah6, bh5)) | 0;\n    lo = (lo + Math.imul(al5, bl6)) | 0;\n    mid = (mid + Math.imul(al5, bh6)) | 0;\n    mid = (mid + Math.imul(ah5, bl6)) | 0;\n    hi = (hi + Math.imul(ah5, bh6)) | 0;\n    lo = (lo + Math.imul(al4, bl7)) | 0;\n    mid = (mid + Math.imul(al4, bh7)) | 0;\n    mid = (mid + Math.imul(ah4, bl7)) | 0;\n    hi = (hi + Math.imul(ah4, bh7)) | 0;\n    lo = (lo + Math.imul(al3, bl8)) | 0;\n    mid = (mid + Math.imul(al3, bh8)) | 0;\n    mid = (mid + Math.imul(ah3, bl8)) | 0;\n    hi = (hi + Math.imul(ah3, bh8)) | 0;\n    lo = (lo + Math.imul(al2, bl9)) | 0;\n    mid = (mid + Math.imul(al2, bh9)) | 0;\n    mid = (mid + Math.imul(ah2, bl9)) | 0;\n    hi = (hi + Math.imul(ah2, bh9)) | 0;\n    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;\n    w11 &= 0x3ffffff;\n    /* k = 12 */\n    lo = Math.imul(al9, bl3);\n    mid = Math.imul(al9, bh3);\n    mid = (mid + Math.imul(ah9, bl3)) | 0;\n    hi = Math.imul(ah9, bh3);\n    lo = (lo + Math.imul(al8, bl4)) | 0;\n    mid = (mid + Math.imul(al8, bh4)) | 0;\n    mid = (mid + Math.imul(ah8, bl4)) | 0;\n    hi = (hi + Math.imul(ah8, bh4)) | 0;\n    lo = (lo + Math.imul(al7, bl5)) | 0;\n    mid = (mid + Math.imul(al7, bh5)) | 0;\n    mid = (mid + Math.imul(ah7, bl5)) | 0;\n    hi = (hi + Math.imul(ah7, bh5)) | 0;\n    lo = (lo + Math.imul(al6, bl6)) | 0;\n    mid = (mid + Math.imul(al6, bh6)) | 0;\n    mid = (mid + Math.imul(ah6, bl6)) | 0;\n    hi = (hi + Math.imul(ah6, bh6)) | 0;\n    lo = (lo + Math.imul(al5, bl7)) | 0;\n    mid = (mid + Math.imul(al5, bh7)) | 0;\n    mid = (mid + Math.imul(ah5, bl7)) | 0;\n    hi = (hi + Math.imul(ah5, bh7)) | 0;\n    lo = (lo + Math.imul(al4, bl8)) | 0;\n    mid = (mid + Math.imul(al4, bh8)) | 0;\n    mid = (mid + Math.imul(ah4, bl8)) | 0;\n    hi = (hi + Math.imul(ah4, bh8)) | 0;\n    lo = (lo + Math.imul(al3, bl9)) | 0;\n    mid = (mid + Math.imul(al3, bh9)) | 0;\n    mid = (mid + Math.imul(ah3, bl9)) | 0;\n    hi = (hi + Math.imul(ah3, bh9)) | 0;\n    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;\n    w12 &= 0x3ffffff;\n    /* k = 13 */\n    lo = Math.imul(al9, bl4);\n    mid = Math.imul(al9, bh4);\n    mid = (mid + Math.imul(ah9, bl4)) | 0;\n    hi = Math.imul(ah9, bh4);\n    lo = (lo + Math.imul(al8, bl5)) | 0;\n    mid = (mid + Math.imul(al8, bh5)) | 0;\n    mid = (mid + Math.imul(ah8, bl5)) | 0;\n    hi = (hi + Math.imul(ah8, bh5)) | 0;\n    lo = (lo + Math.imul(al7, bl6)) | 0;\n    mid = (mid + Math.imul(al7, bh6)) | 0;\n    mid = (mid + Math.imul(ah7, bl6)) | 0;\n    hi = (hi + Math.imul(ah7, bh6)) | 0;\n    lo = (lo + Math.imul(al6, bl7)) | 0;\n    mid = (mid + Math.imul(al6, bh7)) | 0;\n    mid = (mid + Math.imul(ah6, bl7)) | 0;\n    hi = (hi + Math.imul(ah6, bh7)) | 0;\n    lo = (lo + Math.imul(al5, bl8)) | 0;\n    mid = (mid + Math.imul(al5, bh8)) | 0;\n    mid = (mid + Math.imul(ah5, bl8)) | 0;\n    hi = (hi + Math.imul(ah5, bh8)) | 0;\n    lo = (lo + Math.imul(al4, bl9)) | 0;\n    mid = (mid + Math.imul(al4, bh9)) | 0;\n    mid = (mid + Math.imul(ah4, bl9)) | 0;\n    hi = (hi + Math.imul(ah4, bh9)) | 0;\n    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;\n    w13 &= 0x3ffffff;\n    /* k = 14 */\n    lo = Math.imul(al9, bl5);\n    mid = Math.imul(al9, bh5);\n    mid = (mid + Math.imul(ah9, bl5)) | 0;\n    hi = Math.imul(ah9, bh5);\n    lo = (lo + Math.imul(al8, bl6)) | 0;\n    mid = (mid + Math.imul(al8, bh6)) | 0;\n    mid = (mid + Math.imul(ah8, bl6)) | 0;\n    hi = (hi + Math.imul(ah8, bh6)) | 0;\n    lo = (lo + Math.imul(al7, bl7)) | 0;\n    mid = (mid + Math.imul(al7, bh7)) | 0;\n    mid = (mid + Math.imul(ah7, bl7)) | 0;\n    hi = (hi + Math.imul(ah7, bh7)) | 0;\n    lo = (lo + Math.imul(al6, bl8)) | 0;\n    mid = (mid + Math.imul(al6, bh8)) | 0;\n    mid = (mid + Math.imul(ah6, bl8)) | 0;\n    hi = (hi + Math.imul(ah6, bh8)) | 0;\n    lo = (lo + Math.imul(al5, bl9)) | 0;\n    mid = (mid + Math.imul(al5, bh9)) | 0;\n    mid = (mid + Math.imul(ah5, bl9)) | 0;\n    hi = (hi + Math.imul(ah5, bh9)) | 0;\n    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;\n    w14 &= 0x3ffffff;\n    /* k = 15 */\n    lo = Math.imul(al9, bl6);\n    mid = Math.imul(al9, bh6);\n    mid = (mid + Math.imul(ah9, bl6)) | 0;\n    hi = Math.imul(ah9, bh6);\n    lo = (lo + Math.imul(al8, bl7)) | 0;\n    mid = (mid + Math.imul(al8, bh7)) | 0;\n    mid = (mid + Math.imul(ah8, bl7)) | 0;\n    hi = (hi + Math.imul(ah8, bh7)) | 0;\n    lo = (lo + Math.imul(al7, bl8)) | 0;\n    mid = (mid + Math.imul(al7, bh8)) | 0;\n    mid = (mid + Math.imul(ah7, bl8)) | 0;\n    hi = (hi + Math.imul(ah7, bh8)) | 0;\n    lo = (lo + Math.imul(al6, bl9)) | 0;\n    mid = (mid + Math.imul(al6, bh9)) | 0;\n    mid = (mid + Math.imul(ah6, bl9)) | 0;\n    hi = (hi + Math.imul(ah6, bh9)) | 0;\n    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;\n    w15 &= 0x3ffffff;\n    /* k = 16 */\n    lo = Math.imul(al9, bl7);\n    mid = Math.imul(al9, bh7);\n    mid = (mid + Math.imul(ah9, bl7)) | 0;\n    hi = Math.imul(ah9, bh7);\n    lo = (lo + Math.imul(al8, bl8)) | 0;\n    mid = (mid + Math.imul(al8, bh8)) | 0;\n    mid = (mid + Math.imul(ah8, bl8)) | 0;\n    hi = (hi + Math.imul(ah8, bh8)) | 0;\n    lo = (lo + Math.imul(al7, bl9)) | 0;\n    mid = (mid + Math.imul(al7, bh9)) | 0;\n    mid = (mid + Math.imul(ah7, bl9)) | 0;\n    hi = (hi + Math.imul(ah7, bh9)) | 0;\n    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;\n    w16 &= 0x3ffffff;\n    /* k = 17 */\n    lo = Math.imul(al9, bl8);\n    mid = Math.imul(al9, bh8);\n    mid = (mid + Math.imul(ah9, bl8)) | 0;\n    hi = Math.imul(ah9, bh8);\n    lo = (lo + Math.imul(al8, bl9)) | 0;\n    mid = (mid + Math.imul(al8, bh9)) | 0;\n    mid = (mid + Math.imul(ah8, bl9)) | 0;\n    hi = (hi + Math.imul(ah8, bh9)) | 0;\n    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;\n    w17 &= 0x3ffffff;\n    /* k = 18 */\n    lo = Math.imul(al9, bl9);\n    mid = Math.imul(al9, bh9);\n    mid = (mid + Math.imul(ah9, bl9)) | 0;\n    hi = Math.imul(ah9, bh9);\n    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;\n    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;\n    w18 &= 0x3ffffff;\n    o[0] = w0;\n    o[1] = w1;\n    o[2] = w2;\n    o[3] = w3;\n    o[4] = w4;\n    o[5] = w5;\n    o[6] = w6;\n    o[7] = w7;\n    o[8] = w8;\n    o[9] = w9;\n    o[10] = w10;\n    o[11] = w11;\n    o[12] = w12;\n    o[13] = w13;\n    o[14] = w14;\n    o[15] = w15;\n    o[16] = w16;\n    o[17] = w17;\n    o[18] = w18;\n    if (c !== 0) {\n      o[19] = c;\n      out.length++;\n    }\n    return out;\n  };\n\n  // Polyfill comb\n  if (!Math.imul) {\n    comb10MulTo = smallMulTo;\n  }\n\n  function bigMulTo (self, num, out) {\n    out.negative = num.negative ^ self.negative;\n    out.length = self.length + num.length;\n\n    var carry = 0;\n    var hncarry = 0;\n    for (var k = 0; k < out.length - 1; k++) {\n      // Sum all words with the same `i + j = k` and accumulate `ncarry`,\n      // note that ncarry could be >= 0x3ffffff\n      var ncarry = hncarry;\n      hncarry = 0;\n      var rword = carry & 0x3ffffff;\n      var maxJ = Math.min(k, num.length - 1);\n      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n        var i = k - j;\n        var a = self.words[i] | 0;\n        var b = num.words[j] | 0;\n        var r = a * b;\n\n        var lo = r & 0x3ffffff;\n        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;\n        lo = (lo + rword) | 0;\n        rword = lo & 0x3ffffff;\n        ncarry = (ncarry + (lo >>> 26)) | 0;\n\n        hncarry += ncarry >>> 26;\n        ncarry &= 0x3ffffff;\n      }\n      out.words[k] = rword;\n      carry = ncarry;\n      ncarry = hncarry;\n    }\n    if (carry !== 0) {\n      out.words[k] = carry;\n    } else {\n      out.length--;\n    }\n\n    return out._strip();\n  }\n\n  function jumboMulTo (self, num, out) {\n    // Temporary disable, see https://github.com/indutny/bn.js/issues/211\n    // var fftm = new FFTM();\n    // return fftm.mulp(self, num, out);\n    return bigMulTo(self, num, out);\n  }\n\n  BN.prototype.mulTo = function mulTo (num, out) {\n    var res;\n    var len = this.length + num.length;\n    if (this.length === 10 && num.length === 10) {\n      res = comb10MulTo(this, num, out);\n    } else if (len < 63) {\n      res = smallMulTo(this, num, out);\n    } else if (len < 1024) {\n      res = bigMulTo(this, num, out);\n    } else {\n      res = jumboMulTo(this, num, out);\n    }\n\n    return res;\n  };\n\n  // Cooley-Tukey algorithm for FFT\n  // slightly revisited to rely on looping instead of recursion\n\n  function FFTM (x, y) {\n    this.x = x;\n    this.y = y;\n  }\n\n  FFTM.prototype.makeRBT = function makeRBT (N) {\n    var t = new Array(N);\n    var l = BN.prototype._countBits(N) - 1;\n    for (var i = 0; i < N; i++) {\n      t[i] = this.revBin(i, l, N);\n    }\n\n    return t;\n  };\n\n  // Returns binary-reversed representation of `x`\n  FFTM.prototype.revBin = function revBin (x, l, N) {\n    if (x === 0 || x === N - 1) return x;\n\n    var rb = 0;\n    for (var i = 0; i < l; i++) {\n      rb |= (x & 1) << (l - i - 1);\n      x >>= 1;\n    }\n\n    return rb;\n  };\n\n  // Performs \"tweedling\" phase, therefore 'emulating'\n  // behaviour of the recursive algorithm\n  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {\n    for (var i = 0; i < N; i++) {\n      rtws[i] = rws[rbt[i]];\n      itws[i] = iws[rbt[i]];\n    }\n  };\n\n  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {\n    this.permute(rbt, rws, iws, rtws, itws, N);\n\n    for (var s = 1; s < N; s <<= 1) {\n      var l = s << 1;\n\n      var rtwdf = Math.cos(2 * Math.PI / l);\n      var itwdf = Math.sin(2 * Math.PI / l);\n\n      for (var p = 0; p < N; p += l) {\n        var rtwdf_ = rtwdf;\n        var itwdf_ = itwdf;\n\n        for (var j = 0; j < s; j++) {\n          var re = rtws[p + j];\n          var ie = itws[p + j];\n\n          var ro = rtws[p + j + s];\n          var io = itws[p + j + s];\n\n          var rx = rtwdf_ * ro - itwdf_ * io;\n\n          io = rtwdf_ * io + itwdf_ * ro;\n          ro = rx;\n\n          rtws[p + j] = re + ro;\n          itws[p + j] = ie + io;\n\n          rtws[p + j + s] = re - ro;\n          itws[p + j + s] = ie - io;\n\n          /* jshint maxdepth : false */\n          if (j !== l) {\n            rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n\n            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n            rtwdf_ = rx;\n          }\n        }\n      }\n    }\n  };\n\n  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {\n    var N = Math.max(m, n) | 1;\n    var odd = N & 1;\n    var i = 0;\n    for (N = N / 2 | 0; N; N = N >>> 1) {\n      i++;\n    }\n\n    return 1 << i + 1 + odd;\n  };\n\n  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {\n    if (N <= 1) return;\n\n    for (var i = 0; i < N / 2; i++) {\n      var t = rws[i];\n\n      rws[i] = rws[N - i - 1];\n      rws[N - i - 1] = t;\n\n      t = iws[i];\n\n      iws[i] = -iws[N - i - 1];\n      iws[N - i - 1] = -t;\n    }\n  };\n\n  FFTM.prototype.normalize13b = function normalize13b (ws, N) {\n    var carry = 0;\n    for (var i = 0; i < N / 2; i++) {\n      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +\n        Math.round(ws[2 * i] / N) +\n        carry;\n\n      ws[i] = w & 0x3ffffff;\n\n      if (w < 0x4000000) {\n        carry = 0;\n      } else {\n        carry = w / 0x4000000 | 0;\n      }\n    }\n\n    return ws;\n  };\n\n  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {\n    var carry = 0;\n    for (var i = 0; i < len; i++) {\n      carry = carry + (ws[i] | 0);\n\n      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;\n      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;\n    }\n\n    // Pad with zeroes\n    for (i = 2 * len; i < N; ++i) {\n      rws[i] = 0;\n    }\n\n    assert(carry === 0);\n    assert((carry & ~0x1fff) === 0);\n  };\n\n  FFTM.prototype.stub = function stub (N) {\n    var ph = new Array(N);\n    for (var i = 0; i < N; i++) {\n      ph[i] = 0;\n    }\n\n    return ph;\n  };\n\n  FFTM.prototype.mulp = function mulp (x, y, out) {\n    var N = 2 * this.guessLen13b(x.length, y.length);\n\n    var rbt = this.makeRBT(N);\n\n    var _ = this.stub(N);\n\n    var rws = new Array(N);\n    var rwst = new Array(N);\n    var iwst = new Array(N);\n\n    var nrws = new Array(N);\n    var nrwst = new Array(N);\n    var niwst = new Array(N);\n\n    var rmws = out.words;\n    rmws.length = N;\n\n    this.convert13b(x.words, x.length, rws, N);\n    this.convert13b(y.words, y.length, nrws, N);\n\n    this.transform(rws, _, rwst, iwst, N, rbt);\n    this.transform(nrws, _, nrwst, niwst, N, rbt);\n\n    for (var i = 0; i < N; i++) {\n      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n      rwst[i] = rx;\n    }\n\n    this.conjugate(rwst, iwst, N);\n    this.transform(rwst, iwst, rmws, _, N, rbt);\n    this.conjugate(rmws, _, N);\n    this.normalize13b(rmws, N);\n\n    out.negative = x.negative ^ y.negative;\n    out.length = x.length + y.length;\n    return out._strip();\n  };\n\n  // Multiply `this` by `num`\n  BN.prototype.mul = function mul (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return this.mulTo(num, out);\n  };\n\n  // Multiply employing FFT\n  BN.prototype.mulf = function mulf (num) {\n    var out = new BN(null);\n    out.words = new Array(this.length + num.length);\n    return jumboMulTo(this, num, out);\n  };\n\n  // In-place Multiplication\n  BN.prototype.imul = function imul (num) {\n    return this.clone().mulTo(num, this);\n  };\n\n  BN.prototype.imuln = function imuln (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n\n    // Carry\n    var carry = 0;\n    for (var i = 0; i < this.length; i++) {\n      var w = (this.words[i] | 0) * num;\n      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);\n      carry >>= 26;\n      carry += (w / 0x4000000) | 0;\n      // NOTE: lo is 27bit maximum\n      carry += lo >>> 26;\n      this.words[i] = lo & 0x3ffffff;\n    }\n\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.muln = function muln (num) {\n    return this.clone().imuln(num);\n  };\n\n  // `this` * `this`\n  BN.prototype.sqr = function sqr () {\n    return this.mul(this);\n  };\n\n  // `this` * `this` in-place\n  BN.prototype.isqr = function isqr () {\n    return this.imul(this.clone());\n  };\n\n  // Math.pow(`this`, `num`)\n  BN.prototype.pow = function pow (num) {\n    var w = toBitArray(num);\n    if (w.length === 0) return new BN(1);\n\n    // Skip leading zeroes\n    var res = this;\n    for (var i = 0; i < w.length; i++, res = res.sqr()) {\n      if (w[i] !== 0) break;\n    }\n\n    if (++i < w.length) {\n      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n        if (w[i] === 0) continue;\n\n        res = res.mul(q);\n      }\n    }\n\n    return res;\n  };\n\n  // Shift-left in-place\n  BN.prototype.iushln = function iushln (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);\n    var i;\n\n    if (r !== 0) {\n      var carry = 0;\n\n      for (i = 0; i < this.length; i++) {\n        var newCarry = this.words[i] & carryMask;\n        var c = ((this.words[i] | 0) - newCarry) << r;\n        this.words[i] = c | carry;\n        carry = newCarry >>> (26 - r);\n      }\n\n      if (carry) {\n        this.words[i] = carry;\n        this.length++;\n      }\n    }\n\n    if (s !== 0) {\n      for (i = this.length - 1; i >= 0; i--) {\n        this.words[i + s] = this.words[i];\n      }\n\n      for (i = 0; i < s; i++) {\n        this.words[i] = 0;\n      }\n\n      this.length += s;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishln = function ishln (bits) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushln(bits);\n  };\n\n  // Shift-right in-place\n  // NOTE: `hint` is a lowest bit before trailing zeroes\n  // NOTE: if `extended` is present - it will be filled with destroyed bits\n  BN.prototype.iushrn = function iushrn (bits, hint, extended) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var h;\n    if (hint) {\n      h = (hint - (hint % 26)) / 26;\n    } else {\n      h = 0;\n    }\n\n    var r = bits % 26;\n    var s = Math.min((bits - r) / 26, this.length);\n    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n    var maskedWords = extended;\n\n    h -= s;\n    h = Math.max(0, h);\n\n    // Extended mode, copy masked part\n    if (maskedWords) {\n      for (var i = 0; i < s; i++) {\n        maskedWords.words[i] = this.words[i];\n      }\n      maskedWords.length = s;\n    }\n\n    if (s === 0) {\n      // No-op, we should not move anything at all\n    } else if (this.length > s) {\n      this.length -= s;\n      for (i = 0; i < this.length; i++) {\n        this.words[i] = this.words[i + s];\n      }\n    } else {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    var carry = 0;\n    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n      var word = this.words[i] | 0;\n      this.words[i] = (carry << (26 - r)) | (word >>> r);\n      carry = word & mask;\n    }\n\n    // Push carried bits as a mask\n    if (maskedWords && carry !== 0) {\n      maskedWords.words[maskedWords.length++] = carry;\n    }\n\n    if (this.length === 0) {\n      this.words[0] = 0;\n      this.length = 1;\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.ishrn = function ishrn (bits, hint, extended) {\n    // TODO(indutny): implement me\n    assert(this.negative === 0);\n    return this.iushrn(bits, hint, extended);\n  };\n\n  // Shift-left\n  BN.prototype.shln = function shln (bits) {\n    return this.clone().ishln(bits);\n  };\n\n  BN.prototype.ushln = function ushln (bits) {\n    return this.clone().iushln(bits);\n  };\n\n  // Shift-right\n  BN.prototype.shrn = function shrn (bits) {\n    return this.clone().ishrn(bits);\n  };\n\n  BN.prototype.ushrn = function ushrn (bits) {\n    return this.clone().iushrn(bits);\n  };\n\n  // Test if n bit is set\n  BN.prototype.testn = function testn (bit) {\n    assert(typeof bit === 'number' && bit >= 0);\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) return false;\n\n    // Check bit and return\n    var w = this.words[s];\n\n    return !!(w & q);\n  };\n\n  // Return only lowers bits of number (in-place)\n  BN.prototype.imaskn = function imaskn (bits) {\n    assert(typeof bits === 'number' && bits >= 0);\n    var r = bits % 26;\n    var s = (bits - r) / 26;\n\n    assert(this.negative === 0, 'imaskn works only with positive numbers');\n\n    if (this.length <= s) {\n      return this;\n    }\n\n    if (r !== 0) {\n      s++;\n    }\n    this.length = Math.min(s, this.length);\n\n    if (r !== 0) {\n      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);\n      this.words[this.length - 1] &= mask;\n    }\n\n    return this._strip();\n  };\n\n  // Return only lowers bits of number\n  BN.prototype.maskn = function maskn (bits) {\n    return this.clone().imaskn(bits);\n  };\n\n  // Add plain number `num` to `this`\n  BN.prototype.iaddn = function iaddn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.isubn(-num);\n\n    // Possible sign change\n    if (this.negative !== 0) {\n      if (this.length === 1 && (this.words[0] | 0) <= num) {\n        this.words[0] = num - (this.words[0] | 0);\n        this.negative = 0;\n        return this;\n      }\n\n      this.negative = 0;\n      this.isubn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    // Add without checks\n    return this._iaddn(num);\n  };\n\n  BN.prototype._iaddn = function _iaddn (num) {\n    this.words[0] += num;\n\n    // Carry\n    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {\n      this.words[i] -= 0x4000000;\n      if (i === this.length - 1) {\n        this.words[i + 1] = 1;\n      } else {\n        this.words[i + 1]++;\n      }\n    }\n    this.length = Math.max(this.length, i + 1);\n\n    return this;\n  };\n\n  // Subtract plain number `num` from `this`\n  BN.prototype.isubn = function isubn (num) {\n    assert(typeof num === 'number');\n    assert(num < 0x4000000);\n    if (num < 0) return this.iaddn(-num);\n\n    if (this.negative !== 0) {\n      this.negative = 0;\n      this.iaddn(num);\n      this.negative = 1;\n      return this;\n    }\n\n    this.words[0] -= num;\n\n    if (this.length === 1 && this.words[0] < 0) {\n      this.words[0] = -this.words[0];\n      this.negative = 1;\n    } else {\n      // Carry\n      for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n        this.words[i] += 0x4000000;\n        this.words[i + 1] -= 1;\n      }\n    }\n\n    return this._strip();\n  };\n\n  BN.prototype.addn = function addn (num) {\n    return this.clone().iaddn(num);\n  };\n\n  BN.prototype.subn = function subn (num) {\n    return this.clone().isubn(num);\n  };\n\n  BN.prototype.iabs = function iabs () {\n    this.negative = 0;\n\n    return this;\n  };\n\n  BN.prototype.abs = function abs () {\n    return this.clone().iabs();\n  };\n\n  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {\n    var len = num.length + shift;\n    var i;\n\n    this._expand(len);\n\n    var w;\n    var carry = 0;\n    for (i = 0; i < num.length; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      var right = (num.words[i] | 0) * mul;\n      w -= right & 0x3ffffff;\n      carry = (w >> 26) - ((right / 0x4000000) | 0);\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n    for (; i < this.length - shift; i++) {\n      w = (this.words[i + shift] | 0) + carry;\n      carry = w >> 26;\n      this.words[i + shift] = w & 0x3ffffff;\n    }\n\n    if (carry === 0) return this._strip();\n\n    // Subtraction overflow\n    assert(carry === -1);\n    carry = 0;\n    for (i = 0; i < this.length; i++) {\n      w = -(this.words[i] | 0) + carry;\n      carry = w >> 26;\n      this.words[i] = w & 0x3ffffff;\n    }\n    this.negative = 1;\n\n    return this._strip();\n  };\n\n  BN.prototype._wordDiv = function _wordDiv (num, mode) {\n    var shift = this.length - num.length;\n\n    var a = this.clone();\n    var b = num;\n\n    // Normalize\n    var bhi = b.words[b.length - 1] | 0;\n    var bhiBits = this._countBits(bhi);\n    shift = 26 - bhiBits;\n    if (shift !== 0) {\n      b = b.ushln(shift);\n      a.iushln(shift);\n      bhi = b.words[b.length - 1] | 0;\n    }\n\n    // Initialize quotient\n    var m = a.length - b.length;\n    var q;\n\n    if (mode !== 'mod') {\n      q = new BN(null);\n      q.length = m + 1;\n      q.words = new Array(q.length);\n      for (var i = 0; i < q.length; i++) {\n        q.words[i] = 0;\n      }\n    }\n\n    var diff = a.clone()._ishlnsubmul(b, 1, m);\n    if (diff.negative === 0) {\n      a = diff;\n      if (q) {\n        q.words[m] = 1;\n      }\n    }\n\n    for (var j = m - 1; j >= 0; j--) {\n      var qj = (a.words[b.length + j] | 0) * 0x4000000 +\n        (a.words[b.length + j - 1] | 0);\n\n      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max\n      // (0x7ffffff)\n      qj = Math.min((qj / bhi) | 0, 0x3ffffff);\n\n      a._ishlnsubmul(b, qj, j);\n      while (a.negative !== 0) {\n        qj--;\n        a.negative = 0;\n        a._ishlnsubmul(b, 1, j);\n        if (!a.isZero()) {\n          a.negative ^= 1;\n        }\n      }\n      if (q) {\n        q.words[j] = qj;\n      }\n    }\n    if (q) {\n      q._strip();\n    }\n    a._strip();\n\n    // Denormalize\n    if (mode !== 'div' && shift !== 0) {\n      a.iushrn(shift);\n    }\n\n    return {\n      div: q || null,\n      mod: a\n    };\n  };\n\n  // NOTE: 1) `mode` can be set to `mod` to request mod only,\n  //       to `div` to request div only, or be absent to\n  //       request both div & mod\n  //       2) `positive` is true if unsigned mod is requested\n  BN.prototype.divmod = function divmod (num, mode, positive) {\n    assert(!num.isZero());\n\n    if (this.isZero()) {\n      return {\n        div: new BN(0),\n        mod: new BN(0)\n      };\n    }\n\n    var div, mod, res;\n    if (this.negative !== 0 && num.negative === 0) {\n      res = this.neg().divmod(num, mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.iadd(num);\n        }\n      }\n\n      return {\n        div: div,\n        mod: mod\n      };\n    }\n\n    if (this.negative === 0 && num.negative !== 0) {\n      res = this.divmod(num.neg(), mode);\n\n      if (mode !== 'mod') {\n        div = res.div.neg();\n      }\n\n      return {\n        div: div,\n        mod: res.mod\n      };\n    }\n\n    if ((this.negative & num.negative) !== 0) {\n      res = this.neg().divmod(num.neg(), mode);\n\n      if (mode !== 'div') {\n        mod = res.mod.neg();\n        if (positive && mod.negative !== 0) {\n          mod.isub(num);\n        }\n      }\n\n      return {\n        div: res.div,\n        mod: mod\n      };\n    }\n\n    // Both numbers are positive at this point\n\n    // Strip both numbers to approximate shift value\n    if (num.length > this.length || this.cmp(num) < 0) {\n      return {\n        div: new BN(0),\n        mod: this\n      };\n    }\n\n    // Very short reduction\n    if (num.length === 1) {\n      if (mode === 'div') {\n        return {\n          div: this.divn(num.words[0]),\n          mod: null\n        };\n      }\n\n      if (mode === 'mod') {\n        return {\n          div: null,\n          mod: new BN(this.modrn(num.words[0]))\n        };\n      }\n\n      return {\n        div: this.divn(num.words[0]),\n        mod: new BN(this.modrn(num.words[0]))\n      };\n    }\n\n    return this._wordDiv(num, mode);\n  };\n\n  // Find `this` / `num`\n  BN.prototype.div = function div (num) {\n    return this.divmod(num, 'div', false).div;\n  };\n\n  // Find `this` % `num`\n  BN.prototype.mod = function mod (num) {\n    return this.divmod(num, 'mod', false).mod;\n  };\n\n  BN.prototype.umod = function umod (num) {\n    return this.divmod(num, 'mod', true).mod;\n  };\n\n  // Find Round(`this` / `num`)\n  BN.prototype.divRound = function divRound (num) {\n    var dm = this.divmod(num);\n\n    // Fast case - exact division\n    if (dm.mod.isZero()) return dm.div;\n\n    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n\n    var half = num.ushrn(1);\n    var r2 = num.andln(1);\n    var cmp = mod.cmp(half);\n\n    // Round down\n    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;\n\n    // Round up\n    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n  };\n\n  BN.prototype.modrn = function modrn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n    var p = (1 << 26) % num;\n\n    var acc = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      acc = (p * acc + (this.words[i] | 0)) % num;\n    }\n\n    return isNegNum ? -acc : acc;\n  };\n\n  // WARNING: DEPRECATED\n  BN.prototype.modn = function modn (num) {\n    return this.modrn(num);\n  };\n\n  // In-place division by number\n  BN.prototype.idivn = function idivn (num) {\n    var isNegNum = num < 0;\n    if (isNegNum) num = -num;\n\n    assert(num <= 0x3ffffff);\n\n    var carry = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var w = (this.words[i] | 0) + carry * 0x4000000;\n      this.words[i] = (w / num) | 0;\n      carry = w % num;\n    }\n\n    this._strip();\n    return isNegNum ? this.ineg() : this;\n  };\n\n  BN.prototype.divn = function divn (num) {\n    return this.clone().idivn(num);\n  };\n\n  BN.prototype.egcd = function egcd (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var x = this;\n    var y = p.clone();\n\n    if (x.negative !== 0) {\n      x = x.umod(p);\n    } else {\n      x = x.clone();\n    }\n\n    // A * x + B * y = x\n    var A = new BN(1);\n    var B = new BN(0);\n\n    // C * x + D * y = y\n    var C = new BN(0);\n    var D = new BN(1);\n\n    var g = 0;\n\n    while (x.isEven() && y.isEven()) {\n      x.iushrn(1);\n      y.iushrn(1);\n      ++g;\n    }\n\n    var yp = y.clone();\n    var xp = x.clone();\n\n    while (!x.isZero()) {\n      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        x.iushrn(i);\n        while (i-- > 0) {\n          if (A.isOdd() || B.isOdd()) {\n            A.iadd(yp);\n            B.isub(xp);\n          }\n\n          A.iushrn(1);\n          B.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        y.iushrn(j);\n        while (j-- > 0) {\n          if (C.isOdd() || D.isOdd()) {\n            C.iadd(yp);\n            D.isub(xp);\n          }\n\n          C.iushrn(1);\n          D.iushrn(1);\n        }\n      }\n\n      if (x.cmp(y) >= 0) {\n        x.isub(y);\n        A.isub(C);\n        B.isub(D);\n      } else {\n        y.isub(x);\n        C.isub(A);\n        D.isub(B);\n      }\n    }\n\n    return {\n      a: C,\n      b: D,\n      gcd: y.iushln(g)\n    };\n  };\n\n  // This is reduced incarnation of the binary EEA\n  // above, designated to invert members of the\n  // _prime_ fields F(p) at a maximal speed\n  BN.prototype._invmp = function _invmp (p) {\n    assert(p.negative === 0);\n    assert(!p.isZero());\n\n    var a = this;\n    var b = p.clone();\n\n    if (a.negative !== 0) {\n      a = a.umod(p);\n    } else {\n      a = a.clone();\n    }\n\n    var x1 = new BN(1);\n    var x2 = new BN(0);\n\n    var delta = b.clone();\n\n    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);\n      if (i > 0) {\n        a.iushrn(i);\n        while (i-- > 0) {\n          if (x1.isOdd()) {\n            x1.iadd(delta);\n          }\n\n          x1.iushrn(1);\n        }\n      }\n\n      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);\n      if (j > 0) {\n        b.iushrn(j);\n        while (j-- > 0) {\n          if (x2.isOdd()) {\n            x2.iadd(delta);\n          }\n\n          x2.iushrn(1);\n        }\n      }\n\n      if (a.cmp(b) >= 0) {\n        a.isub(b);\n        x1.isub(x2);\n      } else {\n        b.isub(a);\n        x2.isub(x1);\n      }\n    }\n\n    var res;\n    if (a.cmpn(1) === 0) {\n      res = x1;\n    } else {\n      res = x2;\n    }\n\n    if (res.cmpn(0) < 0) {\n      res.iadd(p);\n    }\n\n    return res;\n  };\n\n  BN.prototype.gcd = function gcd (num) {\n    if (this.isZero()) return num.abs();\n    if (num.isZero()) return this.abs();\n\n    var a = this.clone();\n    var b = num.clone();\n    a.negative = 0;\n    b.negative = 0;\n\n    // Remove common factor of two\n    for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n      a.iushrn(1);\n      b.iushrn(1);\n    }\n\n    do {\n      while (a.isEven()) {\n        a.iushrn(1);\n      }\n      while (b.isEven()) {\n        b.iushrn(1);\n      }\n\n      var r = a.cmp(b);\n      if (r < 0) {\n        // Swap `a` and `b` to make `a` always bigger than `b`\n        var t = a;\n        a = b;\n        b = t;\n      } else if (r === 0 || b.cmpn(1) === 0) {\n        break;\n      }\n\n      a.isub(b);\n    } while (true);\n\n    return b.iushln(shift);\n  };\n\n  // Invert number in the field F(num)\n  BN.prototype.invm = function invm (num) {\n    return this.egcd(num).a.umod(num);\n  };\n\n  BN.prototype.isEven = function isEven () {\n    return (this.words[0] & 1) === 0;\n  };\n\n  BN.prototype.isOdd = function isOdd () {\n    return (this.words[0] & 1) === 1;\n  };\n\n  // And first word and num\n  BN.prototype.andln = function andln (num) {\n    return this.words[0] & num;\n  };\n\n  // Increment at the bit position in-line\n  BN.prototype.bincn = function bincn (bit) {\n    assert(typeof bit === 'number');\n    var r = bit % 26;\n    var s = (bit - r) / 26;\n    var q = 1 << r;\n\n    // Fast case: bit is much higher than all existing words\n    if (this.length <= s) {\n      this._expand(s + 1);\n      this.words[s] |= q;\n      return this;\n    }\n\n    // Add bit and propagate, if needed\n    var carry = q;\n    for (var i = s; carry !== 0 && i < this.length; i++) {\n      var w = this.words[i] | 0;\n      w += carry;\n      carry = w >>> 26;\n      w &= 0x3ffffff;\n      this.words[i] = w;\n    }\n    if (carry !== 0) {\n      this.words[i] = carry;\n      this.length++;\n    }\n    return this;\n  };\n\n  BN.prototype.isZero = function isZero () {\n    return this.length === 1 && this.words[0] === 0;\n  };\n\n  BN.prototype.cmpn = function cmpn (num) {\n    var negative = num < 0;\n\n    if (this.negative !== 0 && !negative) return -1;\n    if (this.negative === 0 && negative) return 1;\n\n    this._strip();\n\n    var res;\n    if (this.length > 1) {\n      res = 1;\n    } else {\n      if (negative) {\n        num = -num;\n      }\n\n      assert(num <= 0x3ffffff, 'Number is too big');\n\n      var w = this.words[0] | 0;\n      res = w === num ? 0 : w < num ? -1 : 1;\n    }\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Compare two numbers and return:\n  // 1 - if `this` > `num`\n  // 0 - if `this` == `num`\n  // -1 - if `this` < `num`\n  BN.prototype.cmp = function cmp (num) {\n    if (this.negative !== 0 && num.negative === 0) return -1;\n    if (this.negative === 0 && num.negative !== 0) return 1;\n\n    var res = this.ucmp(num);\n    if (this.negative !== 0) return -res | 0;\n    return res;\n  };\n\n  // Unsigned comparison\n  BN.prototype.ucmp = function ucmp (num) {\n    // At this point both numbers have the same sign\n    if (this.length > num.length) return 1;\n    if (this.length < num.length) return -1;\n\n    var res = 0;\n    for (var i = this.length - 1; i >= 0; i--) {\n      var a = this.words[i] | 0;\n      var b = num.words[i] | 0;\n\n      if (a === b) continue;\n      if (a < b) {\n        res = -1;\n      } else if (a > b) {\n        res = 1;\n      }\n      break;\n    }\n    return res;\n  };\n\n  BN.prototype.gtn = function gtn (num) {\n    return this.cmpn(num) === 1;\n  };\n\n  BN.prototype.gt = function gt (num) {\n    return this.cmp(num) === 1;\n  };\n\n  BN.prototype.gten = function gten (num) {\n    return this.cmpn(num) >= 0;\n  };\n\n  BN.prototype.gte = function gte (num) {\n    return this.cmp(num) >= 0;\n  };\n\n  BN.prototype.ltn = function ltn (num) {\n    return this.cmpn(num) === -1;\n  };\n\n  BN.prototype.lt = function lt (num) {\n    return this.cmp(num) === -1;\n  };\n\n  BN.prototype.lten = function lten (num) {\n    return this.cmpn(num) <= 0;\n  };\n\n  BN.prototype.lte = function lte (num) {\n    return this.cmp(num) <= 0;\n  };\n\n  BN.prototype.eqn = function eqn (num) {\n    return this.cmpn(num) === 0;\n  };\n\n  BN.prototype.eq = function eq (num) {\n    return this.cmp(num) === 0;\n  };\n\n  //\n  // A reduce context, could be using montgomery or something better, depending\n  // on the `m` itself.\n  //\n  BN.red = function red (num) {\n    return new Red(num);\n  };\n\n  BN.prototype.toRed = function toRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    assert(this.negative === 0, 'red works only with positives');\n    return ctx.convertTo(this)._forceRed(ctx);\n  };\n\n  BN.prototype.fromRed = function fromRed () {\n    assert(this.red, 'fromRed works only with numbers in reduction context');\n    return this.red.convertFrom(this);\n  };\n\n  BN.prototype._forceRed = function _forceRed (ctx) {\n    this.red = ctx;\n    return this;\n  };\n\n  BN.prototype.forceRed = function forceRed (ctx) {\n    assert(!this.red, 'Already a number in reduction context');\n    return this._forceRed(ctx);\n  };\n\n  BN.prototype.redAdd = function redAdd (num) {\n    assert(this.red, 'redAdd works only with red numbers');\n    return this.red.add(this, num);\n  };\n\n  BN.prototype.redIAdd = function redIAdd (num) {\n    assert(this.red, 'redIAdd works only with red numbers');\n    return this.red.iadd(this, num);\n  };\n\n  BN.prototype.redSub = function redSub (num) {\n    assert(this.red, 'redSub works only with red numbers');\n    return this.red.sub(this, num);\n  };\n\n  BN.prototype.redISub = function redISub (num) {\n    assert(this.red, 'redISub works only with red numbers');\n    return this.red.isub(this, num);\n  };\n\n  BN.prototype.redShl = function redShl (num) {\n    assert(this.red, 'redShl works only with red numbers');\n    return this.red.shl(this, num);\n  };\n\n  BN.prototype.redMul = function redMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.mul(this, num);\n  };\n\n  BN.prototype.redIMul = function redIMul (num) {\n    assert(this.red, 'redMul works only with red numbers');\n    this.red._verify2(this, num);\n    return this.red.imul(this, num);\n  };\n\n  BN.prototype.redSqr = function redSqr () {\n    assert(this.red, 'redSqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqr(this);\n  };\n\n  BN.prototype.redISqr = function redISqr () {\n    assert(this.red, 'redISqr works only with red numbers');\n    this.red._verify1(this);\n    return this.red.isqr(this);\n  };\n\n  // Square root over p\n  BN.prototype.redSqrt = function redSqrt () {\n    assert(this.red, 'redSqrt works only with red numbers');\n    this.red._verify1(this);\n    return this.red.sqrt(this);\n  };\n\n  BN.prototype.redInvm = function redInvm () {\n    assert(this.red, 'redInvm works only with red numbers');\n    this.red._verify1(this);\n    return this.red.invm(this);\n  };\n\n  // Return negative clone of `this` % `red modulo`\n  BN.prototype.redNeg = function redNeg () {\n    assert(this.red, 'redNeg works only with red numbers');\n    this.red._verify1(this);\n    return this.red.neg(this);\n  };\n\n  BN.prototype.redPow = function redPow (num) {\n    assert(this.red && !num.red, 'redPow(normalNum)');\n    this.red._verify1(this);\n    return this.red.pow(this, num);\n  };\n\n  // Prime numbers with efficient reduction\n  var primes = {\n    k256: null,\n    p224: null,\n    p192: null,\n    p25519: null\n  };\n\n  // Pseudo-Mersenne prime\n  function MPrime (name, p) {\n    // P = 2 ^ N - K\n    this.name = name;\n    this.p = new BN(p, 16);\n    this.n = this.p.bitLength();\n    this.k = new BN(1).iushln(this.n).isub(this.p);\n\n    this.tmp = this._tmp();\n  }\n\n  MPrime.prototype._tmp = function _tmp () {\n    var tmp = new BN(null);\n    tmp.words = new Array(Math.ceil(this.n / 13));\n    return tmp;\n  };\n\n  MPrime.prototype.ireduce = function ireduce (num) {\n    // Assumes that `num` is less than `P^2`\n    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)\n    var r = num;\n    var rlen;\n\n    do {\n      this.split(r, this.tmp);\n      r = this.imulK(r);\n      r = r.iadd(this.tmp);\n      rlen = r.bitLength();\n    } while (rlen > this.n);\n\n    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n    if (cmp === 0) {\n      r.words[0] = 0;\n      r.length = 1;\n    } else if (cmp > 0) {\n      r.isub(this.p);\n    } else {\n      if (r.strip !== undefined) {\n        // r is a BN v4 instance\n        r.strip();\n      } else {\n        // r is a BN v5 instance\n        r._strip();\n      }\n    }\n\n    return r;\n  };\n\n  MPrime.prototype.split = function split (input, out) {\n    input.iushrn(this.n, 0, out);\n  };\n\n  MPrime.prototype.imulK = function imulK (num) {\n    return num.imul(this.k);\n  };\n\n  function K256 () {\n    MPrime.call(\n      this,\n      'k256',\n      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');\n  }\n  inherits(K256, MPrime);\n\n  K256.prototype.split = function split (input, output) {\n    // 256 = 9 * 26 + 22\n    var mask = 0x3fffff;\n\n    var outLen = Math.min(input.length, 9);\n    for (var i = 0; i < outLen; i++) {\n      output.words[i] = input.words[i];\n    }\n    output.length = outLen;\n\n    if (input.length <= 9) {\n      input.words[0] = 0;\n      input.length = 1;\n      return;\n    }\n\n    // Shift by 9 limbs\n    var prev = input.words[9];\n    output.words[output.length++] = prev & mask;\n\n    for (i = 10; i < input.length; i++) {\n      var next = input.words[i] | 0;\n      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);\n      prev = next;\n    }\n    prev >>>= 22;\n    input.words[i - 10] = prev;\n    if (prev === 0 && input.length > 10) {\n      input.length -= 10;\n    } else {\n      input.length -= 9;\n    }\n  };\n\n  K256.prototype.imulK = function imulK (num) {\n    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]\n    num.words[num.length] = 0;\n    num.words[num.length + 1] = 0;\n    num.length += 2;\n\n    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390\n    var lo = 0;\n    for (var i = 0; i < num.length; i++) {\n      var w = num.words[i] | 0;\n      lo += w * 0x3d1;\n      num.words[i] = lo & 0x3ffffff;\n      lo = w * 0x40 + ((lo / 0x4000000) | 0);\n    }\n\n    // Fast length reduction\n    if (num.words[num.length - 1] === 0) {\n      num.length--;\n      if (num.words[num.length - 1] === 0) {\n        num.length--;\n      }\n    }\n    return num;\n  };\n\n  function P224 () {\n    MPrime.call(\n      this,\n      'p224',\n      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');\n  }\n  inherits(P224, MPrime);\n\n  function P192 () {\n    MPrime.call(\n      this,\n      'p192',\n      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');\n  }\n  inherits(P192, MPrime);\n\n  function P25519 () {\n    // 2 ^ 255 - 19\n    MPrime.call(\n      this,\n      '25519',\n      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');\n  }\n  inherits(P25519, MPrime);\n\n  P25519.prototype.imulK = function imulK (num) {\n    // K = 0x13\n    var carry = 0;\n    for (var i = 0; i < num.length; i++) {\n      var hi = (num.words[i] | 0) * 0x13 + carry;\n      var lo = hi & 0x3ffffff;\n      hi >>>= 26;\n\n      num.words[i] = lo;\n      carry = hi;\n    }\n    if (carry !== 0) {\n      num.words[num.length++] = carry;\n    }\n    return num;\n  };\n\n  // Exported mostly for testing purposes, use plain name instead\n  BN._prime = function prime (name) {\n    // Cached version of prime\n    if (primes[name]) return primes[name];\n\n    var prime;\n    if (name === 'k256') {\n      prime = new K256();\n    } else if (name === 'p224') {\n      prime = new P224();\n    } else if (name === 'p192') {\n      prime = new P192();\n    } else if (name === 'p25519') {\n      prime = new P25519();\n    } else {\n      throw new Error('Unknown prime ' + name);\n    }\n    primes[name] = prime;\n\n    return prime;\n  };\n\n  //\n  // Base reduction engine\n  //\n  function Red (m) {\n    if (typeof m === 'string') {\n      var prime = BN._prime(m);\n      this.m = prime.p;\n      this.prime = prime;\n    } else {\n      assert(m.gtn(1), 'modulus must be greater than 1');\n      this.m = m;\n      this.prime = null;\n    }\n  }\n\n  Red.prototype._verify1 = function _verify1 (a) {\n    assert(a.negative === 0, 'red works only with positives');\n    assert(a.red, 'red works only with red numbers');\n  };\n\n  Red.prototype._verify2 = function _verify2 (a, b) {\n    assert((a.negative | b.negative) === 0, 'red works only with positives');\n    assert(a.red && a.red === b.red,\n      'red works only with red numbers');\n  };\n\n  Red.prototype.imod = function imod (a) {\n    if (this.prime) return this.prime.ireduce(a)._forceRed(this);\n\n    move(a, a.umod(this.m)._forceRed(this));\n    return a;\n  };\n\n  Red.prototype.neg = function neg (a) {\n    if (a.isZero()) {\n      return a.clone();\n    }\n\n    return this.m.sub(a)._forceRed(this);\n  };\n\n  Red.prototype.add = function add (a, b) {\n    this._verify2(a, b);\n\n    var res = a.add(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.iadd = function iadd (a, b) {\n    this._verify2(a, b);\n\n    var res = a.iadd(b);\n    if (res.cmp(this.m) >= 0) {\n      res.isub(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.sub = function sub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.sub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res._forceRed(this);\n  };\n\n  Red.prototype.isub = function isub (a, b) {\n    this._verify2(a, b);\n\n    var res = a.isub(b);\n    if (res.cmpn(0) < 0) {\n      res.iadd(this.m);\n    }\n    return res;\n  };\n\n  Red.prototype.shl = function shl (a, num) {\n    this._verify1(a);\n    return this.imod(a.ushln(num));\n  };\n\n  Red.prototype.imul = function imul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.imul(b));\n  };\n\n  Red.prototype.mul = function mul (a, b) {\n    this._verify2(a, b);\n    return this.imod(a.mul(b));\n  };\n\n  Red.prototype.isqr = function isqr (a) {\n    return this.imul(a, a.clone());\n  };\n\n  Red.prototype.sqr = function sqr (a) {\n    return this.mul(a, a);\n  };\n\n  Red.prototype.sqrt = function sqrt (a) {\n    if (a.isZero()) return a.clone();\n\n    var mod3 = this.m.andln(3);\n    assert(mod3 % 2 === 1);\n\n    // Fast case\n    if (mod3 === 3) {\n      var pow = this.m.add(new BN(1)).iushrn(2);\n      return this.pow(a, pow);\n    }\n\n    // Tonelli-Shanks algorithm (Totally unoptimized and slow)\n    //\n    // Find Q and S, that Q * 2 ^ S = (P - 1)\n    var q = this.m.subn(1);\n    var s = 0;\n    while (!q.isZero() && q.andln(1) === 0) {\n      s++;\n      q.iushrn(1);\n    }\n    assert(!q.isZero());\n\n    var one = new BN(1).toRed(this);\n    var nOne = one.redNeg();\n\n    // Find quadratic non-residue\n    // NOTE: Max is such because of generalized Riemann hypothesis.\n    var lpow = this.m.subn(1).iushrn(1);\n    var z = this.m.bitLength();\n    z = new BN(2 * z * z).toRed(this);\n\n    while (this.pow(z, lpow).cmp(nOne) !== 0) {\n      z.redIAdd(nOne);\n    }\n\n    var c = this.pow(z, q);\n    var r = this.pow(a, q.addn(1).iushrn(1));\n    var t = this.pow(a, q);\n    var m = s;\n    while (t.cmp(one) !== 0) {\n      var tmp = t;\n      for (var i = 0; tmp.cmp(one) !== 0; i++) {\n        tmp = tmp.redSqr();\n      }\n      assert(i < m);\n      var b = this.pow(c, new BN(1).iushln(m - i - 1));\n\n      r = r.redMul(b);\n      c = b.redSqr();\n      t = t.redMul(c);\n      m = i;\n    }\n\n    return r;\n  };\n\n  Red.prototype.invm = function invm (a) {\n    var inv = a._invmp(this.m);\n    if (inv.negative !== 0) {\n      inv.negative = 0;\n      return this.imod(inv).redNeg();\n    } else {\n      return this.imod(inv);\n    }\n  };\n\n  Red.prototype.pow = function pow (a, num) {\n    if (num.isZero()) return new BN(1).toRed(this);\n    if (num.cmpn(1) === 0) return a.clone();\n\n    var windowSize = 4;\n    var wnd = new Array(1 << windowSize);\n    wnd[0] = new BN(1).toRed(this);\n    wnd[1] = a;\n    for (var i = 2; i < wnd.length; i++) {\n      wnd[i] = this.mul(wnd[i - 1], a);\n    }\n\n    var res = wnd[0];\n    var current = 0;\n    var currentLen = 0;\n    var start = num.bitLength() % 26;\n    if (start === 0) {\n      start = 26;\n    }\n\n    for (i = num.length - 1; i >= 0; i--) {\n      var word = num.words[i];\n      for (var j = start - 1; j >= 0; j--) {\n        var bit = (word >> j) & 1;\n        if (res !== wnd[0]) {\n          res = this.sqr(res);\n        }\n\n        if (bit === 0 && current === 0) {\n          currentLen = 0;\n          continue;\n        }\n\n        current <<= 1;\n        current |= bit;\n        currentLen++;\n        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;\n\n        res = this.mul(res, wnd[current]);\n        currentLen = 0;\n        current = 0;\n      }\n      start = 26;\n    }\n\n    return res;\n  };\n\n  Red.prototype.convertTo = function convertTo (num) {\n    var r = num.umod(this.m);\n\n    return r === num ? r.clone() : r;\n  };\n\n  Red.prototype.convertFrom = function convertFrom (num) {\n    var res = num.clone();\n    res.red = null;\n    return res;\n  };\n\n  //\n  // Montgomery method engine\n  //\n\n  BN.mont = function mont (num) {\n    return new Mont(num);\n  };\n\n  function Mont (m) {\n    Red.call(this, m);\n\n    this.shift = this.m.bitLength();\n    if (this.shift % 26 !== 0) {\n      this.shift += 26 - (this.shift % 26);\n    }\n\n    this.r = new BN(1).iushln(this.shift);\n    this.r2 = this.imod(this.r.sqr());\n    this.rinv = this.r._invmp(this.m);\n\n    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n    this.minv = this.minv.umod(this.r);\n    this.minv = this.r.sub(this.minv);\n  }\n  inherits(Mont, Red);\n\n  Mont.prototype.convertTo = function convertTo (num) {\n    return this.imod(num.ushln(this.shift));\n  };\n\n  Mont.prototype.convertFrom = function convertFrom (num) {\n    var r = this.imod(num.mul(this.rinv));\n    r.red = null;\n    return r;\n  };\n\n  Mont.prototype.imul = function imul (a, b) {\n    if (a.isZero() || b.isZero()) {\n      a.words[0] = 0;\n      a.length = 1;\n      return a;\n    }\n\n    var t = a.imul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.mul = function mul (a, b) {\n    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);\n\n    var t = a.mul(b);\n    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n    var u = t.isub(c).iushrn(this.shift);\n    var res = u;\n    if (u.cmp(this.m) >= 0) {\n      res = u.isub(this.m);\n    } else if (u.cmpn(0) < 0) {\n      res = u.iadd(this.m);\n    }\n\n    return res._forceRed(this);\n  };\n\n  Mont.prototype.invm = function invm (a) {\n    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R\n    var res = this.imod(a._invmp(this.m).mul(this.r2));\n    return res._forceRed(this);\n  };\n})( false || module, this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ib3JzaC9ub2RlX21vZHVsZXMvYm4uanMvbGliL2JuLmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLGVBQWUsbURBQXdCO0FBQ3ZDO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04seUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHlCQUF5QixtQkFBbUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSwwREFBMEQsbUJBQW1CO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsU0FBUztBQUNqQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsaUJBQWlCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0IsaUJBQWlCO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQixpQkFBaUI7QUFDaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELFdBQVc7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0Isb0JBQW9CO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxvQkFBb0IsT0FBTztBQUMzQjs7QUFFQTtBQUNBOztBQUVBLHNCQUFzQixPQUFPO0FBQzdCO0FBQ0E7O0FBRUEsd0JBQXdCLE9BQU87QUFDL0I7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixHQUFHO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9CQUFvQixXQUFXO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQSxtQ0FBbUM7QUFDbkMsdUNBQXVDO0FBQ3ZDOztBQUVBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBOztBQUVBO0FBQ0EsOEJBQThCLGNBQWM7QUFDNUM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxRQUFRO0FBQ3hDO0FBQ0E7O0FBRUEsa0JBQWtCLE9BQU87QUFDekI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0JBQXNCLE9BQU87QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGtCQUFrQixpQkFBaUI7QUFDbkM7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiwrQ0FBK0M7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0Esc0JBQXNCLHNDQUFzQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixnQkFBZ0I7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsY0FBYztBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxrQ0FBa0MsUUFBUTtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCLG1DQUFtQztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLDhCQUE4QixtQ0FBbUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEIsbUNBQW1DO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGdDQUFnQztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLG9CQUFvQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0EsOEJBQThCLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBRSxNQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYm9yc2gvbm9kZV9tb2R1bGVzL2JuLmpzL2xpYi9ibi5qcz81YzRhIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBVdGlsc1xuICBmdW5jdGlvbiBhc3NlcnQgKHZhbCwgbXNnKSB7XG4gICAgaWYgKCF2YWwpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxuXG4gIC8vIENvdWxkIHVzZSBgaW5oZXJpdHNgIG1vZHVsZSwgYnV0IGRvbid0IHdhbnQgdG8gbW92ZSBmcm9tIHNpbmdsZSBmaWxlXG4gIC8vIGFyY2hpdGVjdHVyZSB5ZXQuXG4gIGZ1bmN0aW9uIGluaGVyaXRzIChjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuICB9XG5cbiAgLy8gQk5cblxuICBmdW5jdGlvbiBCTiAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAoQk4uaXNCTihudW1iZXIpKSB7XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIHRoaXMud29yZHMgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIC8vIFJlZHVjdGlvbiBjb250ZXh0XG4gICAgdGhpcy5yZWQgPSBudWxsO1xuXG4gICAgaWYgKG51bWJlciAhPT0gbnVsbCkge1xuICAgICAgaWYgKGJhc2UgPT09ICdsZScgfHwgYmFzZSA9PT0gJ2JlJykge1xuICAgICAgICBlbmRpYW4gPSBiYXNlO1xuICAgICAgICBiYXNlID0gMTA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2luaXQobnVtYmVyIHx8IDAsIGJhc2UgfHwgMTAsIGVuZGlhbiB8fCAnYmUnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCTjtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLkJOID0gQk47XG4gIH1cblxuICBCTi5CTiA9IEJOO1xuICBCTi53b3JkU2l6ZSA9IDI2O1xuXG4gIHZhciBCdWZmZXI7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgQnVmZmVyID0gd2luZG93LkJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICB9XG5cbiAgQk4uaXNCTiA9IGZ1bmN0aW9uIGlzQk4gKG51bSkge1xuICAgIGlmIChudW0gaW5zdGFuY2VvZiBCTikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bSAhPT0gbnVsbCAmJiB0eXBlb2YgbnVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgbnVtLmNvbnN0cnVjdG9yLndvcmRTaXplID09PSBCTi53b3JkU2l6ZSAmJiBBcnJheS5pc0FycmF5KG51bS53b3Jkcyk7XG4gIH07XG5cbiAgQk4ubWF4ID0gZnVuY3Rpb24gbWF4IChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPiAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ubWluID0gZnVuY3Rpb24gbWluIChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPCAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdCAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAnaGV4Jykge1xuICAgICAgYmFzZSA9IDE2O1xuICAgIH1cbiAgICBhc3NlcnQoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNik7XG5cbiAgICBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGlmIChudW1iZXJbMF0gPT09ICctJykge1xuICAgICAgc3RhcnQrKztcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA8IG51bWJlci5sZW5ndGgpIHtcbiAgICAgIGlmIChiYXNlID09PSAxNikge1xuICAgICAgICB0aGlzLl9wYXJzZUhleChudW1iZXIsIHN0YXJ0LCBlbmRpYW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpO1xuICAgICAgICBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICAgICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdE51bWJlciA9IGZ1bmN0aW9uIF9pbml0TnVtYmVyIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIG51bWJlciA9IC1udW1iZXI7XG4gICAgfVxuICAgIGlmIChudW1iZXIgPCAweDQwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbbnVtYmVyICYgMHgzZmZmZmZmXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKG51bWJlciA8IDB4MTAwMDAwMDAwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmZcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChudW1iZXIgPCAweDIwMDAwMDAwMDAwMDAwKTsgLy8gMiBeIDUzICh1bnNhZmUpXG4gICAgICB0aGlzLndvcmRzID0gW1xuICAgICAgICBudW1iZXIgJiAweDNmZmZmZmYsXG4gICAgICAgIChudW1iZXIgLyAweDQwMDAwMDApICYgMHgzZmZmZmZmLFxuICAgICAgICAxXG4gICAgICBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAzO1xuICAgIH1cblxuICAgIGlmIChlbmRpYW4gIT09ICdsZScpIHJldHVybjtcblxuICAgIC8vIFJldmVyc2UgdGhlIGJ5dGVzXG4gICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdEFycmF5ID0gZnVuY3Rpb24gX2luaXRBcnJheSAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICAvLyBQZXJoYXBzIGEgVWludDhBcnJheVxuICAgIGFzc2VydCh0eXBlb2YgbnVtYmVyLmxlbmd0aCA9PT0gJ251bWJlcicpO1xuICAgIGlmIChudW1iZXIubGVuZ3RoIDw9IDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbMF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbChudW1iZXIubGVuZ3RoIC8gMyk7XG4gICAgdGhpcy53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICB9XG5cbiAgICB2YXIgaiwgdztcbiAgICB2YXIgb2ZmID0gMDtcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMSwgaiA9IDA7IGkgPj0gMDsgaSAtPSAzKSB7XG4gICAgICAgIHcgPSBudW1iZXJbaV0gfCAobnVtYmVyW2kgLSAxXSA8PCA4KSB8IChudW1iZXJbaSAtIDJdIDw8IDE2KTtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSAodyA8PCBvZmYpICYgMHgzZmZmZmZmO1xuICAgICAgICB0aGlzLndvcmRzW2ogKyAxXSA9ICh3ID4+PiAoMjYgLSBvZmYpKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgb2ZmICs9IDI0O1xuICAgICAgICBpZiAob2ZmID49IDI2KSB7XG4gICAgICAgICAgb2ZmIC09IDI2O1xuICAgICAgICAgIGorKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG51bWJlci5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpICsgMV0gPDwgOCkgfCAobnVtYmVyW2kgKyAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VIZXg0Qml0cyAoc3RyaW5nLCBpbmRleCkge1xuICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIC8vICcwJyAtICc5J1xuICAgIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpIHtcbiAgICAgIHJldHVybiBjIC0gNDg7XG4gICAgLy8gJ0EnIC0gJ0YnXG4gICAgfSBlbHNlIGlmIChjID49IDY1ICYmIGMgPD0gNzApIHtcbiAgICAgIHJldHVybiBjIC0gNTU7XG4gICAgLy8gJ2EnIC0gJ2YnXG4gICAgfSBlbHNlIGlmIChjID49IDk3ICYmIGMgPD0gMTAyKSB7XG4gICAgICByZXR1cm4gYyAtIDg3O1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQoZmFsc2UsICdJbnZhbGlkIGNoYXJhY3RlciBpbiAnICsgc3RyaW5nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZUhleEJ5dGUgKHN0cmluZywgbG93ZXJCb3VuZCwgaW5kZXgpIHtcbiAgICB2YXIgciA9IHBhcnNlSGV4NEJpdHMoc3RyaW5nLCBpbmRleCk7XG4gICAgaWYgKGluZGV4IC0gMSA+PSBsb3dlckJvdW5kKSB7XG4gICAgICByIHw9IHBhcnNlSGV4NEJpdHMoc3RyaW5nLCBpbmRleCAtIDEpIDw8IDQ7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUhleCA9IGZ1bmN0aW9uIF9wYXJzZUhleCAobnVtYmVyLCBzdGFydCwgZW5kaWFuKSB7XG4gICAgLy8gQ3JlYXRlIHBvc3NpYmx5IGJpZ2dlciBhcnJheSB0byBlbnN1cmUgdGhhdCBpdCBmaXRzIHRoZSBudW1iZXJcbiAgICB0aGlzLmxlbmd0aCA9IE1hdGguY2VpbCgobnVtYmVyLmxlbmd0aCAtIHN0YXJ0KSAvIDYpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgLy8gMjQtYml0cyBjaHVua3NcbiAgICB2YXIgb2ZmID0gMDtcbiAgICB2YXIgaiA9IDA7XG5cbiAgICB2YXIgdztcbiAgICBpZiAoZW5kaWFuID09PSAnYmUnKSB7XG4gICAgICBmb3IgKGkgPSBudW1iZXIubGVuZ3RoIC0gMTsgaSA+PSBzdGFydDsgaSAtPSAyKSB7XG4gICAgICAgIHcgPSBwYXJzZUhleEJ5dGUobnVtYmVyLCBzdGFydCwgaSkgPDwgb2ZmO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgJiAweDNmZmZmZmY7XG4gICAgICAgIGlmIChvZmYgPj0gMTgpIHtcbiAgICAgICAgICBvZmYgLT0gMTg7XG4gICAgICAgICAgaiArPSAxO1xuICAgICAgICAgIHRoaXMud29yZHNbal0gfD0gdyA+Pj4gMjY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHBhcnNlTGVuZ3RoID0gbnVtYmVyLmxlbmd0aCAtIHN0YXJ0O1xuICAgICAgZm9yIChpID0gcGFyc2VMZW5ndGggJSAyID09PSAwID8gc3RhcnQgKyAxIDogc3RhcnQ7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgdyA9IHBhcnNlSGV4Qnl0ZShudW1iZXIsIHN0YXJ0LCBpKSA8PCBvZmY7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gdyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgaWYgKG9mZiA+PSAxOCkge1xuICAgICAgICAgIG9mZiAtPSAxODtcbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ID4+PiAyNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvZmYgKz0gODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VCYXNlIChzdHIsIHN0YXJ0LCBlbmQsIG11bCkge1xuICAgIHZhciByID0gMDtcbiAgICB2YXIgYiA9IDA7XG4gICAgdmFyIGxlbiA9IE1hdGgubWluKHN0ci5sZW5ndGgsIGVuZCk7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhciBjID0gc3RyLmNoYXJDb2RlQXQoaSkgLSA0ODtcblxuICAgICAgciAqPSBtdWw7XG5cbiAgICAgIC8vICdhJ1xuICAgICAgaWYgKGMgPj0gNDkpIHtcbiAgICAgICAgYiA9IGMgLSA0OSArIDB4YTtcblxuICAgICAgLy8gJ0EnXG4gICAgICB9IGVsc2UgaWYgKGMgPj0gMTcpIHtcbiAgICAgICAgYiA9IGMgLSAxNyArIDB4YTtcblxuICAgICAgLy8gJzAnIC0gJzknXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiID0gYztcbiAgICAgIH1cbiAgICAgIGFzc2VydChjID49IDAgJiYgYiA8IG11bCwgJ0ludmFsaWQgY2hhcmFjdGVyJyk7XG4gICAgICByICs9IGI7XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9wYXJzZUJhc2UgPSBmdW5jdGlvbiBfcGFyc2VCYXNlIChudW1iZXIsIGJhc2UsIHN0YXJ0KSB7XG4gICAgLy8gSW5pdGlhbGl6ZSBhcyB6ZXJvXG4gICAgdGhpcy53b3JkcyA9IFswXTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG5cbiAgICAvLyBGaW5kIGxlbmd0aCBvZiBsaW1iIGluIGJhc2VcbiAgICBmb3IgKHZhciBsaW1iTGVuID0gMCwgbGltYlBvdyA9IDE7IGxpbWJQb3cgPD0gMHgzZmZmZmZmOyBsaW1iUG93ICo9IGJhc2UpIHtcbiAgICAgIGxpbWJMZW4rKztcbiAgICB9XG4gICAgbGltYkxlbi0tO1xuICAgIGxpbWJQb3cgPSAobGltYlBvdyAvIGJhc2UpIHwgMDtcblxuICAgIHZhciB0b3RhbCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcbiAgICB2YXIgbW9kID0gdG90YWwgJSBsaW1iTGVuO1xuICAgIHZhciBlbmQgPSBNYXRoLm1pbih0b3RhbCwgdG90YWwgLSBtb2QpICsgc3RhcnQ7XG5cbiAgICB2YXIgd29yZCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGxpbWJMZW4pIHtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBpICsgbGltYkxlbiwgYmFzZSk7XG5cbiAgICAgIHRoaXMuaW11bG4obGltYlBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZCAhPT0gMCkge1xuICAgICAgdmFyIHBvdyA9IDE7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgbnVtYmVyLmxlbmd0aCwgYmFzZSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtb2Q7IGkrKykge1xuICAgICAgICBwb3cgKj0gYmFzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbXVsbihwb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5IChkZXN0KSB7XG4gICAgZGVzdC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZXN0LndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICB9XG4gICAgZGVzdC5sZW5ndGggPSB0aGlzLmxlbmd0aDtcbiAgICBkZXN0Lm5lZ2F0aXZlID0gdGhpcy5uZWdhdGl2ZTtcbiAgICBkZXN0LnJlZCA9IHRoaXMucmVkO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1vdmUgKGRlc3QsIHNyYykge1xuICAgIGRlc3Qud29yZHMgPSBzcmMud29yZHM7XG4gICAgZGVzdC5sZW5ndGggPSBzcmMubGVuZ3RoO1xuICAgIGRlc3QubmVnYXRpdmUgPSBzcmMubmVnYXRpdmU7XG4gICAgZGVzdC5yZWQgPSBzcmMucmVkO1xuICB9XG5cbiAgQk4ucHJvdG90eXBlLl9tb3ZlID0gZnVuY3Rpb24gX21vdmUgKGRlc3QpIHtcbiAgICBtb3ZlKGRlc3QsIHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uIGNsb25lICgpIHtcbiAgICB2YXIgciA9IG5ldyBCTihudWxsKTtcbiAgICB0aGlzLmNvcHkocik7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9leHBhbmQgPSBmdW5jdGlvbiBfZXhwYW5kIChzaXplKSB7XG4gICAgd2hpbGUgKHRoaXMubGVuZ3RoIDwgc2l6ZSkge1xuICAgICAgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCsrXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFJlbW92ZSBsZWFkaW5nIGAwYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuX3N0cmlwID0gZnVuY3Rpb24gc3RyaXAgKCkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA+IDEgJiYgdGhpcy53b3Jkc1t0aGlzLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICB0aGlzLmxlbmd0aC0tO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX25vcm1TaWduID0gZnVuY3Rpb24gX25vcm1TaWduICgpIHtcbiAgICAvLyAtMCA9IDBcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEgJiYgdGhpcy53b3Jkc1swXSA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIENoZWNrIFN5bWJvbC5mb3IgYmVjYXVzZSBub3QgZXZlcnl3aGVyZSB3aGVyZSBTeW1ib2wgZGVmaW5lZFxuICAvLyBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3ltYm9sI0Jyb3dzZXJfY29tcGF0aWJpbGl0eVxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgQk4ucHJvdG90eXBlW1N5bWJvbC5mb3IoJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldID0gaW5zcGVjdDtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBCTi5wcm90b3R5cGUuaW5zcGVjdCA9IGluc3BlY3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIEJOLnByb3RvdHlwZS5pbnNwZWN0ID0gaW5zcGVjdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgIHJldHVybiAodGhpcy5yZWQgPyAnPEJOLVI6ICcgOiAnPEJOOiAnKSArIHRoaXMudG9TdHJpbmcoMTYpICsgJz4nO1xuICB9XG5cbiAgLypcblxuICB2YXIgemVyb3MgPSBbXTtcbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXTtcbiAgdmFyIGdyb3VwQmFzZXMgPSBbXTtcblxuICB2YXIgcyA9ICcnO1xuICB2YXIgaSA9IC0xO1xuICB3aGlsZSAoKytpIDwgQk4ud29yZFNpemUpIHtcbiAgICB6ZXJvc1tpXSA9IHM7XG4gICAgcyArPSAnMCc7XG4gIH1cbiAgZ3JvdXBTaXplc1swXSA9IDA7XG4gIGdyb3VwU2l6ZXNbMV0gPSAwO1xuICBncm91cEJhc2VzWzBdID0gMDtcbiAgZ3JvdXBCYXNlc1sxXSA9IDA7XG4gIHZhciBiYXNlID0gMiAtIDE7XG4gIHdoaWxlICgrK2Jhc2UgPCAzNiArIDEpIHtcbiAgICB2YXIgZ3JvdXBTaXplID0gMDtcbiAgICB2YXIgZ3JvdXBCYXNlID0gMTtcbiAgICB3aGlsZSAoZ3JvdXBCYXNlIDwgKDEgPDwgQk4ud29yZFNpemUpIC8gYmFzZSkge1xuICAgICAgZ3JvdXBCYXNlICo9IGJhc2U7XG4gICAgICBncm91cFNpemUgKz0gMTtcbiAgICB9XG4gICAgZ3JvdXBTaXplc1tiYXNlXSA9IGdyb3VwU2l6ZTtcbiAgICBncm91cEJhc2VzW2Jhc2VdID0gZ3JvdXBCYXNlO1xuICB9XG5cbiAgKi9cblxuICB2YXIgemVyb3MgPSBbXG4gICAgJycsXG4gICAgJzAnLFxuICAgICcwMCcsXG4gICAgJzAwMCcsXG4gICAgJzAwMDAnLFxuICAgICcwMDAwMCcsXG4gICAgJzAwMDAwMCcsXG4gICAgJzAwMDAwMDAnLFxuICAgICcwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnXG4gIF07XG5cbiAgdmFyIGdyb3VwU2l6ZXMgPSBbXG4gICAgMCwgMCxcbiAgICAyNSwgMTYsIDEyLCAxMSwgMTAsIDksIDgsXG4gICAgOCwgNywgNywgNywgNywgNiwgNixcbiAgICA2LCA2LCA2LCA2LCA2LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDUsXG4gICAgNSwgNSwgNSwgNSwgNSwgNSwgNVxuICBdO1xuXG4gIHZhciBncm91cEJhc2VzID0gW1xuICAgIDAsIDAsXG4gICAgMzM1NTQ0MzIsIDQzMDQ2NzIxLCAxNjc3NzIxNiwgNDg4MjgxMjUsIDYwNDY2MTc2LCA0MDM1MzYwNywgMTY3NzcyMTYsXG4gICAgNDMwNDY3MjEsIDEwMDAwMDAwLCAxOTQ4NzE3MSwgMzU4MzE4MDgsIDYyNzQ4NTE3LCA3NTI5NTM2LCAxMTM5MDYyNSxcbiAgICAxNjc3NzIxNiwgMjQxMzc1NjksIDM0MDEyMjI0LCA0NzA0NTg4MSwgNjQwMDAwMDAsIDQwODQxMDEsIDUxNTM2MzIsXG4gICAgNjQzNjM0MywgNzk2MjYyNCwgOTc2NTYyNSwgMTE4ODEzNzYsIDE0MzQ4OTA3LCAxNzIxMDM2OCwgMjA1MTExNDksXG4gICAgMjQzMDAwMDAsIDI4NjI5MTUxLCAzMzU1NDQzMiwgMzkxMzUzOTMsIDQ1NDM1NDI0LCA1MjUyMTg3NSwgNjA0NjYxNzZcbiAgXTtcblxuICBCTi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoYmFzZSwgcGFkZGluZykge1xuICAgIGJhc2UgPSBiYXNlIHx8IDEwO1xuICAgIHBhZGRpbmcgPSBwYWRkaW5nIHwgMCB8fCAxO1xuXG4gICAgdmFyIG91dDtcbiAgICBpZiAoYmFzZSA9PT0gMTYgfHwgYmFzZSA9PT0gJ2hleCcpIHtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIG9mZiA9IDA7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgICAgdmFyIHdvcmQgPSAoKCh3IDw8IG9mZikgfCBjYXJyeSkgJiAweGZmZmZmZikudG9TdHJpbmcoMTYpO1xuICAgICAgICBjYXJyeSA9ICh3ID4+PiAoMjQgLSBvZmYpKSAmIDB4ZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBpLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNhcnJ5ICE9PSAwIHx8IGkgIT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIG91dCA9IHplcm9zWzYgLSB3b3JkLmxlbmd0aF0gKyB3b3JkICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHdvcmQgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgICBvdXQgPSBjYXJyeS50b1N0cmluZygxNikgKyBvdXQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAob3V0Lmxlbmd0aCAlIHBhZGRpbmcgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJzAnICsgb3V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgb3V0ID0gJy0nICsgb3V0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG5cbiAgICBpZiAoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNikge1xuICAgICAgLy8gdmFyIGdyb3VwU2l6ZSA9IE1hdGguZmxvb3IoQk4ud29yZFNpemUgKiBNYXRoLkxOMiAvIE1hdGgubG9nKGJhc2UpKTtcbiAgICAgIHZhciBncm91cFNpemUgPSBncm91cFNpemVzW2Jhc2VdO1xuICAgICAgLy8gdmFyIGdyb3VwQmFzZSA9IE1hdGgucG93KGJhc2UsIGdyb3VwU2l6ZSk7XG4gICAgICB2YXIgZ3JvdXBCYXNlID0gZ3JvdXBCYXNlc1tiYXNlXTtcbiAgICAgIG91dCA9ICcnO1xuICAgICAgdmFyIGMgPSB0aGlzLmNsb25lKCk7XG4gICAgICBjLm5lZ2F0aXZlID0gMDtcbiAgICAgIHdoaWxlICghYy5pc1plcm8oKSkge1xuICAgICAgICB2YXIgciA9IGMubW9kcm4oZ3JvdXBCYXNlKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgYyA9IGMuaWRpdm4oZ3JvdXBCYXNlKTtcblxuICAgICAgICBpZiAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1tncm91cFNpemUgLSByLmxlbmd0aF0gKyByICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHIgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGFzc2VydChmYWxzZSwgJ0Jhc2Ugc2hvdWxkIGJlIGJldHdlZW4gMiBhbmQgMzYnKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlciAoKSB7XG4gICAgdmFyIHJldCA9IHRoaXMud29yZHNbMF07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXQgKz0gdGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID09PSAzICYmIHRoaXMud29yZHNbMl0gPT09IDB4MDEpIHtcbiAgICAgIC8vIE5PVEU6IGF0IHRoaXMgc3RhZ2UgaXQgaXMga25vd24gdGhhdCB0aGUgdG9wIGJpdCBpcyBzZXRcbiAgICAgIHJldCArPSAweDEwMDAwMDAwMDAwMDAwICsgKHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiAyKSB7XG4gICAgICBhc3NlcnQoZmFsc2UsICdOdW1iZXIgY2FuIG9ubHkgc2FmZWx5IHN0b3JlIHVwIHRvIDUzIGJpdHMnKTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLm5lZ2F0aXZlICE9PSAwKSA/IC1yZXQgOiByZXQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoMTYsIDIpO1xuICB9O1xuXG4gIGlmIChCdWZmZXIpIHtcbiAgICBCTi5wcm90b3R5cGUudG9CdWZmZXIgPSBmdW5jdGlvbiB0b0J1ZmZlciAoZW5kaWFuLCBsZW5ndGgpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEJ1ZmZlciwgZW5kaWFuLCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICBCTi5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uIHRvQXJyYXkgKGVuZGlhbiwgbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQXJyYXksIGVuZGlhbiwgbGVuZ3RoKTtcbiAgfTtcblxuICB2YXIgYWxsb2NhdGUgPSBmdW5jdGlvbiBhbGxvY2F0ZSAoQXJyYXlUeXBlLCBzaXplKSB7XG4gICAgaWYgKEFycmF5VHlwZS5hbGxvY1Vuc2FmZSkge1xuICAgICAgcmV0dXJuIEFycmF5VHlwZS5hbGxvY1Vuc2FmZShzaXplKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBBcnJheVR5cGUoc2l6ZSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXlMaWtlID0gZnVuY3Rpb24gdG9BcnJheUxpa2UgKEFycmF5VHlwZSwgZW5kaWFuLCBsZW5ndGgpIHtcbiAgICB0aGlzLl9zdHJpcCgpO1xuXG4gICAgdmFyIGJ5dGVMZW5ndGggPSB0aGlzLmJ5dGVMZW5ndGgoKTtcbiAgICB2YXIgcmVxTGVuZ3RoID0gbGVuZ3RoIHx8IE1hdGgubWF4KDEsIGJ5dGVMZW5ndGgpO1xuICAgIGFzc2VydChieXRlTGVuZ3RoIDw9IHJlcUxlbmd0aCwgJ2J5dGUgYXJyYXkgbG9uZ2VyIHRoYW4gZGVzaXJlZCBsZW5ndGgnKTtcbiAgICBhc3NlcnQocmVxTGVuZ3RoID4gMCwgJ1JlcXVlc3RlZCBhcnJheSBsZW5ndGggPD0gMCcpO1xuXG4gICAgdmFyIHJlcyA9IGFsbG9jYXRlKEFycmF5VHlwZSwgcmVxTGVuZ3RoKTtcbiAgICB2YXIgcG9zdGZpeCA9IGVuZGlhbiA9PT0gJ2xlJyA/ICdMRScgOiAnQkUnO1xuICAgIHRoaXNbJ190b0FycmF5TGlrZScgKyBwb3N0Zml4XShyZXMsIGJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl90b0FycmF5TGlrZUxFID0gZnVuY3Rpb24gX3RvQXJyYXlMaWtlTEUgKHJlcywgYnl0ZUxlbmd0aCkge1xuICAgIHZhciBwb3NpdGlvbiA9IDA7XG4gICAgdmFyIGNhcnJ5ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwLCBzaGlmdCA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd29yZCA9ICh0aGlzLndvcmRzW2ldIDw8IHNoaWZ0KSB8IGNhcnJ5O1xuXG4gICAgICByZXNbcG9zaXRpb24rK10gPSB3b3JkICYgMHhmZjtcbiAgICAgIGlmIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uKytdID0gKHdvcmQgPj4gOCkgJiAweGZmO1xuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICByZXNbcG9zaXRpb24rK10gPSAod29yZCA+PiAxNikgJiAweGZmO1xuICAgICAgfVxuXG4gICAgICBpZiAoc2hpZnQgPT09IDYpIHtcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgcmVzLmxlbmd0aCkge1xuICAgICAgICAgIHJlc1twb3NpdGlvbisrXSA9ICh3b3JkID4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIH1cbiAgICAgICAgY2FycnkgPSAwO1xuICAgICAgICBzaGlmdCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYXJyeSA9IHdvcmQgPj4+IDI0O1xuICAgICAgICBzaGlmdCArPSAyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwb3NpdGlvbiA8IHJlcy5sZW5ndGgpIHtcbiAgICAgIHJlc1twb3NpdGlvbisrXSA9IGNhcnJ5O1xuXG4gICAgICB3aGlsZSAocG9zaXRpb24gPCByZXMubGVuZ3RoKSB7XG4gICAgICAgIHJlc1twb3NpdGlvbisrXSA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fdG9BcnJheUxpa2VCRSA9IGZ1bmN0aW9uIF90b0FycmF5TGlrZUJFIChyZXMsIGJ5dGVMZW5ndGgpIHtcbiAgICB2YXIgcG9zaXRpb24gPSByZXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIHNoaWZ0ID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3b3JkID0gKHRoaXMud29yZHNbaV0gPDwgc2hpZnQpIHwgY2Fycnk7XG5cbiAgICAgIHJlc1twb3NpdGlvbi0tXSA9IHdvcmQgJiAweGZmO1xuICAgICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gKHdvcmQgPj4gOCkgJiAweGZmO1xuICAgICAgfVxuICAgICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gKHdvcmQgPj4gMTYpICYgMHhmZjtcbiAgICAgIH1cblxuICAgICAgaWYgKHNoaWZ0ID09PSA2KSB7XG4gICAgICAgIGlmIChwb3NpdGlvbiA+PSAwKSB7XG4gICAgICAgICAgcmVzW3Bvc2l0aW9uLS1dID0gKHdvcmQgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgICBjYXJyeSA9IDA7XG4gICAgICAgIHNoaWZ0ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gd29yZCA+Pj4gMjQ7XG4gICAgICAgIHNoaWZ0ICs9IDI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uID49IDApIHtcbiAgICAgIHJlc1twb3NpdGlvbi0tXSA9IGNhcnJ5O1xuXG4gICAgICB3aGlsZSAocG9zaXRpb24gPj0gMCkge1xuICAgICAgICByZXNbcG9zaXRpb24tLV0gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBpZiAoTWF0aC5jbHozMikge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgcmV0dXJuIDMyIC0gTWF0aC5jbHozMih3KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgdmFyIHQgPSB3O1xuICAgICAgdmFyIHIgPSAwO1xuICAgICAgaWYgKHQgPj0gMHgxMDAwKSB7XG4gICAgICAgIHIgKz0gMTM7XG4gICAgICAgIHQgPj4+PSAxMztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4NDApIHtcbiAgICAgICAgciArPSA3O1xuICAgICAgICB0ID4+Pj0gNztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4OCkge1xuICAgICAgICByICs9IDQ7XG4gICAgICAgIHQgPj4+PSA0O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHgwMikge1xuICAgICAgICByICs9IDI7XG4gICAgICAgIHQgPj4+PSAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHIgKyB0O1xuICAgIH07XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3plcm9CaXRzID0gZnVuY3Rpb24gX3plcm9CaXRzICh3KSB7XG4gICAgLy8gU2hvcnQtY3V0XG4gICAgaWYgKHcgPT09IDApIHJldHVybiAyNjtcblxuICAgIHZhciB0ID0gdztcbiAgICB2YXIgciA9IDA7XG4gICAgaWYgKCh0ICYgMHgxZmZmKSA9PT0gMCkge1xuICAgICAgciArPSAxMztcbiAgICAgIHQgPj4+PSAxMztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHg3ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNztcbiAgICAgIHQgPj4+PSA3O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweGYpID09PSAwKSB7XG4gICAgICByICs9IDQ7XG4gICAgICB0ID4+Pj0gNDtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgzKSA9PT0gMCkge1xuICAgICAgciArPSAyO1xuICAgICAgdCA+Pj49IDI7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MSkgPT09IDApIHtcbiAgICAgIHIrKztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG51bWJlciBvZiB1c2VkIGJpdHMgaW4gYSBCTlxuICBCTi5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gYml0TGVuZ3RoICgpIHtcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgaGkgPSB0aGlzLl9jb3VudEJpdHModyk7XG4gICAgcmV0dXJuICh0aGlzLmxlbmd0aCAtIDEpICogMjYgKyBoaTtcbiAgfTtcblxuICBmdW5jdGlvbiB0b0JpdEFycmF5IChudW0pIHtcbiAgICB2YXIgdyA9IG5ldyBBcnJheShudW0uYml0TGVuZ3RoKCkpO1xuXG4gICAgZm9yICh2YXIgYml0ID0gMDsgYml0IDwgdy5sZW5ndGg7IGJpdCsrKSB7XG4gICAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgICB3W2JpdF0gPSAobnVtLndvcmRzW29mZl0gPj4+IHdiaXQpICYgMHgwMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdztcbiAgfVxuXG4gIC8vIE51bWJlciBvZiB0cmFpbGluZyB6ZXJvIGJpdHNcbiAgQk4ucHJvdG90eXBlLnplcm9CaXRzID0gZnVuY3Rpb24gemVyb0JpdHMgKCkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gMDtcblxuICAgIHZhciByID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBiID0gdGhpcy5femVyb0JpdHModGhpcy53b3Jkc1tpXSk7XG4gICAgICByICs9IGI7XG4gICAgICBpZiAoYiAhPT0gMjYpIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYnl0ZUxlbmd0aCA9IGZ1bmN0aW9uIGJ5dGVMZW5ndGggKCkge1xuICAgIHJldHVybiBNYXRoLmNlaWwodGhpcy5iaXRMZW5ndGgoKSAvIDgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b1R3b3MgPSBmdW5jdGlvbiB0b1R3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmFicygpLmlub3RuKHdpZHRoKS5pYWRkbigxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZnJvbVR3b3MgPSBmdW5jdGlvbiBmcm9tVHdvcyAod2lkdGgpIHtcbiAgICBpZiAodGhpcy50ZXN0bih3aWR0aCAtIDEpKSB7XG4gICAgICByZXR1cm4gdGhpcy5ub3RuKHdpZHRoKS5pYWRkbigxKS5pbmVnKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzTmVnID0gZnVuY3Rpb24gaXNOZWcgKCkge1xuICAgIHJldHVybiB0aGlzLm5lZ2F0aXZlICE9PSAwO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbmVnKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmluZWcgPSBmdW5jdGlvbiBpbmVnICgpIHtcbiAgICBpZiAoIXRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBPciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXVvciA9IGZ1bmN0aW9uIGl1b3IgKG51bSkge1xuICAgIHdoaWxlICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGgrK10gPSAwO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXSB8IG51bS53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW9yID0gZnVuY3Rpb24gaW9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdW9yKG51bSk7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudW9yID0gZnVuY3Rpb24gdW9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVvcih0aGlzKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1YW5kID0gZnVuY3Rpb24gaXVhbmQgKG51bSkge1xuICAgIC8vIGIgPSBtaW4tbGVuZ3RoKG51bSwgdGhpcylcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldICYgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYi5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFuZCA9IGZ1bmN0aW9uIGlhbmQgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1YW5kKG51bSk7XG4gIH07XG5cbiAgLy8gQW5kIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5hbmQgPSBmdW5jdGlvbiBhbmQgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYW5kKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51YW5kID0gZnVuY3Rpb24gdWFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdWFuZChudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdWFuZCh0aGlzKTtcbiAgfTtcblxuICAvLyBYb3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1eG9yID0gZnVuY3Rpb24gaXV4b3IgKG51bSkge1xuICAgIC8vIGEubGVuZ3RoID4gYi5sZW5ndGhcbiAgICB2YXIgYTtcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBhID0gdGhpcztcbiAgICAgIGIgPSBudW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBudW07XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldIF4gYi53b3Jkc1tpXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcyAhPT0gYSkge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXhvciA9IGZ1bmN0aW9uIGl4b3IgKG51bSkge1xuICAgIGFzc2VydCgodGhpcy5uZWdhdGl2ZSB8IG51bS5uZWdhdGl2ZSkgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1eG9yKG51bSk7XG4gIH07XG5cbiAgLy8gWG9yIGBudW1gIHdpdGggYHRoaXNgXG4gIEJOLnByb3RvdHlwZS54b3IgPSBmdW5jdGlvbiB4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5peG9yKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51eG9yID0gZnVuY3Rpb24gdXhvciAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXhvcihudW0pO1xuICAgIHJldHVybiBudW0uY2xvbmUoKS5pdXhvcih0aGlzKTtcbiAgfTtcblxuICAvLyBOb3QgYGB0aGlzYGAgd2l0aCBgYHdpZHRoYGAgYml0d2lkdGhcbiAgQk4ucHJvdG90eXBlLmlub3RuID0gZnVuY3Rpb24gaW5vdG4gKHdpZHRoKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiB3aWR0aCA9PT0gJ251bWJlcicgJiYgd2lkdGggPj0gMCk7XG5cbiAgICB2YXIgYnl0ZXNOZWVkZWQgPSBNYXRoLmNlaWwod2lkdGggLyAyNikgfCAwO1xuICAgIHZhciBiaXRzTGVmdCA9IHdpZHRoICUgMjY7XG5cbiAgICAvLyBFeHRlbmQgdGhlIGJ1ZmZlciB3aXRoIGxlYWRpbmcgemVyb2VzXG4gICAgdGhpcy5fZXhwYW5kKGJ5dGVzTmVlZGVkKTtcblxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIGJ5dGVzTmVlZGVkLS07XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIGNvbXBsZXRlIHdvcmRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlc05lZWRlZDsgaSsrKSB7XG4gICAgICB0aGlzLndvcmRzW2ldID0gfnRoaXMud29yZHNbaV0gJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgLy8gSGFuZGxlIHRoZSByZXNpZHVlXG4gICAgaWYgKGJpdHNMZWZ0ID4gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgKDB4M2ZmZmZmZiA+PiAoMjYgLSBiaXRzTGVmdCkpO1xuICAgIH1cblxuICAgIC8vIEFuZCByZW1vdmUgbGVhZGluZyB6ZXJvZXNcbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubm90biA9IGZ1bmN0aW9uIG5vdG4gKHdpZHRoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bih3aWR0aCk7XG4gIH07XG5cbiAgLy8gU2V0IGBiaXRgIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc2V0biA9IGZ1bmN0aW9uIHNldG4gKGJpdCwgdmFsKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcblxuICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgdGhpcy5fZXhwYW5kKG9mZiArIDEpO1xuXG4gICAgaWYgKHZhbCkge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdIHwgKDEgPDwgd2JpdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSAmIH4oMSA8PCB3Yml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICAvLyBBZGQgYG51bWAgdG8gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAobnVtKSB7XG4gICAgdmFyIHI7XG5cbiAgICAvLyBuZWdhdGl2ZSArIHBvc2l0aXZlXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiB0aGlzLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gcG9zaXRpdmUgKyBuZWdhdGl2ZVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByID0gdGhpcy5pc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHIuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhLCBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSByID4+PiAyNjtcbiAgICB9XG4gICAgZm9yICg7IGNhcnJ5ICE9PSAwICYmIGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgaWYgKGNhcnJ5ICE9PSAwKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICAvLyBDb3B5IHRoZSByZXN0IG9mIHRoZSB3b3Jkc1xuICAgIH0gZWxzZSBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgZm9yICg7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBhLndvcmRzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZCAobnVtKSB7XG4gICAgdmFyIHJlcztcbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwICYmIHRoaXMubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSB0aGlzLnN1YihudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlIF49IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH0gZWxzZSBpZiAobnVtLm5lZ2F0aXZlID09PSAwICYmIHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgcmVzID0gbnVtLnN1Yih0aGlzKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLmlhZGQobnVtKTtcblxuICAgIHJldHVybiBudW0uY2xvbmUoKS5pYWRkKHRoaXMpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgIGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAobnVtKSB7XG4gICAgLy8gdGhpcyAtICgtbnVtKSA9IHRoaXMgKyBudW1cbiAgICBpZiAobnVtLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBudW0ubmVnYXRpdmUgPSAwO1xuICAgICAgdmFyIHIgPSB0aGlzLmlhZGQobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcblxuICAgIC8vIC10aGlzIC0gbnVtID0gLSh0aGlzICsgbnVtKVxuICAgIH0gZWxzZSBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGQobnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gICAgfVxuXG4gICAgLy8gQXQgdGhpcyBwb2ludCBib3RoIG51bWJlcnMgYXJlIHBvc2l0aXZlXG4gICAgdmFyIGNtcCA9IHRoaXMuY21wKG51bSk7XG5cbiAgICAvLyBPcHRpbWl6YXRpb24gLSB6ZXJvaWZ5XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGEgPiBiXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKGNtcCA+IDApIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gICAgICByID0gKGEud29yZHNbaV0gfCAwKSAtIChiLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICBjYXJyeSA9IHIgPj4gMjY7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICB9XG5cbiAgICAvLyBDb3B5IHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgaWYgKGNhcnJ5ID09PSAwICYmIGkgPCBhLmxlbmd0aCAmJiBhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLm1heCh0aGlzLmxlbmd0aCwgaSk7XG5cbiAgICBpZiAoYSAhPT0gdGhpcykge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc3ViKG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gc21hbGxNdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICBvdXQubmVnYXRpdmUgPSBudW0ubmVnYXRpdmUgXiBzZWxmLm5lZ2F0aXZlO1xuICAgIHZhciBsZW4gPSAoc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoKSB8IDA7XG4gICAgb3V0Lmxlbmd0aCA9IGxlbjtcbiAgICBsZW4gPSAobGVuIC0gMSkgfCAwO1xuXG4gICAgLy8gUGVlbCBvbmUgaXRlcmF0aW9uIChjb21waWxlciBjYW4ndCBkbyBpdCwgYmVjYXVzZSBvZiBjb2RlIGNvbXBsZXhpdHkpXG4gICAgdmFyIGEgPSBzZWxmLndvcmRzWzBdIHwgMDtcbiAgICB2YXIgYiA9IG51bS53b3Jkc1swXSB8IDA7XG4gICAgdmFyIHIgPSBhICogYjtcblxuICAgIHZhciBsbyA9IHIgJiAweDNmZmZmZmY7XG4gICAgdmFyIGNhcnJ5ID0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICBvdXQud29yZHNbMF0gPSBsbztcblxuICAgIGZvciAodmFyIGsgPSAxOyBrIDwgbGVuOyBrKyspIHtcbiAgICAgIC8vIFN1bSBhbGwgd29yZHMgd2l0aCB0aGUgc2FtZSBgaSArIGogPSBrYCBhbmQgYWNjdW11bGF0ZSBgbmNhcnJ5YCxcbiAgICAgIC8vIG5vdGUgdGhhdCBuY2FycnkgY291bGQgYmUgPj0gMHgzZmZmZmZmXG4gICAgICB2YXIgbmNhcnJ5ID0gY2FycnkgPj4+IDI2O1xuICAgICAgdmFyIHJ3b3JkID0gY2FycnkgJiAweDNmZmZmZmY7XG4gICAgICB2YXIgbWF4SiA9IE1hdGgubWluKGssIG51bS5sZW5ndGggLSAxKTtcbiAgICAgIGZvciAodmFyIGogPSBNYXRoLm1heCgwLCBrIC0gc2VsZi5sZW5ndGggKyAxKTsgaiA8PSBtYXhKOyBqKyspIHtcbiAgICAgICAgdmFyIGkgPSAoayAtIGopIHwgMDtcbiAgICAgICAgYSA9IHNlbGYud29yZHNbaV0gfCAwO1xuICAgICAgICBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgciA9IGEgKiBiICsgcndvcmQ7XG4gICAgICAgIG5jYXJyeSArPSAociAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgICByd29yZCA9IHIgJiAweDNmZmZmZmY7XG4gICAgICB9XG4gICAgICBvdXQud29yZHNba10gPSByd29yZCB8IDA7XG4gICAgICBjYXJyeSA9IG5jYXJyeSB8IDA7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2FycnkgfCAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQubGVuZ3RoLS07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dC5fc3RyaXAoKTtcbiAgfVxuXG4gIC8vIFRPRE8oaW5kdXRueSk6IGl0IG1heSBiZSByZWFzb25hYmxlIHRvIG9taXQgaXQgZm9yIHVzZXJzIHdobyBkb24ndCBuZWVkXG4gIC8vIHRvIHdvcmsgd2l0aCAyNTYtYml0IG51bWJlcnMsIG90aGVyd2lzZSBpdCBnaXZlcyAyMCUgaW1wcm92ZW1lbnQgZm9yIDI1Ni1iaXRcbiAgLy8gbXVsdGlwbGljYXRpb24gKGxpa2UgZWxsaXB0aWMgc2VjcDI1NmsxKS5cbiAgdmFyIGNvbWIxME11bFRvID0gZnVuY3Rpb24gY29tYjEwTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGEgPSBzZWxmLndvcmRzO1xuICAgIHZhciBiID0gbnVtLndvcmRzO1xuICAgIHZhciBvID0gb3V0LndvcmRzO1xuICAgIHZhciBjID0gMDtcbiAgICB2YXIgbG87XG4gICAgdmFyIG1pZDtcbiAgICB2YXIgaGk7XG4gICAgdmFyIGEwID0gYVswXSB8IDA7XG4gICAgdmFyIGFsMCA9IGEwICYgMHgxZmZmO1xuICAgIHZhciBhaDAgPSBhMCA+Pj4gMTM7XG4gICAgdmFyIGExID0gYVsxXSB8IDA7XG4gICAgdmFyIGFsMSA9IGExICYgMHgxZmZmO1xuICAgIHZhciBhaDEgPSBhMSA+Pj4gMTM7XG4gICAgdmFyIGEyID0gYVsyXSB8IDA7XG4gICAgdmFyIGFsMiA9IGEyICYgMHgxZmZmO1xuICAgIHZhciBhaDIgPSBhMiA+Pj4gMTM7XG4gICAgdmFyIGEzID0gYVszXSB8IDA7XG4gICAgdmFyIGFsMyA9IGEzICYgMHgxZmZmO1xuICAgIHZhciBhaDMgPSBhMyA+Pj4gMTM7XG4gICAgdmFyIGE0ID0gYVs0XSB8IDA7XG4gICAgdmFyIGFsNCA9IGE0ICYgMHgxZmZmO1xuICAgIHZhciBhaDQgPSBhNCA+Pj4gMTM7XG4gICAgdmFyIGE1ID0gYVs1XSB8IDA7XG4gICAgdmFyIGFsNSA9IGE1ICYgMHgxZmZmO1xuICAgIHZhciBhaDUgPSBhNSA+Pj4gMTM7XG4gICAgdmFyIGE2ID0gYVs2XSB8IDA7XG4gICAgdmFyIGFsNiA9IGE2ICYgMHgxZmZmO1xuICAgIHZhciBhaDYgPSBhNiA+Pj4gMTM7XG4gICAgdmFyIGE3ID0gYVs3XSB8IDA7XG4gICAgdmFyIGFsNyA9IGE3ICYgMHgxZmZmO1xuICAgIHZhciBhaDcgPSBhNyA+Pj4gMTM7XG4gICAgdmFyIGE4ID0gYVs4XSB8IDA7XG4gICAgdmFyIGFsOCA9IGE4ICYgMHgxZmZmO1xuICAgIHZhciBhaDggPSBhOCA+Pj4gMTM7XG4gICAgdmFyIGE5ID0gYVs5XSB8IDA7XG4gICAgdmFyIGFsOSA9IGE5ICYgMHgxZmZmO1xuICAgIHZhciBhaDkgPSBhOSA+Pj4gMTM7XG4gICAgdmFyIGIwID0gYlswXSB8IDA7XG4gICAgdmFyIGJsMCA9IGIwICYgMHgxZmZmO1xuICAgIHZhciBiaDAgPSBiMCA+Pj4gMTM7XG4gICAgdmFyIGIxID0gYlsxXSB8IDA7XG4gICAgdmFyIGJsMSA9IGIxICYgMHgxZmZmO1xuICAgIHZhciBiaDEgPSBiMSA+Pj4gMTM7XG4gICAgdmFyIGIyID0gYlsyXSB8IDA7XG4gICAgdmFyIGJsMiA9IGIyICYgMHgxZmZmO1xuICAgIHZhciBiaDIgPSBiMiA+Pj4gMTM7XG4gICAgdmFyIGIzID0gYlszXSB8IDA7XG4gICAgdmFyIGJsMyA9IGIzICYgMHgxZmZmO1xuICAgIHZhciBiaDMgPSBiMyA+Pj4gMTM7XG4gICAgdmFyIGI0ID0gYls0XSB8IDA7XG4gICAgdmFyIGJsNCA9IGI0ICYgMHgxZmZmO1xuICAgIHZhciBiaDQgPSBiNCA+Pj4gMTM7XG4gICAgdmFyIGI1ID0gYls1XSB8IDA7XG4gICAgdmFyIGJsNSA9IGI1ICYgMHgxZmZmO1xuICAgIHZhciBiaDUgPSBiNSA+Pj4gMTM7XG4gICAgdmFyIGI2ID0gYls2XSB8IDA7XG4gICAgdmFyIGJsNiA9IGI2ICYgMHgxZmZmO1xuICAgIHZhciBiaDYgPSBiNiA+Pj4gMTM7XG4gICAgdmFyIGI3ID0gYls3XSB8IDA7XG4gICAgdmFyIGJsNyA9IGI3ICYgMHgxZmZmO1xuICAgIHZhciBiaDcgPSBiNyA+Pj4gMTM7XG4gICAgdmFyIGI4ID0gYls4XSB8IDA7XG4gICAgdmFyIGJsOCA9IGI4ICYgMHgxZmZmO1xuICAgIHZhciBiaDggPSBiOCA+Pj4gMTM7XG4gICAgdmFyIGI5ID0gYls5XSB8IDA7XG4gICAgdmFyIGJsOSA9IGI5ICYgMHgxZmZmO1xuICAgIHZhciBiaDkgPSBiOSA+Pj4gMTM7XG5cbiAgICBvdXQubmVnYXRpdmUgPSBzZWxmLm5lZ2F0aXZlIF4gbnVtLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSAxOTtcbiAgICAvKiBrID0gMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDApO1xuICAgIHZhciB3MCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzAgPj4+IDI2KSkgfCAwO1xuICAgIHcwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMSkpIHwgMDtcbiAgICB2YXIgdzEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxID4+PiAyNikpIHwgMDtcbiAgICB3MSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDIsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgyKSkgfCAwO1xuICAgIHZhciB3MiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzIgPj4+IDI2KSkgfCAwO1xuICAgIHcyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwzLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgzKSkgfCAwO1xuICAgIHZhciB3MyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzMgPj4+IDI2KSkgfCAwO1xuICAgIHczICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNCkpIHwgMDtcbiAgICB2YXIgdzQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc0ID4+PiAyNikpIHwgMDtcbiAgICB3NCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDUsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg1KSkgfCAwO1xuICAgIHZhciB3NSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzUgPj4+IDI2KSkgfCAwO1xuICAgIHc1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw2LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg2KSkgfCAwO1xuICAgIHZhciB3NiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzYgPj4+IDI2KSkgfCAwO1xuICAgIHc2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNykpIHwgMDtcbiAgICB2YXIgdzcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc3ID4+PiAyNikpIHwgMDtcbiAgICB3NyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDgsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg4KSkgfCAwO1xuICAgIHZhciB3OCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzggPj4+IDI2KSkgfCAwO1xuICAgIHc4ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg5KSkgfCAwO1xuICAgIHZhciB3OSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzkgPj4+IDI2KSkgfCAwO1xuICAgIHc5ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgxKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwxKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgxKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMCA+Pj4gMjYpKSB8IDA7XG4gICAgdzEwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgyKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwyKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgyKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzExID4+PiAyNikpIHwgMDtcbiAgICB3MTEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwzKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDMpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDMpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDMpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMiA+Pj4gMjYpKSB8IDA7XG4gICAgdzEyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg0KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw0KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg0KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMyA+Pj4gMjYpKSB8IDA7XG4gICAgdzEzICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg1KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw1KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg1KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE0ID4+PiAyNikpIHwgMDtcbiAgICB3MTQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw2KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDYpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDYpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDYpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNSA+Pj4gMjYpKSB8IDA7XG4gICAgdzE1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg3KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw3KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg3KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNiA+Pj4gMjYpKSB8IDA7XG4gICAgdzE2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg4KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw4KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg4KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE3ID4+PiAyNikpIHwgMDtcbiAgICB3MTcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw5KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDkpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDkpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDkpO1xuICAgIHZhciB3MTggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxOCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE4ICY9IDB4M2ZmZmZmZjtcbiAgICBvWzBdID0gdzA7XG4gICAgb1sxXSA9IHcxO1xuICAgIG9bMl0gPSB3MjtcbiAgICBvWzNdID0gdzM7XG4gICAgb1s0XSA9IHc0O1xuICAgIG9bNV0gPSB3NTtcbiAgICBvWzZdID0gdzY7XG4gICAgb1s3XSA9IHc3O1xuICAgIG9bOF0gPSB3ODtcbiAgICBvWzldID0gdzk7XG4gICAgb1sxMF0gPSB3MTA7XG4gICAgb1sxMV0gPSB3MTE7XG4gICAgb1sxMl0gPSB3MTI7XG4gICAgb1sxM10gPSB3MTM7XG4gICAgb1sxNF0gPSB3MTQ7XG4gICAgb1sxNV0gPSB3MTU7XG4gICAgb1sxNl0gPSB3MTY7XG4gICAgb1sxN10gPSB3MTc7XG4gICAgb1sxOF0gPSB3MTg7XG4gICAgaWYgKGMgIT09IDApIHtcbiAgICAgIG9bMTldID0gYztcbiAgICAgIG91dC5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcblxuICAvLyBQb2x5ZmlsbCBjb21iXG4gIGlmICghTWF0aC5pbXVsKSB7XG4gICAgY29tYjEwTXVsVG8gPSBzbWFsbE11bFRvO1xuICB9XG5cbiAgZnVuY3Rpb24gYmlnTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICB2YXIgaG5jYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGVuZ3RoIC0gMTsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgICBobmNhcnJ5ID0gMDtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gayAtIGo7XG4gICAgICAgIHZhciBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgdmFyIHIgPSBhICogYjtcblxuICAgICAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKChyIC8gMHg0MDAwMDAwKSB8IDApKSB8IDA7XG4gICAgICAgIGxvID0gKGxvICsgcndvcmQpIHwgMDtcbiAgICAgICAgcndvcmQgPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArIChsbyA+Pj4gMjYpKSB8IDA7XG5cbiAgICAgICAgaG5jYXJyeSArPSBuY2FycnkgPj4+IDI2O1xuICAgICAgICBuY2FycnkgJj0gMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQ7XG4gICAgICBjYXJyeSA9IG5jYXJyeTtcbiAgICAgIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2Fycnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0Ll9zdHJpcCgpO1xuICB9XG5cbiAgZnVuY3Rpb24ganVtYm9NdWxUbyAoc2VsZiwgbnVtLCBvdXQpIHtcbiAgICAvLyBUZW1wb3JhcnkgZGlzYWJsZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9pbmR1dG55L2JuLmpzL2lzc3Vlcy8yMTFcbiAgICAvLyB2YXIgZmZ0bSA9IG5ldyBGRlRNKCk7XG4gICAgLy8gcmV0dXJuIGZmdG0ubXVscChzZWxmLCBudW0sIG91dCk7XG4gICAgcmV0dXJuIGJpZ011bFRvKHNlbGYsIG51bSwgb3V0KTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uIG11bFRvIChudW0sIG91dCkge1xuICAgIHZhciByZXM7XG4gICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aDtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEwICYmIG51bS5sZW5ndGggPT09IDEwKSB7XG4gICAgICByZXMgPSBjb21iMTBNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCA2Mykge1xuICAgICAgcmVzID0gc21hbGxNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCAxMDI0KSB7XG4gICAgICByZXMgPSBiaWdNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29vbGV5LVR1a2V5IGFsZ29yaXRobSBmb3IgRkZUXG4gIC8vIHNsaWdodGx5IHJldmlzaXRlZCB0byByZWx5IG9uIGxvb3BpbmcgaW5zdGVhZCBvZiByZWN1cnNpb25cblxuICBmdW5jdGlvbiBGRlRNICh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG5cbiAgRkZUTS5wcm90b3R5cGUubWFrZVJCVCA9IGZ1bmN0aW9uIG1ha2VSQlQgKE4pIHtcbiAgICB2YXIgdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbCA9IEJOLnByb3RvdHlwZS5fY291bnRCaXRzKE4pIC0gMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdFtpXSA9IHRoaXMucmV2QmluKGksIGwsIE4pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYmluYXJ5LXJldmVyc2VkIHJlcHJlc2VudGF0aW9uIG9mIGB4YFxuICBGRlRNLnByb3RvdHlwZS5yZXZCaW4gPSBmdW5jdGlvbiByZXZCaW4gKHgsIGwsIE4pIHtcbiAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSBOIC0gMSkgcmV0dXJuIHg7XG5cbiAgICB2YXIgcmIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICByYiB8PSAoeCAmIDEpIDw8IChsIC0gaSAtIDEpO1xuICAgICAgeCA+Pj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmI7XG4gIH07XG5cbiAgLy8gUGVyZm9ybXMgXCJ0d2VlZGxpbmdcIiBwaGFzZSwgdGhlcmVmb3JlICdlbXVsYXRpbmcnXG4gIC8vIGJlaGF2aW91ciBvZiB0aGUgcmVjdXJzaXZlIGFsZ29yaXRobVxuICBGRlRNLnByb3RvdHlwZS5wZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZSAocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBydHdzW2ldID0gcndzW3JidFtpXV07XG4gICAgICBpdHdzW2ldID0gaXdzW3JidFtpXV07XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybSAocndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4sIHJidCkge1xuICAgIHRoaXMucGVybXV0ZShyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKTtcblxuICAgIGZvciAodmFyIHMgPSAxOyBzIDwgTjsgcyA8PD0gMSkge1xuICAgICAgdmFyIGwgPSBzIDw8IDE7XG5cbiAgICAgIHZhciBydHdkZiA9IE1hdGguY29zKDIgKiBNYXRoLlBJIC8gbCk7XG4gICAgICB2YXIgaXR3ZGYgPSBNYXRoLnNpbigyICogTWF0aC5QSSAvIGwpO1xuXG4gICAgICBmb3IgKHZhciBwID0gMDsgcCA8IE47IHAgKz0gbCkge1xuICAgICAgICB2YXIgcnR3ZGZfID0gcnR3ZGY7XG4gICAgICAgIHZhciBpdHdkZl8gPSBpdHdkZjtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHM7IGorKykge1xuICAgICAgICAgIHZhciByZSA9IHJ0d3NbcCArIGpdO1xuICAgICAgICAgIHZhciBpZSA9IGl0d3NbcCArIGpdO1xuXG4gICAgICAgICAgdmFyIHJvID0gcnR3c1twICsgaiArIHNdO1xuICAgICAgICAgIHZhciBpbyA9IGl0d3NbcCArIGogKyBzXTtcblxuICAgICAgICAgIHZhciByeCA9IHJ0d2RmXyAqIHJvIC0gaXR3ZGZfICogaW87XG5cbiAgICAgICAgICBpbyA9IHJ0d2RmXyAqIGlvICsgaXR3ZGZfICogcm87XG4gICAgICAgICAgcm8gPSByeDtcblxuICAgICAgICAgIHJ0d3NbcCArIGpdID0gcmUgKyBybztcbiAgICAgICAgICBpdHdzW3AgKyBqXSA9IGllICsgaW87XG5cbiAgICAgICAgICBydHdzW3AgKyBqICsgc10gPSByZSAtIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGogKyBzXSA9IGllIC0gaW87XG5cbiAgICAgICAgICAvKiBqc2hpbnQgbWF4ZGVwdGggOiBmYWxzZSAqL1xuICAgICAgICAgIGlmIChqICE9PSBsKSB7XG4gICAgICAgICAgICByeCA9IHJ0d2RmICogcnR3ZGZfIC0gaXR3ZGYgKiBpdHdkZl87XG5cbiAgICAgICAgICAgIGl0d2RmXyA9IHJ0d2RmICogaXR3ZGZfICsgaXR3ZGYgKiBydHdkZl87XG4gICAgICAgICAgICBydHdkZl8gPSByeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuZ3Vlc3NMZW4xM2IgPSBmdW5jdGlvbiBndWVzc0xlbjEzYiAobiwgbSkge1xuICAgIHZhciBOID0gTWF0aC5tYXgobSwgbikgfCAxO1xuICAgIHZhciBvZGQgPSBOICYgMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yIChOID0gTiAvIDIgfCAwOyBOOyBOID0gTiA+Pj4gMSkge1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiAxIDw8IGkgKyAxICsgb2RkO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIGNvbmp1Z2F0ZSAocndzLCBpd3MsIE4pIHtcbiAgICBpZiAoTiA8PSAxKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB0ID0gcndzW2ldO1xuXG4gICAgICByd3NbaV0gPSByd3NbTiAtIGkgLSAxXTtcbiAgICAgIHJ3c1tOIC0gaSAtIDFdID0gdDtcblxuICAgICAgdCA9IGl3c1tpXTtcblxuICAgICAgaXdzW2ldID0gLWl3c1tOIC0gaSAtIDFdO1xuICAgICAgaXdzW04gLSBpIC0gMV0gPSAtdDtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubm9ybWFsaXplMTNiID0gZnVuY3Rpb24gbm9ybWFsaXplMTNiICh3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdyA9IE1hdGgucm91bmQod3NbMiAqIGkgKyAxXSAvIE4pICogMHgyMDAwICtcbiAgICAgICAgTWF0aC5yb3VuZCh3c1syICogaV0gLyBOKSArXG4gICAgICAgIGNhcnJ5O1xuXG4gICAgICB3c1tpXSA9IHcgJiAweDNmZmZmZmY7XG5cbiAgICAgIGlmICh3IDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gdyAvIDB4NDAwMDAwMCB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdzO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbnZlcnQxM2IgPSBmdW5jdGlvbiBjb252ZXJ0MTNiICh3cywgbGVuLCByd3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNhcnJ5ID0gY2FycnkgKyAod3NbaV0gfCAwKTtcblxuICAgICAgcndzWzIgKiBpXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICAgIHJ3c1syICogaSArIDFdID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgIH1cblxuICAgIC8vIFBhZCB3aXRoIHplcm9lc1xuICAgIGZvciAoaSA9IDIgKiBsZW47IGkgPCBOOyArK2kpIHtcbiAgICAgIHJ3c1tpXSA9IDA7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAwKTtcbiAgICBhc3NlcnQoKGNhcnJ5ICYgfjB4MWZmZikgPT09IDApO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnN0dWIgPSBmdW5jdGlvbiBzdHViIChOKSB7XG4gICAgdmFyIHBoID0gbmV3IEFycmF5KE4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBwaFtpXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBoO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm11bHAgPSBmdW5jdGlvbiBtdWxwICh4LCB5LCBvdXQpIHtcbiAgICB2YXIgTiA9IDIgKiB0aGlzLmd1ZXNzTGVuMTNiKHgubGVuZ3RoLCB5Lmxlbmd0aCk7XG5cbiAgICB2YXIgcmJ0ID0gdGhpcy5tYWtlUkJUKE4pO1xuXG4gICAgdmFyIF8gPSB0aGlzLnN0dWIoTik7XG5cbiAgICB2YXIgcndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciByd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBpd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIG5yd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5yd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBuaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBybXdzID0gb3V0LndvcmRzO1xuICAgIHJtd3MubGVuZ3RoID0gTjtcblxuICAgIHRoaXMuY29udmVydDEzYih4LndvcmRzLCB4Lmxlbmd0aCwgcndzLCBOKTtcbiAgICB0aGlzLmNvbnZlcnQxM2IoeS53b3JkcywgeS5sZW5ndGgsIG5yd3MsIE4pO1xuXG4gICAgdGhpcy50cmFuc2Zvcm0ocndzLCBfLCByd3N0LCBpd3N0LCBOLCByYnQpO1xuICAgIHRoaXMudHJhbnNmb3JtKG5yd3MsIF8sIG5yd3N0LCBuaXdzdCwgTiwgcmJ0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB2YXIgcnggPSByd3N0W2ldICogbnJ3c3RbaV0gLSBpd3N0W2ldICogbml3c3RbaV07XG4gICAgICBpd3N0W2ldID0gcndzdFtpXSAqIG5pd3N0W2ldICsgaXdzdFtpXSAqIG5yd3N0W2ldO1xuICAgICAgcndzdFtpXSA9IHJ4O1xuICAgIH1cblxuICAgIHRoaXMuY29uanVnYXRlKHJ3c3QsIGl3c3QsIE4pO1xuICAgIHRoaXMudHJhbnNmb3JtKHJ3c3QsIGl3c3QsIHJtd3MsIF8sIE4sIHJidCk7XG4gICAgdGhpcy5jb25qdWdhdGUocm13cywgXywgTik7XG4gICAgdGhpcy5ub3JtYWxpemUxM2Iocm13cywgTik7XG5cbiAgICBvdXQubmVnYXRpdmUgPSB4Lm5lZ2F0aXZlIF4geS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0geC5sZW5ndGggKyB5Lmxlbmd0aDtcbiAgICByZXR1cm4gb3V0Ll9zdHJpcCgpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGB0aGlzYCBieSBgbnVtYFxuICBCTi5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLm11bFRvKG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBNdWx0aXBseSBlbXBsb3lpbmcgRkZUXG4gIEJOLnByb3RvdHlwZS5tdWxmID0gZnVuY3Rpb24gbXVsZiAobnVtKSB7XG4gICAgdmFyIG91dCA9IG5ldyBCTihudWxsKTtcbiAgICBvdXQud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGggKyBudW0ubGVuZ3RoKTtcbiAgICByZXR1cm4ganVtYm9NdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgTXVsdGlwbGljYXRpb25cbiAgQk4ucHJvdG90eXBlLmltdWwgPSBmdW5jdGlvbiBpbXVsIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLm11bFRvKG51bSwgdGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmltdWxuID0gZnVuY3Rpb24gaW11bG4gKG51bSkge1xuICAgIHZhciBpc05lZ051bSA9IG51bSA8IDA7XG4gICAgaWYgKGlzTmVnTnVtKSBudW0gPSAtbnVtO1xuXG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcblxuICAgIC8vIENhcnJ5XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSAqIG51bTtcbiAgICAgIHZhciBsbyA9ICh3ICYgMHgzZmZmZmZmKSArIChjYXJyeSAmIDB4M2ZmZmZmZik7XG4gICAgICBjYXJyeSA+Pj0gMjY7XG4gICAgICBjYXJyeSArPSAodyAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgLy8gTk9URTogbG8gaXMgMjdiaXQgbWF4aW11bVxuICAgICAgY2FycnkgKz0gbG8gPj4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gaXNOZWdOdW0gPyB0aGlzLmluZWcoKSA6IHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLm11bG4gPSBmdW5jdGlvbiBtdWxuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmltdWxuKG51bSk7XG4gIH07XG5cbiAgLy8gYHRoaXNgICogYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zcXIgPSBmdW5jdGlvbiBzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLm11bCh0aGlzKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzcXIgPSBmdW5jdGlvbiBpc3FyICgpIHtcbiAgICByZXR1cm4gdGhpcy5pbXVsKHRoaXMuY2xvbmUoKSk7XG4gIH07XG5cbiAgLy8gTWF0aC5wb3coYHRoaXNgLCBgbnVtYClcbiAgQk4ucHJvdG90eXBlLnBvdyA9IGZ1bmN0aW9uIHBvdyAobnVtKSB7XG4gICAgdmFyIHcgPSB0b0JpdEFycmF5KG51bSk7XG4gICAgaWYgKHcubGVuZ3RoID09PSAwKSByZXR1cm4gbmV3IEJOKDEpO1xuXG4gICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lc1xuICAgIHZhciByZXMgPSB0aGlzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdy5sZW5ndGg7IGkrKywgcmVzID0gcmVzLnNxcigpKSB7XG4gICAgICBpZiAod1tpXSAhPT0gMCkgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKCsraSA8IHcubGVuZ3RoKSB7XG4gICAgICBmb3IgKHZhciBxID0gcmVzLnNxcigpOyBpIDwgdy5sZW5ndGg7IGkrKywgcSA9IHEuc3FyKCkpIHtcbiAgICAgICAgaWYgKHdbaV0gPT09IDApIGNvbnRpbnVlO1xuXG4gICAgICAgIHJlcyA9IHJlcy5tdWwocSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBTaGlmdC1sZWZ0IGluLXBsYWNlXG4gIEJOLnByb3RvdHlwZS5pdXNobG4gPSBmdW5jdGlvbiBpdXNobG4gKGJpdHMpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSAoYml0cyAtIHIpIC8gMjY7XG4gICAgdmFyIGNhcnJ5TWFzayA9ICgweDNmZmZmZmYgPj4+ICgyNiAtIHIpKSA8PCAoMjYgLSByKTtcbiAgICB2YXIgaTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgY2FycnkgPSAwO1xuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbmV3Q2FycnkgPSB0aGlzLndvcmRzW2ldICYgY2FycnlNYXNrO1xuICAgICAgICB2YXIgYyA9ICgodGhpcy53b3Jkc1tpXSB8IDApIC0gbmV3Q2FycnkpIDw8IHI7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSBjIHwgY2Fycnk7XG4gICAgICAgIGNhcnJ5ID0gbmV3Q2FycnkgPj4+ICgyNiAtIHIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FycnkpIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgICB0aGlzLmxlbmd0aCsrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzICE9PSAwKSB7XG4gICAgICBmb3IgKGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIHNdID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cblxuICAgICAgZm9yIChpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gMDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggKz0gcztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaXNobG4gPSBmdW5jdGlvbiBpc2hsbiAoYml0cykge1xuICAgIC8vIFRPRE8oaW5kdXRueSk6IGltcGxlbWVudCBtZVxuICAgIGFzc2VydCh0aGlzLm5lZ2F0aXZlID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHQgaW4tcGxhY2VcbiAgLy8gTk9URTogYGhpbnRgIGlzIGEgbG93ZXN0IGJpdCBiZWZvcmUgdHJhaWxpbmcgemVyb2VzXG4gIC8vIE5PVEU6IGlmIGBleHRlbmRlZGAgaXMgcHJlc2VudCAtIGl0IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVzdHJveWVkIGJpdHNcbiAgQk4ucHJvdG90eXBlLml1c2hybiA9IGZ1bmN0aW9uIGl1c2hybiAoYml0cywgaGludCwgZXh0ZW5kZWQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdHMgPT09ICdudW1iZXInICYmIGJpdHMgPj0gMCk7XG4gICAgdmFyIGg7XG4gICAgaWYgKGhpbnQpIHtcbiAgICAgIGggPSAoaGludCAtIChoaW50ICUgMjYpKSAvIDI2O1xuICAgIH0gZWxzZSB7XG4gICAgICBoID0gMDtcbiAgICB9XG5cbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IE1hdGgubWluKChiaXRzIC0gcikgLyAyNiwgdGhpcy5sZW5ndGgpO1xuICAgIHZhciBtYXNrID0gMHgzZmZmZmZmIF4gKCgweDNmZmZmZmYgPj4+IHIpIDw8IHIpO1xuICAgIHZhciBtYXNrZWRXb3JkcyA9IGV4dGVuZGVkO1xuXG4gICAgaCAtPSBzO1xuICAgIGggPSBNYXRoLm1heCgwLCBoKTtcblxuICAgIC8vIEV4dGVuZGVkIG1vZGUsIGNvcHkgbWFza2VkIHBhcnRcbiAgICBpZiAobWFza2VkV29yZHMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIG1hc2tlZFdvcmRzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICAgIG1hc2tlZFdvcmRzLmxlbmd0aCA9IHM7XG4gICAgfVxuXG4gICAgaWYgKHMgPT09IDApIHtcbiAgICAgIC8vIE5vLW9wLCB3ZSBzaG91bGQgbm90IG1vdmUgYW55dGhpbmcgYXQgYWxsXG4gICAgfSBlbHNlIGlmICh0aGlzLmxlbmd0aCA+IHMpIHtcbiAgICAgIHRoaXMubGVuZ3RoIC09IHM7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gdGhpcy53b3Jkc1tpICsgc107XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDAgJiYgKGNhcnJ5ICE9PSAwIHx8IGkgPj0gaCk7IGktLSkge1xuICAgICAgdmFyIHdvcmQgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAoY2FycnkgPDwgKDI2IC0gcikpIHwgKHdvcmQgPj4+IHIpO1xuICAgICAgY2FycnkgPSB3b3JkICYgbWFzaztcbiAgICB9XG5cbiAgICAvLyBQdXNoIGNhcnJpZWQgYml0cyBhcyBhIG1hc2tcbiAgICBpZiAobWFza2VkV29yZHMgJiYgY2FycnkgIT09IDApIHtcbiAgICAgIG1hc2tlZFdvcmRzLndvcmRzW21hc2tlZFdvcmRzLmxlbmd0aCsrXSA9IGNhcnJ5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IDA7XG4gICAgICB0aGlzLmxlbmd0aCA9IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3N0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaHJuID0gZnVuY3Rpb24gaXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hybihiaXRzLCBoaW50LCBleHRlbmRlZCk7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdFxuICBCTi5wcm90b3R5cGUuc2hsbiA9IGZ1bmN0aW9uIHNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaGxuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hsbiA9IGZ1bmN0aW9uIHVzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHRcbiAgQk4ucHJvdG90eXBlLnNocm4gPSBmdW5jdGlvbiBzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hybihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNocm4gPSBmdW5jdGlvbiB1c2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaHJuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFRlc3QgaWYgbiBiaXQgaXMgc2V0XG4gIEJOLnByb3RvdHlwZS50ZXN0biA9IGZ1bmN0aW9uIHRlc3RuIChiaXQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgICB2YXIgcSA9IDEgPDwgcjtcblxuICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIENoZWNrIGJpdCBhbmQgcmV0dXJuXG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3NdO1xuXG4gICAgcmV0dXJuICEhKHcgJiBxKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXIgKGluLXBsYWNlKVxuICBCTi5wcm90b3R5cGUuaW1hc2tuID0gZnVuY3Rpb24gaW1hc2tuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnMnKTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgcysrO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWluKHMsIHRoaXMubGVuZ3RoKTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSAmPSBtYXNrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIC8vIFJldHVybiBvbmx5IGxvd2VycyBiaXRzIG9mIG51bWJlclxuICBCTi5wcm90b3R5cGUubWFza24gPSBmdW5jdGlvbiBtYXNrbiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW1hc2tuKGJpdHMpO1xuICB9O1xuXG4gIC8vIEFkZCBwbGFpbiBudW1iZXIgYG51bWAgdG8gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5pYWRkbiA9IGZ1bmN0aW9uIGlhZGRuIChudW0pIHtcbiAgICBhc3NlcnQodHlwZW9mIG51bSA9PT0gJ251bWJlcicpO1xuICAgIGFzc2VydChudW0gPCAweDQwMDAwMDApO1xuICAgIGlmIChudW0gPCAwKSByZXR1cm4gdGhpcy5pc3VibigtbnVtKTtcblxuICAgIC8vIFBvc3NpYmxlIHNpZ24gY2hhbmdlXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiAodGhpcy53b3Jkc1swXSB8IDApIDw9IG51bSkge1xuICAgICAgICB0aGlzLndvcmRzWzBdID0gbnVtIC0gKHRoaXMud29yZHNbMF0gfCAwKTtcbiAgICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaXN1Ym4obnVtKTtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhvdXQgY2hlY2tzXG4gICAgcmV0dXJuIHRoaXMuX2lhZGRuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pYWRkbiA9IGZ1bmN0aW9uIF9pYWRkbiAobnVtKSB7XG4gICAgdGhpcy53b3Jkc1swXSArPSBudW07XG5cbiAgICAvLyBDYXJyeVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA+PSAweDQwMDAwMDA7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSAtPSAweDQwMDAwMDA7XG4gICAgICBpZiAoaSA9PT0gdGhpcy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdKys7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGVuZ3RoID0gTWF0aC5tYXgodGhpcy5sZW5ndGgsIGkgKyAxKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IHBsYWluIG51bWJlciBgbnVtYCBmcm9tIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuaXN1Ym4gPSBmdW5jdGlvbiBpc3VibiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcbiAgICBpZiAobnVtIDwgMCkgcmV0dXJuIHRoaXMuaWFkZG4oLW51bSk7XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlhZGRuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIHRoaXMud29yZHNbMF0gLT0gbnVtO1xuXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPCAwKSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gLXRoaXMud29yZHNbMF07XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FycnlcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGggJiYgdGhpcy53b3Jkc1tpXSA8IDA7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldICs9IDB4NDAwMDAwMDtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgMV0gLT0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWRkbiA9IGZ1bmN0aW9uIGFkZG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuc3VibiA9IGZ1bmN0aW9uIHN1Ym4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFicyA9IGZ1bmN0aW9uIGlhYnMgKCkge1xuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uIGFicyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pc2hsbnN1Ym11bCA9IGZ1bmN0aW9uIF9pc2hsbnN1Ym11bCAobnVtLCBtdWwsIHNoaWZ0KSB7XG4gICAgdmFyIGxlbiA9IG51bS5sZW5ndGggKyBzaGlmdDtcbiAgICB2YXIgaTtcblxuICAgIHRoaXMuX2V4cGFuZChsZW4pO1xuXG4gICAgdmFyIHc7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICB2YXIgcmlnaHQgPSAobnVtLndvcmRzW2ldIHwgMCkgKiBtdWw7XG4gICAgICB3IC09IHJpZ2h0ICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSAodyA+PiAyNikgLSAoKHJpZ2h0IC8gMHg0MDAwMDAwKSB8IDApO1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aCAtIHNoaWZ0OyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ID09PSAwKSByZXR1cm4gdGhpcy5fc3RyaXAoKTtcblxuICAgIC8vIFN1YnRyYWN0aW9uIG92ZXJmbG93XG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAtMSk7XG4gICAgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gLSh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB3ICYgMHgzZmZmZmZmO1xuICAgIH1cbiAgICB0aGlzLm5lZ2F0aXZlID0gMTtcblxuICAgIHJldHVybiB0aGlzLl9zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fd29yZERpdiA9IGZ1bmN0aW9uIF93b3JkRGl2IChudW0sIG1vZGUpIHtcbiAgICB2YXIgc2hpZnQgPSB0aGlzLmxlbmd0aCAtIG51bS5sZW5ndGg7XG5cbiAgICB2YXIgYSA9IHRoaXMuY2xvbmUoKTtcbiAgICB2YXIgYiA9IG51bTtcblxuICAgIC8vIE5vcm1hbGl6ZVxuICAgIHZhciBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIHZhciBiaGlCaXRzID0gdGhpcy5fY291bnRCaXRzKGJoaSk7XG4gICAgc2hpZnQgPSAyNiAtIGJoaUJpdHM7XG4gICAgaWYgKHNoaWZ0ICE9PSAwKSB7XG4gICAgICBiID0gYi51c2hsbihzaGlmdCk7XG4gICAgICBhLml1c2hsbihzaGlmdCk7XG4gICAgICBiaGkgPSBiLndvcmRzW2IubGVuZ3RoIC0gMV0gfCAwO1xuICAgIH1cblxuICAgIC8vIEluaXRpYWxpemUgcXVvdGllbnRcbiAgICB2YXIgbSA9IGEubGVuZ3RoIC0gYi5sZW5ndGg7XG4gICAgdmFyIHE7XG5cbiAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgIHEgPSBuZXcgQk4obnVsbCk7XG4gICAgICBxLmxlbmd0aCA9IG0gKyAxO1xuICAgICAgcS53b3JkcyA9IG5ldyBBcnJheShxLmxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcS53b3Jkc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRpZmYgPSBhLmNsb25lKCkuX2lzaGxuc3VibXVsKGIsIDEsIG0pO1xuICAgIGlmIChkaWZmLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICBhID0gZGlmZjtcbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbbV0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGogPSBtIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIHZhciBxaiA9IChhLndvcmRzW2IubGVuZ3RoICsgal0gfCAwKSAqIDB4NDAwMDAwMCArXG4gICAgICAgIChhLndvcmRzW2IubGVuZ3RoICsgaiAtIDFdIHwgMCk7XG5cbiAgICAgIC8vIE5PVEU6IChxaiAvIGJoaSkgaXMgKDB4M2ZmZmZmZiAqIDB4NDAwMDAwMCArIDB4M2ZmZmZmZikgLyAweDIwMDAwMDAgbWF4XG4gICAgICAvLyAoMHg3ZmZmZmZmKVxuICAgICAgcWogPSBNYXRoLm1pbigocWogLyBiaGkpIHwgMCwgMHgzZmZmZmZmKTtcblxuICAgICAgYS5faXNobG5zdWJtdWwoYiwgcWosIGopO1xuICAgICAgd2hpbGUgKGEubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgcWotLTtcbiAgICAgICAgYS5uZWdhdGl2ZSA9IDA7XG4gICAgICAgIGEuX2lzaGxuc3VibXVsKGIsIDEsIGopO1xuICAgICAgICBpZiAoIWEuaXNaZXJvKCkpIHtcbiAgICAgICAgICBhLm5lZ2F0aXZlIF49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChxKSB7XG4gICAgICAgIHEud29yZHNbal0gPSBxajtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHEpIHtcbiAgICAgIHEuX3N0cmlwKCk7XG4gICAgfVxuICAgIGEuX3N0cmlwKCk7XG5cbiAgICAvLyBEZW5vcm1hbGl6ZVxuICAgIGlmIChtb2RlICE9PSAnZGl2JyAmJiBzaGlmdCAhPT0gMCkge1xuICAgICAgYS5pdXNocm4oc2hpZnQpO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBkaXY6IHEgfHwgbnVsbCxcbiAgICAgIG1vZDogYVxuICAgIH07XG4gIH07XG5cbiAgLy8gTk9URTogMSkgYG1vZGVgIGNhbiBiZSBzZXQgdG8gYG1vZGAgdG8gcmVxdWVzdCBtb2Qgb25seSxcbiAgLy8gICAgICAgdG8gYGRpdmAgdG8gcmVxdWVzdCBkaXYgb25seSwgb3IgYmUgYWJzZW50IHRvXG4gIC8vICAgICAgIHJlcXVlc3QgYm90aCBkaXYgJiBtb2RcbiAgLy8gICAgICAgMikgYHBvc2l0aXZlYCBpcyB0cnVlIGlmIHVuc2lnbmVkIG1vZCBpcyByZXF1ZXN0ZWRcbiAgQk4ucHJvdG90eXBlLmRpdm1vZCA9IGZ1bmN0aW9uIGRpdm1vZCAobnVtLCBtb2RlLCBwb3NpdGl2ZSkge1xuICAgIGFzc2VydCghbnVtLmlzWmVybygpKTtcblxuICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiBuZXcgQk4oMClcbiAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIGRpdiwgbW9kLCByZXM7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSB7XG4gICAgICByZXMgPSB0aGlzLm5lZygpLmRpdm1vZChudW0sIG1vZGUpO1xuXG4gICAgICBpZiAobW9kZSAhPT0gJ21vZCcpIHtcbiAgICAgICAgZGl2ID0gcmVzLmRpdi5uZWcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaWFkZChudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IG1vZFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSA9PT0gMCAmJiBudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IGRpdixcbiAgICAgICAgbW9kOiByZXMubW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICgodGhpcy5uZWdhdGl2ZSAmIG51bS5uZWdhdGl2ZSkgIT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bS5uZWcoKSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnZGl2Jykge1xuICAgICAgICBtb2QgPSByZXMubW9kLm5lZygpO1xuICAgICAgICBpZiAocG9zaXRpdmUgJiYgbW9kLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgICAgbW9kLmlzdWIobnVtKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHJlcy5kaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmUgYXQgdGhpcyBwb2ludFxuXG4gICAgLy8gU3RyaXAgYm90aCBudW1iZXJzIHRvIGFwcHJveGltYXRlIHNoaWZ0IHZhbHVlXG4gICAgaWYgKG51bS5sZW5ndGggPiB0aGlzLmxlbmd0aCB8fCB0aGlzLmNtcChudW0pIDwgMCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBuZXcgQk4oMCksXG4gICAgICAgIG1vZDogdGhpc1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBWZXJ5IHNob3J0IHJlZHVjdGlvblxuICAgIGlmIChudW0ubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAobW9kZSA9PT0gJ2RpdicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICAgIG1vZDogbnVsbFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSA9PT0gJ21vZCcpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXY6IG51bGwsXG4gICAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RybihudW0ud29yZHNbMF0pKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IHRoaXMuZGl2bihudW0ud29yZHNbMF0pLFxuICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZHJuKG51bS53b3Jkc1swXSkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93b3JkRGl2KG51bSwgbW9kZSk7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgLyBgbnVtYFxuICBCTi5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gZGl2IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnZGl2JywgZmFsc2UpLmRpdjtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAlIGBudW1gXG4gIEJOLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiBtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCBmYWxzZSkubW9kO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51bW9kID0gZnVuY3Rpb24gdW1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIHRydWUpLm1vZDtcbiAgfTtcblxuICAvLyBGaW5kIFJvdW5kKGB0aGlzYCAvIGBudW1gKVxuICBCTi5wcm90b3R5cGUuZGl2Um91bmQgPSBmdW5jdGlvbiBkaXZSb3VuZCAobnVtKSB7XG4gICAgdmFyIGRtID0gdGhpcy5kaXZtb2QobnVtKTtcblxuICAgIC8vIEZhc3QgY2FzZSAtIGV4YWN0IGRpdmlzaW9uXG4gICAgaWYgKGRtLm1vZC5pc1plcm8oKSkgcmV0dXJuIGRtLmRpdjtcblxuICAgIHZhciBtb2QgPSBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5tb2QuaXN1YihudW0pIDogZG0ubW9kO1xuXG4gICAgdmFyIGhhbGYgPSBudW0udXNocm4oMSk7XG4gICAgdmFyIHIyID0gbnVtLmFuZGxuKDEpO1xuICAgIHZhciBjbXAgPSBtb2QuY21wKGhhbGYpO1xuXG4gICAgLy8gUm91bmQgZG93blxuICAgIGlmIChjbXAgPCAwIHx8IChyMiA9PT0gMSAmJiBjbXAgPT09IDApKSByZXR1cm4gZG0uZGl2O1xuXG4gICAgLy8gUm91bmQgdXBcbiAgICByZXR1cm4gZG0uZGl2Lm5lZ2F0aXZlICE9PSAwID8gZG0uZGl2LmlzdWJuKDEpIDogZG0uZGl2LmlhZGRuKDEpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5tb2RybiA9IGZ1bmN0aW9uIG1vZHJuIChudW0pIHtcbiAgICB2YXIgaXNOZWdOdW0gPSBudW0gPCAwO1xuICAgIGlmIChpc05lZ051bSkgbnVtID0gLW51bTtcblxuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcbiAgICB2YXIgcCA9ICgxIDw8IDI2KSAlIG51bTtcblxuICAgIHZhciBhY2MgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBhY2MgPSAocCAqIGFjYyArICh0aGlzLndvcmRzW2ldIHwgMCkpICUgbnVtO1xuICAgIH1cblxuICAgIHJldHVybiBpc05lZ051bSA/IC1hY2MgOiBhY2M7XG4gIH07XG5cbiAgLy8gV0FSTklORzogREVQUkVDQVRFRFxuICBCTi5wcm90b3R5cGUubW9kbiA9IGZ1bmN0aW9uIG1vZG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLm1vZHJuKG51bSk7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgZGl2aXNpb24gYnkgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5pZGl2biA9IGZ1bmN0aW9uIGlkaXZuIChudW0pIHtcbiAgICB2YXIgaXNOZWdOdW0gPSBudW0gPCAwO1xuICAgIGlmIChpc05lZ051bSkgbnVtID0gLW51bTtcblxuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcblxuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5ICogMHg0MDAwMDAwO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9ICh3IC8gbnVtKSB8IDA7XG4gICAgICBjYXJyeSA9IHcgJSBudW07XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyaXAoKTtcbiAgICByZXR1cm4gaXNOZWdOdW0gPyB0aGlzLmluZWcoKSA6IHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmRpdm4gPSBmdW5jdGlvbiBkaXZuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVnY2QgPSBmdW5jdGlvbiBlZ2NkIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgeCA9IHRoaXM7XG4gICAgdmFyIHkgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoeC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgeCA9IHgudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHguY2xvbmUoKTtcbiAgICB9XG5cbiAgICAvLyBBICogeCArIEIgKiB5ID0geFxuICAgIHZhciBBID0gbmV3IEJOKDEpO1xuICAgIHZhciBCID0gbmV3IEJOKDApO1xuXG4gICAgLy8gQyAqIHggKyBEICogeSA9IHlcbiAgICB2YXIgQyA9IG5ldyBCTigwKTtcbiAgICB2YXIgRCA9IG5ldyBCTigxKTtcblxuICAgIHZhciBnID0gMDtcblxuICAgIHdoaWxlICh4LmlzRXZlbigpICYmIHkuaXNFdmVuKCkpIHtcbiAgICAgIHguaXVzaHJuKDEpO1xuICAgICAgeS5pdXNocm4oMSk7XG4gICAgICArK2c7XG4gICAgfVxuXG4gICAgdmFyIHlwID0geS5jbG9uZSgpO1xuICAgIHZhciB4cCA9IHguY2xvbmUoKTtcblxuICAgIHdoaWxlICgheC5pc1plcm8oKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKHgud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB4Lml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoQS5pc09kZCgpIHx8IEIuaXNPZGQoKSkge1xuICAgICAgICAgICAgQS5pYWRkKHlwKTtcbiAgICAgICAgICAgIEIuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQS5pdXNocm4oMSk7XG4gICAgICAgICAgQi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKHkud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICB5Lml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoQy5pc09kZCgpIHx8IEQuaXNPZGQoKSkge1xuICAgICAgICAgICAgQy5pYWRkKHlwKTtcbiAgICAgICAgICAgIEQuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQy5pdXNocm4oMSk7XG4gICAgICAgICAgRC5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHguY21wKHkpID49IDApIHtcbiAgICAgICAgeC5pc3ViKHkpO1xuICAgICAgICBBLmlzdWIoQyk7XG4gICAgICAgIEIuaXN1YihEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkuaXN1Yih4KTtcbiAgICAgICAgQy5pc3ViKEEpO1xuICAgICAgICBELmlzdWIoQik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IEMsXG4gICAgICBiOiBELFxuICAgICAgZ2NkOiB5Lml1c2hsbihnKVxuICAgIH07XG4gIH07XG5cbiAgLy8gVGhpcyBpcyByZWR1Y2VkIGluY2FybmF0aW9uIG9mIHRoZSBiaW5hcnkgRUVBXG4gIC8vIGFib3ZlLCBkZXNpZ25hdGVkIHRvIGludmVydCBtZW1iZXJzIG9mIHRoZVxuICAvLyBfcHJpbWVfIGZpZWxkcyBGKHApIGF0IGEgbWF4aW1hbCBzcGVlZFxuICBCTi5wcm90b3R5cGUuX2ludm1wID0gZnVuY3Rpb24gX2ludm1wIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIGIgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgYSA9IGEudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICB2YXIgeDEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIHgyID0gbmV3IEJOKDApO1xuXG4gICAgdmFyIGRlbHRhID0gYi5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKGEuY21wbigxKSA+IDAgJiYgYi5jbXBuKDEpID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKGEud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBhLml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDEuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDEuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDEuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7IChiLndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgYi5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgyLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgyLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgyLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYS5jbXAoYikgPj0gMCkge1xuICAgICAgICBhLmlzdWIoYik7XG4gICAgICAgIHgxLmlzdWIoeDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYi5pc3ViKGEpO1xuICAgICAgICB4Mi5pc3ViKHgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmIChhLmNtcG4oMSkgPT09IDApIHtcbiAgICAgIHJlcyA9IHgxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB4MjtcbiAgICB9XG5cbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZChwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbiBnY2QgKG51bSkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gbnVtLmFicygpO1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiB0aGlzLmFicygpO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW0uY2xvbmUoKTtcbiAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICBiLm5lZ2F0aXZlID0gMDtcblxuICAgIC8vIFJlbW92ZSBjb21tb24gZmFjdG9yIG9mIHR3b1xuICAgIGZvciAodmFyIHNoaWZ0ID0gMDsgYS5pc0V2ZW4oKSAmJiBiLmlzRXZlbigpOyBzaGlmdCsrKSB7XG4gICAgICBhLml1c2hybigxKTtcbiAgICAgIGIuaXVzaHJuKDEpO1xuICAgIH1cblxuICAgIGRvIHtcbiAgICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XG4gICAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIHtcbiAgICAgICAgYi5pdXNocm4oMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByID0gYS5jbXAoYik7XG4gICAgICBpZiAociA8IDApIHtcbiAgICAgICAgLy8gU3dhcCBgYWAgYW5kIGBiYCB0byBtYWtlIGBhYCBhbHdheXMgYmlnZ2VyIHRoYW4gYGJgXG4gICAgICAgIHZhciB0ID0gYTtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGIgPSB0O1xuICAgICAgfSBlbHNlIGlmIChyID09PSAwIHx8IGIuY21wbigxKSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYS5pc3ViKGIpO1xuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgcmV0dXJuIGIuaXVzaGxuKHNoaWZ0KTtcbiAgfTtcblxuICAvLyBJbnZlcnQgbnVtYmVyIGluIHRoZSBmaWVsZCBGKG51bSlcbiAgQk4ucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5lZ2NkKG51bSkuYS51bW9kKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQgKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAxO1xuICB9O1xuXG4gIC8vIEFuZCBmaXJzdCB3b3JkIGFuZCBudW1cbiAgQk4ucHJvdG90eXBlLmFuZGxuID0gZnVuY3Rpb24gYW5kbG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLndvcmRzWzBdICYgbnVtO1xuICB9O1xuXG4gIC8vIEluY3JlbWVudCBhdCB0aGUgYml0IHBvc2l0aW9uIGluLWxpbmVcbiAgQk4ucHJvdG90eXBlLmJpbmNuID0gZnVuY3Rpb24gYmluY24gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgdGhpcy5fZXhwYW5kKHMgKyAxKTtcbiAgICAgIHRoaXMud29yZHNbc10gfD0gcTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBiaXQgYW5kIHByb3BhZ2F0ZSwgaWYgbmVlZGVkXG4gICAgdmFyIGNhcnJ5ID0gcTtcbiAgICBmb3IgKHZhciBpID0gczsgY2FycnkgIT09IDAgJiYgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB3ICs9IGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+PiAyNjtcbiAgICAgIHcgJj0gMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHc7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbiBjbXBuIChudW0pIHtcbiAgICB2YXIgbmVnYXRpdmUgPSBudW0gPCAwO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgIW5lZ2F0aXZlKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbmVnYXRpdmUpIHJldHVybiAxO1xuXG4gICAgdGhpcy5fc3RyaXAoKTtcblxuICAgIHZhciByZXM7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gMSkge1xuICAgICAgcmVzID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIG51bSA9IC1udW07XG4gICAgICB9XG5cbiAgICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmLCAnTnVtYmVyIGlzIHRvbyBiaWcnKTtcblxuICAgICAgdmFyIHcgPSB0aGlzLndvcmRzWzBdIHwgMDtcbiAgICAgIHJlcyA9IHcgPT09IG51bSA/IDAgOiB3IDwgbnVtID8gLTEgOiAxO1xuICAgIH1cbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29tcGFyZSB0d28gbnVtYmVycyBhbmQgcmV0dXJuOlxuICAvLyAxIC0gaWYgYHRoaXNgID4gYG51bWBcbiAgLy8gMCAtIGlmIGB0aGlzYCA9PSBgbnVtYFxuICAvLyAtMSAtIGlmIGB0aGlzYCA8IGBudW1gXG4gIEJOLnByb3RvdHlwZS5jbXAgPSBmdW5jdGlvbiBjbXAgKG51bSkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwICYmIG51bS5uZWdhdGl2ZSA9PT0gMCkgcmV0dXJuIC0xO1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIDE7XG5cbiAgICB2YXIgcmVzID0gdGhpcy51Y21wKG51bSk7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHJldHVybiAtcmVzIHwgMDtcbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFVuc2lnbmVkIGNvbXBhcmlzb25cbiAgQk4ucHJvdG90eXBlLnVjbXAgPSBmdW5jdGlvbiB1Y21wIChudW0pIHtcbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBoYXZlIHRoZSBzYW1lIHNpZ25cbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gMTtcbiAgICBpZiAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSByZXR1cm4gLTE7XG5cbiAgICB2YXIgcmVzID0gMDtcbiAgICBmb3IgKHZhciBpID0gdGhpcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGEgPSB0aGlzLndvcmRzW2ldIHwgMDtcbiAgICAgIHZhciBiID0gbnVtLndvcmRzW2ldIHwgMDtcblxuICAgICAgaWYgKGEgPT09IGIpIGNvbnRpbnVlO1xuICAgICAgaWYgKGEgPCBiKSB7XG4gICAgICAgIHJlcyA9IC0xO1xuICAgICAgfSBlbHNlIGlmIChhID4gYikge1xuICAgICAgICByZXMgPSAxO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0biA9IGZ1bmN0aW9uIGd0biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndCA9IGZ1bmN0aW9uIGd0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RlbiA9IGZ1bmN0aW9uIGd0ZW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA+PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGUgPSBmdW5jdGlvbiBndGUgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0biA9IGZ1bmN0aW9uIGx0biAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID09PSAtMTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHQgPSBmdW5jdGlvbiBsdCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdGVuID0gZnVuY3Rpb24gbHRlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pIDw9IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZSA9IGZ1bmN0aW9uIGx0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXFuID0gZnVuY3Rpb24gZXFuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAwO1xuICB9O1xuXG4gIC8vXG4gIC8vIEEgcmVkdWNlIGNvbnRleHQsIGNvdWxkIGJlIHVzaW5nIG1vbnRnb21lcnkgb3Igc29tZXRoaW5nIGJldHRlciwgZGVwZW5kaW5nXG4gIC8vIG9uIHRoZSBgbWAgaXRzZWxmLlxuICAvL1xuICBCTi5yZWQgPSBmdW5jdGlvbiByZWQgKG51bSkge1xuICAgIHJldHVybiBuZXcgUmVkKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvUmVkID0gZnVuY3Rpb24gdG9SZWQgKGN0eCkge1xuICAgIGFzc2VydCghdGhpcy5yZWQsICdBbHJlYWR5IGEgbnVtYmVyIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIHJldHVybiBjdHguY29udmVydFRvKHRoaXMpLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mcm9tUmVkID0gZnVuY3Rpb24gZnJvbVJlZCAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAnZnJvbVJlZCB3b3JrcyBvbmx5IHdpdGggbnVtYmVycyBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLnJlZC5jb252ZXJ0RnJvbSh0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2ZvcmNlUmVkID0gZnVuY3Rpb24gX2ZvcmNlUmVkIChjdHgpIHtcbiAgICB0aGlzLnJlZCA9IGN0eDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZm9yY2VSZWQgPSBmdW5jdGlvbiBmb3JjZVJlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICByZXR1cm4gdGhpcy5fZm9yY2VSZWQoY3R4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkQWRkID0gZnVuY3Rpb24gcmVkQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRBZGQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmFkZCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJQWRkID0gZnVuY3Rpb24gcmVkSUFkZCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSUFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaWFkZCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTdWIgPSBmdW5jdGlvbiByZWRTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFN1YiB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3ViKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTdWIgPSBmdW5jdGlvbiByZWRJU3ViIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3ViKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNobCA9IGZ1bmN0aW9uIHJlZFNobCAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU2hsIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zaGwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkTXVsID0gZnVuY3Rpb24gcmVkTXVsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgICByZXR1cm4gdGhpcy5yZWQubXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElNdWwgPSBmdW5jdGlvbiByZWRJTXVsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRNdWwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTIodGhpcywgbnVtKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaW11bCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRTcXIgPSBmdW5jdGlvbiByZWRTcXIgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuc3FyKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJU3FyID0gZnVuY3Rpb24gcmVkSVNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSVNxciB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaXNxcih0aGlzKTtcbiAgfTtcblxuICAvLyBTcXVhcmUgcm9vdCBvdmVyIHBcbiAgQk4ucHJvdG90eXBlLnJlZFNxcnQgPSBmdW5jdGlvbiByZWRTcXJ0ICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTcXJ0IHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXJ0KHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRJbnZtID0gZnVuY3Rpb24gcmVkSW52bSAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkSW52bSB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuaW52bSh0aGlzKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgICUgYHJlZCBtb2R1bG9gXG4gIEJOLnByb3RvdHlwZS5yZWROZWcgPSBmdW5jdGlvbiByZWROZWcgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE5lZyB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQubmVnKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRQb3cgPSBmdW5jdGlvbiByZWRQb3cgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCAmJiAhbnVtLnJlZCwgJ3JlZFBvdyhub3JtYWxOdW0pJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnBvdyh0aGlzLCBudW0pO1xuICB9O1xuXG4gIC8vIFByaW1lIG51bWJlcnMgd2l0aCBlZmZpY2llbnQgcmVkdWN0aW9uXG4gIHZhciBwcmltZXMgPSB7XG4gICAgazI1NjogbnVsbCxcbiAgICBwMjI0OiBudWxsLFxuICAgIHAxOTI6IG51bGwsXG4gICAgcDI1NTE5OiBudWxsXG4gIH07XG5cbiAgLy8gUHNldWRvLU1lcnNlbm5lIHByaW1lXG4gIGZ1bmN0aW9uIE1QcmltZSAobmFtZSwgcCkge1xuICAgIC8vIFAgPSAyIF4gTiAtIEtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMucCA9IG5ldyBCTihwLCAxNik7XG4gICAgdGhpcy5uID0gdGhpcy5wLmJpdExlbmd0aCgpO1xuICAgIHRoaXMuayA9IG5ldyBCTigxKS5pdXNobG4odGhpcy5uKS5pc3ViKHRoaXMucCk7XG5cbiAgICB0aGlzLnRtcCA9IHRoaXMuX3RtcCgpO1xuICB9XG5cbiAgTVByaW1lLnByb3RvdHlwZS5fdG1wID0gZnVuY3Rpb24gX3RtcCAoKSB7XG4gICAgdmFyIHRtcCA9IG5ldyBCTihudWxsKTtcbiAgICB0bXAud29yZHMgPSBuZXcgQXJyYXkoTWF0aC5jZWlsKHRoaXMubiAvIDEzKSk7XG4gICAgcmV0dXJuIHRtcDtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmlyZWR1Y2UgPSBmdW5jdGlvbiBpcmVkdWNlIChudW0pIHtcbiAgICAvLyBBc3N1bWVzIHRoYXQgYG51bWAgaXMgbGVzcyB0aGFuIGBQXjJgXG4gICAgLy8gbnVtID0gSEkgKiAoMiBeIE4gLSBLKSArIEhJICogSyArIExPID0gSEkgKiBLICsgTE8gKG1vZCBQKVxuICAgIHZhciByID0gbnVtO1xuICAgIHZhciBybGVuO1xuXG4gICAgZG8ge1xuICAgICAgdGhpcy5zcGxpdChyLCB0aGlzLnRtcCk7XG4gICAgICByID0gdGhpcy5pbXVsSyhyKTtcbiAgICAgIHIgPSByLmlhZGQodGhpcy50bXApO1xuICAgICAgcmxlbiA9IHIuYml0TGVuZ3RoKCk7XG4gICAgfSB3aGlsZSAocmxlbiA+IHRoaXMubik7XG5cbiAgICB2YXIgY21wID0gcmxlbiA8IHRoaXMubiA/IC0xIDogci51Y21wKHRoaXMucCk7XG4gICAgaWYgKGNtcCA9PT0gMCkge1xuICAgICAgci53b3Jkc1swXSA9IDA7XG4gICAgICByLmxlbmd0aCA9IDE7XG4gICAgfSBlbHNlIGlmIChjbXAgPiAwKSB7XG4gICAgICByLmlzdWIodGhpcy5wKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHIuc3RyaXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyByIGlzIGEgQk4gdjQgaW5zdGFuY2VcbiAgICAgICAgci5zdHJpcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gciBpcyBhIEJOIHY1IGluc3RhbmNlXG4gICAgICAgIHIuX3N0cmlwKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uIHNwbGl0IChpbnB1dCwgb3V0KSB7XG4gICAgaW5wdXQuaXVzaHJuKHRoaXMubiwgMCwgb3V0KTtcbiAgfTtcblxuICBNUHJpbWUucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIHJldHVybiBudW0uaW11bCh0aGlzLmspO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEsyNTYgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdrMjU2JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmMyZicpO1xuICB9XG4gIGluaGVyaXRzKEsyNTYsIE1QcmltZSk7XG5cbiAgSzI1Ni5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dHB1dCkge1xuICAgIC8vIDI1NiA9IDkgKiAyNiArIDIyXG4gICAgdmFyIG1hc2sgPSAweDNmZmZmZjtcblxuICAgIHZhciBvdXRMZW4gPSBNYXRoLm1pbihpbnB1dC5sZW5ndGgsIDkpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspIHtcbiAgICAgIG91dHB1dC53b3Jkc1tpXSA9IGlucHV0LndvcmRzW2ldO1xuICAgIH1cbiAgICBvdXRwdXQubGVuZ3RoID0gb3V0TGVuO1xuXG4gICAgaWYgKGlucHV0Lmxlbmd0aCA8PSA5KSB7XG4gICAgICBpbnB1dC53b3Jkc1swXSA9IDA7XG4gICAgICBpbnB1dC5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIFNoaWZ0IGJ5IDkgbGltYnNcbiAgICB2YXIgcHJldiA9IGlucHV0LndvcmRzWzldO1xuICAgIG91dHB1dC53b3Jkc1tvdXRwdXQubGVuZ3RoKytdID0gcHJldiAmIG1hc2s7XG5cbiAgICBmb3IgKGkgPSAxMDsgaSA8IGlucHV0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbmV4dCA9IGlucHV0LndvcmRzW2ldIHwgMDtcbiAgICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSAoKG5leHQgJiBtYXNrKSA8PCA0KSB8IChwcmV2ID4+PiAyMik7XG4gICAgICBwcmV2ID0gbmV4dDtcbiAgICB9XG4gICAgcHJldiA+Pj49IDIyO1xuICAgIGlucHV0LndvcmRzW2kgLSAxMF0gPSBwcmV2O1xuICAgIGlmIChwcmV2ID09PSAwICYmIGlucHV0Lmxlbmd0aCA+IDEwKSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gMTA7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlucHV0Lmxlbmd0aCAtPSA5O1xuICAgIH1cbiAgfTtcblxuICBLMjU2LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxMDAwMDAzZDEgPSBbIDB4NDAsIDB4M2QxIF1cbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aF0gPSAwO1xuICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoICsgMV0gPSAwO1xuICAgIG51bS5sZW5ndGggKz0gMjtcblxuICAgIC8vIGJvdW5kZWQgYXQ6IDB4NDAgKiAweDNmZmZmZmYgKyAweDNkMCA9IDB4MTAwMDAwMzkwXG4gICAgdmFyIGxvID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHcgPSBudW0ud29yZHNbaV0gfCAwO1xuICAgICAgbG8gKz0gdyAqIDB4M2QxO1xuICAgICAgbnVtLndvcmRzW2ldID0gbG8gJiAweDNmZmZmZmY7XG4gICAgICBsbyA9IHcgKiAweDQwICsgKChsbyAvIDB4NDAwMDAwMCkgfCAwKTtcbiAgICB9XG5cbiAgICAvLyBGYXN0IGxlbmd0aCByZWR1Y3Rpb25cbiAgICBpZiAobnVtLndvcmRzW251bS5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgICAgbnVtLmxlbmd0aC0tO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVtO1xuICB9O1xuXG4gIGZ1bmN0aW9uIFAyMjQgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMjI0JyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCAwMDAwMDAwMScpO1xuICB9XG4gIGluaGVyaXRzKFAyMjQsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDE5MiAoKSB7XG4gICAgTVByaW1lLmNhbGwoXG4gICAgICB0aGlzLFxuICAgICAgJ3AxOTInLFxuICAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmJyk7XG4gIH1cbiAgaW5oZXJpdHMoUDE5MiwgTVByaW1lKTtcblxuICBmdW5jdGlvbiBQMjU1MTkgKCkge1xuICAgIC8vIDIgXiAyNTUgLSAxOVxuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICcyNTUxOScsXG4gICAgICAnN2ZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZlZCcpO1xuICB9XG4gIGluaGVyaXRzKFAyNTUxOSwgTVByaW1lKTtcblxuICBQMjU1MTkucHJvdG90eXBlLmltdWxLID0gZnVuY3Rpb24gaW11bEsgKG51bSkge1xuICAgIC8vIEsgPSAweDEzXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhpID0gKG51bS53b3Jkc1tpXSB8IDApICogMHgxMyArIGNhcnJ5O1xuICAgICAgdmFyIGxvID0gaGkgJiAweDNmZmZmZmY7XG4gICAgICBoaSA+Pj49IDI2O1xuXG4gICAgICBudW0ud29yZHNbaV0gPSBsbztcbiAgICAgIGNhcnJ5ID0gaGk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgbnVtLndvcmRzW251bS5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICAvLyBFeHBvcnRlZCBtb3N0bHkgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHVzZSBwbGFpbiBuYW1lIGluc3RlYWRcbiAgQk4uX3ByaW1lID0gZnVuY3Rpb24gcHJpbWUgKG5hbWUpIHtcbiAgICAvLyBDYWNoZWQgdmVyc2lvbiBvZiBwcmltZVxuICAgIGlmIChwcmltZXNbbmFtZV0pIHJldHVybiBwcmltZXNbbmFtZV07XG5cbiAgICB2YXIgcHJpbWU7XG4gICAgaWYgKG5hbWUgPT09ICdrMjU2Jykge1xuICAgICAgcHJpbWUgPSBuZXcgSzI1NigpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AyMjQnKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjI0KCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDE5MicpIHtcbiAgICAgIHByaW1lID0gbmV3IFAxOTIoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjU1MTknKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMjU1MTkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHByaW1lICcgKyBuYW1lKTtcbiAgICB9XG4gICAgcHJpbWVzW25hbWVdID0gcHJpbWU7XG5cbiAgICByZXR1cm4gcHJpbWU7XG4gIH07XG5cbiAgLy9cbiAgLy8gQmFzZSByZWR1Y3Rpb24gZW5naW5lXG4gIC8vXG4gIGZ1bmN0aW9uIFJlZCAobSkge1xuICAgIGlmICh0eXBlb2YgbSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciBwcmltZSA9IEJOLl9wcmltZShtKTtcbiAgICAgIHRoaXMubSA9IHByaW1lLnA7XG4gICAgICB0aGlzLnByaW1lID0gcHJpbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFzc2VydChtLmd0bigxKSwgJ21vZHVsdXMgbXVzdCBiZSBncmVhdGVyIHRoYW4gMScpO1xuICAgICAgdGhpcy5tID0gbTtcbiAgICAgIHRoaXMucHJpbWUgPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTEgPSBmdW5jdGlvbiBfdmVyaWZ5MSAoYSkge1xuICAgIGFzc2VydChhLm5lZ2F0aXZlID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQsICdyZWQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5fdmVyaWZ5MiA9IGZ1bmN0aW9uIF92ZXJpZnkyIChhLCBiKSB7XG4gICAgYXNzZXJ0KChhLm5lZ2F0aXZlIHwgYi5uZWdhdGl2ZSkgPT09IDAsICdyZWQgd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlcycpO1xuICAgIGFzc2VydChhLnJlZCAmJiBhLnJlZCA9PT0gYi5yZWQsXG4gICAgICAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW1vZCA9IGZ1bmN0aW9uIGltb2QgKGEpIHtcbiAgICBpZiAodGhpcy5wcmltZSkgcmV0dXJuIHRoaXMucHJpbWUuaXJlZHVjZShhKS5fZm9yY2VSZWQodGhpcyk7XG5cbiAgICBtb3ZlKGEsIGEudW1vZCh0aGlzLm0pLl9mb3JjZVJlZCh0aGlzKSk7XG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tLnN1YihhKS5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5zdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zaGwgPSBmdW5jdGlvbiBzaGwgKGEsIG51bSkge1xuICAgIHRoaXMuX3ZlcmlmeTEoYSk7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLnVzaGxuKG51bSkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5pbXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLm11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLmltdWwoYSwgYS5jbG9uZSgpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLm11bChhLCBhKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiBzcXJ0IChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgbW9kMyA9IHRoaXMubS5hbmRsbigzKTtcbiAgICBhc3NlcnQobW9kMyAlIDIgPT09IDEpO1xuXG4gICAgLy8gRmFzdCBjYXNlXG4gICAgaWYgKG1vZDMgPT09IDMpIHtcbiAgICAgIHZhciBwb3cgPSB0aGlzLm0uYWRkKG5ldyBCTigxKSkuaXVzaHJuKDIpO1xuICAgICAgcmV0dXJuIHRoaXMucG93KGEsIHBvdyk7XG4gICAgfVxuXG4gICAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtIChUb3RhbGx5IHVub3B0aW1pemVkIGFuZCBzbG93KVxuICAgIC8vXG4gICAgLy8gRmluZCBRIGFuZCBTLCB0aGF0IFEgKiAyIF4gUyA9IChQIC0gMSlcbiAgICB2YXIgcSA9IHRoaXMubS5zdWJuKDEpO1xuICAgIHZhciBzID0gMDtcbiAgICB3aGlsZSAoIXEuaXNaZXJvKCkgJiYgcS5hbmRsbigxKSA9PT0gMCkge1xuICAgICAgcysrO1xuICAgICAgcS5pdXNocm4oMSk7XG4gICAgfVxuICAgIGFzc2VydCghcS5pc1plcm8oKSk7XG5cbiAgICB2YXIgb25lID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHZhciBuT25lID0gb25lLnJlZE5lZygpO1xuXG4gICAgLy8gRmluZCBxdWFkcmF0aWMgbm9uLXJlc2lkdWVcbiAgICAvLyBOT1RFOiBNYXggaXMgc3VjaCBiZWNhdXNlIG9mIGdlbmVyYWxpemVkIFJpZW1hbm4gaHlwb3RoZXNpcy5cbiAgICB2YXIgbHBvdyA9IHRoaXMubS5zdWJuKDEpLml1c2hybigxKTtcbiAgICB2YXIgeiA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICB6ID0gbmV3IEJOKDIgKiB6ICogeikudG9SZWQodGhpcyk7XG5cbiAgICB3aGlsZSAodGhpcy5wb3coeiwgbHBvdykuY21wKG5PbmUpICE9PSAwKSB7XG4gICAgICB6LnJlZElBZGQobk9uZSk7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB0aGlzLnBvdyh6LCBxKTtcbiAgICB2YXIgciA9IHRoaXMucG93KGEsIHEuYWRkbigxKS5pdXNocm4oMSkpO1xuICAgIHZhciB0ID0gdGhpcy5wb3coYSwgcSk7XG4gICAgdmFyIG0gPSBzO1xuICAgIHdoaWxlICh0LmNtcChvbmUpICE9PSAwKSB7XG4gICAgICB2YXIgdG1wID0gdDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyB0bXAuY21wKG9uZSkgIT09IDA7IGkrKykge1xuICAgICAgICB0bXAgPSB0bXAucmVkU3FyKCk7XG4gICAgICB9XG4gICAgICBhc3NlcnQoaSA8IG0pO1xuICAgICAgdmFyIGIgPSB0aGlzLnBvdyhjLCBuZXcgQk4oMSkuaXVzaGxuKG0gLSBpIC0gMSkpO1xuXG4gICAgICByID0gci5yZWRNdWwoYik7XG4gICAgICBjID0gYi5yZWRTcXIoKTtcbiAgICAgIHQgPSB0LnJlZE11bChjKTtcbiAgICAgIG0gPSBpO1xuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICB2YXIgaW52ID0gYS5faW52bXAodGhpcy5tKTtcbiAgICBpZiAoaW52Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpbnYubmVnYXRpdmUgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpLnJlZE5lZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludik7XG4gICAgfVxuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChhLCBudW0pIHtcbiAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIGlmIChudW0uY21wbigxKSA9PT0gMCkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciB3aW5kb3dTaXplID0gNDtcbiAgICB2YXIgd25kID0gbmV3IEFycmF5KDEgPDwgd2luZG93U2l6ZSk7XG4gICAgd25kWzBdID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHduZFsxXSA9IGE7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCB3bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHduZFtpXSA9IHRoaXMubXVsKHduZFtpIC0gMV0sIGEpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSB3bmRbMF07XG4gICAgdmFyIGN1cnJlbnQgPSAwO1xuICAgIHZhciBjdXJyZW50TGVuID0gMDtcbiAgICB2YXIgc3RhcnQgPSBudW0uYml0TGVuZ3RoKCkgJSAyNjtcbiAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgZm9yIChpID0gbnVtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IG51bS53b3Jkc1tpXTtcbiAgICAgIGZvciAodmFyIGogPSBzdGFydCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIHZhciBiaXQgPSAod29yZCA+PiBqKSAmIDE7XG4gICAgICAgIGlmIChyZXMgIT09IHduZFswXSkge1xuICAgICAgICAgIHJlcyA9IHRoaXMuc3FyKHJlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYml0ID09PSAwICYmIGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPDw9IDE7XG4gICAgICAgIGN1cnJlbnQgfD0gYml0O1xuICAgICAgICBjdXJyZW50TGVuKys7XG4gICAgICAgIGlmIChjdXJyZW50TGVuICE9PSB3aW5kb3dTaXplICYmIChpICE9PSAwIHx8IGogIT09IDApKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSB0aGlzLm11bChyZXMsIHduZFtjdXJyZW50XSk7XG4gICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICBjdXJyZW50ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgdmFyIHIgPSBudW0udW1vZCh0aGlzLm0pO1xuXG4gICAgcmV0dXJuIHIgPT09IG51bSA/IHIuY2xvbmUoKSA6IHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgcmVzID0gbnVtLmNsb25lKCk7XG4gICAgcmVzLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvL1xuICAvLyBNb250Z29tZXJ5IG1ldGhvZCBlbmdpbmVcbiAgLy9cblxuICBCTi5tb250ID0gZnVuY3Rpb24gbW9udCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBNb250KG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gTW9udCAobSkge1xuICAgIFJlZC5jYWxsKHRoaXMsIG0pO1xuXG4gICAgdGhpcy5zaGlmdCA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICBpZiAodGhpcy5zaGlmdCAlIDI2ICE9PSAwKSB7XG4gICAgICB0aGlzLnNoaWZ0ICs9IDI2IC0gKHRoaXMuc2hpZnQgJSAyNik7XG4gICAgfVxuXG4gICAgdGhpcy5yID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLnNoaWZ0KTtcbiAgICB0aGlzLnIyID0gdGhpcy5pbW9kKHRoaXMuci5zcXIoKSk7XG4gICAgdGhpcy5yaW52ID0gdGhpcy5yLl9pbnZtcCh0aGlzLm0pO1xuXG4gICAgdGhpcy5taW52ID0gdGhpcy5yaW52Lm11bCh0aGlzLnIpLmlzdWJuKDEpLmRpdih0aGlzLm0pO1xuICAgIHRoaXMubWludiA9IHRoaXMubWludi51bW9kKHRoaXMucik7XG4gICAgdGhpcy5taW52ID0gdGhpcy5yLnN1Yih0aGlzLm1pbnYpO1xuICB9XG4gIGluaGVyaXRzKE1vbnQsIFJlZCk7XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5pbW9kKG51bS51c2hsbih0aGlzLnNoaWZ0KSk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHIgPSB0aGlzLmltb2QobnVtLm11bCh0aGlzLnJpbnYpKTtcbiAgICByLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSB7XG4gICAgICBhLndvcmRzWzBdID0gMDtcbiAgICAgIGEubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIHZhciB0ID0gYS5pbXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuXG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDApLl9mb3JjZVJlZCh0aGlzKTtcblxuICAgIHZhciB0ID0gYS5tdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIC8vIChBUileLTEgKiBSXjIgPSAoQV4tMSAqIFJeLTEpICogUl4yID0gQV4tMSAqIFJcbiAgICB2YXIgcmVzID0gdGhpcy5pbW9kKGEuX2ludm1wKHRoaXMubSkubXVsKHRoaXMucjIpKTtcbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcbn0pKHR5cGVvZiBtb2R1bGUgPT09ICd1bmRlZmluZWQnIHx8IG1vZHVsZSwgdGhpcyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/borsh/node_modules/bn.js/lib/bn.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/borsh/node_modules/bs58/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/borsh/node_modules/bs58/index.js ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var basex = __webpack_require__(/*! base-x */ \"(app-pages-browser)/./node_modules/base-x/src/index.js\")\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ib3JzaC9ub2RlX21vZHVsZXMvYnM1OC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxZQUFZLG1CQUFPLENBQUMsc0VBQVE7QUFDNUI7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2JvcnNoL25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzP2UyZjUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGJhc2V4ID0gcmVxdWlyZSgnYmFzZS14JylcbnZhciBBTFBIQUJFVCA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2V4KEFMUEhBQkVUKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/borsh/node_modules/bs58/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/bs58/index.js":
/*!************************************!*\
  !*** ./node_modules/bs58/index.js ***!
  \************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("const basex = __webpack_require__(/*! base-x */ \"(app-pages-browser)/./node_modules/bs58/node_modules/base-x/src/index.js\")\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iczU4L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGNBQWMsbUJBQU8sQ0FBQyx3RkFBUTtBQUM5Qjs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYnM1OC9pbmRleC5qcz9lYWRjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGJhc2V4ID0gcmVxdWlyZSgnYmFzZS14JylcbmNvbnN0IEFMUEhBQkVUID0gJzEyMzQ1Njc4OUFCQ0RFRkdISktMTU5QUVJTVFVWV1hZWmFiY2RlZmdoaWprbW5vcHFyc3R1dnd4eXonXG5cbm1vZHVsZS5leHBvcnRzID0gYmFzZXgoQUxQSEFCRVQpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/bs58/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/bs58/node_modules/base-x/src/index.js":
/*!************************************************************!*\
  !*** ./node_modules/bs58/node_modules/base-x/src/index.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Decode character\n      var carry = BASE_MAP[source.charCodeAt(psz)]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iczU4L25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDJDQUEyQztBQUMzQywrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2Q0FBNkM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFlBQVksU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsK0JBQStCLDZDQUE2QztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYnM1OC9ub2RlX21vZHVsZXMvYmFzZS14L3NyYy9pbmRleC5qcz9iMWE1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuLy8gYmFzZS14IGVuY29kaW5nIC8gZGVjb2Rpbmdcbi8vIENvcHlyaWdodCAoYykgMjAxOCBiYXNlLXggY29udHJpYnV0b3JzXG4vLyBDb3B5cmlnaHQgKGMpIDIwMTQtMjAxOCBUaGUgQml0Y29pbiBDb3JlIGRldmVsb3BlcnMgKGJhc2U1OC5jcHApXG4vLyBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIHNvZnR3YXJlIGxpY2Vuc2UsIHNlZSB0aGUgYWNjb21wYW55aW5nXG4vLyBmaWxlIExJQ0VOU0Ugb3IgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHAuXG5mdW5jdGlvbiBiYXNlIChBTFBIQUJFVCkge1xuICBpZiAoQUxQSEFCRVQubGVuZ3RoID49IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdBbHBoYWJldCB0b28gbG9uZycpIH1cbiAgdmFyIEJBU0VfTUFQID0gbmV3IFVpbnQ4QXJyYXkoMjU2KVxuICBmb3IgKHZhciBqID0gMDsgaiA8IEJBU0VfTUFQLmxlbmd0aDsgaisrKSB7XG4gICAgQkFTRV9NQVBbal0gPSAyNTVcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IEFMUEhBQkVULmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHggPSBBTFBIQUJFVC5jaGFyQXQoaSlcbiAgICB2YXIgeGMgPSB4LmNoYXJDb2RlQXQoMClcbiAgICBpZiAoQkFTRV9NQVBbeGNdICE9PSAyNTUpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcih4ICsgJyBpcyBhbWJpZ3VvdXMnKSB9XG4gICAgQkFTRV9NQVBbeGNdID0gaVxuICB9XG4gIHZhciBCQVNFID0gQUxQSEFCRVQubGVuZ3RoXG4gIHZhciBMRUFERVIgPSBBTFBIQUJFVC5jaGFyQXQoMClcbiAgdmFyIEZBQ1RPUiA9IE1hdGgubG9nKEJBU0UpIC8gTWF0aC5sb2coMjU2KSAvLyBsb2coQkFTRSkgLyBsb2coMjU2KSwgcm91bmRlZCB1cFxuICB2YXIgaUZBQ1RPUiA9IE1hdGgubG9nKDI1NikgLyBNYXRoLmxvZyhCQVNFKSAvLyBsb2coMjU2KSAvIGxvZyhCQVNFKSwgcm91bmRlZCB1cFxuICBmdW5jdGlvbiBlbmNvZGUgKHNvdXJjZSkge1xuICAgIGlmIChzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc291cmNlKSkge1xuICAgICAgc291cmNlID0gbmV3IFVpbnQ4QXJyYXkoc291cmNlLmJ1ZmZlciwgc291cmNlLmJ5dGVPZmZzZXQsIHNvdXJjZS5ieXRlTGVuZ3RoKVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShzb3VyY2UpKSB7XG4gICAgICBzb3VyY2UgPSBVaW50OEFycmF5LmZyb20oc291cmNlKVxuICAgIH1cbiAgICBpZiAoIShzb3VyY2UgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBVaW50OEFycmF5JykgfVxuICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7IHJldHVybiAnJyB9XG4gICAgICAgIC8vIFNraXAgJiBjb3VudCBsZWFkaW5nIHplcm9lcy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgdmFyIHBiZWdpbiA9IDBcbiAgICB2YXIgcGVuZCA9IHNvdXJjZS5sZW5ndGhcbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kICYmIHNvdXJjZVtwYmVnaW5dID09PSAwKSB7XG4gICAgICBwYmVnaW4rK1xuICAgICAgemVyb2VzKytcbiAgICB9XG4gICAgICAgIC8vIEFsbG9jYXRlIGVub3VnaCBzcGFjZSBpbiBiaWctZW5kaWFuIGJhc2U1OCByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgocGVuZCAtIHBiZWdpbikgKiBpRkFDVE9SICsgMSkgPj4+IDBcbiAgICB2YXIgYjU4ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgYnl0ZXMuXG4gICAgd2hpbGUgKHBiZWdpbiAhPT0gcGVuZCkge1xuICAgICAgdmFyIGNhcnJ5ID0gc291cmNlW3BiZWdpbl1cbiAgICAgICAgICAgIC8vIEFwcGx5IFwiYjU4ID0gYjU4ICogMjU2ICsgY2hcIi5cbiAgICAgIHZhciBpID0gMFxuICAgICAgZm9yICh2YXIgaXQxID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQxICE9PSAtMSk7IGl0MS0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKDI1NiAqIGI1OFtpdDFdKSA+Pj4gMFxuICAgICAgICBiNThbaXQxXSA9IChjYXJyeSAlIEJBU0UpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gQkFTRSkgPj4+IDBcbiAgICAgIH1cbiAgICAgIGlmIChjYXJyeSAhPT0gMCkgeyB0aHJvdyBuZXcgRXJyb3IoJ05vbi16ZXJvIGNhcnJ5JykgfVxuICAgICAgbGVuZ3RoID0gaVxuICAgICAgcGJlZ2luKytcbiAgICB9XG4gICAgICAgIC8vIFNraXAgbGVhZGluZyB6ZXJvZXMgaW4gYmFzZTU4IHJlc3VsdC5cbiAgICB2YXIgaXQyID0gc2l6ZSAtIGxlbmd0aFxuICAgIHdoaWxlIChpdDIgIT09IHNpemUgJiYgYjU4W2l0Ml0gPT09IDApIHtcbiAgICAgIGl0MisrXG4gICAgfVxuICAgICAgICAvLyBUcmFuc2xhdGUgdGhlIHJlc3VsdCBpbnRvIGEgc3RyaW5nLlxuICAgIHZhciBzdHIgPSBMRUFERVIucmVwZWF0KHplcm9lcylcbiAgICBmb3IgKDsgaXQyIDwgc2l6ZTsgKytpdDIpIHsgc3RyICs9IEFMUEhBQkVULmNoYXJBdChiNThbaXQyXSkgfVxuICAgIHJldHVybiBzdHJcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUgKHNvdXJjZSkge1xuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnc3RyaW5nJykgeyB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBTdHJpbmcnKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuIG5ldyBVaW50OEFycmF5KCkgfVxuICAgIHZhciBwc3ogPSAwXG4gICAgICAgIC8vIFNraXAgYW5kIGNvdW50IGxlYWRpbmcgJzEncy5cbiAgICB2YXIgemVyb2VzID0gMFxuICAgIHZhciBsZW5ndGggPSAwXG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdID09PSBMRUFERVIpIHtcbiAgICAgIHplcm9lcysrXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTI1NiByZXByZXNlbnRhdGlvbi5cbiAgICB2YXIgc2l6ZSA9ICgoKHNvdXJjZS5sZW5ndGggLSBwc3opICogRkFDVE9SKSArIDEpID4+PiAwIC8vIGxvZyg1OCkgLyBsb2coMjU2KSwgcm91bmRlZCB1cC5cbiAgICB2YXIgYjI1NiA9IG5ldyBVaW50OEFycmF5KHNpemUpXG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIGNoYXJhY3RlcnMuXG4gICAgd2hpbGUgKHNvdXJjZVtwc3pdKSB7XG4gICAgICAgICAgICAvLyBEZWNvZGUgY2hhcmFjdGVyXG4gICAgICB2YXIgY2FycnkgPSBCQVNFX01BUFtzb3VyY2UuY2hhckNvZGVBdChwc3opXVxuICAgICAgICAgICAgLy8gSW52YWxpZCBjaGFyYWN0ZXJcbiAgICAgIGlmIChjYXJyeSA9PT0gMjU1KSB7IHJldHVybiB9XG4gICAgICB2YXIgaSA9IDBcbiAgICAgIGZvciAodmFyIGl0MyA9IHNpemUgLSAxOyAoY2FycnkgIT09IDAgfHwgaSA8IGxlbmd0aCkgJiYgKGl0MyAhPT0gLTEpOyBpdDMtLSwgaSsrKSB7XG4gICAgICAgIGNhcnJ5ICs9IChCQVNFICogYjI1NltpdDNdKSA+Pj4gMFxuICAgICAgICBiMjU2W2l0M10gPSAoY2FycnkgJSAyNTYpID4+PiAwXG4gICAgICAgIGNhcnJ5ID0gKGNhcnJ5IC8gMjU2KSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwc3orK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiMjU2LlxuICAgIHZhciBpdDQgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0NCAhPT0gc2l6ZSAmJiBiMjU2W2l0NF0gPT09IDApIHtcbiAgICAgIGl0NCsrXG4gICAgfVxuICAgIHZhciB2Y2ggPSBuZXcgVWludDhBcnJheSh6ZXJvZXMgKyAoc2l6ZSAtIGl0NCkpXG4gICAgdmFyIGogPSB6ZXJvZXNcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplKSB7XG4gICAgICB2Y2hbaisrXSA9IGIyNTZbaXQ0KytdXG4gICAgfVxuICAgIHJldHVybiB2Y2hcbiAgfVxuICBmdW5jdGlvbiBkZWNvZGUgKHN0cmluZykge1xuICAgIHZhciBidWZmZXIgPSBkZWNvZGVVbnNhZmUoc3RyaW5nKVxuICAgIGlmIChidWZmZXIpIHsgcmV0dXJuIGJ1ZmZlciB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdOb24tYmFzZScgKyBCQVNFICsgJyBjaGFyYWN0ZXInKVxuICB9XG4gIHJldHVybiB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlVW5zYWZlOiBkZWNvZGVVbnNhZmUsXG4gICAgZGVjb2RlOiBkZWNvZGVcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBiYXNlXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/bs58/node_modules/base-x/src/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"(app-pages-browser)/./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"(app-pages-browser)/./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLHdFQUFXO0FBQ2xDLGdCQUFnQixtQkFBTyxDQUFDLG9FQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxrQkFBa0I7QUFDbEIseUJBQXlCOztBQUV6QjtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxTQUFTO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGlCQUFpQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxFQUFFO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLFNBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcz8wN2QxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbmNvbnN0IGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG5jb25zdCBpZWVlNzU0ID0gcmVxdWlyZSgnaWVlZTc1NCcpXG5jb25zdCBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbFsnZm9yJ10gPT09ICdmdW5jdGlvbicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgPyBTeW1ib2xbJ2ZvciddKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxuY29uc3QgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBjb25zdCBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBjb25zdCBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgICApXG4gICAgfVxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXG4gIH1cbiAgcmV0dXJuIGZyb20oYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxuXG5mdW5jdGlvbiBmcm9tICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXG4gIH1cblxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlWaWV3KHZhbHVlKVxuICB9XG5cbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICAgIClcbiAgfVxuXG4gIGlmIChpc0luc3RhbmNlKHZhbHVlLCBBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAoaXNJbnN0YW5jZSh2YWx1ZSwgU2hhcmVkQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxuICBpZiAodmFsdWVPZiAhPSBudWxsICYmIHZhbHVlT2YgIT09IHZhbHVlKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlT2YsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGNvbnN0IGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0oJ3N0cmluZycpLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gIClcbn1cblxuLyoqXG4gKiBGdW5jdGlvbmFsbHkgZXF1aXZhbGVudCB0byBCdWZmZXIoYXJnLCBlbmNvZGluZykgYnV0IHRocm93cyBhIFR5cGVFcnJvclxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXG4gKiBCdWZmZXIuZnJvbShhcnJheSlcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxuICoqL1xuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9wdWxsLzE0OFxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlci5wcm90b3R5cGUsIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSlcblxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpXG4gIH0gZWxzZSBpZiAoc2l6ZSA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgY29uc3QgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgbGV0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgY29uc3QgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlWaWV3IChhcnJheVZpZXcpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYXJyYXlWaWV3LCBVaW50OEFycmF5KSkge1xuICAgIGNvbnN0IGNvcHkgPSBuZXcgVWludDhBcnJheShhcnJheVZpZXcpXG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcihjb3B5LmJ1ZmZlciwgY29weS5ieXRlT2Zmc2V0LCBjb3B5LmJ5dGVMZW5ndGgpXG4gIH1cbiAgcmV0dXJuIGZyb21BcnJheUxpa2UoYXJyYXlWaWV3KVxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wib2Zmc2V0XCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJsZW5ndGhcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgbGV0IGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICBjb25zdCBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxuICAgIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICBsZXQgeCA9IGEubGVuZ3RoXG4gIGxldCB5ID0gYi5sZW5ndGhcblxuICBmb3IgKGxldCBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIGxldCBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgbGV0IHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICBsZXQgYnVmID0gbGlzdFtpXVxuICAgIGlmIChpc0luc3RhbmNlKGJ1ZiwgVWludDhBcnJheSkpIHtcbiAgICAgIGlmIChwb3MgKyBidWYubGVuZ3RoID4gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICAgICAgYnVmZmVyLFxuICAgICAgICAgIGJ1ZixcbiAgICAgICAgICBwb3NcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICB9XG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxuICB9XG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgb3IgQXJyYXlCdWZmZXIuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcbiAgICApXG4gIH1cblxuICBjb25zdCBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGNvbnN0IG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2VyY2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIGNvbnN0IGkgPSBiW25dXG4gIGJbbl0gPSBiW21dXG4gIGJbbV0gPSBpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDggIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyBpICs9IDgpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxuICAgIHN3YXAodGhpcywgaSArIDIsIGkgKyA1KVxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvTG9jYWxlU3RyaW5nID0gQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZ1xuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIGxldCBzdHIgPSAnJ1xuICBjb25zdCBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICBsZXQgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgbGV0IHkgPSBlbmQgLSBzdGFydFxuICBjb25zdCBsZW4gPSBNYXRoLm1pbih4LCB5KVxuXG4gIGNvbnN0IHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIGNvbnN0IHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICBsZXQgaW5kZXhTaXplID0gMVxuICBsZXQgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICBsZXQgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICBsZXQgaVxuICBpZiAoZGlyKSB7XG4gICAgbGV0IGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgbGV0IGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICBjb25zdCByZW1haW5pbmcgPSBidWYubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XG4gICAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgICB9XG4gIH1cblxuICBjb25zdCBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29uc3QgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgY29uc3QgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIGNvbnN0IHJlcyA9IFtdXG5cbiAgbGV0IGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIGNvbnN0IGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIGxldCBjb2RlUG9pbnQgPSBudWxsXG4gICAgbGV0IGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRilcbiAgICAgID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERilcbiAgICAgICAgICA/IDNcbiAgICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKVxuICAgICAgICAgICAgICA/IDJcbiAgICAgICAgICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICBsZXQgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG5jb25zdCBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgY29uc3QgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgbGV0IG91dCA9ICcnXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IGhleFNsaWNlTG9va3VwVGFibGVbYnVmW2ldXVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgbGV0IHJlcyA9ICcnXG4gIC8vIElmIGJ5dGVzLmxlbmd0aCBpcyBvZGQsIHRoZSBsYXN0IDggYml0cyBtdXN0IGJlIGlnbm9yZWQgKHNhbWUgYXMgbm9kZS5qcylcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGggLSAxOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgY29uc3QgbmV3QnVmID0gdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICBsZXQgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGxvID0gZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNFxuXG4gIGNvbnN0IGhpID0gdGhpc1srK29mZnNldF0gK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIGxhc3QgKiAyICoqIDI0XG5cbiAgcmV0dXJuIEJpZ0ludChsbykgKyAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgaGkgPSBmaXJzdCAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgY29uc3QgbG8gPSB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3RcblxuICByZXR1cm4gKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSkgKyBCaWdJbnQobG8pXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoXG4gIGxldCBtdWwgPSAxXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyAxXSB8ICh0aGlzW29mZnNldF0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDI0KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDRdICtcbiAgICB0aGlzW29mZnNldCArIDVdICogMiAqKiA4ICtcbiAgICB0aGlzW29mZnNldCArIDZdICogMiAqKiAxNiArXG4gICAgKGxhc3QgPDwgMjQpIC8vIE92ZXJmbG93XG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NEJFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gKGZpcnN0IDw8IDI0KSArIC8vIE92ZXJmbG93XG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQodGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRMRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICByZXR1cm4gb2Zmc2V0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NEJFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyA3XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNl0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDVdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA0XSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgM10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDJdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAxXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0XSA9IGhpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gMFxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgY29uc3QgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZCksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmICgoZW5jb2RpbmcgPT09ICd1dGY4JyAmJiBjb2RlIDwgMTI4KSB8fFxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xuICAgICAgICAvLyBGYXN0IHBhdGg6IElmIGB2YWxgIGZpdHMgaW50byBhIHNpbmdsZSBieXRlLCB1c2UgdGhhdCBudW1lcmljIHZhbHVlLlxuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgdmFsID0gTnVtYmVyKHZhbClcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICBsZXQgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoXG4gICAgaWYgKGxlbiA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIHZhbHVlIFwiJyArIHZhbCArXG4gICAgICAgICdcIiBpcyBpbnZhbGlkIGZvciBhcmd1bWVudCBcInZhbHVlXCInKVxuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBDVVNUT00gRVJST1JTXG4vLyA9PT09PT09PT09PT09XG5cbi8vIFNpbXBsaWZpZWQgdmVyc2lvbnMgZnJvbSBOb2RlLCBjaGFuZ2VkIGZvciBCdWZmZXItb25seSB1c2FnZVxuY29uc3QgZXJyb3JzID0ge31cbmZ1bmN0aW9uIEUgKHN5bSwgZ2V0TWVzc2FnZSwgQmFzZSkge1xuICBlcnJvcnNbc3ltXSA9IGNsYXNzIE5vZGVFcnJvciBleHRlbmRzIEJhc2Uge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgIHN1cGVyKClcblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdtZXNzYWdlJywge1xuICAgICAgICB2YWx1ZTogZ2V0TWVzc2FnZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9KVxuXG4gICAgICAvLyBBZGQgdGhlIGVycm9yIGNvZGUgdG8gdGhlIG5hbWUgdG8gaW5jbHVkZSBpdCBpbiB0aGUgc3RhY2sgdHJhY2UuXG4gICAgICB0aGlzLm5hbWUgPSBgJHt0aGlzLm5hbWV9IFske3N5bX1dYFxuICAgICAgLy8gQWNjZXNzIHRoZSBzdGFjayB0byBnZW5lcmF0ZSB0aGUgZXJyb3IgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIGVycm9yIGNvZGVcbiAgICAgIC8vIGZyb20gdGhlIG5hbWUuXG4gICAgICB0aGlzLnN0YWNrIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG4gICAgICAvLyBSZXNldCB0aGUgbmFtZSB0byB0aGUgYWN0dWFsIG5hbWUuXG4gICAgICBkZWxldGUgdGhpcy5uYW1lXG4gICAgfVxuXG4gICAgZ2V0IGNvZGUgKCkge1xuICAgICAgcmV0dXJuIHN5bVxuICAgIH1cblxuICAgIHNldCBjb2RlICh2YWx1ZSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdjb2RlJywge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfSlcbiAgICB9XG5cbiAgICB0b1N0cmluZyAoKSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5uYW1lfSBbJHtzeW19XTogJHt0aGlzLm1lc3NhZ2V9YFxuICAgIH1cbiAgfVxufVxuXG5FKCdFUlJfQlVGRkVSX09VVF9PRl9CT1VORFMnLFxuICBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gYCR7bmFtZX0gaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzYFxuICAgIH1cblxuICAgIHJldHVybiAnQXR0ZW1wdCB0byBhY2Nlc3MgbWVtb3J5IG91dHNpZGUgYnVmZmVyIGJvdW5kcydcbiAgfSwgUmFuZ2VFcnJvcilcbkUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJyxcbiAgZnVuY3Rpb24gKG5hbWUsIGFjdHVhbCkge1xuICAgIHJldHVybiBgVGhlIFwiJHtuYW1lfVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgJHt0eXBlb2YgYWN0dWFsfWBcbiAgfSwgVHlwZUVycm9yKVxuRSgnRVJSX09VVF9PRl9SQU5HRScsXG4gIGZ1bmN0aW9uIChzdHIsIHJhbmdlLCBpbnB1dCkge1xuICAgIGxldCBtc2cgPSBgVGhlIHZhbHVlIG9mIFwiJHtzdHJ9XCIgaXMgb3V0IG9mIHJhbmdlLmBcbiAgICBsZXQgcmVjZWl2ZWQgPSBpbnB1dFxuICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGlucHV0KSAmJiBNYXRoLmFicyhpbnB1dCkgPiAyICoqIDMyKSB7XG4gICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihTdHJpbmcoaW5wdXQpKVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGlucHV0ID09PSAnYmlnaW50Jykge1xuICAgICAgcmVjZWl2ZWQgPSBTdHJpbmcoaW5wdXQpXG4gICAgICBpZiAoaW5wdXQgPiBCaWdJbnQoMikgKiogQmlnSW50KDMyKSB8fCBpbnB1dCA8IC0oQmlnSW50KDIpICoqIEJpZ0ludCgzMikpKSB7XG4gICAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKHJlY2VpdmVkKVxuICAgICAgfVxuICAgICAgcmVjZWl2ZWQgKz0gJ24nXG4gICAgfVxuICAgIG1zZyArPSBgIEl0IG11c3QgYmUgJHtyYW5nZX0uIFJlY2VpdmVkICR7cmVjZWl2ZWR9YFxuICAgIHJldHVybiBtc2dcbiAgfSwgUmFuZ2VFcnJvcilcblxuZnVuY3Rpb24gYWRkTnVtZXJpY2FsU2VwYXJhdG9yICh2YWwpIHtcbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gdmFsLmxlbmd0aFxuICBjb25zdCBzdGFydCA9IHZhbFswXSA9PT0gJy0nID8gMSA6IDBcbiAgZm9yICg7IGkgPj0gc3RhcnQgKyA0OyBpIC09IDMpIHtcbiAgICByZXMgPSBgXyR7dmFsLnNsaWNlKGkgLSAzLCBpKX0ke3Jlc31gXG4gIH1cbiAgcmV0dXJuIGAke3ZhbC5zbGljZSgwLCBpKX0ke3Jlc31gXG59XG5cbi8vIENIRUNLIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09XG5cbmZ1bmN0aW9uIGNoZWNrQm91bmRzIChidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBpZiAoYnVmW29mZnNldF0gPT09IHVuZGVmaW5lZCB8fCBidWZbb2Zmc2V0ICsgYnl0ZUxlbmd0aF0gPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgYnVmLmxlbmd0aCAtIChieXRlTGVuZ3RoICsgMSkpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbnRCSSAodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgYnl0ZUxlbmd0aCkge1xuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHtcbiAgICBjb25zdCBuID0gdHlwZW9mIG1pbiA9PT0gJ2JpZ2ludCcgPyAnbicgOiAnJ1xuICAgIGxldCByYW5nZVxuICAgIGlmIChieXRlTGVuZ3RoID4gMykge1xuICAgICAgaWYgKG1pbiA9PT0gMCB8fCBtaW4gPT09IEJpZ0ludCgwKSkge1xuICAgICAgICByYW5nZSA9IGA+PSAwJHtufSBhbmQgPCAyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4fSR7bn1gXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByYW5nZSA9IGA+PSAtKDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn0pIGFuZCA8IDIgKiogYCArXG4gICAgICAgICAgICAgICAgYCR7KGJ5dGVMZW5ndGggKyAxKSAqIDggLSAxfSR7bn1gXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlID0gYD49ICR7bWlufSR7bn0gYW5kIDw9ICR7bWF4fSR7bn1gXG4gICAgfVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSgndmFsdWUnLCByYW5nZSwgdmFsdWUpXG4gIH1cbiAgY2hlY2tCb3VuZHMoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlTnVtYmVyICh2YWx1ZSwgbmFtZSkge1xuICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0lOVkFMSURfQVJHX1RZUEUobmFtZSwgJ251bWJlcicsIHZhbHVlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJvdW5kc0Vycm9yICh2YWx1ZSwgbGVuZ3RoLCB0eXBlKSB7XG4gIGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHtcbiAgICB2YWxpZGF0ZU51bWJlcih2YWx1ZSwgdHlwZSlcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JywgJ2FuIGludGVnZXInLCB2YWx1ZSlcbiAgfVxuXG4gIGlmIChsZW5ndGggPCAwKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfQlVGRkVSX09VVF9PRl9CT1VORFMoKVxuICB9XG5cbiAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgPj0gJHt0eXBlID8gMSA6IDB9IGFuZCA8PSAke2xlbmd0aH1gLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUpXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxuY29uc3QgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIGxldCBjb2RlUG9pbnRcbiAgY29uc3QgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICBsZXQgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgY29uc3QgYnl0ZXMgPSBbXVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIGxldCBjLCBoaSwgbG9cbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3Ncbi8vIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2sgYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgb2YgdGhhdCB0eXBlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcbiAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIHR5cGUgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgIT0gbnVsbCAmJlxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcbn1cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cblxuLy8gQ3JlYXRlIGxvb2t1cCB0YWJsZSBmb3IgYHRvU3RyaW5nKCdoZXgnKWBcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzIxOVxuY29uc3QgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IGFscGhhYmV0ID0gJzAxMjM0NTY3ODlhYmNkZWYnXG4gIGNvbnN0IHRhYmxlID0gbmV3IEFycmF5KDI1NilcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgY29uc3QgaTE2ID0gaSAqIDE2XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG5cbi8vIFJldHVybiBub3QgZnVuY3Rpb24gd2l0aCBFcnJvciBpZiBCaWdJbnQgbm90IHN1cHBvcnRlZFxuZnVuY3Rpb24gZGVmaW5lQmlnSW50TWV0aG9kIChmbikge1xuICByZXR1cm4gdHlwZW9mIEJpZ0ludCA9PT0gJ3VuZGVmaW5lZCcgPyBCdWZmZXJCaWdJbnROb3REZWZpbmVkIDogZm5cbn1cblxuZnVuY3Rpb24gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignQmlnSW50IG5vdCBzdXBwb3J0ZWQnKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLFdBQVcsU0FBUztBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwwREFBMEQsT0FBTztBQUNqRTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQ0FBMEMsU0FBUztBQUNuRDtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsZ0JBQWdCLFlBQVk7QUFDNUI7O0FBRUE7QUFDQSw0REFBNEQ7QUFDNUQsZ0VBQWdFO0FBQ2hFLG9FQUFvRTtBQUNwRSx3RUFBd0U7QUFDeEU7QUFDQSwyREFBMkQsU0FBUztBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsR0FBRztBQUNkLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsVUFBVTtBQUNyQixXQUFXLEdBQUc7QUFDZCxhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFVBQVU7QUFDckIsV0FBVyxHQUFHO0FBQ2QsV0FBVyxTQUFTO0FBQ3BCLGFBQWEsY0FBYztBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlCQUFpQjtBQUM1QixhQUFhLGNBQWM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUE2QjtBQUNqQztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4LmpzP2ZiOTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eVxuICAsIHByZWZpeCA9ICd+JztcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciB0byBjcmVhdGUgYSBzdG9yYWdlIGZvciBvdXIgYEVFYCBvYmplY3RzLlxuICogQW4gYEV2ZW50c2AgaW5zdGFuY2UgaXMgYSBwbGFpbiBvYmplY3Qgd2hvc2UgcHJvcGVydGllcyBhcmUgZXZlbnQgbmFtZXMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFdmVudHMoKSB7fVxuXG4vL1xuLy8gV2UgdHJ5IHRvIG5vdCBpbmhlcml0IGZyb20gYE9iamVjdC5wcm90b3R5cGVgLiBJbiBzb21lIGVuZ2luZXMgY3JlYXRpbmcgYW5cbi8vIGluc3RhbmNlIGluIHRoaXMgd2F5IGlzIGZhc3RlciB0aGFuIGNhbGxpbmcgYE9iamVjdC5jcmVhdGUobnVsbClgIGRpcmVjdGx5LlxuLy8gSWYgYE9iamVjdC5jcmVhdGUobnVsbClgIGlzIG5vdCBzdXBwb3J0ZWQgd2UgcHJlZml4IHRoZSBldmVudCBuYW1lcyB3aXRoIGFcbi8vIGNoYXJhY3RlciB0byBtYWtlIHN1cmUgdGhhdCB0aGUgYnVpbHQtaW4gb2JqZWN0IHByb3BlcnRpZXMgYXJlIG5vdFxuLy8gb3ZlcnJpZGRlbiBvciB1c2VkIGFzIGFuIGF0dGFjayB2ZWN0b3IuXG4vL1xuaWYgKE9iamVjdC5jcmVhdGUpIHtcbiAgRXZlbnRzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy9cbiAgLy8gVGhpcyBoYWNrIGlzIG5lZWRlZCBiZWNhdXNlIHRoZSBgX19wcm90b19fYCBwcm9wZXJ0eSBpcyBzdGlsbCBpbmhlcml0ZWQgaW5cbiAgLy8gc29tZSBvbGQgYnJvd3NlcnMgbGlrZSBBbmRyb2lkIDQsIGlQaG9uZSA1LjEsIE9wZXJhIDExIGFuZCBTYWZhcmkgNS5cbiAgLy9cbiAgaWYgKCFuZXcgRXZlbnRzKCkuX19wcm90b19fKSBwcmVmaXggPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRhdGlvbiBvZiBhIHNpbmdsZSBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBbb25jZT1mYWxzZV0gU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gRUUoZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdGhpcy5mbiA9IGZuO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLm9uY2UgPSBvbmNlIHx8IGZhbHNlO1xufVxuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBlbWl0dGVyIFJlZmVyZW5jZSB0byB0aGUgYEV2ZW50RW1pdHRlcmAgaW5zdGFuY2UuXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IGNvbnRleHQgVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHBhcmFtIHtCb29sZWFufSBvbmNlIFNwZWNpZnkgaWYgdGhlIGxpc3RlbmVyIGlzIGEgb25lLXRpbWUgbGlzdGVuZXIuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cblxuICB2YXIgbGlzdGVuZXIgPSBuZXcgRUUoZm4sIGNvbnRleHQgfHwgZW1pdHRlciwgb25jZSlcbiAgICAsIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHNbZXZ0XSkgZW1pdHRlci5fZXZlbnRzW2V2dF0gPSBsaXN0ZW5lciwgZW1pdHRlci5fZXZlbnRzQ291bnQrKztcbiAgZWxzZSBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdLmZuKSBlbWl0dGVyLl9ldmVudHNbZXZ0XS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IFtlbWl0dGVyLl9ldmVudHNbZXZ0XSwgbGlzdGVuZXJdO1xuXG4gIHJldHVybiBlbWl0dGVyO1xufVxuXG4vKipcbiAqIENsZWFyIGV2ZW50IGJ5IG5hbWUuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldnQgVGhlIEV2ZW50IG5hbWUuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjbGVhckV2ZW50KGVtaXR0ZXIsIGV2dCkge1xuICBpZiAoLS1lbWl0dGVyLl9ldmVudHNDb3VudCA9PT0gMCkgZW1pdHRlci5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICBlbHNlIGRlbGV0ZSBlbWl0dGVyLl9ldmVudHNbZXZ0XTtcbn1cblxuLyoqXG4gKiBNaW5pbWFsIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZSB0aGF0IGlzIG1vbGRlZCBhZ2FpbnN0IHRoZSBOb2RlLmpzXG4gKiBgRXZlbnRFbWl0dGVyYCBpbnRlcmZhY2UuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG59XG5cbi8qKlxuICogUmV0dXJuIGFuIGFycmF5IGxpc3RpbmcgdGhlIGV2ZW50cyBmb3Igd2hpY2ggdGhlIGVtaXR0ZXIgaGFzIHJlZ2lzdGVyZWRcbiAqIGxpc3RlbmVycy5cbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHZhciBuYW1lcyA9IFtdXG4gICAgLCBldmVudHNcbiAgICAsIG5hbWU7XG5cbiAgaWYgKHRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSByZXR1cm4gbmFtZXM7XG5cbiAgZm9yIChuYW1lIGluIChldmVudHMgPSB0aGlzLl9ldmVudHMpKSB7XG4gICAgaWYgKGhhcy5jYWxsKGV2ZW50cywgbmFtZSkpIG5hbWVzLnB1c2gocHJlZml4ID8gbmFtZS5zbGljZSgxKSA6IG5hbWUpO1xuICB9XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICByZXR1cm4gbmFtZXMuY29uY2F0KE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoZXZlbnRzKSk7XG4gIH1cblxuICByZXR1cm4gbmFtZXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbGlzdGVuZXJzIHJlZ2lzdGVyZWQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0FycmF5fSBUaGUgcmVnaXN0ZXJlZCBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24gbGlzdGVuZXJzKGV2ZW50KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50XG4gICAgLCBoYW5kbGVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghaGFuZGxlcnMpIHJldHVybiBbXTtcbiAgaWYgKGhhbmRsZXJzLmZuKSByZXR1cm4gW2hhbmRsZXJzLmZuXTtcblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aCwgZWUgPSBuZXcgQXJyYXkobCk7IGkgPCBsOyBpKyspIHtcbiAgICBlZVtpXSA9IGhhbmRsZXJzW2ldLmZuO1xuICB9XG5cbiAgcmV0dXJuIGVlO1xufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWJlciBvZiBsaXN0ZW5lcnMuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmICghbGlzdGVuZXJzKSByZXR1cm4gMDtcbiAgaWYgKGxpc3RlbmVycy5mbikgcmV0dXJuIDE7XG4gIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoO1xufTtcblxuLyoqXG4gKiBDYWxscyBlYWNoIG9mIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBldmVudCBoYWQgbGlzdGVuZXJzLCBlbHNlIGBmYWxzZWAuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQoZXZlbnQsIGExLCBhMiwgYTMsIGE0LCBhNSkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIXRoaXMuX2V2ZW50c1tldnRdKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdXG4gICAgLCBsZW4gPSBhcmd1bWVudHMubGVuZ3RoXG4gICAgLCBhcmdzXG4gICAgLCBpO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAobGlzdGVuZXJzLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVycy5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCksIHRydWU7XG4gICAgICBjYXNlIDI6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEpLCB0cnVlO1xuICAgICAgY2FzZSAzOiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiksIHRydWU7XG4gICAgICBjYXNlIDQ6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMyksIHRydWU7XG4gICAgICBjYXNlIDU6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQpLCB0cnVlO1xuICAgICAgY2FzZSA2OiByZXR1cm4gbGlzdGVuZXJzLmZuLmNhbGwobGlzdGVuZXJzLmNvbnRleHQsIGExLCBhMiwgYTMsIGE0LCBhNSksIHRydWU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgIH1cblxuICAgIGxpc3RlbmVycy5mbi5hcHBseShsaXN0ZW5lcnMuY29udGV4dCwgYXJncyk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGxlbmd0aCA9IGxpc3RlbmVycy5sZW5ndGhcbiAgICAgICwgajtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGxpc3RlbmVyc1tpXS5vbmNlKSB0aGlzLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lcnNbaV0uZm4sIHVuZGVmaW5lZCwgdHJ1ZSk7XG5cbiAgICAgIHN3aXRjaCAobGVuKSB7XG4gICAgICAgIGNhc2UgMTogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQpOyBicmVhaztcbiAgICAgICAgY2FzZSAyOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEpOyBicmVhaztcbiAgICAgICAgY2FzZSAzOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyKTsgYnJlYWs7XG4gICAgICAgIGNhc2UgNDogbGlzdGVuZXJzW2ldLmZuLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGExLCBhMiwgYTMpOyBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAoIWFyZ3MpIGZvciAoaiA9IDEsIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0xKTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgICBhcmdzW2ogLSAxXSA9IGFyZ3VtZW50c1tqXTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsaXN0ZW5lcnNbaV0uZm4uYXBwbHkobGlzdGVuZXJzW2ldLmNvbnRleHQsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBBZGQgYSBsaXN0ZW5lciBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgbGlzdGVuZXIgZnVuY3Rpb24uXG4gKiBAcGFyYW0geyp9IFtjb250ZXh0PXRoaXNdIFRoZSBjb250ZXh0IHRvIGludm9rZSB0aGUgbGlzdGVuZXIgd2l0aC5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIEFkZCBhIG9uZS10aW1lIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKGV2ZW50LCBmbiwgY29udGV4dCkge1xuICByZXR1cm4gYWRkTGlzdGVuZXIodGhpcywgZXZlbnQsIGZuLCBjb250ZXh0LCB0cnVlKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIHRoZSBsaXN0ZW5lcnMgb2YgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggdGhpcyBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBPbmx5IHJlbW92ZSB0aGUgbGlzdGVuZXJzIHRoYXQgaGF2ZSB0aGlzIGNvbnRleHQuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgT25seSByZW1vdmUgb25lLXRpbWUgbGlzdGVuZXJzLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGZuLCBjb250ZXh0LCBvbmNlKSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiB0aGlzO1xuICBpZiAoIWZuKSB7XG4gICAgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgdmFyIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1tldnRdO1xuXG4gIGlmIChsaXN0ZW5lcnMuZm4pIHtcbiAgICBpZiAoXG4gICAgICBsaXN0ZW5lcnMuZm4gPT09IGZuICYmXG4gICAgICAoIW9uY2UgfHwgbGlzdGVuZXJzLm9uY2UpICYmXG4gICAgICAoIWNvbnRleHQgfHwgbGlzdGVuZXJzLmNvbnRleHQgPT09IGNvbnRleHQpXG4gICAgKSB7XG4gICAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwLCBldmVudHMgPSBbXSwgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGxpc3RlbmVyc1tpXS5mbiAhPT0gZm4gfHxcbiAgICAgICAgKG9uY2UgJiYgIWxpc3RlbmVyc1tpXS5vbmNlKSB8fFxuICAgICAgICAoY29udGV4dCAmJiBsaXN0ZW5lcnNbaV0uY29udGV4dCAhPT0gY29udGV4dClcbiAgICAgICkge1xuICAgICAgICBldmVudHMucHVzaChsaXN0ZW5lcnNbaV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gUmVzZXQgdGhlIGFycmF5LCBvciByZW1vdmUgaXQgY29tcGxldGVseSBpZiB3ZSBoYXZlIG5vIG1vcmUgbGlzdGVuZXJzLlxuICAgIC8vXG4gICAgaWYgKGV2ZW50cy5sZW5ndGgpIHRoaXMuX2V2ZW50c1tldnRdID0gZXZlbnRzLmxlbmd0aCA9PT0gMSA/IGV2ZW50c1swXSA6IGV2ZW50cztcbiAgICBlbHNlIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgYWxsIGxpc3RlbmVycywgb3IgdGhvc2Ugb2YgdGhlIHNwZWNpZmllZCBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gW2V2ZW50XSBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9IGB0aGlzYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dDtcblxuICBpZiAoZXZlbnQpIHtcbiAgICBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuICAgIGlmICh0aGlzLl9ldmVudHNbZXZ0XSkgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudHMoKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vXG4vLyBBbGlhcyBtZXRob2RzIG5hbWVzIGJlY2F1c2UgcGVvcGxlIHJvbGwgbGlrZSB0aGF0LlxuLy9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lcjtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBwcmVmaXguXG4vL1xuRXZlbnRFbWl0dGVyLnByZWZpeGVkID0gcHJlZml4O1xuXG4vL1xuLy8gQWxsb3cgYEV2ZW50RW1pdHRlcmAgdG8gYmUgaW1wb3J0ZWQgYXMgbW9kdWxlIG5hbWVzcGFjZS5cbi8vXG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBtb2R1bGUuXG4vL1xuaWYgKCd1bmRlZmluZWQnICE9PSB0eXBlb2YgbW9kdWxlKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/eventemitter3/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXOztBQUVwQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLFdBQVc7O0FBRXBCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVzs7QUFFcEI7QUFDQTtBQUNBLFNBQVMsVUFBVTs7QUFFbkI7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcz8wZmZlIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG5leHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IChlICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIGUgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IG1MZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IGUgKyBlQmlhc1xuICAgIH0gZWxzZSB7XG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSAwXG4gICAgfVxuICB9XG5cbiAgZm9yICg7IG1MZW4gPj0gODsgYnVmZmVyW29mZnNldCArIGldID0gbSAmIDB4ZmYsIGkgKz0gZCwgbSAvPSAyNTYsIG1MZW4gLT0gOCkge31cblxuICBlID0gKGUgPDwgbUxlbikgfCBtXG4gIGVMZW4gKz0gbUxlblxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XG5cbiAgYnVmZmVyW29mZnNldCArIGkgLSBkXSB8PSBzICogMTI4XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/ieee754/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/jayson/lib/client/browser/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/jayson/lib/client/browser/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst uuid = (__webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/index.js\").v4);\nconst generateRequest = __webpack_require__(/*! ../../generateRequest */ \"(app-pages-browser)/./node_modules/jayson/lib/generateRequest.js\");\n\n/**\n * Constructor for a Jayson Browser Client that does not depend any node.js core libraries\n * @class ClientBrowser\n * @param {Function} callServer Method that calls the server, receives the stringified request and a regular node-style callback\n * @param {Object} [options]\n * @param {Function} [options.reviver] Reviver function for JSON\n * @param {Function} [options.replacer] Replacer function for JSON\n * @param {Number} [options.version=2] JSON-RPC version to use (1|2)\n * @param {Function} [options.generator] Function to use for generating request IDs\n *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it\n * @return {ClientBrowser}\n */\nconst ClientBrowser = function(callServer, options) {\n  if(!(this instanceof ClientBrowser)) {\n    return new ClientBrowser(callServer, options);\n  }\n\n  if (!options) {\n    options = {};\n  }\n\n  this.options = {\n    reviver: typeof options.reviver !== 'undefined' ? options.reviver : null,\n    replacer: typeof options.replacer !== 'undefined' ? options.replacer : null,\n    generator: typeof options.generator !== 'undefined' ? options.generator : function() { return uuid(); },\n    version: typeof options.version !== 'undefined' ? options.version : 2,\n    notificationIdNull: typeof options.notificationIdNull === 'boolean' ? options.notificationIdNull : false,\n  };\n\n  this.callServer = callServer;\n};\n\nmodule.exports = ClientBrowser;\n\n/**\n *  Creates a request and dispatches it if given a callback.\n *  @param {String|Array} method A batch request if passed an Array, or a method name if passed a String\n *  @param {Array|Object} [params] Parameters for the method\n *  @param {String|Number} [id] Optional id. If undefined an id will be generated. If null it creates a notification request\n *  @param {Function} [callback] Request callback. If specified, executes the request rather than only returning it.\n *  @throws {TypeError} Invalid parameters\n *  @return {Object} JSON-RPC 1.0 or 2.0 compatible request\n */\nClientBrowser.prototype.request = function(method, params, id, callback) {\n  const self = this;\n  let request = null;\n\n  // is this a batch request?\n  const isBatch = Array.isArray(method) && typeof params === 'function';\n\n  if (this.options.version === 1 && isBatch) {\n    throw new TypeError('JSON-RPC 1.0 does not support batching');\n  }\n\n  // is this a raw request?\n  const isRaw = !isBatch && method && typeof method === 'object' && typeof params === 'function';\n\n  if(isBatch || isRaw) {\n    callback = params;\n    request = method;\n  } else {\n    if(typeof id === 'function') {\n      callback = id;\n      // specifically undefined because \"null\" is a notification request\n      id = undefined;\n    }\n\n    const hasCallback = typeof callback === 'function';\n\n    try {\n      request = generateRequest(method, params, id, {\n        generator: this.options.generator,\n        version: this.options.version,\n        notificationIdNull: this.options.notificationIdNull,\n      });\n    } catch(err) {\n      if(hasCallback) {\n        return callback(err);\n      }\n      throw err;\n    }\n\n    // no callback means we should just return a raw request\n    if(!hasCallback) {\n      return request;\n    }\n\n  }\n\n  let message;\n  try {\n    message = JSON.stringify(request, this.options.replacer);\n  } catch(err) {\n    return callback(err);\n  }\n\n  this.callServer(message, function(err, response) {\n    self._parseResponse(err, response, callback);\n  });\n\n  // always return the raw request\n  return request;\n};\n\n/**\n * Parses a response from a server\n * @param {Object} err Error to pass on that is unrelated to the actual response\n * @param {String} responseText JSON-RPC 1.0 or 2.0 response\n * @param {Function} callback Callback that will receive different arguments depending on the amount of parameters\n * @private\n */\nClientBrowser.prototype._parseResponse = function(err, responseText, callback) {\n  if(err) {\n    callback(err);\n    return;\n  }\n\n  if(!responseText) {\n    // empty response text, assume that is correct because it could be a\n    // notification which jayson does not give any body for\n    return callback();\n  }\n\n  let response;\n  try {\n    response = JSON.parse(responseText, this.options.reviver);\n  } catch(err) {\n    return callback(err);\n  }\n\n  if(callback.length === 3) {\n    // if callback length is 3, we split callback arguments on error and response\n\n    // is batch response?\n    if(Array.isArray(response)) {\n\n      // neccesary to split strictly on validity according to spec here\n      const isError = function(res) {\n        return typeof res.error !== 'undefined';\n      };\n\n      const isNotError = function (res) {\n        return !isError(res);\n      };\n\n      return callback(null, response.filter(isError), response.filter(isNotError));\n    \n    } else {\n\n      // split regardless of validity\n      return callback(null, response.error, response.result);\n    \n    }\n  \n  }\n\n  callback(null, response);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qYXlzb24vbGliL2NsaWVudC9icm93c2VyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLGFBQWEseUdBQWtCO0FBQy9CLHdCQUF3QixtQkFBTyxDQUFDLCtGQUF1Qjs7QUFFdkQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsWUFBWSxTQUFTO0FBQ3JCLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyRkFBMkYsZ0JBQWdCO0FBQzNHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLGNBQWM7QUFDMUIsWUFBWSxjQUFjO0FBQzFCLFlBQVksZUFBZTtBQUMzQixZQUFZLFVBQVU7QUFDdEIsYUFBYSxXQUFXO0FBQ3hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2pheXNvbi9saWIvY2xpZW50L2Jyb3dzZXIvaW5kZXguanM/ZTI0NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHV1aWQgPSByZXF1aXJlKCd1dWlkJykudjQ7XG5jb25zdCBnZW5lcmF0ZVJlcXVlc3QgPSByZXF1aXJlKCcuLi8uLi9nZW5lcmF0ZVJlcXVlc3QnKTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciBmb3IgYSBKYXlzb24gQnJvd3NlciBDbGllbnQgdGhhdCBkb2VzIG5vdCBkZXBlbmQgYW55IG5vZGUuanMgY29yZSBsaWJyYXJpZXNcbiAqIEBjbGFzcyBDbGllbnRCcm93c2VyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsU2VydmVyIE1ldGhvZCB0aGF0IGNhbGxzIHRoZSBzZXJ2ZXIsIHJlY2VpdmVzIHRoZSBzdHJpbmdpZmllZCByZXF1ZXN0IGFuZCBhIHJlZ3VsYXIgbm9kZS1zdHlsZSBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMucmV2aXZlcl0gUmV2aXZlciBmdW5jdGlvbiBmb3IgSlNPTlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMucmVwbGFjZXJdIFJlcGxhY2VyIGZ1bmN0aW9uIGZvciBKU09OXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudmVyc2lvbj0yXSBKU09OLVJQQyB2ZXJzaW9uIHRvIHVzZSAoMXwyKVxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdG9yXSBGdW5jdGlvbiB0byB1c2UgZm9yIGdlbmVyYXRpbmcgcmVxdWVzdCBJRHNcbiAqICBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm5vdGlmaWNhdGlvbklkTnVsbD1mYWxzZV0gV2hlbiB0cnVlLCB2ZXJzaW9uIDIgcmVxdWVzdHMgd2lsbCBzZXQgaWQgdG8gbnVsbCBpbnN0ZWFkIG9mIG9taXR0aW5nIGl0XG4gKiBAcmV0dXJuIHtDbGllbnRCcm93c2VyfVxuICovXG5jb25zdCBDbGllbnRCcm93c2VyID0gZnVuY3Rpb24oY2FsbFNlcnZlciwgb3B0aW9ucykge1xuICBpZighKHRoaXMgaW5zdGFuY2VvZiBDbGllbnRCcm93c2VyKSkge1xuICAgIHJldHVybiBuZXcgQ2xpZW50QnJvd3NlcihjYWxsU2VydmVyLCBvcHRpb25zKTtcbiAgfVxuXG4gIGlmICghb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuXG4gIHRoaXMub3B0aW9ucyA9IHtcbiAgICByZXZpdmVyOiB0eXBlb2Ygb3B0aW9ucy5yZXZpdmVyICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMucmV2aXZlciA6IG51bGwsXG4gICAgcmVwbGFjZXI6IHR5cGVvZiBvcHRpb25zLnJlcGxhY2VyICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMucmVwbGFjZXIgOiBudWxsLFxuICAgIGdlbmVyYXRvcjogdHlwZW9mIG9wdGlvbnMuZ2VuZXJhdG9yICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuZ2VuZXJhdG9yIDogZnVuY3Rpb24oKSB7IHJldHVybiB1dWlkKCk7IH0sXG4gICAgdmVyc2lvbjogdHlwZW9mIG9wdGlvbnMudmVyc2lvbiAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLnZlcnNpb24gOiAyLFxuICAgIG5vdGlmaWNhdGlvbklkTnVsbDogdHlwZW9mIG9wdGlvbnMubm90aWZpY2F0aW9uSWROdWxsID09PSAnYm9vbGVhbicgPyBvcHRpb25zLm5vdGlmaWNhdGlvbklkTnVsbCA6IGZhbHNlLFxuICB9O1xuXG4gIHRoaXMuY2FsbFNlcnZlciA9IGNhbGxTZXJ2ZXI7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsaWVudEJyb3dzZXI7XG5cbi8qKlxuICogIENyZWF0ZXMgYSByZXF1ZXN0IGFuZCBkaXNwYXRjaGVzIGl0IGlmIGdpdmVuIGEgY2FsbGJhY2suXG4gKiAgQHBhcmFtIHtTdHJpbmd8QXJyYXl9IG1ldGhvZCBBIGJhdGNoIHJlcXVlc3QgaWYgcGFzc2VkIGFuIEFycmF5LCBvciBhIG1ldGhvZCBuYW1lIGlmIHBhc3NlZCBhIFN0cmluZ1xuICogIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBbcGFyYW1zXSBQYXJhbWV0ZXJzIGZvciB0aGUgbWV0aG9kXG4gKiAgQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSBbaWRdIE9wdGlvbmFsIGlkLiBJZiB1bmRlZmluZWQgYW4gaWQgd2lsbCBiZSBnZW5lcmF0ZWQuIElmIG51bGwgaXQgY3JlYXRlcyBhIG5vdGlmaWNhdGlvbiByZXF1ZXN0XG4gKiAgQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrXSBSZXF1ZXN0IGNhbGxiYWNrLiBJZiBzcGVjaWZpZWQsIGV4ZWN1dGVzIHRoZSByZXF1ZXN0IHJhdGhlciB0aGFuIG9ubHkgcmV0dXJuaW5nIGl0LlxuICogIEB0aHJvd3Mge1R5cGVFcnJvcn0gSW52YWxpZCBwYXJhbWV0ZXJzXG4gKiAgQHJldHVybiB7T2JqZWN0fSBKU09OLVJQQyAxLjAgb3IgMi4wIGNvbXBhdGlibGUgcmVxdWVzdFxuICovXG5DbGllbnRCcm93c2VyLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24obWV0aG9kLCBwYXJhbXMsIGlkLCBjYWxsYmFjaykge1xuICBjb25zdCBzZWxmID0gdGhpcztcbiAgbGV0IHJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIGlzIHRoaXMgYSBiYXRjaCByZXF1ZXN0P1xuICBjb25zdCBpc0JhdGNoID0gQXJyYXkuaXNBcnJheShtZXRob2QpICYmIHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbic7XG5cbiAgaWYgKHRoaXMub3B0aW9ucy52ZXJzaW9uID09PSAxICYmIGlzQmF0Y2gpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdKU09OLVJQQyAxLjAgZG9lcyBub3Qgc3VwcG9ydCBiYXRjaGluZycpO1xuICB9XG5cbiAgLy8gaXMgdGhpcyBhIHJhdyByZXF1ZXN0P1xuICBjb25zdCBpc1JhdyA9ICFpc0JhdGNoICYmIG1ldGhvZCAmJiB0eXBlb2YgbWV0aG9kID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcGFyYW1zID09PSAnZnVuY3Rpb24nO1xuXG4gIGlmKGlzQmF0Y2ggfHwgaXNSYXcpIHtcbiAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICByZXF1ZXN0ID0gbWV0aG9kO1xuICB9IGVsc2Uge1xuICAgIGlmKHR5cGVvZiBpZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2FsbGJhY2sgPSBpZDtcbiAgICAgIC8vIHNwZWNpZmljYWxseSB1bmRlZmluZWQgYmVjYXVzZSBcIm51bGxcIiBpcyBhIG5vdGlmaWNhdGlvbiByZXF1ZXN0XG4gICAgICBpZCA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBjb25zdCBoYXNDYWxsYmFjayA9IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJztcblxuICAgIHRyeSB7XG4gICAgICByZXF1ZXN0ID0gZ2VuZXJhdGVSZXF1ZXN0KG1ldGhvZCwgcGFyYW1zLCBpZCwge1xuICAgICAgICBnZW5lcmF0b3I6IHRoaXMub3B0aW9ucy5nZW5lcmF0b3IsXG4gICAgICAgIHZlcnNpb246IHRoaXMub3B0aW9ucy52ZXJzaW9uLFxuICAgICAgICBub3RpZmljYXRpb25JZE51bGw6IHRoaXMub3B0aW9ucy5ub3RpZmljYXRpb25JZE51bGwsXG4gICAgICB9KTtcbiAgICB9IGNhdGNoKGVycikge1xuICAgICAgaWYoaGFzQ2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuXG4gICAgLy8gbm8gY2FsbGJhY2sgbWVhbnMgd2Ugc2hvdWxkIGp1c3QgcmV0dXJuIGEgcmF3IHJlcXVlc3RcbiAgICBpZighaGFzQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiByZXF1ZXN0O1xuICAgIH1cblxuICB9XG5cbiAgbGV0IG1lc3NhZ2U7XG4gIHRyeSB7XG4gICAgbWVzc2FnZSA9IEpTT04uc3RyaW5naWZ5KHJlcXVlc3QsIHRoaXMub3B0aW9ucy5yZXBsYWNlcik7XG4gIH0gY2F0Y2goZXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gIH1cblxuICB0aGlzLmNhbGxTZXJ2ZXIobWVzc2FnZSwgZnVuY3Rpb24oZXJyLCByZXNwb25zZSkge1xuICAgIHNlbGYuX3BhcnNlUmVzcG9uc2UoZXJyLCByZXNwb25zZSwgY2FsbGJhY2spO1xuICB9KTtcblxuICAvLyBhbHdheXMgcmV0dXJuIHRoZSByYXcgcmVxdWVzdFxuICByZXR1cm4gcmVxdWVzdDtcbn07XG5cbi8qKlxuICogUGFyc2VzIGEgcmVzcG9uc2UgZnJvbSBhIHNlcnZlclxuICogQHBhcmFtIHtPYmplY3R9IGVyciBFcnJvciB0byBwYXNzIG9uIHRoYXQgaXMgdW5yZWxhdGVkIHRvIHRoZSBhY3R1YWwgcmVzcG9uc2VcbiAqIEBwYXJhbSB7U3RyaW5nfSByZXNwb25zZVRleHQgSlNPTi1SUEMgMS4wIG9yIDIuMCByZXNwb25zZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdGhhdCB3aWxsIHJlY2VpdmUgZGlmZmVyZW50IGFyZ3VtZW50cyBkZXBlbmRpbmcgb24gdGhlIGFtb3VudCBvZiBwYXJhbWV0ZXJzXG4gKiBAcHJpdmF0ZVxuICovXG5DbGllbnRCcm93c2VyLnByb3RvdHlwZS5fcGFyc2VSZXNwb25zZSA9IGZ1bmN0aW9uKGVyciwgcmVzcG9uc2VUZXh0LCBjYWxsYmFjaykge1xuICBpZihlcnIpIHtcbiAgICBjYWxsYmFjayhlcnIpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmKCFyZXNwb25zZVRleHQpIHtcbiAgICAvLyBlbXB0eSByZXNwb25zZSB0ZXh0LCBhc3N1bWUgdGhhdCBpcyBjb3JyZWN0IGJlY2F1c2UgaXQgY291bGQgYmUgYVxuICAgIC8vIG5vdGlmaWNhdGlvbiB3aGljaCBqYXlzb24gZG9lcyBub3QgZ2l2ZSBhbnkgYm9keSBmb3JcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfVxuXG4gIGxldCByZXNwb25zZTtcbiAgdHJ5IHtcbiAgICByZXNwb25zZSA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0LCB0aGlzLm9wdGlvbnMucmV2aXZlcik7XG4gIH0gY2F0Y2goZXJyKSB7XG4gICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gIH1cblxuICBpZihjYWxsYmFjay5sZW5ndGggPT09IDMpIHtcbiAgICAvLyBpZiBjYWxsYmFjayBsZW5ndGggaXMgMywgd2Ugc3BsaXQgY2FsbGJhY2sgYXJndW1lbnRzIG9uIGVycm9yIGFuZCByZXNwb25zZVxuXG4gICAgLy8gaXMgYmF0Y2ggcmVzcG9uc2U/XG4gICAgaWYoQXJyYXkuaXNBcnJheShyZXNwb25zZSkpIHtcblxuICAgICAgLy8gbmVjY2VzYXJ5IHRvIHNwbGl0IHN0cmljdGx5IG9uIHZhbGlkaXR5IGFjY29yZGluZyB0byBzcGVjIGhlcmVcbiAgICAgIGNvbnN0IGlzRXJyb3IgPSBmdW5jdGlvbihyZXMpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiByZXMuZXJyb3IgIT09ICd1bmRlZmluZWQnO1xuICAgICAgfTtcblxuICAgICAgY29uc3QgaXNOb3RFcnJvciA9IGZ1bmN0aW9uIChyZXMpIHtcbiAgICAgICAgcmV0dXJuICFpc0Vycm9yKHJlcyk7XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UuZmlsdGVyKGlzRXJyb3IpLCByZXNwb25zZS5maWx0ZXIoaXNOb3RFcnJvcikpO1xuICAgIFxuICAgIH0gZWxzZSB7XG5cbiAgICAgIC8vIHNwbGl0IHJlZ2FyZGxlc3Mgb2YgdmFsaWRpdHlcbiAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXNwb25zZS5lcnJvciwgcmVzcG9uc2UucmVzdWx0KTtcbiAgICBcbiAgICB9XG4gIFxuICB9XG5cbiAgY2FsbGJhY2sobnVsbCwgcmVzcG9uc2UpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/jayson/lib/client/browser/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/jayson/lib/generateRequest.js":
/*!****************************************************!*\
  !*** ./node_modules/jayson/lib/generateRequest.js ***!
  \****************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nconst uuid = (__webpack_require__(/*! uuid */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/index.js\").v4);\n\n/**\n *  Generates a JSON-RPC 1.0 or 2.0 request\n *  @param {String} method Name of method to call\n *  @param {Array|Object} params Array of parameters passed to the method as specified, or an object of parameter names and corresponding value\n *  @param {String|Number|null} [id] Request ID can be a string, number, null for explicit notification or left out for automatic generation\n *  @param {Object} [options]\n *  @param {Number} [options.version=2] JSON-RPC version to use (1 or 2)\n *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it\n *  @param {Function} [options.generator] Passed the request, and the options object and is expected to return a request ID\n *  @throws {TypeError} If any of the parameters are invalid\n *  @return {Object} A JSON-RPC 1.0 or 2.0 request\n *  @memberOf Utils\n */\nconst generateRequest = function(method, params, id, options) {\n  if(typeof method !== 'string') {\n    throw new TypeError(method + ' must be a string');\n  }\n\n  options = options || {};\n\n  // check valid version provided\n  const version = typeof options.version === 'number' ? options.version : 2;\n  if (version !== 1 && version !== 2) {\n    throw new TypeError(version + ' must be 1 or 2');\n  }\n\n  const request = {\n    method: method\n  };\n\n  if(version === 2) {\n    request.jsonrpc = '2.0';\n  }\n\n  if(params) {\n    // params given, but invalid?\n    if(typeof params !== 'object' && !Array.isArray(params)) {\n      throw new TypeError(params + ' must be an object, array or omitted');\n    }\n    request.params = params;\n  }\n\n  // if id was left out, generate one (null means explicit notification)\n  if(typeof(id) === 'undefined') {\n    const generator = typeof options.generator === 'function' ? options.generator : function() { return uuid(); };\n    request.id = generator(request, options);\n  } else if (version === 2 && id === null) {\n    // we have a version 2 notification\n    if (options.notificationIdNull) {\n      request.id = null; // id will not be set at all unless option provided\n    }\n  } else {\n    request.id = id;\n  }\n\n  return request;\n};\n\nmodule.exports = generateRequest;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9qYXlzb24vbGliL2dlbmVyYXRlUmVxdWVzdC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLHlHQUFrQjs7QUFFL0I7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLGNBQWM7QUFDMUIsWUFBWSxvQkFBb0I7QUFDaEMsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFNBQVM7QUFDckIsWUFBWSxVQUFVO0FBQ3RCLGFBQWEsV0FBVztBQUN4QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUdBQWlHO0FBQ2pHO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9qYXlzb24vbGliL2dlbmVyYXRlUmVxdWVzdC5qcz84ZWQwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgdXVpZCA9IHJlcXVpcmUoJ3V1aWQnKS52NDtcblxuLyoqXG4gKiAgR2VuZXJhdGVzIGEgSlNPTi1SUEMgMS4wIG9yIDIuMCByZXF1ZXN0XG4gKiAgQHBhcmFtIHtTdHJpbmd9IG1ldGhvZCBOYW1lIG9mIG1ldGhvZCB0byBjYWxsXG4gKiAgQHBhcmFtIHtBcnJheXxPYmplY3R9IHBhcmFtcyBBcnJheSBvZiBwYXJhbWV0ZXJzIHBhc3NlZCB0byB0aGUgbWV0aG9kIGFzIHNwZWNpZmllZCwgb3IgYW4gb2JqZWN0IG9mIHBhcmFtZXRlciBuYW1lcyBhbmQgY29ycmVzcG9uZGluZyB2YWx1ZVxuICogIEBwYXJhbSB7U3RyaW5nfE51bWJlcnxudWxsfSBbaWRdIFJlcXVlc3QgSUQgY2FuIGJlIGEgc3RyaW5nLCBudW1iZXIsIG51bGwgZm9yIGV4cGxpY2l0IG5vdGlmaWNhdGlvbiBvciBsZWZ0IG91dCBmb3IgYXV0b21hdGljIGdlbmVyYXRpb25cbiAqICBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiAgQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnZlcnNpb249Ml0gSlNPTi1SUEMgdmVyc2lvbiB0byB1c2UgKDEgb3IgMilcbiAqICBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm5vdGlmaWNhdGlvbklkTnVsbD1mYWxzZV0gV2hlbiB0cnVlLCB2ZXJzaW9uIDIgcmVxdWVzdHMgd2lsbCBzZXQgaWQgdG8gbnVsbCBpbnN0ZWFkIG9mIG9taXR0aW5nIGl0XG4gKiAgQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdG9yXSBQYXNzZWQgdGhlIHJlcXVlc3QsIGFuZCB0aGUgb3B0aW9ucyBvYmplY3QgYW5kIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhIHJlcXVlc3QgSURcbiAqICBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIGFueSBvZiB0aGUgcGFyYW1ldGVycyBhcmUgaW52YWxpZFxuICogIEByZXR1cm4ge09iamVjdH0gQSBKU09OLVJQQyAxLjAgb3IgMi4wIHJlcXVlc3RcbiAqICBAbWVtYmVyT2YgVXRpbHNcbiAqL1xuY29uc3QgZ2VuZXJhdGVSZXF1ZXN0ID0gZnVuY3Rpb24obWV0aG9kLCBwYXJhbXMsIGlkLCBvcHRpb25zKSB7XG4gIGlmKHR5cGVvZiBtZXRob2QgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtZXRob2QgKyAnIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIGNoZWNrIHZhbGlkIHZlcnNpb24gcHJvdmlkZWRcbiAgY29uc3QgdmVyc2lvbiA9IHR5cGVvZiBvcHRpb25zLnZlcnNpb24gPT09ICdudW1iZXInID8gb3B0aW9ucy52ZXJzaW9uIDogMjtcbiAgaWYgKHZlcnNpb24gIT09IDEgJiYgdmVyc2lvbiAhPT0gMikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IodmVyc2lvbiArICcgbXVzdCBiZSAxIG9yIDInKTtcbiAgfVxuXG4gIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgbWV0aG9kOiBtZXRob2RcbiAgfTtcblxuICBpZih2ZXJzaW9uID09PSAyKSB7XG4gICAgcmVxdWVzdC5qc29ucnBjID0gJzIuMCc7XG4gIH1cblxuICBpZihwYXJhbXMpIHtcbiAgICAvLyBwYXJhbXMgZ2l2ZW4sIGJ1dCBpbnZhbGlkP1xuICAgIGlmKHR5cGVvZiBwYXJhbXMgIT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IocGFyYW1zICsgJyBtdXN0IGJlIGFuIG9iamVjdCwgYXJyYXkgb3Igb21pdHRlZCcpO1xuICAgIH1cbiAgICByZXF1ZXN0LnBhcmFtcyA9IHBhcmFtcztcbiAgfVxuXG4gIC8vIGlmIGlkIHdhcyBsZWZ0IG91dCwgZ2VuZXJhdGUgb25lIChudWxsIG1lYW5zIGV4cGxpY2l0IG5vdGlmaWNhdGlvbilcbiAgaWYodHlwZW9mKGlkKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zdCBnZW5lcmF0b3IgPSB0eXBlb2Ygb3B0aW9ucy5nZW5lcmF0b3IgPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmdlbmVyYXRvciA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdXVpZCgpOyB9O1xuICAgIHJlcXVlc3QuaWQgPSBnZW5lcmF0b3IocmVxdWVzdCwgb3B0aW9ucyk7XG4gIH0gZWxzZSBpZiAodmVyc2lvbiA9PT0gMiAmJiBpZCA9PT0gbnVsbCkge1xuICAgIC8vIHdlIGhhdmUgYSB2ZXJzaW9uIDIgbm90aWZpY2F0aW9uXG4gICAgaWYgKG9wdGlvbnMubm90aWZpY2F0aW9uSWROdWxsKSB7XG4gICAgICByZXF1ZXN0LmlkID0gbnVsbDsgLy8gaWQgd2lsbCBub3QgYmUgc2V0IGF0IGFsbCB1bmxlc3Mgb3B0aW9uIHByb3ZpZGVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcXVlc3QuaWQgPSBpZDtcbiAgfVxuXG4gIHJldHVybiByZXF1ZXN0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZW5lcmF0ZVJlcXVlc3Q7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/jayson/lib/generateRequest.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rpc-websockets/dist/lib/client.js":
/*!********************************************************!*\
  !*** ./node_modules/rpc-websockets/dist/lib/client.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")[\"Buffer\"];\n/**\n * \"Client\" wraps \"ws\" or a browser-implemented \"WebSocket\" library\n * according to the environment providing JSON RPC 2.0 support on top.\n * @module Client\n */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n// @ts-ignore\nconst eventemitter3_1 = __webpack_require__(/*! eventemitter3 */ \"(app-pages-browser)/./node_modules/eventemitter3/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(app-pages-browser)/./node_modules/rpc-websockets/dist/lib/utils.js\");\nclass CommonClient extends eventemitter3_1.EventEmitter {\n    address;\n    rpc_id;\n    queue;\n    options;\n    autoconnect;\n    ready;\n    reconnect;\n    reconnect_timer_id;\n    reconnect_interval;\n    max_reconnects;\n    rest_options;\n    current_reconnects;\n    generate_request_id;\n    socket;\n    webSocketFactory;\n    dataPack;\n    /**\n     * Instantiate a Client class.\n     * @constructor\n     * @param {webSocketFactory} webSocketFactory - factory method for WebSocket\n     * @param {String} address - url to a websocket server\n     * @param {Object} options - ws options object with reconnect parameters\n     * @param {Function} generate_request_id - custom generation request Id\n     * @param {DataPack} dataPack - data pack contains encoder and decoder\n     * @return {CommonClient}\n     */\n    constructor(webSocketFactory, address = \"ws://localhost:8080\", { autoconnect = true, reconnect = true, reconnect_interval = 1000, max_reconnects = 5, ...rest_options } = {}, generate_request_id, dataPack) {\n        super();\n        this.webSocketFactory = webSocketFactory;\n        this.queue = {};\n        this.rpc_id = 0;\n        this.address = address;\n        this.autoconnect = autoconnect;\n        this.ready = false;\n        this.reconnect = reconnect;\n        this.reconnect_timer_id = undefined;\n        this.reconnect_interval = reconnect_interval;\n        this.max_reconnects = max_reconnects;\n        this.rest_options = rest_options;\n        this.current_reconnects = 0;\n        this.generate_request_id = generate_request_id || (() => ++this.rpc_id);\n        if (!dataPack)\n            this.dataPack = new utils_1.DefaultDataPack();\n        else\n            this.dataPack = dataPack;\n        if (this.autoconnect)\n            this._connect(this.address, {\n                autoconnect: this.autoconnect,\n                reconnect: this.reconnect,\n                reconnect_interval: this.reconnect_interval,\n                max_reconnects: this.max_reconnects,\n                ...this.rest_options\n            });\n    }\n    /**\n     * Connects to a defined server if not connected already.\n     * @method\n     * @return {Undefined}\n     */\n    connect() {\n        if (this.socket)\n            return;\n        this._connect(this.address, {\n            autoconnect: this.autoconnect,\n            reconnect: this.reconnect,\n            reconnect_interval: this.reconnect_interval,\n            max_reconnects: this.max_reconnects,\n            ...this.rest_options\n        });\n    }\n    /**\n     * Calls a registered RPC method on server.\n     * @method\n     * @param {String} method - RPC method name\n     * @param {Object|Array} params - optional method parameters\n     * @param {Number} timeout - RPC reply timeout value\n     * @param {Object} ws_opts - options passed to ws\n     * @return {Promise}\n     */\n    call(method, params, timeout, ws_opts) {\n        if (!ws_opts && \"object\" === typeof timeout) {\n            ws_opts = timeout;\n            timeout = null;\n        }\n        return new Promise((resolve, reject) => {\n            if (!this.ready)\n                return reject(new Error(\"socket not ready\"));\n            const rpc_id = this.generate_request_id(method, params);\n            const message = {\n                jsonrpc: \"2.0\",\n                method: method,\n                params: params || undefined,\n                id: rpc_id\n            };\n            this.socket.send(this.dataPack.encode(message), ws_opts, (error) => {\n                if (error)\n                    return reject(error);\n                this.queue[rpc_id] = { promise: [resolve, reject] };\n                if (timeout) {\n                    this.queue[rpc_id].timeout = setTimeout(() => {\n                        delete this.queue[rpc_id];\n                        reject(new Error(\"reply timeout\"));\n                    }, timeout);\n                }\n            });\n        });\n    }\n    /**\n     * Logins with the other side of the connection.\n     * @method\n     * @param {Object} params - Login credentials object\n     * @return {Promise}\n     */\n    async login(params) {\n        const resp = await this.call(\"rpc.login\", params);\n        if (!resp)\n            throw new Error(\"authentication failed\");\n        return resp;\n    }\n    /**\n     * Fetches a list of client's methods registered on server.\n     * @method\n     * @return {Array}\n     */\n    async listMethods() {\n        return await this.call(\"__listMethods\");\n    }\n    /**\n     * Sends a JSON-RPC 2.0 notification to server.\n     * @method\n     * @param {String} method - RPC method name\n     * @param {Object} params - optional method parameters\n     * @return {Promise}\n     */\n    notify(method, params) {\n        return new Promise((resolve, reject) => {\n            if (!this.ready)\n                return reject(new Error(\"socket not ready\"));\n            const message = {\n                jsonrpc: \"2.0\",\n                method: method,\n                params\n            };\n            this.socket.send(this.dataPack.encode(message), (error) => {\n                if (error)\n                    return reject(error);\n                resolve();\n            });\n        });\n    }\n    /**\n     * Subscribes for a defined event.\n     * @method\n     * @param {String|Array} event - event name\n     * @return {Undefined}\n     * @throws {Error}\n     */\n    async subscribe(event) {\n        if (typeof event === \"string\")\n            event = [event];\n        const result = await this.call(\"rpc.on\", event);\n        if (typeof event === \"string\" && result[event] !== \"ok\")\n            throw new Error(\"Failed subscribing to an event '\" + event + \"' with: \" + result[event]);\n        return result;\n    }\n    /**\n     * Unsubscribes from a defined event.\n     * @method\n     * @param {String|Array} event - event name\n     * @return {Undefined}\n     * @throws {Error}\n     */\n    async unsubscribe(event) {\n        if (typeof event === \"string\")\n            event = [event];\n        const result = await this.call(\"rpc.off\", event);\n        if (typeof event === \"string\" && result[event] !== \"ok\")\n            throw new Error(\"Failed unsubscribing from an event with: \" + result);\n        return result;\n    }\n    /**\n     * Closes a WebSocket connection gracefully.\n     * @method\n     * @param {Number} code - socket close code\n     * @param {String} data - optional data to be sent before closing\n     * @return {Undefined}\n     */\n    close(code, data) {\n        this.socket.close(code || 1000, data);\n    }\n    /**\n     * Enable / disable automatic reconnection.\n     * @method\n     * @param {Boolean} reconnect - enable / disable reconnection\n     * @return {Undefined}\n     */\n    setAutoReconnect(reconnect) {\n        this.reconnect = reconnect;\n    }\n    /**\n     * Set the interval between reconnection attempts.\n     * @method\n     * @param {Number} interval - reconnection interval in milliseconds\n     * @return {Undefined}\n     */\n    setReconnectInterval(interval) {\n        this.reconnect_interval = interval;\n    }\n    /**\n     * Set the maximum number of reconnection attempts.\n     * @method\n     * @param {Number} max_reconnects - maximum reconnection attempts\n     * @return {Undefined}\n     */\n    setMaxReconnects(max_reconnects) {\n        this.max_reconnects = max_reconnects;\n    }\n    /**\n     * Connection/Message handler.\n     * @method\n     * @private\n     * @param {String} address - WebSocket API address\n     * @param {Object} options - ws options object\n     * @return {Undefined}\n     */\n    _connect(address, options) {\n        clearTimeout(this.reconnect_timer_id);\n        this.socket = this.webSocketFactory(address, options);\n        this.socket.addEventListener(\"open\", () => {\n            this.ready = true;\n            this.emit(\"open\");\n            this.current_reconnects = 0;\n        });\n        this.socket.addEventListener(\"message\", ({ data: message }) => {\n            if (message instanceof ArrayBuffer)\n                message = Buffer.from(message).toString();\n            try {\n                message = this.dataPack.decode(message);\n            }\n            catch (error) {\n                return;\n            }\n            // check if any listeners are attached and forward event\n            if (message.notification && this.listeners(message.notification).length) {\n                if (!Object.keys(message.params).length)\n                    return this.emit(message.notification);\n                const args = [message.notification];\n                if (message.params.constructor === Object)\n                    args.push(message.params);\n                else\n                    // using for-loop instead of unshift/spread because performance is better\n                    for (let i = 0; i < message.params.length; i++)\n                        args.push(message.params[i]);\n                // run as microtask so that pending queue messages are resolved first\n                // eslint-disable-next-line prefer-spread\n                return Promise.resolve().then(() => { this.emit.apply(this, args); });\n            }\n            if (!this.queue[message.id]) {\n                // general JSON RPC 2.0 events\n                if (message.method) {\n                    // run as microtask so that pending queue messages are resolved first\n                    return Promise.resolve().then(() => {\n                        this.emit(message.method, message?.params);\n                    });\n                }\n                return;\n            }\n            // reject early since server's response is invalid\n            if (\"error\" in message === \"result\" in message)\n                this.queue[message.id].promise[1](new Error(\"Server response malformed. Response must include either \\\"result\\\"\" +\n                    \" or \\\"error\\\", but not both.\"));\n            if (this.queue[message.id].timeout)\n                clearTimeout(this.queue[message.id].timeout);\n            if (message.error)\n                this.queue[message.id].promise[1](message.error);\n            else\n                this.queue[message.id].promise[0](message.result);\n            delete this.queue[message.id];\n        });\n        this.socket.addEventListener(\"error\", (error) => this.emit(\"error\", error));\n        this.socket.addEventListener(\"close\", ({ code, reason }) => {\n            if (this.ready) // Delay close event until internal state is updated\n                setTimeout(() => this.emit(\"close\", code, reason), 0);\n            this.ready = false;\n            this.socket = undefined;\n            if (code === 1000)\n                return;\n            this.current_reconnects++;\n            if (this.reconnect && ((this.max_reconnects > this.current_reconnects) ||\n                this.max_reconnects === 0))\n                this.reconnect_timer_id = setTimeout(() => this._connect(address, options), this.reconnect_interval);\n        });\n    }\n}\nexports[\"default\"] = CommonClient;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9kaXN0L2xpYi9jbGllbnQuanMiLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBLHdCQUF3QixtQkFBTyxDQUFDLGdGQUFlO0FBQy9DLGdCQUFnQixtQkFBTyxDQUFDLG9GQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsZ0JBQWdCO0FBQ2hCO0FBQ0EscUVBQXFFLHVHQUF1RyxJQUFJO0FBQ2hMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsY0FBYztBQUM3QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0IsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxtREFBbUQsZUFBZTtBQUNsRTtBQUNBLDBCQUEwQixNQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQywyQkFBMkI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDhCQUE4QjtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsaURBQWlELGNBQWM7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9kaXN0L2xpYi9jbGllbnQuanM/OTRiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFwiQ2xpZW50XCIgd3JhcHMgXCJ3c1wiIG9yIGEgYnJvd3Nlci1pbXBsZW1lbnRlZCBcIldlYlNvY2tldFwiIGxpYnJhcnlcbiAqIGFjY29yZGluZyB0byB0aGUgZW52aXJvbm1lbnQgcHJvdmlkaW5nIEpTT04gUlBDIDIuMCBzdXBwb3J0IG9uIHRvcC5cbiAqIEBtb2R1bGUgQ2xpZW50XG4gKi9cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLy8gQHRzLWlnbm9yZVxuY29uc3QgZXZlbnRlbWl0dGVyM18xID0gcmVxdWlyZShcImV2ZW50ZW1pdHRlcjNcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5jbGFzcyBDb21tb25DbGllbnQgZXh0ZW5kcyBldmVudGVtaXR0ZXIzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICBhZGRyZXNzO1xuICAgIHJwY19pZDtcbiAgICBxdWV1ZTtcbiAgICBvcHRpb25zO1xuICAgIGF1dG9jb25uZWN0O1xuICAgIHJlYWR5O1xuICAgIHJlY29ubmVjdDtcbiAgICByZWNvbm5lY3RfdGltZXJfaWQ7XG4gICAgcmVjb25uZWN0X2ludGVydmFsO1xuICAgIG1heF9yZWNvbm5lY3RzO1xuICAgIHJlc3Rfb3B0aW9ucztcbiAgICBjdXJyZW50X3JlY29ubmVjdHM7XG4gICAgZ2VuZXJhdGVfcmVxdWVzdF9pZDtcbiAgICBzb2NrZXQ7XG4gICAgd2ViU29ja2V0RmFjdG9yeTtcbiAgICBkYXRhUGFjaztcbiAgICAvKipcbiAgICAgKiBJbnN0YW50aWF0ZSBhIENsaWVudCBjbGFzcy5cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge3dlYlNvY2tldEZhY3Rvcnl9IHdlYlNvY2tldEZhY3RvcnkgLSBmYWN0b3J5IG1ldGhvZCBmb3IgV2ViU29ja2V0XG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgLSB1cmwgdG8gYSB3ZWJzb2NrZXQgc2VydmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB3cyBvcHRpb25zIG9iamVjdCB3aXRoIHJlY29ubmVjdCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZ2VuZXJhdGVfcmVxdWVzdF9pZCAtIGN1c3RvbSBnZW5lcmF0aW9uIHJlcXVlc3QgSWRcbiAgICAgKiBAcGFyYW0ge0RhdGFQYWNrfSBkYXRhUGFjayAtIGRhdGEgcGFjayBjb250YWlucyBlbmNvZGVyIGFuZCBkZWNvZGVyXG4gICAgICogQHJldHVybiB7Q29tbW9uQ2xpZW50fVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHdlYlNvY2tldEZhY3RvcnksIGFkZHJlc3MgPSBcIndzOi8vbG9jYWxob3N0OjgwODBcIiwgeyBhdXRvY29ubmVjdCA9IHRydWUsIHJlY29ubmVjdCA9IHRydWUsIHJlY29ubmVjdF9pbnRlcnZhbCA9IDEwMDAsIG1heF9yZWNvbm5lY3RzID0gNSwgLi4ucmVzdF9vcHRpb25zIH0gPSB7fSwgZ2VuZXJhdGVfcmVxdWVzdF9pZCwgZGF0YVBhY2spIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53ZWJTb2NrZXRGYWN0b3J5ID0gd2ViU29ja2V0RmFjdG9yeTtcbiAgICAgICAgdGhpcy5xdWV1ZSA9IHt9O1xuICAgICAgICB0aGlzLnJwY19pZCA9IDA7XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgIHRoaXMuYXV0b2Nvbm5lY3QgPSBhdXRvY29ubmVjdDtcbiAgICAgICAgdGhpcy5yZWFkeSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlY29ubmVjdCA9IHJlY29ubmVjdDtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RfdGltZXJfaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRoaXMucmVjb25uZWN0X2ludGVydmFsID0gcmVjb25uZWN0X2ludGVydmFsO1xuICAgICAgICB0aGlzLm1heF9yZWNvbm5lY3RzID0gbWF4X3JlY29ubmVjdHM7XG4gICAgICAgIHRoaXMucmVzdF9vcHRpb25zID0gcmVzdF9vcHRpb25zO1xuICAgICAgICB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cyA9IDA7XG4gICAgICAgIHRoaXMuZ2VuZXJhdGVfcmVxdWVzdF9pZCA9IGdlbmVyYXRlX3JlcXVlc3RfaWQgfHwgKCgpID0+ICsrdGhpcy5ycGNfaWQpO1xuICAgICAgICBpZiAoIWRhdGFQYWNrKVxuICAgICAgICAgICAgdGhpcy5kYXRhUGFjayA9IG5ldyB1dGlsc18xLkRlZmF1bHREYXRhUGFjaygpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmRhdGFQYWNrID0gZGF0YVBhY2s7XG4gICAgICAgIGlmICh0aGlzLmF1dG9jb25uZWN0KVxuICAgICAgICAgICAgdGhpcy5fY29ubmVjdCh0aGlzLmFkZHJlc3MsIHtcbiAgICAgICAgICAgICAgICBhdXRvY29ubmVjdDogdGhpcy5hdXRvY29ubmVjdCxcbiAgICAgICAgICAgICAgICByZWNvbm5lY3Q6IHRoaXMucmVjb25uZWN0LFxuICAgICAgICAgICAgICAgIHJlY29ubmVjdF9pbnRlcnZhbDogdGhpcy5yZWNvbm5lY3RfaW50ZXJ2YWwsXG4gICAgICAgICAgICAgICAgbWF4X3JlY29ubmVjdHM6IHRoaXMubWF4X3JlY29ubmVjdHMsXG4gICAgICAgICAgICAgICAgLi4udGhpcy5yZXN0X29wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0cyB0byBhIGRlZmluZWQgc2VydmVyIGlmIG5vdCBjb25uZWN0ZWQgYWxyZWFkeS5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAgICAqL1xuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5fY29ubmVjdCh0aGlzLmFkZHJlc3MsIHtcbiAgICAgICAgICAgIGF1dG9jb25uZWN0OiB0aGlzLmF1dG9jb25uZWN0LFxuICAgICAgICAgICAgcmVjb25uZWN0OiB0aGlzLnJlY29ubmVjdCxcbiAgICAgICAgICAgIHJlY29ubmVjdF9pbnRlcnZhbDogdGhpcy5yZWNvbm5lY3RfaW50ZXJ2YWwsXG4gICAgICAgICAgICBtYXhfcmVjb25uZWN0czogdGhpcy5tYXhfcmVjb25uZWN0cyxcbiAgICAgICAgICAgIC4uLnRoaXMucmVzdF9vcHRpb25zXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxscyBhIHJlZ2lzdGVyZWQgUlBDIG1ldGhvZCBvbiBzZXJ2ZXIuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgLSBSUEMgbWV0aG9kIG5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdHxBcnJheX0gcGFyYW1zIC0gb3B0aW9uYWwgbWV0aG9kIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gdGltZW91dCAtIFJQQyByZXBseSB0aW1lb3V0IHZhbHVlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHdzX29wdHMgLSBvcHRpb25zIHBhc3NlZCB0byB3c1xuICAgICAqIEByZXR1cm4ge1Byb21pc2V9XG4gICAgICovXG4gICAgY2FsbChtZXRob2QsIHBhcmFtcywgdGltZW91dCwgd3Nfb3B0cykge1xuICAgICAgICBpZiAoIXdzX29wdHMgJiYgXCJvYmplY3RcIiA9PT0gdHlwZW9mIHRpbWVvdXQpIHtcbiAgICAgICAgICAgIHdzX29wdHMgPSB0aW1lb3V0O1xuICAgICAgICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWFkeSlcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcInNvY2tldCBub3QgcmVhZHlcIikpO1xuICAgICAgICAgICAgY29uc3QgcnBjX2lkID0gdGhpcy5nZW5lcmF0ZV9yZXF1ZXN0X2lkKG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgaWQ6IHJwY19pZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQodGhpcy5kYXRhUGFjay5lbmNvZGUobWVzc2FnZSksIHdzX29wdHMsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZVtycGNfaWRdID0geyBwcm9taXNlOiBbcmVzb2x2ZSwgcmVqZWN0XSB9O1xuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucXVldWVbcnBjX2lkXS50aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5xdWV1ZVtycGNfaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcInJlcGx5IHRpbWVvdXRcIikpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvZ2lucyB3aXRoIHRoZSBvdGhlciBzaWRlIG9mIHRoZSBjb25uZWN0aW9uLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gTG9naW4gY3JlZGVudGlhbHMgb2JqZWN0XG4gICAgICogQHJldHVybiB7UHJvbWlzZX1cbiAgICAgKi9cbiAgICBhc3luYyBsb2dpbihwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IHRoaXMuY2FsbChcInJwYy5sb2dpblwiLCBwYXJhbXMpO1xuICAgICAgICBpZiAoIXJlc3ApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdXRoZW50aWNhdGlvbiBmYWlsZWRcIik7XG4gICAgICAgIHJldHVybiByZXNwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGZXRjaGVzIGEgbGlzdCBvZiBjbGllbnQncyBtZXRob2RzIHJlZ2lzdGVyZWQgb24gc2VydmVyLlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKi9cbiAgICBhc3luYyBsaXN0TWV0aG9kcygpIHtcbiAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuY2FsbChcIl9fbGlzdE1ldGhvZHNcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgSlNPTi1SUEMgMi4wIG5vdGlmaWNhdGlvbiB0byBzZXJ2ZXIuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgLSBSUEMgbWV0aG9kIG5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gb3B0aW9uYWwgbWV0aG9kIHBhcmFtZXRlcnNcbiAgICAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAgICAqL1xuICAgIG5vdGlmeShtZXRob2QsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlYWR5KVxuICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QobmV3IEVycm9yKFwic29ja2V0IG5vdCByZWFkeVwiKSk7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0ge1xuICAgICAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZCh0aGlzLmRhdGFQYWNrLmVuY29kZShtZXNzYWdlKSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1YnNjcmliZXMgZm9yIGEgZGVmaW5lZCBldmVudC5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGV2ZW50IC0gZXZlbnQgbmFtZVxuICAgICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgKi9cbiAgICBhc3luYyBzdWJzY3JpYmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGV2ZW50ID0gW2V2ZW50XTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jYWxsKFwicnBjLm9uXCIsIGV2ZW50KTtcbiAgICAgICAgaWYgKHR5cGVvZiBldmVudCA9PT0gXCJzdHJpbmdcIiAmJiByZXN1bHRbZXZlbnRdICE9PSBcIm9rXCIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgc3Vic2NyaWJpbmcgdG8gYW4gZXZlbnQgJ1wiICsgZXZlbnQgKyBcIicgd2l0aDogXCIgKyByZXN1bHRbZXZlbnRdKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVW5zdWJzY3JpYmVzIGZyb20gYSBkZWZpbmVkIGV2ZW50LlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gZXZlbnQgLSBldmVudCBuYW1lXG4gICAgICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAgICAqIEB0aHJvd3Mge0Vycm9yfVxuICAgICAqL1xuICAgIGFzeW5jIHVuc3Vic2NyaWJlKGV2ZW50KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBldmVudCA9IFtldmVudF07XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMuY2FsbChcInJwYy5vZmZcIiwgZXZlbnQpO1xuICAgICAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiICYmIHJlc3VsdFtldmVudF0gIT09IFwib2tcIilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB1bnN1YnNjcmliaW5nIGZyb20gYW4gZXZlbnQgd2l0aDogXCIgKyByZXN1bHQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgYSBXZWJTb2NrZXQgY29ubmVjdGlvbiBncmFjZWZ1bGx5LlxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gY29kZSAtIHNvY2tldCBjbG9zZSBjb2RlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGEgLSBvcHRpb25hbCBkYXRhIHRvIGJlIHNlbnQgYmVmb3JlIGNsb3NpbmdcbiAgICAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICAgICovXG4gICAgY2xvc2UoY29kZSwgZGF0YSkge1xuICAgICAgICB0aGlzLnNvY2tldC5jbG9zZShjb2RlIHx8IDEwMDAsIGRhdGEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmFibGUgLyBkaXNhYmxlIGF1dG9tYXRpYyByZWNvbm5lY3Rpb24uXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gcmVjb25uZWN0IC0gZW5hYmxlIC8gZGlzYWJsZSByZWNvbm5lY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICAgICovXG4gICAgc2V0QXV0b1JlY29ubmVjdChyZWNvbm5lY3QpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3QgPSByZWNvbm5lY3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgaW50ZXJ2YWwgYmV0d2VlbiByZWNvbm5lY3Rpb24gYXR0ZW1wdHMuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnZhbCAtIHJlY29ubmVjdGlvbiBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHNcbiAgICAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICAgICovXG4gICAgc2V0UmVjb25uZWN0SW50ZXJ2YWwoaW50ZXJ2YWwpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RfaW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiByZWNvbm5lY3Rpb24gYXR0ZW1wdHMuXG4gICAgICogQG1ldGhvZFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhfcmVjb25uZWN0cyAtIG1heGltdW0gcmVjb25uZWN0aW9uIGF0dGVtcHRzXG4gICAgICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHNldE1heFJlY29ubmVjdHMobWF4X3JlY29ubmVjdHMpIHtcbiAgICAgICAgdGhpcy5tYXhfcmVjb25uZWN0cyA9IG1heF9yZWNvbm5lY3RzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0aW9uL01lc3NhZ2UgaGFuZGxlci5cbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyAtIFdlYlNvY2tldCBBUEkgYWRkcmVzc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gd3Mgb3B0aW9ucyBvYmplY3RcbiAgICAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICAgICovXG4gICAgX2Nvbm5lY3QoYWRkcmVzcywgb3B0aW9ucykge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWNvbm5lY3RfdGltZXJfaWQpO1xuICAgICAgICB0aGlzLnNvY2tldCA9IHRoaXMud2ViU29ja2V0RmFjdG9yeShhZGRyZXNzLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJvcGVuXCIpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50X3JlY29ubmVjdHMgPSAwO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgKHsgZGF0YTogbWVzc2FnZSB9KSA9PiB7XG4gICAgICAgICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBCdWZmZXIuZnJvbShtZXNzYWdlKS50b1N0cmluZygpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gdGhpcy5kYXRhUGFjay5kZWNvZGUobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBjaGVjayBpZiBhbnkgbGlzdGVuZXJzIGFyZSBhdHRhY2hlZCBhbmQgZm9yd2FyZCBldmVudFxuICAgICAgICAgICAgaWYgKG1lc3NhZ2Uubm90aWZpY2F0aW9uICYmIHRoaXMubGlzdGVuZXJzKG1lc3NhZ2Uubm90aWZpY2F0aW9uKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKG1lc3NhZ2UucGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQobWVzc2FnZS5ub3RpZmljYXRpb24pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBbbWVzc2FnZS5ub3RpZmljYXRpb25dO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLnBhcmFtcy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KVxuICAgICAgICAgICAgICAgICAgICBhcmdzLnB1c2gobWVzc2FnZS5wYXJhbXMpO1xuICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNpbmcgZm9yLWxvb3AgaW5zdGVhZCBvZiB1bnNoaWZ0L3NwcmVhZCBiZWNhdXNlIHBlcmZvcm1hbmNlIGlzIGJldHRlclxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1lc3NhZ2UucGFyYW1zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5wdXNoKG1lc3NhZ2UucGFyYW1zW2ldKTtcbiAgICAgICAgICAgICAgICAvLyBydW4gYXMgbWljcm90YXNrIHNvIHRoYXQgcGVuZGluZyBxdWV1ZSBtZXNzYWdlcyBhcmUgcmVzb2x2ZWQgZmlyc3RcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLXNwcmVhZFxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKS50aGVuKCgpID0+IHsgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpOyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5xdWV1ZVttZXNzYWdlLmlkXSkge1xuICAgICAgICAgICAgICAgIC8vIGdlbmVyYWwgSlNPTiBSUEMgMi4wIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBydW4gYXMgbWljcm90YXNrIHNvIHRoYXQgcGVuZGluZyBxdWV1ZSBtZXNzYWdlcyBhcmUgcmVzb2x2ZWQgZmlyc3RcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KG1lc3NhZ2UubWV0aG9kLCBtZXNzYWdlPy5wYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gcmVqZWN0IGVhcmx5IHNpbmNlIHNlcnZlcidzIHJlc3BvbnNlIGlzIGludmFsaWRcbiAgICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gbWVzc2FnZSA9PT0gXCJyZXN1bHRcIiBpbiBtZXNzYWdlKVxuICAgICAgICAgICAgICAgIHRoaXMucXVldWVbbWVzc2FnZS5pZF0ucHJvbWlzZVsxXShuZXcgRXJyb3IoXCJTZXJ2ZXIgcmVzcG9uc2UgbWFsZm9ybWVkLiBSZXNwb25zZSBtdXN0IGluY2x1ZGUgZWl0aGVyIFxcXCJyZXN1bHRcXFwiXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIiBvciBcXFwiZXJyb3JcXFwiLCBidXQgbm90IGJvdGguXCIpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdLnRpbWVvdXQpXG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucXVldWVbbWVzc2FnZS5pZF0udGltZW91dCk7XG4gICAgICAgICAgICBpZiAobWVzc2FnZS5lcnJvcilcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdLnByb21pc2VbMV0obWVzc2FnZS5lcnJvcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZVttZXNzYWdlLmlkXS5wcm9taXNlWzBdKG1lc3NhZ2UucmVzdWx0KTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChlcnJvcikgPT4gdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpKTtcbiAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsICh7IGNvZGUsIHJlYXNvbiB9KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkeSkgLy8gRGVsYXkgY2xvc2UgZXZlbnQgdW50aWwgaW50ZXJuYWwgc3RhdGUgaXMgdXBkYXRlZFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5lbWl0KFwiY2xvc2VcIiwgY29kZSwgcmVhc29uKSwgMCk7XG4gICAgICAgICAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnNvY2tldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChjb2RlID09PSAxMDAwKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudF9yZWNvbm5lY3RzKys7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3QgJiYgKCh0aGlzLm1heF9yZWNvbm5lY3RzID4gdGhpcy5jdXJyZW50X3JlY29ubmVjdHMpIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5tYXhfcmVjb25uZWN0cyA9PT0gMCkpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RfdGltZXJfaWQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX2Nvbm5lY3QoYWRkcmVzcywgb3B0aW9ucyksIHRoaXMucmVjb25uZWN0X2ludGVydmFsKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ29tbW9uQ2xpZW50O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rpc-websockets/dist/lib/client.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rpc-websockets/dist/lib/client/websocket.browser.js":
/*!**************************************************************************!*\
  !*** ./node_modules/rpc-websockets/dist/lib/client/websocket.browser.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * WebSocket implements a browser-side WebSocket specification.\n * @module Client\n */\n\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst eventemitter3_1 = __webpack_require__(/*! eventemitter3 */ \"(app-pages-browser)/./node_modules/eventemitter3/index.js\");\nclass WebSocketBrowserImpl extends eventemitter3_1.EventEmitter {\n    socket;\n    /** Instantiate a WebSocket class\n     * @constructor\n     * @param {String} address - url to a websocket server\n     * @param {(Object)} options - websocket options\n     * @param {(String|Array)} protocols - a list of protocols\n     * @return {WebSocketBrowserImpl} - returns a WebSocket instance\n     */\n    constructor(address, options, protocols) {\n        super();\n        this.socket = new window.WebSocket(address, protocols);\n        this.socket.onopen = () => this.emit(\"open\");\n        this.socket.onmessage = (event) => this.emit(\"message\", event.data);\n        this.socket.onerror = (error) => this.emit(\"error\", error);\n        this.socket.onclose = (event) => {\n            this.emit(\"close\", event.code, event.reason);\n        };\n    }\n    /**\n     * Sends data through a websocket connection\n     * @method\n     * @param {(String|Object)} data - data to be sent via websocket\n     * @param {Object} optionsOrCallback - ws options\n     * @param {Function} callback - a callback called once the data is sent\n     * @return {Undefined}\n     */\n    send(data, optionsOrCallback, callback) {\n        const cb = callback || optionsOrCallback;\n        try {\n            this.socket.send(data);\n            cb();\n        }\n        catch (error) {\n            cb(error);\n        }\n    }\n    /**\n     * Closes an underlying socket\n     * @method\n     * @param {Number} code - status code explaining why the connection is being closed\n     * @param {String} reason - a description why the connection is closing\n     * @return {Undefined}\n     * @throws {Error}\n     */\n    close(code, reason) {\n        this.socket.close(code, reason);\n    }\n    addEventListener(type, listener, options) {\n        this.socket.addEventListener(type, listener, options);\n    }\n}\n/**\n * factory method for common WebSocket instance\n * @method\n * @param {String} address - url to a websocket server\n * @param {(Object)} options - websocket options\n * @return {Undefined}\n */\nfunction default_1(address, options) {\n    return new WebSocketBrowserImpl(address, options);\n}\nexports[\"default\"] = default_1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9kaXN0L2xpYi9jbGllbnQvd2Vic29ja2V0LmJyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0IsbUJBQU8sQ0FBQyxnRkFBZTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxnQkFBZ0I7QUFDL0IsZ0JBQWdCLHNCQUFzQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvZGlzdC9saWIvY2xpZW50L3dlYnNvY2tldC5icm93c2VyLmpzP2MwZjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBXZWJTb2NrZXQgaW1wbGVtZW50cyBhIGJyb3dzZXItc2lkZSBXZWJTb2NrZXQgc3BlY2lmaWNhdGlvbi5cbiAqIEBtb2R1bGUgQ2xpZW50XG4gKi9cblwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZXZlbnRlbWl0dGVyM18xID0gcmVxdWlyZShcImV2ZW50ZW1pdHRlcjNcIik7XG5jbGFzcyBXZWJTb2NrZXRCcm93c2VySW1wbCBleHRlbmRzIGV2ZW50ZW1pdHRlcjNfMS5FdmVudEVtaXR0ZXIge1xuICAgIHNvY2tldDtcbiAgICAvKiogSW5zdGFudGlhdGUgYSBXZWJTb2NrZXQgY2xhc3NcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyAtIHVybCB0byBhIHdlYnNvY2tldCBzZXJ2ZXJcbiAgICAgKiBAcGFyYW0geyhPYmplY3QpfSBvcHRpb25zIC0gd2Vic29ja2V0IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0geyhTdHJpbmd8QXJyYXkpfSBwcm90b2NvbHMgLSBhIGxpc3Qgb2YgcHJvdG9jb2xzXG4gICAgICogQHJldHVybiB7V2ViU29ja2V0QnJvd3NlckltcGx9IC0gcmV0dXJucyBhIFdlYlNvY2tldCBpbnN0YW5jZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIG9wdGlvbnMsIHByb3RvY29scykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNvY2tldCA9IG5ldyB3aW5kb3cuV2ViU29ja2V0KGFkZHJlc3MsIHByb3RvY29scyk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9ub3BlbiA9ICgpID0+IHRoaXMuZW1pdChcIm9wZW5cIik7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9ubWVzc2FnZSA9IChldmVudCkgPT4gdGhpcy5lbWl0KFwibWVzc2FnZVwiLCBldmVudC5kYXRhKTtcbiAgICAgICAgdGhpcy5zb2NrZXQub25lcnJvciA9IChlcnJvcikgPT4gdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICB0aGlzLnNvY2tldC5vbmNsb3NlID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjbG9zZVwiLCBldmVudC5jb2RlLCBldmVudC5yZWFzb24pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBkYXRhIHRocm91Z2ggYSB3ZWJzb2NrZXQgY29ubmVjdGlvblxuICAgICAqIEBtZXRob2RcbiAgICAgKiBAcGFyYW0geyhTdHJpbmd8T2JqZWN0KX0gZGF0YSAtIGRhdGEgdG8gYmUgc2VudCB2aWEgd2Vic29ja2V0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNPckNhbGxiYWNrIC0gd3Mgb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gYSBjYWxsYmFjayBjYWxsZWQgb25jZSB0aGUgZGF0YSBpcyBzZW50XG4gICAgICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAgICAqL1xuICAgIHNlbmQoZGF0YSwgb3B0aW9uc09yQ2FsbGJhY2ssIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNiID0gY2FsbGJhY2sgfHwgb3B0aW9uc09yQ2FsbGJhY2s7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldC5zZW5kKGRhdGEpO1xuICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgYW4gdW5kZXJseWluZyBzb2NrZXRcbiAgICAgKiBAbWV0aG9kXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgLSBzdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBiZWluZyBjbG9zZWRcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcmVhc29uIC0gYSBkZXNjcmlwdGlvbiB3aHkgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2luZ1xuICAgICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgICAgKiBAdGhyb3dzIHtFcnJvcn1cbiAgICAgKi9cbiAgICBjbG9zZShjb2RlLCByZWFzb24pIHtcbiAgICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoY29kZSwgcmVhc29uKTtcbiAgICB9XG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zKTtcbiAgICB9XG59XG4vKipcbiAqIGZhY3RvcnkgbWV0aG9kIGZvciBjb21tb24gV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyAtIHVybCB0byBhIHdlYnNvY2tldCBzZXJ2ZXJcbiAqIEBwYXJhbSB7KE9iamVjdCl9IG9wdGlvbnMgLSB3ZWJzb2NrZXQgb3B0aW9uc1xuICogQHJldHVybiB7VW5kZWZpbmVkfVxuICovXG5mdW5jdGlvbiBkZWZhdWx0XzEoYWRkcmVzcywgb3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgV2ViU29ja2V0QnJvd3NlckltcGwoYWRkcmVzcywgb3B0aW9ucyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkZWZhdWx0XzE7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rpc-websockets/dist/lib/client/websocket.browser.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rpc-websockets/dist/lib/utils.js":
/*!*******************************************************!*\
  !*** ./node_modules/rpc-websockets/dist/lib/utils.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.createError = exports.DefaultDataPack = void 0;\nconst errors = new Map([\n    [-32000, \"Event not provided\"],\n    [-32600, \"Invalid Request\"],\n    [-32601, \"Method not found\"],\n    [-32602, \"Invalid params\"],\n    [-32603, \"Internal error\"],\n    [-32604, \"Params not found\"],\n    [-32605, \"Method forbidden\"],\n    [-32606, \"Event forbidden\"],\n    [-32700, \"Parse error\"]\n]);\nclass DefaultDataPack {\n    encode(value) {\n        return JSON.stringify(value);\n    }\n    decode(value) {\n        return JSON.parse(value);\n    }\n}\nexports.DefaultDataPack = DefaultDataPack;\n/**\n * Creates a JSON-RPC 2.0-compliant error.\n * @param {Number} code - error code\n * @param {String} details - error details\n * @return {Object}\n */\nfunction createError(code, details) {\n    const error = {\n        code: code,\n        message: errors.get(code) || \"Internal Server Error\"\n    };\n    if (details)\n        error[\"data\"] = details;\n    return error;\n}\nexports.createError = createError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9kaXN0L2xpYi91dGlscy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsR0FBRyx1QkFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9kaXN0L2xpYi91dGlscy5qcz8wMGU5Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVFcnJvciA9IGV4cG9ydHMuRGVmYXVsdERhdGFQYWNrID0gdm9pZCAwO1xuY29uc3QgZXJyb3JzID0gbmV3IE1hcChbXG4gICAgWy0zMjAwMCwgXCJFdmVudCBub3QgcHJvdmlkZWRcIl0sXG4gICAgWy0zMjYwMCwgXCJJbnZhbGlkIFJlcXVlc3RcIl0sXG4gICAgWy0zMjYwMSwgXCJNZXRob2Qgbm90IGZvdW5kXCJdLFxuICAgIFstMzI2MDIsIFwiSW52YWxpZCBwYXJhbXNcIl0sXG4gICAgWy0zMjYwMywgXCJJbnRlcm5hbCBlcnJvclwiXSxcbiAgICBbLTMyNjA0LCBcIlBhcmFtcyBub3QgZm91bmRcIl0sXG4gICAgWy0zMjYwNSwgXCJNZXRob2QgZm9yYmlkZGVuXCJdLFxuICAgIFstMzI2MDYsIFwiRXZlbnQgZm9yYmlkZGVuXCJdLFxuICAgIFstMzI3MDAsIFwiUGFyc2UgZXJyb3JcIl1cbl0pO1xuY2xhc3MgRGVmYXVsdERhdGFQYWNrIHtcbiAgICBlbmNvZGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnRzLkRlZmF1bHREYXRhUGFjayA9IERlZmF1bHREYXRhUGFjaztcbi8qKlxuICogQ3JlYXRlcyBhIEpTT04tUlBDIDIuMC1jb21wbGlhbnQgZXJyb3IuXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSAtIGVycm9yIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBkZXRhaWxzIC0gZXJyb3IgZGV0YWlsc1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVFcnJvcihjb2RlLCBkZXRhaWxzKSB7XG4gICAgY29uc3QgZXJyb3IgPSB7XG4gICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgIG1lc3NhZ2U6IGVycm9ycy5nZXQoY29kZSkgfHwgXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIlxuICAgIH07XG4gICAgaWYgKGRldGFpbHMpXG4gICAgICAgIGVycm9yW1wiZGF0YVwiXSA9IGRldGFpbHM7XG4gICAgcmV0dXJuIGVycm9yO1xufVxuZXhwb3J0cy5jcmVhdGVFcnJvciA9IGNyZWF0ZUVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rpc-websockets/dist/lib/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ (function(module, exports, __webpack_require__) {

eval(__webpack_require__.ts("/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */\n/* eslint-disable node/no-deprecated-api */\nvar buffer = __webpack_require__(/*! buffer */ \"(app-pages-browser)/./node_modules/buffer/index.js\")\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.prototype = Object.create(Buffer.prototype)\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0EsYUFBYSxtQkFBTyxDQUFDLGtFQUFRO0FBQzdCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUUsY0FBYztBQUNoQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzPzVhZmYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/safe-buffer/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/text-encoding-utf-8/lib/encoding.lib.js":
/*!**************************************************************!*\
  !*** ./node_modules/text-encoding-utf-8/lib/encoding.lib.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\n// This is free and unencumbered software released into the public domain.\n// See LICENSE.md for more information.\n\n//\n// Utilities\n//\n\n/**\n * @param {number} a The number to test.\n * @param {number} min The minimum value in the range, inclusive.\n * @param {number} max The maximum value in the range, inclusive.\n * @return {boolean} True if a >= min and a <= max.\n */\nfunction inRange(a, min, max) {\n  return min <= a && a <= max;\n}\n\n/**\n * @param {*} o\n * @return {Object}\n */\nfunction ToDictionary(o) {\n  if (o === undefined) return {};\n  if (o === Object(o)) return o;\n  throw TypeError('Could not convert argument to dictionary');\n}\n\n/**\n * @param {string} string Input string of UTF-16 code units.\n * @return {!Array.<number>} Code points.\n */\nfunction stringToCodePoints(string) {\n  // https://heycam.github.io/webidl/#dfn-obtain-unicode\n\n  // 1. Let S be the DOMString value.\n  var s = String(string);\n\n  // 2. Let n be the length of S.\n  var n = s.length;\n\n  // 3. Initialize i to 0.\n  var i = 0;\n\n  // 4. Initialize U to be an empty sequence of Unicode characters.\n  var u = [];\n\n  // 5. While i < n:\n  while (i < n) {\n\n    // 1. Let c be the code unit in S at index i.\n    var c = s.charCodeAt(i);\n\n    // 2. Depending on the value of c:\n\n    // c < 0xD800 or c > 0xDFFF\n    if (c < 0xD800 || c > 0xDFFF) {\n      // Append to U the Unicode character with code point c.\n      u.push(c);\n    }\n\n    // 0xDC00 ≤ c ≤ 0xDFFF\n    else if (0xDC00 <= c && c <= 0xDFFF) {\n      // Append to U a U+FFFD REPLACEMENT CHARACTER.\n      u.push(0xFFFD);\n    }\n\n    // 0xD800 ≤ c ≤ 0xDBFF\n    else if (0xD800 <= c && c <= 0xDBFF) {\n      // 1. If i = n−1, then append to U a U+FFFD REPLACEMENT\n      // CHARACTER.\n      if (i === n - 1) {\n        u.push(0xFFFD);\n      }\n      // 2. Otherwise, i < n−1:\n      else {\n        // 1. Let d be the code unit in S at index i+1.\n        var d = string.charCodeAt(i + 1);\n\n        // 2. If 0xDC00 ≤ d ≤ 0xDFFF, then:\n        if (0xDC00 <= d && d <= 0xDFFF) {\n          // 1. Let a be c & 0x3FF.\n          var a = c & 0x3FF;\n\n          // 2. Let b be d & 0x3FF.\n          var b = d & 0x3FF;\n\n          // 3. Append to U the Unicode character with code point\n          // 2^16+2^10*a+b.\n          u.push(0x10000 + (a << 10) + b);\n\n          // 4. Set i to i+1.\n          i += 1;\n        }\n\n        // 3. Otherwise, d < 0xDC00 or d > 0xDFFF. Append to U a\n        // U+FFFD REPLACEMENT CHARACTER.\n        else  {\n          u.push(0xFFFD);\n        }\n      }\n    }\n\n    // 3. Set i to i+1.\n    i += 1;\n  }\n\n  // 6. Return U.\n  return u;\n}\n\n/**\n * @param {!Array.<number>} code_points Array of code points.\n * @return {string} string String of UTF-16 code units.\n */\nfunction codePointsToString(code_points) {\n  var s = '';\n  for (var i = 0; i < code_points.length; ++i) {\n    var cp = code_points[i];\n    if (cp <= 0xFFFF) {\n      s += String.fromCharCode(cp);\n    } else {\n      cp -= 0x10000;\n      s += String.fromCharCode((cp >> 10) + 0xD800,\n                               (cp & 0x3FF) + 0xDC00);\n    }\n  }\n  return s;\n}\n\n\n//\n// Implementation of Encoding specification\n// https://encoding.spec.whatwg.org/\n//\n\n//\n// 3. Terminology\n//\n\n/**\n * End-of-stream is a special token that signifies no more tokens\n * are in the stream.\n * @const\n */ var end_of_stream = -1;\n\n/**\n * A stream represents an ordered sequence of tokens.\n *\n * @constructor\n * @param {!(Array.<number>|Uint8Array)} tokens Array of tokens that provide the\n * stream.\n */\nfunction Stream(tokens) {\n  /** @type {!Array.<number>} */\n  this.tokens = [].slice.call(tokens);\n}\n\nStream.prototype = {\n  /**\n   * @return {boolean} True if end-of-stream has been hit.\n   */\n  endOfStream: function() {\n    return !this.tokens.length;\n  },\n\n  /**\n   * When a token is read from a stream, the first token in the\n   * stream must be returned and subsequently removed, and\n   * end-of-stream must be returned otherwise.\n   *\n   * @return {number} Get the next token from the stream, or\n   * end_of_stream.\n   */\n   read: function() {\n    if (!this.tokens.length)\n      return end_of_stream;\n     return this.tokens.shift();\n   },\n\n  /**\n   * When one or more tokens are prepended to a stream, those tokens\n   * must be inserted, in given order, before the first token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.\n   */\n  prepend: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/(token);\n      while (tokens.length)\n        this.tokens.unshift(tokens.pop());\n    } else {\n      this.tokens.unshift(token);\n    }\n  },\n\n  /**\n   * When one or more tokens are pushed to a stream, those tokens\n   * must be inserted, in given order, after the last token in the\n   * stream.\n   *\n   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.\n   */\n  push: function(token) {\n    if (Array.isArray(token)) {\n      var tokens = /**@type {!Array.<number>}*/(token);\n      while (tokens.length)\n        this.tokens.push(tokens.shift());\n    } else {\n      this.tokens.push(token);\n    }\n  }\n};\n\n//\n// 4. Encodings\n//\n\n// 4.1 Encoders and decoders\n\n/** @const */\nvar finished = -1;\n\n/**\n * @param {boolean} fatal If true, decoding errors raise an exception.\n * @param {number=} opt_code_point Override the standard fallback code point.\n * @return {number} The code point to insert on a decoding error.\n */\nfunction decoderError(fatal, opt_code_point) {\n  if (fatal)\n    throw TypeError('Decoder error');\n  return opt_code_point || 0xFFFD;\n}\n\n//\n// 7. API\n//\n\n/** @const */ var DEFAULT_ENCODING = 'utf-8';\n\n// 7.1 Interface TextDecoder\n\n/**\n * @constructor\n * @param {string=} encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextDecoder(encoding, options) {\n  if (!(this instanceof TextDecoder)) {\n    return new TextDecoder(encoding, options);\n  }\n  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n  if (encoding !== DEFAULT_ENCODING) {\n    throw new Error('Encoding not supported. Only utf-8 is supported');\n  }\n  options = ToDictionary(options);\n\n  /** @private @type {boolean} */\n  this._streaming = false;\n  /** @private @type {boolean} */\n  this._BOMseen = false;\n  /** @private @type {?Decoder} */\n  this._decoder = null;\n  /** @private @type {boolean} */\n  this._fatal = Boolean(options['fatal']);\n  /** @private @type {boolean} */\n  this._ignoreBOM = Boolean(options['ignoreBOM']);\n\n  Object.defineProperty(this, 'encoding', {value: 'utf-8'});\n  Object.defineProperty(this, 'fatal', {value: this._fatal});\n  Object.defineProperty(this, 'ignoreBOM', {value: this._ignoreBOM});\n}\n\nTextDecoder.prototype = {\n  /**\n   * @param {ArrayBufferView=} input The buffer of bytes to decode.\n   * @param {Object=} options\n   * @return {string} The decoded string.\n   */\n  decode: function decode(input, options) {\n    var bytes;\n    if (typeof input === 'object' && input instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input);\n    } else if (typeof input === 'object' && 'buffer' in input &&\n               input.buffer instanceof ArrayBuffer) {\n      bytes = new Uint8Array(input.buffer,\n                             input.byteOffset,\n                             input.byteLength);\n    } else {\n      bytes = new Uint8Array(0);\n    }\n\n    options = ToDictionary(options);\n\n    if (!this._streaming) {\n      this._decoder = new UTF8Decoder({fatal: this._fatal});\n      this._BOMseen = false;\n    }\n    this._streaming = Boolean(options['stream']);\n\n    var input_stream = new Stream(bytes);\n\n    var code_points = [];\n\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n\n    while (!input_stream.endOfStream()) {\n      result = this._decoder.handler(input_stream, input_stream.read());\n      if (result === finished)\n        break;\n      if (result === null)\n        continue;\n      if (Array.isArray(result))\n        code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));\n      else\n        code_points.push(result);\n    }\n    if (!this._streaming) {\n      do {\n        result = this._decoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (result === null)\n          continue;\n        if (Array.isArray(result))\n          code_points.push.apply(code_points, /**@type {!Array.<number>}*/(result));\n        else\n          code_points.push(result);\n      } while (!input_stream.endOfStream());\n      this._decoder = null;\n    }\n\n    if (code_points.length) {\n      // If encoding is one of utf-8, utf-16be, and utf-16le, and\n      // ignore BOM flag and BOM seen flag are unset, run these\n      // subsubsteps:\n      if (['utf-8'].indexOf(this.encoding) !== -1 &&\n          !this._ignoreBOM && !this._BOMseen) {\n        // If token is U+FEFF, set BOM seen flag.\n        if (code_points[0] === 0xFEFF) {\n          this._BOMseen = true;\n          code_points.shift();\n        } else {\n          // Otherwise, if token is not end-of-stream, set BOM seen\n          // flag and append token to output.\n          this._BOMseen = true;\n        }\n      }\n    }\n\n    return codePointsToString(code_points);\n  }\n};\n\n// 7.2 Interface TextEncoder\n\n/**\n * @constructor\n * @param {string=} encoding The label of the encoding;\n *     defaults to 'utf-8'.\n * @param {Object=} options\n */\nfunction TextEncoder(encoding, options) {\n  if (!(this instanceof TextEncoder))\n    return new TextEncoder(encoding, options);\n  encoding = encoding !== undefined ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n  if (encoding !== DEFAULT_ENCODING) {\n    throw new Error('Encoding not supported. Only utf-8 is supported');\n  }\n  options = ToDictionary(options);\n\n  /** @private @type {boolean} */\n  this._streaming = false;\n  /** @private @type {?Encoder} */\n  this._encoder = null;\n  /** @private @type {{fatal: boolean}} */\n  this._options = {fatal: Boolean(options['fatal'])};\n\n  Object.defineProperty(this, 'encoding', {value: 'utf-8'});\n}\n\nTextEncoder.prototype = {\n  /**\n   * @param {string=} opt_string The string to encode.\n   * @param {Object=} options\n   * @return {Uint8Array} Encoded bytes, as a Uint8Array.\n   */\n  encode: function encode(opt_string, options) {\n    opt_string = opt_string ? String(opt_string) : '';\n    options = ToDictionary(options);\n\n    // NOTE: This option is nonstandard. None of the encodings\n    // permitted for encoding (i.e. UTF-8, UTF-16) are stateful,\n    // so streaming is not necessary.\n    if (!this._streaming)\n      this._encoder = new UTF8Encoder(this._options);\n    this._streaming = Boolean(options['stream']);\n\n    var bytes = [];\n    var input_stream = new Stream(stringToCodePoints(opt_string));\n    /** @type {?(number|!Array.<number>)} */\n    var result;\n    while (!input_stream.endOfStream()) {\n      result = this._encoder.handler(input_stream, input_stream.read());\n      if (result === finished)\n        break;\n      if (Array.isArray(result))\n        bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));\n      else\n        bytes.push(result);\n    }\n    if (!this._streaming) {\n      while (true) {\n        result = this._encoder.handler(input_stream, input_stream.read());\n        if (result === finished)\n          break;\n        if (Array.isArray(result))\n          bytes.push.apply(bytes, /**@type {!Array.<number>}*/(result));\n        else\n          bytes.push(result);\n      }\n      this._encoder = null;\n    }\n    return new Uint8Array(bytes);\n  }\n};\n\n//\n// 8. The encoding\n//\n\n// 8.1 utf-8\n\n/**\n * @constructor\n * @implements {Decoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Decoder(options) {\n  var fatal = options.fatal;\n\n  // utf-8's decoder's has an associated utf-8 code point, utf-8\n  // bytes seen, and utf-8 bytes needed (all initially 0), a utf-8\n  // lower boundary (initially 0x80), and a utf-8 upper boundary\n  // (initially 0xBF).\n  var /** @type {number} */ utf8_code_point = 0,\n      /** @type {number} */ utf8_bytes_seen = 0,\n      /** @type {number} */ utf8_bytes_needed = 0,\n      /** @type {number} */ utf8_lower_boundary = 0x80,\n      /** @type {number} */ utf8_upper_boundary = 0xBF;\n\n  /**\n   * @param {Stream} stream The stream of bytes being decoded.\n   * @param {number} bite The next byte read from the stream.\n   * @return {?(number|!Array.<number>)} The next code point(s)\n   *     decoded, or null if not enough data exists in the input\n   *     stream to decode a complete code point.\n   */\n  this.handler = function(stream, bite) {\n    // 1. If byte is end-of-stream and utf-8 bytes needed is not 0,\n    // set utf-8 bytes needed to 0 and return error.\n    if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n      utf8_bytes_needed = 0;\n      return decoderError(fatal);\n    }\n\n    // 2. If byte is end-of-stream, return finished.\n    if (bite === end_of_stream)\n      return finished;\n\n    // 3. If utf-8 bytes needed is 0, based on byte:\n    if (utf8_bytes_needed === 0) {\n\n      // 0x00 to 0x7F\n      if (inRange(bite, 0x00, 0x7F)) {\n        // Return a code point whose value is byte.\n        return bite;\n      }\n\n      // 0xC2 to 0xDF\n      if (inRange(bite, 0xC2, 0xDF)) {\n        // Set utf-8 bytes needed to 1 and utf-8 code point to byte\n        // − 0xC0.\n        utf8_bytes_needed = 1;\n        utf8_code_point = bite - 0xC0;\n      }\n\n      // 0xE0 to 0xEF\n      else if (inRange(bite, 0xE0, 0xEF)) {\n        // 1. If byte is 0xE0, set utf-8 lower boundary to 0xA0.\n        if (bite === 0xE0)\n          utf8_lower_boundary = 0xA0;\n        // 2. If byte is 0xED, set utf-8 upper boundary to 0x9F.\n        if (bite === 0xED)\n          utf8_upper_boundary = 0x9F;\n        // 3. Set utf-8 bytes needed to 2 and utf-8 code point to\n        // byte − 0xE0.\n        utf8_bytes_needed = 2;\n        utf8_code_point = bite - 0xE0;\n      }\n\n      // 0xF0 to 0xF4\n      else if (inRange(bite, 0xF0, 0xF4)) {\n        // 1. If byte is 0xF0, set utf-8 lower boundary to 0x90.\n        if (bite === 0xF0)\n          utf8_lower_boundary = 0x90;\n        // 2. If byte is 0xF4, set utf-8 upper boundary to 0x8F.\n        if (bite === 0xF4)\n          utf8_upper_boundary = 0x8F;\n        // 3. Set utf-8 bytes needed to 3 and utf-8 code point to\n        // byte − 0xF0.\n        utf8_bytes_needed = 3;\n        utf8_code_point = bite - 0xF0;\n      }\n\n      // Otherwise\n      else {\n        // Return error.\n        return decoderError(fatal);\n      }\n\n      // Then (byte is in the range 0xC2 to 0xF4) set utf-8 code\n      // point to utf-8 code point << (6 × utf-8 bytes needed) and\n      // return continue.\n      utf8_code_point = utf8_code_point << (6 * utf8_bytes_needed);\n      return null;\n    }\n\n    // 4. If byte is not in the range utf-8 lower boundary to utf-8\n    // upper boundary, run these substeps:\n    if (!inRange(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n\n      // 1. Set utf-8 code point, utf-8 bytes needed, and utf-8\n      // bytes seen to 0, set utf-8 lower boundary to 0x80, and set\n      // utf-8 upper boundary to 0xBF.\n      utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n      utf8_lower_boundary = 0x80;\n      utf8_upper_boundary = 0xBF;\n\n      // 2. Prepend byte to stream.\n      stream.prepend(bite);\n\n      // 3. Return error.\n      return decoderError(fatal);\n    }\n\n    // 5. Set utf-8 lower boundary to 0x80 and utf-8 upper boundary\n    // to 0xBF.\n    utf8_lower_boundary = 0x80;\n    utf8_upper_boundary = 0xBF;\n\n    // 6. Increase utf-8 bytes seen by one and set utf-8 code point\n    // to utf-8 code point + (byte − 0x80) << (6 × (utf-8 bytes\n    // needed − utf-8 bytes seen)).\n    utf8_bytes_seen += 1;\n    utf8_code_point += (bite - 0x80) << (6 * (utf8_bytes_needed - utf8_bytes_seen));\n\n    // 7. If utf-8 bytes seen is not equal to utf-8 bytes needed,\n    // continue.\n    if (utf8_bytes_seen !== utf8_bytes_needed)\n      return null;\n\n    // 8. Let code point be utf-8 code point.\n    var code_point = utf8_code_point;\n\n    // 9. Set utf-8 code point, utf-8 bytes needed, and utf-8 bytes\n    // seen to 0.\n    utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n\n    // 10. Return a code point whose value is code point.\n    return code_point;\n  };\n}\n\n/**\n * @constructor\n * @implements {Encoder}\n * @param {{fatal: boolean}} options\n */\nfunction UTF8Encoder(options) {\n  var fatal = options.fatal;\n  /**\n   * @param {Stream} stream Input stream.\n   * @param {number} code_point Next code point read from the stream.\n   * @return {(number|!Array.<number>)} Byte(s) to emit.\n   */\n  this.handler = function(stream, code_point) {\n    // 1. If code point is end-of-stream, return finished.\n    if (code_point === end_of_stream)\n      return finished;\n\n    // 2. If code point is in the range U+0000 to U+007F, return a\n    // byte whose value is code point.\n    if (inRange(code_point, 0x0000, 0x007f))\n      return code_point;\n\n    // 3. Set count and offset based on the range code point is in:\n    var count, offset;\n    // U+0080 to U+07FF:    1 and 0xC0\n    if (inRange(code_point, 0x0080, 0x07FF)) {\n      count = 1;\n      offset = 0xC0;\n    }\n    // U+0800 to U+FFFF:    2 and 0xE0\n    else if (inRange(code_point, 0x0800, 0xFFFF)) {\n      count = 2;\n      offset = 0xE0;\n    }\n    // U+10000 to U+10FFFF: 3 and 0xF0\n    else if (inRange(code_point, 0x10000, 0x10FFFF)) {\n      count = 3;\n      offset = 0xF0;\n    }\n\n    // 4.Let bytes be a byte sequence whose first byte is (code\n    // point >> (6 × count)) + offset.\n    var bytes = [(code_point >> (6 * count)) + offset];\n\n    // 5. Run these substeps while count is greater than 0:\n    while (count > 0) {\n\n      // 1. Set temp to code point >> (6 × (count − 1)).\n      var temp = code_point >> (6 * (count - 1));\n\n      // 2. Append to bytes 0x80 | (temp & 0x3F).\n      bytes.push(0x80 | (temp & 0x3F));\n\n      // 3. Decrease count by one.\n      count -= 1;\n    }\n\n    // 6. Return bytes bytes, in order.\n    return bytes;\n  };\n}\n\nexports.TextEncoder = TextEncoder;\nexports.TextDecoder = TextDecoder;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90ZXh0LWVuY29kaW5nLXV0Zi04L2xpYi9lbmNvZGluZy5saWIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLEdBQUc7QUFDZCxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksaUJBQWlCO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhCQUE4QjtBQUN6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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CLG1CQUFtQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGV4dC1lbmNvZGluZy11dGYtOC9saWIvZW5jb2RpbmcubGliLmpzPzBjNjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG4vLyBUaGlzIGlzIGZyZWUgYW5kIHVuZW5jdW1iZXJlZCBzb2Z0d2FyZSByZWxlYXNlZCBpbnRvIHRoZSBwdWJsaWMgZG9tYWluLlxuLy8gU2VlIExJQ0VOU0UubWQgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbi8vXG4vLyBVdGlsaXRpZXNcbi8vXG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGEgVGhlIG51bWJlciB0byB0ZXN0LlxuICogQHBhcmFtIHtudW1iZXJ9IG1pbiBUaGUgbWluaW11bSB2YWx1ZSBpbiB0aGUgcmFuZ2UsIGluY2x1c2l2ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXggVGhlIG1heGltdW0gdmFsdWUgaW4gdGhlIHJhbmdlLCBpbmNsdXNpdmUuXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIGEgPj0gbWluIGFuZCBhIDw9IG1heC5cbiAqL1xuZnVuY3Rpb24gaW5SYW5nZShhLCBtaW4sIG1heCkge1xuICByZXR1cm4gbWluIDw9IGEgJiYgYSA8PSBtYXg7XG59XG5cbi8qKlxuICogQHBhcmFtIHsqfSBvXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIFRvRGljdGlvbmFyeShvKSB7XG4gIGlmIChvID09PSB1bmRlZmluZWQpIHJldHVybiB7fTtcbiAgaWYgKG8gPT09IE9iamVjdChvKSkgcmV0dXJuIG87XG4gIHRocm93IFR5cGVFcnJvcignQ291bGQgbm90IGNvbnZlcnQgYXJndW1lbnQgdG8gZGljdGlvbmFyeScpO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgSW5wdXQgc3RyaW5nIG9mIFVURi0xNiBjb2RlIHVuaXRzLlxuICogQHJldHVybiB7IUFycmF5LjxudW1iZXI+fSBDb2RlIHBvaW50cy5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9Db2RlUG9pbnRzKHN0cmluZykge1xuICAvLyBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNkZm4tb2J0YWluLXVuaWNvZGVcblxuICAvLyAxLiBMZXQgUyBiZSB0aGUgRE9NU3RyaW5nIHZhbHVlLlxuICB2YXIgcyA9IFN0cmluZyhzdHJpbmcpO1xuXG4gIC8vIDIuIExldCBuIGJlIHRoZSBsZW5ndGggb2YgUy5cbiAgdmFyIG4gPSBzLmxlbmd0aDtcblxuICAvLyAzLiBJbml0aWFsaXplIGkgdG8gMC5cbiAgdmFyIGkgPSAwO1xuXG4gIC8vIDQuIEluaXRpYWxpemUgVSB0byBiZSBhbiBlbXB0eSBzZXF1ZW5jZSBvZiBVbmljb2RlIGNoYXJhY3RlcnMuXG4gIHZhciB1ID0gW107XG5cbiAgLy8gNS4gV2hpbGUgaSA8IG46XG4gIHdoaWxlIChpIDwgbikge1xuXG4gICAgLy8gMS4gTGV0IGMgYmUgdGhlIGNvZGUgdW5pdCBpbiBTIGF0IGluZGV4IGkuXG4gICAgdmFyIGMgPSBzLmNoYXJDb2RlQXQoaSk7XG5cbiAgICAvLyAyLiBEZXBlbmRpbmcgb24gdGhlIHZhbHVlIG9mIGM6XG5cbiAgICAvLyBjIDwgMHhEODAwIG9yIGMgPiAweERGRkZcbiAgICBpZiAoYyA8IDB4RDgwMCB8fCBjID4gMHhERkZGKSB7XG4gICAgICAvLyBBcHBlbmQgdG8gVSB0aGUgVW5pY29kZSBjaGFyYWN0ZXIgd2l0aCBjb2RlIHBvaW50IGMuXG4gICAgICB1LnB1c2goYyk7XG4gICAgfVxuXG4gICAgLy8gMHhEQzAwIOKJpCBjIOKJpCAweERGRkZcbiAgICBlbHNlIGlmICgweERDMDAgPD0gYyAmJiBjIDw9IDB4REZGRikge1xuICAgICAgLy8gQXBwZW5kIHRvIFUgYSBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSLlxuICAgICAgdS5wdXNoKDB4RkZGRCk7XG4gICAgfVxuXG4gICAgLy8gMHhEODAwIOKJpCBjIOKJpCAweERCRkZcbiAgICBlbHNlIGlmICgweEQ4MDAgPD0gYyAmJiBjIDw9IDB4REJGRikge1xuICAgICAgLy8gMS4gSWYgaSA9IG7iiJIxLCB0aGVuIGFwcGVuZCB0byBVIGEgVStGRkZEIFJFUExBQ0VNRU5UXG4gICAgICAvLyBDSEFSQUNURVIuXG4gICAgICBpZiAoaSA9PT0gbiAtIDEpIHtcbiAgICAgICAgdS5wdXNoKDB4RkZGRCk7XG4gICAgICB9XG4gICAgICAvLyAyLiBPdGhlcndpc2UsIGkgPCBu4oiSMTpcbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyAxLiBMZXQgZCBiZSB0aGUgY29kZSB1bml0IGluIFMgYXQgaW5kZXggaSsxLlxuICAgICAgICB2YXIgZCA9IHN0cmluZy5jaGFyQ29kZUF0KGkgKyAxKTtcblxuICAgICAgICAvLyAyLiBJZiAweERDMDAg4omkIGQg4omkIDB4REZGRiwgdGhlbjpcbiAgICAgICAgaWYgKDB4REMwMCA8PSBkICYmIGQgPD0gMHhERkZGKSB7XG4gICAgICAgICAgLy8gMS4gTGV0IGEgYmUgYyAmIDB4M0ZGLlxuICAgICAgICAgIHZhciBhID0gYyAmIDB4M0ZGO1xuXG4gICAgICAgICAgLy8gMi4gTGV0IGIgYmUgZCAmIDB4M0ZGLlxuICAgICAgICAgIHZhciBiID0gZCAmIDB4M0ZGO1xuXG4gICAgICAgICAgLy8gMy4gQXBwZW5kIHRvIFUgdGhlIFVuaWNvZGUgY2hhcmFjdGVyIHdpdGggY29kZSBwb2ludFxuICAgICAgICAgIC8vIDJeMTYrMl4xMCphK2IuXG4gICAgICAgICAgdS5wdXNoKDB4MTAwMDAgKyAoYSA8PCAxMCkgKyBiKTtcblxuICAgICAgICAgIC8vIDQuIFNldCBpIHRvIGkrMS5cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cblxuICAgICAgICAvLyAzLiBPdGhlcndpc2UsIGQgPCAweERDMDAgb3IgZCA+IDB4REZGRi4gQXBwZW5kIHRvIFUgYVxuICAgICAgICAvLyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSLlxuICAgICAgICBlbHNlICB7XG4gICAgICAgICAgdS5wdXNoKDB4RkZGRCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAzLiBTZXQgaSB0byBpKzEuXG4gICAgaSArPSAxO1xuICB9XG5cbiAgLy8gNi4gUmV0dXJuIFUuXG4gIHJldHVybiB1O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7IUFycmF5LjxudW1iZXI+fSBjb2RlX3BvaW50cyBBcnJheSBvZiBjb2RlIHBvaW50cy5cbiAqIEByZXR1cm4ge3N0cmluZ30gc3RyaW5nIFN0cmluZyBvZiBVVEYtMTYgY29kZSB1bml0cy5cbiAqL1xuZnVuY3Rpb24gY29kZVBvaW50c1RvU3RyaW5nKGNvZGVfcG9pbnRzKSB7XG4gIHZhciBzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY29kZV9wb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgY3AgPSBjb2RlX3BvaW50c1tpXTtcbiAgICBpZiAoY3AgPD0gMHhGRkZGKSB7XG4gICAgICBzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY3ApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjcCAtPSAweDEwMDAwO1xuICAgICAgcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKChjcCA+PiAxMCkgKyAweEQ4MDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNwICYgMHgzRkYpICsgMHhEQzAwKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cblxuLy9cbi8vIEltcGxlbWVudGF0aW9uIG9mIEVuY29kaW5nIHNwZWNpZmljYXRpb25cbi8vIGh0dHBzOi8vZW5jb2Rpbmcuc3BlYy53aGF0d2cub3JnL1xuLy9cblxuLy9cbi8vIDMuIFRlcm1pbm9sb2d5XG4vL1xuXG4vKipcbiAqIEVuZC1vZi1zdHJlYW0gaXMgYSBzcGVjaWFsIHRva2VuIHRoYXQgc2lnbmlmaWVzIG5vIG1vcmUgdG9rZW5zXG4gKiBhcmUgaW4gdGhlIHN0cmVhbS5cbiAqIEBjb25zdFxuICovIHZhciBlbmRfb2Zfc3RyZWFtID0gLTE7XG5cbi8qKlxuICogQSBzdHJlYW0gcmVwcmVzZW50cyBhbiBvcmRlcmVkIHNlcXVlbmNlIG9mIHRva2Vucy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7IShBcnJheS48bnVtYmVyPnxVaW50OEFycmF5KX0gdG9rZW5zIEFycmF5IG9mIHRva2VucyB0aGF0IHByb3ZpZGUgdGhlXG4gKiBzdHJlYW0uXG4gKi9cbmZ1bmN0aW9uIFN0cmVhbSh0b2tlbnMpIHtcbiAgLyoqIEB0eXBlIHshQXJyYXkuPG51bWJlcj59ICovXG4gIHRoaXMudG9rZW5zID0gW10uc2xpY2UuY2FsbCh0b2tlbnMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBlbmQtb2Ytc3RyZWFtIGhhcyBiZWVuIGhpdC5cbiAgICovXG4gIGVuZE9mU3RyZWFtOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gIXRoaXMudG9rZW5zLmxlbmd0aDtcbiAgfSxcblxuICAvKipcbiAgICogV2hlbiBhIHRva2VuIGlzIHJlYWQgZnJvbSBhIHN0cmVhbSwgdGhlIGZpcnN0IHRva2VuIGluIHRoZVxuICAgKiBzdHJlYW0gbXVzdCBiZSByZXR1cm5lZCBhbmQgc3Vic2VxdWVudGx5IHJlbW92ZWQsIGFuZFxuICAgKiBlbmQtb2Ytc3RyZWFtIG11c3QgYmUgcmV0dXJuZWQgb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IEdldCB0aGUgbmV4dCB0b2tlbiBmcm9tIHRoZSBzdHJlYW0sIG9yXG4gICAqIGVuZF9vZl9zdHJlYW0uXG4gICAqL1xuICAgcmVhZDogZnVuY3Rpb24oKSB7XG4gICAgaWYgKCF0aGlzLnRva2Vucy5sZW5ndGgpXG4gICAgICByZXR1cm4gZW5kX29mX3N0cmVhbTtcbiAgICAgcmV0dXJuIHRoaXMudG9rZW5zLnNoaWZ0KCk7XG4gICB9LFxuXG4gIC8qKlxuICAgKiBXaGVuIG9uZSBvciBtb3JlIHRva2VucyBhcmUgcHJlcGVuZGVkIHRvIGEgc3RyZWFtLCB0aG9zZSB0b2tlbnNcbiAgICogbXVzdCBiZSBpbnNlcnRlZCwgaW4gZ2l2ZW4gb3JkZXIsIGJlZm9yZSB0aGUgZmlyc3QgdG9rZW4gaW4gdGhlXG4gICAqIHN0cmVhbS5cbiAgICpcbiAgICogQHBhcmFtIHsobnVtYmVyfCFBcnJheS48bnVtYmVyPil9IHRva2VuIFRoZSB0b2tlbihzKSB0byBwcmVwZW5kIHRvIHRoZSBzdHJlYW0uXG4gICAqL1xuICBwcmVwZW5kOiBmdW5jdGlvbih0b2tlbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRva2VuKSkge1xuICAgICAgdmFyIHRva2VucyA9IC8qKkB0eXBlIHshQXJyYXkuPG51bWJlcj59Ki8odG9rZW4pO1xuICAgICAgd2hpbGUgKHRva2Vucy5sZW5ndGgpXG4gICAgICAgIHRoaXMudG9rZW5zLnVuc2hpZnQodG9rZW5zLnBvcCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50b2tlbnMudW5zaGlmdCh0b2tlbik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBXaGVuIG9uZSBvciBtb3JlIHRva2VucyBhcmUgcHVzaGVkIHRvIGEgc3RyZWFtLCB0aG9zZSB0b2tlbnNcbiAgICogbXVzdCBiZSBpbnNlcnRlZCwgaW4gZ2l2ZW4gb3JkZXIsIGFmdGVyIHRoZSBsYXN0IHRva2VuIGluIHRoZVxuICAgKiBzdHJlYW0uXG4gICAqXG4gICAqIEBwYXJhbSB7KG51bWJlcnwhQXJyYXkuPG51bWJlcj4pfSB0b2tlbiBUaGUgdG9rZW5zKHMpIHRvIHByZXBlbmQgdG8gdGhlIHN0cmVhbS5cbiAgICovXG4gIHB1c2g6IGZ1bmN0aW9uKHRva2VuKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodG9rZW4pKSB7XG4gICAgICB2YXIgdG9rZW5zID0gLyoqQHR5cGUgeyFBcnJheS48bnVtYmVyPn0qLyh0b2tlbik7XG4gICAgICB3aGlsZSAodG9rZW5zLmxlbmd0aClcbiAgICAgICAgdGhpcy50b2tlbnMucHVzaCh0b2tlbnMuc2hpZnQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudG9rZW5zLnB1c2godG9rZW4pO1xuICAgIH1cbiAgfVxufTtcblxuLy9cbi8vIDQuIEVuY29kaW5nc1xuLy9cblxuLy8gNC4xIEVuY29kZXJzIGFuZCBkZWNvZGVyc1xuXG4vKiogQGNvbnN0ICovXG52YXIgZmluaXNoZWQgPSAtMTtcblxuLyoqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGZhdGFsIElmIHRydWUsIGRlY29kaW5nIGVycm9ycyByYWlzZSBhbiBleGNlcHRpb24uXG4gKiBAcGFyYW0ge251bWJlcj19IG9wdF9jb2RlX3BvaW50IE92ZXJyaWRlIHRoZSBzdGFuZGFyZCBmYWxsYmFjayBjb2RlIHBvaW50LlxuICogQHJldHVybiB7bnVtYmVyfSBUaGUgY29kZSBwb2ludCB0byBpbnNlcnQgb24gYSBkZWNvZGluZyBlcnJvci5cbiAqL1xuZnVuY3Rpb24gZGVjb2RlckVycm9yKGZhdGFsLCBvcHRfY29kZV9wb2ludCkge1xuICBpZiAoZmF0YWwpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdEZWNvZGVyIGVycm9yJyk7XG4gIHJldHVybiBvcHRfY29kZV9wb2ludCB8fCAweEZGRkQ7XG59XG5cbi8vXG4vLyA3LiBBUElcbi8vXG5cbi8qKiBAY29uc3QgKi8gdmFyIERFRkFVTFRfRU5DT0RJTkcgPSAndXRmLTgnO1xuXG4vLyA3LjEgSW50ZXJmYWNlIFRleHREZWNvZGVyXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge3N0cmluZz19IGVuY29kaW5nIFRoZSBsYWJlbCBvZiB0aGUgZW5jb2Rpbmc7XG4gKiAgICAgZGVmYXVsdHMgdG8gJ3V0Zi04Jy5cbiAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICovXG5mdW5jdGlvbiBUZXh0RGVjb2RlcihlbmNvZGluZywgb3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVGV4dERlY29kZXIpKSB7XG4gICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcihlbmNvZGluZywgb3B0aW9ucyk7XG4gIH1cbiAgZW5jb2RpbmcgPSBlbmNvZGluZyAhPT0gdW5kZWZpbmVkID8gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpIDogREVGQVVMVF9FTkNPRElORztcbiAgaWYgKGVuY29kaW5nICE9PSBERUZBVUxUX0VOQ09ESU5HKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvZGluZyBub3Qgc3VwcG9ydGVkLiBPbmx5IHV0Zi04IGlzIHN1cHBvcnRlZCcpO1xuICB9XG4gIG9wdGlvbnMgPSBUb0RpY3Rpb25hcnkob3B0aW9ucyk7XG5cbiAgLyoqIEBwcml2YXRlIEB0eXBlIHtib29sZWFufSAqL1xuICB0aGlzLl9zdHJlYW1pbmcgPSBmYWxzZTtcbiAgLyoqIEBwcml2YXRlIEB0eXBlIHtib29sZWFufSAqL1xuICB0aGlzLl9CT01zZWVuID0gZmFsc2U7XG4gIC8qKiBAcHJpdmF0ZSBAdHlwZSB7P0RlY29kZXJ9ICovXG4gIHRoaXMuX2RlY29kZXIgPSBudWxsO1xuICAvKiogQHByaXZhdGUgQHR5cGUge2Jvb2xlYW59ICovXG4gIHRoaXMuX2ZhdGFsID0gQm9vbGVhbihvcHRpb25zWydmYXRhbCddKTtcbiAgLyoqIEBwcml2YXRlIEB0eXBlIHtib29sZWFufSAqL1xuICB0aGlzLl9pZ25vcmVCT00gPSBCb29sZWFuKG9wdGlvbnNbJ2lnbm9yZUJPTSddKTtcblxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2VuY29kaW5nJywge3ZhbHVlOiAndXRmLTgnfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnZmF0YWwnLCB7dmFsdWU6IHRoaXMuX2ZhdGFsfSk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnaWdub3JlQk9NJywge3ZhbHVlOiB0aGlzLl9pZ25vcmVCT019KTtcbn1cblxuVGV4dERlY29kZXIucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtBcnJheUJ1ZmZlclZpZXc9fSBpbnB1dCBUaGUgYnVmZmVyIG9mIGJ5dGVzIHRvIGRlY29kZS5cbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zXG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGRlY29kZWQgc3RyaW5nLlxuICAgKi9cbiAgZGVjb2RlOiBmdW5jdGlvbiBkZWNvZGUoaW5wdXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgYnl0ZXM7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ29iamVjdCcgJiYgaW5wdXQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShpbnB1dCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdvYmplY3QnICYmICdidWZmZXInIGluIGlucHV0ICYmXG4gICAgICAgICAgICAgICBpbnB1dC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgYnl0ZXMgPSBuZXcgVWludDhBcnJheShpbnB1dC5idWZmZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LmJ5dGVPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlucHV0LmJ5dGVMZW5ndGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KDApO1xuICAgIH1cblxuICAgIG9wdGlvbnMgPSBUb0RpY3Rpb25hcnkob3B0aW9ucyk7XG5cbiAgICBpZiAoIXRoaXMuX3N0cmVhbWluZykge1xuICAgICAgdGhpcy5fZGVjb2RlciA9IG5ldyBVVEY4RGVjb2Rlcih7ZmF0YWw6IHRoaXMuX2ZhdGFsfSk7XG4gICAgICB0aGlzLl9CT01zZWVuID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX3N0cmVhbWluZyA9IEJvb2xlYW4ob3B0aW9uc1snc3RyZWFtJ10pO1xuXG4gICAgdmFyIGlucHV0X3N0cmVhbSA9IG5ldyBTdHJlYW0oYnl0ZXMpO1xuXG4gICAgdmFyIGNvZGVfcG9pbnRzID0gW107XG5cbiAgICAvKiogQHR5cGUgez8obnVtYmVyfCFBcnJheS48bnVtYmVyPil9ICovXG4gICAgdmFyIHJlc3VsdDtcblxuICAgIHdoaWxlICghaW5wdXRfc3RyZWFtLmVuZE9mU3RyZWFtKCkpIHtcbiAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29kZXIuaGFuZGxlcihpbnB1dF9zdHJlYW0sIGlucHV0X3N0cmVhbS5yZWFkKCkpO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gZmluaXNoZWQpXG4gICAgICAgIGJyZWFrO1xuICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbClcbiAgICAgICAgY29udGludWU7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKVxuICAgICAgICBjb2RlX3BvaW50cy5wdXNoLmFwcGx5KGNvZGVfcG9pbnRzLCAvKipAdHlwZSB7IUFycmF5LjxudW1iZXI+fSovKHJlc3VsdCkpO1xuICAgICAgZWxzZVxuICAgICAgICBjb2RlX3BvaW50cy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fc3RyZWFtaW5nKSB7XG4gICAgICBkbyB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuX2RlY29kZXIuaGFuZGxlcihpbnB1dF9zdHJlYW0sIGlucHV0X3N0cmVhbS5yZWFkKCkpO1xuICAgICAgICBpZiAocmVzdWx0ID09PSBmaW5pc2hlZClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbClcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KSlcbiAgICAgICAgICBjb2RlX3BvaW50cy5wdXNoLmFwcGx5KGNvZGVfcG9pbnRzLCAvKipAdHlwZSB7IUFycmF5LjxudW1iZXI+fSovKHJlc3VsdCkpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgY29kZV9wb2ludHMucHVzaChyZXN1bHQpO1xuICAgICAgfSB3aGlsZSAoIWlucHV0X3N0cmVhbS5lbmRPZlN0cmVhbSgpKTtcbiAgICAgIHRoaXMuX2RlY29kZXIgPSBudWxsO1xuICAgIH1cblxuICAgIGlmIChjb2RlX3BvaW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIElmIGVuY29kaW5nIGlzIG9uZSBvZiB1dGYtOCwgdXRmLTE2YmUsIGFuZCB1dGYtMTZsZSwgYW5kXG4gICAgICAvLyBpZ25vcmUgQk9NIGZsYWcgYW5kIEJPTSBzZWVuIGZsYWcgYXJlIHVuc2V0LCBydW4gdGhlc2VcbiAgICAgIC8vIHN1YnN1YnN0ZXBzOlxuICAgICAgaWYgKFsndXRmLTgnXS5pbmRleE9mKHRoaXMuZW5jb2RpbmcpICE9PSAtMSAmJlxuICAgICAgICAgICF0aGlzLl9pZ25vcmVCT00gJiYgIXRoaXMuX0JPTXNlZW4pIHtcbiAgICAgICAgLy8gSWYgdG9rZW4gaXMgVStGRUZGLCBzZXQgQk9NIHNlZW4gZmxhZy5cbiAgICAgICAgaWYgKGNvZGVfcG9pbnRzWzBdID09PSAweEZFRkYpIHtcbiAgICAgICAgICB0aGlzLl9CT01zZWVuID0gdHJ1ZTtcbiAgICAgICAgICBjb2RlX3BvaW50cy5zaGlmdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSwgaWYgdG9rZW4gaXMgbm90IGVuZC1vZi1zdHJlYW0sIHNldCBCT00gc2VlblxuICAgICAgICAgIC8vIGZsYWcgYW5kIGFwcGVuZCB0b2tlbiB0byBvdXRwdXQuXG4gICAgICAgICAgdGhpcy5fQk9Nc2VlbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29kZVBvaW50c1RvU3RyaW5nKGNvZGVfcG9pbnRzKTtcbiAgfVxufTtcblxuLy8gNy4yIEludGVyZmFjZSBUZXh0RW5jb2RlclxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmc9fSBlbmNvZGluZyBUaGUgbGFiZWwgb2YgdGhlIGVuY29kaW5nO1xuICogICAgIGRlZmF1bHRzIHRvICd1dGYtOCcuXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gVGV4dEVuY29kZXIoZW5jb2RpbmcsIG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFRleHRFbmNvZGVyKSlcbiAgICByZXR1cm4gbmV3IFRleHRFbmNvZGVyKGVuY29kaW5nLCBvcHRpb25zKTtcbiAgZW5jb2RpbmcgPSBlbmNvZGluZyAhPT0gdW5kZWZpbmVkID8gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpIDogREVGQVVMVF9FTkNPRElORztcbiAgaWYgKGVuY29kaW5nICE9PSBERUZBVUxUX0VOQ09ESU5HKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvZGluZyBub3Qgc3VwcG9ydGVkLiBPbmx5IHV0Zi04IGlzIHN1cHBvcnRlZCcpO1xuICB9XG4gIG9wdGlvbnMgPSBUb0RpY3Rpb25hcnkob3B0aW9ucyk7XG5cbiAgLyoqIEBwcml2YXRlIEB0eXBlIHtib29sZWFufSAqL1xuICB0aGlzLl9zdHJlYW1pbmcgPSBmYWxzZTtcbiAgLyoqIEBwcml2YXRlIEB0eXBlIHs/RW5jb2Rlcn0gKi9cbiAgdGhpcy5fZW5jb2RlciA9IG51bGw7XG4gIC8qKiBAcHJpdmF0ZSBAdHlwZSB7e2ZhdGFsOiBib29sZWFufX0gKi9cbiAgdGhpcy5fb3B0aW9ucyA9IHtmYXRhbDogQm9vbGVhbihvcHRpb25zWydmYXRhbCddKX07XG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdlbmNvZGluZycsIHt2YWx1ZTogJ3V0Zi04J30pO1xufVxuXG5UZXh0RW5jb2Rlci5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdF9zdHJpbmcgVGhlIHN0cmluZyB0byBlbmNvZGUuXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9uc1xuICAgKiBAcmV0dXJuIHtVaW50OEFycmF5fSBFbmNvZGVkIGJ5dGVzLCBhcyBhIFVpbnQ4QXJyYXkuXG4gICAqL1xuICBlbmNvZGU6IGZ1bmN0aW9uIGVuY29kZShvcHRfc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgb3B0X3N0cmluZyA9IG9wdF9zdHJpbmcgPyBTdHJpbmcob3B0X3N0cmluZykgOiAnJztcbiAgICBvcHRpb25zID0gVG9EaWN0aW9uYXJ5KG9wdGlvbnMpO1xuXG4gICAgLy8gTk9URTogVGhpcyBvcHRpb24gaXMgbm9uc3RhbmRhcmQuIE5vbmUgb2YgdGhlIGVuY29kaW5nc1xuICAgIC8vIHBlcm1pdHRlZCBmb3IgZW5jb2RpbmcgKGkuZS4gVVRGLTgsIFVURi0xNikgYXJlIHN0YXRlZnVsLFxuICAgIC8vIHNvIHN0cmVhbWluZyBpcyBub3QgbmVjZXNzYXJ5LlxuICAgIGlmICghdGhpcy5fc3RyZWFtaW5nKVxuICAgICAgdGhpcy5fZW5jb2RlciA9IG5ldyBVVEY4RW5jb2Rlcih0aGlzLl9vcHRpb25zKTtcbiAgICB0aGlzLl9zdHJlYW1pbmcgPSBCb29sZWFuKG9wdGlvbnNbJ3N0cmVhbSddKTtcblxuICAgIHZhciBieXRlcyA9IFtdO1xuICAgIHZhciBpbnB1dF9zdHJlYW0gPSBuZXcgU3RyZWFtKHN0cmluZ1RvQ29kZVBvaW50cyhvcHRfc3RyaW5nKSk7XG4gICAgLyoqIEB0eXBlIHs/KG51bWJlcnwhQXJyYXkuPG51bWJlcj4pfSAqL1xuICAgIHZhciByZXN1bHQ7XG4gICAgd2hpbGUgKCFpbnB1dF9zdHJlYW0uZW5kT2ZTdHJlYW0oKSkge1xuICAgICAgcmVzdWx0ID0gdGhpcy5fZW5jb2Rlci5oYW5kbGVyKGlucHV0X3N0cmVhbSwgaW5wdXRfc3RyZWFtLnJlYWQoKSk7XG4gICAgICBpZiAocmVzdWx0ID09PSBmaW5pc2hlZClcbiAgICAgICAgYnJlYWs7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKVxuICAgICAgICBieXRlcy5wdXNoLmFwcGx5KGJ5dGVzLCAvKipAdHlwZSB7IUFycmF5LjxudW1iZXI+fSovKHJlc3VsdCkpO1xuICAgICAgZWxzZVxuICAgICAgICBieXRlcy5wdXNoKHJlc3VsdCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fc3RyZWFtaW5nKSB7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICByZXN1bHQgPSB0aGlzLl9lbmNvZGVyLmhhbmRsZXIoaW5wdXRfc3RyZWFtLCBpbnB1dF9zdHJlYW0ucmVhZCgpKTtcbiAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmluaXNoZWQpXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkpXG4gICAgICAgICAgYnl0ZXMucHVzaC5hcHBseShieXRlcywgLyoqQHR5cGUgeyFBcnJheS48bnVtYmVyPn0qLyhyZXN1bHQpKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ5dGVzLnB1c2gocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VuY29kZXIgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZXMpO1xuICB9XG59O1xuXG4vL1xuLy8gOC4gVGhlIGVuY29kaW5nXG4vL1xuXG4vLyA4LjEgdXRmLThcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtEZWNvZGVyfVxuICogQHBhcmFtIHt7ZmF0YWw6IGJvb2xlYW59fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFVURjhEZWNvZGVyKG9wdGlvbnMpIHtcbiAgdmFyIGZhdGFsID0gb3B0aW9ucy5mYXRhbDtcblxuICAvLyB1dGYtOCdzIGRlY29kZXIncyBoYXMgYW4gYXNzb2NpYXRlZCB1dGYtOCBjb2RlIHBvaW50LCB1dGYtOFxuICAvLyBieXRlcyBzZWVuLCBhbmQgdXRmLTggYnl0ZXMgbmVlZGVkIChhbGwgaW5pdGlhbGx5IDApLCBhIHV0Zi04XG4gIC8vIGxvd2VyIGJvdW5kYXJ5IChpbml0aWFsbHkgMHg4MCksIGFuZCBhIHV0Zi04IHVwcGVyIGJvdW5kYXJ5XG4gIC8vIChpbml0aWFsbHkgMHhCRikuXG4gIHZhciAvKiogQHR5cGUge251bWJlcn0gKi8gdXRmOF9jb2RlX3BvaW50ID0gMCxcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyB1dGY4X2J5dGVzX3NlZW4gPSAwLFxuICAgICAgLyoqIEB0eXBlIHtudW1iZXJ9ICovIHV0ZjhfYnl0ZXNfbmVlZGVkID0gMCxcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyB1dGY4X2xvd2VyX2JvdW5kYXJ5ID0gMHg4MCxcbiAgICAgIC8qKiBAdHlwZSB7bnVtYmVyfSAqLyB1dGY4X3VwcGVyX2JvdW5kYXJ5ID0gMHhCRjtcblxuICAvKipcbiAgICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbSBUaGUgc3RyZWFtIG9mIGJ5dGVzIGJlaW5nIGRlY29kZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRlIFRoZSBuZXh0IGJ5dGUgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIEByZXR1cm4gez8obnVtYmVyfCFBcnJheS48bnVtYmVyPil9IFRoZSBuZXh0IGNvZGUgcG9pbnQocylcbiAgICogICAgIGRlY29kZWQsIG9yIG51bGwgaWYgbm90IGVub3VnaCBkYXRhIGV4aXN0cyBpbiB0aGUgaW5wdXRcbiAgICogICAgIHN0cmVhbSB0byBkZWNvZGUgYSBjb21wbGV0ZSBjb2RlIHBvaW50LlxuICAgKi9cbiAgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24oc3RyZWFtLCBiaXRlKSB7XG4gICAgLy8gMS4gSWYgYnl0ZSBpcyBlbmQtb2Ytc3RyZWFtIGFuZCB1dGYtOCBieXRlcyBuZWVkZWQgaXMgbm90IDAsXG4gICAgLy8gc2V0IHV0Zi04IGJ5dGVzIG5lZWRlZCB0byAwIGFuZCByZXR1cm4gZXJyb3IuXG4gICAgaWYgKGJpdGUgPT09IGVuZF9vZl9zdHJlYW0gJiYgdXRmOF9ieXRlc19uZWVkZWQgIT09IDApIHtcbiAgICAgIHV0ZjhfYnl0ZXNfbmVlZGVkID0gMDtcbiAgICAgIHJldHVybiBkZWNvZGVyRXJyb3IoZmF0YWwpO1xuICAgIH1cblxuICAgIC8vIDIuIElmIGJ5dGUgaXMgZW5kLW9mLXN0cmVhbSwgcmV0dXJuIGZpbmlzaGVkLlxuICAgIGlmIChiaXRlID09PSBlbmRfb2Zfc3RyZWFtKVxuICAgICAgcmV0dXJuIGZpbmlzaGVkO1xuXG4gICAgLy8gMy4gSWYgdXRmLTggYnl0ZXMgbmVlZGVkIGlzIDAsIGJhc2VkIG9uIGJ5dGU6XG4gICAgaWYgKHV0ZjhfYnl0ZXNfbmVlZGVkID09PSAwKSB7XG5cbiAgICAgIC8vIDB4MDAgdG8gMHg3RlxuICAgICAgaWYgKGluUmFuZ2UoYml0ZSwgMHgwMCwgMHg3RikpIHtcbiAgICAgICAgLy8gUmV0dXJuIGEgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSBpcyBieXRlLlxuICAgICAgICByZXR1cm4gYml0ZTtcbiAgICAgIH1cblxuICAgICAgLy8gMHhDMiB0byAweERGXG4gICAgICBpZiAoaW5SYW5nZShiaXRlLCAweEMyLCAweERGKSkge1xuICAgICAgICAvLyBTZXQgdXRmLTggYnl0ZXMgbmVlZGVkIHRvIDEgYW5kIHV0Zi04IGNvZGUgcG9pbnQgdG8gYnl0ZVxuICAgICAgICAvLyDiiJIgMHhDMC5cbiAgICAgICAgdXRmOF9ieXRlc19uZWVkZWQgPSAxO1xuICAgICAgICB1dGY4X2NvZGVfcG9pbnQgPSBiaXRlIC0gMHhDMDtcbiAgICAgIH1cblxuICAgICAgLy8gMHhFMCB0byAweEVGXG4gICAgICBlbHNlIGlmIChpblJhbmdlKGJpdGUsIDB4RTAsIDB4RUYpKSB7XG4gICAgICAgIC8vIDEuIElmIGJ5dGUgaXMgMHhFMCwgc2V0IHV0Zi04IGxvd2VyIGJvdW5kYXJ5IHRvIDB4QTAuXG4gICAgICAgIGlmIChiaXRlID09PSAweEUwKVxuICAgICAgICAgIHV0ZjhfbG93ZXJfYm91bmRhcnkgPSAweEEwO1xuICAgICAgICAvLyAyLiBJZiBieXRlIGlzIDB4RUQsIHNldCB1dGYtOCB1cHBlciBib3VuZGFyeSB0byAweDlGLlxuICAgICAgICBpZiAoYml0ZSA9PT0gMHhFRClcbiAgICAgICAgICB1dGY4X3VwcGVyX2JvdW5kYXJ5ID0gMHg5RjtcbiAgICAgICAgLy8gMy4gU2V0IHV0Zi04IGJ5dGVzIG5lZWRlZCB0byAyIGFuZCB1dGYtOCBjb2RlIHBvaW50IHRvXG4gICAgICAgIC8vIGJ5dGUg4oiSIDB4RTAuXG4gICAgICAgIHV0ZjhfYnl0ZXNfbmVlZGVkID0gMjtcbiAgICAgICAgdXRmOF9jb2RlX3BvaW50ID0gYml0ZSAtIDB4RTA7XG4gICAgICB9XG5cbiAgICAgIC8vIDB4RjAgdG8gMHhGNFxuICAgICAgZWxzZSBpZiAoaW5SYW5nZShiaXRlLCAweEYwLCAweEY0KSkge1xuICAgICAgICAvLyAxLiBJZiBieXRlIGlzIDB4RjAsIHNldCB1dGYtOCBsb3dlciBib3VuZGFyeSB0byAweDkwLlxuICAgICAgICBpZiAoYml0ZSA9PT0gMHhGMClcbiAgICAgICAgICB1dGY4X2xvd2VyX2JvdW5kYXJ5ID0gMHg5MDtcbiAgICAgICAgLy8gMi4gSWYgYnl0ZSBpcyAweEY0LCBzZXQgdXRmLTggdXBwZXIgYm91bmRhcnkgdG8gMHg4Ri5cbiAgICAgICAgaWYgKGJpdGUgPT09IDB4RjQpXG4gICAgICAgICAgdXRmOF91cHBlcl9ib3VuZGFyeSA9IDB4OEY7XG4gICAgICAgIC8vIDMuIFNldCB1dGYtOCBieXRlcyBuZWVkZWQgdG8gMyBhbmQgdXRmLTggY29kZSBwb2ludCB0b1xuICAgICAgICAvLyBieXRlIOKIkiAweEYwLlxuICAgICAgICB1dGY4X2J5dGVzX25lZWRlZCA9IDM7XG4gICAgICAgIHV0ZjhfY29kZV9wb2ludCA9IGJpdGUgLSAweEYwO1xuICAgICAgfVxuXG4gICAgICAvLyBPdGhlcndpc2VcbiAgICAgIGVsc2Uge1xuICAgICAgICAvLyBSZXR1cm4gZXJyb3IuXG4gICAgICAgIHJldHVybiBkZWNvZGVyRXJyb3IoZmF0YWwpO1xuICAgICAgfVxuXG4gICAgICAvLyBUaGVuIChieXRlIGlzIGluIHRoZSByYW5nZSAweEMyIHRvIDB4RjQpIHNldCB1dGYtOCBjb2RlXG4gICAgICAvLyBwb2ludCB0byB1dGYtOCBjb2RlIHBvaW50IDw8ICg2IMOXIHV0Zi04IGJ5dGVzIG5lZWRlZCkgYW5kXG4gICAgICAvLyByZXR1cm4gY29udGludWUuXG4gICAgICB1dGY4X2NvZGVfcG9pbnQgPSB1dGY4X2NvZGVfcG9pbnQgPDwgKDYgKiB1dGY4X2J5dGVzX25lZWRlZCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvLyA0LiBJZiBieXRlIGlzIG5vdCBpbiB0aGUgcmFuZ2UgdXRmLTggbG93ZXIgYm91bmRhcnkgdG8gdXRmLThcbiAgICAvLyB1cHBlciBib3VuZGFyeSwgcnVuIHRoZXNlIHN1YnN0ZXBzOlxuICAgIGlmICghaW5SYW5nZShiaXRlLCB1dGY4X2xvd2VyX2JvdW5kYXJ5LCB1dGY4X3VwcGVyX2JvdW5kYXJ5KSkge1xuXG4gICAgICAvLyAxLiBTZXQgdXRmLTggY29kZSBwb2ludCwgdXRmLTggYnl0ZXMgbmVlZGVkLCBhbmQgdXRmLThcbiAgICAgIC8vIGJ5dGVzIHNlZW4gdG8gMCwgc2V0IHV0Zi04IGxvd2VyIGJvdW5kYXJ5IHRvIDB4ODAsIGFuZCBzZXRcbiAgICAgIC8vIHV0Zi04IHVwcGVyIGJvdW5kYXJ5IHRvIDB4QkYuXG4gICAgICB1dGY4X2NvZGVfcG9pbnQgPSB1dGY4X2J5dGVzX25lZWRlZCA9IHV0ZjhfYnl0ZXNfc2VlbiA9IDA7XG4gICAgICB1dGY4X2xvd2VyX2JvdW5kYXJ5ID0gMHg4MDtcbiAgICAgIHV0ZjhfdXBwZXJfYm91bmRhcnkgPSAweEJGO1xuXG4gICAgICAvLyAyLiBQcmVwZW5kIGJ5dGUgdG8gc3RyZWFtLlxuICAgICAgc3RyZWFtLnByZXBlbmQoYml0ZSk7XG5cbiAgICAgIC8vIDMuIFJldHVybiBlcnJvci5cbiAgICAgIHJldHVybiBkZWNvZGVyRXJyb3IoZmF0YWwpO1xuICAgIH1cblxuICAgIC8vIDUuIFNldCB1dGYtOCBsb3dlciBib3VuZGFyeSB0byAweDgwIGFuZCB1dGYtOCB1cHBlciBib3VuZGFyeVxuICAgIC8vIHRvIDB4QkYuXG4gICAgdXRmOF9sb3dlcl9ib3VuZGFyeSA9IDB4ODA7XG4gICAgdXRmOF91cHBlcl9ib3VuZGFyeSA9IDB4QkY7XG5cbiAgICAvLyA2LiBJbmNyZWFzZSB1dGYtOCBieXRlcyBzZWVuIGJ5IG9uZSBhbmQgc2V0IHV0Zi04IGNvZGUgcG9pbnRcbiAgICAvLyB0byB1dGYtOCBjb2RlIHBvaW50ICsgKGJ5dGUg4oiSIDB4ODApIDw8ICg2IMOXICh1dGYtOCBieXRlc1xuICAgIC8vIG5lZWRlZCDiiJIgdXRmLTggYnl0ZXMgc2VlbikpLlxuICAgIHV0ZjhfYnl0ZXNfc2VlbiArPSAxO1xuICAgIHV0ZjhfY29kZV9wb2ludCArPSAoYml0ZSAtIDB4ODApIDw8ICg2ICogKHV0ZjhfYnl0ZXNfbmVlZGVkIC0gdXRmOF9ieXRlc19zZWVuKSk7XG5cbiAgICAvLyA3LiBJZiB1dGYtOCBieXRlcyBzZWVuIGlzIG5vdCBlcXVhbCB0byB1dGYtOCBieXRlcyBuZWVkZWQsXG4gICAgLy8gY29udGludWUuXG4gICAgaWYgKHV0ZjhfYnl0ZXNfc2VlbiAhPT0gdXRmOF9ieXRlc19uZWVkZWQpXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIC8vIDguIExldCBjb2RlIHBvaW50IGJlIHV0Zi04IGNvZGUgcG9pbnQuXG4gICAgdmFyIGNvZGVfcG9pbnQgPSB1dGY4X2NvZGVfcG9pbnQ7XG5cbiAgICAvLyA5LiBTZXQgdXRmLTggY29kZSBwb2ludCwgdXRmLTggYnl0ZXMgbmVlZGVkLCBhbmQgdXRmLTggYnl0ZXNcbiAgICAvLyBzZWVuIHRvIDAuXG4gICAgdXRmOF9jb2RlX3BvaW50ID0gdXRmOF9ieXRlc19uZWVkZWQgPSB1dGY4X2J5dGVzX3NlZW4gPSAwO1xuXG4gICAgLy8gMTAuIFJldHVybiBhIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgaXMgY29kZSBwb2ludC5cbiAgICByZXR1cm4gY29kZV9wb2ludDtcbiAgfTtcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBpbXBsZW1lbnRzIHtFbmNvZGVyfVxuICogQHBhcmFtIHt7ZmF0YWw6IGJvb2xlYW59fSBvcHRpb25zXG4gKi9cbmZ1bmN0aW9uIFVURjhFbmNvZGVyKG9wdGlvbnMpIHtcbiAgdmFyIGZhdGFsID0gb3B0aW9ucy5mYXRhbDtcbiAgLyoqXG4gICAqIEBwYXJhbSB7U3RyZWFtfSBzdHJlYW0gSW5wdXQgc3RyZWFtLlxuICAgKiBAcGFyYW0ge251bWJlcn0gY29kZV9wb2ludCBOZXh0IGNvZGUgcG9pbnQgcmVhZCBmcm9tIHRoZSBzdHJlYW0uXG4gICAqIEByZXR1cm4geyhudW1iZXJ8IUFycmF5LjxudW1iZXI+KX0gQnl0ZShzKSB0byBlbWl0LlxuICAgKi9cbiAgdGhpcy5oYW5kbGVyID0gZnVuY3Rpb24oc3RyZWFtLCBjb2RlX3BvaW50KSB7XG4gICAgLy8gMS4gSWYgY29kZSBwb2ludCBpcyBlbmQtb2Ytc3RyZWFtLCByZXR1cm4gZmluaXNoZWQuXG4gICAgaWYgKGNvZGVfcG9pbnQgPT09IGVuZF9vZl9zdHJlYW0pXG4gICAgICByZXR1cm4gZmluaXNoZWQ7XG5cbiAgICAvLyAyLiBJZiBjb2RlIHBvaW50IGlzIGluIHRoZSByYW5nZSBVKzAwMDAgdG8gVSswMDdGLCByZXR1cm4gYVxuICAgIC8vIGJ5dGUgd2hvc2UgdmFsdWUgaXMgY29kZSBwb2ludC5cbiAgICBpZiAoaW5SYW5nZShjb2RlX3BvaW50LCAweDAwMDAsIDB4MDA3ZikpXG4gICAgICByZXR1cm4gY29kZV9wb2ludDtcblxuICAgIC8vIDMuIFNldCBjb3VudCBhbmQgb2Zmc2V0IGJhc2VkIG9uIHRoZSByYW5nZSBjb2RlIHBvaW50IGlzIGluOlxuICAgIHZhciBjb3VudCwgb2Zmc2V0O1xuICAgIC8vIFUrMDA4MCB0byBVKzA3RkY6ICAgIDEgYW5kIDB4QzBcbiAgICBpZiAoaW5SYW5nZShjb2RlX3BvaW50LCAweDAwODAsIDB4MDdGRikpIHtcbiAgICAgIGNvdW50ID0gMTtcbiAgICAgIG9mZnNldCA9IDB4QzA7XG4gICAgfVxuICAgIC8vIFUrMDgwMCB0byBVK0ZGRkY6ICAgIDIgYW5kIDB4RTBcbiAgICBlbHNlIGlmIChpblJhbmdlKGNvZGVfcG9pbnQsIDB4MDgwMCwgMHhGRkZGKSkge1xuICAgICAgY291bnQgPSAyO1xuICAgICAgb2Zmc2V0ID0gMHhFMDtcbiAgICB9XG4gICAgLy8gVSsxMDAwMCB0byBVKzEwRkZGRjogMyBhbmQgMHhGMFxuICAgIGVsc2UgaWYgKGluUmFuZ2UoY29kZV9wb2ludCwgMHgxMDAwMCwgMHgxMEZGRkYpKSB7XG4gICAgICBjb3VudCA9IDM7XG4gICAgICBvZmZzZXQgPSAweEYwO1xuICAgIH1cblxuICAgIC8vIDQuTGV0IGJ5dGVzIGJlIGEgYnl0ZSBzZXF1ZW5jZSB3aG9zZSBmaXJzdCBieXRlIGlzIChjb2RlXG4gICAgLy8gcG9pbnQgPj4gKDYgw5cgY291bnQpKSArIG9mZnNldC5cbiAgICB2YXIgYnl0ZXMgPSBbKGNvZGVfcG9pbnQgPj4gKDYgKiBjb3VudCkpICsgb2Zmc2V0XTtcblxuICAgIC8vIDUuIFJ1biB0aGVzZSBzdWJzdGVwcyB3aGlsZSBjb3VudCBpcyBncmVhdGVyIHRoYW4gMDpcbiAgICB3aGlsZSAoY291bnQgPiAwKSB7XG5cbiAgICAgIC8vIDEuIFNldCB0ZW1wIHRvIGNvZGUgcG9pbnQgPj4gKDYgw5cgKGNvdW50IOKIkiAxKSkuXG4gICAgICB2YXIgdGVtcCA9IGNvZGVfcG9pbnQgPj4gKDYgKiAoY291bnQgLSAxKSk7XG5cbiAgICAgIC8vIDIuIEFwcGVuZCB0byBieXRlcyAweDgwIHwgKHRlbXAgJiAweDNGKS5cbiAgICAgIGJ5dGVzLnB1c2goMHg4MCB8ICh0ZW1wICYgMHgzRikpO1xuXG4gICAgICAvLyAzLiBEZWNyZWFzZSBjb3VudCBieSBvbmUuXG4gICAgICBjb3VudCAtPSAxO1xuICAgIH1cblxuICAgIC8vIDYuIFJldHVybiBieXRlcyBieXRlcywgaW4gb3JkZXIuXG4gICAgcmV0dXJuIGJ5dGVzO1xuICB9O1xufVxuXG5leHBvcnRzLlRleHRFbmNvZGVyID0gVGV4dEVuY29kZXI7XG5leHBvcnRzLlRleHREZWNvZGVyID0gVGV4dERlY29kZXI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/text-encoding-utf-8/lib/encoding.lib.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NIL: function() { return /* reexport safe */ _nil_js__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; },\n/* harmony export */   parse: function() { return /* reexport safe */ _parse_js__WEBPACK_IMPORTED_MODULE_8__[\"default\"]; },\n/* harmony export */   stringify: function() { return /* reexport safe */ _stringify_js__WEBPACK_IMPORTED_MODULE_7__[\"default\"]; },\n/* harmony export */   v1: function() { return /* reexport safe */ _v1_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; },\n/* harmony export */   v3: function() { return /* reexport safe */ _v3_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; },\n/* harmony export */   v4: function() { return /* reexport safe */ _v4_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; },\n/* harmony export */   v5: function() { return /* reexport safe */ _v5_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; },\n/* harmony export */   validate: function() { return /* reexport safe */ _validate_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; },\n/* harmony export */   version: function() { return /* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; }\n/* harmony export */ });\n/* harmony import */ var _v1_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v1.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v1.js\");\n/* harmony import */ var _v3_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./v3.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v3.js\");\n/* harmony import */ var _v4_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./v4.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\");\n/* harmony import */ var _v5_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./v5.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v5.js\");\n/* harmony import */ var _nil_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./nil.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/nil.js\");\n/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./version.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/version.js\");\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./validate.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/validate.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./stringify.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parse.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/parse.js\");\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0U7QUFDUTtBQUNFO0FBQ0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9pbmRleC5qcz83MTUzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGRlZmF1bHQgYXMgdjEgfSBmcm9tICcuL3YxLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjMgfSBmcm9tICcuL3YzLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjQgfSBmcm9tICcuL3Y0LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdjUgfSBmcm9tICcuL3Y1LmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgTklMIH0gZnJvbSAnLi9uaWwuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyB2ZXJzaW9uIH0gZnJvbSAnLi92ZXJzaW9uLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgdmFsaWRhdGUgfSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcbmV4cG9ydCB7IGRlZmF1bHQgYXMgc3RyaW5naWZ5IH0gZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuZXhwb3J0IHsgZGVmYXVsdCBhcyBwYXJzZSB9IGZyb20gJy4vcGFyc2UuanMnOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/md5.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/md5.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n/*\n * Convert an array of little-endian words to an array of bytes\n */\n\n\nfunction md5ToHexEncodedArray(input) {\n  var output = [];\n  var length32 = input.length * 32;\n  var hexTab = '0123456789abcdef';\n\n  for (var i = 0; i < length32; i += 8) {\n    var x = input[i >> 5] >>> i % 32 & 0xff;\n    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n\n  return output;\n}\n/**\n * Calculate output length with padding and bit length\n */\n\n\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\n\n\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  var a = 1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d = 271733878;\n\n  for (var i = 0; i < x.length; i += 16) {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n\n  return [a, b, c, d];\n}\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\n\n\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n\n  var length8 = input.length * 8;\n  var output = new Uint32Array(getOutputLength(length8));\n\n  for (var i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n\n  return output;\n}\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\n\n\nfunction safeAdd(x, y) {\n  var lsw = (x & 0xffff) + (y & 0xffff);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\n\n\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\n\n\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\n\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\n\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\n\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\n\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (md5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbWQ1LmpzIiwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDs7QUFFbkQ7O0FBRUEsb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsYUFBYTtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtEQUFlLEdBQUciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9tZDUuanM/YzU2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQnJvd3Nlci1jb21wYXRpYmxlIEphdmFTY3JpcHQgTUQ1XG4gKlxuICogTW9kaWZpY2F0aW9uIG9mIEphdmFTY3JpcHQgTUQ1XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYmx1ZWltcC9KYXZhU2NyaXB0LU1ENVxuICpcbiAqIENvcHlyaWdodCAyMDExLCBTZWJhc3RpYW4gVHNjaGFuXG4gKiBodHRwczovL2JsdWVpbXAubmV0XG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlOlxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVRcbiAqXG4gKiBCYXNlZCBvblxuICogQSBKYXZhU2NyaXB0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBSU0EgRGF0YSBTZWN1cml0eSwgSW5jLiBNRDUgTWVzc2FnZVxuICogRGlnZXN0IEFsZ29yaXRobSwgYXMgZGVmaW5lZCBpbiBSRkMgMTMyMS5cbiAqIFZlcnNpb24gMi4yIENvcHlyaWdodCAoQykgUGF1bCBKb2huc3RvbiAxOTk5IC0gMjAwOVxuICogT3RoZXIgY29udHJpYnV0b3JzOiBHcmVnIEhvbHQsIEFuZHJldyBLZXBlcnQsIFlkbmFyLCBMb3N0aW5ldFxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIEJTRCBMaWNlbnNlXG4gKiBTZWUgaHR0cDovL3BhamhvbWUub3JnLnVrL2NyeXB0L21kNSBmb3IgbW9yZSBpbmZvLlxuICovXG5mdW5jdGlvbiBtZDUoYnl0ZXMpIHtcbiAgaWYgKHR5cGVvZiBieXRlcyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgbXNnID0gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGJ5dGVzKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgICBieXRlcyA9IG5ldyBVaW50OEFycmF5KG1zZy5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyArK2kpIHtcbiAgICAgIGJ5dGVzW2ldID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG1kNVRvSGV4RW5jb2RlZEFycmF5KHdvcmRzVG9NZDUoYnl0ZXNUb1dvcmRzKGJ5dGVzKSwgYnl0ZXMubGVuZ3RoICogOCkpO1xufVxuLypcbiAqIENvbnZlcnQgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcyB0byBhbiBhcnJheSBvZiBieXRlc1xuICovXG5cblxuZnVuY3Rpb24gbWQ1VG9IZXhFbmNvZGVkQXJyYXkoaW5wdXQpIHtcbiAgdmFyIG91dHB1dCA9IFtdO1xuICB2YXIgbGVuZ3RoMzIgPSBpbnB1dC5sZW5ndGggKiAzMjtcbiAgdmFyIGhleFRhYiA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDMyOyBpICs9IDgpIHtcbiAgICB2YXIgeCA9IGlucHV0W2kgPj4gNV0gPj4+IGkgJSAzMiAmIDB4ZmY7XG4gICAgdmFyIGhleCA9IHBhcnNlSW50KGhleFRhYi5jaGFyQXQoeCA+Pj4gNCAmIDB4MGYpICsgaGV4VGFiLmNoYXJBdCh4ICYgMHgwZiksIDE2KTtcbiAgICBvdXRwdXQucHVzaChoZXgpO1xuICB9XG5cbiAgcmV0dXJuIG91dHB1dDtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIG91dHB1dCBsZW5ndGggd2l0aCBwYWRkaW5nIGFuZCBiaXQgbGVuZ3RoXG4gKi9cblxuXG5mdW5jdGlvbiBnZXRPdXRwdXRMZW5ndGgoaW5wdXRMZW5ndGg4KSB7XG4gIHJldHVybiAoaW5wdXRMZW5ndGg4ICsgNjQgPj4+IDkgPDwgNCkgKyAxNCArIDE7XG59XG4vKlxuICogQ2FsY3VsYXRlIHRoZSBNRDUgb2YgYW4gYXJyYXkgb2YgbGl0dGxlLWVuZGlhbiB3b3JkcywgYW5kIGEgYml0IGxlbmd0aC5cbiAqL1xuXG5cbmZ1bmN0aW9uIHdvcmRzVG9NZDUoeCwgbGVuKSB7XG4gIC8qIGFwcGVuZCBwYWRkaW5nICovXG4gIHhbbGVuID4+IDVdIHw9IDB4ODAgPDwgbGVuICUgMzI7XG4gIHhbZ2V0T3V0cHV0TGVuZ3RoKGxlbikgLSAxXSA9IGxlbjtcbiAgdmFyIGEgPSAxNzMyNTg0MTkzO1xuICB2YXIgYiA9IC0yNzE3MzM4Nzk7XG4gIHZhciBjID0gLTE3MzI1ODQxOTQ7XG4gIHZhciBkID0gMjcxNzMzODc4O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeC5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICB2YXIgb2xkYSA9IGE7XG4gICAgdmFyIG9sZGIgPSBiO1xuICAgIHZhciBvbGRjID0gYztcbiAgICB2YXIgb2xkZCA9IGQ7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaV0sIDcsIC02ODA4NzY5MzYpO1xuICAgIGQgPSBtZDVmZihkLCBhLCBiLCBjLCB4W2kgKyAxXSwgMTIsIC0zODk1NjQ1ODYpO1xuICAgIGMgPSBtZDVmZihjLCBkLCBhLCBiLCB4W2kgKyAyXSwgMTcsIDYwNjEwNTgxOSk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDNdLCAyMiwgLTEwNDQ1MjUzMzApO1xuICAgIGEgPSBtZDVmZihhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNywgLTE3NjQxODg5Nyk7XG4gICAgZCA9IG1kNWZmKGQsIGEsIGIsIGMsIHhbaSArIDVdLCAxMiwgMTIwMDA4MDQyNik7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDZdLCAxNywgLTE0NzMyMzEzNDEpO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyA3XSwgMjIsIC00NTcwNTk4Myk7XG4gICAgYSA9IG1kNWZmKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA3LCAxNzcwMDM1NDE2KTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgOV0sIDEyLCAtMTk1ODQxNDQxNyk7XG4gICAgYyA9IG1kNWZmKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTcsIC00MjA2Myk7XG4gICAgYiA9IG1kNWZmKGIsIGMsIGQsIGEsIHhbaSArIDExXSwgMjIsIC0xOTkwNDA0MTYyKTtcbiAgICBhID0gbWQ1ZmYoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA3LCAxODA0NjAzNjgyKTtcbiAgICBkID0gbWQ1ZmYoZCwgYSwgYiwgYywgeFtpICsgMTNdLCAxMiwgLTQwMzQxMTAxKTtcbiAgICBjID0gbWQ1ZmYoYywgZCwgYSwgYiwgeFtpICsgMTRdLCAxNywgLTE1MDIwMDIyOTApO1xuICAgIGIgPSBtZDVmZihiLCBjLCBkLCBhLCB4W2kgKyAxNV0sIDIyLCAxMjM2NTM1MzI5KTtcbiAgICBhID0gbWQ1Z2coYSwgYiwgYywgZCwgeFtpICsgMV0sIDUsIC0xNjU3OTY1MTApO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyA2XSwgOSwgLTEwNjk1MDE2MzIpO1xuICAgIGMgPSBtZDVnZyhjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE0LCA2NDM3MTc3MTMpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2ldLCAyMCwgLTM3Mzg5NzMwMik7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDVdLCA1LCAtNzAxNTU4NjkxKTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTBdLCA5LCAzODAxNjA4Myk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTQsIC02NjA0NzgzMzUpO1xuICAgIGIgPSBtZDVnZyhiLCBjLCBkLCBhLCB4W2kgKyA0XSwgMjAsIC00MDU1Mzc4NDgpO1xuICAgIGEgPSBtZDVnZyhhLCBiLCBjLCBkLCB4W2kgKyA5XSwgNSwgNTY4NDQ2NDM4KTtcbiAgICBkID0gbWQ1Z2coZCwgYSwgYiwgYywgeFtpICsgMTRdLCA5LCAtMTAxOTgwMzY5MCk7XG4gICAgYyA9IG1kNWdnKGMsIGQsIGEsIGIsIHhbaSArIDNdLCAxNCwgLTE4NzM2Mzk2MSk7XG4gICAgYiA9IG1kNWdnKGIsIGMsIGQsIGEsIHhbaSArIDhdLCAyMCwgMTE2MzUzMTUwMSk7XG4gICAgYSA9IG1kNWdnKGEsIGIsIGMsIGQsIHhbaSArIDEzXSwgNSwgLTE0NDQ2ODE0NjcpO1xuICAgIGQgPSBtZDVnZyhkLCBhLCBiLCBjLCB4W2kgKyAyXSwgOSwgLTUxNDAzNzg0KTtcbiAgICBjID0gbWQ1Z2coYywgZCwgYSwgYiwgeFtpICsgN10sIDE0LCAxNzM1MzI4NDczKTtcbiAgICBiID0gbWQ1Z2coYiwgYywgZCwgYSwgeFtpICsgMTJdLCAyMCwgLTE5MjY2MDc3MzQpO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyA1XSwgNCwgLTM3ODU1OCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaSArIDhdLCAxMSwgLTIwMjI1NzQ0NjMpO1xuICAgIGMgPSBtZDVoaChjLCBkLCBhLCBiLCB4W2kgKyAxMV0sIDE2LCAxODM5MDMwNTYyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTRdLCAyMywgLTM1MzA5NTU2KTtcbiAgICBhID0gbWQ1aGgoYSwgYiwgYywgZCwgeFtpICsgMV0sIDQsIC0xNTMwOTkyMDYwKTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgNF0sIDExLCAxMjcyODkzMzUzKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgN10sIDE2LCAtMTU1NDk3NjMyKTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgMTBdLCAyMywgLTEwOTQ3MzA2NDApO1xuICAgIGEgPSBtZDVoaChhLCBiLCBjLCBkLCB4W2kgKyAxM10sIDQsIDY4MTI3OTE3NCk7XG4gICAgZCA9IG1kNWhoKGQsIGEsIGIsIGMsIHhbaV0sIDExLCAtMzU4NTM3MjIyKTtcbiAgICBjID0gbWQ1aGgoYywgZCwgYSwgYiwgeFtpICsgM10sIDE2LCAtNzIyNTIxOTc5KTtcbiAgICBiID0gbWQ1aGgoYiwgYywgZCwgYSwgeFtpICsgNl0sIDIzLCA3NjAyOTE4OSk7XG4gICAgYSA9IG1kNWhoKGEsIGIsIGMsIGQsIHhbaSArIDldLCA0LCAtNjQwMzY0NDg3KTtcbiAgICBkID0gbWQ1aGgoZCwgYSwgYiwgYywgeFtpICsgMTJdLCAxMSwgLTQyMTgxNTgzNSk7XG4gICAgYyA9IG1kNWhoKGMsIGQsIGEsIGIsIHhbaSArIDE1XSwgMTYsIDUzMDc0MjUyMCk7XG4gICAgYiA9IG1kNWhoKGIsIGMsIGQsIGEsIHhbaSArIDJdLCAyMywgLTk5NTMzODY1MSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaV0sIDYsIC0xOTg2MzA4NDQpO1xuICAgIGQgPSBtZDVpaShkLCBhLCBiLCBjLCB4W2kgKyA3XSwgMTAsIDExMjY4OTE0MTUpO1xuICAgIGMgPSBtZDVpaShjLCBkLCBhLCBiLCB4W2kgKyAxNF0sIDE1LCAtMTQxNjM1NDkwNSk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDVdLCAyMSwgLTU3NDM0MDU1KTtcbiAgICBhID0gbWQ1aWkoYSwgYiwgYywgZCwgeFtpICsgMTJdLCA2LCAxNzAwNDg1NTcxKTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgM10sIDEwLCAtMTg5NDk4NjYwNik7XG4gICAgYyA9IG1kNWlpKGMsIGQsIGEsIGIsIHhbaSArIDEwXSwgMTUsIC0xMDUxNTIzKTtcbiAgICBiID0gbWQ1aWkoYiwgYywgZCwgYSwgeFtpICsgMV0sIDIxLCAtMjA1NDkyMjc5OSk7XG4gICAgYSA9IG1kNWlpKGEsIGIsIGMsIGQsIHhbaSArIDhdLCA2LCAxODczMzEzMzU5KTtcbiAgICBkID0gbWQ1aWkoZCwgYSwgYiwgYywgeFtpICsgMTVdLCAxMCwgLTMwNjExNzQ0KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgNl0sIDE1LCAtMTU2MDE5ODM4MCk7XG4gICAgYiA9IG1kNWlpKGIsIGMsIGQsIGEsIHhbaSArIDEzXSwgMjEsIDEzMDkxNTE2NDkpO1xuICAgIGEgPSBtZDVpaShhLCBiLCBjLCBkLCB4W2kgKyA0XSwgNiwgLTE0NTUyMzA3MCk7XG4gICAgZCA9IG1kNWlpKGQsIGEsIGIsIGMsIHhbaSArIDExXSwgMTAsIC0xMTIwMjEwMzc5KTtcbiAgICBjID0gbWQ1aWkoYywgZCwgYSwgYiwgeFtpICsgMl0sIDE1LCA3MTg3ODcyNTkpO1xuICAgIGIgPSBtZDVpaShiLCBjLCBkLCBhLCB4W2kgKyA5XSwgMjEsIC0zNDM0ODU1NTEpO1xuICAgIGEgPSBzYWZlQWRkKGEsIG9sZGEpO1xuICAgIGIgPSBzYWZlQWRkKGIsIG9sZGIpO1xuICAgIGMgPSBzYWZlQWRkKGMsIG9sZGMpO1xuICAgIGQgPSBzYWZlQWRkKGQsIG9sZGQpO1xuICB9XG5cbiAgcmV0dXJuIFthLCBiLCBjLCBkXTtcbn1cbi8qXG4gKiBDb252ZXJ0IGFuIGFycmF5IGJ5dGVzIHRvIGFuIGFycmF5IG9mIGxpdHRsZS1lbmRpYW4gd29yZHNcbiAqIENoYXJhY3RlcnMgPjI1NSBoYXZlIHRoZWlyIGhpZ2gtYnl0ZSBzaWxlbnRseSBpZ25vcmVkLlxuICovXG5cblxuZnVuY3Rpb24gYnl0ZXNUb1dvcmRzKGlucHV0KSB7XG4gIGlmIChpbnB1dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgbGVuZ3RoOCA9IGlucHV0Lmxlbmd0aCAqIDg7XG4gIHZhciBvdXRwdXQgPSBuZXcgVWludDMyQXJyYXkoZ2V0T3V0cHV0TGVuZ3RoKGxlbmd0aDgpKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDg7IGkgKz0gOCkge1xuICAgIG91dHB1dFtpID4+IDVdIHw9IChpbnB1dFtpIC8gOF0gJiAweGZmKSA8PCBpICUgMzI7XG4gIH1cblxuICByZXR1cm4gb3V0cHV0O1xufVxuLypcbiAqIEFkZCBpbnRlZ2Vycywgd3JhcHBpbmcgYXQgMl4zMi4gVGhpcyB1c2VzIDE2LWJpdCBvcGVyYXRpb25zIGludGVybmFsbHlcbiAqIHRvIHdvcmsgYXJvdW5kIGJ1Z3MgaW4gc29tZSBKUyBpbnRlcnByZXRlcnMuXG4gKi9cblxuXG5mdW5jdGlvbiBzYWZlQWRkKHgsIHkpIHtcbiAgdmFyIGxzdyA9ICh4ICYgMHhmZmZmKSArICh5ICYgMHhmZmZmKTtcbiAgdmFyIG1zdyA9ICh4ID4+IDE2KSArICh5ID4+IDE2KSArIChsc3cgPj4gMTYpO1xuICByZXR1cm4gbXN3IDw8IDE2IHwgbHN3ICYgMHhmZmZmO1xufVxuLypcbiAqIEJpdHdpc2Ugcm90YXRlIGEgMzItYml0IG51bWJlciB0byB0aGUgbGVmdC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGJpdFJvdGF0ZUxlZnQobnVtLCBjbnQpIHtcbiAgcmV0dXJuIG51bSA8PCBjbnQgfCBudW0gPj4+IDMyIC0gY250O1xufVxuLypcbiAqIFRoZXNlIGZ1bmN0aW9ucyBpbXBsZW1lbnQgdGhlIGZvdXIgYmFzaWMgb3BlcmF0aW9ucyB0aGUgYWxnb3JpdGhtIHVzZXMuXG4gKi9cblxuXG5mdW5jdGlvbiBtZDVjbW4ocSwgYSwgYiwgeCwgcywgdCkge1xuICByZXR1cm4gc2FmZUFkZChiaXRSb3RhdGVMZWZ0KHNhZmVBZGQoc2FmZUFkZChhLCBxKSwgc2FmZUFkZCh4LCB0KSksIHMpLCBiKTtcbn1cblxuZnVuY3Rpb24gbWQ1ZmYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgJiBjIHwgfmIgJiBkLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1Z2coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgJiBkIHwgYyAmIH5kLCBhLCBiLCB4LCBzLCB0KTtcbn1cblxuZnVuY3Rpb24gbWQ1aGgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuICByZXR1cm4gbWQ1Y21uKGIgXiBjIF4gZCwgYSwgYiwgeCwgcywgdCk7XG59XG5cbmZ1bmN0aW9uIG1kNWlpKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcbiAgcmV0dXJuIG1kNWNtbihjIF4gKGIgfCB+ZCksIGEsIGIsIHgsIHMsIHQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBtZDU7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/md5.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/nil.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/nil.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = ('00000000-0000-0000-0000-000000000000');//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvbmlsLmpzIiwibWFwcGluZ3MiOiI7QUFBQSwrREFBZSxzQ0FBc0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9uaWwuanM/M2ZlNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCAnMDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwJzsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/nil.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/parse.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/parse.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/validate.js\");\n\n\nfunction parse(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  var v;\n  var arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (parse);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcGFyc2UuanMiLCJtYXBwaW5ncyI6Ijs7QUFBcUM7O0FBRXJDO0FBQ0EsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQSxxQkFBcUI7O0FBRXJCO0FBQ0EscUJBQXFCOztBQUVyQjtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLCtEQUFlLEtBQUsiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9wYXJzZS5qcz8wNWE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2YWxpZGF0ZSBmcm9tICcuL3ZhbGlkYXRlLmpzJztcblxuZnVuY3Rpb24gcGFyc2UodXVpZCkge1xuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdJbnZhbGlkIFVVSUQnKTtcbiAgfVxuXG4gIHZhciB2O1xuICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBQYXJzZSAjIyMjIyMjIy0uLi4uLS4uLi4tLi4uLi0uLi4uLi4uLi4uLi5cblxuICBhcnJbMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMCwgOCksIDE2KSkgPj4+IDI0O1xuICBhcnJbMV0gPSB2ID4+PiAxNiAmIDB4ZmY7XG4gIGFyclsyXSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbM10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tIyMjIy0uLi4uLS4uLi4tLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzRdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDksIDEzKSwgMTYpKSA+Pj4gODtcbiAgYXJyWzVdID0gdiAmIDB4ZmY7IC8vIFBhcnNlIC4uLi4uLi4uLS4uLi4tIyMjIy0uLi4uLS4uLi4uLi4uLi4uLlxuXG4gIGFycls2XSA9ICh2ID0gcGFyc2VJbnQodXVpZC5zbGljZSgxNCwgMTgpLCAxNikpID4+PiA4O1xuICBhcnJbN10gPSB2ICYgMHhmZjsgLy8gUGFyc2UgLi4uLi4uLi4tLi4uLi0uLi4uLSMjIyMtLi4uLi4uLi4uLi4uXG5cbiAgYXJyWzhdID0gKHYgPSBwYXJzZUludCh1dWlkLnNsaWNlKDE5LCAyMyksIDE2KSkgPj4+IDg7XG4gIGFycls5XSA9IHYgJiAweGZmOyAvLyBQYXJzZSAuLi4uLi4uLi0uLi4uLS4uLi4tLi4uLi0jIyMjIyMjIyMjIyNcbiAgLy8gKFVzZSBcIi9cIiB0byBhdm9pZCAzMi1iaXQgdHJ1bmNhdGlvbiB3aGVuIGJpdC1zaGlmdGluZyBoaWdoLW9yZGVyIGJ5dGVzKVxuXG4gIGFyclsxMF0gPSAodiA9IHBhcnNlSW50KHV1aWQuc2xpY2UoMjQsIDM2KSwgMTYpKSAvIDB4MTAwMDAwMDAwMDAgJiAweGZmO1xuICBhcnJbMTFdID0gdiAvIDB4MTAwMDAwMDAwICYgMHhmZjtcbiAgYXJyWzEyXSA9IHYgPj4+IDI0ICYgMHhmZjtcbiAgYXJyWzEzXSA9IHYgPj4+IDE2ICYgMHhmZjtcbiAgYXJyWzE0XSA9IHYgPj4+IDggJiAweGZmO1xuICBhcnJbMTVdID0gdiAmIDB4ZmY7XG4gIHJldHVybiBhcnI7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBhcnNlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/parse.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/regex.js":
/*!*****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/regex.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcmVnZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWMsRUFBRSxVQUFVLEVBQUUsZUFBZSxFQUFFLGdCQUFnQixFQUFFLFVBQVUsR0FBRyx5Q0FBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9yZWdleC5qcz83Mzc5Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/regex.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/rng.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/rng.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ rng; }\n/* harmony export */ });\n// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nfunction rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation. Also,\n    // find the complete implementation of crypto (msCrypto) on IE11.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== 'undefined' && typeof msCrypto.getRandomValues === 'function' && msCrypto.getRandomValues.bind(msCrypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvcm5nLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2U7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci9ybmcuanM/YWYzNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiBJbiB0aGUgYnJvd3NlciB3ZSB0aGVyZWZvcmVcbi8vIHJlcXVpcmUgdGhlIGNyeXB0byBBUEkgYW5kIGRvIG5vdCBzdXBwb3J0IGJ1aWx0LWluIGZhbGxiYWNrIHRvIGxvd2VyIHF1YWxpdHkgcmFuZG9tIG51bWJlclxuLy8gZ2VuZXJhdG9ycyAobGlrZSBNYXRoLnJhbmRvbSgpKS5cbnZhciBnZXRSYW5kb21WYWx1ZXM7XG52YXIgcm5kczggPSBuZXcgVWludDhBcnJheSgxNik7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBybmcoKSB7XG4gIC8vIGxhenkgbG9hZCBzbyB0aGF0IGVudmlyb25tZW50cyB0aGF0IG5lZWQgdG8gcG9seWZpbGwgaGF2ZSBhIGNoYW5jZSB0byBkbyBzb1xuICBpZiAoIWdldFJhbmRvbVZhbHVlcykge1xuICAgIC8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0byBpbXBsZW1lbnRhdGlvbi4gQWxzbyxcbiAgICAvLyBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gKG1zQ3J5cHRvKSBvbiBJRTExLlxuICAgIGdldFJhbmRvbVZhbHVlcyA9IHR5cGVvZiBjcnlwdG8gIT09ICd1bmRlZmluZWQnICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKGNyeXB0bykgfHwgdHlwZW9mIG1zQ3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKTtcblxuICAgIGlmICghZ2V0UmFuZG9tVmFsdWVzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NyeXB0by5nZXRSYW5kb21WYWx1ZXMoKSBub3Qgc3VwcG9ydGVkLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkI2dldHJhbmRvbXZhbHVlcy1ub3Qtc3VwcG9ydGVkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/rng.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/sha1.js":
/*!****************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/sha1.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n\n    case 1:\n      return x ^ y ^ z;\n\n    case 2:\n      return x & y ^ x & z ^ y & z;\n\n    case 3:\n      return x ^ y ^ z;\n  }\n}\n\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\n\nfunction sha1(bytes) {\n  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n\n    for (var i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n\n  bytes.push(0x80);\n  var l = bytes.length / 4 + 2;\n  var N = Math.ceil(l / 16);\n  var M = new Array(N);\n\n  for (var _i = 0; _i < N; ++_i) {\n    var arr = new Uint32Array(16);\n\n    for (var j = 0; j < 16; ++j) {\n      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];\n    }\n\n    M[_i] = arr;\n  }\n\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n\n  for (var _i2 = 0; _i2 < N; ++_i2) {\n    var W = new Uint32Array(80);\n\n    for (var t = 0; t < 16; ++t) {\n      W[t] = M[_i2][t];\n    }\n\n    for (var _t = 16; _t < 80; ++_t) {\n      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);\n    }\n\n    var a = H[0];\n    var b = H[1];\n    var c = H[2];\n    var d = H[3];\n    var e = H[4];\n\n    for (var _t2 = 0; _t2 < 80; ++_t2) {\n      var s = Math.floor(_t2 / 20);\n      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (sha1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc2hhMS5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbURBQW1EOztBQUVuRDs7QUFFQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQixRQUFRO0FBQzNCOztBQUVBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLFNBQVM7QUFDN0I7O0FBRUEsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrREFBZSxJQUFJIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc2hhMS5qcz8wZTJkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEFkYXB0ZWQgZnJvbSBDaHJpcyBWZW5lc3MnIFNIQTEgY29kZSBhdFxuLy8gaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9zaGExLmh0bWxcbmZ1bmN0aW9uIGYocywgeCwgeSwgeikge1xuICBzd2l0Y2ggKHMpIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4geCAmIHkgXiB+eCAmIHo7XG5cbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4geCBeIHkgXiB6O1xuXG4gICAgY2FzZSAyOlxuICAgICAgcmV0dXJuIHggJiB5IF4geCAmIHogXiB5ICYgejtcblxuICAgIGNhc2UgMzpcbiAgICAgIHJldHVybiB4IF4geSBeIHo7XG4gIH1cbn1cblxuZnVuY3Rpb24gUk9UTCh4LCBuKSB7XG4gIHJldHVybiB4IDw8IG4gfCB4ID4+PiAzMiAtIG47XG59XG5cbmZ1bmN0aW9uIHNoYTEoYnl0ZXMpIHtcbiAgdmFyIEsgPSBbMHg1YTgyNzk5OSwgMHg2ZWQ5ZWJhMSwgMHg4ZjFiYmNkYywgMHhjYTYyYzFkNl07XG4gIHZhciBIID0gWzB4Njc0NTIzMDEsIDB4ZWZjZGFiODksIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsIDB4YzNkMmUxZjBdO1xuXG4gIGlmICh0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIG1zZyA9IHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChieXRlcykpOyAvLyBVVEY4IGVzY2FwZVxuXG4gICAgYnl0ZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgKytpKSB7XG4gICAgICBieXRlcy5wdXNoKG1zZy5jaGFyQ29kZUF0KGkpKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIUFycmF5LmlzQXJyYXkoYnl0ZXMpKSB7XG4gICAgLy8gQ29udmVydCBBcnJheS1saWtlIHRvIEFycmF5XG4gICAgYnl0ZXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChieXRlcyk7XG4gIH1cblxuICBieXRlcy5wdXNoKDB4ODApO1xuICB2YXIgbCA9IGJ5dGVzLmxlbmd0aCAvIDQgKyAyO1xuICB2YXIgTiA9IE1hdGguY2VpbChsIC8gMTYpO1xuICB2YXIgTSA9IG5ldyBBcnJheShOKTtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgTjsgKytfaSkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDMyQXJyYXkoMTYpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICBhcnJbal0gPSBieXRlc1tfaSAqIDY0ICsgaiAqIDRdIDw8IDI0IHwgYnl0ZXNbX2kgKiA2NCArIGogKiA0ICsgMV0gPDwgMTYgfCBieXRlc1tfaSAqIDY0ICsgaiAqIDQgKyAyXSA8PCA4IHwgYnl0ZXNbX2kgKiA2NCArIGogKiA0ICsgM107XG4gICAgfVxuXG4gICAgTVtfaV0gPSBhcnI7XG4gIH1cblxuICBNW04gLSAxXVsxNF0gPSAoYnl0ZXMubGVuZ3RoIC0gMSkgKiA4IC8gTWF0aC5wb3coMiwgMzIpO1xuICBNW04gLSAxXVsxNF0gPSBNYXRoLmZsb29yKE1bTiAtIDFdWzE0XSk7XG4gIE1bTiAtIDFdWzE1XSA9IChieXRlcy5sZW5ndGggLSAxKSAqIDggJiAweGZmZmZmZmZmO1xuXG4gIGZvciAodmFyIF9pMiA9IDA7IF9pMiA8IE47ICsrX2kyKSB7XG4gICAgdmFyIFcgPSBuZXcgVWludDMyQXJyYXkoODApO1xuXG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCAxNjsgKyt0KSB7XG4gICAgICBXW3RdID0gTVtfaTJdW3RdO1xuICAgIH1cblxuICAgIGZvciAodmFyIF90ID0gMTY7IF90IDwgODA7ICsrX3QpIHtcbiAgICAgIFdbX3RdID0gUk9UTChXW190IC0gM10gXiBXW190IC0gOF0gXiBXW190IC0gMTRdIF4gV1tfdCAtIDE2XSwgMSk7XG4gICAgfVxuXG4gICAgdmFyIGEgPSBIWzBdO1xuICAgIHZhciBiID0gSFsxXTtcbiAgICB2YXIgYyA9IEhbMl07XG4gICAgdmFyIGQgPSBIWzNdO1xuICAgIHZhciBlID0gSFs0XTtcblxuICAgIGZvciAodmFyIF90MiA9IDA7IF90MiA8IDgwOyArK190Mikge1xuICAgICAgdmFyIHMgPSBNYXRoLmZsb29yKF90MiAvIDIwKTtcbiAgICAgIHZhciBUID0gUk9UTChhLCA1KSArIGYocywgYiwgYywgZCkgKyBlICsgS1tzXSArIFdbX3QyXSA+Pj4gMDtcbiAgICAgIGUgPSBkO1xuICAgICAgZCA9IGM7XG4gICAgICBjID0gUk9UTChiLCAzMCkgPj4+IDA7XG4gICAgICBiID0gYTtcbiAgICAgIGEgPSBUO1xuICAgIH1cblxuICAgIEhbMF0gPSBIWzBdICsgYSA+Pj4gMDtcbiAgICBIWzFdID0gSFsxXSArIGIgPj4+IDA7XG4gICAgSFsyXSA9IEhbMl0gKyBjID4+PiAwO1xuICAgIEhbM10gPSBIWzNdICsgZCA+Pj4gMDtcbiAgICBIWzRdID0gSFs0XSArIGUgPj4+IDA7XG4gIH1cblxuICByZXR1cm4gW0hbMF0gPj4gMjQgJiAweGZmLCBIWzBdID4+IDE2ICYgMHhmZiwgSFswXSA+PiA4ICYgMHhmZiwgSFswXSAmIDB4ZmYsIEhbMV0gPj4gMjQgJiAweGZmLCBIWzFdID4+IDE2ICYgMHhmZiwgSFsxXSA+PiA4ICYgMHhmZiwgSFsxXSAmIDB4ZmYsIEhbMl0gPj4gMjQgJiAweGZmLCBIWzJdID4+IDE2ICYgMHhmZiwgSFsyXSA+PiA4ICYgMHhmZiwgSFsyXSAmIDB4ZmYsIEhbM10gPj4gMjQgJiAweGZmLCBIWzNdID4+IDE2ICYgMHhmZiwgSFszXSA+PiA4ICYgMHhmZiwgSFszXSAmIDB4ZmYsIEhbNF0gPj4gMjQgJiAweGZmLCBIWzRdID4+IDE2ICYgMHhmZiwgSFs0XSA+PiA4ICYgMHhmZiwgSFs0XSAmIDB4ZmZdO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzaGExOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/sha1.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/stringify.js":
/*!*********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/stringify.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/validate.js\");\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nvar byteToHex = [];\n\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr) {\n  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  var uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (stringify);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzIiwibWFwcGluZ3MiOiI7O0FBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwZ0JBQTBnQjtBQUMxZ0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTyx3REFBUTtBQUNmO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrREFBZSxTQUFTIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvc3RyaW5naWZ5LmpzP2IxZTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG5cbnZhciBieXRlVG9IZXggPSBbXTtcblxuZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7ICsraSkge1xuICBieXRlVG9IZXgucHVzaCgoaSArIDB4MTAwKS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5KGFycikge1xuICB2YXIgb2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAvLyBOb3RlOiBCZSBjYXJlZnVsIGVkaXRpbmcgdGhpcyBjb2RlISAgSXQncyBiZWVuIHR1bmVkIGZvciBwZXJmb3JtYW5jZVxuICAvLyBhbmQgd29ya3MgaW4gd2F5cyB5b3UgbWF5IG5vdCBleHBlY3QuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQvcHVsbC80MzRcbiAgdmFyIHV1aWQgPSAoYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDFdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgMl1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyAzXV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDRdXSArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgNV1dICsgJy0nICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA2XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDddXSArICctJyArIGJ5dGVUb0hleFthcnJbb2Zmc2V0ICsgOF1dICsgYnl0ZVRvSGV4W2FycltvZmZzZXQgKyA5XV0gKyAnLScgKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEwXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDExXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEyXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDEzXV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE0XV0gKyBieXRlVG9IZXhbYXJyW29mZnNldCArIDE1XV0pLnRvTG93ZXJDYXNlKCk7IC8vIENvbnNpc3RlbmN5IGNoZWNrIGZvciB2YWxpZCBVVUlELiAgSWYgdGhpcyB0aHJvd3MsIGl0J3MgbGlrZWx5IGR1ZSB0byBvbmVcbiAgLy8gb2YgdGhlIGZvbGxvd2luZzpcbiAgLy8gLSBPbmUgb3IgbW9yZSBpbnB1dCBhcnJheSB2YWx1ZXMgZG9uJ3QgbWFwIHRvIGEgaGV4IG9jdGV0IChsZWFkaW5nIHRvXG4gIC8vIFwidW5kZWZpbmVkXCIgaW4gdGhlIHV1aWQpXG4gIC8vIC0gSW52YWxpZCBpbnB1dCB2YWx1ZXMgZm9yIHRoZSBSRkMgYHZlcnNpb25gIG9yIGB2YXJpYW50YCBmaWVsZHNcblxuICBpZiAoIXZhbGlkYXRlKHV1aWQpKSB7XG4gICAgdGhyb3cgVHlwZUVycm9yKCdTdHJpbmdpZmllZCBVVUlEIGlzIGludmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiB1dWlkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBzdHJpbmdpZnk7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/stringify.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v1.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v1.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/stringify.js\");\n\n // **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\n\nvar _nodeId;\n\nvar _clockseq; // Previous uuid creation time\n\n\nvar _lastMSecs = 0;\nvar _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  var i = buf && offset || 0;\n  var b = buf || new Array(16);\n  options = options || {};\n  var node = options.node || _nodeId;\n  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    var seedBytes = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  var msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  var tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (var n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(b);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (v1);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjEuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQTJCO0FBQ1ksQ0FBQztBQUN4QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsZUFBZTs7O0FBR2Y7QUFDQSxvQkFBb0I7O0FBRXBCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCwrQ0FBRzs7QUFFekQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOzs7QUFHQSx3RUFBd0U7QUFDeEU7O0FBRUEsNEVBQTRFOztBQUU1RSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3Qjs7QUFFeEIsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBLHVCQUF1Qjs7QUFFdkIsb0NBQW9DOztBQUVwQyw4QkFBOEI7O0FBRTlCLGtDQUFrQzs7QUFFbEMsNEJBQTRCOztBQUU1QixrQkFBa0IsT0FBTztBQUN6QjtBQUNBOztBQUVBLGdCQUFnQix5REFBUztBQUN6Qjs7QUFFQSwrREFBZSxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjEuanM/NzdjYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgcm5nIGZyb20gJy4vcm5nLmpzJztcbmltcG9ydCBzdHJpbmdpZnkgZnJvbSAnLi9zdHJpbmdpZnkuanMnOyAvLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbnZhciBfbm9kZUlkO1xuXG52YXIgX2Nsb2Nrc2VxOyAvLyBQcmV2aW91cyB1dWlkIGNyZWF0aW9uIHRpbWVcblxuXG52YXIgX2xhc3RNU2VjcyA9IDA7XG52YXIgX2xhc3ROU2VjcyA9IDA7IC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdXVpZGpzL3V1aWQgZm9yIEFQSSBkZXRhaWxzXG5cbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICB2YXIgYiA9IGJ1ZiB8fCBuZXcgQXJyYXkoMTYpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgdmFyIGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTsgLy8gbm9kZSBhbmQgY2xvY2tzZXEgbmVlZCB0byBiZSBpbml0aWFsaXplZCB0byByYW5kb20gdmFsdWVzIGlmIHRoZXkncmUgbm90XG4gIC8vIHNwZWNpZmllZC4gIFdlIGRvIHRoaXMgbGF6aWx5IHRvIG1pbmltaXplIGlzc3VlcyByZWxhdGVkIHRvIGluc3VmZmljaWVudFxuICAvLyBzeXN0ZW0gZW50cm9weS4gIFNlZSAjMTg5XG5cbiAgaWYgKG5vZGUgPT0gbnVsbCB8fCBjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgdmFyIHNlZWRCeXRlcyA9IG9wdGlvbnMucmFuZG9tIHx8IChvcHRpb25zLnJuZyB8fCBybmcpKCk7XG5cbiAgICBpZiAobm9kZSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC41LCBjcmVhdGUgYW5kIDQ4LWJpdCBub2RlIGlkLCAoNDcgcmFuZG9tIGJpdHMgKyBtdWx0aWNhc3QgYml0ID0gMSlcbiAgICAgIG5vZGUgPSBfbm9kZUlkID0gW3NlZWRCeXRlc1swXSB8IDB4MDEsIHNlZWRCeXRlc1sxXSwgc2VlZEJ5dGVzWzJdLCBzZWVkQnl0ZXNbM10sIHNlZWRCeXRlc1s0XSwgc2VlZEJ5dGVzWzVdXTtcbiAgICB9XG5cbiAgICBpZiAoY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbiAgICAgIGNsb2Nrc2VxID0gX2Nsb2Nrc2VxID0gKHNlZWRCeXRlc1s2XSA8PCA4IHwgc2VlZEJ5dGVzWzddKSAmIDB4M2ZmZjtcbiAgICB9XG4gIH0gLy8gVVVJRCB0aW1lc3RhbXBzIGFyZSAxMDAgbmFuby1zZWNvbmQgdW5pdHMgc2luY2UgdGhlIEdyZWdvcmlhbiBlcG9jaCxcbiAgLy8gKDE1ODItMTAtMTUgMDA6MDApLiAgSlNOdW1iZXJzIGFyZW4ndCBwcmVjaXNlIGVub3VnaCBmb3IgdGhpcywgc29cbiAgLy8gdGltZSBpcyBoYW5kbGVkIGludGVybmFsbHkgYXMgJ21zZWNzJyAoaW50ZWdlciBtaWxsaXNlY29uZHMpIGFuZCAnbnNlY3MnXG4gIC8vICgxMDAtbmFub3NlY29uZHMgb2Zmc2V0IGZyb20gbXNlY3MpIHNpbmNlIHVuaXggZXBvY2gsIDE5NzAtMDEtMDEgMDA6MDAuXG5cblxuICB2YXIgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogRGF0ZS5ub3coKTsgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuXG4gIHZhciBuc2VjcyA9IG9wdGlvbnMubnNlY3MgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubnNlY3MgOiBfbGFzdE5TZWNzICsgMTsgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuXG4gIHZhciBkdCA9IG1zZWNzIC0gX2xhc3RNU2VjcyArIChuc2VjcyAtIF9sYXN0TlNlY3MpIC8gMTAwMDA7IC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cblxuICBpZiAoZHQgPCAwICYmIG9wdGlvbnMuY2xvY2tzZXEgPT09IHVuZGVmaW5lZCkge1xuICAgIGNsb2Nrc2VxID0gY2xvY2tzZXEgKyAxICYgMHgzZmZmO1xuICB9IC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcblxuXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9IC8vIFBlciA0LjIuMS4yIFRocm93IGVycm9yIGlmIHRvbyBtYW55IHV1aWRzIGFyZSByZXF1ZXN0ZWRcblxuXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcInV1aWQudjEoKTogQ2FuJ3QgY3JlYXRlIG1vcmUgdGhhbiAxME0gdXVpZHMvc2VjXCIpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxOyAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcblxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDsgLy8gYHRpbWVfbG93YFxuXG4gIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7IC8vIGB0aW1lX21pZGBcblxuICB2YXIgdG1oID0gbXNlY3MgLyAweDEwMDAwMDAwMCAqIDEwMDAwICYgMHhmZmZmZmZmO1xuICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bWggJiAweGZmOyAvLyBgdGltZV9oaWdoX2FuZF92ZXJzaW9uYFxuXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjsgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG5cbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwOyAvLyBgY2xvY2tfc2VxX2xvd2BcblxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7IC8vIGBub2RlYFxuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgKytuKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZiB8fCBzdHJpbmdpZnkoYik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHYxOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v1.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v3.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v3.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v35.js\");\n/* harmony import */ var _md5_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./md5.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/md5.js\");\n\n\nvar v3 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v3', 0x30, _md5_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ __webpack_exports__[\"default\"] = (v3);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjMuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQTJCO0FBQ0E7QUFDM0IsU0FBUyxtREFBRyxhQUFhLCtDQUFHO0FBQzVCLCtEQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92My5qcz84NjYwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IG1kNSBmcm9tICcuL21kNS5qcyc7XG52YXIgdjMgPSB2MzUoJ3YzJywgMHgzMCwgbWQ1KTtcbmV4cG9ydCBkZWZhdWx0IHYzOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v3.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v35.js":
/*!***************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v35.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DNS: function() { return /* binding */ DNS; },\n/* harmony export */   URL: function() { return /* binding */ URL; },\n/* harmony export */   \"default\": function() { return /* export default binding */ __WEBPACK_DEFAULT_EXPORT__; }\n/* harmony export */ });\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/stringify.js\");\n/* harmony import */ var _parse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./parse.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/parse.js\");\n\n\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  var bytes = [];\n\n  for (var i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nvar DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nvar URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\n/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0,_parse_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    var bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (var i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjM1LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXVDO0FBQ1I7O0FBRS9CO0FBQ0EsMkNBQTJDOztBQUUzQzs7QUFFQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFTztBQUNBO0FBQ1AsNkJBQWUsb0NBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IscURBQUs7QUFDdkI7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0IsUUFBUTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsV0FBVyx5REFBUztBQUNwQixJQUFJOzs7QUFHSjtBQUNBLDhCQUE4QjtBQUM5QixJQUFJLGVBQWU7OztBQUduQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3YzNS5qcz8zZjJkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBzdHJpbmdpZnkgZnJvbSAnLi9zdHJpbmdpZnkuanMnO1xuaW1wb3J0IHBhcnNlIGZyb20gJy4vcGFyc2UuanMnO1xuXG5mdW5jdGlvbiBzdHJpbmdUb0J5dGVzKHN0cikge1xuICBzdHIgPSB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoc3RyKSk7IC8vIFVURjggZXNjYXBlXG5cbiAgdmFyIGJ5dGVzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBieXRlcy5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpKTtcbiAgfVxuXG4gIHJldHVybiBieXRlcztcbn1cblxuZXhwb3J0IHZhciBETlMgPSAnNmJhN2I4MTAtOWRhZC0xMWQxLTgwYjQtMDBjMDRmZDQzMGM4JztcbmV4cG9ydCB2YXIgVVJMID0gJzZiYTdiODExLTlkYWQtMTFkMS04MGI0LTAwYzA0ZmQ0MzBjOCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAobmFtZSwgdmVyc2lvbiwgaGFzaGZ1bmMpIHtcbiAgZnVuY3Rpb24gZ2VuZXJhdGVVVUlEKHZhbHVlLCBuYW1lc3BhY2UsIGJ1Ziwgb2Zmc2V0KSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhbHVlID0gc3RyaW5nVG9CeXRlcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuYW1lc3BhY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lc3BhY2UgPSBwYXJzZShuYW1lc3BhY2UpO1xuICAgIH1cblxuICAgIGlmIChuYW1lc3BhY2UubGVuZ3RoICE9PSAxNikge1xuICAgICAgdGhyb3cgVHlwZUVycm9yKCdOYW1lc3BhY2UgbXVzdCBiZSBhcnJheS1saWtlICgxNiBpdGVyYWJsZSBpbnRlZ2VyIHZhbHVlcywgMC0yNTUpJyk7XG4gICAgfSAvLyBDb21wdXRlIGhhc2ggb2YgbmFtZXNwYWNlIGFuZCB2YWx1ZSwgUGVyIDQuM1xuICAgIC8vIEZ1dHVyZTogVXNlIHNwcmVhZCBzeW50YXggd2hlbiBzdXBwb3J0ZWQgb24gYWxsIHBsYXRmb3JtcywgZS5nLiBgYnl0ZXMgPVxuICAgIC8vIGhhc2hmdW5jKFsuLi5uYW1lc3BhY2UsIC4uLiB2YWx1ZV0pYFxuXG5cbiAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNiArIHZhbHVlLmxlbmd0aCk7XG4gICAgYnl0ZXMuc2V0KG5hbWVzcGFjZSk7XG4gICAgYnl0ZXMuc2V0KHZhbHVlLCBuYW1lc3BhY2UubGVuZ3RoKTtcbiAgICBieXRlcyA9IGhhc2hmdW5jKGJ5dGVzKTtcbiAgICBieXRlc1s2XSA9IGJ5dGVzWzZdICYgMHgwZiB8IHZlcnNpb247XG4gICAgYnl0ZXNbOF0gPSBieXRlc1s4XSAmIDB4M2YgfCAweDgwO1xuXG4gICAgaWYgKGJ1Zikge1xuICAgICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICBidWZbb2Zmc2V0ICsgaV0gPSBieXRlc1tpXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGJ1ZjtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyaW5naWZ5KGJ5dGVzKTtcbiAgfSAvLyBGdW5jdGlvbiNuYW1lIGlzIG5vdCBzZXR0YWJsZSBvbiBzb21lIHBsYXRmb3JtcyAoIzI3MClcblxuXG4gIHRyeSB7XG4gICAgZ2VuZXJhdGVVVUlELm5hbWUgPSBuYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgfSBjYXRjaCAoZXJyKSB7fSAvLyBGb3IgQ29tbW9uSlMgZGVmYXVsdCBleHBvcnQgc3VwcG9ydFxuXG5cbiAgZ2VuZXJhdGVVVUlELkROUyA9IEROUztcbiAgZ2VuZXJhdGVVVUlELlVSTCA9IFVSTDtcbiAgcmV0dXJuIGdlbmVyYXRlVVVJRDtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v35.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v4.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _rng_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rng.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/rng.js\");\n/* harmony import */ var _stringify_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stringify.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/stringify.js\");\n\n\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n  var rnds = options.random || (options.rng || _rng_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0,_stringify_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(rnds);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (v4);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjQuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQTJCO0FBQ1k7O0FBRXZDO0FBQ0E7QUFDQSwrQ0FBK0MsK0NBQUcsS0FBSzs7QUFFdkQ7QUFDQSxtQ0FBbUM7O0FBRW5DO0FBQ0E7O0FBRUEsb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFNBQVMseURBQVM7QUFDbEI7O0FBRUEsK0RBQWUsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdXVpZC9kaXN0L2VzbS1icm93c2VyL3Y0LmpzPzgwNWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHJuZyBmcm9tICcuL3JuZy5qcyc7XG5pbXBvcnQgc3RyaW5naWZ5IGZyb20gJy4vc3RyaW5naWZ5LmpzJztcblxuZnVuY3Rpb24gdjQob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciBybmRzID0gb3B0aW9ucy5yYW5kb20gfHwgKG9wdGlvbnMucm5nIHx8IHJuZykoKTsgLy8gUGVyIDQuNCwgc2V0IGJpdHMgZm9yIHZlcnNpb24gYW5kIGBjbG9ja19zZXFfaGlfYW5kX3Jlc2VydmVkYFxuXG4gIHJuZHNbNl0gPSBybmRzWzZdICYgMHgwZiB8IDB4NDA7XG4gIHJuZHNbOF0gPSBybmRzWzhdICYgMHgzZiB8IDB4ODA7IC8vIENvcHkgYnl0ZXMgdG8gYnVmZmVyLCBpZiBwcm92aWRlZFxuXG4gIGlmIChidWYpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgfHwgMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgYnVmW29mZnNldCArIGldID0gcm5kc1tpXTtcbiAgICB9XG5cbiAgICByZXR1cm4gYnVmO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZ2lmeShybmRzKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdjQ7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v4.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v5.js":
/*!**************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/v5.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _v35_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./v35.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v35.js\");\n/* harmony import */ var _sha1_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sha1.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/sha1.js\");\n\n\nvar v5 = (0,_v35_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])('v5', 0x50, _sha1_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n/* harmony default export */ __webpack_exports__[\"default\"] = (v5);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdjUuanMiLCJtYXBwaW5ncyI6Ijs7O0FBQTJCO0FBQ0U7QUFDN0IsU0FBUyxtREFBRyxhQUFhLGdEQUFJO0FBQzdCLCtEQUFlLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92NS5qcz8yOTk0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB2MzUgZnJvbSAnLi92MzUuanMnO1xuaW1wb3J0IHNoYTEgZnJvbSAnLi9zaGExLmpzJztcbnZhciB2NSA9IHYzNSgndjUnLCAweDUwLCBzaGExKTtcbmV4cG9ydCBkZWZhdWx0IHY1OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/v5.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/validate.js":
/*!********************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/validate.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _regex_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regex.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/regex.js\");\n\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].test(uuid);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (validate);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmFsaWRhdGUuanMiLCJtYXBwaW5ncyI6Ijs7QUFBK0I7O0FBRS9CO0FBQ0EscUNBQXFDLGlEQUFLO0FBQzFDOztBQUVBLCtEQUFlLFFBQVEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92YWxpZGF0ZS5qcz85ZDcxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSRUdFWCBmcm9tICcuL3JlZ2V4LmpzJztcblxuZnVuY3Rpb24gdmFsaWRhdGUodXVpZCkge1xuICByZXR1cm4gdHlwZW9mIHV1aWQgPT09ICdzdHJpbmcnICYmIFJFR0VYLnRlc3QodXVpZCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZhbGlkYXRlOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/validate.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/uuid/dist/esm-browser/version.js":
/*!*******************************************************!*\
  !*** ./node_modules/uuid/dist/esm-browser/version.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _validate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validate.js */ \"(app-pages-browser)/./node_modules/uuid/dist/esm-browser/validate.js\");\n\n\nfunction version(uuid) {\n  if (!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (version);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy91dWlkL2Rpc3QvZXNtLWJyb3dzZXIvdmVyc2lvbi5qcyIsIm1hcHBpbmdzIjoiOztBQUFxQzs7QUFFckM7QUFDQSxPQUFPLHdEQUFRO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtEQUFlLE9BQU8iLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3V1aWQvZGlzdC9lc20tYnJvd3Nlci92ZXJzaW9uLmpzPzQxMWYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHZhbGlkYXRlIGZyb20gJy4vdmFsaWRhdGUuanMnO1xuXG5mdW5jdGlvbiB2ZXJzaW9uKHV1aWQpIHtcbiAgaWYgKCF2YWxpZGF0ZSh1dWlkKSkge1xuICAgIHRocm93IFR5cGVFcnJvcignSW52YWxpZCBVVUlEJyk7XG4gIH1cblxuICByZXR1cm4gcGFyc2VJbnQodXVpZC5zdWJzdHIoMTQsIDEpLCAxNik7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHZlcnNpb247Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/uuid/dist/esm-browser/version.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/styles.css":
/*!*****************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react-ui/styles.css ***!
  \*****************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (\"192d4a9dca35\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0LXVpL3N0eWxlcy5jc3MiLCJtYXBwaW5ncyI6IjtBQUFBLCtEQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0LXVpL3N0eWxlcy5jc3M/MzI2YSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjE5MmQ0YTlkY2EzNVwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/styles.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./src/providers/wallet-provider.tsx":
/*!*******************************************!*\
  !*** ./src/providers/wallet-provider.tsx ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletConnectionProvider: function() { return /* binding */ WalletConnectionProvider; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/ConnectionProvider.js\");\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProvider.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/types.js\");\n/* harmony import */ var _solana_wallet_adapter_react_ui__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @solana/wallet-adapter-react-ui */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModalProvider.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _solana_wallet_adapter_react_ui_styles_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-adapter-react-ui/styles.css */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/styles.css\");\n/* __next_internal_client_entry_do_not_use__ WalletConnectionProvider auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n// Default styles that can be overridden by your app\n\nconst WalletConnectionProvider = (param)=>{\n    let { children } = param;\n    _s();\n    // The network can be set to 'devnet', 'testnet', or 'mainnet-beta'.\n    const network = _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletAdapterNetwork.Mainnet;\n    // You can also provide a custom RPC endpoint.\n    //TODO: use a private RPC endpoint\n    const endpoint = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>(0,_solana_web3_js__WEBPACK_IMPORTED_MODULE_2__.clusterApiUrl)(network), [\n        network\n    ]);\n    const wallets = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(()=>[], // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n        network\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_5__.ConnectionProvider, {\n        endpoint: endpoint,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_6__.WalletProvider, {\n            wallets: wallets,\n            autoConnect: true,\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_solana_wallet_adapter_react_ui__WEBPACK_IMPORTED_MODULE_7__.WalletModalProvider, {\n                children: children\n            }, void 0, false, {\n                fileName: \"/Users/rafael/work/buddy-link/buddy-ts-examples/next/sponsaru/src/providers/wallet-provider.tsx\",\n                lineNumber: 43,\n                columnNumber: 9\n            }, undefined)\n        }, void 0, false, {\n            fileName: \"/Users/rafael/work/buddy-link/buddy-ts-examples/next/sponsaru/src/providers/wallet-provider.tsx\",\n            lineNumber: 42,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false, {\n        fileName: \"/Users/rafael/work/buddy-link/buddy-ts-examples/next/sponsaru/src/providers/wallet-provider.tsx\",\n        lineNumber: 41,\n        columnNumber: 5\n    }, undefined);\n};\n_s(WalletConnectionProvider, \"RNaTq20PjYTGasfEtgZ8qKkPMD0=\");\n_c = WalletConnectionProvider;\nvar _c;\n$RefreshReg$(_c, \"WalletConnectionProvider\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9wcm92aWRlcnMvd2FsbGV0LXByb3ZpZGVyLnRzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFDMkM7QUFDdUM7QUFDZjtBQUU4QztBQUNqRTtBQUVoRCxvREFBb0Q7QUFDQTtBQUU3QyxNQUFNTywyQkFBOEQ7UUFBQyxFQUFFQyxRQUFRLEVBQUU7O0lBQ3RGLG9FQUFvRTtJQUNwRSxNQUFNQyxVQUFVTCw2RUFBb0JBLENBQUNNLE9BQU87SUFFNUMsOENBQThDO0lBQzlDLGtDQUFrQztJQUNsQyxNQUFNQyxXQUFXViw4Q0FBT0EsQ0FBQyxJQUFNSyw4REFBYUEsQ0FBQ0csVUFBVTtRQUFDQTtLQUFRO0lBRWhFLE1BQU1HLFVBQVVYLDhDQUFPQSxDQUNyQixJQUFNLEVBY0wsRUFDRCx1REFBdUQ7SUFDdkQ7UUFBQ1E7S0FBUTtJQUdYLHFCQUNFLDhEQUFDUCw0RUFBa0JBO1FBQUNTLFVBQVVBO2tCQUM1Qiw0RUFBQ1Isd0VBQWNBO1lBQUNTLFNBQVNBO1lBQVNDLFdBQVc7c0JBQzNDLDRFQUFDUixnRkFBbUJBOzBCQUFFRzs7Ozs7Ozs7Ozs7Ozs7OztBQUk5QixFQUFFO0dBbkNXRDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvcHJvdmlkZXJzL3dhbGxldC1wcm92aWRlci50c3g/ZWE1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5pbXBvcnQgUmVhY3QsIHsgRkMsIHVzZU1lbW8gfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBDb25uZWN0aW9uUHJvdmlkZXIsIFdhbGxldFByb3ZpZGVyIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdCc7XG5pbXBvcnQgeyBXYWxsZXRBZGFwdGVyTmV0d29yayB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZSc7XG5pbXBvcnQgeyBVbnNhZmVCdXJuZXJXYWxsZXRBZGFwdGVyIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci13YWxsZXRzJztcbmltcG9ydCB7IFdhbGxldE1vZGFsUHJvdmlkZXIsIFdhbGxldERpc2Nvbm5lY3RCdXR0b24sIFdhbGxldE11bHRpQnV0dG9uIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aSc7XG5pbXBvcnQgeyBjbHVzdGVyQXBpVXJsIH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJztcblxuLy8gRGVmYXVsdCBzdHlsZXMgdGhhdCBjYW4gYmUgb3ZlcnJpZGRlbiBieSB5b3VyIGFwcFxuaW1wb3J0ICdAc29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0LXVpL3N0eWxlcy5jc3MnO1xuXG5leHBvcnQgY29uc3QgV2FsbGV0Q29ubmVjdGlvblByb3ZpZGVyOiBGQzx7IGNoaWxkcmVuOiBSZWFjdC5SZWFjdE5vZGUgfT4gPSAoeyBjaGlsZHJlbiB9KSA9PiB7XG4gIC8vIFRoZSBuZXR3b3JrIGNhbiBiZSBzZXQgdG8gJ2Rldm5ldCcsICd0ZXN0bmV0Jywgb3IgJ21haW5uZXQtYmV0YScuXG4gIGNvbnN0IG5ldHdvcmsgPSBXYWxsZXRBZGFwdGVyTmV0d29yay5NYWlubmV0O1xuXG4gIC8vIFlvdSBjYW4gYWxzbyBwcm92aWRlIGEgY3VzdG9tIFJQQyBlbmRwb2ludC5cbiAgLy9UT0RPOiB1c2UgYSBwcml2YXRlIFJQQyBlbmRwb2ludFxuICBjb25zdCBlbmRwb2ludCA9IHVzZU1lbW8oKCkgPT4gY2x1c3RlckFwaVVybChuZXR3b3JrKSwgW25ldHdvcmtdKTtcblxuICBjb25zdCB3YWxsZXRzID0gdXNlTWVtbyhcbiAgICAoKSA9PiBbXG4gICAgICAvKipcbiAgICAgICAqIFdhbGxldHMgdGhhdCBpbXBsZW1lbnQgZWl0aGVyIG9mIHRoZXNlIHN0YW5kYXJkcyB3aWxsIGJlIGF2YWlsYWJsZSBhdXRvbWF0aWNhbGx5LlxuICAgICAgICpcbiAgICAgICAqICAgLSBTb2xhbmEgTW9iaWxlIFN0YWNrIE1vYmlsZSBXYWxsZXQgQWRhcHRlciBQcm90b2NvbFxuICAgICAgICogICAgIChodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLW1vYmlsZS9tb2JpbGUtd2FsbGV0LWFkYXB0ZXIpXG4gICAgICAgKiAgIC0gU29sYW5hIFdhbGxldCBTdGFuZGFyZFxuICAgICAgICogICAgIChodHRwczovL2dpdGh1Yi5jb20vYW56YS14eXovd2FsbGV0LXN0YW5kYXJkKVxuICAgICAgICpcbiAgICAgICAqIElmIHlvdSB3aXNoIHRvIHN1cHBvcnQgYSB3YWxsZXQgdGhhdCBzdXBwb3J0cyBuZWl0aGVyIG9mIHRob3NlIHN0YW5kYXJkcyxcbiAgICAgICAqIGluc3RhbnRpYXRlIGl0cyBsZWdhY3kgd2FsbGV0IGFkYXB0ZXIgaGVyZS4gQ29tbW9uIGxlZ2FjeSBhZGFwdGVycyBjYW4gYmUgZm91bmRcbiAgICAgICAqIGluIHRoZSBucG0gcGFja2FnZSBgQHNvbGFuYS93YWxsZXQtYWRhcHRlci13YWxsZXRzYC5cbiAgICAgICAqL1xuICAgICAgLy8gICBuZXcgVW5zYWZlQnVybmVyV2FsbGV0QWRhcHRlcigpLFxuICAgIF0sXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWhvb2tzL2V4aGF1c3RpdmUtZGVwc1xuICAgIFtuZXR3b3JrXVxuICApO1xuXG4gIHJldHVybiAoXG4gICAgPENvbm5lY3Rpb25Qcm92aWRlciBlbmRwb2ludD17ZW5kcG9pbnR9PlxuICAgICAgPFdhbGxldFByb3ZpZGVyIHdhbGxldHM9e3dhbGxldHN9IGF1dG9Db25uZWN0PlxuICAgICAgICA8V2FsbGV0TW9kYWxQcm92aWRlcj57Y2hpbGRyZW59PC9XYWxsZXRNb2RhbFByb3ZpZGVyPlxuICAgICAgPC9XYWxsZXRQcm92aWRlcj5cbiAgICA8L0Nvbm5lY3Rpb25Qcm92aWRlcj5cbiAgKTtcbn07XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VNZW1vIiwiQ29ubmVjdGlvblByb3ZpZGVyIiwiV2FsbGV0UHJvdmlkZXIiLCJXYWxsZXRBZGFwdGVyTmV0d29yayIsIldhbGxldE1vZGFsUHJvdmlkZXIiLCJjbHVzdGVyQXBpVXJsIiwiV2FsbGV0Q29ubmVjdGlvblByb3ZpZGVyIiwiY2hpbGRyZW4iLCJuZXR3b3JrIiwiTWFpbm5ldCIsImVuZHBvaW50Iiwid2FsbGV0cyIsImF1dG9Db25uZWN0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/providers/wallet-provider.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/_shortw_utils.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createCurve: function() { return /* binding */ createCurve; },\n/* harmony export */   getHash: function() { return /* binding */ getHash; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @noble/hashes/hmac */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n// connects noble-curves to noble-hashes\nfunction getHash(hash) {\n    return {\n        hash,\n        hmac: (key, ...msgs) => (0,_noble_hashes_hmac__WEBPACK_IMPORTED_MODULE_0__.hmac)(hash, key, (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.concatBytes)(...msgs)),\n        randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_1__.randomBytes,\n    };\n}\nfunction createCurve(curveDef, defHash) {\n    const create = (hash) => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_2__.weierstrass)({ ...curveDef, ...getHash(hash) });\n    return Object.freeze({ ...create(defHash), create });\n}\n//# sourceMappingURL=_shortw_utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDMEM7QUFDcUI7QUFDUDtBQUN4RDtBQUNPO0FBQ1A7QUFDQTtBQUNBLGdDQUFnQyx3REFBSSxZQUFZLGdFQUFXO0FBQzNELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ087QUFDUCw2QkFBNkIscUVBQVcsR0FBRywrQkFBK0I7QUFDMUUsMkJBQTJCLDRCQUE0QjtBQUN2RDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9fc2hvcnR3X3V0aWxzLmpzPzMwNjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgaG1hYyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvaG1hYyc7XG5pbXBvcnQgeyBjb25jYXRCeXRlcywgcmFuZG9tQnl0ZXMgfSBmcm9tICdAbm9ibGUvaGFzaGVzL3V0aWxzJztcbmltcG9ydCB7IHdlaWVyc3RyYXNzIH0gZnJvbSAnLi9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyc7XG4vLyBjb25uZWN0cyBub2JsZS1jdXJ2ZXMgdG8gbm9ibGUtaGFzaGVzXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGFzaChoYXNoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaGFzaCxcbiAgICAgICAgaG1hYzogKGtleSwgLi4ubXNncykgPT4gaG1hYyhoYXNoLCBrZXksIGNvbmNhdEJ5dGVzKC4uLm1zZ3MpKSxcbiAgICAgICAgcmFuZG9tQnl0ZXMsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDdXJ2ZShjdXJ2ZURlZiwgZGVmSGFzaCkge1xuICAgIGNvbnN0IGNyZWF0ZSA9IChoYXNoKSA9PiB3ZWllcnN0cmFzcyh7IC4uLmN1cnZlRGVmLCAuLi5nZXRIYXNoKGhhc2gpIH0pO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4uY3JlYXRlKGRlZkhhc2gpLCBjcmVhdGUgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fc2hvcnR3X3V0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/curve.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   validateBasic: function() { return /* binding */ validateBasic; },\n/* harmony export */   wNAF: function() { return /* binding */ wNAF; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Abelian group utilities\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n// Elliptic curve multiplication of Point by scalar. Fragile.\n// Scalars should always be less than curve order: this should be checked inside of a curve itself.\n// Creates precomputation tables for fast multiplication:\n// - private scalar is split by fixed size windows of W bits\n// - every window point is collected from window's table & added to accumulator\n// - since windows are different, same point inside tables won't be accessed more than once per calc\n// - each multiplication is 'Math.ceil(CURVE_ORDER / 𝑊) + 1' point additions (fixed for any scalar)\n// - +1 window is neccessary for wNAF\n// - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n// TODO: Research returning 2d JS array of windows, instead of a single window. This would allow\n// windows to be in different memory locations\nfunction wNAF(c, bits) {\n    const constTimeNegate = (condition, item) => {\n        const neg = item.negate();\n        return condition ? neg : item;\n    };\n    const opts = (W) => {\n        const windows = Math.ceil(bits / W) + 1; // +1, because\n        const windowSize = 2 ** (W - 1); // -1 because we skip zero\n        return { windows, windowSize };\n    };\n    return {\n        constTimeNegate,\n        // non-const time multiplication ladder\n        unsafeLadder(elm, n) {\n            let p = c.ZERO;\n            let d = elm;\n            while (n > _0n) {\n                if (n & _1n)\n                    p = p.add(d);\n                d = d.double();\n                n >>= _1n;\n            }\n            return p;\n        },\n        /**\n         * Creates a wNAF precomputation window. Used for caching.\n         * Default window size is set by `utils.precompute()` and is equal to 8.\n         * Number of precomputed points depends on the curve size:\n         * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:\n         * - 𝑊 is the window size\n         * - 𝑛 is the bitlength of the curve order.\n         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n         * @returns precomputed point tables flattened to a single array\n         */\n        precomputeWindow(elm, W) {\n            const { windows, windowSize } = opts(W);\n            const points = [];\n            let p = elm;\n            let base = p;\n            for (let window = 0; window < windows; window++) {\n                base = p;\n                points.push(base);\n                // =1, because we skip zero\n                for (let i = 1; i < windowSize; i++) {\n                    base = base.add(p);\n                    points.push(base);\n                }\n                p = base.double();\n            }\n            return points;\n        },\n        /**\n         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n         * @param W window size\n         * @param precomputes precomputed tables\n         * @param n scalar (we don't check here, but should be less than curve order)\n         * @returns real and fake (for const-time) points\n         */\n        wNAF(W, precomputes, n) {\n            // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n            // But need to carefully remove other checks before wNAF. ORDER == bits here\n            const { windows, windowSize } = opts(W);\n            let p = c.ZERO;\n            let f = c.BASE;\n            const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n            const maxNumber = 2 ** W;\n            const shiftBy = BigInt(W);\n            for (let window = 0; window < windows; window++) {\n                const offset = window * windowSize;\n                // Extract W bits.\n                let wbits = Number(n & mask);\n                // Shift number by W bits.\n                n >>= shiftBy;\n                // If the bits are bigger than max size, we'll split those.\n                // +224 => 256 - 32\n                if (wbits > windowSize) {\n                    wbits -= maxNumber;\n                    n += _1n;\n                }\n                // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n                // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n                // there is negate now: it is possible that negated element from low value\n                // would be the same as high element, which will create carry into next window.\n                // It's not obvious how this can fail, but still worth investigating later.\n                // Check if we're onto Zero point.\n                // Add random point inside current window to f.\n                const offset1 = offset;\n                const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n                const cond1 = window % 2 !== 0;\n                const cond2 = wbits < 0;\n                if (wbits === 0) {\n                    // The most important part for const-time getPublicKey\n                    f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n                }\n                else {\n                    p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n                }\n            }\n            // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n            // Even if the variable is still unused, there are some checks which will\n            // throw an exception, so compiler needs to prove they won't happen, which is hard.\n            // At this point there is a way to F be infinity-point even if p is not,\n            // which makes it less const-time: around 1 bigint multiply.\n            return { p, f };\n        },\n        wNAFCached(P, precomputesMap, n, transform) {\n            // @ts-ignore\n            const W = P._WINDOW_SIZE || 1;\n            // Calculate precomputes on a first run, reuse them after\n            let comp = precomputesMap.get(P);\n            if (!comp) {\n                comp = this.precomputeWindow(P, W);\n                if (W !== 1) {\n                    precomputesMap.set(P, transform(comp));\n                }\n            }\n            return this.wNAF(W, comp, n);\n        },\n    };\n}\nfunction validateBasic(curve) {\n    (0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.validateField)(curve.Fp);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject)(curve, {\n        n: 'bigint',\n        h: 'bigint',\n        Gx: 'field',\n        Gy: 'field',\n    }, {\n        nBitLength: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n    });\n    // Set defaults\n    return Object.freeze({\n        ...(0,_modular_js__WEBPACK_IMPORTED_MODULE_0__.nLength)(curve.n, curve.nBitLength),\n        ...curve,\n        ...{ p: curve.Fp.ORDER },\n    });\n}\n//# sourceMappingURL=curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9jdXJ2ZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7QUFDQTtBQUNzRDtBQUNWO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELHlDQUF5QztBQUN6QyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxnQkFBZ0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxpQ0FBaUMsa0JBQWtCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDTztBQUNQLElBQUksMERBQWE7QUFDakIsSUFBSSx5REFBYztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxXQUFXLG9EQUFPO0FBQ2xCO0FBQ0EsYUFBYSxtQkFBbUI7QUFDaEMsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2N1cnZlLmpzP2E4YTIiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gQWJlbGlhbiBncm91cCB1dGlsaXRpZXNcbmltcG9ydCB7IHZhbGlkYXRlRmllbGQsIG5MZW5ndGggfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbi8vIEVsbGlwdGljIGN1cnZlIG11bHRpcGxpY2F0aW9uIG9mIFBvaW50IGJ5IHNjYWxhci4gRnJhZ2lsZS5cbi8vIFNjYWxhcnMgc2hvdWxkIGFsd2F5cyBiZSBsZXNzIHRoYW4gY3VydmUgb3JkZXI6IHRoaXMgc2hvdWxkIGJlIGNoZWNrZWQgaW5zaWRlIG9mIGEgY3VydmUgaXRzZWxmLlxuLy8gQ3JlYXRlcyBwcmVjb21wdXRhdGlvbiB0YWJsZXMgZm9yIGZhc3QgbXVsdGlwbGljYXRpb246XG4vLyAtIHByaXZhdGUgc2NhbGFyIGlzIHNwbGl0IGJ5IGZpeGVkIHNpemUgd2luZG93cyBvZiBXIGJpdHNcbi8vIC0gZXZlcnkgd2luZG93IHBvaW50IGlzIGNvbGxlY3RlZCBmcm9tIHdpbmRvdydzIHRhYmxlICYgYWRkZWQgdG8gYWNjdW11bGF0b3Jcbi8vIC0gc2luY2Ugd2luZG93cyBhcmUgZGlmZmVyZW50LCBzYW1lIHBvaW50IGluc2lkZSB0YWJsZXMgd29uJ3QgYmUgYWNjZXNzZWQgbW9yZSB0aGFuIG9uY2UgcGVyIGNhbGNcbi8vIC0gZWFjaCBtdWx0aXBsaWNhdGlvbiBpcyAnTWF0aC5jZWlsKENVUlZFX09SREVSIC8g8J2RiikgKyAxJyBwb2ludCBhZGRpdGlvbnMgKGZpeGVkIGZvciBhbnkgc2NhbGFyKVxuLy8gLSArMSB3aW5kb3cgaXMgbmVjY2Vzc2FyeSBmb3Igd05BRlxuLy8gLSB3TkFGIHJlZHVjZXMgdGFibGUgc2l6ZTogMnggbGVzcyBtZW1vcnkgKyAyeCBmYXN0ZXIgZ2VuZXJhdGlvbiwgYnV0IDEwJSBzbG93ZXIgbXVsdGlwbGljYXRpb25cbi8vIFRPRE86IFJlc2VhcmNoIHJldHVybmluZyAyZCBKUyBhcnJheSBvZiB3aW5kb3dzLCBpbnN0ZWFkIG9mIGEgc2luZ2xlIHdpbmRvdy4gVGhpcyB3b3VsZCBhbGxvd1xuLy8gd2luZG93cyB0byBiZSBpbiBkaWZmZXJlbnQgbWVtb3J5IGxvY2F0aW9uc1xuZXhwb3J0IGZ1bmN0aW9uIHdOQUYoYywgYml0cykge1xuICAgIGNvbnN0IGNvbnN0VGltZU5lZ2F0ZSA9IChjb25kaXRpb24sIGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgbmVnID0gaXRlbS5uZWdhdGUoKTtcbiAgICAgICAgcmV0dXJuIGNvbmRpdGlvbiA/IG5lZyA6IGl0ZW07XG4gICAgfTtcbiAgICBjb25zdCBvcHRzID0gKFcpID0+IHtcbiAgICAgICAgY29uc3Qgd2luZG93cyA9IE1hdGguY2VpbChiaXRzIC8gVykgKyAxOyAvLyArMSwgYmVjYXVzZVxuICAgICAgICBjb25zdCB3aW5kb3dTaXplID0gMiAqKiAoVyAtIDEpOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICByZXR1cm4geyB3aW5kb3dzLCB3aW5kb3dTaXplIH07XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25zdFRpbWVOZWdhdGUsXG4gICAgICAgIC8vIG5vbi1jb25zdCB0aW1lIG11bHRpcGxpY2F0aW9uIGxhZGRlclxuICAgICAgICB1bnNhZmVMYWRkZXIoZWxtLCBuKSB7XG4gICAgICAgICAgICBsZXQgcCA9IGMuWkVSTztcbiAgICAgICAgICAgIGxldCBkID0gZWxtO1xuICAgICAgICAgICAgd2hpbGUgKG4gPiBfMG4pIHtcbiAgICAgICAgICAgICAgICBpZiAobiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGQgPSBkLmRvdWJsZSgpO1xuICAgICAgICAgICAgICAgIG4gPj49IF8xbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBhIHdOQUYgcHJlY29tcHV0YXRpb24gd2luZG93LiBVc2VkIGZvciBjYWNoaW5nLlxuICAgICAgICAgKiBEZWZhdWx0IHdpbmRvdyBzaXplIGlzIHNldCBieSBgdXRpbHMucHJlY29tcHV0ZSgpYCBhbmQgaXMgZXF1YWwgdG8gOC5cbiAgICAgICAgICogTnVtYmVyIG9mIHByZWNvbXB1dGVkIHBvaW50cyBkZXBlbmRzIG9uIHRoZSBjdXJ2ZSBzaXplOlxuICAgICAgICAgKiAyXijwnZGK4oiSMSkgKiAoTWF0aC5jZWlsKPCdkZsgLyDwnZGKKSArIDEpLCB3aGVyZTpcbiAgICAgICAgICogLSDwnZGKIGlzIHRoZSB3aW5kb3cgc2l6ZVxuICAgICAgICAgKiAtIPCdkZsgaXMgdGhlIGJpdGxlbmd0aCBvZiB0aGUgY3VydmUgb3JkZXIuXG4gICAgICAgICAqIEZvciBhIDI1Ni1iaXQgY3VydmUgYW5kIHdpbmRvdyBzaXplIDgsIHRoZSBudW1iZXIgb2YgcHJlY29tcHV0ZWQgcG9pbnRzIGlzIDEyOCAqIDMzID0gNDIyNC5cbiAgICAgICAgICogQHJldHVybnMgcHJlY29tcHV0ZWQgcG9pbnQgdGFibGVzIGZsYXR0ZW5lZCB0byBhIHNpbmdsZSBhcnJheVxuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZVdpbmRvdyhlbG0sIFcpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgbGV0IHAgPSBlbG07XG4gICAgICAgICAgICBsZXQgYmFzZSA9IHA7XG4gICAgICAgICAgICBmb3IgKGxldCB3aW5kb3cgPSAwOyB3aW5kb3cgPCB3aW5kb3dzOyB3aW5kb3crKykge1xuICAgICAgICAgICAgICAgIGJhc2UgPSBwO1xuICAgICAgICAgICAgICAgIHBvaW50cy5wdXNoKGJhc2UpO1xuICAgICAgICAgICAgICAgIC8vID0xLCBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgd2luZG93U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGJhc2UgPSBiYXNlLmFkZChwKTtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzLnB1c2goYmFzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHAgPSBiYXNlLmRvdWJsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBvaW50cztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudHMgZWMgbXVsdGlwbGljYXRpb24gdXNpbmcgcHJlY29tcHV0ZWQgdGFibGVzIGFuZCB3LWFyeSBub24tYWRqYWNlbnQgZm9ybS5cbiAgICAgICAgICogQHBhcmFtIFcgd2luZG93IHNpemVcbiAgICAgICAgICogQHBhcmFtIHByZWNvbXB1dGVzIHByZWNvbXB1dGVkIHRhYmxlc1xuICAgICAgICAgKiBAcGFyYW0gbiBzY2FsYXIgKHdlIGRvbid0IGNoZWNrIGhlcmUsIGJ1dCBzaG91bGQgYmUgbGVzcyB0aGFuIGN1cnZlIG9yZGVyKVxuICAgICAgICAgKiBAcmV0dXJucyByZWFsIGFuZCBmYWtlIChmb3IgY29uc3QtdGltZSkgcG9pbnRzXG4gICAgICAgICAqL1xuICAgICAgICB3TkFGKFcsIHByZWNvbXB1dGVzLCBuKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBtYXliZSBjaGVjayB0aGF0IHNjYWxhciBpcyBsZXNzIHRoYW4gZ3JvdXAgb3JkZXI/IHdOQUYgYmVoYXZpb3VzIGlzIHVuZGVmaW5lZCBvdGhlcndpc2VcbiAgICAgICAgICAgIC8vIEJ1dCBuZWVkIHRvIGNhcmVmdWxseSByZW1vdmUgb3RoZXIgY2hlY2tzIGJlZm9yZSB3TkFGLiBPUkRFUiA9PSBiaXRzIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IHsgd2luZG93cywgd2luZG93U2l6ZSB9ID0gb3B0cyhXKTtcbiAgICAgICAgICAgIGxldCBwID0gYy5aRVJPO1xuICAgICAgICAgICAgbGV0IGYgPSBjLkJBU0U7XG4gICAgICAgICAgICBjb25zdCBtYXNrID0gQmlnSW50KDIgKiogVyAtIDEpOyAvLyBDcmVhdGUgbWFzayB3aXRoIFcgb25lczogMGIxMTExIGZvciBXPTQgZXRjLlxuICAgICAgICAgICAgY29uc3QgbWF4TnVtYmVyID0gMiAqKiBXO1xuICAgICAgICAgICAgY29uc3Qgc2hpZnRCeSA9IEJpZ0ludChXKTtcbiAgICAgICAgICAgIGZvciAobGV0IHdpbmRvdyA9IDA7IHdpbmRvdyA8IHdpbmRvd3M7IHdpbmRvdysrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gd2luZG93ICogd2luZG93U2l6ZTtcbiAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IFcgYml0cy5cbiAgICAgICAgICAgICAgICBsZXQgd2JpdHMgPSBOdW1iZXIobiAmIG1hc2spO1xuICAgICAgICAgICAgICAgIC8vIFNoaWZ0IG51bWJlciBieSBXIGJpdHMuXG4gICAgICAgICAgICAgICAgbiA+Pj0gc2hpZnRCeTtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgYml0cyBhcmUgYmlnZ2VyIHRoYW4gbWF4IHNpemUsIHdlJ2xsIHNwbGl0IHRob3NlLlxuICAgICAgICAgICAgICAgIC8vICsyMjQgPT4gMjU2IC0gMzJcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPiB3aW5kb3dTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHdiaXRzIC09IG1heE51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgbiArPSBfMW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoaXMgY29kZSB3YXMgZmlyc3Qgd3JpdHRlbiB3aXRoIGFzc3VtcHRpb24gdGhhdCAnZicgYW5kICdwJyB3aWxsIG5ldmVyIGJlIGluZmluaXR5IHBvaW50OlxuICAgICAgICAgICAgICAgIC8vIHNpbmNlIGVhY2ggYWRkaXRpb24gaXMgbXVsdGlwbGllZCBieSAyICoqIFcsIGl0IGNhbm5vdCBjYW5jZWwgZWFjaCBvdGhlci4gSG93ZXZlcixcbiAgICAgICAgICAgICAgICAvLyB0aGVyZSBpcyBuZWdhdGUgbm93OiBpdCBpcyBwb3NzaWJsZSB0aGF0IG5lZ2F0ZWQgZWxlbWVudCBmcm9tIGxvdyB2YWx1ZVxuICAgICAgICAgICAgICAgIC8vIHdvdWxkIGJlIHRoZSBzYW1lIGFzIGhpZ2ggZWxlbWVudCwgd2hpY2ggd2lsbCBjcmVhdGUgY2FycnkgaW50byBuZXh0IHdpbmRvdy5cbiAgICAgICAgICAgICAgICAvLyBJdCdzIG5vdCBvYnZpb3VzIGhvdyB0aGlzIGNhbiBmYWlsLCBidXQgc3RpbGwgd29ydGggaW52ZXN0aWdhdGluZyBsYXRlci5cbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBvbnRvIFplcm8gcG9pbnQuXG4gICAgICAgICAgICAgICAgLy8gQWRkIHJhbmRvbSBwb2ludCBpbnNpZGUgY3VycmVudCB3aW5kb3cgdG8gZi5cbiAgICAgICAgICAgICAgICBjb25zdCBvZmZzZXQxID0gb2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldDIgPSBvZmZzZXQgKyBNYXRoLmFicyh3Yml0cykgLSAxOyAvLyAtMSBiZWNhdXNlIHdlIHNraXAgemVyb1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmQxID0gd2luZG93ICUgMiAhPT0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBjb25kMiA9IHdiaXRzIDwgMDtcbiAgICAgICAgICAgICAgICBpZiAod2JpdHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG1vc3QgaW1wb3J0YW50IHBhcnQgZm9yIGNvbnN0LXRpbWUgZ2V0UHVibGljS2V5XG4gICAgICAgICAgICAgICAgICAgIGYgPSBmLmFkZChjb25zdFRpbWVOZWdhdGUoY29uZDEsIHByZWNvbXB1dGVzW29mZnNldDFdKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwID0gcC5hZGQoY29uc3RUaW1lTmVnYXRlKGNvbmQyLCBwcmVjb21wdXRlc1tvZmZzZXQyXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEpJVC1jb21waWxlciBzaG91bGQgbm90IGVsaW1pbmF0ZSBmIGhlcmUsIHNpbmNlIGl0IHdpbGwgbGF0ZXIgYmUgdXNlZCBpbiBub3JtYWxpemVaKClcbiAgICAgICAgICAgIC8vIEV2ZW4gaWYgdGhlIHZhcmlhYmxlIGlzIHN0aWxsIHVudXNlZCwgdGhlcmUgYXJlIHNvbWUgY2hlY2tzIHdoaWNoIHdpbGxcbiAgICAgICAgICAgIC8vIHRocm93IGFuIGV4Y2VwdGlvbiwgc28gY29tcGlsZXIgbmVlZHMgdG8gcHJvdmUgdGhleSB3b24ndCBoYXBwZW4sIHdoaWNoIGlzIGhhcmQuXG4gICAgICAgICAgICAvLyBBdCB0aGlzIHBvaW50IHRoZXJlIGlzIGEgd2F5IHRvIEYgYmUgaW5maW5pdHktcG9pbnQgZXZlbiBpZiBwIGlzIG5vdCxcbiAgICAgICAgICAgIC8vIHdoaWNoIG1ha2VzIGl0IGxlc3MgY29uc3QtdGltZTogYXJvdW5kIDEgYmlnaW50IG11bHRpcGx5LlxuICAgICAgICAgICAgcmV0dXJuIHsgcCwgZiB9O1xuICAgICAgICB9LFxuICAgICAgICB3TkFGQ2FjaGVkKFAsIHByZWNvbXB1dGVzTWFwLCBuLCB0cmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IFcgPSBQLl9XSU5ET1dfU0laRSB8fCAxO1xuICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHByZWNvbXB1dGVzIG9uIGEgZmlyc3QgcnVuLCByZXVzZSB0aGVtIGFmdGVyXG4gICAgICAgICAgICBsZXQgY29tcCA9IHByZWNvbXB1dGVzTWFwLmdldChQKTtcbiAgICAgICAgICAgIGlmICghY29tcCkge1xuICAgICAgICAgICAgICAgIGNvbXAgPSB0aGlzLnByZWNvbXB1dGVXaW5kb3coUCwgVyk7XG4gICAgICAgICAgICAgICAgaWYgKFcgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY29tcHV0ZXNNYXAuc2V0KFAsIHRyYW5zZm9ybShjb21wKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMud05BRihXLCBjb21wLCBuKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmFzaWMoY3VydmUpIHtcbiAgICB2YWxpZGF0ZUZpZWxkKGN1cnZlLkZwKTtcbiAgICB2YWxpZGF0ZU9iamVjdChjdXJ2ZSwge1xuICAgICAgICBuOiAnYmlnaW50JyxcbiAgICAgICAgaDogJ2JpZ2ludCcsXG4gICAgICAgIEd4OiAnZmllbGQnLFxuICAgICAgICBHeTogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIG5CaXRMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9KTtcbiAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgIC4uLm5MZW5ndGgoY3VydmUubiwgY3VydmUubkJpdExlbmd0aCksXG4gICAgICAgIC4uLmN1cnZlLFxuICAgICAgICAuLi57IHA6IGN1cnZlLkZwLk9SREVSIH0sXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/edwards.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/edwards.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   twistedEdwards: function() { return /* binding */ twistedEdwards; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Twisted Edwards curve. The formula is: ax² + y² = 1 + dx²y²\n\n\n\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(curve, {\n        hash: 'function',\n        a: 'bigint',\n        d: 'bigint',\n        randomBytes: 'function',\n    }, {\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        uvRatio: 'function',\n        mapToCurve: 'function',\n    });\n    // Set defaults\n    return Object.freeze({ ...opts });\n}\n// It is not generic twisted curve for now, but ed25519/ed448 generic implementation\nfunction twistedEdwards(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER, prehash: prehash, hash: cHash, randomBytes, nByteLength, h: cofactor, } = CURVE;\n    const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n    const modP = Fp.create; // Function overrides\n    // sqrt(u/v)\n    const uvRatio = CURVE.uvRatio ||\n        ((u, v) => {\n            try {\n                return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n            }\n            catch (e) {\n                return { isValid: false, value: _0n };\n            }\n        });\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes); // NOOP\n    const domain = CURVE.domain ||\n        ((data, ctx, phflag) => {\n            if (ctx.length || phflag)\n                throw new Error('Contexts/pre-hash are not supported');\n            return data;\n        }); // NOOP\n    const inBig = (n) => typeof n === 'bigint' && _0n < n; // n in [1..]\n    const inRange = (n, max) => inBig(n) && inBig(max) && n < max; // n in [1..max-1]\n    const in0MaskRange = (n) => n === _0n || inRange(n, MASK); // n in [0..MASK-1]\n    function assertInRange(n, max) {\n        // n in [1..max-1]\n        if (inRange(n, max))\n            return n;\n        throw new Error(`Expected valid scalar < ${max}, got ${typeof n} ${n}`);\n    }\n    function assertGE0(n) {\n        // n in [0..CURVE_ORDER-1]\n        return n === _0n ? n : assertInRange(n, CURVE_ORDER); // GE = prime subgroup, not full group\n    }\n    const pointPrecomputes = new Map();\n    function isPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ExtendedPoint expected');\n    }\n    // Extended Point works in extended coordinates: (x, y, z, t) ∋ (x=x/z, y=y/z, t=xy).\n    // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n    class Point {\n        constructor(ex, ey, ez, et) {\n            this.ex = ex;\n            this.ey = ey;\n            this.ez = ez;\n            this.et = et;\n            if (!in0MaskRange(ex))\n                throw new Error('x required');\n            if (!in0MaskRange(ey))\n                throw new Error('y required');\n            if (!in0MaskRange(ez))\n                throw new Error('z required');\n            if (!in0MaskRange(et))\n                throw new Error('t required');\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        static fromAffine(p) {\n            if (p instanceof Point)\n                throw new Error('extended point not allowed');\n            const { x, y } = p || {};\n            if (!in0MaskRange(x) || !in0MaskRange(y))\n                throw new Error('invalid affine point');\n            return new Point(x, y, _1n, modP(x * y));\n        }\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.ez));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // Not required for fromHex(), which always creates valid points.\n        // Could be useful for fromAffine().\n        assertValidity() {\n            const { a, d } = CURVE;\n            if (this.is0())\n                throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n            // Equation in affine coordinates: ax² + y² = 1 + dx²y²\n            // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX² + Y²)Z² = Z⁴ + dX²Y²\n            const { ex: X, ey: Y, ez: Z, et: T } = this;\n            const X2 = modP(X * X); // X²\n            const Y2 = modP(Y * Y); // Y²\n            const Z2 = modP(Z * Z); // Z²\n            const Z4 = modP(Z2 * Z2); // Z⁴\n            const aX2 = modP(X2 * a); // aX²\n            const left = modP(Z2 * modP(aX2 + Y2)); // (aX² + Y²)Z²\n            const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z⁴ + dX²Y²\n            if (left !== right)\n                throw new Error('bad point: equation left != right (1)');\n            // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n            const XY = modP(X * Y);\n            const ZT = modP(Z * T);\n            if (XY !== ZT)\n                throw new Error('bad point: equation left != right (2)');\n        }\n        // Compare one point to another.\n        equals(other) {\n            isPoint(other);\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2 } = other;\n            const X1Z2 = modP(X1 * Z2);\n            const X2Z1 = modP(X2 * Z1);\n            const Y1Z2 = modP(Y1 * Z2);\n            const Y2Z1 = modP(Y2 * Z1);\n            return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        negate() {\n            // Flips point sign to a negative one (-x, y in affine coords)\n            return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n        }\n        // Fast algo for doubling Extended Point.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n        // Cost: 4M + 4S + 1*a + 6add + 1*2.\n        double() {\n            const { a } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1 } = this;\n            const A = modP(X1 * X1); // A = X12\n            const B = modP(Y1 * Y1); // B = Y12\n            const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n            const D = modP(a * A); // D = a*A\n            const x1y1 = X1 + Y1;\n            const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n            const G = D + B; // G = D+B\n            const F = G - C; // F = G-C\n            const H = D - B; // H = D-B\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        // Fast algo for adding 2 Extended Points.\n        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n        // Cost: 9M + 1*a + 1*d + 7add.\n        add(other) {\n            isPoint(other);\n            const { a, d } = CURVE;\n            const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n            const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n            // Faster algo for adding 2 Extended Points when curve's a=-1.\n            // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n            // Cost: 8M + 8add + 2*2.\n            // Note: It does not check whether the `other` point is valid.\n            if (a === BigInt(-1)) {\n                const A = modP((Y1 - X1) * (Y2 + X2));\n                const B = modP((Y1 + X1) * (Y2 - X2));\n                const F = modP(B - A);\n                if (F === _0n)\n                    return this.double(); // Same point. Tests say it doesn't affect timing\n                const C = modP(Z1 * _2n * T2);\n                const D = modP(T1 * _2n * Z2);\n                const E = D + C;\n                const G = B + A;\n                const H = D - C;\n                const X3 = modP(E * F);\n                const Y3 = modP(G * H);\n                const T3 = modP(E * H);\n                const Z3 = modP(F * G);\n                return new Point(X3, Y3, Z3, T3);\n            }\n            const A = modP(X1 * X2); // A = X1*X2\n            const B = modP(Y1 * Y2); // B = Y1*Y2\n            const C = modP(T1 * d * T2); // C = T1*d*T2\n            const D = modP(Z1 * Z2); // D = Z1*Z2\n            const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n            const F = D - C; // F = D-C\n            const G = D + C; // G = D+C\n            const H = modP(B - a * A); // H = B-a*A\n            const X3 = modP(E * F); // X3 = E*F\n            const Y3 = modP(G * H); // Y3 = G*H\n            const T3 = modP(E * H); // T3 = E*H\n            const Z3 = modP(F * G); // Z3 = F*G\n            return new Point(X3, Y3, Z3, T3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, Point.normalizeZ);\n        }\n        // Constant-time multiplication.\n        multiply(scalar) {\n            const { p, f } = this.wNAF(assertInRange(scalar, CURVE_ORDER));\n            return Point.normalizeZ([p, f])[0];\n        }\n        // Non-constant-time multiplication. Uses double-and-add algorithm.\n        // It's faster, but should only be used when you don't care about\n        // an exposed private key e.g. sig verification.\n        // Does NOT allow scalars higher than CURVE.n.\n        multiplyUnsafe(scalar) {\n            let n = assertGE0(scalar); // 0 <= scalar < CURVE.n\n            if (n === _0n)\n                return I;\n            if (this.equals(I) || n === _1n)\n                return this;\n            if (this.equals(G))\n                return this.wNAF(n).p;\n            return wnaf.unsafeLadder(this, n);\n        }\n        // Checks if point is of small order.\n        // If you add something to small order point, you will have \"dirty\"\n        // point with torsion component.\n        // Multiplies point by cofactor and checks if the result is 0.\n        isSmallOrder() {\n            return this.multiplyUnsafe(cofactor).is0();\n        }\n        // Multiplies point by curve order and checks if the result is 0.\n        // Returns `false` is the point is dirty.\n        isTorsionFree() {\n            return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n        }\n        // Converts Extended point to default (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        toAffine(iz) {\n            const { ex: x, ey: y, ez: z } = this;\n            const is0 = this.is0();\n            if (iz == null)\n                iz = is0 ? _8n : Fp.inv(z); // 8 was chosen arbitrarily\n            const ax = modP(x * iz);\n            const ay = modP(y * iz);\n            const zz = modP(z * iz);\n            if (is0)\n                return { x: _0n, y: _1n };\n            if (zz !== _1n)\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        clearCofactor() {\n            const { h: cofactor } = CURVE;\n            if (cofactor === _1n)\n                return this;\n            return this.multiplyUnsafe(cofactor);\n        }\n        // Converts hash string or Uint8Array to Point.\n        // Uses algo from RFC8032 5.1.3.\n        static fromHex(hex, zip215 = false) {\n            const { d, a } = CURVE;\n            const len = Fp.BYTES;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex, len); // copy hex to a new array\n            const normed = hex.slice(); // copy again, we'll manipulate it\n            const lastByte = hex[len - 1]; // select last byte\n            normed[len - 1] = lastByte & ~0x80; // clear last bit\n            const y = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(normed);\n            if (y === _0n) {\n                // y=0 is allowed\n            }\n            else {\n                // RFC8032 prohibits >= p, but ZIP215 doesn't\n                if (zip215)\n                    assertInRange(y, MASK); // zip215=true [1..P-1] (2^255-19-1 for ed25519)\n                else\n                    assertInRange(y, Fp.ORDER); // zip215=false [1..MASK-1] (2^256-1 for ed25519)\n            }\n            // Ed25519: x² = (y²-1)/(dy²+1) mod p. Ed448: x² = (y²-1)/(dy²-1) mod p. Generic case:\n            // ax²+y²=1+dx²y² => y²-1=dx²y²-ax² => y²-1=x²(dy²-a) => x²=(y²-1)/(dy²-a)\n            const y2 = modP(y * y); // denominator is always non-0 mod p.\n            const u = modP(y2 - _1n); // u = y² - 1\n            const v = modP(d * y2 - a); // v = d y² + 1.\n            let { isValid, value: x } = uvRatio(u, v); // √(u/v)\n            if (!isValid)\n                throw new Error('Point.fromHex: invalid y coordinate');\n            const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n            const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n            if (!zip215 && x === _0n && isLastByteOdd)\n                // if x=0 and x_0 = 1, fail\n                throw new Error('Point.fromHex: x=0 and x_0=1');\n            if (isLastByteOdd !== isXOdd)\n                x = modP(-x); // if x_0 != x mod 2, set x = p-x\n            return Point.fromAffine({ x, y });\n        }\n        static fromPrivateKey(privKey) {\n            return getExtendedPublicKey(privKey).point;\n        }\n        toRawBytes() {\n            const { x, y } = this.toAffine();\n            const bytes = _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n            bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n            return bytes; // and use the last byte to encode sign of x\n        }\n        toHex() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    Point.ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    const { BASE: G, ZERO: I } = Point;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, nByteLength * 8);\n    function modN(a) {\n        return (0,_modular_js__WEBPACK_IMPORTED_MODULE_2__.mod)(a, CURVE_ORDER);\n    }\n    // Little-endian SHA512 with modulo n\n    function modN_LE(hash) {\n        return modN(_utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(hash));\n    }\n    /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n    function getExtendedPublicKey(key) {\n        const len = nByteLength;\n        key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, len);\n        // Hash private key with curve's hash function to produce uniformingly random input\n        // Check byte lengths: ensure(64, h(ensure(32, key)))\n        const hashed = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('hashed private key', cHash(key), 2 * len);\n        const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n        const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n        const scalar = modN_LE(head); // The actual private scalar\n        const point = G.multiply(scalar); // Point on Edwards curve aka public key\n        const pointBytes = point.toRawBytes(); // Uint8Array representation\n        return { head, prefix, scalar, point, pointBytes };\n    }\n    // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n    function getPublicKey(privKey) {\n        return getExtendedPublicKey(privKey).pointBytes;\n    }\n    // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n    function hashDomainToScalar(context = new Uint8Array(), ...msgs) {\n        const msg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...msgs);\n        return modN_LE(cHash(domain(msg, (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('context', context), !!prehash)));\n    }\n    /** Signs message with privateKey. RFC8032 5.1.6 */\n    function sign(msg, privKey, options = {}) {\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph etc.\n        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n        const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n        const R = G.multiply(r).toRawBytes(); // R = rG\n        const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n        const s = modN(r + k * scalar); // S = (r + k * s) mod L\n        assertGE0(s); // 0 <= s < l\n        const res = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(R, _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesLE(s, Fp.BYTES));\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('result', res, nByteLength * 2); // 64-byte signature\n    }\n    const verifyOpts = VERIFY_DEFAULT;\n    function verify(sig, msg, publicKey, options = verifyOpts) {\n        const { context, zip215 } = options;\n        const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n        sig = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('signature', sig, 2 * len); // An extended group equation is checked.\n        msg = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('message', msg);\n        if (prehash)\n            msg = prehash(msg); // for ed25519ph, etc\n        const s = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberLE(sig.slice(len, 2 * len));\n        // zip215: true is good for consensus-critical apps and allows points < 2^256\n        // zip215: false follows RFC8032 / NIST186-5 and restricts points to CURVE.p\n        let A, R, SB;\n        try {\n            A = Point.fromHex(publicKey, zip215);\n            R = Point.fromHex(sig.slice(0, len), zip215);\n            SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n        }\n        catch (error) {\n            return false;\n        }\n        if (!zip215 && A.isSmallOrder())\n            return false;\n        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n        const RkA = R.add(A.multiplyUnsafe(k));\n        // [8][S]B = [8]R + [8][k]A'\n        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n    }\n    G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n    const utils = {\n        getExtendedPublicKey,\n        // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n        randomPrivateKey: () => randomBytes(Fp.BYTES),\n        /**\n         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n         * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n         * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n         * @param windowSize 2, 4, 8, 16\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3));\n            return point;\n        },\n    };\n    return {\n        CURVE,\n        getPublicKey,\n        sign,\n        verify,\n        ExtendedPoint: Point,\n        utils,\n    };\n}\n//# sourceMappingURL=edwards.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9lZHdhcmRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTtBQUNBO0FBQ21DO0FBQ0Y7QUFDUTtBQUNRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCLHdEQUFhO0FBQzlCLElBQUkscURBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMkJBQTJCLFNBQVM7QUFDcEM7QUFDQTtBQUNPO0FBQ1A7QUFDQSxZQUFZLDRGQUE0RjtBQUN4RztBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsU0FBUztBQUNULDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxHQUFHO0FBQ1osMkRBQTJEO0FBQzNELG1FQUFtRTtBQUNuRSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsSUFBSSxRQUFRLFVBQVUsRUFBRSxFQUFFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBLG9EQUFv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cmFjdC9lZHdhcmRzLmpzPzQ5NWUiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gVHdpc3RlZCBFZHdhcmRzIGN1cnZlLiBUaGUgZm9ybXVsYSBpczogYXjCsiArIHnCsiA9IDEgKyBkeMKyecKyXG5pbXBvcnQgeyBtb2QgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0ICogYXMgdXQgZnJvbSAnLi91dGlscy5qcyc7XG5pbXBvcnQgeyBlbnN1cmVCeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgd05BRiwgdmFsaWRhdGVCYXNpYyB9IGZyb20gJy4vY3VydmUuanMnO1xuLy8gQmUgZnJpZW5kbHkgdG8gYmFkIEVDTUFTY3JpcHQgcGFyc2VycyBieSBub3QgdXNpbmcgYmlnaW50IGxpdGVyYWxzXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKSwgXzFuID0gQmlnSW50KDEpLCBfMm4gPSBCaWdJbnQoMiksIF84biA9IEJpZ0ludCg4KTtcbi8vIHZlcmlmaWNhdGlvbiBydWxlIGlzIGVpdGhlciB6aXAyMTUgb3IgcmZjODAzMiAvIG5pc3QxODYtNS4gQ29uc3VsdCBmcm9tSGV4OlxuY29uc3QgVkVSSUZZX0RFRkFVTFQgPSB7IHppcDIxNTogdHJ1ZSB9O1xuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XG4gICAgICAgIGhhc2g6ICdmdW5jdGlvbicsXG4gICAgICAgIGE6ICdiaWdpbnQnLFxuICAgICAgICBkOiAnYmlnaW50JyxcbiAgICAgICAgcmFuZG9tQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgfSwge1xuICAgICAgICBhZGp1c3RTY2FsYXJCeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgZG9tYWluOiAnZnVuY3Rpb24nLFxuICAgICAgICB1dlJhdGlvOiAnZnVuY3Rpb24nLFxuICAgICAgICBtYXBUb0N1cnZlOiAnZnVuY3Rpb24nLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4ub3B0cyB9KTtcbn1cbi8vIEl0IGlzIG5vdCBnZW5lcmljIHR3aXN0ZWQgY3VydmUgZm9yIG5vdywgYnV0IGVkMjU1MTkvZWQ0NDggZ2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuZXhwb3J0IGZ1bmN0aW9uIHR3aXN0ZWRFZHdhcmRzKGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSLCBwcmVoYXNoOiBwcmVoYXNoLCBoYXNoOiBjSGFzaCwgcmFuZG9tQnl0ZXMsIG5CeXRlTGVuZ3RoLCBoOiBjb2ZhY3RvciwgfSA9IENVUlZFO1xuICAgIGNvbnN0IE1BU0sgPSBfMm4gPDwgKEJpZ0ludChuQnl0ZUxlbmd0aCAqIDgpIC0gXzFuKTtcbiAgICBjb25zdCBtb2RQID0gRnAuY3JlYXRlOyAvLyBGdW5jdGlvbiBvdmVycmlkZXNcbiAgICAvLyBzcXJ0KHUvdilcbiAgICBjb25zdCB1dlJhdGlvID0gQ1VSVkUudXZSYXRpbyB8fFxuICAgICAgICAoKHUsIHYpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogdHJ1ZSwgdmFsdWU6IEZwLnNxcnQodSAqIEZwLmludih2KSkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogZmFsc2UsIHZhbHVlOiBfMG4gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgY29uc3QgYWRqdXN0U2NhbGFyQnl0ZXMgPSBDVVJWRS5hZGp1c3RTY2FsYXJCeXRlcyB8fCAoKGJ5dGVzKSA9PiBieXRlcyk7IC8vIE5PT1BcbiAgICBjb25zdCBkb21haW4gPSBDVVJWRS5kb21haW4gfHxcbiAgICAgICAgKChkYXRhLCBjdHgsIHBoZmxhZykgPT4ge1xuICAgICAgICAgICAgaWYgKGN0eC5sZW5ndGggfHwgcGhmbGFnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGV4dHMvcHJlLWhhc2ggYXJlIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9KTsgLy8gTk9PUFxuICAgIGNvbnN0IGluQmlnID0gKG4pID0+IHR5cGVvZiBuID09PSAnYmlnaW50JyAmJiBfMG4gPCBuOyAvLyBuIGluIFsxLi5dXG4gICAgY29uc3QgaW5SYW5nZSA9IChuLCBtYXgpID0+IGluQmlnKG4pICYmIGluQmlnKG1heCkgJiYgbiA8IG1heDsgLy8gbiBpbiBbMS4ubWF4LTFdXG4gICAgY29uc3QgaW4wTWFza1JhbmdlID0gKG4pID0+IG4gPT09IF8wbiB8fCBpblJhbmdlKG4sIE1BU0spOyAvLyBuIGluIFswLi5NQVNLLTFdXG4gICAgZnVuY3Rpb24gYXNzZXJ0SW5SYW5nZShuLCBtYXgpIHtcbiAgICAgICAgLy8gbiBpbiBbMS4ubWF4LTFdXG4gICAgICAgIGlmIChpblJhbmdlKG4sIG1heCkpXG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCB2YWxpZCBzY2FsYXIgPCAke21heH0sIGdvdCAke3R5cGVvZiBufSAke259YCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEdFMChuKSB7XG4gICAgICAgIC8vIG4gaW4gWzAuLkNVUlZFX09SREVSLTFdXG4gICAgICAgIHJldHVybiBuID09PSBfMG4gPyBuIDogYXNzZXJ0SW5SYW5nZShuLCBDVVJWRV9PUkRFUik7IC8vIEdFID0gcHJpbWUgc3ViZ3JvdXAsIG5vdCBmdWxsIGdyb3VwXG4gICAgfVxuICAgIGNvbnN0IHBvaW50UHJlY29tcHV0ZXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gaXNQb2ludChvdGhlcikge1xuICAgICAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFBvaW50KSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXh0ZW5kZWRQb2ludCBleHBlY3RlZCcpO1xuICAgIH1cbiAgICAvLyBFeHRlbmRlZCBQb2ludCB3b3JrcyBpbiBleHRlbmRlZCBjb29yZGluYXRlczogKHgsIHksIHosIHQpIOKIiyAoeD14L3osIHk9eS96LCB0PXh5KS5cbiAgICAvLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ud2lzdGVkX0Vkd2FyZHNfY3VydmUjRXh0ZW5kZWRfY29vcmRpbmF0ZXNcbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKGV4LCBleSwgZXosIGV0KSB7XG4gICAgICAgICAgICB0aGlzLmV4ID0gZXg7XG4gICAgICAgICAgICB0aGlzLmV5ID0gZXk7XG4gICAgICAgICAgICB0aGlzLmV6ID0gZXo7XG4gICAgICAgICAgICB0aGlzLmV0ID0gZXQ7XG4gICAgICAgICAgICBpZiAoIWluME1hc2tSYW5nZShleCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd4IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAoIWluME1hc2tSYW5nZShleSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd5IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAoIWluME1hc2tSYW5nZShleikpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd6IHJlcXVpcmVkJyk7XG4gICAgICAgICAgICBpZiAoIWluME1hc2tSYW5nZShldCkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0IHJlcXVpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgaWYgKHAgaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2V4dGVuZGVkIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHAgfHwge307XG4gICAgICAgICAgICBpZiAoIWluME1hc2tSYW5nZSh4KSB8fCAhaW4wTWFza1JhbmdlKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoeCwgeSwgXzFuLCBtb2RQKHggKiB5KSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIG5vcm1hbGl6ZVoocG9pbnRzKSB7XG4gICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKHBvaW50cy5tYXAoKHApID0+IHAuZXopKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHMubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vdCByZXF1aXJlZCBmb3IgZnJvbUhleCgpLCB3aGljaCBhbHdheXMgY3JlYXRlcyB2YWxpZCBwb2ludHMuXG4gICAgICAgIC8vIENvdWxkIGJlIHVzZWZ1bCBmb3IgZnJvbUFmZmluZSgpLlxuICAgICAgICBhc3NlcnRWYWxpZGl0eSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAodGhpcy5pczAoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogWkVSTycpOyAvLyBUT0RPOiBvcHRpbWl6ZSwgd2l0aCB2YXJzIGJlbG93P1xuICAgICAgICAgICAgLy8gRXF1YXRpb24gaW4gYWZmaW5lIGNvb3JkaW5hdGVzOiBheMKyICsgecKyID0gMSArIGR4wrJ5wrJcbiAgICAgICAgICAgIC8vIEVxdWF0aW9uIGluIHByb2plY3RpdmUgY29vcmRpbmF0ZXMgKFgvWiwgWS9aLCBaKTogIChhWMKyICsgWcKyKVrCsiA9IFrigbQgKyBkWMKyWcKyXG4gICAgICAgICAgICBjb25zdCB7IGV4OiBYLCBleTogWSwgZXo6IFosIGV0OiBUIH0gPSB0aGlzO1xuICAgICAgICAgICAgY29uc3QgWDIgPSBtb2RQKFggKiBYKTsgLy8gWMKyXG4gICAgICAgICAgICBjb25zdCBZMiA9IG1vZFAoWSAqIFkpOyAvLyBZwrJcbiAgICAgICAgICAgIGNvbnN0IFoyID0gbW9kUChaICogWik7IC8vIFrCslxuICAgICAgICAgICAgY29uc3QgWjQgPSBtb2RQKFoyICogWjIpOyAvLyBa4oG0XG4gICAgICAgICAgICBjb25zdCBhWDIgPSBtb2RQKFgyICogYSk7IC8vIGFYwrJcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBtb2RQKFoyICogbW9kUChhWDIgKyBZMikpOyAvLyAoYVjCsiArIFnCsilawrJcbiAgICAgICAgICAgIGNvbnN0IHJpZ2h0ID0gbW9kUChaNCArIG1vZFAoZCAqIG1vZFAoWDIgKiBZMikpKTsgLy8gWuKBtCArIGRYwrJZwrJcbiAgICAgICAgICAgIGlmIChsZWZ0ICE9PSByaWdodClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCAoMSknKTtcbiAgICAgICAgICAgIC8vIEluIEV4dGVuZGVkIGNvb3JkaW5hdGVzIHdlIGFsc28gaGF2ZSBULCB3aGljaCBpcyB4Knk9VC9aOiBjaGVjayBYKlkgPT0gWipUXG4gICAgICAgICAgICBjb25zdCBYWSA9IG1vZFAoWCAqIFkpO1xuICAgICAgICAgICAgY29uc3QgWlQgPSBtb2RQKFogKiBUKTtcbiAgICAgICAgICAgIGlmIChYWSAhPT0gWlQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQgKDIpJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcGFyZSBvbmUgcG9pbnQgdG8gYW5vdGhlci5cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBpc1BvaW50KG90aGVyKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZXg6IFgxLCBleTogWTEsIGV6OiBaMSB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IHsgZXg6IFgyLCBleTogWTIsIGV6OiBaMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICBjb25zdCBYMVoyID0gbW9kUChYMSAqIFoyKTtcbiAgICAgICAgICAgIGNvbnN0IFgyWjEgPSBtb2RQKFgyICogWjEpO1xuICAgICAgICAgICAgY29uc3QgWTFaMiA9IG1vZFAoWTEgKiBaMik7XG4gICAgICAgICAgICBjb25zdCBZMloxID0gbW9kUChZMiAqIFoxKTtcbiAgICAgICAgICAgIHJldHVybiBYMVoyID09PSBYMloxICYmIFkxWjIgPT09IFkyWjE7XG4gICAgICAgIH1cbiAgICAgICAgaXMwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXF1YWxzKFBvaW50LlpFUk8pO1xuICAgICAgICB9XG4gICAgICAgIG5lZ2F0ZSgpIHtcbiAgICAgICAgICAgIC8vIEZsaXBzIHBvaW50IHNpZ24gdG8gYSBuZWdhdGl2ZSBvbmUgKC14LCB5IGluIGFmZmluZSBjb29yZHMpXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KG1vZFAoLXRoaXMuZXgpLCB0aGlzLmV5LCB0aGlzLmV6LCBtb2RQKC10aGlzLmV0KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFzdCBhbGdvIGZvciBkb3VibGluZyBFeHRlbmRlZCBQb2ludC5cbiAgICAgICAgLy8gaHR0cHM6Ly9oeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tdHdpc3RlZC1leHRlbmRlZC5odG1sI2RvdWJsaW5nLWRibC0yMDA4LWh3Y2RcbiAgICAgICAgLy8gQ29zdDogNE0gKyA0UyArIDEqYSArIDZhZGQgKyAxKjIuXG4gICAgICAgIGRvdWJsZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCB7IGV4OiBYMSwgZXk6IFkxLCBlejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBBID0gbW9kUChYMSAqIFgxKTsgLy8gQSA9IFgxMlxuICAgICAgICAgICAgY29uc3QgQiA9IG1vZFAoWTEgKiBZMSk7IC8vIEIgPSBZMTJcbiAgICAgICAgICAgIGNvbnN0IEMgPSBtb2RQKF8ybiAqIG1vZFAoWjEgKiBaMSkpOyAvLyBDID0gMipaMTJcbiAgICAgICAgICAgIGNvbnN0IEQgPSBtb2RQKGEgKiBBKTsgLy8gRCA9IGEqQVxuICAgICAgICAgICAgY29uc3QgeDF5MSA9IFgxICsgWTE7XG4gICAgICAgICAgICBjb25zdCBFID0gbW9kUChtb2RQKHgxeTEgKiB4MXkxKSAtIEEgLSBCKTsgLy8gRSA9IChYMStZMSkyLUEtQlxuICAgICAgICAgICAgY29uc3QgRyA9IEQgKyBCOyAvLyBHID0gRCtCXG4gICAgICAgICAgICBjb25zdCBGID0gRyAtIEM7IC8vIEYgPSBHLUNcbiAgICAgICAgICAgIGNvbnN0IEggPSBEIC0gQjsgLy8gSCA9IEQtQlxuICAgICAgICAgICAgY29uc3QgWDMgPSBtb2RQKEUgKiBGKTsgLy8gWDMgPSBFKkZcbiAgICAgICAgICAgIGNvbnN0IFkzID0gbW9kUChHICogSCk7IC8vIFkzID0gRypIXG4gICAgICAgICAgICBjb25zdCBUMyA9IG1vZFAoRSAqIEgpOyAvLyBUMyA9IEUqSFxuICAgICAgICAgICAgY29uc3QgWjMgPSBtb2RQKEYgKiBHKTsgLy8gWjMgPSBGKkdcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMywgVDMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhc3QgYWxnbyBmb3IgYWRkaW5nIDIgRXh0ZW5kZWQgUG9pbnRzLlxuICAgICAgICAvLyBodHRwczovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLmh0bWwjYWRkaXRpb24tYWRkLTIwMDgtaHdjZFxuICAgICAgICAvLyBDb3N0OiA5TSArIDEqYSArIDEqZCArIDdhZGQuXG4gICAgICAgIGFkZChvdGhlcikge1xuICAgICAgICAgICAgaXNQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IGEsIGQgfSA9IENVUlZFO1xuICAgICAgICAgICAgY29uc3QgeyBleDogWDEsIGV5OiBZMSwgZXo6IFoxLCBldDogVDEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGV4OiBYMiwgZXk6IFkyLCBlejogWjIsIGV0OiBUMiB9ID0gb3RoZXI7XG4gICAgICAgICAgICAvLyBGYXN0ZXIgYWxnbyBmb3IgYWRkaW5nIDIgRXh0ZW5kZWQgUG9pbnRzIHdoZW4gY3VydmUncyBhPS0xLlxuICAgICAgICAgICAgLy8gaHR0cDovL2h5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by10d2lzdGVkLWV4dGVuZGVkLTEuaHRtbCNhZGRpdGlvbi1hZGQtMjAwOC1od2NkLTRcbiAgICAgICAgICAgIC8vIENvc3Q6IDhNICsgOGFkZCArIDIqMi5cbiAgICAgICAgICAgIC8vIE5vdGU6IEl0IGRvZXMgbm90IGNoZWNrIHdoZXRoZXIgdGhlIGBvdGhlcmAgcG9pbnQgaXMgdmFsaWQuXG4gICAgICAgICAgICBpZiAoYSA9PT0gQmlnSW50KC0xKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IEEgPSBtb2RQKChZMSAtIFgxKSAqIChZMiArIFgyKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgQiA9IG1vZFAoKFkxICsgWDEpICogKFkyIC0gWDIpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBGID0gbW9kUChCIC0gQSk7XG4gICAgICAgICAgICAgICAgaWYgKEYgPT09IF8wbilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG91YmxlKCk7IC8vIFNhbWUgcG9pbnQuIFRlc3RzIHNheSBpdCBkb2Vzbid0IGFmZmVjdCB0aW1pbmdcbiAgICAgICAgICAgICAgICBjb25zdCBDID0gbW9kUChaMSAqIF8ybiAqIFQyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBEID0gbW9kUChUMSAqIF8ybiAqIFoyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBFID0gRCArIEM7XG4gICAgICAgICAgICAgICAgY29uc3QgRyA9IEIgKyBBO1xuICAgICAgICAgICAgICAgIGNvbnN0IEggPSBEIC0gQztcbiAgICAgICAgICAgICAgICBjb25zdCBYMyA9IG1vZFAoRSAqIEYpO1xuICAgICAgICAgICAgICAgIGNvbnN0IFkzID0gbW9kUChHICogSCk7XG4gICAgICAgICAgICAgICAgY29uc3QgVDMgPSBtb2RQKEUgKiBIKTtcbiAgICAgICAgICAgICAgICBjb25zdCBaMyA9IG1vZFAoRiAqIEcpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMywgVDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgQSA9IG1vZFAoWDEgKiBYMik7IC8vIEEgPSBYMSpYMlxuICAgICAgICAgICAgY29uc3QgQiA9IG1vZFAoWTEgKiBZMik7IC8vIEIgPSBZMSpZMlxuICAgICAgICAgICAgY29uc3QgQyA9IG1vZFAoVDEgKiBkICogVDIpOyAvLyBDID0gVDEqZCpUMlxuICAgICAgICAgICAgY29uc3QgRCA9IG1vZFAoWjEgKiBaMik7IC8vIEQgPSBaMSpaMlxuICAgICAgICAgICAgY29uc3QgRSA9IG1vZFAoKFgxICsgWTEpICogKFgyICsgWTIpIC0gQSAtIEIpOyAvLyBFID0gKFgxK1kxKSooWDIrWTIpLUEtQlxuICAgICAgICAgICAgY29uc3QgRiA9IEQgLSBDOyAvLyBGID0gRC1DXG4gICAgICAgICAgICBjb25zdCBHID0gRCArIEM7IC8vIEcgPSBEK0NcbiAgICAgICAgICAgIGNvbnN0IEggPSBtb2RQKEIgLSBhICogQSk7IC8vIEggPSBCLWEqQVxuICAgICAgICAgICAgY29uc3QgWDMgPSBtb2RQKEUgKiBGKTsgLy8gWDMgPSBFKkZcbiAgICAgICAgICAgIGNvbnN0IFkzID0gbW9kUChHICogSCk7IC8vIFkzID0gRypIXG4gICAgICAgICAgICBjb25zdCBUMyA9IG1vZFAoRSAqIEgpOyAvLyBUMyA9IEUqSFxuICAgICAgICAgICAgY29uc3QgWjMgPSBtb2RQKEYgKiBHKTsgLy8gWjMgPSBGKkdcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMywgVDMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHdOQUYobikge1xuICAgICAgICAgICAgcmV0dXJuIHduYWYud05BRkNhY2hlZCh0aGlzLCBwb2ludFByZWNvbXB1dGVzLCBuLCBQb2ludC5ub3JtYWxpemVaKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICBtdWx0aXBseShzY2FsYXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcCwgZiB9ID0gdGhpcy53TkFGKGFzc2VydEluUmFuZ2Uoc2NhbGFyLCBDVVJWRV9PUkRFUikpO1xuICAgICAgICAgICAgcmV0dXJuIFBvaW50Lm5vcm1hbGl6ZVooW3AsIGZdKVswXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb24tY29uc3RhbnQtdGltZSBtdWx0aXBsaWNhdGlvbi4gVXNlcyBkb3VibGUtYW5kLWFkZCBhbGdvcml0aG0uXG4gICAgICAgIC8vIEl0J3MgZmFzdGVyLCBidXQgc2hvdWxkIG9ubHkgYmUgdXNlZCB3aGVuIHlvdSBkb24ndCBjYXJlIGFib3V0XG4gICAgICAgIC8vIGFuIGV4cG9zZWQgcHJpdmF0ZSBrZXkgZS5nLiBzaWcgdmVyaWZpY2F0aW9uLlxuICAgICAgICAvLyBEb2VzIE5PVCBhbGxvdyBzY2FsYXJzIGhpZ2hlciB0aGFuIENVUlZFLm4uXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKHNjYWxhcikge1xuICAgICAgICAgICAgbGV0IG4gPSBhc3NlcnRHRTAoc2NhbGFyKTsgLy8gMCA8PSBzY2FsYXIgPCBDVVJWRS5uXG4gICAgICAgICAgICBpZiAobiA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybiBJO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXF1YWxzKEkpIHx8IG4gPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgIGlmICh0aGlzLmVxdWFscyhHKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53TkFGKG4pLnA7XG4gICAgICAgICAgICByZXR1cm4gd25hZi51bnNhZmVMYWRkZXIodGhpcywgbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2tzIGlmIHBvaW50IGlzIG9mIHNtYWxsIG9yZGVyLlxuICAgICAgICAvLyBJZiB5b3UgYWRkIHNvbWV0aGluZyB0byBzbWFsbCBvcmRlciBwb2ludCwgeW91IHdpbGwgaGF2ZSBcImRpcnR5XCJcbiAgICAgICAgLy8gcG9pbnQgd2l0aCB0b3JzaW9uIGNvbXBvbmVudC5cbiAgICAgICAgLy8gTXVsdGlwbGllcyBwb2ludCBieSBjb2ZhY3RvciBhbmQgY2hlY2tzIGlmIHRoZSByZXN1bHQgaXMgMC5cbiAgICAgICAgaXNTbWFsbE9yZGVyKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoY29mYWN0b3IpLmlzMCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE11bHRpcGxpZXMgcG9pbnQgYnkgY3VydmUgb3JkZXIgYW5kIGNoZWNrcyBpZiB0aGUgcmVzdWx0IGlzIDAuXG4gICAgICAgIC8vIFJldHVybnMgYGZhbHNlYCBpcyB0aGUgcG9pbnQgaXMgZGlydHkuXG4gICAgICAgIGlzVG9yc2lvbkZyZWUoKSB7XG4gICAgICAgICAgICByZXR1cm4gd25hZi51bnNhZmVMYWRkZXIodGhpcywgQ1VSVkVfT1JERVIpLmlzMCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIEV4dGVuZGVkIHBvaW50IHRvIGRlZmF1bHQgKHgsIHkpIGNvb3JkaW5hdGVzLlxuICAgICAgICAvLyBDYW4gYWNjZXB0IHByZWNvbXB1dGVkIFpeLTEgLSBmb3IgZXhhbXBsZSwgZnJvbSBpbnZlcnRCYXRjaC5cbiAgICAgICAgdG9BZmZpbmUoaXopIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZXg6IHgsIGV5OiB5LCBlejogeiB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGlzMCA9IHRoaXMuaXMwKCk7XG4gICAgICAgICAgICBpZiAoaXogPT0gbnVsbClcbiAgICAgICAgICAgICAgICBpeiA9IGlzMCA/IF84biA6IEZwLmludih6KTsgLy8gOCB3YXMgY2hvc2VuIGFyYml0cmFyaWx5XG4gICAgICAgICAgICBjb25zdCBheCA9IG1vZFAoeCAqIGl6KTtcbiAgICAgICAgICAgIGNvbnN0IGF5ID0gbW9kUCh5ICogaXopO1xuICAgICAgICAgICAgY29uc3QgenogPSBtb2RQKHogKiBpeik7XG4gICAgICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IF8wbiwgeTogXzFuIH07XG4gICAgICAgICAgICBpZiAoenogIT09IF8xbilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludlogd2FzIGludmFsaWQnKTtcbiAgICAgICAgICAgIHJldHVybiB7IHg6IGF4LCB5OiBheSB9O1xuICAgICAgICB9XG4gICAgICAgIGNsZWFyQ29mYWN0b3IoKSB7XG4gICAgICAgICAgICBjb25zdCB7IGg6IGNvZmFjdG9yIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGlmIChjb2ZhY3RvciA9PT0gXzFuKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubXVsdGlwbHlVbnNhZmUoY29mYWN0b3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbnZlcnRzIGhhc2ggc3RyaW5nIG9yIFVpbnQ4QXJyYXkgdG8gUG9pbnQuXG4gICAgICAgIC8vIFVzZXMgYWxnbyBmcm9tIFJGQzgwMzIgNS4xLjMuXG4gICAgICAgIHN0YXRpYyBmcm9tSGV4KGhleCwgemlwMjE1ID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZCwgYSB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBGcC5CWVRFUztcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdwb2ludEhleCcsIGhleCwgbGVuKTsgLy8gY29weSBoZXggdG8gYSBuZXcgYXJyYXlcbiAgICAgICAgICAgIGNvbnN0IG5vcm1lZCA9IGhleC5zbGljZSgpOyAvLyBjb3B5IGFnYWluLCB3ZSdsbCBtYW5pcHVsYXRlIGl0XG4gICAgICAgICAgICBjb25zdCBsYXN0Qnl0ZSA9IGhleFtsZW4gLSAxXTsgLy8gc2VsZWN0IGxhc3QgYnl0ZVxuICAgICAgICAgICAgbm9ybWVkW2xlbiAtIDFdID0gbGFzdEJ5dGUgJiB+MHg4MDsgLy8gY2xlYXIgbGFzdCBiaXRcbiAgICAgICAgICAgIGNvbnN0IHkgPSB1dC5ieXRlc1RvTnVtYmVyTEUobm9ybWVkKTtcbiAgICAgICAgICAgIGlmICh5ID09PSBfMG4pIHtcbiAgICAgICAgICAgICAgICAvLyB5PTAgaXMgYWxsb3dlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUkZDODAzMiBwcm9oaWJpdHMgPj0gcCwgYnV0IFpJUDIxNSBkb2Vzbid0XG4gICAgICAgICAgICAgICAgaWYgKHppcDIxNSlcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0SW5SYW5nZSh5LCBNQVNLKTsgLy8gemlwMjE1PXRydWUgWzEuLlAtMV0gKDJeMjU1LTE5LTEgZm9yIGVkMjU1MTkpXG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBhc3NlcnRJblJhbmdlKHksIEZwLk9SREVSKTsgLy8gemlwMjE1PWZhbHNlIFsxLi5NQVNLLTFdICgyXjI1Ni0xIGZvciBlZDI1NTE5KVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRWQyNTUxOTogeMKyID0gKHnCsi0xKS8oZHnCsisxKSBtb2QgcC4gRWQ0NDg6IHjCsiA9ICh5wrItMSkvKGR5wrItMSkgbW9kIHAuIEdlbmVyaWMgY2FzZTpcbiAgICAgICAgICAgIC8vIGF4wrIrecKyPTErZHjCsnnCsiA9PiB5wrItMT1keMKyecKyLWF4wrIgPT4gecKyLTE9eMKyKGR5wrItYSkgPT4geMKyPSh5wrItMSkvKGR5wrItYSlcbiAgICAgICAgICAgIGNvbnN0IHkyID0gbW9kUCh5ICogeSk7IC8vIGRlbm9taW5hdG9yIGlzIGFsd2F5cyBub24tMCBtb2QgcC5cbiAgICAgICAgICAgIGNvbnN0IHUgPSBtb2RQKHkyIC0gXzFuKTsgLy8gdSA9IHnCsiAtIDFcbiAgICAgICAgICAgIGNvbnN0IHYgPSBtb2RQKGQgKiB5MiAtIGEpOyAvLyB2ID0gZCB5wrIgKyAxLlxuICAgICAgICAgICAgbGV0IHsgaXNWYWxpZCwgdmFsdWU6IHggfSA9IHV2UmF0aW8odSwgdik7IC8vIOKImih1L3YpXG4gICAgICAgICAgICBpZiAoIWlzVmFsaWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludC5mcm9tSGV4OiBpbnZhbGlkIHkgY29vcmRpbmF0ZScpO1xuICAgICAgICAgICAgY29uc3QgaXNYT2RkID0gKHggJiBfMW4pID09PSBfMW47IC8vIFRoZXJlIGFyZSAyIHNxdWFyZSByb290cy4gVXNlIHhfMCBiaXQgdG8gc2VsZWN0IHByb3BlclxuICAgICAgICAgICAgY29uc3QgaXNMYXN0Qnl0ZU9kZCA9IChsYXN0Qnl0ZSAmIDB4ODApICE9PSAwOyAvLyB4XzAsIGxhc3QgYml0XG4gICAgICAgICAgICBpZiAoIXppcDIxNSAmJiB4ID09PSBfMG4gJiYgaXNMYXN0Qnl0ZU9kZClcbiAgICAgICAgICAgICAgICAvLyBpZiB4PTAgYW5kIHhfMCA9IDEsIGZhaWxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BvaW50LmZyb21IZXg6IHg9MCBhbmQgeF8wPTEnKTtcbiAgICAgICAgICAgIGlmIChpc0xhc3RCeXRlT2RkICE9PSBpc1hPZGQpXG4gICAgICAgICAgICAgICAgeCA9IG1vZFAoLXgpOyAvLyBpZiB4XzAgIT0geCBtb2QgMiwgc2V0IHggPSBwLXhcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5mcm9tQWZmaW5lKHsgeCwgeSB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgZnJvbVByaXZhdGVLZXkocHJpdktleSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldEV4dGVuZGVkUHVibGljS2V5KHByaXZLZXkpLnBvaW50O1xuICAgICAgICB9XG4gICAgICAgIHRvUmF3Qnl0ZXMoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gdXQubnVtYmVyVG9CeXRlc0xFKHksIEZwLkJZVEVTKTsgLy8gZWFjaCB5IGhhcyAyIHggdmFsdWVzICh4LCAteSlcbiAgICAgICAgICAgIGJ5dGVzW2J5dGVzLmxlbmd0aCAtIDFdIHw9IHggJiBfMW4gPyAweDgwIDogMDsgLy8gd2hlbiBjb21wcmVzc2luZywgaXQncyBlbm91Z2ggdG8gc3RvcmUgeVxuICAgICAgICAgICAgcmV0dXJuIGJ5dGVzOyAvLyBhbmQgdXNlIHRoZSBsYXN0IGJ5dGUgdG8gZW5jb2RlIHNpZ24gb2YgeFxuICAgICAgICB9XG4gICAgICAgIHRvSGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmJ5dGVzVG9IZXgodGhpcy50b1Jhd0J5dGVzKCkpOyAvLyBTYW1lIGFzIHRvUmF3Qnl0ZXMsIGJ1dCByZXR1cm5zIHN0cmluZy5cbiAgICAgICAgfVxuICAgIH1cbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgXzFuLCBtb2RQKENVUlZFLkd4ICogQ1VSVkUuR3kpKTtcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KF8wbiwgXzFuLCBfMW4sIF8wbik7IC8vIDAsIDEsIDEsIDBcbiAgICBjb25zdCB7IEJBU0U6IEcsIFpFUk86IEkgfSA9IFBvaW50O1xuICAgIGNvbnN0IHduYWYgPSB3TkFGKFBvaW50LCBuQnl0ZUxlbmd0aCAqIDgpO1xuICAgIGZ1bmN0aW9uIG1vZE4oYSkge1xuICAgICAgICByZXR1cm4gbW9kKGEsIENVUlZFX09SREVSKTtcbiAgICB9XG4gICAgLy8gTGl0dGxlLWVuZGlhbiBTSEE1MTIgd2l0aCBtb2R1bG8gblxuICAgIGZ1bmN0aW9uIG1vZE5fTEUoaGFzaCkge1xuICAgICAgICByZXR1cm4gbW9kTih1dC5ieXRlc1RvTnVtYmVyTEUoaGFzaCkpO1xuICAgIH1cbiAgICAvKiogQ29udmVuaWVuY2UgbWV0aG9kIHRoYXQgY3JlYXRlcyBwdWJsaWMga2V5IGFuZCBvdGhlciBzdHVmZi4gUkZDODAzMiA1LjEuNSAqL1xuICAgIGZ1bmN0aW9uIGdldEV4dGVuZGVkUHVibGljS2V5KGtleSkge1xuICAgICAgICBjb25zdCBsZW4gPSBuQnl0ZUxlbmd0aDtcbiAgICAgICAga2V5ID0gZW5zdXJlQnl0ZXMoJ3ByaXZhdGUga2V5Jywga2V5LCBsZW4pO1xuICAgICAgICAvLyBIYXNoIHByaXZhdGUga2V5IHdpdGggY3VydmUncyBoYXNoIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdW5pZm9ybWluZ2x5IHJhbmRvbSBpbnB1dFxuICAgICAgICAvLyBDaGVjayBieXRlIGxlbmd0aHM6IGVuc3VyZSg2NCwgaChlbnN1cmUoMzIsIGtleSkpKVxuICAgICAgICBjb25zdCBoYXNoZWQgPSBlbnN1cmVCeXRlcygnaGFzaGVkIHByaXZhdGUga2V5JywgY0hhc2goa2V5KSwgMiAqIGxlbik7XG4gICAgICAgIGNvbnN0IGhlYWQgPSBhZGp1c3RTY2FsYXJCeXRlcyhoYXNoZWQuc2xpY2UoMCwgbGVuKSk7IC8vIGNsZWFyIGZpcnN0IGhhbGYgYml0cywgcHJvZHVjZSBGRVxuICAgICAgICBjb25zdCBwcmVmaXggPSBoYXNoZWQuc2xpY2UobGVuLCAyICogbGVuKTsgLy8gc2Vjb25kIGhhbGYgaXMgY2FsbGVkIGtleSBwcmVmaXggKDUuMS42KVxuICAgICAgICBjb25zdCBzY2FsYXIgPSBtb2ROX0xFKGhlYWQpOyAvLyBUaGUgYWN0dWFsIHByaXZhdGUgc2NhbGFyXG4gICAgICAgIGNvbnN0IHBvaW50ID0gRy5tdWx0aXBseShzY2FsYXIpOyAvLyBQb2ludCBvbiBFZHdhcmRzIGN1cnZlIGFrYSBwdWJsaWMga2V5XG4gICAgICAgIGNvbnN0IHBvaW50Qnl0ZXMgPSBwb2ludC50b1Jhd0J5dGVzKCk7IC8vIFVpbnQ4QXJyYXkgcmVwcmVzZW50YXRpb25cbiAgICAgICAgcmV0dXJuIHsgaGVhZCwgcHJlZml4LCBzY2FsYXIsIHBvaW50LCBwb2ludEJ5dGVzIH07XG4gICAgfVxuICAgIC8vIENhbGN1bGF0ZXMgRWREU0EgcHViIGtleS4gUkZDODAzMiA1LjEuNS4gUHJpdmtleSBpcyBoYXNoZWQuIFVzZSBmaXJzdCBoYWxmIHdpdGggMyBiaXRzIGNsZWFyZWRcbiAgICBmdW5jdGlvbiBnZXRQdWJsaWNLZXkocHJpdktleSkge1xuICAgICAgICByZXR1cm4gZ2V0RXh0ZW5kZWRQdWJsaWNLZXkocHJpdktleSkucG9pbnRCeXRlcztcbiAgICB9XG4gICAgLy8gaW50KCdMRScsIFNIQTUxMihkb20yKEYsIEMpIHx8IG1zZ3MpKSBtb2QgTlxuICAgIGZ1bmN0aW9uIGhhc2hEb21haW5Ub1NjYWxhcihjb250ZXh0ID0gbmV3IFVpbnQ4QXJyYXkoKSwgLi4ubXNncykge1xuICAgICAgICBjb25zdCBtc2cgPSB1dC5jb25jYXRCeXRlcyguLi5tc2dzKTtcbiAgICAgICAgcmV0dXJuIG1vZE5fTEUoY0hhc2goZG9tYWluKG1zZywgZW5zdXJlQnl0ZXMoJ2NvbnRleHQnLCBjb250ZXh0KSwgISFwcmVoYXNoKSkpO1xuICAgIH1cbiAgICAvKiogU2lnbnMgbWVzc2FnZSB3aXRoIHByaXZhdGVLZXkuIFJGQzgwMzIgNS4xLjYgKi9cbiAgICBmdW5jdGlvbiBzaWduKG1zZywgcHJpdktleSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIG1zZyA9IGVuc3VyZUJ5dGVzKCdtZXNzYWdlJywgbXNnKTtcbiAgICAgICAgaWYgKHByZWhhc2gpXG4gICAgICAgICAgICBtc2cgPSBwcmVoYXNoKG1zZyk7IC8vIGZvciBlZDI1NTE5cGggZXRjLlxuICAgICAgICBjb25zdCB7IHByZWZpeCwgc2NhbGFyLCBwb2ludEJ5dGVzIH0gPSBnZXRFeHRlbmRlZFB1YmxpY0tleShwcml2S2V5KTtcbiAgICAgICAgY29uc3QgciA9IGhhc2hEb21haW5Ub1NjYWxhcihvcHRpb25zLmNvbnRleHQsIHByZWZpeCwgbXNnKTsgLy8gciA9IGRvbTIoRiwgQykgfHwgcHJlZml4IHx8IFBIKE0pXG4gICAgICAgIGNvbnN0IFIgPSBHLm11bHRpcGx5KHIpLnRvUmF3Qnl0ZXMoKTsgLy8gUiA9IHJHXG4gICAgICAgIGNvbnN0IGsgPSBoYXNoRG9tYWluVG9TY2FsYXIob3B0aW9ucy5jb250ZXh0LCBSLCBwb2ludEJ5dGVzLCBtc2cpOyAvLyBSIHx8IEEgfHwgUEgoTSlcbiAgICAgICAgY29uc3QgcyA9IG1vZE4ociArIGsgKiBzY2FsYXIpOyAvLyBTID0gKHIgKyBrICogcykgbW9kIExcbiAgICAgICAgYXNzZXJ0R0UwKHMpOyAvLyAwIDw9IHMgPCBsXG4gICAgICAgIGNvbnN0IHJlcyA9IHV0LmNvbmNhdEJ5dGVzKFIsIHV0Lm51bWJlclRvQnl0ZXNMRShzLCBGcC5CWVRFUykpO1xuICAgICAgICByZXR1cm4gZW5zdXJlQnl0ZXMoJ3Jlc3VsdCcsIHJlcywgbkJ5dGVMZW5ndGggKiAyKTsgLy8gNjQtYnl0ZSBzaWduYXR1cmVcbiAgICB9XG4gICAgY29uc3QgdmVyaWZ5T3B0cyA9IFZFUklGWV9ERUZBVUxUO1xuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWcsIG1zZywgcHVibGljS2V5LCBvcHRpb25zID0gdmVyaWZ5T3B0cykge1xuICAgICAgICBjb25zdCB7IGNvbnRleHQsIHppcDIxNSB9ID0gb3B0aW9ucztcbiAgICAgICAgY29uc3QgbGVuID0gRnAuQllURVM7IC8vIFZlcmlmaWVzIEVkRFNBIHNpZ25hdHVyZSBhZ2FpbnN0IG1lc3NhZ2UgYW5kIHB1YmxpYyBrZXkuIFJGQzgwMzIgNS4xLjcuXG4gICAgICAgIHNpZyA9IGVuc3VyZUJ5dGVzKCdzaWduYXR1cmUnLCBzaWcsIDIgKiBsZW4pOyAvLyBBbiBleHRlbmRlZCBncm91cCBlcXVhdGlvbiBpcyBjaGVja2VkLlxuICAgICAgICBtc2cgPSBlbnN1cmVCeXRlcygnbWVzc2FnZScsIG1zZyk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnID0gcHJlaGFzaChtc2cpOyAvLyBmb3IgZWQyNTUxOXBoLCBldGNcbiAgICAgICAgY29uc3QgcyA9IHV0LmJ5dGVzVG9OdW1iZXJMRShzaWcuc2xpY2UobGVuLCAyICogbGVuKSk7XG4gICAgICAgIC8vIHppcDIxNTogdHJ1ZSBpcyBnb29kIGZvciBjb25zZW5zdXMtY3JpdGljYWwgYXBwcyBhbmQgYWxsb3dzIHBvaW50cyA8IDJeMjU2XG4gICAgICAgIC8vIHppcDIxNTogZmFsc2UgZm9sbG93cyBSRkM4MDMyIC8gTklTVDE4Ni01IGFuZCByZXN0cmljdHMgcG9pbnRzIHRvIENVUlZFLnBcbiAgICAgICAgbGV0IEEsIFIsIFNCO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgQSA9IFBvaW50LmZyb21IZXgocHVibGljS2V5LCB6aXAyMTUpO1xuICAgICAgICAgICAgUiA9IFBvaW50LmZyb21IZXgoc2lnLnNsaWNlKDAsIGxlbiksIHppcDIxNSk7XG4gICAgICAgICAgICBTQiA9IEcubXVsdGlwbHlVbnNhZmUocyk7IC8vIDAgPD0gcyA8IGwgaXMgZG9uZSBpbnNpZGVcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXppcDIxNSAmJiBBLmlzU21hbGxPcmRlcigpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBrID0gaGFzaERvbWFpblRvU2NhbGFyKGNvbnRleHQsIFIudG9SYXdCeXRlcygpLCBBLnRvUmF3Qnl0ZXMoKSwgbXNnKTtcbiAgICAgICAgY29uc3QgUmtBID0gUi5hZGQoQS5tdWx0aXBseVVuc2FmZShrKSk7XG4gICAgICAgIC8vIFs4XVtTXUIgPSBbOF1SICsgWzhdW2tdQSdcbiAgICAgICAgcmV0dXJuIFJrQS5zdWJ0cmFjdChTQikuY2xlYXJDb2ZhY3RvcigpLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICB9XG4gICAgRy5fc2V0V2luZG93U2l6ZSg4KTsgLy8gRW5hYmxlIHByZWNvbXB1dGVzLiBTbG93cyBkb3duIGZpcnN0IHB1YmxpY0tleSBjb21wdXRhdGlvbiBieSAyMG1zLlxuICAgIGNvbnN0IHV0aWxzID0ge1xuICAgICAgICBnZXRFeHRlbmRlZFB1YmxpY0tleSxcbiAgICAgICAgLy8gZWQyNTUxOSBwcml2YXRlIGtleXMgYXJlIHVuaWZvcm0gMzJiLiBObyBuZWVkIHRvIGNoZWNrIGZvciBtb2R1bG8gYmlhcywgbGlrZSBpbiBzZWNwMjU2azEuXG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IHJhbmRvbUJ5dGVzKEZwLkJZVEVTKSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdlJ3JlIGRvaW5nIHNjYWxhciBtdWx0aXBsaWNhdGlvbiAodXNlZCBpbiBnZXRQdWJsaWNLZXkgZXRjKSB3aXRoIHByZWNvbXB1dGVkIEJBU0VfUE9JTlRcbiAgICAgICAgICogdmFsdWVzLiBUaGlzIHNsb3dzIGRvd24gZmlyc3QgZ2V0UHVibGljS2V5KCkgYnkgbWlsbGlzZWNvbmRzIChzZWUgU3BlZWQgc2VjdGlvbiksXG4gICAgICAgICAqIGJ1dCBhbGxvd3MgdG8gc3BlZWQtdXAgc3Vic2VxdWVudCBnZXRQdWJsaWNLZXkoKSBjYWxscyB1cCB0byAyMHguXG4gICAgICAgICAqIEBwYXJhbSB3aW5kb3dTaXplIDIsIDQsIDgsIDE2XG4gICAgICAgICAqL1xuICAgICAgICBwcmVjb21wdXRlKHdpbmRvd1NpemUgPSA4LCBwb2ludCA9IFBvaW50LkJBU0UpIHtcbiAgICAgICAgICAgIHBvaW50Ll9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpO1xuICAgICAgICAgICAgcG9pbnQubXVsdGlwbHkoQmlnSW50KDMpKTtcbiAgICAgICAgICAgIHJldHVybiBwb2ludDtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIENVUlZFLFxuICAgICAgICBnZXRQdWJsaWNLZXksXG4gICAgICAgIHNpZ24sXG4gICAgICAgIHZlcmlmeSxcbiAgICAgICAgRXh0ZW5kZWRQb2ludDogUG9pbnQsXG4gICAgICAgIHV0aWxzLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lZHdhcmRzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/edwards.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js":
/*!******************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/hash-to-curve.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createHasher: function() { return /* binding */ createHasher; },\n/* harmony export */   expand_message_xmd: function() { return /* binding */ expand_message_xmd; },\n/* harmony export */   expand_message_xof: function() { return /* binding */ expand_message_xof; },\n/* harmony export */   hash_to_field: function() { return /* binding */ hash_to_field; },\n/* harmony export */   isogenyMap: function() { return /* binding */ isogenyMap; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = _utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE;\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value, length) {\n    if (value < 0 || value >= 1 << (8 * length)) {\n        throw new Error(`bad I2OSP call: value=${value} length=${length}`);\n    }\n    const res = Array.from({ length }).fill(0);\n    for (let i = length - 1; i >= 0; i--) {\n        res[i] = value & 0xff;\n        value >>>= 8;\n    }\n    return new Uint8Array(res);\n}\nfunction strxor(a, b) {\n    const arr = new Uint8Array(a.length);\n    for (let i = 0; i < a.length; i++) {\n        arr[i] = a[i] ^ b[i];\n    }\n    return arr;\n}\nfunction anum(item) {\n    if (!Number.isSafeInteger(item))\n        throw new Error('number expected');\n}\n// Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1\nfunction expand_message_xmd(msg, DST, lenInBytes, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    if (DST.length > 255)\n        DST = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-'), DST));\n    const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n    const ell = Math.ceil(lenInBytes / b_in_bytes);\n    if (ell > 255)\n        throw new Error('Invalid xmd length');\n    const DST_prime = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(DST, i2osp(DST.length, 1));\n    const Z_pad = i2osp(0, r_in_bytes);\n    const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n    const b = new Array(ell);\n    const b_0 = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n    b[0] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(b_0, i2osp(1, 1), DST_prime));\n    for (let i = 1; i <= ell; i++) {\n        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n        b[i] = H((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...args));\n    }\n    const pseudo_random_bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.concatBytes)(...b);\n    return pseudo_random_bytes.slice(0, lenInBytes);\n}\n// Produces a uniformly random byte string using an extendable-output function (XOF) H.\n// 1. The collision resistance of H MUST be at least k bits.\n// 2. H MUST be an XOF that has been proved indifferentiable from\n//    a random oracle under a reasonable cryptographic assumption.\n// https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2\nfunction expand_message_xof(msg, DST, lenInBytes, k, H) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(DST);\n    anum(lenInBytes);\n    // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n    // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n    if (DST.length > 255) {\n        const dkLen = Math.ceil((2 * k) / 8);\n        DST = H.create({ dkLen }).update((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)('H2C-OVERSIZE-DST-')).update(DST).digest();\n    }\n    if (lenInBytes > 65535 || DST.length > 255)\n        throw new Error('expand_message_xof: invalid lenInBytes');\n    return (H.create({ dkLen: lenInBytes })\n        .update(msg)\n        .update(i2osp(lenInBytes, 2))\n        // 2. DST_prime = DST || I2OSP(len(DST), 1)\n        .update(DST)\n        .update(i2osp(DST.length, 1))\n        .digest());\n}\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F\n * https://www.rfc-editor.org/rfc/rfc9380#section-5.2\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nfunction hash_to_field(msg, count, options) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(options, {\n        DST: 'stringOrUint8Array',\n        p: 'bigint',\n        m: 'isSafeInteger',\n        k: 'isSafeInteger',\n        hash: 'hash',\n    });\n    const { p, k, m, hash, expand, DST: _DST } = options;\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.abytes)(msg);\n    anum(count);\n    const DST = typeof _DST === 'string' ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.utf8ToBytes)(_DST) : _DST;\n    const log2p = p.toString(2).length;\n    const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n    const len_in_bytes = count * m * L;\n    let prb; // pseudo_random_bytes\n    if (expand === 'xmd') {\n        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n    }\n    else if (expand === 'xof') {\n        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n    }\n    else if (expand === '_internal_pass') {\n        // for internal tests only\n        prb = msg;\n    }\n    else {\n        throw new Error('expand must be \"xmd\" or \"xof\"');\n    }\n    const u = new Array(count);\n    for (let i = 0; i < count; i++) {\n        const e = new Array(m);\n        for (let j = 0; j < m; j++) {\n            const elm_offset = L * (j + i * m);\n            const tv = prb.subarray(elm_offset, elm_offset + L);\n            e[j] = (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(os2ip(tv), p);\n        }\n        u[i] = e;\n    }\n    return u;\n}\nfunction isogenyMap(field, map) {\n    // Make same order as in spec\n    const COEFF = map.map((i) => Array.from(i).reverse());\n    return (x, y) => {\n        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));\n        x = field.div(xNum, xDen); // xNum / xDen\n        y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n        return { x, y };\n    };\n}\nfunction createHasher(Point, mapToCurve, def) {\n    if (typeof mapToCurve !== 'function')\n        throw new Error('mapToCurve() must be defined');\n    return {\n        // Encodes byte string to elliptic curve.\n        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        hashToCurve(msg, options) {\n            const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });\n            const u0 = Point.fromAffine(mapToCurve(u[0]));\n            const u1 = Point.fromAffine(mapToCurve(u[1]));\n            const P = u0.add(u1).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n        // Encodes byte string to elliptic curve.\n        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n        encodeToCurve(msg, options) {\n            const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });\n            const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n            P.assertValidity();\n            return P;\n        },\n    };\n}\n//# sourceMappingURL=hash-to-curve.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9oYXNoLXRvLWN1cnZlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBbUM7QUFDNEQ7QUFDL0Y7QUFDQSxjQUFjLHNEQUFlO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxPQUFPLFNBQVMsT0FBTztBQUN4RTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksaURBQU07QUFDVixJQUFJLGlEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHNEQUFXLENBQUMsc0RBQVc7QUFDdkMsWUFBWSw4Q0FBOEM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNEQUFXO0FBQ2pDO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0Esa0JBQWtCLHNEQUFXO0FBQzdCLGFBQWEsc0RBQVc7QUFDeEIsb0JBQW9CLFVBQVU7QUFDOUI7QUFDQSxpQkFBaUIsc0RBQVc7QUFDNUI7QUFDQSxnQ0FBZ0Msc0RBQVc7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLElBQUksaURBQU07QUFDVixJQUFJLGlEQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPLFNBQVMsc0RBQVc7QUFDcEQ7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLG1CQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkVBQTZFO0FBQ2pHO0FBQ0E7QUFDTztBQUNQLElBQUkseURBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLG1DQUFtQztBQUMvQyxJQUFJLGlEQUFNO0FBQ1Y7QUFDQSwyQ0FBMkMsc0RBQVc7QUFDdEQ7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBLG1CQUFtQixnREFBRztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpREFBaUQ7QUFDakQsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxrQ0FBa0M7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsd0NBQXdDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanM/Yzc1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtb2QgfSBmcm9tICcuL21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb051bWJlckJFLCBhYnl0ZXMsIGNvbmNhdEJ5dGVzLCB1dGY4VG9CeXRlcywgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIE9jdGV0IFN0cmVhbSB0byBJbnRlZ2VyLiBcInNwZWNcIiBpbXBsZW1lbnRhdGlvbiBvZiBvczJpcCBpcyAyLjV4IHNsb3dlciB2cyBieXRlc1RvTnVtYmVyQkUuXG5jb25zdCBvczJpcCA9IGJ5dGVzVG9OdW1iZXJCRTtcbi8vIEludGVnZXIgdG8gT2N0ZXQgU3RyZWFtIChudW1iZXJUb0J5dGVzQkUpXG5mdW5jdGlvbiBpMm9zcCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAxIDw8ICg4ICogbGVuZ3RoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJhZCBJMk9TUCBjYWxsOiB2YWx1ZT0ke3ZhbHVlfSBsZW5ndGg9JHtsZW5ndGh9YCk7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IEFycmF5LmZyb20oeyBsZW5ndGggfSkuZmlsbCgwKTtcbiAgICBmb3IgKGxldCBpID0gbGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgcmVzW2ldID0gdmFsdWUgJiAweGZmO1xuICAgICAgICB2YWx1ZSA+Pj49IDg7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVWludDhBcnJheShyZXMpO1xufVxuZnVuY3Rpb24gc3RyeG9yKGEsIGIpIHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheShhLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFycltpXSA9IGFbaV0gXiBiW2ldO1xuICAgIH1cbiAgICByZXR1cm4gYXJyO1xufVxuZnVuY3Rpb24gYW51bShpdGVtKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihpdGVtKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdudW1iZXIgZXhwZWN0ZWQnKTtcbn1cbi8vIFByb2R1Y2VzIGEgdW5pZm9ybWx5IHJhbmRvbSBieXRlIHN0cmluZyB1c2luZyBhIGNyeXB0b2dyYXBoaWMgaGFzaCBmdW5jdGlvbiBIIHRoYXQgb3V0cHV0cyBiIGJpdHNcbi8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjFcbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbkluQnl0ZXMsIEgpIHtcbiAgICBhYnl0ZXMobXNnKTtcbiAgICBhYnl0ZXMoRFNUKTtcbiAgICBhbnVtKGxlbkluQnl0ZXMpO1xuICAgIC8vIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNS4zLjNcbiAgICBpZiAoRFNULmxlbmd0aCA+IDI1NSlcbiAgICAgICAgRFNUID0gSChjb25jYXRCeXRlcyh1dGY4VG9CeXRlcygnSDJDLU9WRVJTSVpFLURTVC0nKSwgRFNUKSk7XG4gICAgY29uc3QgeyBvdXRwdXRMZW46IGJfaW5fYnl0ZXMsIGJsb2NrTGVuOiByX2luX2J5dGVzIH0gPSBIO1xuICAgIGNvbnN0IGVsbCA9IE1hdGguY2VpbChsZW5JbkJ5dGVzIC8gYl9pbl9ieXRlcyk7XG4gICAgaWYgKGVsbCA+IDI1NSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHhtZCBsZW5ndGgnKTtcbiAgICBjb25zdCBEU1RfcHJpbWUgPSBjb25jYXRCeXRlcyhEU1QsIGkyb3NwKERTVC5sZW5ndGgsIDEpKTtcbiAgICBjb25zdCBaX3BhZCA9IGkyb3NwKDAsIHJfaW5fYnl0ZXMpO1xuICAgIGNvbnN0IGxfaV9iX3N0ciA9IGkyb3NwKGxlbkluQnl0ZXMsIDIpOyAvLyBsZW5faW5fYnl0ZXNfc3RyXG4gICAgY29uc3QgYiA9IG5ldyBBcnJheShlbGwpO1xuICAgIGNvbnN0IGJfMCA9IEgoY29uY2F0Qnl0ZXMoWl9wYWQsIG1zZywgbF9pX2Jfc3RyLCBpMm9zcCgwLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgYlswXSA9IEgoY29uY2F0Qnl0ZXMoYl8wLCBpMm9zcCgxLCAxKSwgRFNUX3ByaW1lKSk7XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gZWxsOyBpKyspIHtcbiAgICAgICAgY29uc3QgYXJncyA9IFtzdHJ4b3IoYl8wLCBiW2kgLSAxXSksIGkyb3NwKGkgKyAxLCAxKSwgRFNUX3ByaW1lXTtcbiAgICAgICAgYltpXSA9IEgoY29uY2F0Qnl0ZXMoLi4uYXJncykpO1xuICAgIH1cbiAgICBjb25zdCBwc2V1ZG9fcmFuZG9tX2J5dGVzID0gY29uY2F0Qnl0ZXMoLi4uYik7XG4gICAgcmV0dXJuIHBzZXVkb19yYW5kb21fYnl0ZXMuc2xpY2UoMCwgbGVuSW5CeXRlcyk7XG59XG4vLyBQcm9kdWNlcyBhIHVuaWZvcm1seSByYW5kb20gYnl0ZSBzdHJpbmcgdXNpbmcgYW4gZXh0ZW5kYWJsZS1vdXRwdXQgZnVuY3Rpb24gKFhPRikgSC5cbi8vIDEuIFRoZSBjb2xsaXNpb24gcmVzaXN0YW5jZSBvZiBIIE1VU1QgYmUgYXQgbGVhc3QgayBiaXRzLlxuLy8gMi4gSCBNVVNUIGJlIGFuIFhPRiB0aGF0IGhhcyBiZWVuIHByb3ZlZCBpbmRpZmZlcmVudGlhYmxlIGZyb21cbi8vICAgIGEgcmFuZG9tIG9yYWNsZSB1bmRlciBhIHJlYXNvbmFibGUgY3J5cHRvZ3JhcGhpYyBhc3N1bXB0aW9uLlxuLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuMlxuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZF9tZXNzYWdlX3hvZihtc2csIERTVCwgbGVuSW5CeXRlcywgaywgSCkge1xuICAgIGFieXRlcyhtc2cpO1xuICAgIGFieXRlcyhEU1QpO1xuICAgIGFudW0obGVuSW5CeXRlcyk7XG4gICAgLy8gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjMuM1xuICAgIC8vIERTVCA9IEgoJ0gyQy1PVkVSU0laRS1EU1QtJyB8fCBhX3ZlcnlfbG9uZ19EU1QsIE1hdGguY2VpbCgobGVuSW5CeXRlcyAqIGspIC8gOCkpO1xuICAgIGlmIChEU1QubGVuZ3RoID4gMjU1KSB7XG4gICAgICAgIGNvbnN0IGRrTGVuID0gTWF0aC5jZWlsKCgyICogaykgLyA4KTtcbiAgICAgICAgRFNUID0gSC5jcmVhdGUoeyBka0xlbiB9KS51cGRhdGUodXRmOFRvQnl0ZXMoJ0gyQy1PVkVSU0laRS1EU1QtJykpLnVwZGF0ZShEU1QpLmRpZ2VzdCgpO1xuICAgIH1cbiAgICBpZiAobGVuSW5CeXRlcyA+IDY1NTM1IHx8IERTVC5sZW5ndGggPiAyNTUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZXhwYW5kX21lc3NhZ2VfeG9mOiBpbnZhbGlkIGxlbkluQnl0ZXMnKTtcbiAgICByZXR1cm4gKEguY3JlYXRlKHsgZGtMZW46IGxlbkluQnl0ZXMgfSlcbiAgICAgICAgLnVwZGF0ZShtc2cpXG4gICAgICAgIC51cGRhdGUoaTJvc3AobGVuSW5CeXRlcywgMikpXG4gICAgICAgIC8vIDIuIERTVF9wcmltZSA9IERTVCB8fCBJMk9TUChsZW4oRFNUKSwgMSlcbiAgICAgICAgLnVwZGF0ZShEU1QpXG4gICAgICAgIC51cGRhdGUoaTJvc3AoRFNULmxlbmd0aCwgMSkpXG4gICAgICAgIC5kaWdlc3QoKSk7XG59XG4vKipcbiAqIEhhc2hlcyBhcmJpdHJhcnktbGVuZ3RoIGJ5dGUgc3RyaW5ncyB0byBhIGxpc3Qgb2Ygb25lIG9yIG1vcmUgZWxlbWVudHMgb2YgYSBmaW5pdGUgZmllbGQgRlxuICogaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi01LjJcbiAqIEBwYXJhbSBtc2cgYSBieXRlIHN0cmluZyBjb250YWluaW5nIHRoZSBtZXNzYWdlIHRvIGhhc2hcbiAqIEBwYXJhbSBjb3VudCB0aGUgbnVtYmVyIG9mIGVsZW1lbnRzIG9mIEYgdG8gb3V0cHV0XG4gKiBAcGFyYW0gb3B0aW9ucyBge0RTVDogc3RyaW5nLCBwOiBiaWdpbnQsIG06IG51bWJlciwgazogbnVtYmVyLCBleHBhbmQ6ICd4bWQnIHwgJ3hvZicsIGhhc2g6IEh9YCwgc2VlIGFib3ZlXG4gKiBAcmV0dXJucyBbdV8wLCAuLi4sIHVfKGNvdW50IC0gMSldLCBhIGxpc3Qgb2YgZmllbGQgZWxlbWVudHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNoX3RvX2ZpZWxkKG1zZywgY291bnQsIG9wdGlvbnMpIHtcbiAgICB2YWxpZGF0ZU9iamVjdChvcHRpb25zLCB7XG4gICAgICAgIERTVDogJ3N0cmluZ09yVWludDhBcnJheScsXG4gICAgICAgIHA6ICdiaWdpbnQnLFxuICAgICAgICBtOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIGs6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgIH0pO1xuICAgIGNvbnN0IHsgcCwgaywgbSwgaGFzaCwgZXhwYW5kLCBEU1Q6IF9EU1QgfSA9IG9wdGlvbnM7XG4gICAgYWJ5dGVzKG1zZyk7XG4gICAgYW51bShjb3VudCk7XG4gICAgY29uc3QgRFNUID0gdHlwZW9mIF9EU1QgPT09ICdzdHJpbmcnID8gdXRmOFRvQnl0ZXMoX0RTVCkgOiBfRFNUO1xuICAgIGNvbnN0IGxvZzJwID0gcC50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgTCA9IE1hdGguY2VpbCgobG9nMnAgKyBrKSAvIDgpOyAvLyBzZWN0aW9uIDUuMSBvZiBpZXRmIGRyYWZ0IGxpbmsgYWJvdmVcbiAgICBjb25zdCBsZW5faW5fYnl0ZXMgPSBjb3VudCAqIG0gKiBMO1xuICAgIGxldCBwcmI7IC8vIHBzZXVkb19yYW5kb21fYnl0ZXNcbiAgICBpZiAoZXhwYW5kID09PSAneG1kJykge1xuICAgICAgICBwcmIgPSBleHBhbmRfbWVzc2FnZV94bWQobXNnLCBEU1QsIGxlbl9pbl9ieXRlcywgaGFzaCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4cGFuZCA9PT0gJ3hvZicpIHtcbiAgICAgICAgcHJiID0gZXhwYW5kX21lc3NhZ2VfeG9mKG1zZywgRFNULCBsZW5faW5fYnl0ZXMsIGssIGhhc2gpO1xuICAgIH1cbiAgICBlbHNlIGlmIChleHBhbmQgPT09ICdfaW50ZXJuYWxfcGFzcycpIHtcbiAgICAgICAgLy8gZm9yIGludGVybmFsIHRlc3RzIG9ubHlcbiAgICAgICAgcHJiID0gbXNnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdleHBhbmQgbXVzdCBiZSBcInhtZFwiIG9yIFwieG9mXCInKTtcbiAgICB9XG4gICAgY29uc3QgdSA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGUgPSBuZXcgQXJyYXkobSk7XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBlbG1fb2Zmc2V0ID0gTCAqIChqICsgaSAqIG0pO1xuICAgICAgICAgICAgY29uc3QgdHYgPSBwcmIuc3ViYXJyYXkoZWxtX29mZnNldCwgZWxtX29mZnNldCArIEwpO1xuICAgICAgICAgICAgZVtqXSA9IG1vZChvczJpcCh0diksIHApO1xuICAgICAgICB9XG4gICAgICAgIHVbaV0gPSBlO1xuICAgIH1cbiAgICByZXR1cm4gdTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc29nZW55TWFwKGZpZWxkLCBtYXApIHtcbiAgICAvLyBNYWtlIHNhbWUgb3JkZXIgYXMgaW4gc3BlY1xuICAgIGNvbnN0IENPRUZGID0gbWFwLm1hcCgoaSkgPT4gQXJyYXkuZnJvbShpKS5yZXZlcnNlKCkpO1xuICAgIHJldHVybiAoeCwgeSkgPT4ge1xuICAgICAgICBjb25zdCBbeE51bSwgeERlbiwgeU51bSwgeURlbl0gPSBDT0VGRi5tYXAoKHZhbCkgPT4gdmFsLnJlZHVjZSgoYWNjLCBpKSA9PiBmaWVsZC5hZGQoZmllbGQubXVsKGFjYywgeCksIGkpKSk7XG4gICAgICAgIHggPSBmaWVsZC5kaXYoeE51bSwgeERlbik7IC8vIHhOdW0gLyB4RGVuXG4gICAgICAgIHkgPSBmaWVsZC5tdWwoeSwgZmllbGQuZGl2KHlOdW0sIHlEZW4pKTsgLy8geSAqICh5TnVtIC8geURldilcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSGFzaGVyKFBvaW50LCBtYXBUb0N1cnZlLCBkZWYpIHtcbiAgICBpZiAodHlwZW9mIG1hcFRvQ3VydmUgIT09ICdmdW5jdGlvbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbWFwVG9DdXJ2ZSgpIG11c3QgYmUgZGVmaW5lZCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIC8vIEVuY29kZXMgYnl0ZSBzdHJpbmcgdG8gZWxsaXB0aWMgY3VydmUuXG4gICAgICAgIC8vIGhhc2hfdG9fY3VydmUgZnJvbSBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTNcbiAgICAgICAgaGFzaFRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDIsIHsgLi4uZGVmLCBEU1Q6IGRlZi5EU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCB1MCA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzBdKSk7XG4gICAgICAgICAgICBjb25zdCB1MSA9IFBvaW50LmZyb21BZmZpbmUobWFwVG9DdXJ2ZSh1WzFdKSk7XG4gICAgICAgICAgICBjb25zdCBQID0gdTAuYWRkKHUxKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gRW5jb2RlcyBieXRlIHN0cmluZyB0byBlbGxpcHRpYyBjdXJ2ZS5cbiAgICAgICAgLy8gZW5jb2RlX3RvX2N1cnZlIGZyb20gaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvcmZjL3JmYzkzODAjc2VjdGlvbi0zXG4gICAgICAgIGVuY29kZVRvQ3VydmUobXNnLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCB1ID0gaGFzaF90b19maWVsZChtc2csIDEsIHsgLi4uZGVmLCBEU1Q6IGRlZi5lbmNvZGVEU1QsIC4uLm9wdGlvbnMgfSk7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShtYXBUb0N1cnZlKHVbMF0pKS5jbGVhckNvZmFjdG9yKCk7XG4gICAgICAgICAgICBQLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUDtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaC10by1jdXJ2ZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js":
/*!************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/modular.js ***!
  \************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Field: function() { return /* binding */ Field; },\n/* harmony export */   FpDiv: function() { return /* binding */ FpDiv; },\n/* harmony export */   FpInvertBatch: function() { return /* binding */ FpInvertBatch; },\n/* harmony export */   FpIsSquare: function() { return /* binding */ FpIsSquare; },\n/* harmony export */   FpPow: function() { return /* binding */ FpPow; },\n/* harmony export */   FpSqrt: function() { return /* binding */ FpSqrt; },\n/* harmony export */   FpSqrtEven: function() { return /* binding */ FpSqrtEven; },\n/* harmony export */   FpSqrtOdd: function() { return /* binding */ FpSqrtOdd; },\n/* harmony export */   getFieldBytesLength: function() { return /* binding */ getFieldBytesLength; },\n/* harmony export */   getMinHashLength: function() { return /* binding */ getMinHashLength; },\n/* harmony export */   hashToPrivateScalar: function() { return /* binding */ hashToPrivateScalar; },\n/* harmony export */   invert: function() { return /* binding */ invert; },\n/* harmony export */   isNegativeLE: function() { return /* binding */ isNegativeLE; },\n/* harmony export */   mapHashToField: function() { return /* binding */ mapHashToField; },\n/* harmony export */   mod: function() { return /* binding */ mod; },\n/* harmony export */   nLength: function() { return /* binding */ nLength; },\n/* harmony export */   pow: function() { return /* binding */ pow; },\n/* harmony export */   pow2: function() { return /* binding */ pow2; },\n/* harmony export */   tonelliShanks: function() { return /* binding */ tonelliShanks; },\n/* harmony export */   validateField: function() { return /* binding */ validateField; }\n/* harmony export */ });\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Utilities for modular arithmetics and finite fields\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _4n = BigInt(4), _5n = BigInt(5), _8n = BigInt(8);\n// prettier-ignore\nconst _9n = BigInt(9), _16n = BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n    const result = a % b;\n    return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\n// TODO: use field version && remove\nfunction pow(num, power, modulo) {\n    if (modulo <= _0n || power < _0n)\n        throw new Error('Expected power/modulo > 0');\n    if (modulo === _1n)\n        return _0n;\n    let res = _1n;\n    while (power > _0n) {\n        if (power & _1n)\n            res = (res * num) % modulo;\n        num = (num * num) % modulo;\n        power >>= _1n;\n    }\n    return res;\n}\n// Does x ^ (2 ^ power) mod p. pow2(30, 4) == 30 ^ (2 ^ 4)\nfunction pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n) {\n        res *= res;\n        res %= modulo;\n    }\n    return res;\n}\n// Inverses number over modulo\nfunction invert(number, modulo) {\n    if (number === _0n || modulo <= _0n) {\n        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);\n    }\n    // Euclidean GCD https://brilliant.org/wiki/extended-euclidean-algorithm/\n    // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n    let a = mod(number, modulo);\n    let b = modulo;\n    // prettier-ignore\n    let x = _0n, y = _1n, u = _1n, v = _0n;\n    while (a !== _0n) {\n        // JIT applies optimization if those two lines follow each other\n        const q = b / a;\n        const r = b % a;\n        const m = x - u * q;\n        const n = y - v * q;\n        // prettier-ignore\n        b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n)\n        throw new Error('invert: does not exist');\n    return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n    // Legendre constant: used to calculate Legendre symbol (a | p),\n    // which denotes the value of a^((p-1)/2) (mod p).\n    // (a | p) ≡ 1    if a is a square (mod p)\n    // (a | p) ≡ -1   if a is not a square (mod p)\n    // (a | p) ≡ 0    if a ≡ 0 (mod p)\n    const legendreC = (P - _1n) / _2n;\n    let Q, S, Z;\n    // Step 1: By factoring out powers of 2 from p - 1,\n    // find q and s such that p - 1 = q*(2^s) with q odd\n    for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)\n        ;\n    // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n    for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)\n        ;\n    // Fast-path\n    if (S === 1) {\n        const p1div4 = (P + _1n) / _4n;\n        return function tonelliFast(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Slow-path\n    const Q1div2 = (Q + _1n) / _2n;\n    return function tonelliSlow(Fp, n) {\n        // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))\n            throw new Error('Cannot find square root');\n        let r = S;\n        // TODO: will fail at Fp2/etc\n        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n        let x = Fp.pow(n, Q1div2); // first guess at the square root\n        let b = Fp.pow(n, Q); // first guess at the fudge factor\n        while (!Fp.eql(b, Fp.ONE)) {\n            if (Fp.eql(b, Fp.ZERO))\n                return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n            // Find m such b^(2^m)==1\n            let m = 1;\n            for (let t2 = Fp.sqr(b); m < r; m++) {\n                if (Fp.eql(t2, Fp.ONE))\n                    break;\n                t2 = Fp.sqr(t2); // t2 *= t2\n            }\n            // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n            const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n            g = Fp.sqr(ge); // g = ge * ge\n            x = Fp.mul(x, ge); // x *= ge\n            b = Fp.mul(b, g); // b *= g\n            r = m;\n        }\n        return x;\n    };\n}\nfunction FpSqrt(P) {\n    // NOTE: different algorithms can give different roots, it is up to user to decide which one they want.\n    // For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n    // P ≡ 3 (mod 4)\n    // √n = n^((P+1)/4)\n    if (P % _4n === _3n) {\n        // Not all roots possible!\n        // const ORDER =\n        //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n        // const NUM = 72057594037927816n;\n        const p1div4 = (P + _1n) / _4n;\n        return function sqrt3mod4(Fp, n) {\n            const root = Fp.pow(n, p1div4);\n            // Throw if root**2 != n\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n    if (P % _8n === _5n) {\n        const c1 = (P - _5n) / _8n;\n        return function sqrt5mod8(Fp, n) {\n            const n2 = Fp.mul(n, _2n);\n            const v = Fp.pow(n2, c1);\n            const nv = Fp.mul(n, v);\n            const i = Fp.mul(Fp.mul(nv, _2n), v);\n            const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n            if (!Fp.eql(Fp.sqr(root), n))\n                throw new Error('Cannot find square root');\n            return root;\n        };\n    }\n    // P ≡ 9 (mod 16)\n    if (P % _16n === _9n) {\n        // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n        // Means we cannot use sqrt for constants at all!\n        //\n        // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n        // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n        // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n        // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n        // sqrt = (x) => {\n        //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n        //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n        //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n        //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n        //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n        //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n        //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n        //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n        //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n        //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n        // }\n    }\n    // Other cases: Tonelli-Shanks algorithm\n    return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\n// prettier-ignore\nconst FIELD_FIELDS = [\n    'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n    'eql', 'add', 'sub', 'mul', 'pow', 'div',\n    'addN', 'subN', 'mulN', 'sqrN'\n];\nfunction validateField(field) {\n    const initial = {\n        ORDER: 'bigint',\n        MASK: 'bigint',\n        BYTES: 'isSafeInteger',\n        BITS: 'isSafeInteger',\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n        map[val] = 'function';\n        return map;\n    }, initial);\n    return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n    // Should have same speed as pow for bigints\n    // TODO: benchmark!\n    if (power < _0n)\n        throw new Error('Expected power > 0');\n    if (power === _0n)\n        return f.ONE;\n    if (power === _1n)\n        return num;\n    let p = f.ONE;\n    let d = num;\n    while (power > _0n) {\n        if (power & _1n)\n            p = f.mul(p, d);\n        d = f.sqr(d);\n        power >>= _1n;\n    }\n    return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n    const tmp = new Array(nums.length);\n    // Walk from first to last, multiply them by each other MOD p\n    const lastMultiplied = nums.reduce((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = acc;\n        return f.mul(acc, num);\n    }, f.ONE);\n    // Invert last element\n    const inverted = f.inv(lastMultiplied);\n    // Walk from last to first, multiply them by inverted each other MOD p\n    nums.reduceRight((acc, num, i) => {\n        if (f.is0(num))\n            return acc;\n        tmp[i] = f.mul(acc, tmp[i]);\n        return f.mul(acc, num);\n    }, inverted);\n    return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n    return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n    const legendreConst = (f.ORDER - _1n) / _2n; // Integer arithmetic\n    return (x) => {\n        const p = f.pow(x, legendreConst);\n        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n    };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n    // Bit size, byte size of CURVE.n\n    const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n}\n/**\n * Initializes a finite field over prime. **Non-primes are not supported.**\n * Do not init in loop: slow. Very fragile: always run a benchmark on a change.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n    if (ORDER <= _0n)\n        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n    if (BYTES > 2048)\n        throw new Error('Field lengths over 2048 bytes are not supported');\n    const sqrtP = FpSqrt(ORDER);\n    const f = Object.freeze({\n        ORDER,\n        BITS,\n        BYTES,\n        MASK: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bitMask)(BITS),\n        ZERO: _0n,\n        ONE: _1n,\n        create: (num) => mod(num, ORDER),\n        isValid: (num) => {\n            if (typeof num !== 'bigint')\n                throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);\n            return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n        },\n        is0: (num) => num === _0n,\n        isOdd: (num) => (num & _1n) === _1n,\n        neg: (num) => mod(-num, ORDER),\n        eql: (lhs, rhs) => lhs === rhs,\n        sqr: (num) => mod(num * num, ORDER),\n        add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n        pow: (num, power) => FpPow(f, num, power),\n        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n        // Same as above, but doesn't normalize\n        sqrN: (num) => num * num,\n        addN: (lhs, rhs) => lhs + rhs,\n        subN: (lhs, rhs) => lhs - rhs,\n        mulN: (lhs, rhs) => lhs * rhs,\n        inv: (num) => invert(num, ORDER),\n        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),\n        invertBatch: (lst) => FpInvertBatch(f, lst),\n        // TODO: do we really need constant cmov?\n        // We don't have const-time bigints anyway, so probably will be not very useful\n        cmov: (a, b, c) => (c ? b : a),\n        toBytes: (num) => (isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(num, BYTES) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(num, BYTES)),\n        fromBytes: (bytes) => {\n            if (bytes.length !== BYTES)\n                throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);\n            return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(bytes) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(bytes);\n        },\n    });\n    return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n    if (!Fp.isOdd)\n        throw new Error(`Field doesn't have isOdd`);\n    const root = Fp.sqrt(elm);\n    return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use mapKeyToField instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n    hash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('privateHash', hash);\n    const hashLen = hash.length;\n    const minLen = nLength(groupOrder).nByteLength + 8;\n    if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(hash) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(hash);\n    return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== 'bigint')\n        throw new Error('field order must be bigint');\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n    if (len < 16 || len < minLen || len > 1024)\n        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);\n    const num = isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberBE)(key) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(key);\n    // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n    const reduced = mod(num, fieldOrder - _1n) + _1n;\n    return isLE ? (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(reduced, fieldLen) : (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesBE)(reduced, fieldLen);\n}\n//# sourceMappingURL=modular.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb2R1bGFyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDdUk7QUFDdkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLHFFQUFxRSxRQUFRLE1BQU0sT0FBTztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBLGtCQUFrQiwyQ0FBMkM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsbUNBQW1DO0FBQ25DLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQsNEJBQTRCO0FBQzVCLCtCQUErQjtBQUMvQiw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQ7QUFDQSxrREFBa0Q7QUFDbEQsa0RBQWtEO0FBQ2xELGtEQUFrRDtBQUNsRCxrREFBa0Q7QUFDbEQsc0RBQXNEO0FBQ3RELHNEQUFzRDtBQUN0RCwwQ0FBMEM7QUFDMUMsMENBQTBDO0FBQzFDLHNEQUFzRDtBQUN0RCwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxXQUFXLHlEQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUCxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyxzREFBc0Q7QUFDN0Q7QUFDQSx5REFBeUQsTUFBTTtBQUMvRCxZQUFZLHVDQUF1QztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsa0RBQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxXQUFXO0FBQzFGLDhDQUE4QztBQUM5QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLDBEQUFlLGVBQWUsMERBQWU7QUFDL0U7QUFDQTtBQUNBLDBEQUEwRCxNQUFNLFFBQVEsYUFBYTtBQUNyRiwwQkFBMEIsMERBQWUsVUFBVSwwREFBZTtBQUNsRSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFdBQVcsc0RBQVc7QUFDdEI7QUFDQTtBQUNBO0FBQ0EseURBQXlELE9BQU8sNEJBQTRCLFFBQVE7QUFDcEcsdUJBQXVCLDBEQUFlLFNBQVMsMERBQWU7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPLDRCQUE0QixJQUFJO0FBQzNFLHVCQUF1QiwwREFBZSxRQUFRLDBEQUFlO0FBQzdEO0FBQ0E7QUFDQSxrQkFBa0IsMERBQWUsc0JBQXNCLDBEQUFlO0FBQ3RFO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L21vZHVsYXIuanM/NjJjNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtY3VydmVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBVdGlsaXRpZXMgZm9yIG1vZHVsYXIgYXJpdGhtZXRpY3MgYW5kIGZpbml0ZSBmaWVsZHNcbmltcG9ydCB7IGJpdE1hc2ssIG51bWJlclRvQnl0ZXNCRSwgbnVtYmVyVG9CeXRlc0xFLCBieXRlc1RvTnVtYmVyQkUsIGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIHZhbGlkYXRlT2JqZWN0LCB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMG4gPSBCaWdJbnQoMCksIF8xbiA9IEJpZ0ludCgxKSwgXzJuID0gQmlnSW50KDIpLCBfM24gPSBCaWdJbnQoMyk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF80biA9IEJpZ0ludCg0KSwgXzVuID0gQmlnSW50KDUpLCBfOG4gPSBCaWdJbnQoOCk7XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IF85biA9IEJpZ0ludCg5KSwgXzE2biA9IEJpZ0ludCgxNik7XG4vLyBDYWxjdWxhdGVzIGEgbW9kdWxvIGJcbmV4cG9ydCBmdW5jdGlvbiBtb2QoYSwgYikge1xuICAgIGNvbnN0IHJlc3VsdCA9IGEgJSBiO1xuICAgIHJldHVybiByZXN1bHQgPj0gXzBuID8gcmVzdWx0IDogYiArIHJlc3VsdDtcbn1cbi8qKlxuICogRWZmaWNpZW50bHkgcmFpc2UgbnVtIHRvIHBvd2VyIGFuZCBkbyBtb2R1bGFyIGRpdmlzaW9uLlxuICogVW5zYWZlIGluIHNvbWUgY29udGV4dHM6IHVzZXMgbGFkZGVyLCBzbyBjYW4gZXhwb3NlIGJpZ2ludCBiaXRzLlxuICogQGV4YW1wbGVcbiAqIHBvdygybiwgNm4sIDExbikgLy8gNjRuICUgMTFuID09IDluXG4gKi9cbi8vIFRPRE86IHVzZSBmaWVsZCB2ZXJzaW9uICYmIHJlbW92ZVxuZXhwb3J0IGZ1bmN0aW9uIHBvdyhudW0sIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBpZiAobW9kdWxvIDw9IF8wbiB8fCBwb3dlciA8IF8wbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwb3dlci9tb2R1bG8gPiAwJyk7XG4gICAgaWYgKG1vZHVsbyA9PT0gXzFuKVxuICAgICAgICByZXR1cm4gXzBuO1xuICAgIGxldCByZXMgPSBfMW47XG4gICAgd2hpbGUgKHBvd2VyID4gXzBuKSB7XG4gICAgICAgIGlmIChwb3dlciAmIF8xbilcbiAgICAgICAgICAgIHJlcyA9IChyZXMgKiBudW0pICUgbW9kdWxvO1xuICAgICAgICBudW0gPSAobnVtICogbnVtKSAlIG1vZHVsbztcbiAgICAgICAgcG93ZXIgPj49IF8xbjtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cbi8vIERvZXMgeCBeICgyIF4gcG93ZXIpIG1vZCBwLiBwb3cyKDMwLCA0KSA9PSAzMCBeICgyIF4gNClcbmV4cG9ydCBmdW5jdGlvbiBwb3cyKHgsIHBvd2VyLCBtb2R1bG8pIHtcbiAgICBsZXQgcmVzID0geDtcbiAgICB3aGlsZSAocG93ZXItLSA+IF8wbikge1xuICAgICAgICByZXMgKj0gcmVzO1xuICAgICAgICByZXMgJT0gbW9kdWxvO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gSW52ZXJzZXMgbnVtYmVyIG92ZXIgbW9kdWxvXG5leHBvcnQgZnVuY3Rpb24gaW52ZXJ0KG51bWJlciwgbW9kdWxvKSB7XG4gICAgaWYgKG51bWJlciA9PT0gXzBuIHx8IG1vZHVsbyA8PSBfMG4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZlcnQ6IGV4cGVjdGVkIHBvc2l0aXZlIGludGVnZXJzLCBnb3Qgbj0ke251bWJlcn0gbW9kPSR7bW9kdWxvfWApO1xuICAgIH1cbiAgICAvLyBFdWNsaWRlYW4gR0NEIGh0dHBzOi8vYnJpbGxpYW50Lm9yZy93aWtpL2V4dGVuZGVkLWV1Y2xpZGVhbi1hbGdvcml0aG0vXG4gICAgLy8gRmVybWF0J3MgbGl0dGxlIHRoZW9yZW0gXCJDVC1saWtlXCIgdmVyc2lvbiBpbnYobikgPSBuXihtLTIpIG1vZCBtIGlzIDMweCBzbG93ZXIuXG4gICAgbGV0IGEgPSBtb2QobnVtYmVyLCBtb2R1bG8pO1xuICAgIGxldCBiID0gbW9kdWxvO1xuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIGxldCB4ID0gXzBuLCB5ID0gXzFuLCB1ID0gXzFuLCB2ID0gXzBuO1xuICAgIHdoaWxlIChhICE9PSBfMG4pIHtcbiAgICAgICAgLy8gSklUIGFwcGxpZXMgb3B0aW1pemF0aW9uIGlmIHRob3NlIHR3byBsaW5lcyBmb2xsb3cgZWFjaCBvdGhlclxuICAgICAgICBjb25zdCBxID0gYiAvIGE7XG4gICAgICAgIGNvbnN0IHIgPSBiICUgYTtcbiAgICAgICAgY29uc3QgbSA9IHggLSB1ICogcTtcbiAgICAgICAgY29uc3QgbiA9IHkgLSB2ICogcTtcbiAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgIGIgPSBhLCBhID0gciwgeCA9IHUsIHkgPSB2LCB1ID0gbSwgdiA9IG47XG4gICAgfVxuICAgIGNvbnN0IGdjZCA9IGI7XG4gICAgaWYgKGdjZCAhPT0gXzFuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmVydDogZG9lcyBub3QgZXhpc3QnKTtcbiAgICByZXR1cm4gbW9kKHgsIG1vZHVsbyk7XG59XG4vKipcbiAqIFRvbmVsbGktU2hhbmtzIHNxdWFyZSByb290IHNlYXJjaCBhbGdvcml0aG0uXG4gKiAxLiBodHRwczovL2VwcmludC5pYWNyLm9yZy8yMDEyLzY4NS5wZGYgKHBhZ2UgMTIpXG4gKiAyLiBTcXVhcmUgUm9vdHMgZnJvbSAxOyAyNCwgNTEsIDEwIHRvIERhbiBTaGFua3NcbiAqIFdpbGwgc3RhcnQgYW4gaW5maW5pdGUgbG9vcCBpZiBmaWVsZCBvcmRlciBQIGlzIG5vdCBwcmltZS5cbiAqIEBwYXJhbSBQIGZpZWxkIG9yZGVyXG4gKiBAcmV0dXJucyBmdW5jdGlvbiB0aGF0IHRha2VzIGZpZWxkIEZwIChjcmVhdGVkIGZyb20gUCkgYW5kIG51bWJlciBuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b25lbGxpU2hhbmtzKFApIHtcbiAgICAvLyBMZWdlbmRyZSBjb25zdGFudDogdXNlZCB0byBjYWxjdWxhdGUgTGVnZW5kcmUgc3ltYm9sIChhIHwgcCksXG4gICAgLy8gd2hpY2ggZGVub3RlcyB0aGUgdmFsdWUgb2YgYV4oKHAtMSkvMikgKG1vZCBwKS5cbiAgICAvLyAoYSB8IHApIOKJoSAxICAgIGlmIGEgaXMgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIC0xICAgaWYgYSBpcyBub3QgYSBzcXVhcmUgKG1vZCBwKVxuICAgIC8vIChhIHwgcCkg4omhIDAgICAgaWYgYSDiiaEgMCAobW9kIHApXG4gICAgY29uc3QgbGVnZW5kcmVDID0gKFAgLSBfMW4pIC8gXzJuO1xuICAgIGxldCBRLCBTLCBaO1xuICAgIC8vIFN0ZXAgMTogQnkgZmFjdG9yaW5nIG91dCBwb3dlcnMgb2YgMiBmcm9tIHAgLSAxLFxuICAgIC8vIGZpbmQgcSBhbmQgcyBzdWNoIHRoYXQgcCAtIDEgPSBxKigyXnMpIHdpdGggcSBvZGRcbiAgICBmb3IgKFEgPSBQIC0gXzFuLCBTID0gMDsgUSAlIF8ybiA9PT0gXzBuOyBRIC89IF8ybiwgUysrKVxuICAgICAgICA7XG4gICAgLy8gU3RlcCAyOiBTZWxlY3QgYSBub24tc3F1YXJlIHogc3VjaCB0aGF0ICh6IHwgcCkg4omhIC0xIGFuZCBzZXQgYyDiiaEgenFcbiAgICBmb3IgKFogPSBfMm47IFogPCBQICYmIHBvdyhaLCBsZWdlbmRyZUMsIFApICE9PSBQIC0gXzFuOyBaKyspXG4gICAgICAgIDtcbiAgICAvLyBGYXN0LXBhdGhcbiAgICBpZiAoUyA9PT0gMSkge1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpRmFzdChGcCwgbikge1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9IEZwLnBvdyhuLCBwMWRpdjQpO1xuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gU2xvdy1wYXRoXG4gICAgY29uc3QgUTFkaXYyID0gKFEgKyBfMW4pIC8gXzJuO1xuICAgIHJldHVybiBmdW5jdGlvbiB0b25lbGxpU2xvdyhGcCwgbikge1xuICAgICAgICAvLyBTdGVwIDA6IENoZWNrIHRoYXQgbiBpcyBpbmRlZWQgYSBzcXVhcmU6IChuIHwgcCkgc2hvdWxkIG5vdCBiZSDiiaEgLTFcbiAgICAgICAgaWYgKEZwLnBvdyhuLCBsZWdlbmRyZUMpID09PSBGcC5uZWcoRnAuT05FKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgbGV0IHIgPSBTO1xuICAgICAgICAvLyBUT0RPOiB3aWxsIGZhaWwgYXQgRnAyL2V0Y1xuICAgICAgICBsZXQgZyA9IEZwLnBvdyhGcC5tdWwoRnAuT05FLCBaKSwgUSk7IC8vIHdpbGwgdXBkYXRlIGJvdGggeCBhbmQgYlxuICAgICAgICBsZXQgeCA9IEZwLnBvdyhuLCBRMWRpdjIpOyAvLyBmaXJzdCBndWVzcyBhdCB0aGUgc3F1YXJlIHJvb3RcbiAgICAgICAgbGV0IGIgPSBGcC5wb3cobiwgUSk7IC8vIGZpcnN0IGd1ZXNzIGF0IHRoZSBmdWRnZSBmYWN0b3JcbiAgICAgICAgd2hpbGUgKCFGcC5lcWwoYiwgRnAuT05FKSkge1xuICAgICAgICAgICAgaWYgKEZwLmVxbChiLCBGcC5aRVJPKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gRnAuWkVSTzsgLy8gaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVG9uZWxsaSVFMiU4MCU5M1NoYW5rc19hbGdvcml0aG0gKDQuIElmIHQgPSAwLCByZXR1cm4gciA9IDApXG4gICAgICAgICAgICAvLyBGaW5kIG0gc3VjaCBiXigyXm0pPT0xXG4gICAgICAgICAgICBsZXQgbSA9IDE7XG4gICAgICAgICAgICBmb3IgKGxldCB0MiA9IEZwLnNxcihiKTsgbSA8IHI7IG0rKykge1xuICAgICAgICAgICAgICAgIGlmIChGcC5lcWwodDIsIEZwLk9ORSkpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHQyID0gRnAuc3FyKHQyKTsgLy8gdDIgKj0gdDJcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5PVEU6IHItbS0xIGNhbiBiZSBiaWdnZXIgdGhhbiAzMiwgbmVlZCB0byBjb252ZXJ0IHRvIGJpZ2ludCBiZWZvcmUgc2hpZnQsIG90aGVyd2lzZSB0aGVyZSB3aWxsIGJlIG92ZXJmbG93XG4gICAgICAgICAgICBjb25zdCBnZSA9IEZwLnBvdyhnLCBfMW4gPDwgQmlnSW50KHIgLSBtIC0gMSkpOyAvLyBnZSA9IDJeKHItbS0xKVxuICAgICAgICAgICAgZyA9IEZwLnNxcihnZSk7IC8vIGcgPSBnZSAqIGdlXG4gICAgICAgICAgICB4ID0gRnAubXVsKHgsIGdlKTsgLy8geCAqPSBnZVxuICAgICAgICAgICAgYiA9IEZwLm11bChiLCBnKTsgLy8gYiAqPSBnXG4gICAgICAgICAgICByID0gbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geDtcbiAgICB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIEZwU3FydChQKSB7XG4gICAgLy8gTk9URTogZGlmZmVyZW50IGFsZ29yaXRobXMgY2FuIGdpdmUgZGlmZmVyZW50IHJvb3RzLCBpdCBpcyB1cCB0byB1c2VyIHRvIGRlY2lkZSB3aGljaCBvbmUgdGhleSB3YW50LlxuICAgIC8vIEZvciBleGFtcGxlIHRoZXJlIGlzIEZwU3FydE9kZC9GcFNxcnRFdmVuIHRvIGNob2ljZSByb290IGJhc2VkIG9uIG9kZG5lc3MgKHVzZWQgZm9yIGhhc2gtdG8tY3VydmUpLlxuICAgIC8vIFAg4omhIDMgKG1vZCA0KVxuICAgIC8vIOKImm4gPSBuXigoUCsxKS80KVxuICAgIGlmIChQICUgXzRuID09PSBfM24pIHtcbiAgICAgICAgLy8gTm90IGFsbCByb290cyBwb3NzaWJsZSFcbiAgICAgICAgLy8gY29uc3QgT1JERVIgPVxuICAgICAgICAvLyAgIDB4MWEwMTExZWEzOTdmZTY5YTRiMWJhN2I2NDM0YmFjZDc2NDc3NGI4NGYzODUxMmJmNjczMGQyYTBmNmIwZjYyNDFlYWJmZmZlYjE1M2ZmZmZiOWZlZmZmZmZmZmZhYWFibjtcbiAgICAgICAgLy8gY29uc3QgTlVNID0gNzIwNTc1OTQwMzc5Mjc4MTZuO1xuICAgICAgICBjb25zdCBwMWRpdjQgPSAoUCArIF8xbikgLyBfNG47XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzcXJ0M21vZDQoRnAsIG4pIHtcbiAgICAgICAgICAgIGNvbnN0IHJvb3QgPSBGcC5wb3cobiwgcDFkaXY0KTtcbiAgICAgICAgICAgIC8vIFRocm93IGlmIHJvb3QqKjIgIT0gblxuICAgICAgICAgICAgaWYgKCFGcC5lcWwoRnAuc3FyKHJvb3QpLCBuKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgICAgICAgICByZXR1cm4gcm9vdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gQXRraW4gYWxnb3JpdGhtIGZvciBxIOKJoSA1IChtb2QgOCksIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTIvNjg1LnBkZiAocGFnZSAxMClcbiAgICBpZiAoUCAlIF84biA9PT0gXzVuKSB7XG4gICAgICAgIGNvbnN0IGMxID0gKFAgLSBfNW4pIC8gXzhuO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gc3FydDVtb2Q4KEZwLCBuKSB7XG4gICAgICAgICAgICBjb25zdCBuMiA9IEZwLm11bChuLCBfMm4pO1xuICAgICAgICAgICAgY29uc3QgdiA9IEZwLnBvdyhuMiwgYzEpO1xuICAgICAgICAgICAgY29uc3QgbnYgPSBGcC5tdWwobiwgdik7XG4gICAgICAgICAgICBjb25zdCBpID0gRnAubXVsKEZwLm11bChudiwgXzJuKSwgdik7XG4gICAgICAgICAgICBjb25zdCByb290ID0gRnAubXVsKG52LCBGcC5zdWIoaSwgRnAuT05FKSk7XG4gICAgICAgICAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIG4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZpbmQgc3F1YXJlIHJvb3QnKTtcbiAgICAgICAgICAgIHJldHVybiByb290O1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvLyBQIOKJoSA5IChtb2QgMTYpXG4gICAgaWYgKFAgJSBfMTZuID09PSBfOW4pIHtcbiAgICAgICAgLy8gTk9URTogdG9uZWxsaSBpcyB0b28gc2xvdyBmb3IgYmxzLUZwMiBjYWxjdWxhdGlvbnMgZXZlbiBvbiBzdGFydFxuICAgICAgICAvLyBNZWFucyB3ZSBjYW5ub3QgdXNlIHNxcnQgZm9yIGNvbnN0YW50cyBhdCBhbGwhXG4gICAgICAgIC8vXG4gICAgICAgIC8vIGNvbnN0IGMxID0gRnAuc3FydChGcC5uZWdhdGUoRnAuT05FKSk7IC8vICAxLiBjMSA9IHNxcnQoLTEpIGluIEYsIGkuZS4sIChjMV4yKSA9PSAtMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMyID0gRnAuc3FydChjMSk7ICAgICAgICAgICAgICAgIC8vICAyLiBjMiA9IHNxcnQoYzEpIGluIEYsIGkuZS4sIChjMl4yKSA9PSBjMSBpbiBGXG4gICAgICAgIC8vIGNvbnN0IGMzID0gRnAuc3FydChGcC5uZWdhdGUoYzEpKTsgICAgIC8vICAzLiBjMyA9IHNxcnQoLWMxKSBpbiBGLCBpLmUuLCAoYzNeMikgPT0gLWMxIGluIEZcbiAgICAgICAgLy8gY29uc3QgYzQgPSAoUCArIF83bikgLyBfMTZuOyAgICAgICAgICAgLy8gIDQuIGM0ID0gKHEgKyA3KSAvIDE2ICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICAvLyBzcXJ0ID0gKHgpID0+IHtcbiAgICAgICAgLy8gICBsZXQgdHYxID0gRnAucG93KHgsIGM0KTsgICAgICAgICAgICAgLy8gIDEuIHR2MSA9IHheYzRcbiAgICAgICAgLy8gICBsZXQgdHYyID0gRnAubXVsKGMxLCB0djEpOyAgICAgICAgICAgLy8gIDIuIHR2MiA9IGMxICogdHYxXG4gICAgICAgIC8vICAgY29uc3QgdHYzID0gRnAubXVsKGMyLCB0djEpOyAgICAgICAgIC8vICAzLiB0djMgPSBjMiAqIHR2MVxuICAgICAgICAvLyAgIGxldCB0djQgPSBGcC5tdWwoYzMsIHR2MSk7ICAgICAgICAgICAvLyAgNC4gdHY0ID0gYzMgKiB0djFcbiAgICAgICAgLy8gICBjb25zdCBlMSA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA1LiAgZTEgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMiA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYzKSwgeCk7IC8vICA2LiAgZTIgPSAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICB0djEgPSBGcC5jbW92KHR2MSwgdHYyLCBlMSk7IC8vICA3LiB0djEgPSBDTU9WKHR2MSwgdHYyLCBlMSkgICMgU2VsZWN0IHR2MiBpZiAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICB0djIgPSBGcC5jbW92KHR2NCwgdHYzLCBlMik7IC8vICA4LiB0djIgPSBDTU9WKHR2NCwgdHYzLCBlMikgICMgU2VsZWN0IHR2MyBpZiAodHYzXjIpID09IHhcbiAgICAgICAgLy8gICBjb25zdCBlMyA9IEZwLmVxdWFscyhGcC5zcXVhcmUodHYyKSwgeCk7IC8vICA5LiAgZTMgPSAodHYyXjIpID09IHhcbiAgICAgICAgLy8gICByZXR1cm4gRnAuY21vdih0djEsIHR2MiwgZTMpOyAvLyAgMTAuICB6ID0gQ01PVih0djEsIHR2MiwgZTMpICAjIFNlbGVjdCB0aGUgc3FydCBmcm9tIHR2MSBhbmQgdHYyXG4gICAgICAgIC8vIH1cbiAgICB9XG4gICAgLy8gT3RoZXIgY2FzZXM6IFRvbmVsbGktU2hhbmtzIGFsZ29yaXRobVxuICAgIHJldHVybiB0b25lbGxpU2hhbmtzKFApO1xufVxuLy8gTGl0dGxlLWVuZGlhbiBjaGVjayBmb3IgZmlyc3QgTEUgYml0IChsYXN0IEJFIGJpdCk7XG5leHBvcnQgY29uc3QgaXNOZWdhdGl2ZUxFID0gKG51bSwgbW9kdWxvKSA9PiAobW9kKG51bSwgbW9kdWxvKSAmIF8xbikgPT09IF8xbjtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgRklFTERfRklFTERTID0gW1xuICAgICdjcmVhdGUnLCAnaXNWYWxpZCcsICdpczAnLCAnbmVnJywgJ2ludicsICdzcXJ0JywgJ3NxcicsXG4gICAgJ2VxbCcsICdhZGQnLCAnc3ViJywgJ211bCcsICdwb3cnLCAnZGl2JyxcbiAgICAnYWRkTicsICdzdWJOJywgJ211bE4nLCAnc3FyTidcbl07XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVGaWVsZChmaWVsZCkge1xuICAgIGNvbnN0IGluaXRpYWwgPSB7XG4gICAgICAgIE9SREVSOiAnYmlnaW50JyxcbiAgICAgICAgTUFTSzogJ2JpZ2ludCcsXG4gICAgICAgIEJZVEVTOiAnaXNTYWZlSW50ZWdlcicsXG4gICAgICAgIEJJVFM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICB9O1xuICAgIGNvbnN0IG9wdHMgPSBGSUVMRF9GSUVMRFMucmVkdWNlKChtYXAsIHZhbCkgPT4ge1xuICAgICAgICBtYXBbdmFsXSA9ICdmdW5jdGlvbic7XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfSwgaW5pdGlhbCk7XG4gICAgcmV0dXJuIHZhbGlkYXRlT2JqZWN0KGZpZWxkLCBvcHRzKTtcbn1cbi8vIEdlbmVyaWMgZmllbGQgZnVuY3Rpb25zXG4vKipcbiAqIFNhbWUgYXMgYHBvd2AgYnV0IGZvciBGcDogbm9uLWNvbnN0YW50LXRpbWUuXG4gKiBVbnNhZmUgaW4gc29tZSBjb250ZXh0czogdXNlcyBsYWRkZXIsIHNvIGNhbiBleHBvc2UgYmlnaW50IGJpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcFBvdyhmLCBudW0sIHBvd2VyKSB7XG4gICAgLy8gU2hvdWxkIGhhdmUgc2FtZSBzcGVlZCBhcyBwb3cgZm9yIGJpZ2ludHNcbiAgICAvLyBUT0RPOiBiZW5jaG1hcmshXG4gICAgaWYgKHBvd2VyIDwgXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBvd2VyID4gMCcpO1xuICAgIGlmIChwb3dlciA9PT0gXzBuKVxuICAgICAgICByZXR1cm4gZi5PTkU7XG4gICAgaWYgKHBvd2VyID09PSBfMW4pXG4gICAgICAgIHJldHVybiBudW07XG4gICAgbGV0IHAgPSBmLk9ORTtcbiAgICBsZXQgZCA9IG51bTtcbiAgICB3aGlsZSAocG93ZXIgPiBfMG4pIHtcbiAgICAgICAgaWYgKHBvd2VyICYgXzFuKVxuICAgICAgICAgICAgcCA9IGYubXVsKHAsIGQpO1xuICAgICAgICBkID0gZi5zcXIoZCk7XG4gICAgICAgIHBvd2VyID4+PSBfMW47XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSBpbnZlcnQgYW4gYXJyYXkgb2YgRmllbGQgZWxlbWVudHMuXG4gKiBgaW52KDApYCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYCBoZXJlOiBtYWtlIHN1cmUgdG8gdGhyb3cgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBGcEludmVydEJhdGNoKGYsIG51bXMpIHtcbiAgICBjb25zdCB0bXAgPSBuZXcgQXJyYXkobnVtcy5sZW5ndGgpO1xuICAgIC8vIFdhbGsgZnJvbSBmaXJzdCB0byBsYXN0LCBtdWx0aXBseSB0aGVtIGJ5IGVhY2ggb3RoZXIgTU9EIHBcbiAgICBjb25zdCBsYXN0TXVsdGlwbGllZCA9IG51bXMucmVkdWNlKChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGFjYztcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBmLk9ORSk7XG4gICAgLy8gSW52ZXJ0IGxhc3QgZWxlbWVudFxuICAgIGNvbnN0IGludmVydGVkID0gZi5pbnYobGFzdE11bHRpcGxpZWQpO1xuICAgIC8vIFdhbGsgZnJvbSBsYXN0IHRvIGZpcnN0LCBtdWx0aXBseSB0aGVtIGJ5IGludmVydGVkIGVhY2ggb3RoZXIgTU9EIHBcbiAgICBudW1zLnJlZHVjZVJpZ2h0KChhY2MsIG51bSwgaSkgPT4ge1xuICAgICAgICBpZiAoZi5pczAobnVtKSlcbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIHRtcFtpXSA9IGYubXVsKGFjYywgdG1wW2ldKTtcbiAgICAgICAgcmV0dXJuIGYubXVsKGFjYywgbnVtKTtcbiAgICB9LCBpbnZlcnRlZCk7XG4gICAgcmV0dXJuIHRtcDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcERpdihmLCBsaHMsIHJocykge1xuICAgIHJldHVybiBmLm11bChsaHMsIHR5cGVvZiByaHMgPT09ICdiaWdpbnQnID8gaW52ZXJ0KHJocywgZi5PUkRFUikgOiBmLmludihyaHMpKTtcbn1cbi8vIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBUcnVlIHdoZW5ldmVyIHRoZSB2YWx1ZSB4IGlzIGEgc3F1YXJlIGluIHRoZSBmaWVsZCBGLlxuZXhwb3J0IGZ1bmN0aW9uIEZwSXNTcXVhcmUoZikge1xuICAgIGNvbnN0IGxlZ2VuZHJlQ29uc3QgPSAoZi5PUkRFUiAtIF8xbikgLyBfMm47IC8vIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIHJldHVybiAoeCkgPT4ge1xuICAgICAgICBjb25zdCBwID0gZi5wb3coeCwgbGVnZW5kcmVDb25zdCk7XG4gICAgICAgIHJldHVybiBmLmVxbChwLCBmLlpFUk8pIHx8IGYuZXFsKHAsIGYuT05FKTtcbiAgICB9O1xufVxuLy8gQ1VSVkUubiBsZW5ndGhzXG5leHBvcnQgZnVuY3Rpb24gbkxlbmd0aChuLCBuQml0TGVuZ3RoKSB7XG4gICAgLy8gQml0IHNpemUsIGJ5dGUgc2l6ZSBvZiBDVVJWRS5uXG4gICAgY29uc3QgX25CaXRMZW5ndGggPSBuQml0TGVuZ3RoICE9PSB1bmRlZmluZWQgPyBuQml0TGVuZ3RoIDogbi50b1N0cmluZygyKS5sZW5ndGg7XG4gICAgY29uc3QgbkJ5dGVMZW5ndGggPSBNYXRoLmNlaWwoX25CaXRMZW5ndGggLyA4KTtcbiAgICByZXR1cm4geyBuQml0TGVuZ3RoOiBfbkJpdExlbmd0aCwgbkJ5dGVMZW5ndGggfTtcbn1cbi8qKlxuICogSW5pdGlhbGl6ZXMgYSBmaW5pdGUgZmllbGQgb3ZlciBwcmltZS4gKipOb24tcHJpbWVzIGFyZSBub3Qgc3VwcG9ydGVkLioqXG4gKiBEbyBub3QgaW5pdCBpbiBsb29wOiBzbG93LiBWZXJ5IGZyYWdpbGU6IGFsd2F5cyBydW4gYSBiZW5jaG1hcmsgb24gYSBjaGFuZ2UuXG4gKiBNYWpvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb25zOlxuICogKiBhKSBkZW5vcm1hbGl6ZWQgb3BlcmF0aW9ucyBsaWtlIG11bE4gaW5zdGVhZCBvZiBtdWxcbiAqICogYikgc2FtZSBvYmplY3Qgc2hhcGU6IG5ldmVyIGFkZCBvciByZW1vdmUga2V5c1xuICogKiBjKSBPYmplY3QuZnJlZXplXG4gKiBAcGFyYW0gT1JERVIgcHJpbWUgcG9zaXRpdmUgYmlnaW50XG4gKiBAcGFyYW0gYml0TGVuIGhvdyBtYW55IGJpdHMgdGhlIGZpZWxkIGNvbnN1bWVzXG4gKiBAcGFyYW0gaXNMRSAoZGVmOiBmYWxzZSkgaWYgZW5jb2RpbmcgLyBkZWNvZGluZyBzaG91bGQgYmUgaW4gbGl0dGxlLWVuZGlhblxuICogQHBhcmFtIHJlZGVmIG9wdGlvbmFsIGZhc3RlciByZWRlZmluaXRpb25zIG9mIHNxcnQgYW5kIG90aGVyIG1ldGhvZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIEZpZWxkKE9SREVSLCBiaXRMZW4sIGlzTEUgPSBmYWxzZSwgcmVkZWYgPSB7fSkge1xuICAgIGlmIChPUkRFUiA8PSBfMG4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgRXhwZWN0ZWQgRmllbGQgT1JERVIgPiAwLCBnb3QgJHtPUkRFUn1gKTtcbiAgICBjb25zdCB7IG5CaXRMZW5ndGg6IEJJVFMsIG5CeXRlTGVuZ3RoOiBCWVRFUyB9ID0gbkxlbmd0aChPUkRFUiwgYml0TGVuKTtcbiAgICBpZiAoQllURVMgPiAyMDQ4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpZWxkIGxlbmd0aHMgb3ZlciAyMDQ4IGJ5dGVzIGFyZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgY29uc3Qgc3FydFAgPSBGcFNxcnQoT1JERVIpO1xuICAgIGNvbnN0IGYgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgT1JERVIsXG4gICAgICAgIEJJVFMsXG4gICAgICAgIEJZVEVTLFxuICAgICAgICBNQVNLOiBiaXRNYXNrKEJJVFMpLFxuICAgICAgICBaRVJPOiBfMG4sXG4gICAgICAgIE9ORTogXzFuLFxuICAgICAgICBjcmVhdGU6IChudW0pID0+IG1vZChudW0sIE9SREVSKSxcbiAgICAgICAgaXNWYWxpZDogKG51bSkgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBudW0gIT09ICdiaWdpbnQnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWVsZCBlbGVtZW50OiBleHBlY3RlZCBiaWdpbnQsIGdvdCAke3R5cGVvZiBudW19YCk7XG4gICAgICAgICAgICByZXR1cm4gXzBuIDw9IG51bSAmJiBudW0gPCBPUkRFUjsgLy8gMCBpcyB2YWxpZCBlbGVtZW50LCBidXQgaXQncyBub3QgaW52ZXJ0aWJsZVxuICAgICAgICB9LFxuICAgICAgICBpczA6IChudW0pID0+IG51bSA9PT0gXzBuLFxuICAgICAgICBpc09kZDogKG51bSkgPT4gKG51bSAmIF8xbikgPT09IF8xbixcbiAgICAgICAgbmVnOiAobnVtKSA9PiBtb2QoLW51bSwgT1JERVIpLFxuICAgICAgICBlcWw6IChsaHMsIHJocykgPT4gbGhzID09PSByaHMsXG4gICAgICAgIHNxcjogKG51bSkgPT4gbW9kKG51bSAqIG51bSwgT1JERVIpLFxuICAgICAgICBhZGQ6IChsaHMsIHJocykgPT4gbW9kKGxocyArIHJocywgT1JERVIpLFxuICAgICAgICBzdWI6IChsaHMsIHJocykgPT4gbW9kKGxocyAtIHJocywgT1JERVIpLFxuICAgICAgICBtdWw6IChsaHMsIHJocykgPT4gbW9kKGxocyAqIHJocywgT1JERVIpLFxuICAgICAgICBwb3c6IChudW0sIHBvd2VyKSA9PiBGcFBvdyhmLCBudW0sIHBvd2VyKSxcbiAgICAgICAgZGl2OiAobGhzLCByaHMpID0+IG1vZChsaHMgKiBpbnZlcnQocmhzLCBPUkRFUiksIE9SREVSKSxcbiAgICAgICAgLy8gU2FtZSBhcyBhYm92ZSwgYnV0IGRvZXNuJ3Qgbm9ybWFsaXplXG4gICAgICAgIHNxck46IChudW0pID0+IG51bSAqIG51bSxcbiAgICAgICAgYWRkTjogKGxocywgcmhzKSA9PiBsaHMgKyByaHMsXG4gICAgICAgIHN1Yk46IChsaHMsIHJocykgPT4gbGhzIC0gcmhzLFxuICAgICAgICBtdWxOOiAobGhzLCByaHMpID0+IGxocyAqIHJocyxcbiAgICAgICAgaW52OiAobnVtKSA9PiBpbnZlcnQobnVtLCBPUkRFUiksXG4gICAgICAgIHNxcnQ6IHJlZGVmLnNxcnQgfHwgKChuKSA9PiBzcXJ0UChmLCBuKSksXG4gICAgICAgIGludmVydEJhdGNoOiAobHN0KSA9PiBGcEludmVydEJhdGNoKGYsIGxzdCksXG4gICAgICAgIC8vIFRPRE86IGRvIHdlIHJlYWxseSBuZWVkIGNvbnN0YW50IGNtb3Y/XG4gICAgICAgIC8vIFdlIGRvbid0IGhhdmUgY29uc3QtdGltZSBiaWdpbnRzIGFueXdheSwgc28gcHJvYmFibHkgd2lsbCBiZSBub3QgdmVyeSB1c2VmdWxcbiAgICAgICAgY21vdjogKGEsIGIsIGMpID0+IChjID8gYiA6IGEpLFxuICAgICAgICB0b0J5dGVzOiAobnVtKSA9PiAoaXNMRSA/IG51bWJlclRvQnl0ZXNMRShudW0sIEJZVEVTKSA6IG51bWJlclRvQnl0ZXNCRShudW0sIEJZVEVTKSksXG4gICAgICAgIGZyb21CeXRlczogKGJ5dGVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICE9PSBCWVRFUylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZwLmZyb21CeXRlczogZXhwZWN0ZWQgJHtCWVRFU30sIGdvdCAke2J5dGVzLmxlbmd0aH1gKTtcbiAgICAgICAgICAgIHJldHVybiBpc0xFID8gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSA6IGJ5dGVzVG9OdW1iZXJCRShieXRlcyk7XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoZik7XG59XG5leHBvcnQgZnVuY3Rpb24gRnBTcXJ0T2RkKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gcm9vdCA6IEZwLm5lZyhyb290KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBGcFNxcnRFdmVuKEZwLCBlbG0pIHtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZpZWxkIGRvZXNuJ3QgaGF2ZSBpc09kZGApO1xuICAgIGNvbnN0IHJvb3QgPSBGcC5zcXJ0KGVsbSk7XG4gICAgcmV0dXJuIEZwLmlzT2RkKHJvb3QpID8gRnAubmVnKHJvb3QpIDogcm9vdDtcbn1cbi8qKlxuICogXCJDb25zdGFudC10aW1lXCIgcHJpdmF0ZSBrZXkgZ2VuZXJhdGlvbiB1dGlsaXR5LlxuICogU2FtZSBhcyBtYXBLZXlUb0ZpZWxkLCBidXQgYWNjZXB0cyBsZXNzIGJ5dGVzICg0MCBpbnN0ZWFkIG9mIDQ4IGZvciAzMi1ieXRlIGZpZWxkKS5cbiAqIFdoaWNoIG1ha2VzIGl0IHNsaWdodGx5IG1vcmUgYmlhc2VkLCBsZXNzIHNlY3VyZS5cbiAqIEBkZXByZWNhdGVkIHVzZSBtYXBLZXlUb0ZpZWxkIGluc3RlYWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhc2hUb1ByaXZhdGVTY2FsYXIoaGFzaCwgZ3JvdXBPcmRlciwgaXNMRSA9IGZhbHNlKSB7XG4gICAgaGFzaCA9IGVuc3VyZUJ5dGVzKCdwcml2YXRlSGFzaCcsIGhhc2gpO1xuICAgIGNvbnN0IGhhc2hMZW4gPSBoYXNoLmxlbmd0aDtcbiAgICBjb25zdCBtaW5MZW4gPSBuTGVuZ3RoKGdyb3VwT3JkZXIpLm5CeXRlTGVuZ3RoICsgODtcbiAgICBpZiAobWluTGVuIDwgMjQgfHwgaGFzaExlbiA8IG1pbkxlbiB8fCBoYXNoTGVuID4gMTAyNClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBoYXNoVG9Qcml2YXRlU2NhbGFyOiBleHBlY3RlZCAke21pbkxlbn0tMTAyNCBieXRlcyBvZiBpbnB1dCwgZ290ICR7aGFzaExlbn1gKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckxFKGhhc2gpIDogYnl0ZXNUb051bWJlckJFKGhhc2gpO1xuICAgIHJldHVybiBtb2QobnVtLCBncm91cE9yZGVyIC0gXzFuKSArIF8xbjtcbn1cbi8qKlxuICogUmV0dXJucyB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgY29uc3VtZWQgYnkgdGhlIGZpZWxkIGVsZW1lbnQuXG4gKiBGb3IgZXhhbXBsZSwgMzIgYnl0ZXMgZm9yIHVzdWFsIDI1Ni1iaXQgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBAcGFyYW0gZmllbGRPcmRlciBudW1iZXIgb2YgZmllbGQgZWxlbWVudHMsIHVzdWFsbHkgQ1VSVkUublxuICogQHJldHVybnMgYnl0ZSBsZW5ndGggb2YgZmllbGRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEZpZWxkQnl0ZXNMZW5ndGgoZmllbGRPcmRlcikge1xuICAgIGlmICh0eXBlb2YgZmllbGRPcmRlciAhPT0gJ2JpZ2ludCcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmllbGQgb3JkZXIgbXVzdCBiZSBiaWdpbnQnKTtcbiAgICBjb25zdCBiaXRMZW5ndGggPSBmaWVsZE9yZGVyLnRvU3RyaW5nKDIpLmxlbmd0aDtcbiAgICByZXR1cm4gTWF0aC5jZWlsKGJpdExlbmd0aCAvIDgpO1xufVxuLyoqXG4gKiBSZXR1cm5zIG1pbmltYWwgYW1vdW50IG9mIGJ5dGVzIHRoYXQgY2FuIGJlIHNhZmVseSByZWR1Y2VkXG4gKiBieSBmaWVsZCBvcmRlci5cbiAqIFNob3VsZCBiZSAyXi0xMjggZm9yIDEyOC1iaXQgY3VydmUgc3VjaCBhcyBQMjU2LlxuICogQHBhcmFtIGZpZWxkT3JkZXIgbnVtYmVyIG9mIGZpZWxkIGVsZW1lbnRzLCB1c3VhbGx5IENVUlZFLm5cbiAqIEByZXR1cm5zIGJ5dGUgbGVuZ3RoIG9mIHRhcmdldCBoYXNoXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpIHtcbiAgICBjb25zdCBsZW5ndGggPSBnZXRGaWVsZEJ5dGVzTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIHJldHVybiBsZW5ndGggKyBNYXRoLmNlaWwobGVuZ3RoIC8gMik7XG59XG4vKipcbiAqIFwiQ29uc3RhbnQtdGltZVwiIHByaXZhdGUga2V5IGdlbmVyYXRpb24gdXRpbGl0eS5cbiAqIENhbiB0YWtlIChuICsgbi8yKSBvciBtb3JlIGJ5dGVzIG9mIHVuaWZvcm0gaW5wdXQgZS5nLiBmcm9tIENTUFJORyBvciBLREZcbiAqIGFuZCBjb252ZXJ0IHRoZW0gaW50byBwcml2YXRlIHNjYWxhciwgd2l0aCB0aGUgbW9kdWxvIGJpYXMgYmVpbmcgbmVnbGlnaWJsZS5cbiAqIE5lZWRzIGF0IGxlYXN0IDQ4IGJ5dGVzIG9mIGlucHV0IGZvciAzMi1ieXRlIHByaXZhdGUga2V5LlxuICogaHR0cHM6Ly9yZXNlYXJjaC5rdWRlbHNraXNlY3VyaXR5LmNvbS8yMDIwLzA3LzI4L3RoZS1kZWZpbml0aXZlLWd1aWRlLXRvLW1vZHVsby1iaWFzLWFuZC1ob3ctdG8tYXZvaWQtaXQvXG4gKiBGSVBTIDE4Ni01LCBBLjIgaHR0cHM6Ly9jc3JjLm5pc3QuZ292L3B1YmxpY2F0aW9ucy9kZXRhaWwvZmlwcy8xODYvNS9maW5hbFxuICogUkZDIDkzODAsIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM5MzgwI3NlY3Rpb24tNVxuICogQHBhcmFtIGhhc2ggaGFzaCBvdXRwdXQgZnJvbSBTSEEzIG9yIGEgc2ltaWxhciBmdW5jdGlvblxuICogQHBhcmFtIGdyb3VwT3JkZXIgc2l6ZSBvZiBzdWJncm91cCAtIChlLmcuIHNlY3AyNTZrMS5DVVJWRS5uKVxuICogQHBhcmFtIGlzTEUgaW50ZXJwcmV0IGhhc2ggYnl0ZXMgYXMgTEUgbnVtXG4gKiBAcmV0dXJucyB2YWxpZCBwcml2YXRlIHNjYWxhclxuICovXG5leHBvcnQgZnVuY3Rpb24gbWFwSGFzaFRvRmllbGQoa2V5LCBmaWVsZE9yZGVyLCBpc0xFID0gZmFsc2UpIHtcbiAgICBjb25zdCBsZW4gPSBrZXkubGVuZ3RoO1xuICAgIGNvbnN0IGZpZWxkTGVuID0gZ2V0RmllbGRCeXRlc0xlbmd0aChmaWVsZE9yZGVyKTtcbiAgICBjb25zdCBtaW5MZW4gPSBnZXRNaW5IYXNoTGVuZ3RoKGZpZWxkT3JkZXIpO1xuICAgIC8vIE5vIHNtYWxsIG51bWJlcnM6IG5lZWQgdG8gdW5kZXJzdGFuZCBiaWFzIHN0b3J5LiBObyBodWdlIG51bWJlcnM6IGVhc2llciB0byBkZXRlY3QgSlMgdGltaW5ncy5cbiAgICBpZiAobGVuIDwgMTYgfHwgbGVuIDwgbWluTGVuIHx8IGxlbiA+IDEwMjQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZXhwZWN0ZWQgJHttaW5MZW59LTEwMjQgYnl0ZXMgb2YgaW5wdXQsIGdvdCAke2xlbn1gKTtcbiAgICBjb25zdCBudW0gPSBpc0xFID8gYnl0ZXNUb051bWJlckJFKGtleSkgOiBieXRlc1RvTnVtYmVyTEUoa2V5KTtcbiAgICAvLyBgbW9kKHgsIDExKWAgY2FuIHNvbWV0aW1lcyBwcm9kdWNlIDAuIGBtb2QoeCwgMTApICsgMWAgaXMgdGhlIHNhbWUsIGJ1dCBubyAwXG4gICAgY29uc3QgcmVkdWNlZCA9IG1vZChudW0sIGZpZWxkT3JkZXIgLSBfMW4pICsgXzFuO1xuICAgIHJldHVybiBpc0xFID8gbnVtYmVyVG9CeXRlc0xFKHJlZHVjZWQsIGZpZWxkTGVuKSA6IG51bWJlclRvQnl0ZXNCRShyZWR1Y2VkLCBmaWVsZExlbik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2R1bGFyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/montgomery.js":
/*!***************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/montgomery.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   montgomery: function() { return /* binding */ montgomery; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nfunction validateOpts(curve) {\n    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.validateObject)(curve, {\n        a: 'bigint',\n    }, {\n        montgomeryBits: 'isSafeInteger',\n        nByteLength: 'isSafeInteger',\n        adjustScalarBytes: 'function',\n        domain: 'function',\n        powPminus2: 'function',\n        Gu: 'bigint',\n    });\n    // Set defaults\n    return Object.freeze({ ...curve });\n}\n// NOTE: not really montgomery curve, just bunch of very specific methods for X25519/X448 (RFC 7748, https://www.rfc-editor.org/rfc/rfc7748)\n// Uses only one coordinate instead of two\nfunction montgomery(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { P } = CURVE;\n    const modP = (n) => (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.mod)(n, P);\n    const montgomeryBits = CURVE.montgomeryBits;\n    const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n    const fieldLen = CURVE.nByteLength;\n    const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);\n    const powPminus2 = CURVE.powPminus2 || ((x) => (0,_modular_js__WEBPACK_IMPORTED_MODULE_1__.pow)(x, P - BigInt(2), P));\n    // cswap from RFC7748. But it is not from RFC7748!\n    /*\n      cswap(swap, x_2, x_3):\n           dummy = mask(swap) AND (x_2 XOR x_3)\n           x_2 = x_2 XOR dummy\n           x_3 = x_3 XOR dummy\n           Return (x_2, x_3)\n    Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n     and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    */\n    function cswap(swap, x_2, x_3) {\n        const dummy = modP(swap * (x_2 - x_3));\n        x_2 = modP(x_2 - dummy);\n        x_3 = modP(x_3 + dummy);\n        return [x_2, x_3];\n    }\n    // Accepts 0 as well\n    function assertFieldElement(n) {\n        if (typeof n === 'bigint' && _0n <= n && n < P)\n            return n;\n        throw new Error('Expected valid scalar 0 < scalar < CURVE.P');\n    }\n    // x25519 from 4\n    // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n    const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n    /**\n     *\n     * @param pointU u coordinate (x) on Montgomery Curve 25519\n     * @param scalar by which the point would be multiplied\n     * @returns new Point on Montgomery curve\n     */\n    function montgomeryLadder(pointU, scalar) {\n        const u = assertFieldElement(pointU);\n        // Section 5: Implementations MUST accept non-canonical values and process them as\n        // if they had been reduced modulo the field prime.\n        const k = assertFieldElement(scalar);\n        const x_1 = u;\n        let x_2 = _1n;\n        let z_2 = _0n;\n        let x_3 = u;\n        let z_3 = _1n;\n        let swap = _0n;\n        let sw;\n        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n            const k_t = (k >> t) & _1n;\n            swap ^= k_t;\n            sw = cswap(swap, x_2, x_3);\n            x_2 = sw[0];\n            x_3 = sw[1];\n            sw = cswap(swap, z_2, z_3);\n            z_2 = sw[0];\n            z_3 = sw[1];\n            swap = k_t;\n            const A = x_2 + z_2;\n            const AA = modP(A * A);\n            const B = x_2 - z_2;\n            const BB = modP(B * B);\n            const E = AA - BB;\n            const C = x_3 + z_3;\n            const D = x_3 - z_3;\n            const DA = modP(D * A);\n            const CB = modP(C * B);\n            const dacb = DA + CB;\n            const da_cb = DA - CB;\n            x_3 = modP(dacb * dacb);\n            z_3 = modP(x_1 * modP(da_cb * da_cb));\n            x_2 = modP(AA * BB);\n            z_2 = modP(E * (AA + modP(a24 * E)));\n        }\n        // (x_2, x_3) = cswap(swap, x_2, x_3)\n        sw = cswap(swap, x_2, x_3);\n        x_2 = sw[0];\n        x_3 = sw[1];\n        // (z_2, z_3) = cswap(swap, z_2, z_3)\n        sw = cswap(swap, z_2, z_3);\n        z_2 = sw[0];\n        z_3 = sw[1];\n        // z_2^(p - 2)\n        const z2 = powPminus2(z_2);\n        // Return x_2 * (z_2^(p - 2))\n        return modP(x_2 * z2);\n    }\n    function encodeUCoordinate(u) {\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.numberToBytesLE)(modP(u), montgomeryBytes);\n    }\n    function decodeUCoordinate(uEnc) {\n        // Section 5: When receiving such an array, implementations of X25519\n        // MUST mask the most significant bit in the final byte.\n        const u = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('u coordinate', uEnc, montgomeryBytes);\n        if (fieldLen === 32)\n            u[31] &= 127; // 0b0111_1111\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(u);\n    }\n    function decodeScalar(n) {\n        const bytes = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ensureBytes)('scalar', n);\n        const len = bytes.length;\n        if (len !== montgomeryBytes && len !== fieldLen)\n            throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);\n        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.bytesToNumberLE)(adjustScalarBytes(bytes));\n    }\n    function scalarMult(scalar, u) {\n        const pointU = decodeUCoordinate(u);\n        const _scalar = decodeScalar(scalar);\n        const pu = montgomeryLadder(pointU, _scalar);\n        // The result was not contributory\n        // https://cr.yp.to/ecdh.html#validate\n        if (pu === _0n)\n            throw new Error('Invalid private or public key received');\n        return encodeUCoordinate(pu);\n    }\n    // Computes public key from private. By doing scalar multiplication of base point.\n    const GuBytes = encodeUCoordinate(CURVE.Gu);\n    function scalarMultBase(scalar) {\n        return scalarMult(scalar, GuBytes);\n    }\n    return {\n        scalarMult,\n        scalarMultBase,\n        getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),\n        getPublicKey: (privateKey) => scalarMultBase(privateKey),\n        utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },\n        GuBytes: GuBytes,\n    };\n}\n//# sourceMappingURL=montgomery.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC9tb250Z29tZXJ5LmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ3dDO0FBQ21EO0FBQzNGO0FBQ0E7QUFDQTtBQUNBLElBQUkseURBQWM7QUFDbEI7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLFlBQVksSUFBSTtBQUNoQix3QkFBd0IsZ0RBQUc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0RBQUc7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsVUFBVTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLDBEQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFXO0FBQzdCO0FBQ0EsMEJBQTBCO0FBQzFCLGVBQWUsMERBQWU7QUFDOUI7QUFDQTtBQUNBLHNCQUFzQixzREFBVztBQUNqQztBQUNBO0FBQ0Esd0NBQXdDLGlCQUFpQixLQUFLLFVBQVUsYUFBYSxJQUFJO0FBQ3pGLGVBQWUsMERBQWU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDhEQUE4RDtBQUMvRTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9lc20vYWJzdHJhY3QvbW9udGdvbWVyeS5qcz9mNzQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IG1vZCwgcG93IH0gZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCB7IGJ5dGVzVG9OdW1iZXJMRSwgZW5zdXJlQnl0ZXMsIG51bWJlclRvQnl0ZXNMRSwgdmFsaWRhdGVPYmplY3QgfSBmcm9tICcuL3V0aWxzLmpzJztcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmZ1bmN0aW9uIHZhbGlkYXRlT3B0cyhjdXJ2ZSkge1xuICAgIHZhbGlkYXRlT2JqZWN0KGN1cnZlLCB7XG4gICAgICAgIGE6ICdiaWdpbnQnLFxuICAgIH0sIHtcbiAgICAgICAgbW9udGdvbWVyeUJpdHM6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgbkJ5dGVMZW5ndGg6ICdpc1NhZmVJbnRlZ2VyJyxcbiAgICAgICAgYWRqdXN0U2NhbGFyQnl0ZXM6ICdmdW5jdGlvbicsXG4gICAgICAgIGRvbWFpbjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgcG93UG1pbnVzMjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgR3U6ICdiaWdpbnQnLFxuICAgIH0pO1xuICAgIC8vIFNldCBkZWZhdWx0c1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKHsgLi4uY3VydmUgfSk7XG59XG4vLyBOT1RFOiBub3QgcmVhbGx5IG1vbnRnb21lcnkgY3VydmUsIGp1c3QgYnVuY2ggb2YgdmVyeSBzcGVjaWZpYyBtZXRob2RzIGZvciBYMjU1MTkvWDQ0OCAoUkZDIDc3NDgsIGh0dHBzOi8vd3d3LnJmYy1lZGl0b3Iub3JnL3JmYy9yZmM3NzQ4KVxuLy8gVXNlcyBvbmx5IG9uZSBjb29yZGluYXRlIGluc3RlYWQgb2YgdHdvXG5leHBvcnQgZnVuY3Rpb24gbW9udGdvbWVyeShjdXJ2ZURlZikge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVPcHRzKGN1cnZlRGVmKTtcbiAgICBjb25zdCB7IFAgfSA9IENVUlZFO1xuICAgIGNvbnN0IG1vZFAgPSAobikgPT4gbW9kKG4sIFApO1xuICAgIGNvbnN0IG1vbnRnb21lcnlCaXRzID0gQ1VSVkUubW9udGdvbWVyeUJpdHM7XG4gICAgY29uc3QgbW9udGdvbWVyeUJ5dGVzID0gTWF0aC5jZWlsKG1vbnRnb21lcnlCaXRzIC8gOCk7XG4gICAgY29uc3QgZmllbGRMZW4gPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICBjb25zdCBhZGp1c3RTY2FsYXJCeXRlcyA9IENVUlZFLmFkanVzdFNjYWxhckJ5dGVzIHx8ICgoYnl0ZXMpID0+IGJ5dGVzKTtcbiAgICBjb25zdCBwb3dQbWludXMyID0gQ1VSVkUucG93UG1pbnVzMiB8fCAoKHgpID0+IHBvdyh4LCBQIC0gQmlnSW50KDIpLCBQKSk7XG4gICAgLy8gY3N3YXAgZnJvbSBSRkM3NzQ4LiBCdXQgaXQgaXMgbm90IGZyb20gUkZDNzc0OCFcbiAgICAvKlxuICAgICAgY3N3YXAoc3dhcCwgeF8yLCB4XzMpOlxuICAgICAgICAgICBkdW1teSA9IG1hc2soc3dhcCkgQU5EICh4XzIgWE9SIHhfMylcbiAgICAgICAgICAgeF8yID0geF8yIFhPUiBkdW1teVxuICAgICAgICAgICB4XzMgPSB4XzMgWE9SIGR1bW15XG4gICAgICAgICAgIFJldHVybiAoeF8yLCB4XzMpXG4gICAgV2hlcmUgbWFzayhzd2FwKSBpcyB0aGUgYWxsLTEgb3IgYWxsLTAgd29yZCBvZiB0aGUgc2FtZSBsZW5ndGggYXMgeF8yXG4gICAgIGFuZCB4XzMsIGNvbXB1dGVkLCBlLmcuLCBhcyBtYXNrKHN3YXApID0gMCAtIHN3YXAuXG4gICAgKi9cbiAgICBmdW5jdGlvbiBjc3dhcChzd2FwLCB4XzIsIHhfMykge1xuICAgICAgICBjb25zdCBkdW1teSA9IG1vZFAoc3dhcCAqICh4XzIgLSB4XzMpKTtcbiAgICAgICAgeF8yID0gbW9kUCh4XzIgLSBkdW1teSk7XG4gICAgICAgIHhfMyA9IG1vZFAoeF8zICsgZHVtbXkpO1xuICAgICAgICByZXR1cm4gW3hfMiwgeF8zXTtcbiAgICB9XG4gICAgLy8gQWNjZXB0cyAwIGFzIHdlbGxcbiAgICBmdW5jdGlvbiBhc3NlcnRGaWVsZEVsZW1lbnQobikge1xuICAgICAgICBpZiAodHlwZW9mIG4gPT09ICdiaWdpbnQnICYmIF8wbiA8PSBuICYmIG4gPCBQKVxuICAgICAgICAgICAgcmV0dXJuIG47XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdmFsaWQgc2NhbGFyIDAgPCBzY2FsYXIgPCBDVVJWRS5QJyk7XG4gICAgfVxuICAgIC8vIHgyNTUxOSBmcm9tIDRcbiAgICAvLyBUaGUgY29uc3RhbnQgYTI0IGlzICg0ODY2NjIgLSAyKSAvIDQgPSAxMjE2NjUgZm9yIGN1cnZlMjU1MTkvWDI1NTE5XG4gICAgY29uc3QgYTI0ID0gKENVUlZFLmEgLSBCaWdJbnQoMikpIC8gQmlnSW50KDQpO1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvaW50VSB1IGNvb3JkaW5hdGUgKHgpIG9uIE1vbnRnb21lcnkgQ3VydmUgMjU1MTlcbiAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICogQHJldHVybnMgbmV3IFBvaW50IG9uIE1vbnRnb21lcnkgY3VydmVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtb250Z29tZXJ5TGFkZGVyKHBvaW50VSwgc2NhbGFyKSB7XG4gICAgICAgIGNvbnN0IHUgPSBhc3NlcnRGaWVsZEVsZW1lbnQocG9pbnRVKTtcbiAgICAgICAgLy8gU2VjdGlvbiA1OiBJbXBsZW1lbnRhdGlvbnMgTVVTVCBhY2NlcHQgbm9uLWNhbm9uaWNhbCB2YWx1ZXMgYW5kIHByb2Nlc3MgdGhlbSBhc1xuICAgICAgICAvLyBpZiB0aGV5IGhhZCBiZWVuIHJlZHVjZWQgbW9kdWxvIHRoZSBmaWVsZCBwcmltZS5cbiAgICAgICAgY29uc3QgayA9IGFzc2VydEZpZWxkRWxlbWVudChzY2FsYXIpO1xuICAgICAgICBjb25zdCB4XzEgPSB1O1xuICAgICAgICBsZXQgeF8yID0gXzFuO1xuICAgICAgICBsZXQgel8yID0gXzBuO1xuICAgICAgICBsZXQgeF8zID0gdTtcbiAgICAgICAgbGV0IHpfMyA9IF8xbjtcbiAgICAgICAgbGV0IHN3YXAgPSBfMG47XG4gICAgICAgIGxldCBzdztcbiAgICAgICAgZm9yIChsZXQgdCA9IEJpZ0ludChtb250Z29tZXJ5Qml0cyAtIDEpOyB0ID49IF8wbjsgdC0tKSB7XG4gICAgICAgICAgICBjb25zdCBrX3QgPSAoayA+PiB0KSAmIF8xbjtcbiAgICAgICAgICAgIHN3YXAgXj0ga190O1xuICAgICAgICAgICAgc3cgPSBjc3dhcChzd2FwLCB4XzIsIHhfMyk7XG4gICAgICAgICAgICB4XzIgPSBzd1swXTtcbiAgICAgICAgICAgIHhfMyA9IHN3WzFdO1xuICAgICAgICAgICAgc3cgPSBjc3dhcChzd2FwLCB6XzIsIHpfMyk7XG4gICAgICAgICAgICB6XzIgPSBzd1swXTtcbiAgICAgICAgICAgIHpfMyA9IHN3WzFdO1xuICAgICAgICAgICAgc3dhcCA9IGtfdDtcbiAgICAgICAgICAgIGNvbnN0IEEgPSB4XzIgKyB6XzI7XG4gICAgICAgICAgICBjb25zdCBBQSA9IG1vZFAoQSAqIEEpO1xuICAgICAgICAgICAgY29uc3QgQiA9IHhfMiAtIHpfMjtcbiAgICAgICAgICAgIGNvbnN0IEJCID0gbW9kUChCICogQik7XG4gICAgICAgICAgICBjb25zdCBFID0gQUEgLSBCQjtcbiAgICAgICAgICAgIGNvbnN0IEMgPSB4XzMgKyB6XzM7XG4gICAgICAgICAgICBjb25zdCBEID0geF8zIC0gel8zO1xuICAgICAgICAgICAgY29uc3QgREEgPSBtb2RQKEQgKiBBKTtcbiAgICAgICAgICAgIGNvbnN0IENCID0gbW9kUChDICogQik7XG4gICAgICAgICAgICBjb25zdCBkYWNiID0gREEgKyBDQjtcbiAgICAgICAgICAgIGNvbnN0IGRhX2NiID0gREEgLSBDQjtcbiAgICAgICAgICAgIHhfMyA9IG1vZFAoZGFjYiAqIGRhY2IpO1xuICAgICAgICAgICAgel8zID0gbW9kUCh4XzEgKiBtb2RQKGRhX2NiICogZGFfY2IpKTtcbiAgICAgICAgICAgIHhfMiA9IG1vZFAoQUEgKiBCQik7XG4gICAgICAgICAgICB6XzIgPSBtb2RQKEUgKiAoQUEgKyBtb2RQKGEyNCAqIEUpKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gKHhfMiwgeF8zKSA9IGNzd2FwKHN3YXAsIHhfMiwgeF8zKVxuICAgICAgICBzdyA9IGNzd2FwKHN3YXAsIHhfMiwgeF8zKTtcbiAgICAgICAgeF8yID0gc3dbMF07XG4gICAgICAgIHhfMyA9IHN3WzFdO1xuICAgICAgICAvLyAoel8yLCB6XzMpID0gY3N3YXAoc3dhcCwgel8yLCB6XzMpXG4gICAgICAgIHN3ID0gY3N3YXAoc3dhcCwgel8yLCB6XzMpO1xuICAgICAgICB6XzIgPSBzd1swXTtcbiAgICAgICAgel8zID0gc3dbMV07XG4gICAgICAgIC8vIHpfMl4ocCAtIDIpXG4gICAgICAgIGNvbnN0IHoyID0gcG93UG1pbnVzMih6XzIpO1xuICAgICAgICAvLyBSZXR1cm4geF8yICogKHpfMl4ocCAtIDIpKVxuICAgICAgICByZXR1cm4gbW9kUCh4XzIgKiB6Mik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZVVDb29yZGluYXRlKHUpIHtcbiAgICAgICAgcmV0dXJuIG51bWJlclRvQnl0ZXNMRShtb2RQKHUpLCBtb250Z29tZXJ5Qnl0ZXMpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVVQ29vcmRpbmF0ZSh1RW5jKSB7XG4gICAgICAgIC8vIFNlY3Rpb24gNTogV2hlbiByZWNlaXZpbmcgc3VjaCBhbiBhcnJheSwgaW1wbGVtZW50YXRpb25zIG9mIFgyNTUxOVxuICAgICAgICAvLyBNVVNUIG1hc2sgdGhlIG1vc3Qgc2lnbmlmaWNhbnQgYml0IGluIHRoZSBmaW5hbCBieXRlLlxuICAgICAgICBjb25zdCB1ID0gZW5zdXJlQnl0ZXMoJ3UgY29vcmRpbmF0ZScsIHVFbmMsIG1vbnRnb21lcnlCeXRlcyk7XG4gICAgICAgIGlmIChmaWVsZExlbiA9PT0gMzIpXG4gICAgICAgICAgICB1WzMxXSAmPSAxMjc7IC8vIDBiMDExMV8xMTExXG4gICAgICAgIHJldHVybiBieXRlc1RvTnVtYmVyTEUodSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZVNjYWxhcihuKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZW5zdXJlQnl0ZXMoJ3NjYWxhcicsIG4pO1xuICAgICAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gIT09IG1vbnRnb21lcnlCeXRlcyAmJiBsZW4gIT09IGZpZWxkTGVuKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFeHBlY3RlZCAke21vbnRnb21lcnlCeXRlc30gb3IgJHtmaWVsZExlbn0gYnl0ZXMsIGdvdCAke2xlbn1gKTtcbiAgICAgICAgcmV0dXJuIGJ5dGVzVG9OdW1iZXJMRShhZGp1c3RTY2FsYXJCeXRlcyhieXRlcykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsYXJNdWx0KHNjYWxhciwgdSkge1xuICAgICAgICBjb25zdCBwb2ludFUgPSBkZWNvZGVVQ29vcmRpbmF0ZSh1KTtcbiAgICAgICAgY29uc3QgX3NjYWxhciA9IGRlY29kZVNjYWxhcihzY2FsYXIpO1xuICAgICAgICBjb25zdCBwdSA9IG1vbnRnb21lcnlMYWRkZXIocG9pbnRVLCBfc2NhbGFyKTtcbiAgICAgICAgLy8gVGhlIHJlc3VsdCB3YXMgbm90IGNvbnRyaWJ1dG9yeVxuICAgICAgICAvLyBodHRwczovL2NyLnlwLnRvL2VjZGguaHRtbCN2YWxpZGF0ZVxuICAgICAgICBpZiAocHUgPT09IF8wbilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBwcml2YXRlIG9yIHB1YmxpYyBrZXkgcmVjZWl2ZWQnKTtcbiAgICAgICAgcmV0dXJuIGVuY29kZVVDb29yZGluYXRlKHB1KTtcbiAgICB9XG4gICAgLy8gQ29tcHV0ZXMgcHVibGljIGtleSBmcm9tIHByaXZhdGUuIEJ5IGRvaW5nIHNjYWxhciBtdWx0aXBsaWNhdGlvbiBvZiBiYXNlIHBvaW50LlxuICAgIGNvbnN0IEd1Qnl0ZXMgPSBlbmNvZGVVQ29vcmRpbmF0ZShDVVJWRS5HdSk7XG4gICAgZnVuY3Rpb24gc2NhbGFyTXVsdEJhc2Uoc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiBzY2FsYXJNdWx0KHNjYWxhciwgR3VCeXRlcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHNjYWxhck11bHQsXG4gICAgICAgIHNjYWxhck11bHRCYXNlLFxuICAgICAgICBnZXRTaGFyZWRTZWNyZXQ6IChwcml2YXRlS2V5LCBwdWJsaWNLZXkpID0+IHNjYWxhck11bHQocHJpdmF0ZUtleSwgcHVibGljS2V5KSxcbiAgICAgICAgZ2V0UHVibGljS2V5OiAocHJpdmF0ZUtleSkgPT4gc2NhbGFyTXVsdEJhc2UocHJpdmF0ZUtleSksXG4gICAgICAgIHV0aWxzOiB7IHJhbmRvbVByaXZhdGVLZXk6ICgpID0+IENVUlZFLnJhbmRvbUJ5dGVzKENVUlZFLm5CeXRlTGVuZ3RoKSB9LFxuICAgICAgICBHdUJ5dGVzOiBHdUJ5dGVzLFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb250Z29tZXJ5LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/montgomery.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/utils.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   abytes: function() { return /* binding */ abytes; },\n/* harmony export */   bitGet: function() { return /* binding */ bitGet; },\n/* harmony export */   bitLen: function() { return /* binding */ bitLen; },\n/* harmony export */   bitMask: function() { return /* binding */ bitMask; },\n/* harmony export */   bitSet: function() { return /* binding */ bitSet; },\n/* harmony export */   bytesToHex: function() { return /* binding */ bytesToHex; },\n/* harmony export */   bytesToNumberBE: function() { return /* binding */ bytesToNumberBE; },\n/* harmony export */   bytesToNumberLE: function() { return /* binding */ bytesToNumberLE; },\n/* harmony export */   concatBytes: function() { return /* binding */ concatBytes; },\n/* harmony export */   createHmacDrbg: function() { return /* binding */ createHmacDrbg; },\n/* harmony export */   ensureBytes: function() { return /* binding */ ensureBytes; },\n/* harmony export */   equalBytes: function() { return /* binding */ equalBytes; },\n/* harmony export */   hexToBytes: function() { return /* binding */ hexToBytes; },\n/* harmony export */   hexToNumber: function() { return /* binding */ hexToNumber; },\n/* harmony export */   isBytes: function() { return /* binding */ isBytes; },\n/* harmony export */   numberToBytesBE: function() { return /* binding */ numberToBytesBE; },\n/* harmony export */   numberToBytesLE: function() { return /* binding */ numberToBytesLE; },\n/* harmony export */   numberToHexUnpadded: function() { return /* binding */ numberToHexUnpadded; },\n/* harmony export */   numberToVarBytesBE: function() { return /* binding */ numberToVarBytesBE; },\n/* harmony export */   utf8ToBytes: function() { return /* binding */ utf8ToBytes; },\n/* harmony export */   validateObject: function() { return /* binding */ validateObject; }\n/* harmony export */ });\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction abytes(item) {\n    if (!isBytes(item))\n        throw new Error('Uint8Array expected');\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    abytes(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\nfunction numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? `0${hex}` : hex;\n}\nfunction hexToNumber(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    // Big Endian\n    return BigInt(hex === '' ? '0' : `0x${hex}`);\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n    return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === 'string') {\n        try {\n            res = hexToBytes(hex);\n        }\n        catch (e) {\n            throw new Error(`${title} must be valid hex string, got \"${hex}\". Cause: ${e}`);\n        }\n    }\n    else if (isBytes(hex)) {\n        // Uint8Array.from() instead of hash.slice() because node.js Buffer\n        // is instance of Uint8Array, and its slice() creates **mutable** copy\n        res = Uint8Array.from(hex);\n    }\n    else {\n        throw new Error(`${title} must be hex string or Uint8Array`);\n    }\n    const len = res.length;\n    if (typeof expectedLength === 'number' && len !== expectedLength)\n        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);\n    return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        abytes(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n    if (a.length !== b.length)\n        return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n        diff |= a[i] ^ b[i];\n    return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n        ;\n    return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n    return (n >> BigInt(pos)) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n    return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;\n// DRBG\nconst u8n = (data) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr) => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== 'number' || hashLen < 2)\n        throw new Error('hashLen must be a number');\n    if (typeof qByteLen !== 'number' || qByteLen < 2)\n        throw new Error('qByteLen must be a number');\n    if (typeof hmacFn !== 'function')\n        throw new Error('hmacFn must be a function');\n    // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n    let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n    let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n    let i = 0; // Iterations counter, will throw when over 1000\n    const reset = () => {\n        v.fill(1);\n        k.fill(0);\n        i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n    const reseed = (seed = u8n()) => {\n        // HMAC-DRBG reseed() function. Steps D-G\n        k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n        v = h(); // v = hmac(k || v)\n        if (seed.length === 0)\n            return;\n        k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n        v = h(); // v = hmac(k || v)\n    };\n    const gen = () => {\n        // HMAC-DRBG generate() function\n        if (i++ >= 1000)\n            throw new Error('drbg: tried 1000 values');\n        let len = 0;\n        const out = [];\n        while (len < qByteLen) {\n            v = h();\n            const sl = v.slice();\n            out.push(sl);\n            len += v.length;\n        }\n        return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n        reset();\n        reseed(seed); // Steps D-G\n        let res = undefined; // Step H: grind until k is in [1..n-1]\n        while (!(res = pred(gen())))\n            reseed();\n        reset();\n        return res;\n    };\n    return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n    bigint: (val) => typeof val === 'bigint',\n    function: (val) => typeof val === 'function',\n    boolean: (val) => typeof val === 'boolean',\n    string: (val) => typeof val === 'string',\n    stringOrUint8Array: (val) => typeof val === 'string' || isBytes(val),\n    isSafeInteger: (val) => Number.isSafeInteger(val),\n    array: (val) => Array.isArray(val),\n    field: (val, object) => object.Fp.isValid(val),\n    hash: (val) => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n    const checkField = (fieldName, type, isOptional) => {\n        const checkVal = validatorFns[type];\n        if (typeof checkVal !== 'function')\n            throw new Error(`Invalid validator \"${type}\", expected function`);\n        const val = object[fieldName];\n        if (isOptional && val === undefined)\n            return;\n        if (!checkVal(val, object)) {\n            throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);\n        }\n    };\n    for (const [fieldName, type] of Object.entries(validators))\n        checkField(fieldName, type, false);\n    for (const [fieldName, type] of Object.entries(optValidators))\n        checkField(fieldName, type, true);\n    return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGdDQUFnQyxJQUFJO0FBQ3BDO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLE9BQU8saUNBQWlDLElBQUksWUFBWSxFQUFFO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTyxXQUFXLGdCQUFnQixhQUFhLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsbUJBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qiw0QkFBNEI7QUFDbkQ7QUFDTztBQUNQO0FBQ0EsNENBQTRDO0FBQzVDLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiwwQkFBMEI7QUFDMUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLG1DQUFtQztBQUNuQyxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQ7QUFDbkQsOERBQThEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxLQUFLO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQixHQUFHLEtBQUssR0FBRyxXQUFXLGNBQWMsS0FBSztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVcsV0FBVyxZQUFZLElBQUk7QUFDcEQsa0NBQWtDLG9CQUFvQixJQUFJLGFBQWEsR0FBRztBQUMxRTtBQUNBLGtDQUFrQyxVQUFVLElBQUksU0FBUztBQUN6RCxrQ0FBa0Msb0JBQW9CLElBQUksU0FBUztBQUNuRSxrQ0FBa0MsMkJBQTJCO0FBQzdELGtDQUFrQyx3QkFBd0I7QUFDMUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL2Fic3RyYWN0L3V0aWxzLmpzPzJkNGYiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuLy8gMTAwIGxpbmVzIG9mIGNvZGUgaW4gdGhlIGZpbGUgYXJlIGR1cGxpY2F0ZWQgZnJvbSBub2JsZS1oYXNoZXMgKHV0aWxzKS5cbi8vIFRoaXMgaXMgT0s6IGBhYnN0cmFjdGAgZGlyZWN0b3J5IGRvZXMgbm90IHVzZSBub2JsZS1oYXNoZXMuXG4vLyBVc2VyIG1heSBvcHQtaW4gaW50byB1c2luZyBkaWZmZXJlbnQgaGFzaGluZyBsaWJyYXJ5LiBUaGlzIHdheSwgbm9ibGUtaGFzaGVzXG4vLyB3b24ndCBiZSBpbmNsdWRlZCBpbnRvIHRoZWlyIGJ1bmRsZS5cbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbmNvbnN0IF8ybiA9IEJpZ0ludCgyKTtcbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYWJ5dGVzKGl0ZW0pIHtcbiAgICBpZiAoIWlzQnl0ZXMoaXRlbSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVWludDhBcnJheSBleHBlY3RlZCcpO1xufVxuLy8gQXJyYXkgd2hlcmUgaW5kZXggMHhmMCAoMjQwKSBpcyBtYXBwZWQgdG8gc3RyaW5nICdmMCdcbmNvbnN0IGhleGVzID0gLyogQF9fUFVSRV9fICovIEFycmF5LmZyb20oeyBsZW5ndGg6IDI1NiB9LCAoXywgaSkgPT4gaS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgJzAnKSk7XG4vKipcbiAqIEBleGFtcGxlIGJ5dGVzVG9IZXgoVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSkpIC8vICdjYWZlMDEyMydcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9IZXgoYnl0ZXMpIHtcbiAgICBhYnl0ZXMoYnl0ZXMpO1xuICAgIC8vIHByZS1jYWNoaW5nIGltcHJvdmVzIHRoZSBzcGVlZCA2eFxuICAgIGxldCBoZXggPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGhleCArPSBoZXhlc1tieXRlc1tpXV07XG4gICAgfVxuICAgIHJldHVybiBoZXg7XG59XG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9IZXhVbnBhZGRlZChudW0pIHtcbiAgICBjb25zdCBoZXggPSBudW0udG9TdHJpbmcoMTYpO1xuICAgIHJldHVybiBoZXgubGVuZ3RoICYgMSA/IGAwJHtoZXh9YCA6IGhleDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb051bWJlcihoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICAvLyBCaWcgRW5kaWFuXG4gICAgcmV0dXJuIEJpZ0ludChoZXggPT09ICcnID8gJzAnIDogYDB4JHtoZXh9YCk7XG59XG4vLyBXZSB1c2Ugb3B0aW1pemVkIHRlY2huaXF1ZSB0byBjb252ZXJ0IGhleCBzdHJpbmcgdG8gYnl0ZSBhcnJheVxuY29uc3QgYXNjaWlzID0geyBfMDogNDgsIF85OiA1NywgX0E6IDY1LCBfRjogNzAsIF9hOiA5NywgX2Y6IDEwMiB9O1xuZnVuY3Rpb24gYXNjaWlUb0Jhc2UxNihjaGFyKSB7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl8wICYmIGNoYXIgPD0gYXNjaWlzLl85KVxuICAgICAgICByZXR1cm4gY2hhciAtIGFzY2lpcy5fMDtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX0EgJiYgY2hhciA8PSBhc2NpaXMuX0YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fQSAtIDEwKTtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuX2EgJiYgY2hhciA8PSBhc2NpaXMuX2YpXG4gICAgICAgIHJldHVybiBjaGFyIC0gKGFzY2lpcy5fYSAtIDEwKTtcbiAgICByZXR1cm47XG59XG4vKipcbiAqIEBleGFtcGxlIGhleFRvQnl0ZXMoJ2NhZmUwMTIzJykgLy8gVWludDhBcnJheS5mcm9tKFsweGNhLCAweGZlLCAweDAxLCAweDIzXSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhleFRvQnl0ZXMoaGV4KSB7XG4gICAgaWYgKHR5cGVvZiBoZXggIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCAnICsgdHlwZW9mIGhleCk7XG4gICAgY29uc3QgaGwgPSBoZXgubGVuZ3RoO1xuICAgIGNvbnN0IGFsID0gaGwgLyAyO1xuICAgIGlmIChobCAlIDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigncGFkZGVkIGhleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCB1bnBhZGRlZCBoZXggb2YgbGVuZ3RoICcgKyBobCk7XG4gICAgY29uc3QgYXJyYXkgPSBuZXcgVWludDhBcnJheShhbCk7XG4gICAgZm9yIChsZXQgYWkgPSAwLCBoaSA9IDA7IGFpIDwgYWw7IGFpKyssIGhpICs9IDIpIHtcbiAgICAgICAgY29uc3QgbjEgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpKSk7XG4gICAgICAgIGNvbnN0IG4yID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSArIDEpKTtcbiAgICAgICAgaWYgKG4xID09PSB1bmRlZmluZWQgfHwgbjIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgY2hhciA9IGhleFtoaV0gKyBoZXhbaGkgKyAxXTtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IG5vbi1oZXggY2hhcmFjdGVyIFwiJyArIGNoYXIgKyAnXCIgYXQgaW5kZXggJyArIGhpKTtcbiAgICAgICAgfVxuICAgICAgICBhcnJheVthaV0gPSBuMSAqIDE2ICsgbjI7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIEJFOiBCaWcgRW5kaWFuLCBMRTogTGl0dGxlIEVuZGlhblxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzVG9OdW1iZXJCRShieXRlcykge1xuICAgIHJldHVybiBoZXhUb051bWJlcihieXRlc1RvSGV4KGJ5dGVzKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb051bWJlckxFKGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICByZXR1cm4gaGV4VG9OdW1iZXIoYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oYnl0ZXMpLnJldmVyc2UoKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pIHtcbiAgICByZXR1cm4gaGV4VG9CeXRlcyhuLnRvU3RyaW5nKDE2KS5wYWRTdGFydChsZW4gKiAyLCAnMCcpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBudW1iZXJUb0J5dGVzTEUobiwgbGVuKSB7XG4gICAgcmV0dXJuIG51bWJlclRvQnl0ZXNCRShuLCBsZW4pLnJldmVyc2UoKTtcbn1cbi8vIFVucGFkZGVkLCByYXJlbHkgdXNlZFxuZXhwb3J0IGZ1bmN0aW9uIG51bWJlclRvVmFyQnl0ZXNCRShuKSB7XG4gICAgcmV0dXJuIGhleFRvQnl0ZXMobnVtYmVyVG9IZXhVbnBhZGRlZChuKSk7XG59XG4vKipcbiAqIFRha2VzIGhleCBzdHJpbmcgb3IgVWludDhBcnJheSwgY29udmVydHMgdG8gVWludDhBcnJheS5cbiAqIFZhbGlkYXRlcyBvdXRwdXQgbGVuZ3RoLlxuICogV2lsbCB0aHJvdyBlcnJvciBmb3Igb3RoZXIgdHlwZXMuXG4gKiBAcGFyYW0gdGl0bGUgZGVzY3JpcHRpdmUgdGl0bGUgZm9yIGFuIGVycm9yIGUuZy4gJ3ByaXZhdGUga2V5J1xuICogQHBhcmFtIGhleCBoZXggc3RyaW5nIG9yIFVpbnQ4QXJyYXlcbiAqIEBwYXJhbSBleHBlY3RlZExlbmd0aCBvcHRpb25hbCwgd2lsbCBjb21wYXJlIHRvIHJlc3VsdCBhcnJheSdzIGxlbmd0aFxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZUJ5dGVzKHRpdGxlLCBoZXgsIGV4cGVjdGVkTGVuZ3RoKSB7XG4gICAgbGV0IHJlcztcbiAgICBpZiAodHlwZW9mIGhleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlcyA9IGhleFRvQnl0ZXMoaGV4KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBtdXN0IGJlIHZhbGlkIGhleCBzdHJpbmcsIGdvdCBcIiR7aGV4fVwiLiBDYXVzZTogJHtlfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQnl0ZXMoaGV4KSkge1xuICAgICAgICAvLyBVaW50OEFycmF5LmZyb20oKSBpbnN0ZWFkIG9mIGhhc2guc2xpY2UoKSBiZWNhdXNlIG5vZGUuanMgQnVmZmVyXG4gICAgICAgIC8vIGlzIGluc3RhbmNlIG9mIFVpbnQ4QXJyYXksIGFuZCBpdHMgc2xpY2UoKSBjcmVhdGVzICoqbXV0YWJsZSoqIGNvcHlcbiAgICAgICAgcmVzID0gVWludDhBcnJheS5mcm9tKGhleCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCR7dGl0bGV9IG11c3QgYmUgaGV4IHN0cmluZyBvciBVaW50OEFycmF5YCk7XG4gICAgfVxuICAgIGNvbnN0IGxlbiA9IHJlcy5sZW5ndGg7XG4gICAgaWYgKHR5cGVvZiBleHBlY3RlZExlbmd0aCA9PT0gJ251bWJlcicgJiYgbGVuICE9PSBleHBlY3RlZExlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RpdGxlfSBleHBlY3RlZCAke2V4cGVjdGVkTGVuZ3RofSBieXRlcywgZ290ICR7bGVufWApO1xuICAgIHJldHVybiByZXM7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgYWJ5dGVzKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBDb21wYXJlcyAyIHU4YS1zIGluIGtpbmRhIGNvbnN0YW50IHRpbWVcbmV4cG9ydCBmdW5jdGlvbiBlcXVhbEJ5dGVzKGEsIGIpIHtcbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgbGV0IGRpZmYgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKylcbiAgICAgICAgZGlmZiB8PSBhW2ldIF4gYltpXTtcbiAgICByZXR1cm4gZGlmZiA9PT0gMDtcbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLy8gQml0IG9wZXJhdGlvbnNcbi8qKlxuICogQ2FsY3VsYXRlcyBhbW91bnQgb2YgYml0cyBpbiBhIGJpZ2ludC5cbiAqIFNhbWUgYXMgYG4udG9TdHJpbmcoMikubGVuZ3RoYFxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0TGVuKG4pIHtcbiAgICBsZXQgbGVuO1xuICAgIGZvciAobGVuID0gMDsgbiA+IF8wbjsgbiA+Pj0gXzFuLCBsZW4gKz0gMSlcbiAgICAgICAgO1xuICAgIHJldHVybiBsZW47XG59XG4vKipcbiAqIEdldHMgc2luZ2xlIGJpdCBhdCBwb3NpdGlvbi5cbiAqIE5PVEU6IGZpcnN0IGJpdCBwb3NpdGlvbiBpcyAwIChzYW1lIGFzIGFycmF5cylcbiAqIFNhbWUgYXMgYCEhK0FycmF5LmZyb20obi50b1N0cmluZygyKSkucmV2ZXJzZSgpW3Bvc11gXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBiaXRHZXQobiwgcG9zKSB7XG4gICAgcmV0dXJuIChuID4+IEJpZ0ludChwb3MpKSAmIF8xbjtcbn1cbi8qKlxuICogU2V0cyBzaW5nbGUgYml0IGF0IHBvc2l0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYml0U2V0KG4sIHBvcywgdmFsdWUpIHtcbiAgICByZXR1cm4gbiB8ICgodmFsdWUgPyBfMW4gOiBfMG4pIDw8IEJpZ0ludChwb3MpKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIG1hc2sgZm9yIE4gYml0cy4gTm90IHVzaW5nICoqIG9wZXJhdG9yIHdpdGggYmlnaW50cyBiZWNhdXNlIG9mIG9sZCBlbmdpbmVzLlxuICogU2FtZSBhcyBCaWdJbnQoYDBiJHtBcnJheShpKS5maWxsKCcxJykuam9pbignJyl9YClcbiAqL1xuZXhwb3J0IGNvbnN0IGJpdE1hc2sgPSAobikgPT4gKF8ybiA8PCBCaWdJbnQobiAtIDEpKSAtIF8xbjtcbi8vIERSQkdcbmNvbnN0IHU4biA9IChkYXRhKSA9PiBuZXcgVWludDhBcnJheShkYXRhKTsgLy8gY3JlYXRlcyBVaW50OEFycmF5XG5jb25zdCB1OGZyID0gKGFycikgPT4gVWludDhBcnJheS5mcm9tKGFycik7IC8vIGFub3RoZXIgc2hvcnRjdXRcbi8qKlxuICogTWluaW1hbCBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICogQHJldHVybnMgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgRFJCRyB1bnRpbCAybmQgYXJnIHJldHVybnMgc29tZXRoaW5nIG1lYW5pbmdmdWxcbiAqIEBleGFtcGxlXG4gKiAgIGNvbnN0IGRyYmcgPSBjcmVhdGVIbWFjRFJCRzxLZXk+KDMyLCAzMiwgaG1hYyk7XG4gKiAgIGRyYmcoc2VlZCwgYnl0ZXNUb0tleSk7IC8vIGJ5dGVzVG9LZXkgbXVzdCByZXR1cm4gS2V5IG9yIHVuZGVmaW5lZFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlSG1hY0RyYmcoaGFzaExlbiwgcUJ5dGVMZW4sIGhtYWNGbikge1xuICAgIGlmICh0eXBlb2YgaGFzaExlbiAhPT0gJ251bWJlcicgfHwgaGFzaExlbiA8IDIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGFzaExlbiBtdXN0IGJlIGEgbnVtYmVyJyk7XG4gICAgaWYgKHR5cGVvZiBxQnl0ZUxlbiAhPT0gJ251bWJlcicgfHwgcUJ5dGVMZW4gPCAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3FCeXRlTGVuIG11c3QgYmUgYSBudW1iZXInKTtcbiAgICBpZiAodHlwZW9mIGhtYWNGbiAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdobWFjRm4gbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgLy8gU3RlcCBCLCBTdGVwIEM6IHNldCBoYXNoTGVuIHRvIDgqY2VpbChobGVuLzgpXG4gICAgbGV0IHYgPSB1OG4oaGFzaExlbik7IC8vIE1pbmltYWwgbm9uLWZ1bGwtc3BlYyBITUFDLURSQkcgZnJvbSBOSVNUIDgwMC05MCBmb3IgUkZDNjk3OSBzaWdzLlxuICAgIGxldCBrID0gdThuKGhhc2hMZW4pOyAvLyBTdGVwcyBCIGFuZCBDIG9mIFJGQzY5NzkgMy4yOiBzZXQgaGFzaExlbiwgaW4gb3VyIGNhc2UgYWx3YXlzIHNhbWVcbiAgICBsZXQgaSA9IDA7IC8vIEl0ZXJhdGlvbnMgY291bnRlciwgd2lsbCB0aHJvdyB3aGVuIG92ZXIgMTAwMFxuICAgIGNvbnN0IHJlc2V0ID0gKCkgPT4ge1xuICAgICAgICB2LmZpbGwoMSk7XG4gICAgICAgIGsuZmlsbCgwKTtcbiAgICAgICAgaSA9IDA7XG4gICAgfTtcbiAgICBjb25zdCBoID0gKC4uLmIpID0+IGhtYWNGbihrLCB2LCAuLi5iKTsgLy8gaG1hYyhrKSh2LCAuLi52YWx1ZXMpXG4gICAgY29uc3QgcmVzZWVkID0gKHNlZWQgPSB1OG4oKSkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgcmVzZWVkKCkgZnVuY3Rpb24uIFN0ZXBzIEQtR1xuICAgICAgICBrID0gaCh1OGZyKFsweDAwXSksIHNlZWQpOyAvLyBrID0gaG1hYyhrIHx8IHYgfHwgMHgwMCB8fCBzZWVkKVxuICAgICAgICB2ID0gaCgpOyAvLyB2ID0gaG1hYyhrIHx8IHYpXG4gICAgICAgIGlmIChzZWVkLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgayA9IGgodThmcihbMHgwMV0pLCBzZWVkKTsgLy8gayA9IGhtYWMoayB8fCB2IHx8IDB4MDEgfHwgc2VlZClcbiAgICAgICAgdiA9IGgoKTsgLy8gdiA9IGhtYWMoayB8fCB2KVxuICAgIH07XG4gICAgY29uc3QgZ2VuID0gKCkgPT4ge1xuICAgICAgICAvLyBITUFDLURSQkcgZ2VuZXJhdGUoKSBmdW5jdGlvblxuICAgICAgICBpZiAoaSsrID49IDEwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2RyYmc6IHRyaWVkIDEwMDAgdmFsdWVzJyk7XG4gICAgICAgIGxldCBsZW4gPSAwO1xuICAgICAgICBjb25zdCBvdXQgPSBbXTtcbiAgICAgICAgd2hpbGUgKGxlbiA8IHFCeXRlTGVuKSB7XG4gICAgICAgICAgICB2ID0gaCgpO1xuICAgICAgICAgICAgY29uc3Qgc2wgPSB2LnNsaWNlKCk7XG4gICAgICAgICAgICBvdXQucHVzaChzbCk7XG4gICAgICAgICAgICBsZW4gKz0gdi5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbmNhdEJ5dGVzKC4uLm91dCk7XG4gICAgfTtcbiAgICBjb25zdCBnZW5VbnRpbCA9IChzZWVkLCBwcmVkKSA9PiB7XG4gICAgICAgIHJlc2V0KCk7XG4gICAgICAgIHJlc2VlZChzZWVkKTsgLy8gU3RlcHMgRC1HXG4gICAgICAgIGxldCByZXMgPSB1bmRlZmluZWQ7IC8vIFN0ZXAgSDogZ3JpbmQgdW50aWwgayBpcyBpbiBbMS4ubi0xXVxuICAgICAgICB3aGlsZSAoIShyZXMgPSBwcmVkKGdlbigpKSkpXG4gICAgICAgICAgICByZXNlZWQoKTtcbiAgICAgICAgcmVzZXQoKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9O1xuICAgIHJldHVybiBnZW5VbnRpbDtcbn1cbi8vIFZhbGlkYXRpbmcgY3VydmVzIGFuZCBmaWVsZHNcbmNvbnN0IHZhbGlkYXRvckZucyA9IHtcbiAgICBiaWdpbnQ6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdiaWdpbnQnLFxuICAgIGZ1bmN0aW9uOiAodmFsKSA9PiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuICAgIGJvb2xlYW46ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdib29sZWFuJyxcbiAgICBzdHJpbmc6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnLFxuICAgIHN0cmluZ09yVWludDhBcnJheTogKHZhbCkgPT4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgaXNCeXRlcyh2YWwpLFxuICAgIGlzU2FmZUludGVnZXI6ICh2YWwpID0+IE51bWJlci5pc1NhZmVJbnRlZ2VyKHZhbCksXG4gICAgYXJyYXk6ICh2YWwpID0+IEFycmF5LmlzQXJyYXkodmFsKSxcbiAgICBmaWVsZDogKHZhbCwgb2JqZWN0KSA9PiBvYmplY3QuRnAuaXNWYWxpZCh2YWwpLFxuICAgIGhhc2g6ICh2YWwpID0+IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgJiYgTnVtYmVyLmlzU2FmZUludGVnZXIodmFsLm91dHB1dExlbiksXG59O1xuLy8gdHlwZSBSZWNvcmQ8SyBleHRlbmRzIHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCwgVD4gPSB7IFtQIGluIEtdOiBUOyB9XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVPYmplY3Qob2JqZWN0LCB2YWxpZGF0b3JzLCBvcHRWYWxpZGF0b3JzID0ge30pIHtcbiAgICBjb25zdCBjaGVja0ZpZWxkID0gKGZpZWxkTmFtZSwgdHlwZSwgaXNPcHRpb25hbCkgPT4ge1xuICAgICAgICBjb25zdCBjaGVja1ZhbCA9IHZhbGlkYXRvckZuc1t0eXBlXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGVja1ZhbCAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWxpZGF0b3IgXCIke3R5cGV9XCIsIGV4cGVjdGVkIGZ1bmN0aW9uYCk7XG4gICAgICAgIGNvbnN0IHZhbCA9IG9iamVjdFtmaWVsZE5hbWVdO1xuICAgICAgICBpZiAoaXNPcHRpb25hbCAmJiB2YWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFjaGVja1ZhbCh2YWwsIG9iamVjdCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSAke1N0cmluZyhmaWVsZE5hbWUpfT0ke3ZhbH0gKCR7dHlwZW9mIHZhbH0pLCBleHBlY3RlZCAke3R5cGV9YCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZvciAoY29uc3QgW2ZpZWxkTmFtZSwgdHlwZV0gb2YgT2JqZWN0LmVudHJpZXModmFsaWRhdG9ycykpXG4gICAgICAgIGNoZWNrRmllbGQoZmllbGROYW1lLCB0eXBlLCBmYWxzZSk7XG4gICAgZm9yIChjb25zdCBbZmllbGROYW1lLCB0eXBlXSBvZiBPYmplY3QuZW50cmllcyhvcHRWYWxpZGF0b3JzKSlcbiAgICAgICAgY2hlY2tGaWVsZChmaWVsZE5hbWUsIHR5cGUsIHRydWUpO1xuICAgIHJldHVybiBvYmplY3Q7XG59XG4vLyB2YWxpZGF0ZSB0eXBlIHRlc3RzXG4vLyBjb25zdCBvOiB7IGE6IG51bWJlcjsgYjogbnVtYmVyOyBjOiBudW1iZXIgfSA9IHsgYTogMSwgYjogNSwgYzogNiB9O1xuLy8gY29uc3QgejAgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdpc1NhZmVJbnRlZ2VyJyB9LCB7IGM6ICdiaWdpbnQnIH0pOyAvLyBPayFcbi8vIC8vIFNob3VsZCBmYWlsIHR5cGUtY2hlY2tcbi8vIGNvbnN0IHoxID0gdmFsaWRhdGVPYmplY3QobywgeyBhOiAndG1wJyB9LCB7IGM6ICd6eicgfSk7XG4vLyBjb25zdCB6MiA9IHZhbGlkYXRlT2JqZWN0KG8sIHsgYTogJ2lzU2FmZUludGVnZXInIH0sIHsgYzogJ3p6JyB9KTtcbi8vIGNvbnN0IHozID0gdmFsaWRhdGVPYmplY3QobywgeyB0ZXN0OiAnYm9vbGVhbicsIHo6ICdidWcnIH0pO1xuLy8gY29uc3QgejQgPSB2YWxpZGF0ZU9iamVjdChvLCB7IGE6ICdib29sZWFuJywgejogJ2J1ZycgfSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlscy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js":
/*!****************************************************************!*\
  !*** ./node_modules/@noble/curves/esm/abstract/weierstrass.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DER: function() { return /* binding */ DER; },\n/* harmony export */   SWUFpSqrtRatio: function() { return /* binding */ SWUFpSqrtRatio; },\n/* harmony export */   mapToCurveSimpleSWU: function() { return /* binding */ mapToCurveSimpleSWU; },\n/* harmony export */   weierstrass: function() { return /* binding */ weierstrass; },\n/* harmony export */   weierstrassPoints: function() { return /* binding */ weierstrassPoints; }\n/* harmony export */ });\n/* harmony import */ var _modular_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _curve_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// Short Weierstrass curve. The formula is: y² = x³ + ax + b\n\n\n\n\nfunction validatePointOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        a: 'field',\n        b: 'field',\n    }, {\n        allowedPrivateKeyLengths: 'array',\n        wrapPrivateKey: 'boolean',\n        isTorsionFree: 'function',\n        clearCofactor: 'function',\n        allowInfinityPoint: 'boolean',\n        fromBytes: 'function',\n        toBytes: 'function',\n    });\n    const { endo, Fp, a } = opts;\n    if (endo) {\n        if (!Fp.eql(a, Fp.ZERO)) {\n            throw new Error('Endomorphism can only be defined for Koblitz curves that have a=0');\n        }\n        if (typeof endo !== 'object' ||\n            typeof endo.beta !== 'bigint' ||\n            typeof endo.splitScalar !== 'function') {\n            throw new Error('Expected endomorphism with beta: bigint and splitScalar: function');\n        }\n    }\n    return Object.freeze({ ...opts });\n}\n// ASN.1 DER encoding utilities\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = _utils_js__WEBPACK_IMPORTED_MODULE_1__;\nconst DER = {\n    // asn.1 DER encoding utils\n    Err: class DERErr extends Error {\n        constructor(m = '') {\n            super(m);\n        }\n    },\n    _parseInt(data) {\n        const { Err: E } = DER;\n        if (data.length < 2 || data[0] !== 0x02)\n            throw new E('Invalid signature integer tag');\n        const len = data[1];\n        const res = data.subarray(2, len + 2);\n        if (!len || res.length !== len)\n            throw new E('Invalid signature integer: wrong length');\n        // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n        // since we always use positive integers here. It must always be empty:\n        // - add zero byte if exists\n        // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n        if (res[0] & 0b10000000)\n            throw new E('Invalid signature integer: negative');\n        if (res[0] === 0x00 && !(res[1] & 0b10000000))\n            throw new E('Invalid signature integer: unnecessary leading zero');\n        return { d: b2n(res), l: data.subarray(len + 2) }; // d is data, l is left\n    },\n    toSig(hex) {\n        // parse DER signature\n        const { Err: E } = DER;\n        const data = typeof hex === 'string' ? h2b(hex) : hex;\n        _utils_js__WEBPACK_IMPORTED_MODULE_1__.abytes(data);\n        let l = data.length;\n        if (l < 2 || data[0] != 0x30)\n            throw new E('Invalid signature tag');\n        if (data[1] !== l - 2)\n            throw new E('Invalid signature: incorrect length');\n        const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));\n        const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);\n        if (rBytesLeft.length)\n            throw new E('Invalid signature: left bytes after parsing');\n        return { r, s };\n    },\n    hexFromSig(sig) {\n        // Add leading zero if first byte has negative bit enabled. More details in '_parseInt'\n        const slice = (s) => (Number.parseInt(s[0], 16) & 0b1000 ? '00' + s : s);\n        const h = (num) => {\n            const hex = num.toString(16);\n            return hex.length & 1 ? `0${hex}` : hex;\n        };\n        const s = slice(h(sig.s));\n        const r = slice(h(sig.r));\n        const shl = s.length / 2;\n        const rhl = r.length / 2;\n        const sl = h(shl);\n        const rl = h(rhl);\n        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;\n    },\n};\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\nfunction weierstrassPoints(opts) {\n    const CURVE = validatePointOpts(opts);\n    const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n    const toBytes = CURVE.toBytes ||\n        ((_c, point, _isCompressed) => {\n            const a = point.toAffine();\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n        });\n    const fromBytes = CURVE.fromBytes ||\n        ((bytes) => {\n            // const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n            return { x, y };\n        });\n    /**\n     * y² = x³ + ax + b: Short weierstrass curve formula\n     * @returns y²\n     */\n    function weierstrassEquation(x) {\n        const { a, b } = CURVE;\n        const x2 = Fp.sqr(x); // x * x\n        const x3 = Fp.mul(x2, x); // x2 * x\n        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n    }\n    // Validate whether the passed curve params are valid.\n    // We check if curve equation works for generator point.\n    // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n    // ProjectivePoint class has not been initialized yet.\n    if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n        throw new Error('bad generator point: equation left != right');\n    // Valid group elements reside in range 1..n-1\n    function isWithinCurveOrder(num) {\n        return typeof num === 'bigint' && _0n < num && num < CURVE.n;\n    }\n    function assertGE(num) {\n        if (!isWithinCurveOrder(num))\n            throw new Error('Expected valid bigint: 0 < bigint < curve.n');\n    }\n    // Validates if priv key is valid and converts it to bigint.\n    // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n    function normPrivateKeyToScalar(key) {\n        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;\n        if (lengths && typeof key !== 'bigint') {\n            if (_utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(key))\n                key = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(key);\n            // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n            if (typeof key !== 'string' || !lengths.includes(key.length))\n                throw new Error('Invalid key');\n            key = key.padStart(nByteLength * 2, '0');\n        }\n        let num;\n        try {\n            num =\n                typeof key === 'bigint'\n                    ? key\n                    : _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('private key', key, nByteLength));\n        }\n        catch (error) {\n            throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);\n        }\n        if (wrapPrivateKey)\n            num = _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(num, n); // disabled by default, enabled for BLS\n        assertGE(num); // num in range [1..N-1]\n        return num;\n    }\n    const pointPrecomputes = new Map();\n    function assertPrjPoint(other) {\n        if (!(other instanceof Point))\n            throw new Error('ProjectivePoint expected');\n    }\n    /**\n     * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z) ∋ (x=x/z, y=y/z)\n     * Default Point works in 2d / affine coordinates: (x, y)\n     * We're doing calculations in projective, because its operations don't require costly inversion.\n     */\n    class Point {\n        constructor(px, py, pz) {\n            this.px = px;\n            this.py = py;\n            this.pz = pz;\n            if (px == null || !Fp.isValid(px))\n                throw new Error('x required');\n            if (py == null || !Fp.isValid(py))\n                throw new Error('y required');\n            if (pz == null || !Fp.isValid(pz))\n                throw new Error('z required');\n        }\n        // Does not validate if the point is on-curve.\n        // Use fromHex instead, or call assertValidity() later.\n        static fromAffine(p) {\n            const { x, y } = p || {};\n            if (!p || !Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('invalid affine point');\n            if (p instanceof Point)\n                throw new Error('projective point not allowed');\n            const is0 = (i) => Fp.eql(i, Fp.ZERO);\n            // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n            if (is0(x) && is0(y))\n                return Point.ZERO;\n            return new Point(x, y, Fp.ONE);\n        }\n        get x() {\n            return this.toAffine().x;\n        }\n        get y() {\n            return this.toAffine().y;\n        }\n        /**\n         * Takes a bunch of Projective Points but executes only one\n         * inversion on all of them. Inversion is very slow operation,\n         * so this improves performance massively.\n         * Optimization: converts a list of projective points to a list of identical points with Z=1.\n         */\n        static normalizeZ(points) {\n            const toInv = Fp.invertBatch(points.map((p) => p.pz));\n            return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n        }\n        /**\n         * Converts hash string or Uint8Array to Point.\n         * @param hex short/long ECDSA hex\n         */\n        static fromHex(hex) {\n            const P = Point.fromAffine(fromBytes((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('pointHex', hex)));\n            P.assertValidity();\n            return P;\n        }\n        // Multiplies generator point by privateKey.\n        static fromPrivateKey(privateKey) {\n            return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n        }\n        // \"Private method\", don't use it directly\n        _setWindowSize(windowSize) {\n            this._WINDOW_SIZE = windowSize;\n            pointPrecomputes.delete(this);\n        }\n        // A point on curve is valid if it conforms to equation.\n        assertValidity() {\n            if (this.is0()) {\n                // (0, 1, 0) aka ZERO is invalid in most contexts.\n                // In BLS, ZERO can be serialized, so we allow it.\n                // (0, 0, 0) is wrong representation of ZERO and is always invalid.\n                if (CURVE.allowInfinityPoint && !Fp.is0(this.py))\n                    return;\n                throw new Error('bad point: ZERO');\n            }\n            // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n            const { x, y } = this.toAffine();\n            // Check if x, y are valid field elements\n            if (!Fp.isValid(x) || !Fp.isValid(y))\n                throw new Error('bad point: x or y not FE');\n            const left = Fp.sqr(y); // y²\n            const right = weierstrassEquation(x); // x³ + ax + b\n            if (!Fp.eql(left, right))\n                throw new Error('bad point: equation left != right');\n            if (!this.isTorsionFree())\n                throw new Error('bad point: not in prime-order subgroup');\n        }\n        hasEvenY() {\n            const { y } = this.toAffine();\n            if (Fp.isOdd)\n                return !Fp.isOdd(y);\n            throw new Error(\"Field doesn't support isOdd\");\n        }\n        /**\n         * Compare one point to another.\n         */\n        equals(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n            const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n            return U1 && U2;\n        }\n        /**\n         * Flips point to one corresponding to (x, -y) in Affine coordinates.\n         */\n        negate() {\n            return new Point(this.px, Fp.neg(this.py), this.pz);\n        }\n        // Renes-Costello-Batina exception-free doubling formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 3\n        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n        double() {\n            const { a, b } = CURVE;\n            const b3 = Fp.mul(b, _3n);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            let t0 = Fp.mul(X1, X1); // step 1\n            let t1 = Fp.mul(Y1, Y1);\n            let t2 = Fp.mul(Z1, Z1);\n            let t3 = Fp.mul(X1, Y1);\n            t3 = Fp.add(t3, t3); // step 5\n            Z3 = Fp.mul(X1, Z1);\n            Z3 = Fp.add(Z3, Z3);\n            X3 = Fp.mul(a, Z3);\n            Y3 = Fp.mul(b3, t2);\n            Y3 = Fp.add(X3, Y3); // step 10\n            X3 = Fp.sub(t1, Y3);\n            Y3 = Fp.add(t1, Y3);\n            Y3 = Fp.mul(X3, Y3);\n            X3 = Fp.mul(t3, X3);\n            Z3 = Fp.mul(b3, Z3); // step 15\n            t2 = Fp.mul(a, t2);\n            t3 = Fp.sub(t0, t2);\n            t3 = Fp.mul(a, t3);\n            t3 = Fp.add(t3, Z3);\n            Z3 = Fp.add(t0, t0); // step 20\n            t0 = Fp.add(Z3, t0);\n            t0 = Fp.add(t0, t2);\n            t0 = Fp.mul(t0, t3);\n            Y3 = Fp.add(Y3, t0);\n            t2 = Fp.mul(Y1, Z1); // step 25\n            t2 = Fp.add(t2, t2);\n            t0 = Fp.mul(t2, t3);\n            X3 = Fp.sub(X3, t0);\n            Z3 = Fp.mul(t2, t1);\n            Z3 = Fp.add(Z3, Z3); // step 30\n            Z3 = Fp.add(Z3, Z3);\n            return new Point(X3, Y3, Z3);\n        }\n        // Renes-Costello-Batina exception-free addition formula.\n        // There is 30% faster Jacobian formula, but it is not complete.\n        // https://eprint.iacr.org/2015/1060, algorithm 1\n        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n        add(other) {\n            assertPrjPoint(other);\n            const { px: X1, py: Y1, pz: Z1 } = this;\n            const { px: X2, py: Y2, pz: Z2 } = other;\n            let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n            const a = CURVE.a;\n            const b3 = Fp.mul(CURVE.b, _3n);\n            let t0 = Fp.mul(X1, X2); // step 1\n            let t1 = Fp.mul(Y1, Y2);\n            let t2 = Fp.mul(Z1, Z2);\n            let t3 = Fp.add(X1, Y1);\n            let t4 = Fp.add(X2, Y2); // step 5\n            t3 = Fp.mul(t3, t4);\n            t4 = Fp.add(t0, t1);\n            t3 = Fp.sub(t3, t4);\n            t4 = Fp.add(X1, Z1);\n            let t5 = Fp.add(X2, Z2); // step 10\n            t4 = Fp.mul(t4, t5);\n            t5 = Fp.add(t0, t2);\n            t4 = Fp.sub(t4, t5);\n            t5 = Fp.add(Y1, Z1);\n            X3 = Fp.add(Y2, Z2); // step 15\n            t5 = Fp.mul(t5, X3);\n            X3 = Fp.add(t1, t2);\n            t5 = Fp.sub(t5, X3);\n            Z3 = Fp.mul(a, t4);\n            X3 = Fp.mul(b3, t2); // step 20\n            Z3 = Fp.add(X3, Z3);\n            X3 = Fp.sub(t1, Z3);\n            Z3 = Fp.add(t1, Z3);\n            Y3 = Fp.mul(X3, Z3);\n            t1 = Fp.add(t0, t0); // step 25\n            t1 = Fp.add(t1, t0);\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.mul(b3, t4);\n            t1 = Fp.add(t1, t2);\n            t2 = Fp.sub(t0, t2); // step 30\n            t2 = Fp.mul(a, t2);\n            t4 = Fp.add(t4, t2);\n            t0 = Fp.mul(t1, t4);\n            Y3 = Fp.add(Y3, t0);\n            t0 = Fp.mul(t5, t4); // step 35\n            X3 = Fp.mul(t3, X3);\n            X3 = Fp.sub(X3, t0);\n            t0 = Fp.mul(t3, t1);\n            Z3 = Fp.mul(t5, Z3);\n            Z3 = Fp.add(Z3, t0); // step 40\n            return new Point(X3, Y3, Z3);\n        }\n        subtract(other) {\n            return this.add(other.negate());\n        }\n        is0() {\n            return this.equals(Point.ZERO);\n        }\n        wNAF(n) {\n            return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {\n                const toInv = Fp.invertBatch(comp.map((p) => p.pz));\n                return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n            });\n        }\n        /**\n         * Non-constant-time multiplication. Uses double-and-add algorithm.\n         * It's faster, but should only be used when you don't care about\n         * an exposed private key e.g. sig verification, which works over *public* keys.\n         */\n        multiplyUnsafe(n) {\n            const I = Point.ZERO;\n            if (n === _0n)\n                return I;\n            assertGE(n); // Will throw on 0\n            if (n === _1n)\n                return this;\n            const { endo } = CURVE;\n            if (!endo)\n                return wnaf.unsafeLadder(this, n);\n            // Apply endomorphism\n            let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n            let k1p = I;\n            let k2p = I;\n            let d = this;\n            while (k1 > _0n || k2 > _0n) {\n                if (k1 & _1n)\n                    k1p = k1p.add(d);\n                if (k2 & _1n)\n                    k2p = k2p.add(d);\n                d = d.double();\n                k1 >>= _1n;\n                k2 >>= _1n;\n            }\n            if (k1neg)\n                k1p = k1p.negate();\n            if (k2neg)\n                k2p = k2p.negate();\n            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n            return k1p.add(k2p);\n        }\n        /**\n         * Constant time multiplication.\n         * Uses wNAF method. Windowed method may be 10% faster,\n         * but takes 2x longer to generate and consumes 2x memory.\n         * Uses precomputes when available.\n         * Uses endomorphism for Koblitz curves.\n         * @param scalar by which the point would be multiplied\n         * @returns New point\n         */\n        multiply(scalar) {\n            assertGE(scalar);\n            let n = scalar;\n            let point, fake; // Fake point is used to const-time mult\n            const { endo } = CURVE;\n            if (endo) {\n                const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);\n                let { p: k1p, f: f1p } = this.wNAF(k1);\n                let { p: k2p, f: f2p } = this.wNAF(k2);\n                k1p = wnaf.constTimeNegate(k1neg, k1p);\n                k2p = wnaf.constTimeNegate(k2neg, k2p);\n                k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n                point = k1p.add(k2p);\n                fake = f1p.add(f2p);\n            }\n            else {\n                const { p, f } = this.wNAF(n);\n                point = p;\n                fake = f;\n            }\n            // Normalize `z` for both points, but return only real one\n            return Point.normalizeZ([point, fake])[0];\n        }\n        /**\n         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n         * Not using Strauss-Shamir trick: precomputation tables are faster.\n         * The trick could be useful if both P and Q are not G (not in our case).\n         * @returns non-zero affine point\n         */\n        multiplyAndAddUnsafe(Q, a, b) {\n            const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n            const mul = (P, a // Select faster multiply() method\n            ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n            const sum = mul(this, a).add(mul(Q, b));\n            return sum.is0() ? undefined : sum;\n        }\n        // Converts Projective point to affine (x, y) coordinates.\n        // Can accept precomputed Z^-1 - for example, from invertBatch.\n        // (x, y, z) ∋ (x=x/z, y=y/z)\n        toAffine(iz) {\n            const { px: x, py: y, pz: z } = this;\n            const is0 = this.is0();\n            // If invZ was 0, we return zero point. However we still want to execute\n            // all operations, so we replace invZ with a random number, 1.\n            if (iz == null)\n                iz = is0 ? Fp.ONE : Fp.inv(z);\n            const ax = Fp.mul(x, iz);\n            const ay = Fp.mul(y, iz);\n            const zz = Fp.mul(z, iz);\n            if (is0)\n                return { x: Fp.ZERO, y: Fp.ZERO };\n            if (!Fp.eql(zz, Fp.ONE))\n                throw new Error('invZ was invalid');\n            return { x: ax, y: ay };\n        }\n        isTorsionFree() {\n            const { h: cofactor, isTorsionFree } = CURVE;\n            if (cofactor === _1n)\n                return true; // No subgroups, always torsion-free\n            if (isTorsionFree)\n                return isTorsionFree(Point, this);\n            throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n        }\n        clearCofactor() {\n            const { h: cofactor, clearCofactor } = CURVE;\n            if (cofactor === _1n)\n                return this; // Fast-path\n            if (clearCofactor)\n                return clearCofactor(Point, this);\n            return this.multiplyUnsafe(CURVE.h);\n        }\n        toRawBytes(isCompressed = true) {\n            this.assertValidity();\n            return toBytes(Point, this, isCompressed);\n        }\n        toHex(isCompressed = true) {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(this.toRawBytes(isCompressed));\n        }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n    const _bits = CURVE.nBitLength;\n    const wnaf = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n    // Validate if generator point is on curve\n    return {\n        CURVE,\n        ProjectivePoint: Point,\n        normPrivateKeyToScalar,\n        weierstrassEquation,\n        isWithinCurveOrder,\n    };\n}\nfunction validateOpts(curve) {\n    const opts = (0,_curve_js__WEBPACK_IMPORTED_MODULE_0__.validateBasic)(curve);\n    _utils_js__WEBPACK_IMPORTED_MODULE_1__.validateObject(opts, {\n        hash: 'hash',\n        hmac: 'function',\n        randomBytes: 'function',\n    }, {\n        bits2int: 'function',\n        bits2int_modN: 'function',\n        lowS: 'boolean',\n    });\n    return Object.freeze({ lowS: true, ...opts });\n}\nfunction weierstrass(curveDef) {\n    const CURVE = validateOpts(curveDef);\n    const { Fp, n: CURVE_ORDER } = CURVE;\n    const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n    const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n    function isValidFieldElement(num) {\n        return _0n < num && num < Fp.ORDER; // 0 is banned since it's not invertible FE\n    }\n    function modN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mod(a, CURVE_ORDER);\n    }\n    function invN(a) {\n        return _modular_js__WEBPACK_IMPORTED_MODULE_2__.invert(a, CURVE_ORDER);\n    }\n    const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder, } = weierstrassPoints({\n        ...CURVE,\n        toBytes(_c, point, isCompressed) {\n            const a = point.toAffine();\n            const x = Fp.toBytes(a.x);\n            const cat = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes;\n            if (isCompressed) {\n                return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n            }\n            else {\n                return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n            }\n        },\n        fromBytes(bytes) {\n            const len = bytes.length;\n            const head = bytes[0];\n            const tail = bytes.subarray(1);\n            // this.assertValidity() is done inside of fromHex\n            if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n                const x = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(tail);\n                if (!isValidFieldElement(x))\n                    throw new Error('Point is not on curve');\n                const y2 = weierstrassEquation(x); // y² = x³ + ax + b\n                let y;\n                try {\n                    y = Fp.sqrt(y2); // y = y² ^ (p+1)/4\n                }\n                catch (sqrtError) {\n                    const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n                    throw new Error('Point is not on curve' + suffix);\n                }\n                const isYOdd = (y & _1n) === _1n;\n                // ECDSA\n                const isHeadOdd = (head & 1) === 1;\n                if (isHeadOdd !== isYOdd)\n                    y = Fp.neg(y);\n                return { x, y };\n            }\n            else if (len === uncompressedLen && head === 0x04) {\n                const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n                const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n                return { x, y };\n            }\n            else {\n                throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);\n            }\n        },\n    });\n    const numToNByteStr = (num) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToHex(_utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength));\n    function isBiggerThanHalfOrder(number) {\n        const HALF = CURVE_ORDER >> _1n;\n        return number > HALF;\n    }\n    function normalizeS(s) {\n        return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n    }\n    // slice bytes num\n    const slcNum = (b, from, to) => _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(b.slice(from, to));\n    /**\n     * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n     */\n    class Signature {\n        constructor(r, s, recovery) {\n            this.r = r;\n            this.s = s;\n            this.recovery = recovery;\n            this.assertValidity();\n        }\n        // pair (bytes of r, bytes of s)\n        static fromCompact(hex) {\n            const l = CURVE.nByteLength;\n            hex = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('compactSignature', hex, l * 2);\n            return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n        }\n        // DER encoded ECDSA signature\n        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n        static fromDER(hex) {\n            const { r, s } = DER.toSig((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('DER', hex));\n            return new Signature(r, s);\n        }\n        assertValidity() {\n            // can use assertGE here\n            if (!isWithinCurveOrder(this.r))\n                throw new Error('r must be 0 < r < CURVE.n');\n            if (!isWithinCurveOrder(this.s))\n                throw new Error('s must be 0 < s < CURVE.n');\n        }\n        addRecoveryBit(recovery) {\n            return new Signature(this.r, this.s, recovery);\n        }\n        recoverPublicKey(msgHash) {\n            const { r, s, recovery: rec } = this;\n            const h = bits2int_modN((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash)); // Truncate hash\n            if (rec == null || ![0, 1, 2, 3].includes(rec))\n                throw new Error('recovery id invalid');\n            const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n            if (radj >= Fp.ORDER)\n                throw new Error('recovery id 2 or 3 invalid');\n            const prefix = (rec & 1) === 0 ? '02' : '03';\n            const R = Point.fromHex(prefix + numToNByteStr(radj));\n            const ir = invN(radj); // r^-1\n            const u1 = modN(-h * ir); // -hr^-1\n            const u2 = modN(s * ir); // sr^-1\n            const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n            if (!Q)\n                throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n            Q.assertValidity();\n            return Q;\n        }\n        // Signatures should be low-s, to prevent malleability.\n        hasHighS() {\n            return isBiggerThanHalfOrder(this.s);\n        }\n        normalizeS() {\n            return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n        }\n        // DER-encoded\n        toDERRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toDERHex());\n        }\n        toDERHex() {\n            return DER.hexFromSig({ r: this.r, s: this.s });\n        }\n        // padded bytes of r, then padded bytes of s\n        toCompactRawBytes() {\n            return _utils_js__WEBPACK_IMPORTED_MODULE_1__.hexToBytes(this.toCompactHex());\n        }\n        toCompactHex() {\n            return numToNByteStr(this.r) + numToNByteStr(this.s);\n        }\n    }\n    const utils = {\n        isValidPrivateKey(privateKey) {\n            try {\n                normPrivateKeyToScalar(privateKey);\n                return true;\n            }\n            catch (error) {\n                return false;\n            }\n        },\n        normPrivateKeyToScalar: normPrivateKeyToScalar,\n        /**\n         * Produces cryptographically secure private key from random of size\n         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n         */\n        randomPrivateKey: () => {\n            const length = _modular_js__WEBPACK_IMPORTED_MODULE_2__.getMinHashLength(CURVE.n);\n            return _modular_js__WEBPACK_IMPORTED_MODULE_2__.mapHashToField(CURVE.randomBytes(length), CURVE.n);\n        },\n        /**\n         * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n         * Allows to massively speed-up `point.multiply(scalar)`.\n         * @returns cached point\n         * @example\n         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n         * fast.multiply(privKey); // much faster ECDH now\n         */\n        precompute(windowSize = 8, point = Point.BASE) {\n            point._setWindowSize(windowSize);\n            point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n            return point;\n        },\n    };\n    /**\n     * Computes public key for a private key. Checks for validity of the private key.\n     * @param privateKey private key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns Public key, full when isCompressed=false; short when isCompressed=true\n     */\n    function getPublicKey(privateKey, isCompressed = true) {\n        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n    }\n    /**\n     * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n     */\n    function isProbPub(item) {\n        const arr = _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(item);\n        const str = typeof item === 'string';\n        const len = (arr || str) && item.length;\n        if (arr)\n            return len === compressedLen || len === uncompressedLen;\n        if (str)\n            return len === 2 * compressedLen || len === 2 * uncompressedLen;\n        if (item instanceof Point)\n            return true;\n        return false;\n    }\n    /**\n     * ECDH (Elliptic Curve Diffie Hellman).\n     * Computes shared public key from private key and public key.\n     * Checks: 1) private key validity 2) shared key is on-curve.\n     * Does NOT hash the result.\n     * @param privateA private key\n     * @param publicB different public key\n     * @param isCompressed whether to return compact (default), or full key\n     * @returns shared public key\n     */\n    function getSharedSecret(privateA, publicB, isCompressed = true) {\n        if (isProbPub(privateA))\n            throw new Error('first arg must be private key');\n        if (!isProbPub(publicB))\n            throw new Error('second arg must be public key');\n        const b = Point.fromHex(publicB); // check for being on-curve\n        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n    }\n    // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n    // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n    // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n    // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n    const bits2int = CURVE.bits2int ||\n        function (bytes) {\n            // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n            // for some cases, since bytes.length * 8 is not actual bitLength.\n            const num = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bytesToNumberBE(bytes); // check for == u8 done here\n            const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n            return delta > 0 ? num >> BigInt(delta) : num;\n        };\n    const bits2int_modN = CURVE.bits2int_modN ||\n        function (bytes) {\n            return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n        };\n    // NOTE: pads output with zero as per spec\n    const ORDER_MASK = _utils_js__WEBPACK_IMPORTED_MODULE_1__.bitMask(CURVE.nBitLength);\n    /**\n     * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n     */\n    function int2octets(num) {\n        if (typeof num !== 'bigint')\n            throw new Error('bigint expected');\n        if (!(_0n <= num && num < ORDER_MASK))\n            throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);\n        // works with order, can have different size than numToField!\n        return _utils_js__WEBPACK_IMPORTED_MODULE_1__.numberToBytesBE(num, CURVE.nByteLength);\n    }\n    // Steps A, D of RFC6979 3.2\n    // Creates RFC6979 seed; converts msg/privKey to numbers.\n    // Used only in sign, not in verify.\n    // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order, this will be wrong at least for P521.\n    // Also it can be bigger for P224 + SHA256\n    function prepSig(msgHash, privateKey, opts = defaultSigOpts) {\n        if (['recovered', 'canonical'].some((k) => k in opts))\n            throw new Error('sign() legacy options not supported');\n        const { hash, randomBytes } = CURVE;\n        let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n        if (lowS == null)\n            lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        if (prehash)\n            msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('prehashed msgHash', hash(msgHash));\n        // We can't later call bits2octets, since nested bits2int is broken for curves\n        // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n        // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n        const h1int = bits2int_modN(msgHash);\n        const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n        const seedArgs = [int2octets(d), int2octets(h1int)];\n        // extraEntropy. RFC6979 3.6: additional k' (optional).\n        if (ent != null && ent !== false) {\n            // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n            const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n            seedArgs.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('extraEntropy', e)); // check for being bytes\n        }\n        const seed = _utils_js__WEBPACK_IMPORTED_MODULE_1__.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n        const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n        // Converts signature params into point w r/s, checks result for validity.\n        function k2sig(kBytes) {\n            // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n            const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n            if (!isWithinCurveOrder(k))\n                return; // Important: all mod() calls here must be done over N\n            const ik = invN(k); // k^-1 mod n\n            const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n            const r = modN(q.x); // r = q.x mod n\n            if (r === _0n)\n                return;\n            // Can use scalar blinding b^-1(bm + bdr) where b ∈ [1,q−1] according to\n            // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n            // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n            const s = modN(ik * modN(m + r * d)); // Not using blinding here\n            if (s === _0n)\n                return;\n            let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n            let normS = s;\n            if (lowS && isBiggerThanHalfOrder(s)) {\n                normS = normalizeS(s); // if lowS was passed, ensure s is always\n                recovery ^= 1; // // in the bottom half of N\n            }\n            return new Signature(r, normS, recovery); // use normS, not s\n        }\n        return { seed, k2sig };\n    }\n    const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };\n    const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };\n    /**\n     * Signs message hash with a private key.\n     * ```\n     * sign(m, d, k) where\n     *   (x, y) = G × k\n     *   r = x mod n\n     *   s = (m + dr)/k mod n\n     * ```\n     * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n     * @param privKey private key\n     * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n     * @returns signature with recovery param\n     */\n    function sign(msgHash, privKey, opts = defaultSigOpts) {\n        const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n        const C = CURVE;\n        const drbg = _utils_js__WEBPACK_IMPORTED_MODULE_1__.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);\n        return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n    }\n    // Enable precomputes. Slows down first publicKey computation by 20ms.\n    Point.BASE._setWindowSize(8);\n    // utils.precompute(8, ProjectivePoint.BASE)\n    /**\n     * Verifies a signature against message hash and public key.\n     * Rejects lowS signatures by default: to override,\n     * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n     *\n     * ```\n     * verify(r, s, h, P) where\n     *   U1 = hs^-1 mod n\n     *   U2 = rs^-1 mod n\n     *   R = U1⋅G - U2⋅P\n     *   mod(R.x, n) == r\n     * ```\n     */\n    function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {\n        const sg = signature;\n        msgHash = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('msgHash', msgHash);\n        publicKey = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.ensureBytes)('publicKey', publicKey);\n        if ('strict' in opts)\n            throw new Error('options.strict was renamed to lowS');\n        const { lowS, prehash } = opts;\n        let _sig = undefined;\n        let P;\n        try {\n            if (typeof sg === 'string' || _utils_js__WEBPACK_IMPORTED_MODULE_1__.isBytes(sg)) {\n                // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n                // Since DER can also be 2*nByteLength bytes, we check for it first.\n                try {\n                    _sig = Signature.fromDER(sg);\n                }\n                catch (derError) {\n                    if (!(derError instanceof DER.Err))\n                        throw derError;\n                    _sig = Signature.fromCompact(sg);\n                }\n            }\n            else if (typeof sg === 'object' && typeof sg.r === 'bigint' && typeof sg.s === 'bigint') {\n                const { r, s } = sg;\n                _sig = new Signature(r, s);\n            }\n            else {\n                throw new Error('PARSE');\n            }\n            P = Point.fromHex(publicKey);\n        }\n        catch (error) {\n            if (error.message === 'PARSE')\n                throw new Error(`signature must be Signature instance, Uint8Array or hex string`);\n            return false;\n        }\n        if (lowS && _sig.hasHighS())\n            return false;\n        if (prehash)\n            msgHash = CURVE.hash(msgHash);\n        const { r, s } = _sig;\n        const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n        const is = invN(s); // s^-1\n        const u1 = modN(h * is); // u1 = hs^-1 mod n\n        const u2 = modN(r * is); // u2 = rs^-1 mod n\n        const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1⋅G + u2⋅P\n        if (!R)\n            return false;\n        const v = modN(R.x);\n        return v === r;\n    }\n    return {\n        CURVE,\n        getPublicKey,\n        getSharedSecret,\n        sign,\n        verify,\n        ProjectivePoint: Point,\n        Signature,\n        utils,\n    };\n}\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nfunction SWUFpSqrtRatio(Fp, Z) {\n    // Generic implementation\n    const q = Fp.ORDER;\n    let l = _0n;\n    for (let o = q - _1n; o % _2n === _0n; o /= _2n)\n        l += _1n;\n    const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n    // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n    // 2n ** c1 == 2n << (c1-1)\n    const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n    const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n    const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n    const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n    const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n    const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n    const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n    const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n    let sqrtRatio = (u, v) => {\n        let tv1 = c6; // 1. tv1 = c6\n        let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n        let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n        tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n        let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n        tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n        tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n        tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n        tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n        let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n        tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n        let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n        tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n        tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n        tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n        tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n        // 17. for i in (c1, c1 - 1, ..., 2):\n        for (let i = c1; i > _1n; i--) {\n            let tv5 = i - _2n; // 18.    tv5 = i - 2\n            tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n            let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n            const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n            tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n            tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n            tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n            tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n            tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n        }\n        return { isValid: isQR, value: tv3 };\n    };\n    if (Fp.ORDER % _4n === _3n) {\n        // sqrt_ratio_3mod4(u, v)\n        const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n        const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n        sqrtRatio = (u, v) => {\n            let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n            const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n            tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n            let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n            y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n            const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n            const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n            const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n            let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n            return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n        };\n    }\n    // No curves uses that\n    // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n    return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nfunction mapToCurveSimpleSWU(Fp, opts) {\n    _modular_js__WEBPACK_IMPORTED_MODULE_2__.validateField(Fp);\n    if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n        throw new Error('mapToCurveSimpleSWU: invalid opts');\n    const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n    if (!Fp.isOdd)\n        throw new Error('Fp.isOdd is not implemented!');\n    // Input: u, an element of F.\n    // Output: (x, y), a point on E.\n    return (u) => {\n        // prettier-ignore\n        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n        tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n        tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n        tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n        tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n        tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n        tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n        tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n        tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n        tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n        tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n        tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n        tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n        tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n        tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n        tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n        x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n        const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n        y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n        y = Fp.mul(y, value); // 20.   y = y * y1\n        x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n        y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n        const e1 = Fp.isOdd(u) === Fp.isOdd(y); // 23.  e1 = sgn0(u) == sgn0(y)\n        y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n        x = Fp.div(x, tv4); // 25.   x = x / tv4\n        return { x, y };\n    };\n}\n//# sourceMappingURL=weierstrass.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDb0M7QUFDSDtBQUNRO0FBQ1E7QUFDakQ7QUFDQSxpQkFBaUIsd0RBQWE7QUFDOUIsSUFBSSxxREFBaUI7QUFDckI7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxZQUFZLGNBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0EsUUFBUSx3Q0FBd0MsRUFBRSxzQ0FBRTtBQUM3QztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLDBDQUEwQztBQUMzRCxLQUFLO0FBQ0w7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0EsUUFBUSw2Q0FBUztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQyxnQkFBZ0Isc0JBQXNCO0FBQ3RDO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUIsSUFBSSxHQUFHLEVBQUUsRUFBRSxJQUFJLEdBQUcsRUFBRSxFQUFFO0FBQzNELEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxZQUFZLEtBQUssU0FBUztBQUMxQjtB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QjtBQUM1QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9hYnN0cmFjdC93ZWllcnN0cmFzcy5qcz9kMDQyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFNob3J0IFdlaWVyc3RyYXNzIGN1cnZlLiBUaGUgZm9ybXVsYSBpczogecKyID0geMKzICsgYXggKyBiXG5pbXBvcnQgKiBhcyBtb2QgZnJvbSAnLi9tb2R1bGFyLmpzJztcbmltcG9ydCAqIGFzIHV0IGZyb20gJy4vdXRpbHMuanMnO1xuaW1wb3J0IHsgZW5zdXJlQnl0ZXMgfSBmcm9tICcuL3V0aWxzLmpzJztcbmltcG9ydCB7IHdOQUYsIHZhbGlkYXRlQmFzaWMgfSBmcm9tICcuL2N1cnZlLmpzJztcbmZ1bmN0aW9uIHZhbGlkYXRlUG9pbnRPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgYTogJ2ZpZWxkJyxcbiAgICAgICAgYjogJ2ZpZWxkJyxcbiAgICB9LCB7XG4gICAgICAgIGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogJ2FycmF5JyxcbiAgICAgICAgd3JhcFByaXZhdGVLZXk6ICdib29sZWFuJyxcbiAgICAgICAgaXNUb3JzaW9uRnJlZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgY2xlYXJDb2ZhY3RvcjogJ2Z1bmN0aW9uJyxcbiAgICAgICAgYWxsb3dJbmZpbml0eVBvaW50OiAnYm9vbGVhbicsXG4gICAgICAgIGZyb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdG9CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9KTtcbiAgICBjb25zdCB7IGVuZG8sIEZwLCBhIH0gPSBvcHRzO1xuICAgIGlmIChlbmRvKSB7XG4gICAgICAgIGlmICghRnAuZXFsKGEsIEZwLlpFUk8pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuZG9tb3JwaGlzbSBjYW4gb25seSBiZSBkZWZpbmVkIGZvciBLb2JsaXR6IGN1cnZlcyB0aGF0IGhhdmUgYT0wJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmRvICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgdHlwZW9mIGVuZG8uYmV0YSAhPT0gJ2JpZ2ludCcgfHxcbiAgICAgICAgICAgIHR5cGVvZiBlbmRvLnNwbGl0U2NhbGFyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGVuZG9tb3JwaGlzbSB3aXRoIGJldGE6IGJpZ2ludCBhbmQgc3BsaXRTY2FsYXI6IGZ1bmN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyAuLi5vcHRzIH0pO1xufVxuLy8gQVNOLjEgREVSIGVuY29kaW5nIHV0aWxpdGllc1xuY29uc3QgeyBieXRlc1RvTnVtYmVyQkU6IGIybiwgaGV4VG9CeXRlczogaDJiIH0gPSB1dDtcbmV4cG9ydCBjb25zdCBERVIgPSB7XG4gICAgLy8gYXNuLjEgREVSIGVuY29kaW5nIHV0aWxzXG4gICAgRXJyOiBjbGFzcyBERVJFcnIgZXh0ZW5kcyBFcnJvciB7XG4gICAgICAgIGNvbnN0cnVjdG9yKG0gPSAnJykge1xuICAgICAgICAgICAgc3VwZXIobSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIF9wYXJzZUludChkYXRhKSB7XG4gICAgICAgIGNvbnN0IHsgRXJyOiBFIH0gPSBERVI7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IDIgfHwgZGF0YVswXSAhPT0gMHgwMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSBpbnRlZ2VyIHRhZycpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhWzFdO1xuICAgICAgICBjb25zdCByZXMgPSBkYXRhLnN1YmFycmF5KDIsIGxlbiArIDIpO1xuICAgICAgICBpZiAoIWxlbiB8fCByZXMubGVuZ3RoICE9PSBsZW4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogd3JvbmcgbGVuZ3RoJyk7XG4gICAgICAgIC8vIGh0dHBzOi8vY3J5cHRvLnN0YWNrZXhjaGFuZ2UuY29tL2EvNTc3MzQgTGVmdG1vc3QgYml0IG9mIGZpcnN0IGJ5dGUgaXMgJ25lZ2F0aXZlJyBmbGFnLFxuICAgICAgICAvLyBzaW5jZSB3ZSBhbHdheXMgdXNlIHBvc2l0aXZlIGludGVnZXJzIGhlcmUuIEl0IG11c3QgYWx3YXlzIGJlIGVtcHR5OlxuICAgICAgICAvLyAtIGFkZCB6ZXJvIGJ5dGUgaWYgZXhpc3RzXG4gICAgICAgIC8vIC0gaWYgbmV4dCBieXRlIGRvZXNuJ3QgaGF2ZSBhIGZsYWcsIGxlYWRpbmcgemVybyBpcyBub3QgYWxsb3dlZCAobWluaW1hbCBlbmNvZGluZylcbiAgICAgICAgaWYgKHJlc1swXSAmIDBiMTAwMDAwMDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgRSgnSW52YWxpZCBzaWduYXR1cmUgaW50ZWdlcjogbmVnYXRpdmUnKTtcbiAgICAgICAgaWYgKHJlc1swXSA9PT0gMHgwMCAmJiAhKHJlc1sxXSAmIDBiMTAwMDAwMDApKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlIGludGVnZXI6IHVubmVjZXNzYXJ5IGxlYWRpbmcgemVybycpO1xuICAgICAgICByZXR1cm4geyBkOiBiMm4ocmVzKSwgbDogZGF0YS5zdWJhcnJheShsZW4gKyAyKSB9OyAvLyBkIGlzIGRhdGEsIGwgaXMgbGVmdFxuICAgIH0sXG4gICAgdG9TaWcoaGV4KSB7XG4gICAgICAgIC8vIHBhcnNlIERFUiBzaWduYXR1cmVcbiAgICAgICAgY29uc3QgeyBFcnI6IEUgfSA9IERFUjtcbiAgICAgICAgY29uc3QgZGF0YSA9IHR5cGVvZiBoZXggPT09ICdzdHJpbmcnID8gaDJiKGhleCkgOiBoZXg7XG4gICAgICAgIHV0LmFieXRlcyhkYXRhKTtcbiAgICAgICAgbGV0IGwgPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGwgPCAyIHx8IGRhdGFbMF0gIT0gMHgzMClcbiAgICAgICAgICAgIHRocm93IG5ldyBFKCdJbnZhbGlkIHNpZ25hdHVyZSB0YWcnKTtcbiAgICAgICAgaWYgKGRhdGFbMV0gIT09IGwgLSAyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBpbmNvcnJlY3QgbGVuZ3RoJyk7XG4gICAgICAgIGNvbnN0IHsgZDogciwgbDogc0J5dGVzIH0gPSBERVIuX3BhcnNlSW50KGRhdGEuc3ViYXJyYXkoMikpO1xuICAgICAgICBjb25zdCB7IGQ6IHMsIGw6IHJCeXRlc0xlZnQgfSA9IERFUi5fcGFyc2VJbnQoc0J5dGVzKTtcbiAgICAgICAgaWYgKHJCeXRlc0xlZnQubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEUoJ0ludmFsaWQgc2lnbmF0dXJlOiBsZWZ0IGJ5dGVzIGFmdGVyIHBhcnNpbmcnKTtcbiAgICAgICAgcmV0dXJuIHsgciwgcyB9O1xuICAgIH0sXG4gICAgaGV4RnJvbVNpZyhzaWcpIHtcbiAgICAgICAgLy8gQWRkIGxlYWRpbmcgemVybyBpZiBmaXJzdCBieXRlIGhhcyBuZWdhdGl2ZSBiaXQgZW5hYmxlZC4gTW9yZSBkZXRhaWxzIGluICdfcGFyc2VJbnQnXG4gICAgICAgIGNvbnN0IHNsaWNlID0gKHMpID0+IChOdW1iZXIucGFyc2VJbnQoc1swXSwgMTYpICYgMGIxMDAwID8gJzAwJyArIHMgOiBzKTtcbiAgICAgICAgY29uc3QgaCA9IChudW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhleCA9IG51bS50b1N0cmluZygxNik7XG4gICAgICAgICAgICByZXR1cm4gaGV4Lmxlbmd0aCAmIDEgPyBgMCR7aGV4fWAgOiBoZXg7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHMgPSBzbGljZShoKHNpZy5zKSk7XG4gICAgICAgIGNvbnN0IHIgPSBzbGljZShoKHNpZy5yKSk7XG4gICAgICAgIGNvbnN0IHNobCA9IHMubGVuZ3RoIC8gMjtcbiAgICAgICAgY29uc3QgcmhsID0gci5sZW5ndGggLyAyO1xuICAgICAgICBjb25zdCBzbCA9IGgoc2hsKTtcbiAgICAgICAgY29uc3QgcmwgPSBoKHJobCk7XG4gICAgICAgIHJldHVybiBgMzAke2gocmhsICsgc2hsICsgNCl9MDIke3JsfSR7cn0wMiR7c2x9JHtzfWA7XG4gICAgfSxcbn07XG4vLyBCZSBmcmllbmRseSB0byBiYWQgRUNNQVNjcmlwdCBwYXJzZXJzIGJ5IG5vdCB1c2luZyBiaWdpbnQgbGl0ZXJhbHNcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzNuID0gQmlnSW50KDMpLCBfNG4gPSBCaWdJbnQoNCk7XG5leHBvcnQgZnVuY3Rpb24gd2VpZXJzdHJhc3NQb2ludHMob3B0cykge1xuICAgIGNvbnN0IENVUlZFID0gdmFsaWRhdGVQb2ludE9wdHMob3B0cyk7XG4gICAgY29uc3QgeyBGcCB9ID0gQ1VSVkU7IC8vIEFsbCBjdXJ2ZXMgaGFzIHNhbWUgZmllbGQgLyBncm91cCBsZW5ndGggYXMgZm9yIG5vdywgYnV0IHRoZXkgY2FuIGRpZmZlclxuICAgIGNvbnN0IHRvQnl0ZXMgPSBDVVJWRS50b0J5dGVzIHx8XG4gICAgICAgICgoX2MsIHBvaW50LCBfaXNDb21wcmVzc2VkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gcG9pbnQudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIHJldHVybiB1dC5jb25jYXRCeXRlcyhVaW50OEFycmF5LmZyb20oWzB4MDRdKSwgRnAudG9CeXRlcyhhLngpLCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICB9KTtcbiAgICBjb25zdCBmcm9tQnl0ZXMgPSBDVVJWRS5mcm9tQnl0ZXMgfHxcbiAgICAgICAgKChieXRlcykgPT4ge1xuICAgICAgICAgICAgLy8gY29uc3QgaGVhZCA9IGJ5dGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgdGFpbCA9IGJ5dGVzLnN1YmFycmF5KDEpO1xuICAgICAgICAgICAgLy8gaWYgKGhlYWQgIT09IDB4MDQpIHRocm93IG5ldyBFcnJvcignT25seSBub24tY29tcHJlc3NlZCBlbmNvZGluZyBpcyBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHggPSBGcC5mcm9tQnl0ZXModGFpbC5zdWJhcnJheSgwLCBGcC5CWVRFUykpO1xuICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgIHJldHVybiB7IHgsIHkgfTtcbiAgICAgICAgfSk7XG4gICAgLyoqXG4gICAgICogecKyID0geMKzICsgYXggKyBiOiBTaG9ydCB3ZWllcnN0cmFzcyBjdXJ2ZSBmb3JtdWxhXG4gICAgICogQHJldHVybnMgecKyXG4gICAgICovXG4gICAgZnVuY3Rpb24gd2VpZXJzdHJhc3NFcXVhdGlvbih4KSB7XG4gICAgICAgIGNvbnN0IHsgYSwgYiB9ID0gQ1VSVkU7XG4gICAgICAgIGNvbnN0IHgyID0gRnAuc3FyKHgpOyAvLyB4ICogeFxuICAgICAgICBjb25zdCB4MyA9IEZwLm11bCh4MiwgeCk7IC8vIHgyICogeFxuICAgICAgICByZXR1cm4gRnAuYWRkKEZwLmFkZCh4MywgRnAubXVsKHgsIGEpKSwgYik7IC8vIHgzICsgYSAqIHggKyBiXG4gICAgfVxuICAgIC8vIFZhbGlkYXRlIHdoZXRoZXIgdGhlIHBhc3NlZCBjdXJ2ZSBwYXJhbXMgYXJlIHZhbGlkLlxuICAgIC8vIFdlIGNoZWNrIGlmIGN1cnZlIGVxdWF0aW9uIHdvcmtzIGZvciBnZW5lcmF0b3IgcG9pbnQuXG4gICAgLy8gYGFzc2VydFZhbGlkaXR5KClgIHdvbid0IHdvcms6IGBpc1RvcnNpb25GcmVlKClgIGlzIG5vdCBhdmFpbGFibGUgYXQgdGhpcyBwb2ludCBpbiBibHMxMi0zODEuXG4gICAgLy8gUHJvamVjdGl2ZVBvaW50IGNsYXNzIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXQuXG4gICAgaWYgKCFGcC5lcWwoRnAuc3FyKENVUlZFLkd5KSwgd2VpZXJzdHJhc3NFcXVhdGlvbihDVVJWRS5HeCkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBnZW5lcmF0b3IgcG9pbnQ6IGVxdWF0aW9uIGxlZnQgIT0gcmlnaHQnKTtcbiAgICAvLyBWYWxpZCBncm91cCBlbGVtZW50cyByZXNpZGUgaW4gcmFuZ2UgMS4ubi0xXG4gICAgZnVuY3Rpb24gaXNXaXRoaW5DdXJ2ZU9yZGVyKG51bSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIG51bSA9PT0gJ2JpZ2ludCcgJiYgXzBuIDwgbnVtICYmIG51bSA8IENVUlZFLm47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFzc2VydEdFKG51bSkge1xuICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihudW0pKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB2YWxpZCBiaWdpbnQ6IDAgPCBiaWdpbnQgPCBjdXJ2ZS5uJyk7XG4gICAgfVxuICAgIC8vIFZhbGlkYXRlcyBpZiBwcml2IGtleSBpcyB2YWxpZCBhbmQgY29udmVydHMgaXQgdG8gYmlnaW50LlxuICAgIC8vIFN1cHBvcnRzIG9wdGlvbnMgYWxsb3dlZFByaXZhdGVLZXlMZW5ndGhzIGFuZCB3cmFwUHJpdmF0ZUtleS5cbiAgICBmdW5jdGlvbiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKGtleSkge1xuICAgICAgICBjb25zdCB7IGFsbG93ZWRQcml2YXRlS2V5TGVuZ3RoczogbGVuZ3RocywgbkJ5dGVMZW5ndGgsIHdyYXBQcml2YXRlS2V5LCBuIH0gPSBDVVJWRTtcbiAgICAgICAgaWYgKGxlbmd0aHMgJiYgdHlwZW9mIGtleSAhPT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgIGlmICh1dC5pc0J5dGVzKGtleSkpXG4gICAgICAgICAgICAgICAga2V5ID0gdXQuYnl0ZXNUb0hleChrZXkpO1xuICAgICAgICAgICAgLy8gTm9ybWFsaXplIHRvIGhleCBzdHJpbmcsIHBhZC4gRS5nLiBQNTIxIHdvdWxkIG5vcm0gMTMwLTEzMiBjaGFyIGhleCB0byAxMzItY2hhciBieXRlc1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnIHx8ICFsZW5ndGhzLmluY2x1ZGVzKGtleS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBrZXknKTtcbiAgICAgICAgICAgIGtleSA9IGtleS5wYWRTdGFydChuQnl0ZUxlbmd0aCAqIDIsICcwJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG51bTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG51bSA9XG4gICAgICAgICAgICAgICAgdHlwZW9mIGtleSA9PT0gJ2JpZ2ludCdcbiAgICAgICAgICAgICAgICAgICAgPyBrZXlcbiAgICAgICAgICAgICAgICAgICAgOiB1dC5ieXRlc1RvTnVtYmVyQkUoZW5zdXJlQnl0ZXMoJ3ByaXZhdGUga2V5Jywga2V5LCBuQnl0ZUxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwcml2YXRlIGtleSBtdXN0IGJlICR7bkJ5dGVMZW5ndGh9IGJ5dGVzLCBoZXggb3IgYmlnaW50LCBub3QgJHt0eXBlb2Yga2V5fWApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3cmFwUHJpdmF0ZUtleSlcbiAgICAgICAgICAgIG51bSA9IG1vZC5tb2QobnVtLCBuKTsgLy8gZGlzYWJsZWQgYnkgZGVmYXVsdCwgZW5hYmxlZCBmb3IgQkxTXG4gICAgICAgIGFzc2VydEdFKG51bSk7IC8vIG51bSBpbiByYW5nZSBbMS4uTi0xXVxuICAgICAgICByZXR1cm4gbnVtO1xuICAgIH1cbiAgICBjb25zdCBwb2ludFByZWNvbXB1dGVzID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGFzc2VydFByalBvaW50KG90aGVyKSB7XG4gICAgICAgIGlmICghKG90aGVyIGluc3RhbmNlb2YgUG9pbnQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQcm9qZWN0aXZlUG9pbnQgZXhwZWN0ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvamVjdGl2ZSBQb2ludCB3b3JrcyBpbiAzZCAvIHByb2plY3RpdmUgKGhvbW9nZW5lb3VzKSBjb29yZGluYXRlczogKHgsIHksIHopIOKIiyAoeD14L3osIHk9eS96KVxuICAgICAqIERlZmF1bHQgUG9pbnQgd29ya3MgaW4gMmQgLyBhZmZpbmUgY29vcmRpbmF0ZXM6ICh4LCB5KVxuICAgICAqIFdlJ3JlIGRvaW5nIGNhbGN1bGF0aW9ucyBpbiBwcm9qZWN0aXZlLCBiZWNhdXNlIGl0cyBvcGVyYXRpb25zIGRvbid0IHJlcXVpcmUgY29zdGx5IGludmVyc2lvbi5cbiAgICAgKi9cbiAgICBjbGFzcyBQb2ludCB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHB4LCBweSwgcHopIHtcbiAgICAgICAgICAgIHRoaXMucHggPSBweDtcbiAgICAgICAgICAgIHRoaXMucHkgPSBweTtcbiAgICAgICAgICAgIHRoaXMucHogPSBwejtcbiAgICAgICAgICAgIGlmIChweCA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB4KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ggcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweSA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB5KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3kgcmVxdWlyZWQnKTtcbiAgICAgICAgICAgIGlmIChweiA9PSBudWxsIHx8ICFGcC5pc1ZhbGlkKHB6KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3ogcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEb2VzIG5vdCB2YWxpZGF0ZSBpZiB0aGUgcG9pbnQgaXMgb24tY3VydmUuXG4gICAgICAgIC8vIFVzZSBmcm9tSGV4IGluc3RlYWQsIG9yIGNhbGwgYXNzZXJ0VmFsaWRpdHkoKSBsYXRlci5cbiAgICAgICAgc3RhdGljIGZyb21BZmZpbmUocCkge1xuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBwIHx8IHt9O1xuICAgICAgICAgICAgaWYgKCFwIHx8ICFGcC5pc1ZhbGlkKHgpIHx8ICFGcC5pc1ZhbGlkKHkpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBhZmZpbmUgcG9pbnQnKTtcbiAgICAgICAgICAgIGlmIChwIGluc3RhbmNlb2YgUG9pbnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcm9qZWN0aXZlIHBvaW50IG5vdCBhbGxvd2VkJyk7XG4gICAgICAgICAgICBjb25zdCBpczAgPSAoaSkgPT4gRnAuZXFsKGksIEZwLlpFUk8pO1xuICAgICAgICAgICAgLy8gZnJvbUFmZmluZSh4OjAsIHk6MCkgd291bGQgcHJvZHVjZSAoeDowLCB5OjAsIHo6MSksIGJ1dCB3ZSBuZWVkICh4OjAsIHk6MSwgejowKVxuICAgICAgICAgICAgaWYgKGlzMCh4KSAmJiBpczAoeSkpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFBvaW50LlpFUk87XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHksIEZwLk9ORSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHgoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLng7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHkoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b0FmZmluZSgpLnk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRha2VzIGEgYnVuY2ggb2YgUHJvamVjdGl2ZSBQb2ludHMgYnV0IGV4ZWN1dGVzIG9ubHkgb25lXG4gICAgICAgICAqIGludmVyc2lvbiBvbiBhbGwgb2YgdGhlbS4gSW52ZXJzaW9uIGlzIHZlcnkgc2xvdyBvcGVyYXRpb24sXG4gICAgICAgICAqIHNvIHRoaXMgaW1wcm92ZXMgcGVyZm9ybWFuY2UgbWFzc2l2ZWx5LlxuICAgICAgICAgKiBPcHRpbWl6YXRpb246IGNvbnZlcnRzIGEgbGlzdCBvZiBwcm9qZWN0aXZlIHBvaW50cyB0byBhIGxpc3Qgb2YgaWRlbnRpY2FsIHBvaW50cyB3aXRoIFo9MS5cbiAgICAgICAgICovXG4gICAgICAgIHN0YXRpYyBub3JtYWxpemVaKHBvaW50cykge1xuICAgICAgICAgICAgY29uc3QgdG9JbnYgPSBGcC5pbnZlcnRCYXRjaChwb2ludHMubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzLm1hcCgocCwgaSkgPT4gcC50b0FmZmluZSh0b0ludltpXSkpLm1hcChQb2ludC5mcm9tQWZmaW5lKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ29udmVydHMgaGFzaCBzdHJpbmcgb3IgVWludDhBcnJheSB0byBQb2ludC5cbiAgICAgICAgICogQHBhcmFtIGhleCBzaG9ydC9sb25nIEVDRFNBIGhleFxuICAgICAgICAgKi9cbiAgICAgICAgc3RhdGljIGZyb21IZXgoaGV4KSB7XG4gICAgICAgICAgICBjb25zdCBQID0gUG9pbnQuZnJvbUFmZmluZShmcm9tQnl0ZXMoZW5zdXJlQnl0ZXMoJ3BvaW50SGV4JywgaGV4KSkpO1xuICAgICAgICAgICAgUC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIFA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTXVsdGlwbGllcyBnZW5lcmF0b3IgcG9pbnQgYnkgcHJpdmF0ZUtleS5cbiAgICAgICAgc3RhdGljIGZyb21Qcml2YXRlS2V5KHByaXZhdGVLZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBQb2ludC5CQVNFLm11bHRpcGx5KG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIocHJpdmF0ZUtleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiUHJpdmF0ZSBtZXRob2RcIiwgZG9uJ3QgdXNlIGl0IGRpcmVjdGx5XG4gICAgICAgIF9zZXRXaW5kb3dTaXplKHdpbmRvd1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuX1dJTkRPV19TSVpFID0gd2luZG93U2l6ZTtcbiAgICAgICAgICAgIHBvaW50UHJlY29tcHV0ZXMuZGVsZXRlKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEEgcG9pbnQgb24gY3VydmUgaXMgdmFsaWQgaWYgaXQgY29uZm9ybXMgdG8gZXF1YXRpb24uXG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXMwKCkpIHtcbiAgICAgICAgICAgICAgICAvLyAoMCwgMSwgMCkgYWthIFpFUk8gaXMgaW52YWxpZCBpbiBtb3N0IGNvbnRleHRzLlxuICAgICAgICAgICAgICAgIC8vIEluIEJMUywgWkVSTyBjYW4gYmUgc2VyaWFsaXplZCwgc28gd2UgYWxsb3cgaXQuXG4gICAgICAgICAgICAgICAgLy8gKDAsIDAsIDApIGlzIHdyb25nIHJlcHJlc2VudGF0aW9uIG9mIFpFUk8gYW5kIGlzIGFsd2F5cyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgIGlmIChDVVJWRS5hbGxvd0luZmluaXR5UG9pbnQgJiYgIUZwLmlzMCh0aGlzLnB5KSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIHBvaW50OiBaRVJPJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTb21lIDNyZC1wYXJ0eSB0ZXN0IHZlY3RvcnMgcmVxdWlyZSBkaWZmZXJlbnQgd29yZGluZyBiZXR3ZWVuIGhlcmUgJiBgZnJvbUNvbXByZXNzZWRIZXhgXG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHgsIHkgYXJlIHZhbGlkIGZpZWxkIGVsZW1lbnRzXG4gICAgICAgICAgICBpZiAoIUZwLmlzVmFsaWQoeCkgfHwgIUZwLmlzVmFsaWQoeSkpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgcG9pbnQ6IHggb3IgeSBub3QgRkUnKTtcbiAgICAgICAgICAgIGNvbnN0IGxlZnQgPSBGcC5zcXIoeSk7IC8vIHnCslxuICAgICAgICAgICAgY29uc3QgcmlnaHQgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB4wrMgKyBheCArIGJcbiAgICAgICAgICAgIGlmICghRnAuZXFsKGxlZnQsIHJpZ2h0KSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogZXF1YXRpb24gbGVmdCAhPSByaWdodCcpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVG9yc2lvbkZyZWUoKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCBwb2ludDogbm90IGluIHByaW1lLW9yZGVyIHN1Ymdyb3VwJyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzRXZlblkoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHkgfSA9IHRoaXMudG9BZmZpbmUoKTtcbiAgICAgICAgICAgIGlmIChGcC5pc09kZClcbiAgICAgICAgICAgICAgICByZXR1cm4gIUZwLmlzT2RkKHkpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRmllbGQgZG9lc24ndCBzdXBwb3J0IGlzT2RkXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWxzKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgY29uc3QgVTEgPSBGcC5lcWwoRnAubXVsKFgxLCBaMiksIEZwLm11bChYMiwgWjEpKTtcbiAgICAgICAgICAgIGNvbnN0IFUyID0gRnAuZXFsKEZwLm11bChZMSwgWjIpLCBGcC5tdWwoWTIsIFoxKSk7XG4gICAgICAgICAgICByZXR1cm4gVTEgJiYgVTI7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZsaXBzIHBvaW50IHRvIG9uZSBjb3JyZXNwb25kaW5nIHRvICh4LCAteSkgaW4gQWZmaW5lIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgbmVnYXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLnB4LCBGcC5uZWcodGhpcy5weSksIHRoaXMucHopO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbmVzLUNvc3RlbGxvLUJhdGluYSBleGNlcHRpb24tZnJlZSBkb3VibGluZyBmb3JtdWxhLlxuICAgICAgICAvLyBUaGVyZSBpcyAzMCUgZmFzdGVyIEphY29iaWFuIGZvcm11bGEsIGJ1dCBpdCBpcyBub3QgY29tcGxldGUuXG4gICAgICAgIC8vIGh0dHBzOi8vZXByaW50LmlhY3Iub3JnLzIwMTUvMTA2MCwgYWxnb3JpdGhtIDNcbiAgICAgICAgLy8gQ29zdDogOE0gKyAzUyArIDMqYSArIDIqYjMgKyAxNWFkZC5cbiAgICAgICAgZG91YmxlKCkge1xuICAgICAgICAgICAgY29uc3QgeyBhLCBiIH0gPSBDVVJWRTtcbiAgICAgICAgICAgIGNvbnN0IGIzID0gRnAubXVsKGIsIF8zbik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBsZXQgWDMgPSBGcC5aRVJPLCBZMyA9IEZwLlpFUk8sIFozID0gRnAuWkVSTzsgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBsZXQgdDAgPSBGcC5tdWwoWDEsIFgxKTsgLy8gc3RlcCAxXG4gICAgICAgICAgICBsZXQgdDEgPSBGcC5tdWwoWTEsIFkxKTtcbiAgICAgICAgICAgIGxldCB0MiA9IEZwLm11bChaMSwgWjEpO1xuICAgICAgICAgICAgbGV0IHQzID0gRnAubXVsKFgxLCBZMSk7XG4gICAgICAgICAgICB0MyA9IEZwLmFkZCh0MywgdDMpOyAvLyBzdGVwIDVcbiAgICAgICAgICAgIFozID0gRnAubXVsKFgxLCBaMSk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgWjMpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoYjMsIHQyKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFgzLCBZMyk7IC8vIHN0ZXAgMTBcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBZMyk7XG4gICAgICAgICAgICBZMyA9IEZwLmFkZCh0MSwgWTMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFkzKTtcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bChiMywgWjMpOyAvLyBzdGVwIDE1XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MCwgdDIpO1xuICAgICAgICAgICAgdDMgPSBGcC5tdWwoYSwgdDMpO1xuICAgICAgICAgICAgdDMgPSBGcC5hZGQodDMsIFozKTtcbiAgICAgICAgICAgIFozID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjBcbiAgICAgICAgICAgIHQwID0gRnAuYWRkKFozLCB0MCk7XG4gICAgICAgICAgICB0MCA9IEZwLmFkZCh0MCwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDAsIHQzKTtcbiAgICAgICAgICAgIFkzID0gRnAuYWRkKFkzLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChZMSwgWjEpOyAvLyBzdGVwIDI1XG4gICAgICAgICAgICB0MiA9IEZwLmFkZCh0MiwgdDIpO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDIsIHQzKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKFgzLCB0MCk7XG4gICAgICAgICAgICBaMyA9IEZwLm11bCh0MiwgdDEpO1xuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTsgLy8gc3RlcCAzMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWjMsIFozKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoWDMsIFkzLCBaMyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVuZXMtQ29zdGVsbG8tQmF0aW5hIGV4Y2VwdGlvbi1mcmVlIGFkZGl0aW9uIGZvcm11bGEuXG4gICAgICAgIC8vIFRoZXJlIGlzIDMwJSBmYXN0ZXIgSmFjb2JpYW4gZm9ybXVsYSwgYnV0IGl0IGlzIG5vdCBjb21wbGV0ZS5cbiAgICAgICAgLy8gaHR0cHM6Ly9lcHJpbnQuaWFjci5vcmcvMjAxNS8xMDYwLCBhbGdvcml0aG0gMVxuICAgICAgICAvLyBDb3N0OiAxMk0gKyAwUyArIDMqYSArIDMqYjMgKyAyM2FkZC5cbiAgICAgICAgYWRkKG90aGVyKSB7XG4gICAgICAgICAgICBhc3NlcnRQcmpQb2ludChvdGhlcik7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMSwgcHk6IFkxLCBwejogWjEgfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiBYMiwgcHk6IFkyLCBwejogWjIgfSA9IG90aGVyO1xuICAgICAgICAgICAgbGV0IFgzID0gRnAuWkVSTywgWTMgPSBGcC5aRVJPLCBaMyA9IEZwLlpFUk87IC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICAgICAgY29uc3QgYSA9IENVUlZFLmE7XG4gICAgICAgICAgICBjb25zdCBiMyA9IEZwLm11bChDVVJWRS5iLCBfM24pO1xuICAgICAgICAgICAgbGV0IHQwID0gRnAubXVsKFgxLCBYMik7IC8vIHN0ZXAgMVxuICAgICAgICAgICAgbGV0IHQxID0gRnAubXVsKFkxLCBZMik7XG4gICAgICAgICAgICBsZXQgdDIgPSBGcC5tdWwoWjEsIFoyKTtcbiAgICAgICAgICAgIGxldCB0MyA9IEZwLmFkZChYMSwgWTEpO1xuICAgICAgICAgICAgbGV0IHQ0ID0gRnAuYWRkKFgyLCBZMik7IC8vIHN0ZXAgNVxuICAgICAgICAgICAgdDMgPSBGcC5tdWwodDMsIHQ0KTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQwLCB0MSk7XG4gICAgICAgICAgICB0MyA9IEZwLnN1Yih0MywgdDQpO1xuICAgICAgICAgICAgdDQgPSBGcC5hZGQoWDEsIFoxKTtcbiAgICAgICAgICAgIGxldCB0NSA9IEZwLmFkZChYMiwgWjIpOyAvLyBzdGVwIDEwXG4gICAgICAgICAgICB0NCA9IEZwLm11bCh0NCwgdDUpO1xuICAgICAgICAgICAgdDUgPSBGcC5hZGQodDAsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuc3ViKHQ0LCB0NSk7XG4gICAgICAgICAgICB0NSA9IEZwLmFkZChZMSwgWjEpO1xuICAgICAgICAgICAgWDMgPSBGcC5hZGQoWTIsIFoyKTsgLy8gc3RlcCAxNVxuICAgICAgICAgICAgdDUgPSBGcC5tdWwodDUsIFgzKTtcbiAgICAgICAgICAgIFgzID0gRnAuYWRkKHQxLCB0Mik7XG4gICAgICAgICAgICB0NSA9IEZwLnN1Yih0NSwgWDMpO1xuICAgICAgICAgICAgWjMgPSBGcC5tdWwoYSwgdDQpO1xuICAgICAgICAgICAgWDMgPSBGcC5tdWwoYjMsIHQyKTsgLy8gc3RlcCAyMFxuICAgICAgICAgICAgWjMgPSBGcC5hZGQoWDMsIFozKTtcbiAgICAgICAgICAgIFgzID0gRnAuc3ViKHQxLCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZCh0MSwgWjMpO1xuICAgICAgICAgICAgWTMgPSBGcC5tdWwoWDMsIFozKTtcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQwLCB0MCk7IC8vIHN0ZXAgMjVcbiAgICAgICAgICAgIHQxID0gRnAuYWRkKHQxLCB0MCk7XG4gICAgICAgICAgICB0MiA9IEZwLm11bChhLCB0Mik7XG4gICAgICAgICAgICB0NCA9IEZwLm11bChiMywgdDQpO1xuICAgICAgICAgICAgdDEgPSBGcC5hZGQodDEsIHQyKTtcbiAgICAgICAgICAgIHQyID0gRnAuc3ViKHQwLCB0Mik7IC8vIHN0ZXAgMzBcbiAgICAgICAgICAgIHQyID0gRnAubXVsKGEsIHQyKTtcbiAgICAgICAgICAgIHQ0ID0gRnAuYWRkKHQ0LCB0Mik7XG4gICAgICAgICAgICB0MCA9IEZwLm11bCh0MSwgdDQpO1xuICAgICAgICAgICAgWTMgPSBGcC5hZGQoWTMsIHQwKTtcbiAgICAgICAgICAgIHQwID0gRnAubXVsKHQ1LCB0NCk7IC8vIHN0ZXAgMzVcbiAgICAgICAgICAgIFgzID0gRnAubXVsKHQzLCBYMyk7XG4gICAgICAgICAgICBYMyA9IEZwLnN1YihYMywgdDApO1xuICAgICAgICAgICAgdDAgPSBGcC5tdWwodDMsIHQxKTtcbiAgICAgICAgICAgIFozID0gRnAubXVsKHQ1LCBaMyk7XG4gICAgICAgICAgICBaMyA9IEZwLmFkZChaMywgdDApOyAvLyBzdGVwIDQwXG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFgzLCBZMywgWjMpO1xuICAgICAgICB9XG4gICAgICAgIHN1YnRyYWN0KG90aGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5hZGQob3RoZXIubmVnYXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlzMCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVxdWFscyhQb2ludC5aRVJPKTtcbiAgICAgICAgfVxuICAgICAgICB3TkFGKG4pIHtcbiAgICAgICAgICAgIHJldHVybiB3bmFmLndOQUZDYWNoZWQodGhpcywgcG9pbnRQcmVjb21wdXRlcywgbiwgKGNvbXApID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b0ludiA9IEZwLmludmVydEJhdGNoKGNvbXAubWFwKChwKSA9PiBwLnB6KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXAubWFwKChwLCBpKSA9PiBwLnRvQWZmaW5lKHRvSW52W2ldKSkubWFwKFBvaW50LmZyb21BZmZpbmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE5vbi1jb25zdGFudC10aW1lIG11bHRpcGxpY2F0aW9uLiBVc2VzIGRvdWJsZS1hbmQtYWRkIGFsZ29yaXRobS5cbiAgICAgICAgICogSXQncyBmYXN0ZXIsIGJ1dCBzaG91bGQgb25seSBiZSB1c2VkIHdoZW4geW91IGRvbid0IGNhcmUgYWJvdXRcbiAgICAgICAgICogYW4gZXhwb3NlZCBwcml2YXRlIGtleSBlLmcuIHNpZyB2ZXJpZmljYXRpb24sIHdoaWNoIHdvcmtzIG92ZXIgKnB1YmxpYyoga2V5cy5cbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5VW5zYWZlKG4pIHtcbiAgICAgICAgICAgIGNvbnN0IEkgPSBQb2ludC5aRVJPO1xuICAgICAgICAgICAgaWYgKG4gPT09IF8wbilcbiAgICAgICAgICAgICAgICByZXR1cm4gSTtcbiAgICAgICAgICAgIGFzc2VydEdFKG4pOyAvLyBXaWxsIHRocm93IG9uIDBcbiAgICAgICAgICAgIGlmIChuID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICBjb25zdCB7IGVuZG8gfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKCFlbmRvKVxuICAgICAgICAgICAgICAgIHJldHVybiB3bmFmLnVuc2FmZUxhZGRlcih0aGlzLCBuKTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGVuZG9tb3JwaGlzbVxuICAgICAgICAgICAgbGV0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICBsZXQgazFwID0gSTtcbiAgICAgICAgICAgIGxldCBrMnAgPSBJO1xuICAgICAgICAgICAgbGV0IGQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGsxID4gXzBuIHx8IGsyID4gXzBuKSB7XG4gICAgICAgICAgICAgICAgaWYgKGsxICYgXzFuKVxuICAgICAgICAgICAgICAgICAgICBrMXAgPSBrMXAuYWRkKGQpO1xuICAgICAgICAgICAgICAgIGlmIChrMiAmIF8xbilcbiAgICAgICAgICAgICAgICAgICAgazJwID0gazJwLmFkZChkKTtcbiAgICAgICAgICAgICAgICBkID0gZC5kb3VibGUoKTtcbiAgICAgICAgICAgICAgICBrMSA+Pj0gXzFuO1xuICAgICAgICAgICAgICAgIGsyID4+PSBfMW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazFwID0gazFwLm5lZ2F0ZSgpO1xuICAgICAgICAgICAgaWYgKGsybmVnKVxuICAgICAgICAgICAgICAgIGsycCA9IGsycC5uZWdhdGUoKTtcbiAgICAgICAgICAgIGsycCA9IG5ldyBQb2ludChGcC5tdWwoazJwLnB4LCBlbmRvLmJldGEpLCBrMnAucHksIGsycC5weik7XG4gICAgICAgICAgICByZXR1cm4gazFwLmFkZChrMnApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDb25zdGFudCB0aW1lIG11bHRpcGxpY2F0aW9uLlxuICAgICAgICAgKiBVc2VzIHdOQUYgbWV0aG9kLiBXaW5kb3dlZCBtZXRob2QgbWF5IGJlIDEwJSBmYXN0ZXIsXG4gICAgICAgICAqIGJ1dCB0YWtlcyAyeCBsb25nZXIgdG8gZ2VuZXJhdGUgYW5kIGNvbnN1bWVzIDJ4IG1lbW9yeS5cbiAgICAgICAgICogVXNlcyBwcmVjb21wdXRlcyB3aGVuIGF2YWlsYWJsZS5cbiAgICAgICAgICogVXNlcyBlbmRvbW9ycGhpc20gZm9yIEtvYmxpdHogY3VydmVzLlxuICAgICAgICAgKiBAcGFyYW0gc2NhbGFyIGJ5IHdoaWNoIHRoZSBwb2ludCB3b3VsZCBiZSBtdWx0aXBsaWVkXG4gICAgICAgICAqIEByZXR1cm5zIE5ldyBwb2ludFxuICAgICAgICAgKi9cbiAgICAgICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgICAgICBhc3NlcnRHRShzY2FsYXIpO1xuICAgICAgICAgICAgbGV0IG4gPSBzY2FsYXI7XG4gICAgICAgICAgICBsZXQgcG9pbnQsIGZha2U7IC8vIEZha2UgcG9pbnQgaXMgdXNlZCB0byBjb25zdC10aW1lIG11bHRcbiAgICAgICAgICAgIGNvbnN0IHsgZW5kbyB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoZW5kbykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgazFuZWcsIGsxLCBrMm5lZywgazIgfSA9IGVuZG8uc3BsaXRTY2FsYXIobik7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazFwLCBmOiBmMXAgfSA9IHRoaXMud05BRihrMSk7XG4gICAgICAgICAgICAgICAgbGV0IHsgcDogazJwLCBmOiBmMnAgfSA9IHRoaXMud05BRihrMik7XG4gICAgICAgICAgICAgICAgazFwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazFuZWcsIGsxcCk7XG4gICAgICAgICAgICAgICAgazJwID0gd25hZi5jb25zdFRpbWVOZWdhdGUoazJuZWcsIGsycCk7XG4gICAgICAgICAgICAgICAgazJwID0gbmV3IFBvaW50KEZwLm11bChrMnAucHgsIGVuZG8uYmV0YSksIGsycC5weSwgazJwLnB6KTtcbiAgICAgICAgICAgICAgICBwb2ludCA9IGsxcC5hZGQoazJwKTtcbiAgICAgICAgICAgICAgICBmYWtlID0gZjFwLmFkZChmMnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwLCBmIH0gPSB0aGlzLndOQUYobik7XG4gICAgICAgICAgICAgICAgcG9pbnQgPSBwO1xuICAgICAgICAgICAgICAgIGZha2UgPSBmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm9ybWFsaXplIGB6YCBmb3IgYm90aCBwb2ludHMsIGJ1dCByZXR1cm4gb25seSByZWFsIG9uZVxuICAgICAgICAgICAgcmV0dXJuIFBvaW50Lm5vcm1hbGl6ZVooW3BvaW50LCBmYWtlXSlbMF07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEVmZmljaWVudGx5IGNhbGN1bGF0ZSBgYVAgKyBiUWAuIFVuc2FmZSwgY2FuIGV4cG9zZSBwcml2YXRlIGtleSwgaWYgdXNlZCBpbmNvcnJlY3RseS5cbiAgICAgICAgICogTm90IHVzaW5nIFN0cmF1c3MtU2hhbWlyIHRyaWNrOiBwcmVjb21wdXRhdGlvbiB0YWJsZXMgYXJlIGZhc3Rlci5cbiAgICAgICAgICogVGhlIHRyaWNrIGNvdWxkIGJlIHVzZWZ1bCBpZiBib3RoIFAgYW5kIFEgYXJlIG5vdCBHIChub3QgaW4gb3VyIGNhc2UpLlxuICAgICAgICAgKiBAcmV0dXJucyBub24temVybyBhZmZpbmUgcG9pbnRcbiAgICAgICAgICovXG4gICAgICAgIG11bHRpcGx5QW5kQWRkVW5zYWZlKFEsIGEsIGIpIHtcbiAgICAgICAgICAgIGNvbnN0IEcgPSBQb2ludC5CQVNFOyAvLyBObyBTdHJhdXNzLVNoYW1pciB0cmljazogd2UgaGF2ZSAxMCUgZmFzdGVyIEcgcHJlY29tcHV0ZXNcbiAgICAgICAgICAgIGNvbnN0IG11bCA9IChQLCBhIC8vIFNlbGVjdCBmYXN0ZXIgbXVsdGlwbHkoKSBtZXRob2RcbiAgICAgICAgICAgICkgPT4gKGEgPT09IF8wbiB8fCBhID09PSBfMW4gfHwgIVAuZXF1YWxzKEcpID8gUC5tdWx0aXBseVVuc2FmZShhKSA6IFAubXVsdGlwbHkoYSkpO1xuICAgICAgICAgICAgY29uc3Qgc3VtID0gbXVsKHRoaXMsIGEpLmFkZChtdWwoUSwgYikpO1xuICAgICAgICAgICAgcmV0dXJuIHN1bS5pczAoKSA/IHVuZGVmaW5lZCA6IHN1bTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb252ZXJ0cyBQcm9qZWN0aXZlIHBvaW50IHRvIGFmZmluZSAoeCwgeSkgY29vcmRpbmF0ZXMuXG4gICAgICAgIC8vIENhbiBhY2NlcHQgcHJlY29tcHV0ZWQgWl4tMSAtIGZvciBleGFtcGxlLCBmcm9tIGludmVydEJhdGNoLlxuICAgICAgICAvLyAoeCwgeSwgeikg4oiLICh4PXgveiwgeT15L3opXG4gICAgICAgIHRvQWZmaW5lKGl6KSB7XG4gICAgICAgICAgICBjb25zdCB7IHB4OiB4LCBweTogeSwgcHo6IHogfSA9IHRoaXM7XG4gICAgICAgICAgICBjb25zdCBpczAgPSB0aGlzLmlzMCgpO1xuICAgICAgICAgICAgLy8gSWYgaW52WiB3YXMgMCwgd2UgcmV0dXJuIHplcm8gcG9pbnQuIEhvd2V2ZXIgd2Ugc3RpbGwgd2FudCB0byBleGVjdXRlXG4gICAgICAgICAgICAvLyBhbGwgb3BlcmF0aW9ucywgc28gd2UgcmVwbGFjZSBpbnZaIHdpdGggYSByYW5kb20gbnVtYmVyLCAxLlxuICAgICAgICAgICAgaWYgKGl6ID09IG51bGwpXG4gICAgICAgICAgICAgICAgaXogPSBpczAgPyBGcC5PTkUgOiBGcC5pbnYoeik7XG4gICAgICAgICAgICBjb25zdCBheCA9IEZwLm11bCh4LCBpeik7XG4gICAgICAgICAgICBjb25zdCBheSA9IEZwLm11bCh5LCBpeik7XG4gICAgICAgICAgICBjb25zdCB6eiA9IEZwLm11bCh6LCBpeik7XG4gICAgICAgICAgICBpZiAoaXMwKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IHg6IEZwLlpFUk8sIHk6IEZwLlpFUk8gfTtcbiAgICAgICAgICAgIGlmICghRnAuZXFsKHp6LCBGcC5PTkUpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52WiB3YXMgaW52YWxpZCcpO1xuICAgICAgICAgICAgcmV0dXJuIHsgeDogYXgsIHk6IGF5IH07XG4gICAgICAgIH1cbiAgICAgICAgaXNUb3JzaW9uRnJlZSgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgaDogY29mYWN0b3IsIGlzVG9yc2lvbkZyZWUgfSA9IENVUlZFO1xuICAgICAgICAgICAgaWYgKGNvZmFjdG9yID09PSBfMW4pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIE5vIHN1Ymdyb3VwcywgYWx3YXlzIHRvcnNpb24tZnJlZVxuICAgICAgICAgICAgaWYgKGlzVG9yc2lvbkZyZWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzVG9yc2lvbkZyZWUoUG9pbnQsIHRoaXMpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpc1RvcnNpb25GcmVlKCkgaGFzIG5vdCBiZWVuIGRlY2xhcmVkIGZvciB0aGUgZWxsaXB0aWMgY3VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhckNvZmFjdG9yKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoOiBjb2ZhY3RvciwgY2xlYXJDb2ZhY3RvciB9ID0gQ1VSVkU7XG4gICAgICAgICAgICBpZiAoY29mYWN0b3IgPT09IF8xbilcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpczsgLy8gRmFzdC1wYXRoXG4gICAgICAgICAgICBpZiAoY2xlYXJDb2ZhY3RvcilcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xlYXJDb2ZhY3RvcihQb2ludCwgdGhpcyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tdWx0aXBseVVuc2FmZShDVVJWRS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKTtcbiAgICAgICAgICAgIHJldHVybiB0b0J5dGVzKFBvaW50LCB0aGlzLCBpc0NvbXByZXNzZWQpO1xuICAgICAgICB9XG4gICAgICAgIHRvSGV4KGlzQ29tcHJlc3NlZCA9IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiB1dC5ieXRlc1RvSGV4KHRoaXMudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQb2ludC5CQVNFID0gbmV3IFBvaW50KENVUlZFLkd4LCBDVVJWRS5HeSwgRnAuT05FKTtcbiAgICBQb2ludC5aRVJPID0gbmV3IFBvaW50KEZwLlpFUk8sIEZwLk9ORSwgRnAuWkVSTyk7XG4gICAgY29uc3QgX2JpdHMgPSBDVVJWRS5uQml0TGVuZ3RoO1xuICAgIGNvbnN0IHduYWYgPSB3TkFGKFBvaW50LCBDVVJWRS5lbmRvID8gTWF0aC5jZWlsKF9iaXRzIC8gMikgOiBfYml0cyk7XG4gICAgLy8gVmFsaWRhdGUgaWYgZ2VuZXJhdG9yIHBvaW50IGlzIG9uIGN1cnZlXG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsXG4gICAgICAgIHdlaWVyc3RyYXNzRXF1YXRpb24sXG4gICAgICAgIGlzV2l0aGluQ3VydmVPcmRlcixcbiAgICB9O1xufVxuZnVuY3Rpb24gdmFsaWRhdGVPcHRzKGN1cnZlKSB7XG4gICAgY29uc3Qgb3B0cyA9IHZhbGlkYXRlQmFzaWMoY3VydmUpO1xuICAgIHV0LnZhbGlkYXRlT2JqZWN0KG9wdHMsIHtcbiAgICAgICAgaGFzaDogJ2hhc2gnLFxuICAgICAgICBobWFjOiAnZnVuY3Rpb24nLFxuICAgICAgICByYW5kb21CeXRlczogJ2Z1bmN0aW9uJyxcbiAgICB9LCB7XG4gICAgICAgIGJpdHMyaW50OiAnZnVuY3Rpb24nLFxuICAgICAgICBiaXRzMmludF9tb2ROOiAnZnVuY3Rpb24nLFxuICAgICAgICBsb3dTOiAnYm9vbGVhbicsXG4gICAgfSk7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBsb3dTOiB0cnVlLCAuLi5vcHRzIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdlaWVyc3RyYXNzKGN1cnZlRGVmKSB7XG4gICAgY29uc3QgQ1VSVkUgPSB2YWxpZGF0ZU9wdHMoY3VydmVEZWYpO1xuICAgIGNvbnN0IHsgRnAsIG46IENVUlZFX09SREVSIH0gPSBDVVJWRTtcbiAgICBjb25zdCBjb21wcmVzc2VkTGVuID0gRnAuQllURVMgKyAxOyAvLyBlLmcuIDMzIGZvciAzMlxuICAgIGNvbnN0IHVuY29tcHJlc3NlZExlbiA9IDIgKiBGcC5CWVRFUyArIDE7IC8vIGUuZy4gNjUgZm9yIDMyXG4gICAgZnVuY3Rpb24gaXNWYWxpZEZpZWxkRWxlbWVudChudW0pIHtcbiAgICAgICAgcmV0dXJuIF8wbiA8IG51bSAmJiBudW0gPCBGcC5PUkRFUjsgLy8gMCBpcyBiYW5uZWQgc2luY2UgaXQncyBub3QgaW52ZXJ0aWJsZSBGRVxuICAgIH1cbiAgICBmdW5jdGlvbiBtb2ROKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5tb2QoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbnZOKGEpIHtcbiAgICAgICAgcmV0dXJuIG1vZC5pbnZlcnQoYSwgQ1VSVkVfT1JERVIpO1xuICAgIH1cbiAgICBjb25zdCB7IFByb2plY3RpdmVQb2ludDogUG9pbnQsIG5vcm1Qcml2YXRlS2V5VG9TY2FsYXIsIHdlaWVyc3RyYXNzRXF1YXRpb24sIGlzV2l0aGluQ3VydmVPcmRlciwgfSA9IHdlaWVyc3RyYXNzUG9pbnRzKHtcbiAgICAgICAgLi4uQ1VSVkUsXG4gICAgICAgIHRvQnl0ZXMoX2MsIHBvaW50LCBpc0NvbXByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBwb2ludC50b0FmZmluZSgpO1xuICAgICAgICAgICAgY29uc3QgeCA9IEZwLnRvQnl0ZXMoYS54KTtcbiAgICAgICAgICAgIGNvbnN0IGNhdCA9IHV0LmNvbmNhdEJ5dGVzO1xuICAgICAgICAgICAgaWYgKGlzQ29tcHJlc3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYXQoVWludDhBcnJheS5mcm9tKFtwb2ludC5oYXNFdmVuWSgpID8gMHgwMiA6IDB4MDNdKSwgeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2F0KFVpbnQ4QXJyYXkuZnJvbShbMHgwNF0pLCB4LCBGcC50b0J5dGVzKGEueSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aDtcbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBieXRlc1swXTtcbiAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBieXRlcy5zdWJhcnJheSgxKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYXNzZXJ0VmFsaWRpdHkoKSBpcyBkb25lIGluc2lkZSBvZiBmcm9tSGV4XG4gICAgICAgICAgICBpZiAobGVuID09PSBjb21wcmVzc2VkTGVuICYmIChoZWFkID09PSAweDAyIHx8IGhlYWQgPT09IDB4MDMpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHV0LmJ5dGVzVG9OdW1iZXJCRSh0YWlsKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRGaWVsZEVsZW1lbnQoeCkpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUG9pbnQgaXMgbm90IG9uIGN1cnZlJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeTIgPSB3ZWllcnN0cmFzc0VxdWF0aW9uKHgpOyAvLyB5wrIgPSB4wrMgKyBheCArIGJcbiAgICAgICAgICAgICAgICBsZXQgeTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB5ID0gRnAuc3FydCh5Mik7IC8vIHkgPSB5wrIgXiAocCsxKS80XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChzcXJ0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VmZml4ID0gc3FydEVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyAnOiAnICsgc3FydEVycm9yLm1lc3NhZ2UgOiAnJztcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBpcyBub3Qgb24gY3VydmUnICsgc3VmZml4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNZT2RkID0gKHkgJiBfMW4pID09PSBfMW47XG4gICAgICAgICAgICAgICAgLy8gRUNEU0FcbiAgICAgICAgICAgICAgICBjb25zdCBpc0hlYWRPZGQgPSAoaGVhZCAmIDEpID09PSAxO1xuICAgICAgICAgICAgICAgIGlmIChpc0hlYWRPZGQgIT09IGlzWU9kZClcbiAgICAgICAgICAgICAgICAgICAgeSA9IEZwLm5lZyh5KTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChsZW4gPT09IHVuY29tcHJlc3NlZExlbiAmJiBoZWFkID09PSAweDA0KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KDAsIEZwLkJZVEVTKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgeSA9IEZwLmZyb21CeXRlcyh0YWlsLnN1YmFycmF5KEZwLkJZVEVTLCAyICogRnAuQllURVMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB4LCB5IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBvaW50IG9mIGxlbmd0aCAke2xlbn0gd2FzIGludmFsaWQuIEV4cGVjdGVkICR7Y29tcHJlc3NlZExlbn0gY29tcHJlc3NlZCBieXRlcyBvciAke3VuY29tcHJlc3NlZExlbn0gdW5jb21wcmVzc2VkIGJ5dGVzYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbnVtVG9OQnl0ZVN0ciA9IChudW0pID0+IHV0LmJ5dGVzVG9IZXgodXQubnVtYmVyVG9CeXRlc0JFKG51bSwgQ1VSVkUubkJ5dGVMZW5ndGgpKTtcbiAgICBmdW5jdGlvbiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIobnVtYmVyKSB7XG4gICAgICAgIGNvbnN0IEhBTEYgPSBDVVJWRV9PUkRFUiA+PiBfMW47XG4gICAgICAgIHJldHVybiBudW1iZXIgPiBIQUxGO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemVTKHMpIHtcbiAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcihzKSA/IG1vZE4oLXMpIDogcztcbiAgICB9XG4gICAgLy8gc2xpY2UgYnl0ZXMgbnVtXG4gICAgY29uc3Qgc2xjTnVtID0gKGIsIGZyb20sIHRvKSA9PiB1dC5ieXRlc1RvTnVtYmVyQkUoYi5zbGljZShmcm9tLCB0bykpO1xuICAgIC8qKlxuICAgICAqIEVDRFNBIHNpZ25hdHVyZSB3aXRoIGl0cyAociwgcykgcHJvcGVydGllcy4gU3VwcG9ydHMgREVSICYgY29tcGFjdCByZXByZXNlbnRhdGlvbnMuXG4gICAgICovXG4gICAgY2xhc3MgU2lnbmF0dXJlIHtcbiAgICAgICAgY29uc3RydWN0b3IociwgcywgcmVjb3ZlcnkpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHI7XG4gICAgICAgICAgICB0aGlzLnMgPSBzO1xuICAgICAgICAgICAgdGhpcy5yZWNvdmVyeSA9IHJlY292ZXJ5O1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRWYWxpZGl0eSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhaXIgKGJ5dGVzIG9mIHIsIGJ5dGVzIG9mIHMpXG4gICAgICAgIHN0YXRpYyBmcm9tQ29tcGFjdChoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBDVVJWRS5uQnl0ZUxlbmd0aDtcbiAgICAgICAgICAgIGhleCA9IGVuc3VyZUJ5dGVzKCdjb21wYWN0U2lnbmF0dXJlJywgaGV4LCBsICogMik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZShzbGNOdW0oaGV4LCAwLCBsKSwgc2xjTnVtKGhleCwgbCwgMiAqIGwpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBERVIgZW5jb2RlZCBFQ0RTQSBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9iaXRjb2luLnN0YWNrZXhjaGFuZ2UuY29tL3F1ZXN0aW9ucy81NzY0NC93aGF0LWFyZS10aGUtcGFydHMtb2YtYS1iaXRjb2luLXRyYW5zYWN0aW9uLWlucHV0LXNjcmlwdFxuICAgICAgICBzdGF0aWMgZnJvbURFUihoZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcyB9ID0gREVSLnRvU2lnKGVuc3VyZUJ5dGVzKCdERVInLCBoZXgpKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydFZhbGlkaXR5KCkge1xuICAgICAgICAgICAgLy8gY2FuIHVzZSBhc3NlcnRHRSBoZXJlXG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcih0aGlzLnIpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignciBtdXN0IGJlIDAgPCByIDwgQ1VSVkUubicpO1xuICAgICAgICAgICAgaWYgKCFpc1dpdGhpbkN1cnZlT3JkZXIodGhpcy5zKSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3MgbXVzdCBiZSAwIDwgcyA8IENVUlZFLm4nKTtcbiAgICAgICAgfVxuICAgICAgICBhZGRSZWNvdmVyeUJpdChyZWNvdmVyeSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTaWduYXR1cmUodGhpcy5yLCB0aGlzLnMsIHJlY292ZXJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZWNvdmVyUHVibGljS2V5KG1zZ0hhc2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgcywgcmVjb3Zlcnk6IHJlYyB9ID0gdGhpcztcbiAgICAgICAgICAgIGNvbnN0IGggPSBiaXRzMmludF9tb2ROKGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCkpOyAvLyBUcnVuY2F0ZSBoYXNoXG4gICAgICAgICAgICBpZiAocmVjID09IG51bGwgfHwgIVswLCAxLCAyLCAzXS5pbmNsdWRlcyhyZWMpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVjb3ZlcnkgaWQgaW52YWxpZCcpO1xuICAgICAgICAgICAgY29uc3QgcmFkaiA9IHJlYyA9PT0gMiB8fCByZWMgPT09IDMgPyByICsgQ1VSVkUubiA6IHI7XG4gICAgICAgICAgICBpZiAocmFkaiA+PSBGcC5PUkRFUilcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3JlY292ZXJ5IGlkIDIgb3IgMyBpbnZhbGlkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVmaXggPSAocmVjICYgMSkgPT09IDAgPyAnMDInIDogJzAzJztcbiAgICAgICAgICAgIGNvbnN0IFIgPSBQb2ludC5mcm9tSGV4KHByZWZpeCArIG51bVRvTkJ5dGVTdHIocmFkaikpO1xuICAgICAgICAgICAgY29uc3QgaXIgPSBpbnZOKHJhZGopOyAvLyByXi0xXG4gICAgICAgICAgICBjb25zdCB1MSA9IG1vZE4oLWggKiBpcik7IC8vIC1ocl4tMVxuICAgICAgICAgICAgY29uc3QgdTIgPSBtb2ROKHMgKiBpcik7IC8vIHNyXi0xXG4gICAgICAgICAgICBjb25zdCBRID0gUG9pbnQuQkFTRS5tdWx0aXBseUFuZEFkZFVuc2FmZShSLCB1MSwgdTIpOyAvLyAoc3JeLTEpUi0oaHJeLTEpRyA9IC0oaHJeLTEpRyArIChzcl4tMSlcbiAgICAgICAgICAgIGlmICghUSlcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BvaW50IGF0IGluZmluaWZ5Jyk7IC8vIHVuc2FmZSBpcyBmaW5lOiBubyBwcml2IGRhdGEgbGVha2VkXG4gICAgICAgICAgICBRLmFzc2VydFZhbGlkaXR5KCk7XG4gICAgICAgICAgICByZXR1cm4gUTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTaWduYXR1cmVzIHNob3VsZCBiZSBsb3ctcywgdG8gcHJldmVudCBtYWxsZWFiaWxpdHkuXG4gICAgICAgIGhhc0hpZ2hTKCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQmlnZ2VyVGhhbkhhbGZPcmRlcih0aGlzLnMpO1xuICAgICAgICB9XG4gICAgICAgIG5vcm1hbGl6ZVMoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNIaWdoUygpID8gbmV3IFNpZ25hdHVyZSh0aGlzLnIsIG1vZE4oLXRoaXMucyksIHRoaXMucmVjb3ZlcnkpIDogdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBERVItZW5jb2RlZFxuICAgICAgICB0b0RFUlJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0RFUkhleCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0b0RFUkhleCgpIHtcbiAgICAgICAgICAgIHJldHVybiBERVIuaGV4RnJvbVNpZyh7IHI6IHRoaXMuciwgczogdGhpcy5zIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vIHBhZGRlZCBieXRlcyBvZiByLCB0aGVuIHBhZGRlZCBieXRlcyBvZiBzXG4gICAgICAgIHRvQ29tcGFjdFJhd0J5dGVzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHV0LmhleFRvQnl0ZXModGhpcy50b0NvbXBhY3RIZXgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgdG9Db21wYWN0SGV4KCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bVRvTkJ5dGVTdHIodGhpcy5yKSArIG51bVRvTkJ5dGVTdHIodGhpcy5zKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB1dGlscyA9IHtcbiAgICAgICAgaXNWYWxpZFByaXZhdGVLZXkocHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVLZXkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBub3JtUHJpdmF0ZUtleVRvU2NhbGFyOiBub3JtUHJpdmF0ZUtleVRvU2NhbGFyLFxuICAgICAgICAvKipcbiAgICAgICAgICogUHJvZHVjZXMgY3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHByaXZhdGUga2V5IGZyb20gcmFuZG9tIG9mIHNpemVcbiAgICAgICAgICogKGdyb3VwTGVuICsgY2VpbChncm91cExlbiAvIDIpKSB3aXRoIG1vZHVsbyBiaWFzIGJlaW5nIG5lZ2xpZ2libGUuXG4gICAgICAgICAqL1xuICAgICAgICByYW5kb21Qcml2YXRlS2V5OiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBtb2QuZ2V0TWluSGFzaExlbmd0aChDVVJWRS5uKTtcbiAgICAgICAgICAgIHJldHVybiBtb2QubWFwSGFzaFRvRmllbGQoQ1VSVkUucmFuZG9tQnl0ZXMobGVuZ3RoKSwgQ1VSVkUubik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDcmVhdGVzIHByZWNvbXB1dGUgdGFibGUgZm9yIGFuIGFyYml0cmFyeSBFQyBwb2ludC4gTWFrZXMgcG9pbnQgXCJjYWNoZWRcIi5cbiAgICAgICAgICogQWxsb3dzIHRvIG1hc3NpdmVseSBzcGVlZC11cCBgcG9pbnQubXVsdGlwbHkoc2NhbGFyKWAuXG4gICAgICAgICAqIEByZXR1cm5zIGNhY2hlZCBwb2ludFxuICAgICAgICAgKiBAZXhhbXBsZVxuICAgICAgICAgKiBjb25zdCBmYXN0ID0gdXRpbHMucHJlY29tcHV0ZSg4LCBQcm9qZWN0aXZlUG9pbnQuZnJvbUhleChzb21lb25lc1B1YktleSkpO1xuICAgICAgICAgKiBmYXN0Lm11bHRpcGx5KHByaXZLZXkpOyAvLyBtdWNoIGZhc3RlciBFQ0RIIG5vd1xuICAgICAgICAgKi9cbiAgICAgICAgcHJlY29tcHV0ZSh3aW5kb3dTaXplID0gOCwgcG9pbnQgPSBQb2ludC5CQVNFKSB7XG4gICAgICAgICAgICBwb2ludC5fc2V0V2luZG93U2l6ZSh3aW5kb3dTaXplKTtcbiAgICAgICAgICAgIHBvaW50Lm11bHRpcGx5KEJpZ0ludCgzKSk7IC8vIDMgaXMgYXJiaXRyYXJ5LCBqdXN0IG5lZWQgYW55IG51bWJlciBoZXJlXG4gICAgICAgICAgICByZXR1cm4gcG9pbnQ7XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyBwdWJsaWMga2V5IGZvciBhIHByaXZhdGUga2V5LiBDaGVja3MgZm9yIHZhbGlkaXR5IG9mIHRoZSBwcml2YXRlIGtleS5cbiAgICAgKiBAcGFyYW0gcHJpdmF0ZUtleSBwcml2YXRlIGtleVxuICAgICAqIEBwYXJhbSBpc0NvbXByZXNzZWQgd2hldGhlciB0byByZXR1cm4gY29tcGFjdCAoZGVmYXVsdCksIG9yIGZ1bGwga2V5XG4gICAgICogQHJldHVybnMgUHVibGljIGtleSwgZnVsbCB3aGVuIGlzQ29tcHJlc3NlZD1mYWxzZTsgc2hvcnQgd2hlbiBpc0NvbXByZXNzZWQ9dHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFB1YmxpY0tleShwcml2YXRlS2V5LCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIHJldHVybiBQb2ludC5mcm9tUHJpdmF0ZUtleShwcml2YXRlS2V5KS50b1Jhd0J5dGVzKGlzQ29tcHJlc3NlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFF1aWNrIGFuZCBkaXJ0eSBjaGVjayBmb3IgaXRlbSBiZWluZyBwdWJsaWMga2V5LiBEb2VzIG5vdCB2YWxpZGF0ZSBoZXgsIG9yIGJlaW5nIG9uLWN1cnZlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzUHJvYlB1YihpdGVtKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IHV0LmlzQnl0ZXMoaXRlbSk7XG4gICAgICAgIGNvbnN0IHN0ciA9IHR5cGVvZiBpdGVtID09PSAnc3RyaW5nJztcbiAgICAgICAgY29uc3QgbGVuID0gKGFyciB8fCBzdHIpICYmIGl0ZW0ubGVuZ3RoO1xuICAgICAgICBpZiAoYXJyKVxuICAgICAgICAgICAgcmV0dXJuIGxlbiA9PT0gY29tcHJlc3NlZExlbiB8fCBsZW4gPT09IHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKHN0cilcbiAgICAgICAgICAgIHJldHVybiBsZW4gPT09IDIgKiBjb21wcmVzc2VkTGVuIHx8IGxlbiA9PT0gMiAqIHVuY29tcHJlc3NlZExlbjtcbiAgICAgICAgaWYgKGl0ZW0gaW5zdGFuY2VvZiBQb2ludClcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVDREggKEVsbGlwdGljIEN1cnZlIERpZmZpZSBIZWxsbWFuKS5cbiAgICAgKiBDb21wdXRlcyBzaGFyZWQgcHVibGljIGtleSBmcm9tIHByaXZhdGUga2V5IGFuZCBwdWJsaWMga2V5LlxuICAgICAqIENoZWNrczogMSkgcHJpdmF0ZSBrZXkgdmFsaWRpdHkgMikgc2hhcmVkIGtleSBpcyBvbi1jdXJ2ZS5cbiAgICAgKiBEb2VzIE5PVCBoYXNoIHRoZSByZXN1bHQuXG4gICAgICogQHBhcmFtIHByaXZhdGVBIHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIHB1YmxpY0IgZGlmZmVyZW50IHB1YmxpYyBrZXlcbiAgICAgKiBAcGFyYW0gaXNDb21wcmVzc2VkIHdoZXRoZXIgdG8gcmV0dXJuIGNvbXBhY3QgKGRlZmF1bHQpLCBvciBmdWxsIGtleVxuICAgICAqIEByZXR1cm5zIHNoYXJlZCBwdWJsaWMga2V5XG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0U2hhcmVkU2VjcmV0KHByaXZhdGVBLCBwdWJsaWNCLCBpc0NvbXByZXNzZWQgPSB0cnVlKSB7XG4gICAgICAgIGlmIChpc1Byb2JQdWIocHJpdmF0ZUEpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmaXJzdCBhcmcgbXVzdCBiZSBwcml2YXRlIGtleScpO1xuICAgICAgICBpZiAoIWlzUHJvYlB1YihwdWJsaWNCKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2Vjb25kIGFyZyBtdXN0IGJlIHB1YmxpYyBrZXknKTtcbiAgICAgICAgY29uc3QgYiA9IFBvaW50LmZyb21IZXgocHVibGljQik7IC8vIGNoZWNrIGZvciBiZWluZyBvbi1jdXJ2ZVxuICAgICAgICByZXR1cm4gYi5tdWx0aXBseShub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXZhdGVBKSkudG9SYXdCeXRlcyhpc0NvbXByZXNzZWQpO1xuICAgIH1cbiAgICAvLyBSRkM2OTc5OiBlbnN1cmUgRUNEU0EgbXNnIGlzIFggYnl0ZXMgYW5kIDwgTi4gUkZDIHN1Z2dlc3RzIG9wdGlvbmFsIHRydW5jYXRpbmcgdmlhIGJpdHMyb2N0ZXRzLlxuICAgIC8vIEZJUFMgMTg2LTQgNC42IHN1Z2dlc3RzIHRoZSBsZWZ0bW9zdCBtaW4obkJpdExlbiwgb3V0TGVuKSBiaXRzLCB3aGljaCBtYXRjaGVzIGJpdHMyaW50LlxuICAgIC8vIGJpdHMyaW50IGNhbiBwcm9kdWNlIHJlcz5OLCB3ZSBjYW4gZG8gbW9kKHJlcywgTikgc2luY2UgdGhlIGJpdExlbiBpcyB0aGUgc2FtZS5cbiAgICAvLyBpbnQyb2N0ZXRzIGNhbid0IGJlIHVzZWQ7IHBhZHMgc21hbGwgbXNncyB3aXRoIDA6IHVuYWNjZXB0YXRibGUgZm9yIHRydW5jIGFzIHBlciBSRkMgdmVjdG9yc1xuICAgIGNvbnN0IGJpdHMyaW50ID0gQ1VSVkUuYml0czJpbnQgfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICAvLyBGb3IgY3VydmVzIHdpdGggbkJpdExlbmd0aCAlIDggIT09IDA6IGJpdHMyb2N0ZXRzKGJpdHMyb2N0ZXRzKG0pKSAhPT0gYml0czJvY3RldHMobSlcbiAgICAgICAgICAgIC8vIGZvciBzb21lIGNhc2VzLCBzaW5jZSBieXRlcy5sZW5ndGggKiA4IGlzIG5vdCBhY3R1YWwgYml0TGVuZ3RoLlxuICAgICAgICAgICAgY29uc3QgbnVtID0gdXQuYnl0ZXNUb051bWJlckJFKGJ5dGVzKTsgLy8gY2hlY2sgZm9yID09IHU4IGRvbmUgaGVyZVxuICAgICAgICAgICAgY29uc3QgZGVsdGEgPSBieXRlcy5sZW5ndGggKiA4IC0gQ1VSVkUubkJpdExlbmd0aDsgLy8gdHJ1bmNhdGUgdG8gbkJpdExlbmd0aCBsZWZ0bW9zdCBiaXRzXG4gICAgICAgICAgICByZXR1cm4gZGVsdGEgPiAwID8gbnVtID4+IEJpZ0ludChkZWx0YSkgOiBudW07XG4gICAgICAgIH07XG4gICAgY29uc3QgYml0czJpbnRfbW9kTiA9IENVUlZFLmJpdHMyaW50X21vZE4gfHxcbiAgICAgICAgZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gbW9kTihiaXRzMmludChieXRlcykpOyAvLyBjYW4ndCB1c2UgYnl0ZXNUb051bWJlckJFIGhlcmVcbiAgICAgICAgfTtcbiAgICAvLyBOT1RFOiBwYWRzIG91dHB1dCB3aXRoIHplcm8gYXMgcGVyIHNwZWNcbiAgICBjb25zdCBPUkRFUl9NQVNLID0gdXQuYml0TWFzayhDVVJWRS5uQml0TGVuZ3RoKTtcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0byBieXRlcy4gQ2hlY2tzIGlmIG51bSBpbiBgWzAuLk9SREVSX01BU0stMV1gIGUuZy46IGBbMC4uMl4yNTYtMV1gLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludDJvY3RldHMobnVtKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbnVtICE9PSAnYmlnaW50JylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYmlnaW50IGV4cGVjdGVkJyk7XG4gICAgICAgIGlmICghKF8wbiA8PSBudW0gJiYgbnVtIDwgT1JERVJfTUFTSykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGJpZ2ludCBleHBlY3RlZCA8IDJeJHtDVVJWRS5uQml0TGVuZ3RofWApO1xuICAgICAgICAvLyB3b3JrcyB3aXRoIG9yZGVyLCBjYW4gaGF2ZSBkaWZmZXJlbnQgc2l6ZSB0aGFuIG51bVRvRmllbGQhXG4gICAgICAgIHJldHVybiB1dC5udW1iZXJUb0J5dGVzQkUobnVtLCBDVVJWRS5uQnl0ZUxlbmd0aCk7XG4gICAgfVxuICAgIC8vIFN0ZXBzIEEsIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAvLyBDcmVhdGVzIFJGQzY5Nzkgc2VlZDsgY29udmVydHMgbXNnL3ByaXZLZXkgdG8gbnVtYmVycy5cbiAgICAvLyBVc2VkIG9ubHkgaW4gc2lnbiwgbm90IGluIHZlcmlmeS5cbiAgICAvLyBOT1RFOiB3ZSBjYW5ub3QgYXNzdW1lIGhlcmUgdGhhdCBtc2dIYXNoIGhhcyBzYW1lIGFtb3VudCBvZiBieXRlcyBhcyBjdXJ2ZSBvcmRlciwgdGhpcyB3aWxsIGJlIHdyb25nIGF0IGxlYXN0IGZvciBQNTIxLlxuICAgIC8vIEFsc28gaXQgY2FuIGJlIGJpZ2dlciBmb3IgUDIyNCArIFNIQTI1NlxuICAgIGZ1bmN0aW9uIHByZXBTaWcobXNnSGFzaCwgcHJpdmF0ZUtleSwgb3B0cyA9IGRlZmF1bHRTaWdPcHRzKSB7XG4gICAgICAgIGlmIChbJ3JlY292ZXJlZCcsICdjYW5vbmljYWwnXS5zb21lKChrKSA9PiBrIGluIG9wdHMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduKCkgbGVnYWN5IG9wdGlvbnMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICBjb25zdCB7IGhhc2gsIHJhbmRvbUJ5dGVzIH0gPSBDVVJWRTtcbiAgICAgICAgbGV0IHsgbG93UywgcHJlaGFzaCwgZXh0cmFFbnRyb3B5OiBlbnQgfSA9IG9wdHM7IC8vIGdlbmVyYXRlcyBsb3ctcyBzaWdzIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKGxvd1MgPT0gbnVsbClcbiAgICAgICAgICAgIGxvd1MgPSB0cnVlOyAvLyBSRkM2OTc5IDMuMjogd2Ugc2tpcCBzdGVwIEEsIGJlY2F1c2Ugd2UgYWxyZWFkeSBwcm92aWRlIGhhc2hcbiAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdtc2dIYXNoJywgbXNnSGFzaCk7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IGVuc3VyZUJ5dGVzKCdwcmVoYXNoZWQgbXNnSGFzaCcsIGhhc2gobXNnSGFzaCkpO1xuICAgICAgICAvLyBXZSBjYW4ndCBsYXRlciBjYWxsIGJpdHMyb2N0ZXRzLCBzaW5jZSBuZXN0ZWQgYml0czJpbnQgaXMgYnJva2VuIGZvciBjdXJ2ZXNcbiAgICAgICAgLy8gd2l0aCBuQml0TGVuZ3RoICUgOCAhPT0gMC4gQmVjYXVzZSBvZiB0aGF0LCB3ZSB1bndyYXAgaXQgaGVyZSBhcyBpbnQyb2N0ZXRzIGNhbGwuXG4gICAgICAgIC8vIGNvbnN0IGJpdHMyb2N0ZXRzID0gKGJpdHMpID0+IGludDJvY3RldHMoYml0czJpbnRfbW9kTihiaXRzKSlcbiAgICAgICAgY29uc3QgaDFpbnQgPSBiaXRzMmludF9tb2ROKG1zZ0hhc2gpO1xuICAgICAgICBjb25zdCBkID0gbm9ybVByaXZhdGVLZXlUb1NjYWxhcihwcml2YXRlS2V5KTsgLy8gdmFsaWRhdGUgcHJpdmF0ZSBrZXksIGNvbnZlcnQgdG8gYmlnaW50XG4gICAgICAgIGNvbnN0IHNlZWRBcmdzID0gW2ludDJvY3RldHMoZCksIGludDJvY3RldHMoaDFpbnQpXTtcbiAgICAgICAgLy8gZXh0cmFFbnRyb3B5LiBSRkM2OTc5IDMuNjogYWRkaXRpb25hbCBrJyAob3B0aW9uYWwpLlxuICAgICAgICBpZiAoZW50ICE9IG51bGwgJiYgZW50ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gSyA9IEhNQUNfSyhWIHx8IDB4MDAgfHwgaW50Mm9jdGV0cyh4KSB8fCBiaXRzMm9jdGV0cyhoMSkgfHwgaycpXG4gICAgICAgICAgICBjb25zdCBlID0gZW50ID09PSB0cnVlID8gcmFuZG9tQnl0ZXMoRnAuQllURVMpIDogZW50OyAvLyBnZW5lcmF0ZSByYW5kb20gYnl0ZXMgT1IgcGFzcyBhcy1pc1xuICAgICAgICAgICAgc2VlZEFyZ3MucHVzaChlbnN1cmVCeXRlcygnZXh0cmFFbnRyb3B5JywgZSkpOyAvLyBjaGVjayBmb3IgYmVpbmcgYnl0ZXNcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWVkID0gdXQuY29uY2F0Qnl0ZXMoLi4uc2VlZEFyZ3MpOyAvLyBTdGVwIEQgb2YgUkZDNjk3OSAzLjJcbiAgICAgICAgY29uc3QgbSA9IGgxaW50OyAvLyBOT1RFOiBubyBuZWVkIHRvIGNhbGwgYml0czJpbnQgc2Vjb25kIHRpbWUgaGVyZSwgaXQgaXMgaW5zaWRlIHRydW5jYXRlSGFzaCFcbiAgICAgICAgLy8gQ29udmVydHMgc2lnbmF0dXJlIHBhcmFtcyBpbnRvIHBvaW50IHcgci9zLCBjaGVja3MgcmVzdWx0IGZvciB2YWxpZGl0eS5cbiAgICAgICAgZnVuY3Rpb24gazJzaWcoa0J5dGVzKSB7XG4gICAgICAgICAgICAvLyBSRkMgNjk3OSBTZWN0aW9uIDMuMiwgc3RlcCAzOiBrID0gYml0czJpbnQoVClcbiAgICAgICAgICAgIGNvbnN0IGsgPSBiaXRzMmludChrQnl0ZXMpOyAvLyBDYW5ub3QgdXNlIGZpZWxkcyBtZXRob2RzLCBzaW5jZSBpdCBpcyBncm91cCBlbGVtZW50XG4gICAgICAgICAgICBpZiAoIWlzV2l0aGluQ3VydmVPcmRlcihrKSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIEltcG9ydGFudDogYWxsIG1vZCgpIGNhbGxzIGhlcmUgbXVzdCBiZSBkb25lIG92ZXIgTlxuICAgICAgICAgICAgY29uc3QgaWsgPSBpbnZOKGspOyAvLyBrXi0xIG1vZCBuXG4gICAgICAgICAgICBjb25zdCBxID0gUG9pbnQuQkFTRS5tdWx0aXBseShrKS50b0FmZmluZSgpOyAvLyBxID0gR2tcbiAgICAgICAgICAgIGNvbnN0IHIgPSBtb2ROKHEueCk7IC8vIHIgPSBxLnggbW9kIG5cbiAgICAgICAgICAgIGlmIChyID09PSBfMG4pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gQ2FuIHVzZSBzY2FsYXIgYmxpbmRpbmcgYl4tMShibSArIGJkcikgd2hlcmUgYiDiiIggWzEsceKIkjFdIGFjY29yZGluZyB0b1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly90Y2hlcy5pYWNyLm9yZy9pbmRleC5waHAvVENIRVMvYXJ0aWNsZS92aWV3LzczMzcvNjUwOS4gV2UndmUgZGVjaWRlZCBhZ2FpbnN0IGl0OlxuICAgICAgICAgICAgLy8gYSkgZGVwZW5kZW5jeSBvbiBDU1BSTkcgYikgMTUlIHNsb3dkb3duIGMpIGRvZXNuJ3QgcmVhbGx5IGhlbHAgc2luY2UgYmlnaW50cyBhcmUgbm90IENUXG4gICAgICAgICAgICBjb25zdCBzID0gbW9kTihpayAqIG1vZE4obSArIHIgKiBkKSk7IC8vIE5vdCB1c2luZyBibGluZGluZyBoZXJlXG4gICAgICAgICAgICBpZiAocyA9PT0gXzBuKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCByZWNvdmVyeSA9IChxLnggPT09IHIgPyAwIDogMikgfCBOdW1iZXIocS55ICYgXzFuKTsgLy8gcmVjb3ZlcnkgYml0ICgyIG9yIDMsIHdoZW4gcS54ID4gbilcbiAgICAgICAgICAgIGxldCBub3JtUyA9IHM7XG4gICAgICAgICAgICBpZiAobG93UyAmJiBpc0JpZ2dlclRoYW5IYWxmT3JkZXIocykpIHtcbiAgICAgICAgICAgICAgICBub3JtUyA9IG5vcm1hbGl6ZVMocyk7IC8vIGlmIGxvd1Mgd2FzIHBhc3NlZCwgZW5zdXJlIHMgaXMgYWx3YXlzXG4gICAgICAgICAgICAgICAgcmVjb3ZlcnkgXj0gMTsgLy8gLy8gaW4gdGhlIGJvdHRvbSBoYWxmIG9mIE5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgU2lnbmF0dXJlKHIsIG5vcm1TLCByZWNvdmVyeSk7IC8vIHVzZSBub3JtUywgbm90IHNcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzZWVkLCBrMnNpZyB9O1xuICAgIH1cbiAgICBjb25zdCBkZWZhdWx0U2lnT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICBjb25zdCBkZWZhdWx0VmVyT3B0cyA9IHsgbG93UzogQ1VSVkUubG93UywgcHJlaGFzaDogZmFsc2UgfTtcbiAgICAvKipcbiAgICAgKiBTaWducyBtZXNzYWdlIGhhc2ggd2l0aCBhIHByaXZhdGUga2V5LlxuICAgICAqIGBgYFxuICAgICAqIHNpZ24obSwgZCwgaykgd2hlcmVcbiAgICAgKiAgICh4LCB5KSA9IEcgw5cga1xuICAgICAqICAgciA9IHggbW9kIG5cbiAgICAgKiAgIHMgPSAobSArIGRyKS9rIG1vZCBuXG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIG1zZ0hhc2ggTk9UIG1lc3NhZ2UuIG1zZyBuZWVkcyB0byBiZSBoYXNoZWQgdG8gYG1zZ0hhc2hgLCBvciB1c2UgYHByZWhhc2hgLlxuICAgICAqIEBwYXJhbSBwcml2S2V5IHByaXZhdGUga2V5XG4gICAgICogQHBhcmFtIG9wdHMgbG93UyBmb3Igbm9uLW1hbGxlYWJsZSBzaWdzLiBleHRyYUVudHJvcHkgZm9yIG1peGluZyByYW5kb21uZXNzIGludG8gay4gcHJlaGFzaCB3aWxsIGhhc2ggZmlyc3QgYXJnLlxuICAgICAqIEByZXR1cm5zIHNpZ25hdHVyZSB3aXRoIHJlY292ZXJ5IHBhcmFtXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2lnbihtc2dIYXNoLCBwcml2S2V5LCBvcHRzID0gZGVmYXVsdFNpZ09wdHMpIHtcbiAgICAgICAgY29uc3QgeyBzZWVkLCBrMnNpZyB9ID0gcHJlcFNpZyhtc2dIYXNoLCBwcml2S2V5LCBvcHRzKTsgLy8gU3RlcHMgQSwgRCBvZiBSRkM2OTc5IDMuMi5cbiAgICAgICAgY29uc3QgQyA9IENVUlZFO1xuICAgICAgICBjb25zdCBkcmJnID0gdXQuY3JlYXRlSG1hY0RyYmcoQy5oYXNoLm91dHB1dExlbiwgQy5uQnl0ZUxlbmd0aCwgQy5obWFjKTtcbiAgICAgICAgcmV0dXJuIGRyYmcoc2VlZCwgazJzaWcpOyAvLyBTdGVwcyBCLCBDLCBELCBFLCBGLCBHXG4gICAgfVxuICAgIC8vIEVuYWJsZSBwcmVjb21wdXRlcy4gU2xvd3MgZG93biBmaXJzdCBwdWJsaWNLZXkgY29tcHV0YXRpb24gYnkgMjBtcy5cbiAgICBQb2ludC5CQVNFLl9zZXRXaW5kb3dTaXplKDgpO1xuICAgIC8vIHV0aWxzLnByZWNvbXB1dGUoOCwgUHJvamVjdGl2ZVBvaW50LkJBU0UpXG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSBzaWduYXR1cmUgYWdhaW5zdCBtZXNzYWdlIGhhc2ggYW5kIHB1YmxpYyBrZXkuXG4gICAgICogUmVqZWN0cyBsb3dTIHNpZ25hdHVyZXMgYnkgZGVmYXVsdDogdG8gb3ZlcnJpZGUsXG4gICAgICogc3BlY2lmeSBvcHRpb24gYHtsb3dTOiBmYWxzZX1gLiBJbXBsZW1lbnRzIHNlY3Rpb24gNC4xLjQgZnJvbSBodHRwczovL3d3dy5zZWNnLm9yZy9zZWMxLXYyLnBkZjpcbiAgICAgKlxuICAgICAqIGBgYFxuICAgICAqIHZlcmlmeShyLCBzLCBoLCBQKSB3aGVyZVxuICAgICAqICAgVTEgPSBoc14tMSBtb2QgblxuICAgICAqICAgVTIgPSByc14tMSBtb2QgblxuICAgICAqICAgUiA9IFUx4ouFRyAtIFUy4ouFUFxuICAgICAqICAgbW9kKFIueCwgbikgPT0gclxuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHZlcmlmeShzaWduYXR1cmUsIG1zZ0hhc2gsIHB1YmxpY0tleSwgb3B0cyA9IGRlZmF1bHRWZXJPcHRzKSB7XG4gICAgICAgIGNvbnN0IHNnID0gc2lnbmF0dXJlO1xuICAgICAgICBtc2dIYXNoID0gZW5zdXJlQnl0ZXMoJ21zZ0hhc2gnLCBtc2dIYXNoKTtcbiAgICAgICAgcHVibGljS2V5ID0gZW5zdXJlQnl0ZXMoJ3B1YmxpY0tleScsIHB1YmxpY0tleSk7XG4gICAgICAgIGlmICgnc3RyaWN0JyBpbiBvcHRzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLnN0cmljdCB3YXMgcmVuYW1lZCB0byBsb3dTJyk7XG4gICAgICAgIGNvbnN0IHsgbG93UywgcHJlaGFzaCB9ID0gb3B0cztcbiAgICAgICAgbGV0IF9zaWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBQO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzZyA9PT0gJ3N0cmluZycgfHwgdXQuaXNCeXRlcyhzZykpIHtcbiAgICAgICAgICAgICAgICAvLyBTaWduYXR1cmUgY2FuIGJlIHJlcHJlc2VudGVkIGluIDIgd2F5czogY29tcGFjdCAoMipuQnl0ZUxlbmd0aCkgJiBERVIgKHZhcmlhYmxlLWxlbmd0aCkuXG4gICAgICAgICAgICAgICAgLy8gU2luY2UgREVSIGNhbiBhbHNvIGJlIDIqbkJ5dGVMZW5ndGggYnl0ZXMsIHdlIGNoZWNrIGZvciBpdCBmaXJzdC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21ERVIoc2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZGVyRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZGVyRXJyb3IgaW5zdGFuY2VvZiBERVIuRXJyKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGRlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICBfc2lnID0gU2lnbmF0dXJlLmZyb21Db21wYWN0KHNnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc2cgPT09ICdvYmplY3QnICYmIHR5cGVvZiBzZy5yID09PSAnYmlnaW50JyAmJiB0eXBlb2Ygc2cucyA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHIsIHMgfSA9IHNnO1xuICAgICAgICAgICAgICAgIF9zaWcgPSBuZXcgU2lnbmF0dXJlKHIsIHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQQVJTRScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUCA9IFBvaW50LmZyb21IZXgocHVibGljS2V5KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvci5tZXNzYWdlID09PSAnUEFSU0UnKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgc2lnbmF0dXJlIG11c3QgYmUgU2lnbmF0dXJlIGluc3RhbmNlLCBVaW50OEFycmF5IG9yIGhleCBzdHJpbmdgKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG93UyAmJiBfc2lnLmhhc0hpZ2hTKCkpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChwcmVoYXNoKVxuICAgICAgICAgICAgbXNnSGFzaCA9IENVUlZFLmhhc2gobXNnSGFzaCk7XG4gICAgICAgIGNvbnN0IHsgciwgcyB9ID0gX3NpZztcbiAgICAgICAgY29uc3QgaCA9IGJpdHMyaW50X21vZE4obXNnSGFzaCk7IC8vIENhbm5vdCB1c2UgZmllbGRzIG1ldGhvZHMsIHNpbmNlIGl0IGlzIGdyb3VwIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaXMgPSBpbnZOKHMpOyAvLyBzXi0xXG4gICAgICAgIGNvbnN0IHUxID0gbW9kTihoICogaXMpOyAvLyB1MSA9IGhzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IHUyID0gbW9kTihyICogaXMpOyAvLyB1MiA9IHJzXi0xIG1vZCBuXG4gICAgICAgIGNvbnN0IFIgPSBQb2ludC5CQVNFLm11bHRpcGx5QW5kQWRkVW5zYWZlKFAsIHUxLCB1Mik/LnRvQWZmaW5lKCk7IC8vIFIgPSB1MeKLhUcgKyB1MuKLhVBcbiAgICAgICAgaWYgKCFSKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB2ID0gbW9kTihSLngpO1xuICAgICAgICByZXR1cm4gdiA9PT0gcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgQ1VSVkUsXG4gICAgICAgIGdldFB1YmxpY0tleSxcbiAgICAgICAgZ2V0U2hhcmVkU2VjcmV0LFxuICAgICAgICBzaWduLFxuICAgICAgICB2ZXJpZnksXG4gICAgICAgIFByb2plY3RpdmVQb2ludDogUG9pbnQsXG4gICAgICAgIFNpZ25hdHVyZSxcbiAgICAgICAgdXRpbHMsXG4gICAgfTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFNoYWxsdWUgYW5kIHZhbiBkZSBXb2VzdGlqbmUgbWV0aG9kIGZvciBhbnkgd2VpZXJzdHJhc3MgY3VydmUuXG4gKiBUT0RPOiBjaGVjayBpZiB0aGVyZSBpcyBhIHdheSB0byBtZXJnZSB0aGlzIHdpdGggdXZSYXRpbyBpbiBFZHdhcmRzOyBtb3ZlIHRvIG1vZHVsYXIuXG4gKiBiID0gVHJ1ZSBhbmQgeSA9IHNxcnQodSAvIHYpIGlmICh1IC8gdikgaXMgc3F1YXJlIGluIEYsIGFuZFxuICogYiA9IEZhbHNlIGFuZCB5ID0gc3FydChaICogKHUgLyB2KSkgb3RoZXJ3aXNlLlxuICogQHBhcmFtIEZwXG4gKiBAcGFyYW0gWlxuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIFNXVUZwU3FydFJhdGlvKEZwLCBaKSB7XG4gICAgLy8gR2VuZXJpYyBpbXBsZW1lbnRhdGlvblxuICAgIGNvbnN0IHEgPSBGcC5PUkRFUjtcbiAgICBsZXQgbCA9IF8wbjtcbiAgICBmb3IgKGxldCBvID0gcSAtIF8xbjsgbyAlIF8ybiA9PT0gXzBuOyBvIC89IF8ybilcbiAgICAgICAgbCArPSBfMW47XG4gICAgY29uc3QgYzEgPSBsOyAvLyAxLiBjMSwgdGhlIGxhcmdlc3QgaW50ZWdlciBzdWNoIHRoYXQgMl5jMSBkaXZpZGVzIHEgLSAxLlxuICAgIC8vIFdlIG5lZWQgMm4gKiogYzEgYW5kIDJuICoqIChjMS0xKS4gV2UgY2FuJ3QgdXNlICoqOyBidXQgd2UgY2FuIHVzZSA8PC5cbiAgICAvLyAybiAqKiBjMSA9PSAybiA8PCAoYzEtMSlcbiAgICBjb25zdCBfMm5fcG93X2MxXzEgPSBfMm4gPDwgKGMxIC0gXzFuIC0gXzFuKTtcbiAgICBjb25zdCBfMm5fcG93X2MxID0gXzJuX3Bvd19jMV8xICogXzJuO1xuICAgIGNvbnN0IGMyID0gKHEgLSBfMW4pIC8gXzJuX3Bvd19jMTsgLy8gMi4gYzIgPSAocSAtIDEpIC8gKDJeYzEpICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGMzID0gKGMyIC0gXzFuKSAvIF8ybjsgLy8gMy4gYzMgPSAoYzIgLSAxKSAvIDIgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM0ID0gXzJuX3Bvd19jMSAtIF8xbjsgLy8gNC4gYzQgPSAyXmMxIC0gMSAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM1ID0gXzJuX3Bvd19jMV8xOyAvLyA1LiBjNSA9IDJeKGMxIC0gMSkgICAgICAgICAgICAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgIGNvbnN0IGM2ID0gRnAucG93KFosIGMyKTsgLy8gNi4gYzYgPSBaXmMyXG4gICAgY29uc3QgYzcgPSBGcC5wb3coWiwgKGMyICsgXzFuKSAvIF8ybik7IC8vIDcuIGM3ID0gWl4oKGMyICsgMSkgLyAyKVxuICAgIGxldCBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICBsZXQgdHYxID0gYzY7IC8vIDEuIHR2MSA9IGM2XG4gICAgICAgIGxldCB0djIgPSBGcC5wb3codiwgYzQpOyAvLyAyLiB0djIgPSB2XmM0XG4gICAgICAgIGxldCB0djMgPSBGcC5zcXIodHYyKTsgLy8gMy4gdHYzID0gdHYyXjJcbiAgICAgICAgdHYzID0gRnAubXVsKHR2Mywgdik7IC8vIDQuIHR2MyA9IHR2MyAqIHZcbiAgICAgICAgbGV0IHR2NSA9IEZwLm11bCh1LCB0djMpOyAvLyA1LiB0djUgPSB1ICogdHYzXG4gICAgICAgIHR2NSA9IEZwLnBvdyh0djUsIGMzKTsgLy8gNi4gdHY1ID0gdHY1XmMzXG4gICAgICAgIHR2NSA9IEZwLm11bCh0djUsIHR2Mik7IC8vIDcuIHR2NSA9IHR2NSAqIHR2MlxuICAgICAgICB0djIgPSBGcC5tdWwodHY1LCB2KTsgLy8gOC4gdHYyID0gdHY1ICogdlxuICAgICAgICB0djMgPSBGcC5tdWwodHY1LCB1KTsgLy8gOS4gdHYzID0gdHY1ICogdVxuICAgICAgICBsZXQgdHY0ID0gRnAubXVsKHR2MywgdHYyKTsgLy8gMTAuIHR2NCA9IHR2MyAqIHR2MlxuICAgICAgICB0djUgPSBGcC5wb3codHY0LCBjNSk7IC8vIDExLiB0djUgPSB0djReYzVcbiAgICAgICAgbGV0IGlzUVIgPSBGcC5lcWwodHY1LCBGcC5PTkUpOyAvLyAxMi4gaXNRUiA9IHR2NSA9PSAxXG4gICAgICAgIHR2MiA9IEZwLm11bCh0djMsIGM3KTsgLy8gMTMuIHR2MiA9IHR2MyAqIGM3XG4gICAgICAgIHR2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDE0LiB0djUgPSB0djQgKiB0djFcbiAgICAgICAgdHYzID0gRnAuY21vdih0djIsIHR2MywgaXNRUik7IC8vIDE1LiB0djMgPSBDTU9WKHR2MiwgdHYzLCBpc1FSKVxuICAgICAgICB0djQgPSBGcC5jbW92KHR2NSwgdHY0LCBpc1FSKTsgLy8gMTYuIHR2NCA9IENNT1YodHY1LCB0djQsIGlzUVIpXG4gICAgICAgIC8vIDE3LiBmb3IgaSBpbiAoYzEsIGMxIC0gMSwgLi4uLCAyKTpcbiAgICAgICAgZm9yIChsZXQgaSA9IGMxOyBpID4gXzFuOyBpLS0pIHtcbiAgICAgICAgICAgIGxldCB0djUgPSBpIC0gXzJuOyAvLyAxOC4gICAgdHY1ID0gaSAtIDJcbiAgICAgICAgICAgIHR2NSA9IF8ybiA8PCAodHY1IC0gXzFuKTsgLy8gMTkuICAgIHR2NSA9IDJedHY1XG4gICAgICAgICAgICBsZXQgdHZ2NSA9IEZwLnBvdyh0djQsIHR2NSk7IC8vIDIwLiAgICB0djUgPSB0djRedHY1XG4gICAgICAgICAgICBjb25zdCBlMSA9IEZwLmVxbCh0dnY1LCBGcC5PTkUpOyAvLyAyMS4gICAgZTEgPSB0djUgPT0gMVxuICAgICAgICAgICAgdHYyID0gRnAubXVsKHR2MywgdHYxKTsgLy8gMjIuICAgIHR2MiA9IHR2MyAqIHR2MVxuICAgICAgICAgICAgdHYxID0gRnAubXVsKHR2MSwgdHYxKTsgLy8gMjMuICAgIHR2MSA9IHR2MSAqIHR2MVxuICAgICAgICAgICAgdHZ2NSA9IEZwLm11bCh0djQsIHR2MSk7IC8vIDI0LiAgICB0djUgPSB0djQgKiB0djFcbiAgICAgICAgICAgIHR2MyA9IEZwLmNtb3YodHYyLCB0djMsIGUxKTsgLy8gMjUuICAgIHR2MyA9IENNT1YodHYyLCB0djMsIGUxKVxuICAgICAgICAgICAgdHY0ID0gRnAuY21vdih0dnY1LCB0djQsIGUxKTsgLy8gMjYuICAgIHR2NCA9IENNT1YodHY1LCB0djQsIGUxKVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGlzVmFsaWQ6IGlzUVIsIHZhbHVlOiB0djMgfTtcbiAgICB9O1xuICAgIGlmIChGcC5PUkRFUiAlIF80biA9PT0gXzNuKSB7XG4gICAgICAgIC8vIHNxcnRfcmF0aW9fM21vZDQodSwgdilcbiAgICAgICAgY29uc3QgYzEgPSAoRnAuT1JERVIgLSBfM24pIC8gXzRuOyAvLyAxLiBjMSA9IChxIC0gMykgLyA0ICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuICAgICAgICBjb25zdCBjMiA9IEZwLnNxcnQoRnAubmVnKFopKTsgLy8gMi4gYzIgPSBzcXJ0KC1aKVxuICAgICAgICBzcXJ0UmF0aW8gPSAodSwgdikgPT4ge1xuICAgICAgICAgICAgbGV0IHR2MSA9IEZwLnNxcih2KTsgLy8gMS4gdHYxID0gdl4yXG4gICAgICAgICAgICBjb25zdCB0djIgPSBGcC5tdWwodSwgdik7IC8vIDIuIHR2MiA9IHUgKiB2XG4gICAgICAgICAgICB0djEgPSBGcC5tdWwodHYxLCB0djIpOyAvLyAzLiB0djEgPSB0djEgKiB0djJcbiAgICAgICAgICAgIGxldCB5MSA9IEZwLnBvdyh0djEsIGMxKTsgLy8gNC4geTEgPSB0djFeYzFcbiAgICAgICAgICAgIHkxID0gRnAubXVsKHkxLCB0djIpOyAvLyA1LiB5MSA9IHkxICogdHYyXG4gICAgICAgICAgICBjb25zdCB5MiA9IEZwLm11bCh5MSwgYzIpOyAvLyA2LiB5MiA9IHkxICogYzJcbiAgICAgICAgICAgIGNvbnN0IHR2MyA9IEZwLm11bChGcC5zcXIoeTEpLCB2KTsgLy8gNy4gdHYzID0geTFeMjsgOC4gdHYzID0gdHYzICogdlxuICAgICAgICAgICAgY29uc3QgaXNRUiA9IEZwLmVxbCh0djMsIHUpOyAvLyA5LiBpc1FSID0gdHYzID09IHVcbiAgICAgICAgICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGlzUVIpOyAvLyAxMC4geSA9IENNT1YoeTIsIHkxLCBpc1FSKVxuICAgICAgICAgICAgcmV0dXJuIHsgaXNWYWxpZDogaXNRUiwgdmFsdWU6IHkgfTsgLy8gMTEuIHJldHVybiAoaXNRUiwgeSkgaXNRUiA/IHkgOiB5KmMyXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIE5vIGN1cnZlcyB1c2VzIHRoYXRcbiAgICAvLyBpZiAoRnAuT1JERVIgJSBfOG4gPT09IF81bikgLy8gc3FydF9yYXRpb181bW9kOFxuICAgIHJldHVybiBzcXJ0UmF0aW87XG59XG4vKipcbiAqIFNpbXBsaWZpZWQgU2hhbGx1ZS12YW4gZGUgV29lc3Rpam5lLVVsYXMgTWV0aG9kXG4gKiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNzZWN0aW9uLTYuNi4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBUb0N1cnZlU2ltcGxlU1dVKEZwLCBvcHRzKSB7XG4gICAgbW9kLnZhbGlkYXRlRmllbGQoRnApO1xuICAgIGlmICghRnAuaXNWYWxpZChvcHRzLkEpIHx8ICFGcC5pc1ZhbGlkKG9wdHMuQikgfHwgIUZwLmlzVmFsaWQob3B0cy5aKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtYXBUb0N1cnZlU2ltcGxlU1dVOiBpbnZhbGlkIG9wdHMnKTtcbiAgICBjb25zdCBzcXJ0UmF0aW8gPSBTV1VGcFNxcnRSYXRpbyhGcCwgb3B0cy5aKTtcbiAgICBpZiAoIUZwLmlzT2RkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZwLmlzT2RkIGlzIG5vdCBpbXBsZW1lbnRlZCEnKTtcbiAgICAvLyBJbnB1dDogdSwgYW4gZWxlbWVudCBvZiBGLlxuICAgIC8vIE91dHB1dDogKHgsIHkpLCBhIHBvaW50IG9uIEUuXG4gICAgcmV0dXJuICh1KSA9PiB7XG4gICAgICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgICAgICBsZXQgdHYxLCB0djIsIHR2MywgdHY0LCB0djUsIHR2NiwgeCwgeTtcbiAgICAgICAgdHYxID0gRnAuc3FyKHUpOyAvLyAxLiAgdHYxID0gdV4yXG4gICAgICAgIHR2MSA9IEZwLm11bCh0djEsIG9wdHMuWik7IC8vIDIuICB0djEgPSBaICogdHYxXG4gICAgICAgIHR2MiA9IEZwLnNxcih0djEpOyAvLyAzLiAgdHYyID0gdHYxXjJcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHYxKTsgLy8gNC4gIHR2MiA9IHR2MiArIHR2MVxuICAgICAgICB0djMgPSBGcC5hZGQodHYyLCBGcC5PTkUpOyAvLyA1LiAgdHYzID0gdHYyICsgMVxuICAgICAgICB0djMgPSBGcC5tdWwodHYzLCBvcHRzLkIpOyAvLyA2LiAgdHYzID0gQiAqIHR2M1xuICAgICAgICB0djQgPSBGcC5jbW92KG9wdHMuWiwgRnAubmVnKHR2MiksICFGcC5lcWwodHYyLCBGcC5aRVJPKSk7IC8vIDcuICB0djQgPSBDTU9WKFosIC10djIsIHR2MiAhPSAwKVxuICAgICAgICB0djQgPSBGcC5tdWwodHY0LCBvcHRzLkEpOyAvLyA4LiAgdHY0ID0gQSAqIHR2NFxuICAgICAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gOS4gIHR2MiA9IHR2M14yXG4gICAgICAgIHR2NiA9IEZwLnNxcih0djQpOyAvLyAxMC4gdHY2ID0gdHY0XjJcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5BKTsgLy8gMTEuIHR2NSA9IEEgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTIuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB0djIgPSBGcC5tdWwodHYyLCB0djMpOyAvLyAxMy4gdHYyID0gdHYyICogdHYzXG4gICAgICAgIHR2NiA9IEZwLm11bCh0djYsIHR2NCk7IC8vIDE0LiB0djYgPSB0djYgKiB0djRcbiAgICAgICAgdHY1ID0gRnAubXVsKHR2Niwgb3B0cy5CKTsgLy8gMTUuIHR2NSA9IEIgKiB0djZcbiAgICAgICAgdHYyID0gRnAuYWRkKHR2MiwgdHY1KTsgLy8gMTYuIHR2MiA9IHR2MiArIHR2NVxuICAgICAgICB4ID0gRnAubXVsKHR2MSwgdHYzKTsgLy8gMTcuICAgeCA9IHR2MSAqIHR2M1xuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlIH0gPSBzcXJ0UmF0aW8odHYyLCB0djYpOyAvLyAxOC4gKGlzX2d4MV9zcXVhcmUsIHkxKSA9IHNxcnRfcmF0aW8odHYyLCB0djYpXG4gICAgICAgIHkgPSBGcC5tdWwodHYxLCB1KTsgLy8gMTkuICAgeSA9IHR2MSAqIHUgIC0+IFogKiB1XjMgKiB5MVxuICAgICAgICB5ID0gRnAubXVsKHksIHZhbHVlKTsgLy8gMjAuICAgeSA9IHkgKiB5MVxuICAgICAgICB4ID0gRnAuY21vdih4LCB0djMsIGlzVmFsaWQpOyAvLyAyMS4gICB4ID0gQ01PVih4LCB0djMsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIHkgPSBGcC5jbW92KHksIHZhbHVlLCBpc1ZhbGlkKTsgLy8gMjIuICAgeSA9IENNT1YoeSwgeTEsIGlzX2d4MV9zcXVhcmUpXG4gICAgICAgIGNvbnN0IGUxID0gRnAuaXNPZGQodSkgPT09IEZwLmlzT2RkKHkpOyAvLyAyMy4gIGUxID0gc2duMCh1KSA9PSBzZ24wKHkpXG4gICAgICAgIHkgPSBGcC5jbW92KEZwLm5lZyh5KSwgeSwgZTEpOyAvLyAyNC4gICB5ID0gQ01PVigteSwgeSwgZTEpXG4gICAgICAgIHggPSBGcC5kaXYoeCwgdHY0KTsgLy8gMjUuICAgeCA9IHggLyB0djRcbiAgICAgICAgcmV0dXJuIHsgeCwgeSB9O1xuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWllcnN0cmFzcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/ed25519.js":
/*!***************************************************!*\
  !*** ./node_modules/@noble/curves/esm/ed25519.js ***!
  \***************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ED25519_TORSION_SUBGROUP: function() { return /* binding */ ED25519_TORSION_SUBGROUP; },\n/* harmony export */   RistrettoPoint: function() { return /* binding */ RistrettoPoint; },\n/* harmony export */   ed25519: function() { return /* binding */ ed25519; },\n/* harmony export */   ed25519ctx: function() { return /* binding */ ed25519ctx; },\n/* harmony export */   ed25519ph: function() { return /* binding */ ed25519ph; },\n/* harmony export */   edwardsToMontgomery: function() { return /* binding */ edwardsToMontgomery; },\n/* harmony export */   edwardsToMontgomeryPriv: function() { return /* binding */ edwardsToMontgomeryPriv; },\n/* harmony export */   edwardsToMontgomeryPub: function() { return /* binding */ edwardsToMontgomeryPub; },\n/* harmony export */   encodeToCurve: function() { return /* binding */ encodeToCurve; },\n/* harmony export */   hashToCurve: function() { return /* binding */ hashToCurve; },\n/* harmony export */   hashToRistretto255: function() { return /* binding */ hashToRistretto255; },\n/* harmony export */   hash_to_ristretto255: function() { return /* binding */ hash_to_ristretto255; },\n/* harmony export */   x25519: function() { return /* binding */ x25519; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/sha512 */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha512.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/edwards.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/edwards.js\");\n/* harmony import */ var _abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./abstract/montgomery.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/montgomery.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\n/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n */\nconst ED25519_P = BigInt('57896044618658097711785492504343953926634992332820282019728792003956564819949');\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst ED25519_SQRT_M1 = BigInt('19681161376707505956807079304988542015446066515923890162744021073123829784752');\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _5n = BigInt(5);\n// prettier-ignore\nconst _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\nfunction ed25519_pow_2_252_3(x) {\n    const P = ED25519_P;\n    const x2 = (x * x) % P;\n    const b2 = (x2 * x) % P; // x^3, 11\n    const b4 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b2, _2n, P) * b2) % P; // x^15, 1111\n    const b5 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b4, _1n, P) * x) % P; // x^31\n    const b10 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b5, _5n, P) * b5) % P;\n    const b20 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b10, _10n, P) * b10) % P;\n    const b40 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b20, _20n, P) * b20) % P;\n    const b80 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b40, _40n, P) * b40) % P;\n    const b160 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b80, _80n, P) * b80) % P;\n    const b240 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b160, _80n, P) * b80) % P;\n    const b250 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b240, _10n, P) * b10) % P;\n    const pow_p_5_8 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b250, _2n, P) * x) % P;\n    // ^ To pow to (p+3)/8, multiply it by x.\n    return { pow_p_5_8, b2 };\n}\nfunction adjustScalarBytes(bytes) {\n    // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n    // set the three least significant bits of the first byte\n    bytes[0] &= 248; // 0b1111_1000\n    // and the most significant bit of the last to zero,\n    bytes[31] &= 127; // 0b0111_1111\n    // set the second most significant bit of the last byte to 1\n    bytes[31] |= 64; // 0b0100_0000\n    return bytes;\n}\n// sqrt(u/v)\nfunction uvRatio(u, v) {\n    const P = ED25519_P;\n    const v3 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * v * v, P); // v³\n    const v7 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v3 * v3 * v, P); // v⁷\n    // (p+3)/8 and (p-5)/8\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(u * v3 * pow, P); // (uv³)(uv⁷)^(p-5)/8\n    const vx2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(v * x * x, P); // vx²\n    const root1 = x; // First root candidate\n    const root2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x * ED25519_SQRT_M1, P); // Second root candidate\n    const useRoot1 = vx2 === u; // If vx² = u (mod p), x is a square root\n    const useRoot2 = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u, P); // If vx² = -u, set x <-- x * 2^((p-1)/4)\n    const noRoot = vx2 === (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-u * ED25519_SQRT_M1, P); // There is no valid root, vx² = -u√(-1)\n    if (useRoot1)\n        x = root1;\n    if (useRoot2 || noRoot)\n        x = root2; // We return root2 anyway, for const-time\n    if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P))\n        x = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-x, P);\n    return { isValid: useRoot1 || useRoot2, value: x };\n}\n// Just in case\nconst ED25519_TORSION_SUBGROUP = [\n    '0100000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n    '0000000000000000000000000000000000000000000000000000000000000080',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n    'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n    '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n    '0000000000000000000000000000000000000000000000000000000000000000',\n    'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(ED25519_P, undefined, true);\nconst ed25519Defaults = {\n    // Param: a\n    a: BigInt(-1), // Fp.create(-1) is proper; our way still works and is faster\n    // d is equal to -121665/121666 over finite field.\n    // Negative number is P - number, and division is invert(number, P)\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n\n    Fp,\n    // Subgroup order: how many points curve has\n    // 2n**252n + 27742317777372353535851937790883648493n;\n    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n    // Cofactor\n    h: BigInt(8),\n    // Base point (x, y) aka generator point\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n    hash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,\n    randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.randomBytes,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/√v\n    uvRatio,\n};\nconst ed25519 = /* @__PURE__ */ (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)(ed25519Defaults);\nfunction ed25519_domain(data, ctx, phflag) {\n    if (ctx.length > 255)\n        throw new Error('Context is too big');\n    return (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.concatBytes)((0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.utf8ToBytes)('SigEd25519 no Ed25519 collisions'), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);\n}\nconst ed25519ctx = /* @__PURE__ */ (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n});\nconst ed25519ph = /* @__PURE__ */ (0,_abstract_edwards_js__WEBPACK_IMPORTED_MODULE_3__.twistedEdwards)({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n    prehash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,\n});\nconst x25519 = /* @__PURE__ */ (() => (0,_abstract_montgomery_js__WEBPACK_IMPORTED_MODULE_4__.montgomery)({\n    P: ED25519_P,\n    a: BigInt(486662),\n    montgomeryBits: 255, // n is 253 bits\n    nByteLength: 32,\n    Gu: BigInt(9),\n    powPminus2: (x) => {\n        const P = ED25519_P;\n        // x^(p-2) aka x^(2^255-21)\n        const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n        return (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(pow_p_5_8, BigInt(3), P) * b2, P);\n    },\n    adjustScalarBytes,\n    randomBytes: _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.randomBytes,\n}))();\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nfunction edwardsToMontgomeryPub(edwardsPub) {\n    const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n    const _1n = BigInt(1);\n    return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nconst edwardsToMontgomery = edwardsToMontgomeryPub; // deprecated\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nfunction edwardsToMontgomeryPriv(edwardsPriv) {\n    const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n    return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = (Fp.ORDER + BigInt(3)) / BigInt(8); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = Fp.pow(_2n, ELL2_C1); // 2. c2 = 2^c1\nconst ELL2_C3 = Fp.sqrt(Fp.neg(Fp.ONE)); // 3. c3 = sqrt(-1)\nconst ELL2_C4 = (Fp.ORDER - BigInt(5)) / BigInt(8); // 4. c4 = (q - 5) / 8       # Integer arithmetic\nconst ELL2_J = BigInt(486662);\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u) {\n    let tv1 = Fp.sqr(u); //  1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, _2n); //  2.  tv1 = 2 * tv1\n    let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n    let x1n = Fp.neg(ELL2_J); //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n    let tv2 = Fp.sqr(xd); //  5.  tv2 = xd^2\n    let gxd = Fp.mul(tv2, xd); //  6.  gxd = tv2 * xd        # gxd = xd^3\n    let gx1 = Fp.mul(tv1, ELL2_J); //  7.  gx1 = J * tv1         # x1n + J * xd\n    gx1 = Fp.mul(gx1, x1n); //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n    gx1 = Fp.add(gx1, tv2); //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n    gx1 = Fp.mul(gx1, x1n); //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n    let tv3 = Fp.sqr(gxd); //  11. tv3 = gxd^2\n    tv2 = Fp.sqr(tv3); //  12. tv2 = tv3^2           # gxd^4\n    tv3 = Fp.mul(tv3, gxd); //  13. tv3 = tv3 * gxd       # gxd^3\n    tv3 = Fp.mul(tv3, gx1); //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n    tv2 = Fp.mul(tv2, tv3); //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n    let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n    y11 = Fp.mul(y11, tv3); //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n    let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n    tv2 = Fp.sqr(y11); //  19. tv2 = y11^2\n    tv2 = Fp.mul(tv2, gxd); //  20. tv2 = tv2 * gxd\n    let e1 = Fp.eql(tv2, gx1); //  21.  e1 = tv2 == gx1\n    let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n    let x2n = Fp.mul(x1n, tv1); //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n    let y21 = Fp.mul(y11, u); //  24. y21 = y11 * u\n    y21 = Fp.mul(y21, ELL2_C2); //  25. y21 = y21 * c2\n    let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n    let gx2 = Fp.mul(gx1, tv1); //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n    tv2 = Fp.sqr(y21); //  28. tv2 = y21^2\n    tv2 = Fp.mul(tv2, gxd); //  29. tv2 = tv2 * gxd\n    let e2 = Fp.eql(tv2, gx2); //  30.  e2 = tv2 == gx2\n    let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n    tv2 = Fp.sqr(y1); //  32. tv2 = y1^2\n    tv2 = Fp.mul(tv2, gxd); //  33. tv2 = tv2 * gxd\n    let e3 = Fp.eql(tv2, gx1); //  34.  e3 = tv2 == gx1\n    let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n    let y = Fp.cmov(y2, y1, e3); //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n    let e4 = Fp.isOdd(y); //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n    y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n    return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\nconst ELL2_C1_EDWARDS = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u) {\n    const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n    // map_to_curve_elligator2_curve25519(u)\n    let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n    xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n    let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n    let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n    let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n    let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n    let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n    xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n    xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n    yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n    yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n    const inv = Fp.invertBatch([xd, yd]); // batch division\n    return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) }; //  13. return (xn, xd, yn, yd)\n}\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {\n    DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n    encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\nfunction assertRstPoint(other) {\n    if (!(other instanceof RistPoint))\n        throw new Error('RistrettoPoint expected');\n}\n// √(-1) aka √(a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// √(ad - 1)\nconst SQRT_AD_MINUS_ONE = BigInt('25063068953384623474111414158702152701244531502492656460079210482610430750235');\n// 1 / √(a-d)\nconst INVSQRT_A_MINUS_D = BigInt('54469307008909316920995813868745141605393597292927456921205312896311721017578');\n// 1-d²\nconst ONE_MINUS_D_SQ = BigInt('1159843021668779879193775521855586647937357759715417654439879720876111806838');\n// (d-1)²\nconst D_MINUS_ONE_SQ = BigInt('40440834346308536858101042469323190826248399146238708352240133220865137265952');\n// Calculates 1/√(number)\nconst invertSqrt = (number) => uvRatio(_1n, number);\nconst MAX_255B = BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff');\nconst bytes255ToNumberLE = (bytes) => ed25519.CURVE.Fp.create((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToNumberLE)(bytes) & MAX_255B);\n// Computes Elligator map for Ristretto\n// https://ristretto.group/formulas/elligator.html\nfunction calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const r = mod(SQRT_M1 * r0 * r0); // 1\n    const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n    let c = BigInt(-1); // 3\n    const D = mod((c - d * r) * mod(r + d)); // 4\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n    let s_ = mod(s * r0); // 6\n    if (!(0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s_, P))\n        s_ = mod(-s_);\n    if (!Ns_D_is_sq)\n        s = s_; // 7\n    if (!Ns_D_is_sq)\n        c = r; // 8\n    const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n    const s2 = s * s;\n    const W0 = mod((s + s) * D); // 10\n    const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n    const W2 = mod(_1n - s2); // 12\n    const W3 = mod(_1n + s2); // 13\n    return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n */\nclass RistPoint {\n    // Private property to discourage combining ExtendedPoint + RistrettoPoint\n    // Always use Ristretto encoding/decoding instead.\n    constructor(ep) {\n        this.ep = ep;\n    }\n    static fromAffine(ap) {\n        return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n    }\n    /**\n     * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n     * The hash-to-group operation applies Elligator twice and adds the results.\n     * **Note:** this is one-way map, there is no conversion from point to hash.\n     * https://ristretto.group/formulas/elligator.html\n     * @param hex 64-byte output of a hash function\n     */\n    static hashToCurve(hex) {\n        hex = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)('ristrettoHash', hex, 64);\n        const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n        const R1 = calcElligatorRistrettoMap(r1);\n        const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n        const R2 = calcElligatorRistrettoMap(r2);\n        return new RistPoint(R1.add(R2));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * https://ristretto.group/formulas/decoding.html\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */\n    static fromHex(hex) {\n        hex = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.ensureBytes)('ristrettoHex', hex, 32);\n        const { a, d } = ed25519.CURVE;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n        const s = bytes255ToNumberLE(hex);\n        // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n        // 3. Check that s is non-negative, or else abort\n        if (!(0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.equalBytes)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.numberToBytesLE)(s, 32), hex) || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P))\n            throw new Error(emsg);\n        const s2 = mod(s * s);\n        const u1 = mod(_1n + a * s2); // 4 (a is -1)\n        const u2 = mod(_1n - a * s2); // 5\n        const u1_2 = mod(u1 * u1);\n        const u2_2 = mod(u2 * u2);\n        const v = mod(a * d * u1_2 - u2_2); // 6\n        const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n        const Dx = mod(I * u2); // 8\n        const Dy = mod(I * Dx * v); // 9\n        let x = mod((s + s) * Dx); // 10\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x, P))\n            x = mod(-x); // 10\n        const y = mod(u1 * Dy); // 11\n        const t = mod(x * y); // 12\n        if (!isValid || (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t, P) || y === _0n)\n            throw new Error(emsg);\n        return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * https://ristretto.group/formulas/encoding.html\n     */\n    toRawBytes() {\n        let { ex: x, ey: y, ez: z, et: t } = this.ep;\n        const P = ed25519.CURVE.Fp.ORDER;\n        const mod = ed25519.CURVE.Fp.create;\n        const u1 = mod(mod(z + y) * mod(z - y)); // 1\n        const u2 = mod(x * y); // 2\n        // Square root always exists\n        const u2sq = mod(u2 * u2);\n        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n        const D1 = mod(invsqrt * u1); // 4\n        const D2 = mod(invsqrt * u2); // 5\n        const zInv = mod(D1 * D2 * t); // 6\n        let D; // 7\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(t * zInv, P)) {\n            let _x = mod(y * SQRT_M1);\n            let _y = mod(x * SQRT_M1);\n            x = _x;\n            y = _y;\n            D = mod(D1 * INVSQRT_A_MINUS_D);\n        }\n        else {\n            D = D2; // 8\n        }\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(x * zInv, P))\n            y = mod(-y); // 9\n        let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n        if ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.isNegativeLE)(s, P))\n            s = mod(-s);\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.numberToBytesLE)(s, 32); // 11\n    }\n    toHex() {\n        return (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_6__.bytesToHex)(this.toRawBytes());\n    }\n    toString() {\n        return this.toHex();\n    }\n    // Compare one point to another.\n    equals(other) {\n        assertRstPoint(other);\n        const { ex: X1, ey: Y1 } = this.ep;\n        const { ex: X2, ey: Y2 } = other.ep;\n        const mod = ed25519.CURVE.Fp.create;\n        // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n        const one = mod(X1 * Y2) === mod(Y1 * X2);\n        const two = mod(Y1 * Y2) === mod(X1 * X2);\n        return one || two;\n    }\n    add(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.add(other.ep));\n    }\n    subtract(other) {\n        assertRstPoint(other);\n        return new RistPoint(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n        return new RistPoint(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n        return new RistPoint(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n        return new RistPoint(this.ep.double());\n    }\n    negate() {\n        return new RistPoint(this.ep.negate());\n    }\n}\nconst RistrettoPoint = /* @__PURE__ */ (() => {\n    if (!RistPoint.BASE)\n        RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n    if (!RistPoint.ZERO)\n        RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n    return RistPoint;\n})();\n// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B\nconst hashToRistretto255 = (msg, options) => {\n    const d = options.DST;\n    const DST = typeof d === 'string' ? (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_2__.utf8ToBytes)(d) : d;\n    const uniform_bytes = (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.expand_message_xmd)(msg, DST, 64, _noble_hashes_sha512__WEBPACK_IMPORTED_MODULE_1__.sha512);\n    const P = RistPoint.hashToCurve(uniform_bytes);\n    return P;\n};\nconst hash_to_ristretto255 = hashToRistretto255; // legacy\n//# sourceMappingURL=ed25519.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9lZDI1NTE5LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDOEM7QUFDOEI7QUFDckI7QUFDRDtBQUM2QjtBQUMwQjtBQUM5QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QixnQkFBZ0IsMERBQUksd0JBQXdCO0FBQzVDLGdCQUFnQiwwREFBSSx1QkFBdUI7QUFDM0MsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGtCQUFrQiwwREFBSTtBQUN0QixrQkFBa0IsMERBQUk7QUFDdEIsa0JBQWtCLDBEQUFJO0FBQ3RCLHVCQUF1QiwwREFBSTtBQUMzQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSx5REFBRyxnQkFBZ0I7QUFDbEMsZUFBZSx5REFBRyxrQkFBa0I7QUFDcEM7QUFDQTtBQUNBLFlBQVkseURBQUcsbUJBQW1CO0FBQ2xDLGdCQUFnQix5REFBRyxnQkFBZ0I7QUFDbkMscUJBQXFCO0FBQ3JCLGtCQUFrQix5REFBRywwQkFBMEI7QUFDL0MsZ0NBQWdDO0FBQ2hDLDZCQUE2Qix5REFBRyxTQUFTO0FBQ3pDLDJCQUEyQix5REFBRywyQkFBMkI7QUFDekQ7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLFFBQVEsa0VBQVk7QUFDcEIsWUFBWSx5REFBRztBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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WTtBQUN4Qix5QkFBeUI7QUFDekIsa0NBQWtDO0FBQ2xDLFlBQVksa0VBQVk7QUFDeEI7QUFDQSxlQUFlLG1FQUFlLFNBQVM7QUFDdkM7QUFDQTtBQUNBLGVBQWUsOERBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDLGdCQUFnQixpQkFBaUI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ087QUFDUDtBQUNBLHdDQUF3QyxnRUFBVztBQUNuRCwwQkFBMEIsOEVBQWtCLGVBQWUsd0RBQU07QUFDakU7QUFDQTtBQUNBO0FBQ08saURBQWlEO0FBQ3hEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9lZDI1NTE5LmpzPzg5NzciXSwic291cmNlc0NvbnRlbnQiOlsiLyohIG5vYmxlLWN1cnZlcyAtIE1JVCBMaWNlbnNlIChjKSAyMDIyIFBhdWwgTWlsbGVyIChwYXVsbWlsbHIuY29tKSAqL1xuaW1wb3J0IHsgc2hhNTEyIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy9zaGE1MTInO1xuaW1wb3J0IHsgY29uY2F0Qnl0ZXMsIHJhbmRvbUJ5dGVzLCB1dGY4VG9CeXRlcyB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvdXRpbHMnO1xuaW1wb3J0IHsgdHdpc3RlZEVkd2FyZHMgfSBmcm9tICcuL2Fic3RyYWN0L2Vkd2FyZHMuanMnO1xuaW1wb3J0IHsgbW9udGdvbWVyeSB9IGZyb20gJy4vYWJzdHJhY3QvbW9udGdvbWVyeS5qcyc7XG5pbXBvcnQgeyBGaWVsZCwgRnBTcXJ0RXZlbiwgaXNOZWdhdGl2ZUxFLCBtb2QsIHBvdzIgfSBmcm9tICcuL2Fic3RyYWN0L21vZHVsYXIuanMnO1xuaW1wb3J0IHsgYnl0ZXNUb0hleCwgYnl0ZXNUb051bWJlckxFLCBlbnN1cmVCeXRlcywgZXF1YWxCeXRlcywgbnVtYmVyVG9CeXRlc0xFLCB9IGZyb20gJy4vYWJzdHJhY3QvdXRpbHMuanMnO1xuaW1wb3J0IHsgY3JlYXRlSGFzaGVyLCBleHBhbmRfbWVzc2FnZV94bWQgfSBmcm9tICcuL2Fic3RyYWN0L2hhc2gtdG8tY3VydmUuanMnO1xuLyoqXG4gKiBlZDI1NTE5IFR3aXN0ZWQgRWR3YXJkcyBjdXJ2ZSB3aXRoIGZvbGxvd2luZyBhZGRvbnM6XG4gKiAtIFgyNTUxOSBFQ0RIXG4gKiAtIFJpc3RyZXR0byBjb2ZhY3RvciBlbGltaW5hdGlvblxuICogLSBFbGxpZ2F0b3IgaGFzaC10by1ncm91cCAvIHBvaW50IGluZGlzdGluZ3Vpc2hhYmlsaXR5XG4gKi9cbmNvbnN0IEVEMjU1MTlfUCA9IEJpZ0ludCgnNTc4OTYwNDQ2MTg2NTgwOTc3MTE3ODU0OTI1MDQzNDM5NTM5MjY2MzQ5OTIzMzI4MjAyODIwMTk3Mjg3OTIwMDM5NTY1NjQ4MTk5NDknKTtcbi8vIOKImigtMSkgYWthIOKImihhKSBha2EgMl4oKHAtMSkvNClcbmNvbnN0IEVEMjU1MTlfU1FSVF9NMSA9IEJpZ0ludCgnMTk2ODExNjEzNzY3MDc1MDU5NTY4MDcwNzkzMDQ5ODg1NDIwMTU0NDYwNjY1MTU5MjM4OTAxNjI3NDQwMjEwNzMxMjM4Mjk3ODQ3NTInKTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgXzBuID0gQmlnSW50KDApLCBfMW4gPSBCaWdJbnQoMSksIF8ybiA9IEJpZ0ludCgyKSwgXzVuID0gQmlnSW50KDUpO1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCBfMTBuID0gQmlnSW50KDEwKSwgXzIwbiA9IEJpZ0ludCgyMCksIF80MG4gPSBCaWdJbnQoNDApLCBfODBuID0gQmlnSW50KDgwKTtcbmZ1bmN0aW9uIGVkMjU1MTlfcG93XzJfMjUyXzMoeCkge1xuICAgIGNvbnN0IFAgPSBFRDI1NTE5X1A7XG4gICAgY29uc3QgeDIgPSAoeCAqIHgpICUgUDtcbiAgICBjb25zdCBiMiA9ICh4MiAqIHgpICUgUDsgLy8geF4zLCAxMVxuICAgIGNvbnN0IGI0ID0gKHBvdzIoYjIsIF8ybiwgUCkgKiBiMikgJSBQOyAvLyB4XjE1LCAxMTExXG4gICAgY29uc3QgYjUgPSAocG93MihiNCwgXzFuLCBQKSAqIHgpICUgUDsgLy8geF4zMVxuICAgIGNvbnN0IGIxMCA9IChwb3cyKGI1LCBfNW4sIFApICogYjUpICUgUDtcbiAgICBjb25zdCBiMjAgPSAocG93MihiMTAsIF8xMG4sIFApICogYjEwKSAlIFA7XG4gICAgY29uc3QgYjQwID0gKHBvdzIoYjIwLCBfMjBuLCBQKSAqIGIyMCkgJSBQO1xuICAgIGNvbnN0IGI4MCA9IChwb3cyKGI0MCwgXzQwbiwgUCkgKiBiNDApICUgUDtcbiAgICBjb25zdCBiMTYwID0gKHBvdzIoYjgwLCBfODBuLCBQKSAqIGI4MCkgJSBQO1xuICAgIGNvbnN0IGIyNDAgPSAocG93MihiMTYwLCBfODBuLCBQKSAqIGI4MCkgJSBQO1xuICAgIGNvbnN0IGIyNTAgPSAocG93MihiMjQwLCBfMTBuLCBQKSAqIGIxMCkgJSBQO1xuICAgIGNvbnN0IHBvd19wXzVfOCA9IChwb3cyKGIyNTAsIF8ybiwgUCkgKiB4KSAlIFA7XG4gICAgLy8gXiBUbyBwb3cgdG8gKHArMykvOCwgbXVsdGlwbHkgaXQgYnkgeC5cbiAgICByZXR1cm4geyBwb3dfcF81XzgsIGIyIH07XG59XG5mdW5jdGlvbiBhZGp1c3RTY2FsYXJCeXRlcyhieXRlcykge1xuICAgIC8vIFNlY3Rpb24gNTogRm9yIFgyNTUxOSwgaW4gb3JkZXIgdG8gZGVjb2RlIDMyIHJhbmRvbSBieXRlcyBhcyBhbiBpbnRlZ2VyIHNjYWxhcixcbiAgICAvLyBzZXQgdGhlIHRocmVlIGxlYXN0IHNpZ25pZmljYW50IGJpdHMgb2YgdGhlIGZpcnN0IGJ5dGVcbiAgICBieXRlc1swXSAmPSAyNDg7IC8vIDBiMTExMV8xMDAwXG4gICAgLy8gYW5kIHRoZSBtb3N0IHNpZ25pZmljYW50IGJpdCBvZiB0aGUgbGFzdCB0byB6ZXJvLFxuICAgIGJ5dGVzWzMxXSAmPSAxMjc7IC8vIDBiMDExMV8xMTExXG4gICAgLy8gc2V0IHRoZSBzZWNvbmQgbW9zdCBzaWduaWZpY2FudCBiaXQgb2YgdGhlIGxhc3QgYnl0ZSB0byAxXG4gICAgYnl0ZXNbMzFdIHw9IDY0OyAvLyAwYjAxMDBfMDAwMFxuICAgIHJldHVybiBieXRlcztcbn1cbi8vIHNxcnQodS92KVxuZnVuY3Rpb24gdXZSYXRpbyh1LCB2KSB7XG4gICAgY29uc3QgUCA9IEVEMjU1MTlfUDtcbiAgICBjb25zdCB2MyA9IG1vZCh2ICogdiAqIHYsIFApOyAvLyB2wrNcbiAgICBjb25zdCB2NyA9IG1vZCh2MyAqIHYzICogdiwgUCk7IC8vIHbigbdcbiAgICAvLyAocCszKS84IGFuZCAocC01KS84XG4gICAgY29uc3QgcG93ID0gZWQyNTUxOV9wb3dfMl8yNTJfMyh1ICogdjcpLnBvd19wXzVfODtcbiAgICBsZXQgeCA9IG1vZCh1ICogdjMgKiBwb3csIFApOyAvLyAodXbCsykodXbigbcpXihwLTUpLzhcbiAgICBjb25zdCB2eDIgPSBtb2QodiAqIHggKiB4LCBQKTsgLy8gdnjCslxuICAgIGNvbnN0IHJvb3QxID0geDsgLy8gRmlyc3Qgcm9vdCBjYW5kaWRhdGVcbiAgICBjb25zdCByb290MiA9IG1vZCh4ICogRUQyNTUxOV9TUVJUX00xLCBQKTsgLy8gU2Vjb25kIHJvb3QgY2FuZGlkYXRlXG4gICAgY29uc3QgdXNlUm9vdDEgPSB2eDIgPT09IHU7IC8vIElmIHZ4wrIgPSB1IChtb2QgcCksIHggaXMgYSBzcXVhcmUgcm9vdFxuICAgIGNvbnN0IHVzZVJvb3QyID0gdngyID09PSBtb2QoLXUsIFApOyAvLyBJZiB2eMKyID0gLXUsIHNldCB4IDwtLSB4ICogMl4oKHAtMSkvNClcbiAgICBjb25zdCBub1Jvb3QgPSB2eDIgPT09IG1vZCgtdSAqIEVEMjU1MTlfU1FSVF9NMSwgUCk7IC8vIFRoZXJlIGlzIG5vIHZhbGlkIHJvb3QsIHZ4wrIgPSAtdeKImigtMSlcbiAgICBpZiAodXNlUm9vdDEpXG4gICAgICAgIHggPSByb290MTtcbiAgICBpZiAodXNlUm9vdDIgfHwgbm9Sb290KVxuICAgICAgICB4ID0gcm9vdDI7IC8vIFdlIHJldHVybiByb290MiBhbnl3YXksIGZvciBjb25zdC10aW1lXG4gICAgaWYgKGlzTmVnYXRpdmVMRSh4LCBQKSlcbiAgICAgICAgeCA9IG1vZCgteCwgUCk7XG4gICAgcmV0dXJuIHsgaXNWYWxpZDogdXNlUm9vdDEgfHwgdXNlUm9vdDIsIHZhbHVlOiB4IH07XG59XG4vLyBKdXN0IGluIGNhc2VcbmV4cG9ydCBjb25zdCBFRDI1NTE5X1RPUlNJT05fU1VCR1JPVVAgPSBbXG4gICAgJzAxMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICdjNzE3NmE3MDNkNGRkODRmYmEzYzBiNzYwZDEwNjcwZjJhMjA1M2ZhMmMzOWNjYzY0ZWM3ZmQ3NzkyYWMwMzdhJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA4MCcsXG4gICAgJzI2ZTg5NThmYzJiMjI3YjA0NWMzZjQ4OWYyZWY5OGYwZDVkZmFjMDVkM2M2MzMzOWIxMzgwMjg4NmQ1M2ZjMDUnLFxuICAgICdlY2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZjdmJyxcbiAgICAnMjZlODk1OGZjMmIyMjdiMDQ1YzNmNDg5ZjJlZjk4ZjBkNWRmYWMwNWQzYzYzMzM5YjEzODAyODg2ZDUzZmM4NScsXG4gICAgJzAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICdjNzE3NmE3MDNkNGRkODRmYmEzYzBiNzYwZDEwNjcwZjJhMjA1M2ZhMmMzOWNjYzY0ZWM3ZmQ3NzkyYWMwM2ZhJyxcbl07XG5jb25zdCBGcCA9IEZpZWxkKEVEMjU1MTlfUCwgdW5kZWZpbmVkLCB0cnVlKTtcbmNvbnN0IGVkMjU1MTlEZWZhdWx0cyA9IHtcbiAgICAvLyBQYXJhbTogYVxuICAgIGE6IEJpZ0ludCgtMSksIC8vIEZwLmNyZWF0ZSgtMSkgaXMgcHJvcGVyOyBvdXIgd2F5IHN0aWxsIHdvcmtzIGFuZCBpcyBmYXN0ZXJcbiAgICAvLyBkIGlzIGVxdWFsIHRvIC0xMjE2NjUvMTIxNjY2IG92ZXIgZmluaXRlIGZpZWxkLlxuICAgIC8vIE5lZ2F0aXZlIG51bWJlciBpcyBQIC0gbnVtYmVyLCBhbmQgZGl2aXNpb24gaXMgaW52ZXJ0KG51bWJlciwgUClcbiAgICBkOiBCaWdJbnQoJzM3MDk1NzA1OTM0NjY5NDM5MzQzMTM4MDgzNTA4NzU0NTY1MTg5NTQyMTEzODc5ODQzMjE5MDE2Mzg4Nzg1NTMzMDg1OTQwMjgzNTU1JyksXG4gICAgLy8gRmluaXRlIGZpZWxkIPCdlL1wIG92ZXIgd2hpY2ggd2UnbGwgZG8gY2FsY3VsYXRpb25zOyAybioqMjU1biAtIDE5blxuICAgIEZwLFxuICAgIC8vIFN1Ymdyb3VwIG9yZGVyOiBob3cgbWFueSBwb2ludHMgY3VydmUgaGFzXG4gICAgLy8gMm4qKjI1Mm4gKyAyNzc0MjMxNzc3NzM3MjM1MzUzNTg1MTkzNzc5MDg4MzY0ODQ5M247XG4gICAgbjogQmlnSW50KCc3MjM3MDA1NTc3MzMyMjYyMjEzOTczMTg2NTYzMDQyOTk0MjQwODU3MTE2MzU5Mzc5OTA3NjA2MDAxOTUwOTM4Mjg1NDU0MjUwOTg5JyksXG4gICAgLy8gQ29mYWN0b3JcbiAgICBoOiBCaWdJbnQoOCksXG4gICAgLy8gQmFzZSBwb2ludCAoeCwgeSkgYWthIGdlbmVyYXRvciBwb2ludFxuICAgIEd4OiBCaWdJbnQoJzE1MTEyMjIxMzQ5NTM1NDAwNzcyNTAxMTUxNDA5NTg4NTMxNTExNDU0MDEyNjkzMDQxODU3MjA2MDQ2MTEzMjgzOTQ5ODQ3NzYyMjAyJyksXG4gICAgR3k6IEJpZ0ludCgnNDYzMTY4MzU2OTQ5MjY0NzgxNjk0MjgzOTQwMDM0NzUxNjMxNDEzMDc5OTM4NjYyNTYyMjU2MTU3ODMwMzM2MDMxNjUyNTE4NTU5NjAnKSxcbiAgICBoYXNoOiBzaGE1MTIsXG4gICAgcmFuZG9tQnl0ZXMsXG4gICAgYWRqdXN0U2NhbGFyQnl0ZXMsXG4gICAgLy8gZG9tMlxuICAgIC8vIFJhdGlvIG9mIHUgdG8gdi4gQWxsb3dzIHVzIHRvIGNvbWJpbmUgaW52ZXJzaW9uIGFuZCBzcXVhcmUgcm9vdC4gVXNlcyBhbGdvIGZyb20gUkZDODAzMiA1LjEuMy5cbiAgICAvLyBDb25zdGFudC10aW1lLCB1L+KImnZcbiAgICB1dlJhdGlvLFxufTtcbmV4cG9ydCBjb25zdCBlZDI1NTE5ID0gLyogQF9fUFVSRV9fICovIHR3aXN0ZWRFZHdhcmRzKGVkMjU1MTlEZWZhdWx0cyk7XG5mdW5jdGlvbiBlZDI1NTE5X2RvbWFpbihkYXRhLCBjdHgsIHBoZmxhZykge1xuICAgIGlmIChjdHgubGVuZ3RoID4gMjU1KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRleHQgaXMgdG9vIGJpZycpO1xuICAgIHJldHVybiBjb25jYXRCeXRlcyh1dGY4VG9CeXRlcygnU2lnRWQyNTUxOSBubyBFZDI1NTE5IGNvbGxpc2lvbnMnKSwgbmV3IFVpbnQ4QXJyYXkoW3BoZmxhZyA/IDEgOiAwLCBjdHgubGVuZ3RoXSksIGN0eCwgZGF0YSk7XG59XG5leHBvcnQgY29uc3QgZWQyNTUxOWN0eCA9IC8qIEBfX1BVUkVfXyAqLyB0d2lzdGVkRWR3YXJkcyh7XG4gICAgLi4uZWQyNTUxOURlZmF1bHRzLFxuICAgIGRvbWFpbjogZWQyNTUxOV9kb21haW4sXG59KTtcbmV4cG9ydCBjb25zdCBlZDI1NTE5cGggPSAvKiBAX19QVVJFX18gKi8gdHdpc3RlZEVkd2FyZHMoe1xuICAgIC4uLmVkMjU1MTlEZWZhdWx0cyxcbiAgICBkb21haW46IGVkMjU1MTlfZG9tYWluLFxuICAgIHByZWhhc2g6IHNoYTUxMixcbn0pO1xuZXhwb3J0IGNvbnN0IHgyNTUxOSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gbW9udGdvbWVyeSh7XG4gICAgUDogRUQyNTUxOV9QLFxuICAgIGE6IEJpZ0ludCg0ODY2NjIpLFxuICAgIG1vbnRnb21lcnlCaXRzOiAyNTUsIC8vIG4gaXMgMjUzIGJpdHNcbiAgICBuQnl0ZUxlbmd0aDogMzIsXG4gICAgR3U6IEJpZ0ludCg5KSxcbiAgICBwb3dQbWludXMyOiAoeCkgPT4ge1xuICAgICAgICBjb25zdCBQID0gRUQyNTUxOV9QO1xuICAgICAgICAvLyB4XihwLTIpIGFrYSB4XigyXjI1NS0yMSlcbiAgICAgICAgY29uc3QgeyBwb3dfcF81XzgsIGIyIH0gPSBlZDI1NTE5X3Bvd18yXzI1Ml8zKHgpO1xuICAgICAgICByZXR1cm4gbW9kKHBvdzIocG93X3BfNV84LCBCaWdJbnQoMyksIFApICogYjIsIFApO1xuICAgIH0sXG4gICAgYWRqdXN0U2NhbGFyQnl0ZXMsXG4gICAgcmFuZG9tQnl0ZXMsXG59KSkoKTtcbi8qKlxuICogQ29udmVydHMgZWQyNTUxOSBwdWJsaWMga2V5IHRvIHgyNTUxOSBwdWJsaWMga2V5LiBVc2VzIGZvcm11bGE6XG4gKiAqIGAodSwgdikgPSAoKDEreSkvKDEteSksIHNxcnQoLTQ4NjY2NCkqdS94KWBcbiAqICogYCh4LCB5KSA9IChzcXJ0KC00ODY2NjQpKnUvdiwgKHUtMSkvKHUrMSkpYFxuICogQGV4YW1wbGVcbiAqICAgY29uc3Qgc29tZW9uZXNQdWIgPSBlZDI1NTE5LmdldFB1YmxpY0tleShlZDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKSk7XG4gKiAgIGNvbnN0IGFQcml2ID0geDI1NTE5LnV0aWxzLnJhbmRvbVByaXZhdGVLZXkoKTtcbiAqICAgeDI1NTE5LmdldFNoYXJlZFNlY3JldChhUHJpdiwgZWR3YXJkc1RvTW9udGdvbWVyeVB1Yihzb21lb25lc1B1YikpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZHdhcmRzVG9Nb250Z29tZXJ5UHViKGVkd2FyZHNQdWIpIHtcbiAgICBjb25zdCB7IHkgfSA9IGVkMjU1MTkuRXh0ZW5kZWRQb2ludC5mcm9tSGV4KGVkd2FyZHNQdWIpO1xuICAgIGNvbnN0IF8xbiA9IEJpZ0ludCgxKTtcbiAgICByZXR1cm4gRnAudG9CeXRlcyhGcC5jcmVhdGUoKF8xbiArIHkpICogRnAuaW52KF8xbiAtIHkpKSk7XG59XG5leHBvcnQgY29uc3QgZWR3YXJkc1RvTW9udGdvbWVyeSA9IGVkd2FyZHNUb01vbnRnb21lcnlQdWI7IC8vIGRlcHJlY2F0ZWRcbi8qKlxuICogQ29udmVydHMgZWQyNTUxOSBzZWNyZXQga2V5IHRvIHgyNTUxOSBzZWNyZXQga2V5LlxuICogQGV4YW1wbGVcbiAqICAgY29uc3Qgc29tZW9uZXNQdWIgPSB4MjU1MTkuZ2V0UHVibGljS2V5KHgyNTUxOS51dGlscy5yYW5kb21Qcml2YXRlS2V5KCkpO1xuICogICBjb25zdCBhUHJpdiA9IGVkMjU1MTkudXRpbHMucmFuZG9tUHJpdmF0ZUtleSgpO1xuICogICB4MjU1MTkuZ2V0U2hhcmVkU2VjcmV0KGVkd2FyZHNUb01vbnRnb21lcnlQcml2KGFQcml2KSwgc29tZW9uZXNQdWIpXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlZHdhcmRzVG9Nb250Z29tZXJ5UHJpdihlZHdhcmRzUHJpdikge1xuICAgIGNvbnN0IGhhc2hlZCA9IGVkMjU1MTlEZWZhdWx0cy5oYXNoKGVkd2FyZHNQcml2LnN1YmFycmF5KDAsIDMyKSk7XG4gICAgcmV0dXJuIGVkMjU1MTlEZWZhdWx0cy5hZGp1c3RTY2FsYXJCeXRlcyhoYXNoZWQpLnN1YmFycmF5KDAsIDMyKTtcbn1cbi8vIEhhc2ggVG8gQ3VydmUgRWxsaWdhdG9yMiBNYXAgKE5PVEU6IGRpZmZlcmVudCBmcm9tIHJpc3RyZXR0bzI1NSBlbGxpZ2F0b3IpXG4vLyBOT1RFOiB2ZXJ5IGltcG9ydGFudCBwYXJ0IGlzIHVzYWdlIG9mIEZwU3FydEV2ZW4gZm9yIEVMTDJfQzFfRURXQVJEUywgc2luY2Vcbi8vIFNhZ2VNYXRoIHJldHVybnMgZGlmZmVyZW50IHJvb3QgZmlyc3QgYW5kIGV2ZXJ5dGhpbmcgZmFsbHMgYXBhcnRcbmNvbnN0IEVMTDJfQzEgPSAoRnAuT1JERVIgKyBCaWdJbnQoMykpIC8gQmlnSW50KDgpOyAvLyAxLiBjMSA9IChxICsgMykgLyA4ICAgICAgICMgSW50ZWdlciBhcml0aG1ldGljXG5jb25zdCBFTEwyX0MyID0gRnAucG93KF8ybiwgRUxMMl9DMSk7IC8vIDIuIGMyID0gMl5jMVxuY29uc3QgRUxMMl9DMyA9IEZwLnNxcnQoRnAubmVnKEZwLk9ORSkpOyAvLyAzLiBjMyA9IHNxcnQoLTEpXG5jb25zdCBFTEwyX0M0ID0gKEZwLk9SREVSIC0gQmlnSW50KDUpKSAvIEJpZ0ludCg4KTsgLy8gNC4gYzQgPSAocSAtIDUpIC8gOCAgICAgICAjIEludGVnZXIgYXJpdGhtZXRpY1xuY29uc3QgRUxMMl9KID0gQmlnSW50KDQ4NjY2Mik7XG4vLyBwcmV0dGllci1pZ25vcmVcbmZ1bmN0aW9uIG1hcF90b19jdXJ2ZV9lbGxpZ2F0b3IyX2N1cnZlMjU1MTkodSkge1xuICAgIGxldCB0djEgPSBGcC5zcXIodSk7IC8vICAxLiAgdHYxID0gdV4yXG4gICAgdHYxID0gRnAubXVsKHR2MSwgXzJuKTsgLy8gIDIuICB0djEgPSAyICogdHYxXG4gICAgbGV0IHhkID0gRnAuYWRkKHR2MSwgRnAuT05FKTsgLy8gIDMuICAgeGQgPSB0djEgKyAxICAgICAgICAgIyBOb256ZXJvOiAtMSBpcyBzcXVhcmUgKG1vZCBwKSwgdHYxIGlzIG5vdFxuICAgIGxldCB4MW4gPSBGcC5uZWcoRUxMMl9KKTsgLy8gIDQuICB4MW4gPSAtSiAgICAgICAgICAgICAgIyB4MSA9IHgxbiAvIHhkID0gLUogLyAoMSArIDIgKiB1XjIpXG4gICAgbGV0IHR2MiA9IEZwLnNxcih4ZCk7IC8vICA1LiAgdHYyID0geGReMlxuICAgIGxldCBneGQgPSBGcC5tdWwodHYyLCB4ZCk7IC8vICA2LiAgZ3hkID0gdHYyICogeGQgICAgICAgICMgZ3hkID0geGReM1xuICAgIGxldCBneDEgPSBGcC5tdWwodHYxLCBFTEwyX0opOyAvLyAgNy4gIGd4MSA9IEogKiB0djEgICAgICAgICAjIHgxbiArIEogKiB4ZFxuICAgIGd4MSA9IEZwLm11bChneDEsIHgxbik7IC8vICA4LiAgZ3gxID0gZ3gxICogeDFuICAgICAgICMgeDFuXjIgKyBKICogeDFuICogeGRcbiAgICBneDEgPSBGcC5hZGQoZ3gxLCB0djIpOyAvLyAgOS4gIGd4MSA9IGd4MSArIHR2MiAgICAgICAjIHgxbl4yICsgSiAqIHgxbiAqIHhkICsgeGReMlxuICAgIGd4MSA9IEZwLm11bChneDEsIHgxbik7IC8vICAxMC4gZ3gxID0gZ3gxICogeDFuICAgICAgICMgeDFuXjMgKyBKICogeDFuXjIgKiB4ZCArIHgxbiAqIHhkXjJcbiAgICBsZXQgdHYzID0gRnAuc3FyKGd4ZCk7IC8vICAxMS4gdHYzID0gZ3hkXjJcbiAgICB0djIgPSBGcC5zcXIodHYzKTsgLy8gIDEyLiB0djIgPSB0djNeMiAgICAgICAgICAgIyBneGReNFxuICAgIHR2MyA9IEZwLm11bCh0djMsIGd4ZCk7IC8vICAxMy4gdHYzID0gdHYzICogZ3hkICAgICAgICMgZ3hkXjNcbiAgICB0djMgPSBGcC5tdWwodHYzLCBneDEpOyAvLyAgMTQuIHR2MyA9IHR2MyAqIGd4MSAgICAgICAjIGd4MSAqIGd4ZF4zXG4gICAgdHYyID0gRnAubXVsKHR2MiwgdHYzKTsgLy8gIDE1LiB0djIgPSB0djIgKiB0djMgICAgICAgIyBneDEgKiBneGReN1xuICAgIGxldCB5MTEgPSBGcC5wb3codHYyLCBFTEwyX0M0KTsgLy8gIDE2LiB5MTEgPSB0djJeYzQgICAgICAgICMgKGd4MSAqIGd4ZF43KV4oKHAgLSA1KSAvIDgpXG4gICAgeTExID0gRnAubXVsKHkxMSwgdHYzKTsgLy8gIDE3LiB5MTEgPSB5MTEgKiB0djMgICAgICAgIyBneDEqZ3hkXjMqKGd4MSpneGReNyleKChwLTUpLzgpXG4gICAgbGV0IHkxMiA9IEZwLm11bCh5MTEsIEVMTDJfQzMpOyAvLyAgMTguIHkxMiA9IHkxMSAqIGMzXG4gICAgdHYyID0gRnAuc3FyKHkxMSk7IC8vICAxOS4gdHYyID0geTExXjJcbiAgICB0djIgPSBGcC5tdWwodHYyLCBneGQpOyAvLyAgMjAuIHR2MiA9IHR2MiAqIGd4ZFxuICAgIGxldCBlMSA9IEZwLmVxbCh0djIsIGd4MSk7IC8vICAyMS4gIGUxID0gdHYyID09IGd4MVxuICAgIGxldCB5MSA9IEZwLmNtb3YoeTEyLCB5MTEsIGUxKTsgLy8gIDIyLiAgeTEgPSBDTU9WKHkxMiwgeTExLCBlMSkgICMgSWYgZyh4MSkgaXMgc3F1YXJlLCB0aGlzIGlzIGl0cyBzcXJ0XG4gICAgbGV0IHgybiA9IEZwLm11bCh4MW4sIHR2MSk7IC8vICAyMy4geDJuID0geDFuICogdHYxICAgICAgICMgeDIgPSB4Mm4gLyB4ZCA9IDIgKiB1XjIgKiB4MW4gLyB4ZFxuICAgIGxldCB5MjEgPSBGcC5tdWwoeTExLCB1KTsgLy8gIDI0LiB5MjEgPSB5MTEgKiB1XG4gICAgeTIxID0gRnAubXVsKHkyMSwgRUxMMl9DMik7IC8vICAyNS4geTIxID0geTIxICogYzJcbiAgICBsZXQgeTIyID0gRnAubXVsKHkyMSwgRUxMMl9DMyk7IC8vICAyNi4geTIyID0geTIxICogYzNcbiAgICBsZXQgZ3gyID0gRnAubXVsKGd4MSwgdHYxKTsgLy8gIDI3LiBneDIgPSBneDEgKiB0djEgICAgICAgIyBnKHgyKSA9IGd4MiAvIGd4ZCA9IDIgKiB1XjIgKiBnKHgxKVxuICAgIHR2MiA9IEZwLnNxcih5MjEpOyAvLyAgMjguIHR2MiA9IHkyMV4yXG4gICAgdHYyID0gRnAubXVsKHR2MiwgZ3hkKTsgLy8gIDI5LiB0djIgPSB0djIgKiBneGRcbiAgICBsZXQgZTIgPSBGcC5lcWwodHYyLCBneDIpOyAvLyAgMzAuICBlMiA9IHR2MiA9PSBneDJcbiAgICBsZXQgeTIgPSBGcC5jbW92KHkyMiwgeTIxLCBlMik7IC8vICAzMS4gIHkyID0gQ01PVih5MjIsIHkyMSwgZTIpICAjIElmIGcoeDIpIGlzIHNxdWFyZSwgdGhpcyBpcyBpdHMgc3FydFxuICAgIHR2MiA9IEZwLnNxcih5MSk7IC8vICAzMi4gdHYyID0geTFeMlxuICAgIHR2MiA9IEZwLm11bCh0djIsIGd4ZCk7IC8vICAzMy4gdHYyID0gdHYyICogZ3hkXG4gICAgbGV0IGUzID0gRnAuZXFsKHR2MiwgZ3gxKTsgLy8gIDM0LiAgZTMgPSB0djIgPT0gZ3gxXG4gICAgbGV0IHhuID0gRnAuY21vdih4Mm4sIHgxbiwgZTMpOyAvLyAgMzUuICB4biA9IENNT1YoeDJuLCB4MW4sIGUzKSAgIyBJZiBlMywgeCA9IHgxLCBlbHNlIHggPSB4MlxuICAgIGxldCB5ID0gRnAuY21vdih5MiwgeTEsIGUzKTsgLy8gIDM2LiAgIHkgPSBDTU9WKHkyLCB5MSwgZTMpICAgICMgSWYgZTMsIHkgPSB5MSwgZWxzZSB5ID0geTJcbiAgICBsZXQgZTQgPSBGcC5pc09kZCh5KTsgLy8gIDM3LiAgZTQgPSBzZ24wKHkpID09IDEgICAgICAgICMgRml4IHNpZ24gb2YgeVxuICAgIHkgPSBGcC5jbW92KHksIEZwLm5lZyh5KSwgZTMgIT09IGU0KTsgLy8gIDM4LiAgIHkgPSBDTU9WKHksIC15LCBlMyBYT1IgZTQpXG4gICAgcmV0dXJuIHsgeE1uOiB4biwgeE1kOiB4ZCwgeU1uOiB5LCB5TWQ6IF8xbiB9OyAvLyAgMzkuIHJldHVybiAoeG4sIHhkLCB5LCAxKVxufVxuY29uc3QgRUxMMl9DMV9FRFdBUkRTID0gRnBTcXJ0RXZlbihGcCwgRnAubmVnKEJpZ0ludCg0ODY2NjQpKSk7IC8vIHNnbjAoYzEpIE1VU1QgZXF1YWwgMFxuZnVuY3Rpb24gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfZWR3YXJkczI1NTE5KHUpIHtcbiAgICBjb25zdCB7IHhNbiwgeE1kLCB5TW4sIHlNZCB9ID0gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfY3VydmUyNTUxOSh1KTsgLy8gIDEuICAoeE1uLCB4TWQsIHlNbiwgeU1kKSA9XG4gICAgLy8gbWFwX3RvX2N1cnZlX2VsbGlnYXRvcjJfY3VydmUyNTUxOSh1KVxuICAgIGxldCB4biA9IEZwLm11bCh4TW4sIHlNZCk7IC8vICAyLiAgeG4gPSB4TW4gKiB5TWRcbiAgICB4biA9IEZwLm11bCh4biwgRUxMMl9DMV9FRFdBUkRTKTsgLy8gIDMuICB4biA9IHhuICogYzFcbiAgICBsZXQgeGQgPSBGcC5tdWwoeE1kLCB5TW4pOyAvLyAgNC4gIHhkID0geE1kICogeU1uICAgICMgeG4gLyB4ZCA9IGMxICogeE0gLyB5TVxuICAgIGxldCB5biA9IEZwLnN1Yih4TW4sIHhNZCk7IC8vICA1LiAgeW4gPSB4TW4gLSB4TWRcbiAgICBsZXQgeWQgPSBGcC5hZGQoeE1uLCB4TWQpOyAvLyAgNi4gIHlkID0geE1uICsgeE1kICAgICMgKG4gLyBkIC0gMSkgLyAobiAvIGQgKyAxKSA9IChuIC0gZCkgLyAobiArIGQpXG4gICAgbGV0IHR2MSA9IEZwLm11bCh4ZCwgeWQpOyAvLyAgNy4gdHYxID0geGQgKiB5ZFxuICAgIGxldCBlID0gRnAuZXFsKHR2MSwgRnAuWkVSTyk7IC8vICA4LiAgIGUgPSB0djEgPT0gMFxuICAgIHhuID0gRnAuY21vdih4biwgRnAuWkVSTywgZSk7IC8vICA5LiAgeG4gPSBDTU9WKHhuLCAwLCBlKVxuICAgIHhkID0gRnAuY21vdih4ZCwgRnAuT05FLCBlKTsgLy8gIDEwLiB4ZCA9IENNT1YoeGQsIDEsIGUpXG4gICAgeW4gPSBGcC5jbW92KHluLCBGcC5PTkUsIGUpOyAvLyAgMTEuIHluID0gQ01PVih5biwgMSwgZSlcbiAgICB5ZCA9IEZwLmNtb3YoeWQsIEZwLk9ORSwgZSk7IC8vICAxMi4geWQgPSBDTU9WKHlkLCAxLCBlKVxuICAgIGNvbnN0IGludiA9IEZwLmludmVydEJhdGNoKFt4ZCwgeWRdKTsgLy8gYmF0Y2ggZGl2aXNpb25cbiAgICByZXR1cm4geyB4OiBGcC5tdWwoeG4sIGludlswXSksIHk6IEZwLm11bCh5biwgaW52WzFdKSB9OyAvLyAgMTMuIHJldHVybiAoeG4sIHhkLCB5biwgeWQpXG59XG5jb25zdCBodGYgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGNyZWF0ZUhhc2hlcihlZDI1NTE5LkV4dGVuZGVkUG9pbnQsIChzY2FsYXJzKSA9PiBtYXBfdG9fY3VydmVfZWxsaWdhdG9yMl9lZHdhcmRzMjU1MTkoc2NhbGFyc1swXSksIHtcbiAgICBEU1Q6ICdlZHdhcmRzMjU1MTlfWE1EOlNIQS01MTJfRUxMMl9ST18nLFxuICAgIGVuY29kZURTVDogJ2Vkd2FyZHMyNTUxOV9YTUQ6U0hBLTUxMl9FTEwyX05VXycsXG4gICAgcDogRnAuT1JERVIsXG4gICAgbTogMSxcbiAgICBrOiAxMjgsXG4gICAgZXhwYW5kOiAneG1kJyxcbiAgICBoYXNoOiBzaGE1MTIsXG59KSkoKTtcbmV4cG9ydCBjb25zdCBoYXNoVG9DdXJ2ZSA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gaHRmLmhhc2hUb0N1cnZlKSgpO1xuZXhwb3J0IGNvbnN0IGVuY29kZVRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGh0Zi5lbmNvZGVUb0N1cnZlKSgpO1xuZnVuY3Rpb24gYXNzZXJ0UnN0UG9pbnQob3RoZXIpIHtcbiAgICBpZiAoIShvdGhlciBpbnN0YW5jZW9mIFJpc3RQb2ludCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignUmlzdHJldHRvUG9pbnQgZXhwZWN0ZWQnKTtcbn1cbi8vIOKImigtMSkgYWthIOKImihhKSBha2EgMl4oKHAtMSkvNClcbmNvbnN0IFNRUlRfTTEgPSBFRDI1NTE5X1NRUlRfTTE7XG4vLyDiiJooYWQgLSAxKVxuY29uc3QgU1FSVF9BRF9NSU5VU19PTkUgPSBCaWdJbnQoJzI1MDYzMDY4OTUzMzg0NjIzNDc0MTExNDE0MTU4NzAyMTUyNzAxMjQ0NTMxNTAyNDkyNjU2NDYwMDc5MjEwNDgyNjEwNDMwNzUwMjM1Jyk7XG4vLyAxIC8g4oiaKGEtZClcbmNvbnN0IElOVlNRUlRfQV9NSU5VU19EID0gQmlnSW50KCc1NDQ2OTMwNzAwODkwOTMxNjkyMDk5NTgxMzg2ODc0NTE0MTYwNTM5MzU5NzI5MjkyNzQ1NjkyMTIwNTMxMjg5NjMxMTcyMTAxNzU3OCcpO1xuLy8gMS1kwrJcbmNvbnN0IE9ORV9NSU5VU19EX1NRID0gQmlnSW50KCcxMTU5ODQzMDIxNjY4Nzc5ODc5MTkzNzc1NTIxODU1NTg2NjQ3OTM3MzU3NzU5NzE1NDE3NjU0NDM5ODc5NzIwODc2MTExODA2ODM4Jyk7XG4vLyAoZC0xKcKyXG5jb25zdCBEX01JTlVTX09ORV9TUSA9IEJpZ0ludCgnNDA0NDA4MzQzNDYzMDg1MzY4NTgxMDEwNDI0NjkzMjMxOTA4MjYyNDgzOTkxNDYyMzg3MDgzNTIyNDAxMzMyMjA4NjUxMzcyNjU5NTInKTtcbi8vIENhbGN1bGF0ZXMgMS/iiJoobnVtYmVyKVxuY29uc3QgaW52ZXJ0U3FydCA9IChudW1iZXIpID0+IHV2UmF0aW8oXzFuLCBudW1iZXIpO1xuY29uc3QgTUFYXzI1NUIgPSBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZicpO1xuY29uc3QgYnl0ZXMyNTVUb051bWJlckxFID0gKGJ5dGVzKSA9PiBlZDI1NTE5LkNVUlZFLkZwLmNyZWF0ZShieXRlc1RvTnVtYmVyTEUoYnl0ZXMpICYgTUFYXzI1NUIpO1xuLy8gQ29tcHV0ZXMgRWxsaWdhdG9yIG1hcCBmb3IgUmlzdHJldHRvXG4vLyBodHRwczovL3Jpc3RyZXR0by5ncm91cC9mb3JtdWxhcy9lbGxpZ2F0b3IuaHRtbFxuZnVuY3Rpb24gY2FsY0VsbGlnYXRvclJpc3RyZXR0b01hcChyMCkge1xuICAgIGNvbnN0IHsgZCB9ID0gZWQyNTUxOS5DVVJWRTtcbiAgICBjb25zdCBQID0gZWQyNTUxOS5DVVJWRS5GcC5PUkRFUjtcbiAgICBjb25zdCBtb2QgPSBlZDI1NTE5LkNVUlZFLkZwLmNyZWF0ZTtcbiAgICBjb25zdCByID0gbW9kKFNRUlRfTTEgKiByMCAqIHIwKTsgLy8gMVxuICAgIGNvbnN0IE5zID0gbW9kKChyICsgXzFuKSAqIE9ORV9NSU5VU19EX1NRKTsgLy8gMlxuICAgIGxldCBjID0gQmlnSW50KC0xKTsgLy8gM1xuICAgIGNvbnN0IEQgPSBtb2QoKGMgLSBkICogcikgKiBtb2QociArIGQpKTsgLy8gNFxuICAgIGxldCB7IGlzVmFsaWQ6IE5zX0RfaXNfc3EsIHZhbHVlOiBzIH0gPSB1dlJhdGlvKE5zLCBEKTsgLy8gNVxuICAgIGxldCBzXyA9IG1vZChzICogcjApOyAvLyA2XG4gICAgaWYgKCFpc05lZ2F0aXZlTEUoc18sIFApKVxuICAgICAgICBzXyA9IG1vZCgtc18pO1xuICAgIGlmICghTnNfRF9pc19zcSlcbiAgICAgICAgcyA9IHNfOyAvLyA3XG4gICAgaWYgKCFOc19EX2lzX3NxKVxuICAgICAgICBjID0gcjsgLy8gOFxuICAgIGNvbnN0IE50ID0gbW9kKGMgKiAociAtIF8xbikgKiBEX01JTlVTX09ORV9TUSAtIEQpOyAvLyA5XG4gICAgY29uc3QgczIgPSBzICogcztcbiAgICBjb25zdCBXMCA9IG1vZCgocyArIHMpICogRCk7IC8vIDEwXG4gICAgY29uc3QgVzEgPSBtb2QoTnQgKiBTUVJUX0FEX01JTlVTX09ORSk7IC8vIDExXG4gICAgY29uc3QgVzIgPSBtb2QoXzFuIC0gczIpOyAvLyAxMlxuICAgIGNvbnN0IFczID0gbW9kKF8xbiArIHMyKTsgLy8gMTNcbiAgICByZXR1cm4gbmV3IGVkMjU1MTkuRXh0ZW5kZWRQb2ludChtb2QoVzAgKiBXMyksIG1vZChXMiAqIFcxKSwgbW9kKFcxICogVzMpLCBtb2QoVzAgKiBXMikpO1xufVxuLyoqXG4gKiBFYWNoIGVkMjU1MTkvRXh0ZW5kZWRQb2ludCBoYXMgOCBkaWZmZXJlbnQgZXF1aXZhbGVudCBwb2ludHMuIFRoaXMgY2FuIGJlXG4gKiBhIHNvdXJjZSBvZiBidWdzIGZvciBwcm90b2NvbHMgbGlrZSByaW5nIHNpZ25hdHVyZXMuIFJpc3RyZXR0byB3YXMgY3JlYXRlZCB0byBzb2x2ZSB0aGlzLlxuICogUmlzdHJldHRvIHBvaW50IG9wZXJhdGVzIGluIFg6WTpaOlQgZXh0ZW5kZWQgY29vcmRpbmF0ZXMgbGlrZSBFeHRlbmRlZFBvaW50LFxuICogYnV0IGl0IHNob3VsZCB3b3JrIGluIGl0cyBvd24gbmFtZXNwYWNlOiBkbyBub3QgY29tYmluZSB0aG9zZSB0d28uXG4gKiBodHRwczovL2RhdGF0cmFja2VyLmlldGYub3JnL2RvYy9odG1sL2RyYWZ0LWlydGYtY2ZyZy1yaXN0cmV0dG8yNTUtZGVjYWY0NDhcbiAqL1xuY2xhc3MgUmlzdFBvaW50IHtcbiAgICAvLyBQcml2YXRlIHByb3BlcnR5IHRvIGRpc2NvdXJhZ2UgY29tYmluaW5nIEV4dGVuZGVkUG9pbnQgKyBSaXN0cmV0dG9Qb2ludFxuICAgIC8vIEFsd2F5cyB1c2UgUmlzdHJldHRvIGVuY29kaW5nL2RlY29kaW5nIGluc3RlYWQuXG4gICAgY29uc3RydWN0b3IoZXApIHtcbiAgICAgICAgdGhpcy5lcCA9IGVwO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUFmZmluZShhcCkge1xuICAgICAgICByZXR1cm4gbmV3IFJpc3RQb2ludChlZDI1NTE5LkV4dGVuZGVkUG9pbnQuZnJvbUFmZmluZShhcCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYWtlcyB1bmlmb3JtIG91dHB1dCBvZiA2NC1ieXRlIGhhc2ggZnVuY3Rpb24gbGlrZSBzaGE1MTIgYW5kIGNvbnZlcnRzIGl0IHRvIGBSaXN0cmV0dG9Qb2ludGAuXG4gICAgICogVGhlIGhhc2gtdG8tZ3JvdXAgb3BlcmF0aW9uIGFwcGxpZXMgRWxsaWdhdG9yIHR3aWNlIGFuZCBhZGRzIHRoZSByZXN1bHRzLlxuICAgICAqICoqTm90ZToqKiB0aGlzIGlzIG9uZS13YXkgbWFwLCB0aGVyZSBpcyBubyBjb252ZXJzaW9uIGZyb20gcG9pbnQgdG8gaGFzaC5cbiAgICAgKiBodHRwczovL3Jpc3RyZXR0by5ncm91cC9mb3JtdWxhcy9lbGxpZ2F0b3IuaHRtbFxuICAgICAqIEBwYXJhbSBoZXggNjQtYnl0ZSBvdXRwdXQgb2YgYSBoYXNoIGZ1bmN0aW9uXG4gICAgICovXG4gICAgc3RhdGljIGhhc2hUb0N1cnZlKGhleCkge1xuICAgICAgICBoZXggPSBlbnN1cmVCeXRlcygncmlzdHJldHRvSGFzaCcsIGhleCwgNjQpO1xuICAgICAgICBjb25zdCByMSA9IGJ5dGVzMjU1VG9OdW1iZXJMRShoZXguc2xpY2UoMCwgMzIpKTtcbiAgICAgICAgY29uc3QgUjEgPSBjYWxjRWxsaWdhdG9yUmlzdHJldHRvTWFwKHIxKTtcbiAgICAgICAgY29uc3QgcjIgPSBieXRlczI1NVRvTnVtYmVyTEUoaGV4LnNsaWNlKDMyLCA2NCkpO1xuICAgICAgICBjb25zdCBSMiA9IGNhbGNFbGxpZ2F0b3JSaXN0cmV0dG9NYXAocjIpO1xuICAgICAgICByZXR1cm4gbmV3IFJpc3RQb2ludChSMS5hZGQoUjIpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydHMgcmlzdHJldHRvLWVuY29kZWQgc3RyaW5nIHRvIHJpc3RyZXR0byBwb2ludC5cbiAgICAgKiBodHRwczovL3Jpc3RyZXR0by5ncm91cC9mb3JtdWxhcy9kZWNvZGluZy5odG1sXG4gICAgICogQHBhcmFtIGhleCBSaXN0cmV0dG8tZW5jb2RlZCAzMiBieXRlcy4gTm90IGV2ZXJ5IDMyLWJ5dGUgc3RyaW5nIGlzIHZhbGlkIHJpc3RyZXR0byBlbmNvZGluZ1xuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tSGV4KGhleCkge1xuICAgICAgICBoZXggPSBlbnN1cmVCeXRlcygncmlzdHJldHRvSGV4JywgaGV4LCAzMik7XG4gICAgICAgIGNvbnN0IHsgYSwgZCB9ID0gZWQyNTUxOS5DVVJWRTtcbiAgICAgICAgY29uc3QgUCA9IGVkMjU1MTkuQ1VSVkUuRnAuT1JERVI7XG4gICAgICAgIGNvbnN0IG1vZCA9IGVkMjU1MTkuQ1VSVkUuRnAuY3JlYXRlO1xuICAgICAgICBjb25zdCBlbXNnID0gJ1Jpc3RyZXR0b1BvaW50LmZyb21IZXg6IHRoZSBoZXggaXMgbm90IHZhbGlkIGVuY29kaW5nIG9mIFJpc3RyZXR0b1BvaW50JztcbiAgICAgICAgY29uc3QgcyA9IGJ5dGVzMjU1VG9OdW1iZXJMRShoZXgpO1xuICAgICAgICAvLyAxLiBDaGVjayB0aGF0IHNfYnl0ZXMgaXMgdGhlIGNhbm9uaWNhbCBlbmNvZGluZyBvZiBhIGZpZWxkIGVsZW1lbnQsIG9yIGVsc2UgYWJvcnQuXG4gICAgICAgIC8vIDMuIENoZWNrIHRoYXQgcyBpcyBub24tbmVnYXRpdmUsIG9yIGVsc2UgYWJvcnRcbiAgICAgICAgaWYgKCFlcXVhbEJ5dGVzKG51bWJlclRvQnl0ZXNMRShzLCAzMiksIGhleCkgfHwgaXNOZWdhdGl2ZUxFKHMsIFApKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVtc2cpO1xuICAgICAgICBjb25zdCBzMiA9IG1vZChzICogcyk7XG4gICAgICAgIGNvbnN0IHUxID0gbW9kKF8xbiArIGEgKiBzMik7IC8vIDQgKGEgaXMgLTEpXG4gICAgICAgIGNvbnN0IHUyID0gbW9kKF8xbiAtIGEgKiBzMik7IC8vIDVcbiAgICAgICAgY29uc3QgdTFfMiA9IG1vZCh1MSAqIHUxKTtcbiAgICAgICAgY29uc3QgdTJfMiA9IG1vZCh1MiAqIHUyKTtcbiAgICAgICAgY29uc3QgdiA9IG1vZChhICogZCAqIHUxXzIgLSB1Ml8yKTsgLy8gNlxuICAgICAgICBjb25zdCB7IGlzVmFsaWQsIHZhbHVlOiBJIH0gPSBpbnZlcnRTcXJ0KG1vZCh2ICogdTJfMikpOyAvLyA3XG4gICAgICAgIGNvbnN0IER4ID0gbW9kKEkgKiB1Mik7IC8vIDhcbiAgICAgICAgY29uc3QgRHkgPSBtb2QoSSAqIER4ICogdik7IC8vIDlcbiAgICAgICAgbGV0IHggPSBtb2QoKHMgKyBzKSAqIER4KTsgLy8gMTBcbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRSh4LCBQKSlcbiAgICAgICAgICAgIHggPSBtb2QoLXgpOyAvLyAxMFxuICAgICAgICBjb25zdCB5ID0gbW9kKHUxICogRHkpOyAvLyAxMVxuICAgICAgICBjb25zdCB0ID0gbW9kKHggKiB5KTsgLy8gMTJcbiAgICAgICAgaWYgKCFpc1ZhbGlkIHx8IGlzTmVnYXRpdmVMRSh0LCBQKSB8fCB5ID09PSBfMG4pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZW1zZyk7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KG5ldyBlZDI1NTE5LkV4dGVuZGVkUG9pbnQoeCwgeSwgXzFuLCB0KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZXMgcmlzdHJldHRvIHBvaW50IHRvIFVpbnQ4QXJyYXkuXG4gICAgICogaHR0cHM6Ly9yaXN0cmV0dG8uZ3JvdXAvZm9ybXVsYXMvZW5jb2RpbmcuaHRtbFxuICAgICAqL1xuICAgIHRvUmF3Qnl0ZXMoKSB7XG4gICAgICAgIGxldCB7IGV4OiB4LCBleTogeSwgZXo6IHosIGV0OiB0IH0gPSB0aGlzLmVwO1xuICAgICAgICBjb25zdCBQID0gZWQyNTUxOS5DVVJWRS5GcC5PUkRFUjtcbiAgICAgICAgY29uc3QgbW9kID0gZWQyNTUxOS5DVVJWRS5GcC5jcmVhdGU7XG4gICAgICAgIGNvbnN0IHUxID0gbW9kKG1vZCh6ICsgeSkgKiBtb2QoeiAtIHkpKTsgLy8gMVxuICAgICAgICBjb25zdCB1MiA9IG1vZCh4ICogeSk7IC8vIDJcbiAgICAgICAgLy8gU3F1YXJlIHJvb3QgYWx3YXlzIGV4aXN0c1xuICAgICAgICBjb25zdCB1MnNxID0gbW9kKHUyICogdTIpO1xuICAgICAgICBjb25zdCB7IHZhbHVlOiBpbnZzcXJ0IH0gPSBpbnZlcnRTcXJ0KG1vZCh1MSAqIHUyc3EpKTsgLy8gM1xuICAgICAgICBjb25zdCBEMSA9IG1vZChpbnZzcXJ0ICogdTEpOyAvLyA0XG4gICAgICAgIGNvbnN0IEQyID0gbW9kKGludnNxcnQgKiB1Mik7IC8vIDVcbiAgICAgICAgY29uc3QgekludiA9IG1vZChEMSAqIEQyICogdCk7IC8vIDZcbiAgICAgICAgbGV0IEQ7IC8vIDdcbiAgICAgICAgaWYgKGlzTmVnYXRpdmVMRSh0ICogekludiwgUCkpIHtcbiAgICAgICAgICAgIGxldCBfeCA9IG1vZCh5ICogU1FSVF9NMSk7XG4gICAgICAgICAgICBsZXQgX3kgPSBtb2QoeCAqIFNRUlRfTTEpO1xuICAgICAgICAgICAgeCA9IF94O1xuICAgICAgICAgICAgeSA9IF95O1xuICAgICAgICAgICAgRCA9IG1vZChEMSAqIElOVlNRUlRfQV9NSU5VU19EKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIEQgPSBEMjsgLy8gOFxuICAgICAgICB9XG4gICAgICAgIGlmIChpc05lZ2F0aXZlTEUoeCAqIHpJbnYsIFApKVxuICAgICAgICAgICAgeSA9IG1vZCgteSk7IC8vIDlcbiAgICAgICAgbGV0IHMgPSBtb2QoKHogLSB5KSAqIEQpOyAvLyAxMCAoY2hlY2sgZm9vdGVyJ3Mgbm90ZSwgbm8gc3FydCgtYSkpXG4gICAgICAgIGlmIChpc05lZ2F0aXZlTEUocywgUCkpXG4gICAgICAgICAgICBzID0gbW9kKC1zKTtcbiAgICAgICAgcmV0dXJuIG51bWJlclRvQnl0ZXNMRShzLCAzMik7IC8vIDExXG4gICAgfVxuICAgIHRvSGV4KCkge1xuICAgICAgICByZXR1cm4gYnl0ZXNUb0hleCh0aGlzLnRvUmF3Qnl0ZXMoKSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b0hleCgpO1xuICAgIH1cbiAgICAvLyBDb21wYXJlIG9uZSBwb2ludCB0byBhbm90aGVyLlxuICAgIGVxdWFscyhvdGhlcikge1xuICAgICAgICBhc3NlcnRSc3RQb2ludChvdGhlcik7XG4gICAgICAgIGNvbnN0IHsgZXg6IFgxLCBleTogWTEgfSA9IHRoaXMuZXA7XG4gICAgICAgIGNvbnN0IHsgZXg6IFgyLCBleTogWTIgfSA9IG90aGVyLmVwO1xuICAgICAgICBjb25zdCBtb2QgPSBlZDI1NTE5LkNVUlZFLkZwLmNyZWF0ZTtcbiAgICAgICAgLy8gKHgxICogeTIgPT0geTEgKiB4MikgfCAoeTEgKiB5MiA9PSB4MSAqIHgyKVxuICAgICAgICBjb25zdCBvbmUgPSBtb2QoWDEgKiBZMikgPT09IG1vZChZMSAqIFgyKTtcbiAgICAgICAgY29uc3QgdHdvID0gbW9kKFkxICogWTIpID09PSBtb2QoWDEgKiBYMik7XG4gICAgICAgIHJldHVybiBvbmUgfHwgdHdvO1xuICAgIH1cbiAgICBhZGQob3RoZXIpIHtcbiAgICAgICAgYXNzZXJ0UnN0UG9pbnQob3RoZXIpO1xuICAgICAgICByZXR1cm4gbmV3IFJpc3RQb2ludCh0aGlzLmVwLmFkZChvdGhlci5lcCkpO1xuICAgIH1cbiAgICBzdWJ0cmFjdChvdGhlcikge1xuICAgICAgICBhc3NlcnRSc3RQb2ludChvdGhlcik7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAuc3VidHJhY3Qob3RoZXIuZXApKTtcbiAgICB9XG4gICAgbXVsdGlwbHkoc2NhbGFyKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAubXVsdGlwbHkoc2NhbGFyKSk7XG4gICAgfVxuICAgIG11bHRpcGx5VW5zYWZlKHNjYWxhcikge1xuICAgICAgICByZXR1cm4gbmV3IFJpc3RQb2ludCh0aGlzLmVwLm11bHRpcGx5VW5zYWZlKHNjYWxhcikpO1xuICAgIH1cbiAgICBkb3VibGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAuZG91YmxlKCkpO1xuICAgIH1cbiAgICBuZWdhdGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUmlzdFBvaW50KHRoaXMuZXAubmVnYXRlKCkpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBSaXN0cmV0dG9Qb2ludCA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4ge1xuICAgIGlmICghUmlzdFBvaW50LkJBU0UpXG4gICAgICAgIFJpc3RQb2ludC5CQVNFID0gbmV3IFJpc3RQb2ludChlZDI1NTE5LkV4dGVuZGVkUG9pbnQuQkFTRSk7XG4gICAgaWYgKCFSaXN0UG9pbnQuWkVSTylcbiAgICAgICAgUmlzdFBvaW50LlpFUk8gPSBuZXcgUmlzdFBvaW50KGVkMjU1MTkuRXh0ZW5kZWRQb2ludC5aRVJPKTtcbiAgICByZXR1cm4gUmlzdFBvaW50O1xufSkoKTtcbi8vIEhhc2hpbmcgdG8gcmlzdHJldHRvMjU1LiBodHRwczovL3d3dy5yZmMtZWRpdG9yLm9yZy9yZmMvcmZjOTM4MCNhcHBlbmRpeC1CXG5leHBvcnQgY29uc3QgaGFzaFRvUmlzdHJldHRvMjU1ID0gKG1zZywgb3B0aW9ucykgPT4ge1xuICAgIGNvbnN0IGQgPSBvcHRpb25zLkRTVDtcbiAgICBjb25zdCBEU1QgPSB0eXBlb2YgZCA9PT0gJ3N0cmluZycgPyB1dGY4VG9CeXRlcyhkKSA6IGQ7XG4gICAgY29uc3QgdW5pZm9ybV9ieXRlcyA9IGV4cGFuZF9tZXNzYWdlX3htZChtc2csIERTVCwgNjQsIHNoYTUxMik7XG4gICAgY29uc3QgUCA9IFJpc3RQb2ludC5oYXNoVG9DdXJ2ZSh1bmlmb3JtX2J5dGVzKTtcbiAgICByZXR1cm4gUDtcbn07XG5leHBvcnQgY29uc3QgaGFzaF90b19yaXN0cmV0dG8yNTUgPSBoYXNoVG9SaXN0cmV0dG8yNTU7IC8vIGxlZ2FjeVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZWQyNTUxOS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/ed25519.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js":
/*!*****************************************************!*\
  !*** ./node_modules/@noble/curves/esm/secp256k1.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   encodeToCurve: function() { return /* binding */ encodeToCurve; },\n/* harmony export */   hashToCurve: function() { return /* binding */ hashToCurve; },\n/* harmony export */   schnorr: function() { return /* binding */ schnorr; },\n/* harmony export */   secp256k1: function() { return /* binding */ secp256k1; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @noble/hashes/sha256 */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js\");\n/* harmony import */ var _noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @noble/hashes/utils */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n/* harmony import */ var _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract/modular.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/modular.js\");\n/* harmony import */ var _abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abstract/weierstrass.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/weierstrass.js\");\n/* harmony import */ var _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstract/utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/utils.js\");\n/* harmony import */ var _abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./abstract/hash-to-curve.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/abstract/hash-to-curve.js\");\n/* harmony import */ var _shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_shortw_utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/_shortw_utils.js\");\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n\n\n\n\n\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a, b) => (a + b / _2n) / b;\n/**\n * √n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y) {\n    const P = secp256k1P;\n    // prettier-ignore\n    const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    // prettier-ignore\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = (y * y * y) % P; // x^3, 11\n    const b3 = (b2 * b2 * y) % P; // x^7\n    const b6 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b3, _3n, P) * b3) % P;\n    const b9 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b6, _3n, P) * b3) % P;\n    const b11 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b9, _2n, P) * b2) % P;\n    const b22 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b11, _11n, P) * b11) % P;\n    const b44 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b22, _22n, P) * b22) % P;\n    const b88 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b44, _44n, P) * b44) % P;\n    const b176 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b88, _88n, P) * b88) % P;\n    const b220 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b176, _44n, P) * b44) % P;\n    const b223 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b220, _3n, P) * b3) % P;\n    const t1 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(b223, _23n, P) * b22) % P;\n    const t2 = ((0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t1, _6n, P) * b2) % P;\n    const root = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.pow2)(t2, _2n, P);\n    if (!Fp.eql(Fp.sqr(root), y))\n        throw new Error('Cannot find square root');\n    return root;\n}\nconst Fp = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.Field)(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\nconst secp256k1 = (0,_shortw_utils_js__WEBPACK_IMPORTED_MODULE_1__.createCurve)({\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7), // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975\n    Fp, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    /**\n     * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n     * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n     * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n     * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066\n     */\n    endo: {\n        beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n        splitScalar: (k) => {\n            const n = secp256k1N;\n            const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n            const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n            const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n            const b2 = a1;\n            const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n            const c1 = divNearest(b2 * k, n);\n            const c2 = divNearest(-b1 * k, n);\n            let k1 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(k - c1 * a1 - c2 * a2, n);\n            let k2 = (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(-c1 * b1 - c2 * b2, n);\n            const k1neg = k1 > POW_2_128;\n            const k2neg = k2 > POW_2_128;\n            if (k1neg)\n                k1 = n - k1;\n            if (k2neg)\n                k2 = n - k2;\n            if (k1 > POW_2_128 || k2 > POW_2_128) {\n                throw new Error('splitScalar: Endomorphism failed, k=' + k);\n            }\n            return { k1neg, k1, k2neg, k2 };\n        },\n    },\n}, _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256);\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\nconst fe = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1P;\nconst ge = (x) => typeof x === 'bigint' && _0n < x && x < secp256k1N;\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES = {};\nfunction taggedHash(tag, ...messages) {\n    let tagP = TAGGED_HASH_PREFIXES[tag];\n    if (tagP === undefined) {\n        const tagH = (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n        tagP = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagH, tagH);\n        TAGGED_HASH_PREFIXES[tag] = tagP;\n    }\n    return (0,_noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256)((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.concatBytes)(tagP, ...messages));\n}\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n) => (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE)(n, 32);\nconst modP = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1P);\nconst modN = (x) => (0,_abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod)(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv) {\n    let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n    let p = Point.fromPrivateKey(d_); // P = d'⋅G; 0 < d' < n check is done inside\n    const scalar = p.hasEvenY() ? d_ : modN(-d_);\n    return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x) {\n    if (!fe(x))\n        throw new Error('bad x: need 0 < x < p'); // Fail if x ≥ p.\n    const xx = modP(x * x);\n    const c = modP(xx * x + BigInt(7)); // Let c = x³ + 7 mod p.\n    let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n    if (y % _2n !== _0n)\n        y = modP(-y); // Return the unique point P such that x(P) = x and\n    const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n    p.assertValidity();\n    return p;\n}\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args) {\n    return modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/challenge', ...args)));\n}\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey) {\n    return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'≥n. Ret bytes(d'⋅G)\n}\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(message, privateKey, auxRand = (0,_noble_hashes_utils__WEBPACK_IMPORTED_MODULE_4__.randomBytes)(32)) {\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n    const a = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n    const t = numTo32b(d ^ (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n    const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n    const k_ = modN((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(rand)); // Let k' = int(rand) mod n\n    if (k_ === _0n)\n        throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n    const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'⋅G.\n    const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n    const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n    sig.set(rx, 0);\n    sig.set(numTo32b(modN(k + e * d)), 32);\n    // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n    if (!schnorrVerify(sig, m, px))\n        throw new Error('sign: Invalid signature produced');\n    return sig;\n}\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature, message, publicKey) {\n    const sig = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('signature', signature, 64);\n    const m = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('message', message);\n    const pub = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.ensureBytes)('publicKey', publicKey, 32);\n    try {\n        const P = lift_x((0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(pub)); // P = lift_x(int(pk)); fail if that fails\n        const r = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r ≥ p.\n        if (!fe(r))\n            return false;\n        const s = (0,_abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE)(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s ≥ n.\n        if (!ge(s))\n            return false;\n        const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n        const R = GmulAdd(P, s, modN(-e)); // R = s⋅G - e⋅P\n        if (!R || !R.hasEvenY() || R.toAffine().x !== r)\n            return false; // -eP == (n-e)P\n        return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R) ≠ r.\n    }\n    catch (error) {\n        return false;\n    }\n}\nconst schnorr = /* @__PURE__ */ (() => ({\n    getPublicKey: schnorrGetPublicKey,\n    sign: schnorrSign,\n    verify: schnorrVerify,\n    utils: {\n        randomPrivateKey: secp256k1.utils.randomPrivateKey,\n        lift_x,\n        pointToBytes,\n        numberToBytesBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.numberToBytesBE,\n        bytesToNumberBE: _abstract_utils_js__WEBPACK_IMPORTED_MODULE_3__.bytesToNumberBE,\n        taggedHash,\n        mod: _abstract_modular_js__WEBPACK_IMPORTED_MODULE_0__.mod,\n    },\n}))();\nconst isoMap = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.isogenyMap)(Fp, [\n    // xNum\n    [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n    ],\n    // xDen\n    [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n    // yNum\n    [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n    ],\n    // yDen\n    [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n    ],\n].map((i) => i.map((j) => BigInt(j)))))();\nconst mapSWU = /* @__PURE__ */ (() => (0,_abstract_weierstrass_js__WEBPACK_IMPORTED_MODULE_6__.mapToCurveSimpleSWU)(Fp, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fp.create(BigInt('-11')),\n}))();\nconst htf = /* @__PURE__ */ (() => (0,_abstract_hash_to_curve_js__WEBPACK_IMPORTED_MODULE_5__.createHasher)(secp256k1.ProjectivePoint, (scalars) => {\n    const { x, y } = mapSWU(Fp.create(scalars[0]));\n    return isoMap(x, y);\n}, {\n    DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n    encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n    p: Fp.ORDER,\n    m: 1,\n    k: 128,\n    expand: 'xmd',\n    hash: _noble_hashes_sha256__WEBPACK_IMPORTED_MODULE_2__.sha256,\n}))();\nconst hashToCurve = /* @__PURE__ */ (() => htf.hashToCurve)();\nconst encodeToCurve = /* @__PURE__ */ (() => htf.encodeToCurve)();\n//# sourceMappingURL=secp256k1.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL2VzbS9zZWNwMjU2azEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUM4QztBQUNJO0FBQ087QUFDTztBQUNpQztBQUMxQjtBQUN0QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsa0NBQWtDO0FBQ2xDLGdCQUFnQiwwREFBSTtBQUNwQixnQkFBZ0IsMERBQUk7QUFDcEIsaUJBQWlCLDBEQUFJO0FBQ3JCLGlCQUFpQiwwREFBSTtBQUNyQixpQkFBaUIsMERBQUk7QUFDckIsaUJBQWlCLDBEQUFJO0FBQ3JCLGtCQUFrQiwwREFBSTtBQUN0QixrQkFBa0IsMERBQUk7QUFDdEIsa0JBQWtCLDBEQUFJO0FBQ3RCLGdCQUFnQiwwREFBSTtBQUNwQixnQkFBZ0IsMERBQUk7QUFDcEIsaUJBQWlCLDBEQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyREFBSyxxQ0FBcUMsZUFBZTtBQUM3RCxrQkFBa0IsNkRBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0EscUJBQXFCLHlEQUFHO0FBQ3hCLHFCQUFxQix5REFBRztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsU0FBUztBQUNULEtBQUs7QUFDTCxDQUFDLEVBQUUsd0RBQU07QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiw0REFBTTtBQUMzQixlQUFlLCtEQUFXO0FBQzFCO0FBQ0E7QUFDQSxXQUFXLDREQUFNLENBQUMsK0RBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLG1FQUFlO0FBQ3ZDLG9CQUFvQix5REFBRztBQUN2QixvQkFBb0IseURBQUc7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Qsc0NBQXNDLGFBQWE7QUFDbkQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7QUFDbEQ7QUFDQSx3Q0FBd0M7QUFDeEMsd0JBQXdCO0FBQ3hCO0FBQ0Esc0JBQXNCO0FBQ3RCLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixtRUFBZTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0VBQVc7QUFDL0QsY0FBYywrREFBVztBQUN6QixZQUFZLHVCQUF1QixtQ0FBbUM7QUFDdEUsY0FBYywrREFBVywwQkFBMEI7QUFDbkQsMkJBQTJCLG1FQUFlLGlDQUFpQztBQUMzRSx3REFBd0Q7QUFDeEQsb0JBQW9CLG1FQUFlLFNBQVM7QUFDNUM7QUFDQSxtREFBbUQ7QUFDbkQsWUFBWSx1QkFBdUIsMkJBQTJCO0FBQzlELG9DQUFvQztBQUNwQyxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtEQUFXO0FBQzNCLGNBQWMsK0RBQVc7QUFDekIsZ0JBQWdCLCtEQUFXO0FBQzNCO0FBQ0EseUJBQXlCLG1FQUFlLFFBQVEsd0JBQXdCO0FBQ3hFLGtCQUFrQixtRUFBZSx1QkFBdUIsMkJBQTJCO0FBQ25GO0FBQ0E7QUFDQSxrQkFBa0IsbUVBQWUsd0JBQXdCLDRCQUE0QjtBQUNyRjtBQUNBO0FBQ0EsOERBQThEO0FBQzlELDJDQUEyQztBQUMzQztBQUNBLDBCQUEwQjtBQUMxQixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsdUJBQXVCO0FBQ3ZCO0FBQ0EsV0FBVztBQUNYLEtBQUs7QUFDTCxDQUFDO0FBQ0Qsc0NBQXNDLHNFQUFVO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLDZFQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUNBQW1DLHdFQUFZO0FBQy9DLFlBQVksT0FBTztBQUNuQjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHdEQUFNO0FBQ2hCLENBQUM7QUFDTTtBQUNBO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvZXNtL3NlY3AyNTZrMS5qcz82MjA0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1jdXJ2ZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbmltcG9ydCB7IHNoYTI1NiB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvc2hhMjU2JztcbmltcG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSAnQG5vYmxlL2hhc2hlcy91dGlscyc7XG5pbXBvcnQgeyBGaWVsZCwgbW9kLCBwb3cyIH0gZnJvbSAnLi9hYnN0cmFjdC9tb2R1bGFyLmpzJztcbmltcG9ydCB7IG1hcFRvQ3VydmVTaW1wbGVTV1UgfSBmcm9tICcuL2Fic3RyYWN0L3dlaWVyc3RyYXNzLmpzJztcbmltcG9ydCB7IGJ5dGVzVG9OdW1iZXJCRSwgY29uY2F0Qnl0ZXMsIGVuc3VyZUJ5dGVzLCBudW1iZXJUb0J5dGVzQkUgfSBmcm9tICcuL2Fic3RyYWN0L3V0aWxzLmpzJztcbmltcG9ydCB7IGNyZWF0ZUhhc2hlciwgaXNvZ2VueU1hcCB9IGZyb20gJy4vYWJzdHJhY3QvaGFzaC10by1jdXJ2ZS5qcyc7XG5pbXBvcnQgeyBjcmVhdGVDdXJ2ZSB9IGZyb20gJy4vX3Nob3J0d191dGlscy5qcyc7XG5jb25zdCBzZWNwMjU2azFQID0gQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmZjMmYnKTtcbmNvbnN0IHNlY3AyNTZrMU4gPSBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmViYWFlZGNlNmFmNDhhMDNiYmZkMjVlOGNkMDM2NDE0MScpO1xuY29uc3QgXzFuID0gQmlnSW50KDEpO1xuY29uc3QgXzJuID0gQmlnSW50KDIpO1xuY29uc3QgZGl2TmVhcmVzdCA9IChhLCBiKSA9PiAoYSArIGIgLyBfMm4pIC8gYjtcbi8qKlxuICog4oiabiA9IG5eKChwKzEpLzQpIGZvciBmaWVsZHMgcCA9IDMgbW9kIDQuIFdlIHVud3JhcCB0aGUgbG9vcCBhbmQgbXVsdGlwbHkgYml0LWJ5LWJpdC5cbiAqIChQKzFuLzRuKS50b1N0cmluZygyKSB3b3VsZCBwcm9kdWNlIGJpdHMgWzIyM3ggMSwgMCwgMjJ4IDEsIDR4IDAsIDExLCAwMF1cbiAqL1xuZnVuY3Rpb24gc3FydE1vZCh5KSB7XG4gICAgY29uc3QgUCA9IHNlY3AyNTZrMVA7XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgY29uc3QgXzNuID0gQmlnSW50KDMpLCBfNm4gPSBCaWdJbnQoNiksIF8xMW4gPSBCaWdJbnQoMTEpLCBfMjJuID0gQmlnSW50KDIyKTtcbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBjb25zdCBfMjNuID0gQmlnSW50KDIzKSwgXzQ0biA9IEJpZ0ludCg0NCksIF84OG4gPSBCaWdJbnQoODgpO1xuICAgIGNvbnN0IGIyID0gKHkgKiB5ICogeSkgJSBQOyAvLyB4XjMsIDExXG4gICAgY29uc3QgYjMgPSAoYjIgKiBiMiAqIHkpICUgUDsgLy8geF43XG4gICAgY29uc3QgYjYgPSAocG93MihiMywgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjkgPSAocG93MihiNiwgXzNuLCBQKSAqIGIzKSAlIFA7XG4gICAgY29uc3QgYjExID0gKHBvdzIoYjksIF8ybiwgUCkgKiBiMikgJSBQO1xuICAgIGNvbnN0IGIyMiA9IChwb3cyKGIxMSwgXzExbiwgUCkgKiBiMTEpICUgUDtcbiAgICBjb25zdCBiNDQgPSAocG93MihiMjIsIF8yMm4sIFApICogYjIyKSAlIFA7XG4gICAgY29uc3QgYjg4ID0gKHBvdzIoYjQ0LCBfNDRuLCBQKSAqIGI0NCkgJSBQO1xuICAgIGNvbnN0IGIxNzYgPSAocG93MihiODgsIF84OG4sIFApICogYjg4KSAlIFA7XG4gICAgY29uc3QgYjIyMCA9IChwb3cyKGIxNzYsIF80NG4sIFApICogYjQ0KSAlIFA7XG4gICAgY29uc3QgYjIyMyA9IChwb3cyKGIyMjAsIF8zbiwgUCkgKiBiMykgJSBQO1xuICAgIGNvbnN0IHQxID0gKHBvdzIoYjIyMywgXzIzbiwgUCkgKiBiMjIpICUgUDtcbiAgICBjb25zdCB0MiA9IChwb3cyKHQxLCBfNm4sIFApICogYjIpICUgUDtcbiAgICBjb25zdCByb290ID0gcG93Mih0MiwgXzJuLCBQKTtcbiAgICBpZiAoIUZwLmVxbChGcC5zcXIocm9vdCksIHkpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBmaW5kIHNxdWFyZSByb290Jyk7XG4gICAgcmV0dXJuIHJvb3Q7XG59XG5jb25zdCBGcCA9IEZpZWxkKHNlY3AyNTZrMVAsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB7IHNxcnQ6IHNxcnRNb2QgfSk7XG5leHBvcnQgY29uc3Qgc2VjcDI1NmsxID0gY3JlYXRlQ3VydmUoe1xuICAgIGE6IEJpZ0ludCgwKSwgLy8gZXF1YXRpb24gcGFyYW1zOiBhLCBiXG4gICAgYjogQmlnSW50KDcpLCAvLyBTZWVtIHRvIGJlIHJpZ2lkOiBiaXRjb2ludGFsay5vcmcvaW5kZXgucGhwP3RvcGljPTI4OTc5NS5tc2czMTgzOTc1I21zZzMxODM5NzVcbiAgICBGcCwgLy8gRmllbGQncyBwcmltZTogMm4qKjI1Nm4gLSAybioqMzJuIC0gMm4qKjluIC0gMm4qKjhuIC0gMm4qKjduIC0gMm4qKjZuIC0gMm4qKjRuIC0gMW5cbiAgICBuOiBzZWNwMjU2azFOLCAvLyBDdXJ2ZSBvcmRlciwgdG90YWwgY291bnQgb2YgdmFsaWQgcG9pbnRzIGluIHRoZSBmaWVsZFxuICAgIC8vIEJhc2UgcG9pbnQgKHgsIHkpIGFrYSBnZW5lcmF0b3IgcG9pbnRcbiAgICBHeDogQmlnSW50KCc1NTA2NjI2MzAyMjI3NzM0MzY2OTU3ODcxODg5NTE2ODUzNDMyNjI1MDYwMzQ1Mzc3NzU5NDE3NTUwMDE4NzM2MDM4OTExNjcyOTI0MCcpLFxuICAgIEd5OiBCaWdJbnQoJzMyNjcwNTEwMDIwNzU4ODE2OTc4MDgzMDg1MTMwNTA3MDQzMTg0NDcxMjczMzgwNjU5MjQzMjc1OTM4OTA0MzM1NzU3MzM3NDgyNDI0JyksXG4gICAgaDogQmlnSW50KDEpLCAvLyBDb2ZhY3RvclxuICAgIGxvd1M6IHRydWUsIC8vIEFsbG93IG9ubHkgbG93LVMgc2lnbmF0dXJlcyBieSBkZWZhdWx0IGluIHNpZ24oKSBhbmQgdmVyaWZ5KClcbiAgICAvKipcbiAgICAgKiBzZWNwMjU2azEgYmVsb25ncyB0byBLb2JsaXR6IGN1cnZlczogaXQgaGFzIGVmZmljaWVudGx5IGNvbXB1dGFibGUgZW5kb21vcnBoaXNtLlxuICAgICAqIEVuZG9tb3JwaGlzbSB1c2VzIDJ4IGxlc3MgUkFNLCBzcGVlZHMgdXAgcHJlY29tcHV0YXRpb24gYnkgMnggYW5kIEVDREggLyBrZXkgcmVjb3ZlcnkgYnkgMjAlLlxuICAgICAqIEZvciBwcmVjb21wdXRlZCB3TkFGIGl0IHRyYWRlcyBvZmYgMS8yIGluaXQgdGltZSAmIDEvMyByYW0gZm9yIDIwJSBwZXJmIGhpdC5cbiAgICAgKiBFeHBsYW5hdGlvbjogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGF1bG1pbGxyL2ViNjcwODA2NzkzZTg0ZGY2MjhhN2M0MzRhODczMDY2XG4gICAgICovXG4gICAgZW5kbzoge1xuICAgICAgICBiZXRhOiBCaWdJbnQoJzB4N2FlOTZhMmI2NTdjMDcxMDZlNjQ0NzllYWMzNDM0ZTk5Y2YwNDk3NTEyZjU4OTk1YzEzOTZjMjg3MTk1MDFlZScpLFxuICAgICAgICBzcGxpdFNjYWxhcjogKGspID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBzZWNwMjU2azFOO1xuICAgICAgICAgICAgY29uc3QgYTEgPSBCaWdJbnQoJzB4MzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnKTtcbiAgICAgICAgICAgIGNvbnN0IGIxID0gLV8xbiAqIEJpZ0ludCgnMHhlNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycpO1xuICAgICAgICAgICAgY29uc3QgYTIgPSBCaWdJbnQoJzB4MTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4Jyk7XG4gICAgICAgICAgICBjb25zdCBiMiA9IGExO1xuICAgICAgICAgICAgY29uc3QgUE9XXzJfMTI4ID0gQmlnSW50KCcweDEwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMCcpOyAvLyAoMm4qKjEyOG4pLnRvU3RyaW5nKDE2KVxuICAgICAgICAgICAgY29uc3QgYzEgPSBkaXZOZWFyZXN0KGIyICogaywgbik7XG4gICAgICAgICAgICBjb25zdCBjMiA9IGRpdk5lYXJlc3QoLWIxICogaywgbik7XG4gICAgICAgICAgICBsZXQgazEgPSBtb2QoayAtIGMxICogYTEgLSBjMiAqIGEyLCBuKTtcbiAgICAgICAgICAgIGxldCBrMiA9IG1vZCgtYzEgKiBiMSAtIGMyICogYjIsIG4pO1xuICAgICAgICAgICAgY29uc3QgazFuZWcgPSBrMSA+IFBPV18yXzEyODtcbiAgICAgICAgICAgIGNvbnN0IGsybmVnID0gazIgPiBQT1dfMl8xMjg7XG4gICAgICAgICAgICBpZiAoazFuZWcpXG4gICAgICAgICAgICAgICAgazEgPSBuIC0gazE7XG4gICAgICAgICAgICBpZiAoazJuZWcpXG4gICAgICAgICAgICAgICAgazIgPSBuIC0gazI7XG4gICAgICAgICAgICBpZiAoazEgPiBQT1dfMl8xMjggfHwgazIgPiBQT1dfMl8xMjgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NwbGl0U2NhbGFyOiBFbmRvbW9ycGhpc20gZmFpbGVkLCBrPScgKyBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7IGsxbmVnLCBrMSwgazJuZWcsIGsyIH07XG4gICAgICAgIH0sXG4gICAgfSxcbn0sIHNoYTI1Nik7XG4vLyBTY2hub3JyIHNpZ25hdHVyZXMgYXJlIHN1cGVyaW9yIHRvIEVDRFNBIGZyb20gYWJvdmUuIEJlbG93IGlzIFNjaG5vcnItc3BlY2lmaWMgQklQMDM0MCBjb2RlLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2JpdGNvaW4vYmlwcy9ibG9iL21hc3Rlci9iaXAtMDM0MC5tZWRpYXdpa2lcbmNvbnN0IF8wbiA9IEJpZ0ludCgwKTtcbmNvbnN0IGZlID0gKHgpID0+IHR5cGVvZiB4ID09PSAnYmlnaW50JyAmJiBfMG4gPCB4ICYmIHggPCBzZWNwMjU2azFQO1xuY29uc3QgZ2UgPSAoeCkgPT4gdHlwZW9mIHggPT09ICdiaWdpbnQnICYmIF8wbiA8IHggJiYgeCA8IHNlY3AyNTZrMU47XG4vKiogQW4gb2JqZWN0IG1hcHBpbmcgdGFncyB0byB0aGVpciB0YWdnZWQgaGFzaCBwcmVmaXggb2YgW1NIQTI1Nih0YWcpIHwgU0hBMjU2KHRhZyldICovXG5jb25zdCBUQUdHRURfSEFTSF9QUkVGSVhFUyA9IHt9O1xuZnVuY3Rpb24gdGFnZ2VkSGFzaCh0YWcsIC4uLm1lc3NhZ2VzKSB7XG4gICAgbGV0IHRhZ1AgPSBUQUdHRURfSEFTSF9QUkVGSVhFU1t0YWddO1xuICAgIGlmICh0YWdQID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgdGFnSCA9IHNoYTI1NihVaW50OEFycmF5LmZyb20odGFnLCAoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG4gICAgICAgIHRhZ1AgPSBjb25jYXRCeXRlcyh0YWdILCB0YWdIKTtcbiAgICAgICAgVEFHR0VEX0hBU0hfUFJFRklYRVNbdGFnXSA9IHRhZ1A7XG4gICAgfVxuICAgIHJldHVybiBzaGEyNTYoY29uY2F0Qnl0ZXModGFnUCwgLi4ubWVzc2FnZXMpKTtcbn1cbi8vIEVDRFNBIGNvbXBhY3QgcG9pbnRzIGFyZSAzMy1ieXRlLiBTY2hub3JyIGlzIDMyOiB3ZSBzdHJpcCBmaXJzdCBieXRlIDB4MDIgb3IgMHgwM1xuY29uc3QgcG9pbnRUb0J5dGVzID0gKHBvaW50KSA9PiBwb2ludC50b1Jhd0J5dGVzKHRydWUpLnNsaWNlKDEpO1xuY29uc3QgbnVtVG8zMmIgPSAobikgPT4gbnVtYmVyVG9CeXRlc0JFKG4sIDMyKTtcbmNvbnN0IG1vZFAgPSAoeCkgPT4gbW9kKHgsIHNlY3AyNTZrMVApO1xuY29uc3QgbW9kTiA9ICh4KSA9PiBtb2QoeCwgc2VjcDI1NmsxTik7XG5jb25zdCBQb2ludCA9IHNlY3AyNTZrMS5Qcm9qZWN0aXZlUG9pbnQ7XG5jb25zdCBHbXVsQWRkID0gKFEsIGEsIGIpID0+IFBvaW50LkJBU0UubXVsdGlwbHlBbmRBZGRVbnNhZmUoUSwgYSwgYik7XG4vLyBDYWxjdWxhdGUgcG9pbnQsIHNjYWxhciBhbmQgYnl0ZXNcbmZ1bmN0aW9uIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdikge1xuICAgIGxldCBkXyA9IHNlY3AyNTZrMS51dGlscy5ub3JtUHJpdmF0ZUtleVRvU2NhbGFyKHByaXYpOyAvLyBzYW1lIG1ldGhvZCBleGVjdXRlZCBpbiBmcm9tUHJpdmF0ZUtleVxuICAgIGxldCBwID0gUG9pbnQuZnJvbVByaXZhdGVLZXkoZF8pOyAvLyBQID0gZCfii4VHOyAwIDwgZCcgPCBuIGNoZWNrIGlzIGRvbmUgaW5zaWRlXG4gICAgY29uc3Qgc2NhbGFyID0gcC5oYXNFdmVuWSgpID8gZF8gOiBtb2ROKC1kXyk7XG4gICAgcmV0dXJuIHsgc2NhbGFyOiBzY2FsYXIsIGJ5dGVzOiBwb2ludFRvQnl0ZXMocCkgfTtcbn1cbi8qKlxuICogbGlmdF94IGZyb20gQklQMzQwLiBDb252ZXJ0IDMyLWJ5dGUgeCBjb29yZGluYXRlIHRvIGVsbGlwdGljIGN1cnZlIHBvaW50LlxuICogQHJldHVybnMgdmFsaWQgcG9pbnQgY2hlY2tlZCBmb3IgYmVpbmcgb24tY3VydmVcbiAqL1xuZnVuY3Rpb24gbGlmdF94KHgpIHtcbiAgICBpZiAoIWZlKHgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2JhZCB4OiBuZWVkIDAgPCB4IDwgcCcpOyAvLyBGYWlsIGlmIHgg4omlIHAuXG4gICAgY29uc3QgeHggPSBtb2RQKHggKiB4KTtcbiAgICBjb25zdCBjID0gbW9kUCh4eCAqIHggKyBCaWdJbnQoNykpOyAvLyBMZXQgYyA9IHjCsyArIDcgbW9kIHAuXG4gICAgbGV0IHkgPSBzcXJ0TW9kKGMpOyAvLyBMZXQgeSA9IGNeKHArMSkvNCBtb2QgcC5cbiAgICBpZiAoeSAlIF8ybiAhPT0gXzBuKVxuICAgICAgICB5ID0gbW9kUCgteSk7IC8vIFJldHVybiB0aGUgdW5pcXVlIHBvaW50IFAgc3VjaCB0aGF0IHgoUCkgPSB4IGFuZFxuICAgIGNvbnN0IHAgPSBuZXcgUG9pbnQoeCwgeSwgXzFuKTsgLy8geShQKSA9IHkgaWYgeSBtb2QgMiA9IDAgb3IgeShQKSA9IHAteSBvdGhlcndpc2UuXG4gICAgcC5hc3NlcnRWYWxpZGl0eSgpO1xuICAgIHJldHVybiBwO1xufVxuLyoqXG4gKiBDcmVhdGUgdGFnZ2VkIGhhc2gsIGNvbnZlcnQgaXQgdG8gYmlnaW50LCByZWR1Y2UgbW9kdWxvLW4uXG4gKi9cbmZ1bmN0aW9uIGNoYWxsZW5nZSguLi5hcmdzKSB7XG4gICAgcmV0dXJuIG1vZE4oYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvY2hhbGxlbmdlJywgLi4uYXJncykpKTtcbn1cbi8qKlxuICogU2Nobm9yciBwdWJsaWMga2V5IGlzIGp1c3QgYHhgIGNvb3JkaW5hdGUgb2YgUG9pbnQgYXMgcGVyIEJJUDM0MC5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yckdldFB1YmxpY0tleShwcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIHNjaG5vcnJHZXRFeHRQdWJLZXkocHJpdmF0ZUtleSkuYnl0ZXM7IC8vIGQnPWludChzaykuIEZhaWwgaWYgZCc9MCBvciBkJ+KJpW4uIFJldCBieXRlcyhkJ+KLhUcpXG59XG4vKipcbiAqIENyZWF0ZXMgU2Nobm9yciBzaWduYXR1cmUgYXMgcGVyIEJJUDM0MC4gVmVyaWZpZXMgaXRzZWxmIGJlZm9yZSByZXR1cm5pbmcgYW55dGhpbmcuXG4gKiBhdXhSYW5kIGlzIG9wdGlvbmFsIGFuZCBpcyBub3QgdGhlIHNvbGUgc291cmNlIG9mIGsgZ2VuZXJhdGlvbjogYmFkIENTUFJORyB3b24ndCBiZSBkYW5nZXJvdXMuXG4gKi9cbmZ1bmN0aW9uIHNjaG5vcnJTaWduKG1lc3NhZ2UsIHByaXZhdGVLZXksIGF1eFJhbmQgPSByYW5kb21CeXRlcygzMikpIHtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCB7IGJ5dGVzOiBweCwgc2NhbGFyOiBkIH0gPSBzY2hub3JyR2V0RXh0UHViS2V5KHByaXZhdGVLZXkpOyAvLyBjaGVja3MgZm9yIGlzV2l0aGluQ3VydmVPcmRlclxuICAgIGNvbnN0IGEgPSBlbnN1cmVCeXRlcygnYXV4UmFuZCcsIGF1eFJhbmQsIDMyKTsgLy8gQXV4aWxpYXJ5IHJhbmRvbSBkYXRhIGE6IGEgMzItYnl0ZSBhcnJheVxuICAgIGNvbnN0IHQgPSBudW1UbzMyYihkIF4gYnl0ZXNUb051bWJlckJFKHRhZ2dlZEhhc2goJ0JJUDAzNDAvYXV4JywgYSkpKTsgLy8gTGV0IHQgYmUgdGhlIGJ5dGUtd2lzZSB4b3Igb2YgYnl0ZXMoZCkgYW5kIGhhc2gvYXV4KGEpXG4gICAgY29uc3QgcmFuZCA9IHRhZ2dlZEhhc2goJ0JJUDAzNDAvbm9uY2UnLCB0LCBweCwgbSk7IC8vIExldCByYW5kID0gaGFzaC9ub25jZSh0IHx8IGJ5dGVzKFApIHx8IG0pXG4gICAgY29uc3Qga18gPSBtb2ROKGJ5dGVzVG9OdW1iZXJCRShyYW5kKSk7IC8vIExldCBrJyA9IGludChyYW5kKSBtb2QgblxuICAgIGlmIChrXyA9PT0gXzBuKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NpZ24gZmFpbGVkOiBrIGlzIHplcm8nKTsgLy8gRmFpbCBpZiBrJyA9IDAuXG4gICAgY29uc3QgeyBieXRlczogcngsIHNjYWxhcjogayB9ID0gc2Nobm9yckdldEV4dFB1YktleShrXyk7IC8vIExldCBSID0gayfii4VHLlxuICAgIGNvbnN0IGUgPSBjaGFsbGVuZ2UocngsIHB4LCBtKTsgLy8gTGV0IGUgPSBpbnQoaGFzaC9jaGFsbGVuZ2UoYnl0ZXMoUikgfHwgYnl0ZXMoUCkgfHwgbSkpIG1vZCBuLlxuICAgIGNvbnN0IHNpZyA9IG5ldyBVaW50OEFycmF5KDY0KTsgLy8gTGV0IHNpZyA9IGJ5dGVzKFIpIHx8IGJ5dGVzKChrICsgZWQpIG1vZCBuKS5cbiAgICBzaWcuc2V0KHJ4LCAwKTtcbiAgICBzaWcuc2V0KG51bVRvMzJiKG1vZE4oayArIGUgKiBkKSksIDMyKTtcbiAgICAvLyBJZiBWZXJpZnkoYnl0ZXMoUCksIG0sIHNpZykgKHNlZSBiZWxvdykgcmV0dXJucyBmYWlsdXJlLCBhYm9ydFxuICAgIGlmICghc2Nobm9yclZlcmlmeShzaWcsIG0sIHB4KSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaWduOiBJbnZhbGlkIHNpZ25hdHVyZSBwcm9kdWNlZCcpO1xuICAgIHJldHVybiBzaWc7XG59XG4vKipcbiAqIFZlcmlmaWVzIFNjaG5vcnIgc2lnbmF0dXJlLlxuICogV2lsbCBzd2FsbG93IGVycm9ycyAmIHJldHVybiBmYWxzZSBleGNlcHQgZm9yIGluaXRpYWwgdHlwZSB2YWxpZGF0aW9uIG9mIGFyZ3VtZW50cy5cbiAqL1xuZnVuY3Rpb24gc2Nobm9yclZlcmlmeShzaWduYXR1cmUsIG1lc3NhZ2UsIHB1YmxpY0tleSkge1xuICAgIGNvbnN0IHNpZyA9IGVuc3VyZUJ5dGVzKCdzaWduYXR1cmUnLCBzaWduYXR1cmUsIDY0KTtcbiAgICBjb25zdCBtID0gZW5zdXJlQnl0ZXMoJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgICBjb25zdCBwdWIgPSBlbnN1cmVCeXRlcygncHVibGljS2V5JywgcHVibGljS2V5LCAzMik7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgUCA9IGxpZnRfeChieXRlc1RvTnVtYmVyQkUocHViKSk7IC8vIFAgPSBsaWZ0X3goaW50KHBrKSk7IGZhaWwgaWYgdGhhdCBmYWlsc1xuICAgICAgICBjb25zdCByID0gYnl0ZXNUb051bWJlckJFKHNpZy5zdWJhcnJheSgwLCAzMikpOyAvLyBMZXQgciA9IGludChzaWdbMDozMl0pOyBmYWlsIGlmIHIg4omlIHAuXG4gICAgICAgIGlmICghZmUocikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHMgPSBieXRlc1RvTnVtYmVyQkUoc2lnLnN1YmFycmF5KDMyLCA2NCkpOyAvLyBMZXQgcyA9IGludChzaWdbMzI6NjRdKTsgZmFpbCBpZiBzIOKJpSBuLlxuICAgICAgICBpZiAoIWdlKHMpKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCBlID0gY2hhbGxlbmdlKG51bVRvMzJiKHIpLCBwb2ludFRvQnl0ZXMoUCksIG0pOyAvLyBpbnQoY2hhbGxlbmdlKGJ5dGVzKHIpfHxieXRlcyhQKXx8bSkpJW5cbiAgICAgICAgY29uc3QgUiA9IEdtdWxBZGQoUCwgcywgbW9kTigtZSkpOyAvLyBSID0gc+KLhUcgLSBl4ouFUFxuICAgICAgICBpZiAoIVIgfHwgIVIuaGFzRXZlblkoKSB8fCBSLnRvQWZmaW5lKCkueCAhPT0gcilcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gLWVQID09IChuLWUpUFxuICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gRmFpbCBpZiBpc19pbmZpbml0ZShSKSAvIG5vdCBoYXNfZXZlbl95KFIpIC8geChSKSDiiaAgci5cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgY29uc3Qgc2Nobm9yciA9IC8qIEBfX1BVUkVfXyAqLyAoKCkgPT4gKHtcbiAgICBnZXRQdWJsaWNLZXk6IHNjaG5vcnJHZXRQdWJsaWNLZXksXG4gICAgc2lnbjogc2Nobm9yclNpZ24sXG4gICAgdmVyaWZ5OiBzY2hub3JyVmVyaWZ5LFxuICAgIHV0aWxzOiB7XG4gICAgICAgIHJhbmRvbVByaXZhdGVLZXk6IHNlY3AyNTZrMS51dGlscy5yYW5kb21Qcml2YXRlS2V5LFxuICAgICAgICBsaWZ0X3gsXG4gICAgICAgIHBvaW50VG9CeXRlcyxcbiAgICAgICAgbnVtYmVyVG9CeXRlc0JFLFxuICAgICAgICBieXRlc1RvTnVtYmVyQkUsXG4gICAgICAgIHRhZ2dlZEhhc2gsXG4gICAgICAgIG1vZCxcbiAgICB9LFxufSkpKCk7XG5jb25zdCBpc29NYXAgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGlzb2dlbnlNYXAoRnAsIFtcbiAgICAvLyB4TnVtXG4gICAgW1xuICAgICAgICAnMHg4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZTM4ZGFhYWFhOGM3JyxcbiAgICAgICAgJzB4N2QzZDRjODBiYzMyMWQ1YjlmMzE1Y2VhN2ZkNDRjNWQ1OTVkMmZjMGJmNjNiOTJkZmZmMTA0NGYxN2M2NTgxJyxcbiAgICAgICAgJzB4NTM0YzMyOGQyM2YyMzRlNmUyYTQxM2RlY2EyNWNhZWNlNDUwNjE0NDAzN2M0MDMxNGVjYmQwYjUzZDlkZDI2MicsXG4gICAgICAgICcweDhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhlMzhkYWFhYWE4OGMnLFxuICAgIF0sXG4gICAgLy8geERlblxuICAgIFtcbiAgICAgICAgJzB4ZDM1NzcxMTkzZDk0OTE4YTljYTM0Y2NiYjdiNjQwZGQ4NmNkNDA5NTQyZjg0ODdkOWZlNmI3NDU3ODFlYjQ5YicsXG4gICAgICAgICcweGVkYWRjNmY2NDM4M2RjMWRmN2M0YjJkNTFiNTQyMjU0MDZkMzZiNjQxZjVlNDFiYmM1MmE1NjYxMmE4YzZkMTQnLFxuICAgICAgICAnMHgwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAxJywgLy8gTEFTVCAxXG4gICAgXSxcbiAgICAvLyB5TnVtXG4gICAgW1xuICAgICAgICAnMHg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YmRhMTJmNjg0YjhlMzhlMjNjJyxcbiAgICAgICAgJzB4Yzc1ZTBjMzJkNWNiN2MwZmE5ZDBhNTRiMTJhMGE2ZDU2NDdhYjA0NmQ2ODZkYTZmZGZmYzkwZmMyMDFkNzFhMycsXG4gICAgICAgICcweDI5YTYxOTQ2OTFmOTFhNzM3MTUyMDllZjY1MTJlNTc2NzIyODMwYTIwMWJlMjAxOGE3NjVlODVhOWVjZWU5MzEnLFxuICAgICAgICAnMHgyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjY4NGJkYTEyZjM4ZTM4ZDg0JyxcbiAgICBdLFxuICAgIC8vIHlEZW5cbiAgICBbXG4gICAgICAgICcweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlZmZmZmY5M2InLFxuICAgICAgICAnMHg3YTA2NTM0YmI4YmRiNDlmZDVlOWU2NjMyNzIyYzI5ODk0NjdjMWJmYzhlOGQ5NzhkZmI0MjVkMjY4NWMyNTczJyxcbiAgICAgICAgJzB4NjQ4NGFhNzE2NTQ1Y2EyY2YzYTcwYzNmYThmZTMzN2UwYTNkMjExNjJmMGQ2Mjk5YTdiZjgxOTJiZmQyYTc2ZicsXG4gICAgICAgICcweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEnLCAvLyBMQVNUIDFcbiAgICBdLFxuXS5tYXAoKGkpID0+IGkubWFwKChqKSA9PiBCaWdJbnQoaikpKSkpKCk7XG5jb25zdCBtYXBTV1UgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IG1hcFRvQ3VydmVTaW1wbGVTV1UoRnAsIHtcbiAgICBBOiBCaWdJbnQoJzB4M2Y4NzMxYWJkZDY2MWFkY2EwOGE1NTU4ZjBmNWQyNzJlOTUzZDM2M2NiNmYwZTVkNDA1NDQ3YzAxYTQ0NDUzMycpLFxuICAgIEI6IEJpZ0ludCgnMTc3MScpLFxuICAgIFo6IEZwLmNyZWF0ZShCaWdJbnQoJy0xMScpKSxcbn0pKSgpO1xuY29uc3QgaHRmID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBjcmVhdGVIYXNoZXIoc2VjcDI1NmsxLlByb2plY3RpdmVQb2ludCwgKHNjYWxhcnMpID0+IHtcbiAgICBjb25zdCB7IHgsIHkgfSA9IG1hcFNXVShGcC5jcmVhdGUoc2NhbGFyc1swXSkpO1xuICAgIHJldHVybiBpc29NYXAoeCwgeSk7XG59LCB7XG4gICAgRFNUOiAnc2VjcDI1NmsxX1hNRDpTSEEtMjU2X1NTV1VfUk9fJyxcbiAgICBlbmNvZGVEU1Q6ICdzZWNwMjU2azFfWE1EOlNIQS0yNTZfU1NXVV9OVV8nLFxuICAgIHA6IEZwLk9SREVSLFxuICAgIG06IDEsXG4gICAgazogMTI4LFxuICAgIGV4cGFuZDogJ3htZCcsXG4gICAgaGFzaDogc2hhMjU2LFxufSkpKCk7XG5leHBvcnQgY29uc3QgaGFzaFRvQ3VydmUgPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IGh0Zi5oYXNoVG9DdXJ2ZSkoKTtcbmV4cG9ydCBjb25zdCBlbmNvZGVUb0N1cnZlID0gLyogQF9fUFVSRV9fICovICgoKSA9PiBodGYuZW5jb2RlVG9DdXJ2ZSkoKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlY3AyNTZrMS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/esm/secp256k1.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: function() { return /* binding */ bool; },\n/* harmony export */   bytes: function() { return /* binding */ bytes; },\n/* harmony export */   exists: function() { return /* binding */ exists; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   isBytes: function() { return /* binding */ isBytes; },\n/* harmony export */   number: function() { return /* binding */ number; },\n/* harmony export */   output: function() { return /* binding */ output; }\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ __webpack_exports__[\"default\"] = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0EsMERBQTBELEVBQUU7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsUUFBUSxrQkFBa0IsU0FBUztBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLElBQUk7QUFDckY7QUFDQTtBQUNxRDtBQUNyRCxpQkFBaUI7QUFDakIsK0RBQWUsTUFBTSxFQUFDO0FBQ3RCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fYXNzZXJ0LmpzP2NmZmEiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gbnVtYmVyKG4pIHtcbiAgICBpZiAoIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pIHx8IG4gPCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHBvc2l0aXZlIGludGVnZXIgZXhwZWN0ZWQsIG5vdCAke259YCk7XG59XG5mdW5jdGlvbiBib29sKGIpIHtcbiAgICBpZiAodHlwZW9mIGIgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBib29sZWFuIGV4cGVjdGVkLCBub3QgJHtifWApO1xufVxuLy8gY29waWVkIGZyb20gdXRpbHNcbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG5mdW5jdGlvbiBieXRlcyhiLCAuLi5sZW5ndGhzKSB7XG4gICAgaWYgKCFpc0J5dGVzKGIpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VpbnQ4QXJyYXkgZXhwZWN0ZWQnKTtcbiAgICBpZiAobGVuZ3Rocy5sZW5ndGggPiAwICYmICFsZW5ndGhzLmluY2x1ZGVzKGIubGVuZ3RoKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVaW50OEFycmF5IGV4cGVjdGVkIG9mIGxlbmd0aCAke2xlbmd0aHN9LCBub3Qgb2YgbGVuZ3RoPSR7Yi5sZW5ndGh9YCk7XG59XG5mdW5jdGlvbiBoYXNoKGgpIHtcbiAgICBpZiAodHlwZW9mIGggIT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGguY3JlYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2ggc2hvdWxkIGJlIHdyYXBwZWQgYnkgdXRpbHMud3JhcENvbnN0cnVjdG9yJyk7XG4gICAgbnVtYmVyKGgub3V0cHV0TGVuKTtcbiAgICBudW1iZXIoaC5ibG9ja0xlbik7XG59XG5mdW5jdGlvbiBleGlzdHMoaW5zdGFuY2UsIGNoZWNrRmluaXNoZWQgPSB0cnVlKSB7XG4gICAgaWYgKGluc3RhbmNlLmRlc3Ryb3llZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIGluc3RhbmNlIGhhcyBiZWVuIGRlc3Ryb3llZCcpO1xuICAgIGlmIChjaGVja0ZpbmlzaGVkICYmIGluc3RhbmNlLmZpbmlzaGVkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0hhc2gjZGlnZXN0KCkgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQnKTtcbn1cbmZ1bmN0aW9uIG91dHB1dChvdXQsIGluc3RhbmNlKSB7XG4gICAgYnl0ZXMob3V0KTtcbiAgICBjb25zdCBtaW4gPSBpbnN0YW5jZS5vdXRwdXRMZW47XG4gICAgaWYgKG91dC5sZW5ndGggPCBtaW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBkaWdlc3RJbnRvKCkgZXhwZWN0cyBvdXRwdXQgYnVmZmVyIG9mIGxlbmd0aCBhdCBsZWFzdCAke21pbn1gKTtcbiAgICB9XG59XG5leHBvcnQgeyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuY29uc3QgYXNzZXJ0ID0geyBudW1iZXIsIGJvb2wsIGJ5dGVzLCBoYXNoLCBleGlzdHMsIG91dHB1dCB9O1xuZXhwb3J0IGRlZmF1bHQgYXNzZXJ0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X2Fzc2VydC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: function() { return /* binding */ Chi; },\n/* harmony export */   HashMD: function() { return /* binding */ HashMD; },\n/* harmony export */   Maj: function() { return /* binding */ Maj; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fbWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBOEM7QUFDUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTyxxQkFBcUIsMkNBQUk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxREFBVTtBQUM5QjtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLGdCQUFnQix5QkFBeUI7QUFDekMsZUFBZSxrREFBTztBQUN0QjtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxxREFBVTtBQUMzQyx1QkFBdUIsdUJBQXVCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0MsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGNBQWM7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFEQUFVO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsWUFBWTtBQUNwQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0JBQW9CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IscURBQXFEO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fbWQuanM/NzVmMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBleGlzdHMsIG91dHB1dCB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCBjcmVhdGVWaWV3LCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBQb2x5ZmlsbCBmb3IgU2FmYXJpIDE0XG5mdW5jdGlvbiBzZXRCaWdVaW50NjQodmlldywgYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpIHtcbiAgICBpZiAodHlwZW9mIHZpZXcuc2V0QmlnVWludDY0ID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gdmlldy5zZXRCaWdVaW50NjQoYnl0ZU9mZnNldCwgdmFsdWUsIGlzTEUpO1xuICAgIGNvbnN0IF8zMm4gPSBCaWdJbnQoMzIpO1xuICAgIGNvbnN0IF91MzJfbWF4ID0gQmlnSW50KDB4ZmZmZmZmZmYpO1xuICAgIGNvbnN0IHdoID0gTnVtYmVyKCh2YWx1ZSA+PiBfMzJuKSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCB3bCA9IE51bWJlcih2YWx1ZSAmIF91MzJfbWF4KTtcbiAgICBjb25zdCBoID0gaXNMRSA/IDQgOiAwO1xuICAgIGNvbnN0IGwgPSBpc0xFID8gMCA6IDQ7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGgsIHdoLCBpc0xFKTtcbiAgICB2aWV3LnNldFVpbnQzMihieXRlT2Zmc2V0ICsgbCwgd2wsIGlzTEUpO1xufVxuLy8gQ2hvaWNlOiBhID8gYiA6IGNcbmV4cG9ydCBjb25zdCBDaGkgPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeICh+YSAmIGMpO1xuLy8gTWFqb3JpdHkgZnVuY3Rpb24sIHRydWUgaWYgYW55IHR3byBpbnB1c3QgaXMgdHJ1ZVxuZXhwb3J0IGNvbnN0IE1haiA9IChhLCBiLCBjKSA9PiAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG4vKipcbiAqIE1lcmtsZS1EYW1nYXJkIGhhc2ggY29uc3RydWN0aW9uIGJhc2UgY2xhc3MuXG4gKiBDb3VsZCBiZSB1c2VkIHRvIGNyZWF0ZSBNRDUsIFJJUEVNRCwgU0hBMSwgU0hBMi5cbiAqL1xuZXhwb3J0IGNsYXNzIEhhc2hNRCBleHRlbmRzIEhhc2gge1xuICAgIGNvbnN0cnVjdG9yKGJsb2NrTGVuLCBvdXRwdXRMZW4sIHBhZE9mZnNldCwgaXNMRSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0aGlzLnBhZE9mZnNldCA9IHBhZE9mZnNldDtcbiAgICAgICAgdGhpcy5pc0xFID0gaXNMRTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBuZXcgVWludDhBcnJheShibG9ja0xlbik7XG4gICAgICAgIHRoaXMudmlldyA9IGNyZWF0ZVZpZXcodGhpcy5idWZmZXIpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgdmlldywgYnVmZmVyLCBibG9ja0xlbiB9ID0gdGhpcztcbiAgICAgICAgZGF0YSA9IHRvQnl0ZXMoZGF0YSk7XG4gICAgICAgIGNvbnN0IGxlbiA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBwb3MgPSAwOyBwb3MgPCBsZW47KSB7XG4gICAgICAgICAgICBjb25zdCB0YWtlID0gTWF0aC5taW4oYmxvY2tMZW4gLSB0aGlzLnBvcywgbGVuIC0gcG9zKTtcbiAgICAgICAgICAgIC8vIEZhc3QgcGF0aDogd2UgaGF2ZSBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gaW5wdXQsIGNhc3QgaXQgdG8gdmlldyBhbmQgcHJvY2Vzc1xuICAgICAgICAgICAgaWYgKHRha2UgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGF0YVZpZXcgPSBjcmVhdGVWaWV3KGRhdGEpO1xuICAgICAgICAgICAgICAgIGZvciAoOyBibG9ja0xlbiA8PSBsZW4gLSBwb3M7IHBvcyArPSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKGRhdGFWaWV3LCBwb3MpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVmZmVyLnNldChkYXRhLnN1YmFycmF5KHBvcywgcG9zICsgdGFrZSksIHRoaXMucG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcyA9PT0gYmxvY2tMZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubGVuZ3RoICs9IGRhdGEubGVuZ3RoO1xuICAgICAgICB0aGlzLnJvdW5kQ2xlYW4oKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIGV4aXN0cyh0aGlzKTtcbiAgICAgICAgb3V0cHV0KG91dCwgdGhpcyk7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICAvLyBQYWRkaW5nXG4gICAgICAgIC8vIFdlIGNhbiBhdm9pZCBhbGxvY2F0aW9uIG9mIGJ1ZmZlciBmb3IgcGFkZGluZyBjb21wbGV0ZWx5IGlmIGl0XG4gICAgICAgIC8vIHdhcyBwcmV2aW91c2x5IG5vdCBhbGxvY2F0ZWQgaGVyZS4gQnV0IGl0IHdvbid0IGNoYW5nZSBwZXJmb3JtYW5jZS5cbiAgICAgICAgY29uc3QgeyBidWZmZXIsIHZpZXcsIGJsb2NrTGVuLCBpc0xFIH0gPSB0aGlzO1xuICAgICAgICBsZXQgeyBwb3MgfSA9IHRoaXM7XG4gICAgICAgIC8vIGFwcGVuZCB0aGUgYml0ICcxJyB0byB0aGUgbWVzc2FnZVxuICAgICAgICBidWZmZXJbcG9zKytdID0gMGIxMDAwMDAwMDtcbiAgICAgICAgdGhpcy5idWZmZXIuc3ViYXJyYXkocG9zKS5maWxsKDApO1xuICAgICAgICAvLyB3ZSBoYXZlIGxlc3MgdGhhbiBwYWRPZmZzZXQgbGVmdCBpbiBidWZmZXIsIHNvIHdlIGNhbm5vdCBwdXQgbGVuZ3RoIGluXG4gICAgICAgIC8vIGN1cnJlbnQgYmxvY2ssIG5lZWQgcHJvY2VzcyBpdCBhbmQgcGFkIGFnYWluXG4gICAgICAgIGlmICh0aGlzLnBhZE9mZnNldCA+IGJsb2NrTGVuIC0gcG9zKSB7XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgICAgICBwb3MgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBhZCB1bnRpbCBmdWxsIGJsb2NrIGJ5dGUgd2l0aCB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBpID0gcG9zOyBpIDwgYmxvY2tMZW47IGkrKylcbiAgICAgICAgICAgIGJ1ZmZlcltpXSA9IDA7XG4gICAgICAgIC8vIE5vdGU6IHNoYTUxMiByZXF1aXJlcyBsZW5ndGggdG8gYmUgMTI4Yml0IGludGVnZXIsIGJ1dCBsZW5ndGggaW4gSlMgd2lsbCBvdmVyZmxvdyBiZWZvcmUgdGhhdFxuICAgICAgICAvLyBZb3UgbmVlZCB0byB3cml0ZSBhcm91bmQgMiBleGFieXRlcyAodTY0X21heCAvIDggLyAoMTAyNCoqNikpIGZvciB0aGlzIHRvIGhhcHBlbi5cbiAgICAgICAgLy8gU28gd2UganVzdCB3cml0ZSBsb3dlc3QgNjQgYml0cyBvZiB0aGF0IHZhbHVlLlxuICAgICAgICBzZXRCaWdVaW50NjQodmlldywgYmxvY2tMZW4gLSA4LCBCaWdJbnQodGhpcy5sZW5ndGggKiA4KSwgaXNMRSk7XG4gICAgICAgIHRoaXMucHJvY2Vzcyh2aWV3LCAwKTtcbiAgICAgICAgY29uc3Qgb3ZpZXcgPSBjcmVhdGVWaWV3KG91dCk7XG4gICAgICAgIGNvbnN0IGxlbiA9IHRoaXMub3V0cHV0TGVuO1xuICAgICAgICAvLyBOT1RFOiB3ZSBkbyBkaXZpc2lvbiBieSA0IGxhdGVyLCB3aGljaCBzaG91bGQgYmUgZnVzZWQgaW4gc2luZ2xlIG9wIHdpdGggbW9kdWxvIGJ5IEpJVFxuICAgICAgICBpZiAobGVuICUgNClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignX3NoYTI6IG91dHB1dExlbiBzaG91bGQgYmUgYWxpZ25lZCB0byAzMmJpdCcpO1xuICAgICAgICBjb25zdCBvdXRMZW4gPSBsZW4gLyA0O1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0KCk7XG4gICAgICAgIGlmIChvdXRMZW4gPiBzdGF0ZS5sZW5ndGgpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gYmlnZ2VyIHRoYW4gc3RhdGUnKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRMZW47IGkrKylcbiAgICAgICAgICAgIG92aWV3LnNldFVpbnQzMig0ICogaSwgc3RhdGVbaV0sIGlzTEUpO1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCBvdXRwdXRMZW4gfSA9IHRoaXM7XG4gICAgICAgIHRoaXMuZGlnZXN0SW50byhidWZmZXIpO1xuICAgICAgICBjb25zdCByZXMgPSBidWZmZXIuc2xpY2UoMCwgb3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgdG8gfHwgKHRvID0gbmV3IHRoaXMuY29uc3RydWN0b3IoKSk7XG4gICAgICAgIHRvLnNldCguLi50aGlzLmdldCgpKTtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgYnVmZmVyLCBsZW5ndGgsIGZpbmlzaGVkLCBkZXN0cm95ZWQsIHBvcyB9ID0gdGhpcztcbiAgICAgICAgdG8ubGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICB0by5wb3MgPSBwb3M7XG4gICAgICAgIHRvLmZpbmlzaGVkID0gZmluaXNoZWQ7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IGRlc3Ryb3llZDtcbiAgICAgICAgaWYgKGxlbmd0aCAlIGJsb2NrTGVuKVxuICAgICAgICAgICAgdG8uYnVmZmVyLnNldChidWZmZXIpO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X21kLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_u64.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_u64.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: function() { return /* binding */ add; },\n/* harmony export */   add3H: function() { return /* binding */ add3H; },\n/* harmony export */   add3L: function() { return /* binding */ add3L; },\n/* harmony export */   add4H: function() { return /* binding */ add4H; },\n/* harmony export */   add4L: function() { return /* binding */ add4L; },\n/* harmony export */   add5H: function() { return /* binding */ add5H; },\n/* harmony export */   add5L: function() { return /* binding */ add5L; },\n/* harmony export */   fromBig: function() { return /* binding */ fromBig; },\n/* harmony export */   rotlBH: function() { return /* binding */ rotlBH; },\n/* harmony export */   rotlBL: function() { return /* binding */ rotlBL; },\n/* harmony export */   rotlSH: function() { return /* binding */ rotlSH; },\n/* harmony export */   rotlSL: function() { return /* binding */ rotlSL; },\n/* harmony export */   rotr32H: function() { return /* binding */ rotr32H; },\n/* harmony export */   rotr32L: function() { return /* binding */ rotr32L; },\n/* harmony export */   rotrBH: function() { return /* binding */ rotrBH; },\n/* harmony export */   rotrBL: function() { return /* binding */ rotrBL; },\n/* harmony export */   rotrSH: function() { return /* binding */ rotrSH; },\n/* harmony export */   rotrSL: function() { return /* binding */ rotrSL; },\n/* harmony export */   shrSH: function() { return /* binding */ shrSH; },\n/* harmony export */   shrSL: function() { return /* binding */ shrSL; },\n/* harmony export */   split: function() { return /* binding */ split; },\n/* harmony export */   toBig: function() { return /* binding */ toBig; }\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEMsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNpTDtBQUNqTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBZSxHQUFHLEVBQUM7QUFDbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanM/YzUzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBVMzJfTUFTSzY0ID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyICoqIDMyIC0gMSk7XG5jb25zdCBfMzJuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgzMik7XG4vLyBXZSBhcmUgbm90IHVzaW5nIEJpZ1VpbnQ2NEFycmF5LCBiZWNhdXNlIHRoZXkgYXJlIGV4dHJlbWVseSBzbG93IGFzIHBlciAyMDIyXG5mdW5jdGlvbiBmcm9tQmlnKG4sIGxlID0gZmFsc2UpIHtcbiAgICBpZiAobGUpXG4gICAgICAgIHJldHVybiB7IGg6IE51bWJlcihuICYgVTMyX01BU0s2NCksIGw6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIH07XG4gICAgcmV0dXJuIHsgaDogTnVtYmVyKChuID4+IF8zMm4pICYgVTMyX01BU0s2NCkgfCAwLCBsOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpIHwgMCB9O1xufVxuZnVuY3Rpb24gc3BsaXQobHN0LCBsZSA9IGZhbHNlKSB7XG4gICAgbGV0IEFoID0gbmV3IFVpbnQzMkFycmF5KGxzdC5sZW5ndGgpO1xuICAgIGxldCBBbCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB7IGgsIGwgfSA9IGZyb21CaWcobHN0W2ldLCBsZSk7XG4gICAgICAgIFtBaFtpXSwgQWxbaV1dID0gW2gsIGxdO1xuICAgIH1cbiAgICByZXR1cm4gW0FoLCBBbF07XG59XG5jb25zdCB0b0JpZyA9IChoLCBsKSA9PiAoQmlnSW50KGggPj4+IDApIDw8IF8zMm4pIHwgQmlnSW50KGwgPj4+IDApO1xuLy8gZm9yIFNoaWZ0IGluIFswLCAzMilcbmNvbnN0IHNoclNIID0gKGgsIF9sLCBzKSA9PiBoID4+PiBzO1xuY29uc3Qgc2hyU0wgPSAoaCwgbCwgcykgPT4gKGggPDwgKDMyIC0gcykpIHwgKGwgPj4+IHMpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBTaGlmdCBpbiBbMSwgMzIpXG5jb25zdCByb3RyU0ggPSAoaCwgbCwgcykgPT4gKGggPj4+IHMpIHwgKGwgPDwgKDMyIC0gcykpO1xuY29uc3Qgcm90clNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdHJCSCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoNjQgLSBzKSkgfCAobCA+Pj4gKHMgLSAzMikpO1xuY29uc3Qgcm90ckJMID0gKGgsIGwsIHMpID0+IChoID4+PiAocyAtIDMyKSkgfCAobCA8PCAoNjQgLSBzKSk7XG4vLyBSaWdodCByb3RhdGUgZm9yIHNoaWZ0PT09MzIgKGp1c3Qgc3dhcHMgbCZoKVxuY29uc3Qgcm90cjMySCA9IChfaCwgbCkgPT4gbDtcbmNvbnN0IHJvdHIzMkwgPSAoaCwgX2wpID0+IGg7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90bFNIID0gKGgsIGwsIHMpID0+IChoIDw8IHMpIHwgKGwgPj4+ICgzMiAtIHMpKTtcbmNvbnN0IHJvdGxTTCA9IChoLCBsLCBzKSA9PiAobCA8PCBzKSB8IChoID4+PiAoMzIgLSBzKSk7XG4vLyBMZWZ0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gKDMyLCA2NCksIE5PVEU6IDMyIGlzIHNwZWNpYWwgY2FzZS5cbmNvbnN0IHJvdGxCSCA9IChoLCBsLCBzKSA9PiAobCA8PCAocyAtIDMyKSkgfCAoaCA+Pj4gKDY0IC0gcykpO1xuY29uc3Qgcm90bEJMID0gKGgsIGwsIHMpID0+IChoIDw8IChzIC0gMzIpKSB8IChsID4+PiAoNjQgLSBzKSk7XG4vLyBKUyB1c2VzIDMyLWJpdCBzaWduZWQgaW50ZWdlcnMgZm9yIGJpdHdpc2Ugb3BlcmF0aW9ucyB3aGljaCBtZWFucyB3ZSBjYW5ub3Rcbi8vIHNpbXBsZSB0YWtlIGNhcnJ5IG91dCBvZiBsb3cgYml0IHN1bSBieSBzaGlmdCwgd2UgbmVlZCB0byB1c2UgZGl2aXNpb24uXG5mdW5jdGlvbiBhZGQoQWgsIEFsLCBCaCwgQmwpIHtcbiAgICBjb25zdCBsID0gKEFsID4+PiAwKSArIChCbCA+Pj4gMCk7XG4gICAgcmV0dXJuIHsgaDogKEFoICsgQmggKyAoKGwgLyAyICoqIDMyKSB8IDApKSB8IDAsIGw6IGwgfCAwIH07XG59XG4vLyBBZGRpdGlvbiB3aXRoIG1vcmUgdGhhbiAyIGVsZW1lbnRzXG5jb25zdCBhZGQzTCA9IChBbCwgQmwsIENsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCk7XG5jb25zdCBhZGQzSCA9IChsb3csIEFoLCBCaCwgQ2gpID0+IChBaCArIEJoICsgQ2ggKyAoKGxvdyAvIDIgKiogMzIpIHwgMCkpIHwgMDtcbmNvbnN0IGFkZDRMID0gKEFsLCBCbCwgQ2wsIERsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApO1xuY29uc3QgYWRkNEggPSAobG93LCBBaCwgQmgsIENoLCBEaCkgPT4gKEFoICsgQmggKyBDaCArIERoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ1TCA9IChBbCwgQmwsIENsLCBEbCwgRWwpID0+IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApICsgKENsID4+PiAwKSArIChEbCA+Pj4gMCkgKyAoRWwgPj4+IDApO1xuY29uc3QgYWRkNUggPSAobG93LCBBaCwgQmgsIENoLCBEaCwgRWgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArIEVoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG4vLyBwcmV0dGllci1pZ25vcmVcbmV4cG9ydCB7IGZyb21CaWcsIHNwbGl0LCB0b0JpZywgc2hyU0gsIHNoclNMLCByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsIHJvdHIzMkgsIHJvdHIzMkwsIHJvdGxTSCwgcm90bFNMLCByb3RsQkgsIHJvdGxCTCwgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLCB9O1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB1NjQgPSB7XG4gICAgZnJvbUJpZywgc3BsaXQsIHRvQmlnLFxuICAgIHNoclNILCBzaHJTTCxcbiAgICByb3RyU0gsIHJvdHJTTCwgcm90ckJILCByb3RyQkwsXG4gICAgcm90cjMySCwgcm90cjMyTCxcbiAgICByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsXG4gICAgYWRkLCBhZGQzTCwgYWRkM0gsIGFkZDRMLCBhZGQ0SCwgYWRkNUgsIGFkZDVMLFxufTtcbmV4cG9ydCBkZWZhdWx0IHU2NDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV91NjQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_u64.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: function() { return /* binding */ crypto; }\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG8uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bub2JsZS9jdXJ2ZXMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcz8zOGJmIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjb25zdCBjcnlwdG8gPSB0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcgJiYgJ2NyeXB0bycgaW4gZ2xvYmFsVGhpcyA/IGdsb2JhbFRoaXMuY3J5cHRvIDogdW5kZWZpbmVkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3J5cHRvLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HMAC: function() { return /* binding */ HMAC; },\n/* harmony export */   hmac: function() { return /* binding */ hmac; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// HMAC (RFC 2104)\nclass HMAC extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(hash, _key) {\n        super();\n        this.finished = false;\n        this.destroyed = false;\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.hash)(hash);\n        const key = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(_key);\n        this.iHash = hash.create();\n        if (typeof this.iHash.update !== 'function')\n            throw new Error('Expected instance of class which extends utils.Hash');\n        this.blockLen = this.iHash.blockLen;\n        this.outputLen = this.iHash.outputLen;\n        const blockLen = this.blockLen;\n        const pad = new Uint8Array(blockLen);\n        // blockLen can be bigger than outputLen\n        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36;\n        this.iHash.update(pad);\n        // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n        this.oHash = hash.create();\n        // Undo internal XOR && apply outer XOR\n        for (let i = 0; i < pad.length; i++)\n            pad[i] ^= 0x36 ^ 0x5c;\n        this.oHash.update(pad);\n        pad.fill(0);\n    }\n    update(buf) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        this.iHash.update(buf);\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.bytes)(out, this.outputLen);\n        this.finished = true;\n        this.iHash.digestInto(out);\n        this.oHash.update(out);\n        this.oHash.digestInto(out);\n        this.destroy();\n    }\n    digest() {\n        const out = new Uint8Array(this.oHash.outputLen);\n        this.digestInto(out);\n        return out;\n    }\n    _cloneInto(to) {\n        // Create new instance without calling constructor since key already in state and we don't know it.\n        to || (to = Object.create(Object.getPrototypeOf(this), {}));\n        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n        to = to;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        to.blockLen = blockLen;\n        to.outputLen = outputLen;\n        to.oHash = oHash._cloneInto(to.oHash);\n        to.iHash = iHash._cloneInto(to.iHash);\n        return to;\n    }\n    destroy() {\n        this.destroyed = true;\n        this.oHash.destroy();\n        this.iHash.destroy();\n    }\n}\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n */\nconst hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\nhmac.create = (hash, key) => new HMAC(hash, key);\n//# sourceMappingURL=hmac.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBZ0c7QUFDckQ7QUFDM0M7QUFDTyxtQkFBbUIsMkNBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdEQUFVO0FBQ2xCLG9CQUFvQixrREFBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsZ0JBQWdCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFZO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBWTtBQUNwQixRQUFRLGlEQUFXO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFO0FBQ2pFLGdCQUFnQix5REFBeUQ7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9obWFjLmpzPzg1ZTgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaGFzaCBhcyBhc3NlcnRIYXNoLCBieXRlcyBhcyBhc3NlcnRCeXRlcywgZXhpc3RzIGFzIGFzc2VydEV4aXN0cyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG5pbXBvcnQgeyBIYXNoLCB0b0J5dGVzIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBITUFDIChSRkMgMjEwNClcbmV4cG9ydCBjbGFzcyBITUFDIGV4dGVuZHMgSGFzaCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgX2tleSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIGFzc2VydEhhc2goaGFzaCk7XG4gICAgICAgIGNvbnN0IGtleSA9IHRvQnl0ZXMoX2tleSk7XG4gICAgICAgIHRoaXMuaUhhc2ggPSBoYXNoLmNyZWF0ZSgpO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMuaUhhc2gudXBkYXRlICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnN0YW5jZSBvZiBjbGFzcyB3aGljaCBleHRlbmRzIHV0aWxzLkhhc2gnKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IHRoaXMuaUhhc2guYmxvY2tMZW47XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gdGhpcy5pSGFzaC5vdXRwdXRMZW47XG4gICAgICAgIGNvbnN0IGJsb2NrTGVuID0gdGhpcy5ibG9ja0xlbjtcbiAgICAgICAgY29uc3QgcGFkID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICAvLyBibG9ja0xlbiBjYW4gYmUgYmlnZ2VyIHRoYW4gb3V0cHV0TGVuXG4gICAgICAgIHBhZC5zZXQoa2V5Lmxlbmd0aCA+IGJsb2NrTGVuID8gaGFzaC5jcmVhdGUoKS51cGRhdGUoa2V5KS5kaWdlc3QoKSA6IGtleSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgcGFkW2ldIF49IDB4MzY7XG4gICAgICAgIHRoaXMuaUhhc2gudXBkYXRlKHBhZCk7XG4gICAgICAgIC8vIEJ5IGRvaW5nIHVwZGF0ZSAocHJvY2Vzc2luZyBvZiBmaXJzdCBibG9jaykgb2Ygb3V0ZXIgaGFzaCBoZXJlIHdlIGNhbiByZS11c2UgaXQgYmV0d2VlbiBtdWx0aXBsZSBjYWxscyB2aWEgY2xvbmVcbiAgICAgICAgdGhpcy5vSGFzaCA9IGhhc2guY3JlYXRlKCk7XG4gICAgICAgIC8vIFVuZG8gaW50ZXJuYWwgWE9SICYmIGFwcGx5IG91dGVyIFhPUlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhZC5sZW5ndGg7IGkrKylcbiAgICAgICAgICAgIHBhZFtpXSBePSAweDM2IF4gMHg1YztcbiAgICAgICAgdGhpcy5vSGFzaC51cGRhdGUocGFkKTtcbiAgICAgICAgcGFkLmZpbGwoMCk7XG4gICAgfVxuICAgIHVwZGF0ZShidWYpIHtcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xuICAgICAgICB0aGlzLmlIYXNoLnVwZGF0ZShidWYpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZGlnZXN0SW50byhvdXQpIHtcbiAgICAgICAgYXNzZXJ0RXhpc3RzKHRoaXMpO1xuICAgICAgICBhc3NlcnRCeXRlcyhvdXQsIHRoaXMub3V0cHV0TGVuKTtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuaUhhc2guZGlnZXN0SW50byhvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLnVwZGF0ZShvdXQpO1xuICAgICAgICB0aGlzLm9IYXNoLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgfVxuICAgIGRpZ2VzdCgpIHtcbiAgICAgICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5vSGFzaC5vdXRwdXRMZW4pO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8ob3V0KTtcbiAgICAgICAgcmV0dXJuIG91dDtcbiAgICB9XG4gICAgX2Nsb25lSW50byh0bykge1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGluc3RhbmNlIHdpdGhvdXQgY2FsbGluZyBjb25zdHJ1Y3RvciBzaW5jZSBrZXkgYWxyZWFkeSBpbiBzdGF0ZSBhbmQgd2UgZG9uJ3Qga25vdyBpdC5cbiAgICAgICAgdG8gfHwgKHRvID0gT2JqZWN0LmNyZWF0ZShPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcyksIHt9KSk7XG4gICAgICAgIGNvbnN0IHsgb0hhc2gsIGlIYXNoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBibG9ja0xlbiwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0byA9IHRvO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIHRvLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRvLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdG8ub0hhc2ggPSBvSGFzaC5fY2xvbmVJbnRvKHRvLm9IYXNoKTtcbiAgICAgICAgdG8uaUhhc2ggPSBpSGFzaC5fY2xvbmVJbnRvKHRvLmlIYXNoKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgICAgIHRoaXMub0hhc2guZGVzdHJveSgpO1xuICAgICAgICB0aGlzLmlIYXNoLmRlc3Ryb3koKTtcbiAgICB9XG59XG4vKipcbiAqIEhNQUM6IFJGQzIxMDQgbWVzc2FnZSBhdXRoZW50aWNhdGlvbiBjb2RlLlxuICogQHBhcmFtIGhhc2ggLSBmdW5jdGlvbiB0aGF0IHdvdWxkIGJlIHVzZWQgZS5nLiBzaGEyNTZcbiAqIEBwYXJhbSBrZXkgLSBtZXNzYWdlIGtleVxuICogQHBhcmFtIG1lc3NhZ2UgLSBtZXNzYWdlIGRhdGFcbiAqL1xuZXhwb3J0IGNvbnN0IGhtYWMgPSAoaGFzaCwga2V5LCBtZXNzYWdlKSA9PiBuZXcgSE1BQyhoYXNoLCBrZXkpLnVwZGF0ZShtZXNzYWdlKS5kaWdlc3QoKTtcbmhtYWMuY3JlYXRlID0gKGhhc2gsIGtleSkgPT4gbmV3IEhNQUMoaGFzaCwga2V5KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhtYWMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/hmac.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: function() { return /* binding */ sha224; },\n/* harmony export */   sha256: function() { return /* binding */ sha256; }\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEyNTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUE0QztBQUNPO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwwQ0FBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlCQUF5QjtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQSx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQyx1QkFBdUIsK0NBQUksV0FBVywrQ0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQSxjQUFjLHlCQUF5QjtBQUN2Qyx3QkFBd0IsUUFBUTtBQUNoQywyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFELHFDQUFxQywyQ0FBRztBQUN4QywyQkFBMkIsK0NBQUksU0FBUywrQ0FBSSxVQUFVLCtDQUFJO0FBQzFELGlDQUFpQywyQ0FBRztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sK0JBQStCLDBEQUFlO0FBQzlDLCtCQUErQiwwREFBZTtBQUNyRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhMjU2LmpzPzI3MzAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGFzaE1ELCBDaGksIE1haiB9IGZyb20gJy4vX21kLmpzJztcbmltcG9ydCB7IHJvdHIsIHdyYXBDb25zdHJ1Y3RvciB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gU0hBMi0yNTYgbmVlZCB0byB0cnkgMl4xMjggaGFzaGVzIHRvIGV4ZWN1dGUgYmlydGhkYXkgYXR0YWNrLlxuLy8gQlRDIG5ldHdvcmsgaXMgZG9pbmcgMl42NyBoYXNoZXMvc2VjIGFzIHBlciBlYXJseSAyMDIzLlxuLy8gUm91bmQgY29uc3RhbnRzOlxuLy8gZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgNjQgcHJpbWVzIDIuLjMxMSlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0sgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAweDQyOGEyZjk4LCAweDcxMzc0NDkxLCAweGI1YzBmYmNmLCAweGU5YjVkYmE1LCAweDM5NTZjMjViLCAweDU5ZjExMWYxLCAweDkyM2Y4MmE0LCAweGFiMWM1ZWQ1LFxuICAgIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gICAgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYywgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSxcbiAgICAweDk4M2U1MTUyLCAweGE4MzFjNjZkLCAweGIwMDMyN2M4LCAweGJmNTk3ZmM3LCAweGM2ZTAwYmYzLCAweGQ1YTc5MTQ3LCAweDA2Y2E2MzUxLCAweDE0MjkyOTY3LFxuICAgIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSwgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCxcbiAgICAweDE5YTRjMTE2LCAweDFlMzc2YzA4LCAweDI3NDg3NzRjLCAweDM0YjBiY2I1LCAweDM5MWMwY2IzLCAweDRlZDhhYTRhLCAweDViOWNjYTRmLCAweDY4MmU2ZmYzLFxuICAgIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl0pO1xuLy8gSW5pdGlhbCBzdGF0ZTpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIHNxdWFyZSByb290cyBvZiB0aGUgZmlyc3QgOCBwcmltZXMgMi4uMTlcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgU0hBMjU2X0lWID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg2YTA5ZTY2NywgMHhiYjY3YWU4NSwgMHgzYzZlZjM3MiwgMHhhNTRmZjUzYSwgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuXSk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbi8vIE5hbWVkIHRoaXMgd2F5IGJlY2F1c2UgaXQgbWF0Y2hlcyBzcGVjaWZpY2F0aW9uLlxuY29uc3QgU0hBMjU2X1cgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDY0KTtcbmNsYXNzIFNIQTI1NiBleHRlbmRzIEhhc2hNRCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKDY0LCAzMiwgOCwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlXG4gICAgICAgIC8vIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgdGhpcy5BID0gU0hBMjU2X0lWWzBdIHwgMDtcbiAgICAgICAgdGhpcy5CID0gU0hBMjU2X0lWWzFdIHwgMDtcbiAgICAgICAgdGhpcy5DID0gU0hBMjU2X0lWWzJdIHwgMDtcbiAgICAgICAgdGhpcy5EID0gU0hBMjU2X0lWWzNdIHwgMDtcbiAgICAgICAgdGhpcy5FID0gU0hBMjU2X0lWWzRdIHwgMDtcbiAgICAgICAgdGhpcy5GID0gU0hBMjU2X0lWWzVdIHwgMDtcbiAgICAgICAgdGhpcy5HID0gU0hBMjU2X0lWWzZdIHwgMDtcbiAgICAgICAgdGhpcy5IID0gU0hBMjU2X0lWWzddIHwgMDtcbiAgICB9XG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIHJldHVybiBbQSwgQiwgQywgRCwgRSwgRiwgRywgSF07XG4gICAgfVxuICAgIC8vIHByZXR0aWVyLWlnbm9yZVxuICAgIHNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKSB7XG4gICAgICAgIHRoaXMuQSA9IEEgfCAwO1xuICAgICAgICB0aGlzLkIgPSBCIHwgMDtcbiAgICAgICAgdGhpcy5DID0gQyB8IDA7XG4gICAgICAgIHRoaXMuRCA9IEQgfCAwO1xuICAgICAgICB0aGlzLkUgPSBFIHwgMDtcbiAgICAgICAgdGhpcy5GID0gRiB8IDA7XG4gICAgICAgIHRoaXMuRyA9IEcgfCAwO1xuICAgICAgICB0aGlzLkggPSBIIHwgMDtcbiAgICB9XG4gICAgcHJvY2Vzcyh2aWV3LCBvZmZzZXQpIHtcbiAgICAgICAgLy8gRXh0ZW5kIHRoZSBmaXJzdCAxNiB3b3JkcyBpbnRvIHRoZSByZW1haW5pbmcgNDggd29yZHMgd1sxNi4uNjNdIG9mIHRoZSBtZXNzYWdlIHNjaGVkdWxlIGFycmF5XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7IGkrKywgb2Zmc2V0ICs9IDQpXG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IHZpZXcuZ2V0VWludDMyKG9mZnNldCwgZmFsc2UpO1xuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBXMTUgPSBTSEEyNTZfV1tpIC0gMTVdO1xuICAgICAgICAgICAgY29uc3QgVzIgPSBTSEEyNTZfV1tpIC0gMl07XG4gICAgICAgICAgICBjb25zdCBzMCA9IHJvdHIoVzE1LCA3KSBeIHJvdHIoVzE1LCAxOCkgXiAoVzE1ID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm90cihXMiwgMTcpIF4gcm90cihXMiwgMTkpIF4gKFcyID4+PiAxMCk7XG4gICAgICAgICAgICBTSEEyNTZfV1tpXSA9IChzMSArIFNIQTI1Nl9XW2kgLSA3XSArIHMwICsgU0hBMjU2X1dbaSAtIDE2XSkgfCAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgNjQgcm91bmRzXG4gICAgICAgIGxldCB7IEEsIEIsIEMsIEQsIEUsIEYsIEcsIEggfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgc2lnbWExID0gcm90cihFLCA2KSBeIHJvdHIoRSwgMTEpIF4gcm90cihFLCAyNSk7XG4gICAgICAgICAgICBjb25zdCBUMSA9IChIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBMjU2X0tbaV0gKyBTSEEyNTZfV1tpXSkgfCAwO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwID0gcm90cihBLCAyKSBeIHJvdHIoQSwgMTMpIF4gcm90cihBLCAyMik7XG4gICAgICAgICAgICBjb25zdCBUMiA9IChzaWdtYTAgKyBNYWooQSwgQiwgQykpIHwgMDtcbiAgICAgICAgICAgIEggPSBHO1xuICAgICAgICAgICAgRyA9IEY7XG4gICAgICAgICAgICBGID0gRTtcbiAgICAgICAgICAgIEUgPSAoRCArIFQxKSB8IDA7XG4gICAgICAgICAgICBEID0gQztcbiAgICAgICAgICAgIEMgPSBCO1xuICAgICAgICAgICAgQiA9IEE7XG4gICAgICAgICAgICBBID0gKFQxICsgVDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICBBID0gKEEgKyB0aGlzLkEpIHwgMDtcbiAgICAgICAgQiA9IChCICsgdGhpcy5CKSB8IDA7XG4gICAgICAgIEMgPSAoQyArIHRoaXMuQykgfCAwO1xuICAgICAgICBEID0gKEQgKyB0aGlzLkQpIHwgMDtcbiAgICAgICAgRSA9IChFICsgdGhpcy5FKSB8IDA7XG4gICAgICAgIEYgPSAoRiArIHRoaXMuRikgfCAwO1xuICAgICAgICBHID0gKEcgKyB0aGlzLkcpIHwgMDtcbiAgICAgICAgSCA9IChIICsgdGhpcy5IKSB8IDA7XG4gICAgICAgIHRoaXMuc2V0KEEsIEIsIEMsIEQsIEUsIEYsIEcsIEgpO1xuICAgIH1cbiAgICByb3VuZENsZWFuKCkge1xuICAgICAgICBTSEEyNTZfVy5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5idWZmZXIuZmlsbCgwKTtcbiAgICB9XG59XG4vLyBDb25zdGFudHMgZnJvbSBodHRwczovL252bHB1YnMubmlzdC5nb3YvbmlzdHB1YnMvRklQUy9OSVNULkZJUFMuMTgwLTQucGRmXG5jbGFzcyBTSEEyMjQgZXh0ZW5kcyBTSEEyNTYge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLkEgPSAweGMxMDU5ZWQ4IHwgMDtcbiAgICAgICAgdGhpcy5CID0gMHgzNjdjZDUwNyB8IDA7XG4gICAgICAgIHRoaXMuQyA9IDB4MzA3MGRkMTcgfCAwO1xuICAgICAgICB0aGlzLkQgPSAweGY3MGU1OTM5IHwgMDtcbiAgICAgICAgdGhpcy5FID0gMHhmZmMwMGIzMSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IDB4Njg1ODE1MTEgfCAwO1xuICAgICAgICB0aGlzLkcgPSAweDY0Zjk4ZmE3IHwgMDtcbiAgICAgICAgdGhpcy5IID0gMHhiZWZhNGZhNCB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMjg7XG4gICAgfVxufVxuLyoqXG4gKiBTSEEyLTI1NiBoYXNoIGZ1bmN0aW9uXG4gKiBAcGFyYW0gbWVzc2FnZSAtIGRhdGEgdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTI1NigpKTtcbmV4cG9ydCBjb25zdCBzaGEyMjQgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyMjQoKSk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaGEyNTYuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha512.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha512.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SHA512: function() { return /* binding */ SHA512; },\n/* harmony export */   sha384: function() { return /* binding */ sha384; },\n/* harmony export */   sha512: function() { return /* binding */ sha512; },\n/* harmony export */   sha512_224: function() { return /* binding */ sha512_224; },\n/* harmony export */   sha512_256: function() { return /* binding */ sha512_256; }\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_md.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].split([\n    '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n    '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n    '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n    '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n    '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n    '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n    '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n    '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n    '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n    '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n    '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n    '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n    '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n    '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n    '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n    '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n    '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n    '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n    '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n    '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nclass SHA512 extends _md_js__WEBPACK_IMPORTED_MODULE_1__.HashMD {\n    constructor() {\n        super(128, 64, 16, false);\n        // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n        // Also looks cleaner and easier to verify with spec.\n        // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x6a09e667 | 0;\n        this.Al = 0xf3bcc908 | 0;\n        this.Bh = 0xbb67ae85 | 0;\n        this.Bl = 0x84caa73b | 0;\n        this.Ch = 0x3c6ef372 | 0;\n        this.Cl = 0xfe94f82b | 0;\n        this.Dh = 0xa54ff53a | 0;\n        this.Dl = 0x5f1d36f1 | 0;\n        this.Eh = 0x510e527f | 0;\n        this.El = 0xade682d1 | 0;\n        this.Fh = 0x9b05688c | 0;\n        this.Fl = 0x2b3e6c1f | 0;\n        this.Gh = 0x1f83d9ab | 0;\n        this.Gl = 0xfb41bd6b | 0;\n        this.Hh = 0x5be0cd19 | 0;\n        this.Hl = 0x137e2179 | 0;\n    }\n    // prettier-ignore\n    get() {\n        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n        this.Ah = Ah | 0;\n        this.Al = Al | 0;\n        this.Bh = Bh | 0;\n        this.Bl = Bl | 0;\n        this.Ch = Ch | 0;\n        this.Cl = Cl | 0;\n        this.Dh = Dh | 0;\n        this.Dl = Dl | 0;\n        this.Eh = Eh | 0;\n        this.El = El | 0;\n        this.Fh = Fh | 0;\n        this.Fl = Fl | 0;\n        this.Gh = Gh | 0;\n        this.Gl = Gl | 0;\n        this.Hh = Hh | 0;\n        this.Hl = Hl | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4) {\n            SHA512_W_H[i] = view.getUint32(offset);\n            SHA512_W_L[i] = view.getUint32((offset += 4));\n        }\n        for (let i = 16; i < 80; i++) {\n            // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n            const W15h = SHA512_W_H[i - 15] | 0;\n            const W15l = SHA512_W_L[i - 15] | 0;\n            const s0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W15h, W15l, 7);\n            const s0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 1) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W15h, W15l, 8) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W15h, W15l, 7);\n            // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n            const W2h = SHA512_W_H[i - 2] | 0;\n            const W2l = SHA512_W_L[i - 2] | 0;\n            const s1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSH(W2h, W2l, 6);\n            const s1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(W2h, W2l, 19) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(W2h, W2l, 61) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shrSL(W2h, W2l, 6);\n            // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n            const SUMl = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n            const SUMh = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n            SHA512_W_H[i] = SUMh | 0;\n            SHA512_W_L[i] = SUMl | 0;\n        }\n        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n        // Compression function main loop, 80 rounds\n        for (let i = 0; i < 80; i++) {\n            // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n            const sigma1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Eh, El, 41);\n            const sigma1l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 14) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Eh, El, 18) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Eh, El, 41);\n            //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n            const CHIl = (El & Fl) ^ (~El & Gl);\n            // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n            // prettier-ignore\n            const T1ll = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n            const T1h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n            const T1l = T1ll | 0;\n            // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n            const sigma0h = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSH(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBH(Ah, Al, 39);\n            const sigma0l = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrSL(Ah, Al, 28) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 34) ^ _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].rotrBL(Ah, Al, 39);\n            const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n            const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n            Hh = Gh | 0;\n            Hl = Gl | 0;\n            Gh = Fh | 0;\n            Gl = Fl | 0;\n            Fh = Eh | 0;\n            Fl = El | 0;\n            ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n            Dh = Ch | 0;\n            Dl = Cl | 0;\n            Ch = Bh | 0;\n            Cl = Bl | 0;\n            Bh = Ah | 0;\n            Bl = Al | 0;\n            const All = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3L(T1l, sigma0l, MAJl);\n            Ah = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add3H(All, T1h, sigma0h, MAJh);\n            Al = All | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        ({ h: Ah, l: Al } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n        ({ h: Bh, l: Bl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n        ({ h: Ch, l: Cl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n        ({ h: Dh, l: Dl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n        ({ h: Eh, l: El } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n        ({ h: Fh, l: Fl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n        ({ h: Gh, l: Gl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n        ({ h: Hh, l: Hl } = _u64_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n        SHA512_W_H.fill(0);\n        SHA512_W_L.fill(0);\n    }\n    destroy() {\n        this.buffer.fill(0);\n        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n}\nclass SHA512_224 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x8c3d37c8 | 0;\n        this.Al = 0x19544da2 | 0;\n        this.Bh = 0x73e19966 | 0;\n        this.Bl = 0x89dcd4d6 | 0;\n        this.Ch = 0x1dfab7ae | 0;\n        this.Cl = 0x32ff9c82 | 0;\n        this.Dh = 0x679dd514 | 0;\n        this.Dl = 0x582f9fcf | 0;\n        this.Eh = 0x0f6d2b69 | 0;\n        this.El = 0x7bd44da8 | 0;\n        this.Fh = 0x77e36f73 | 0;\n        this.Fl = 0x04c48942 | 0;\n        this.Gh = 0x3f9d85a8 | 0;\n        this.Gl = 0x6a1d36c8 | 0;\n        this.Hh = 0x1112e6ad | 0;\n        this.Hl = 0x91d692a1 | 0;\n        this.outputLen = 28;\n    }\n}\nclass SHA512_256 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0x22312194 | 0;\n        this.Al = 0xfc2bf72c | 0;\n        this.Bh = 0x9f555fa3 | 0;\n        this.Bl = 0xc84c64c2 | 0;\n        this.Ch = 0x2393b86b | 0;\n        this.Cl = 0x6f53b151 | 0;\n        this.Dh = 0x96387719 | 0;\n        this.Dl = 0x5940eabd | 0;\n        this.Eh = 0x96283ee2 | 0;\n        this.El = 0xa88effe3 | 0;\n        this.Fh = 0xbe5e1e25 | 0;\n        this.Fl = 0x53863992 | 0;\n        this.Gh = 0x2b0199fc | 0;\n        this.Gl = 0x2c85b8aa | 0;\n        this.Hh = 0x0eb72ddc | 0;\n        this.Hl = 0x81c52ca2 | 0;\n        this.outputLen = 32;\n    }\n}\nclass SHA384 extends SHA512 {\n    constructor() {\n        super();\n        // h -- high 32 bits, l -- low 32 bits\n        this.Ah = 0xcbbb9d5d | 0;\n        this.Al = 0xc1059ed8 | 0;\n        this.Bh = 0x629a292a | 0;\n        this.Bl = 0x367cd507 | 0;\n        this.Ch = 0x9159015a | 0;\n        this.Cl = 0x3070dd17 | 0;\n        this.Dh = 0x152fecd8 | 0;\n        this.Dl = 0xf70e5939 | 0;\n        this.Eh = 0x67332667 | 0;\n        this.El = 0xffc00b31 | 0;\n        this.Fh = 0x8eb44a87 | 0;\n        this.Fl = 0x68581511 | 0;\n        this.Gh = 0xdb0c2e0d | 0;\n        this.Gl = 0x64f98fa7 | 0;\n        this.Hh = 0x47b5481d | 0;\n        this.Hl = 0xbefa4fa4 | 0;\n        this.outputLen = 48;\n    }\n}\nconst sha512 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512());\nconst sha512_224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_224());\nconst sha512_256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA512_256());\nconst sha384 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_2__.wrapConstructor)(() => new SHA384());\n//# sourceMappingURL=sha512.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGE1MTIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBa0M7QUFDTjtBQUNpQjtBQUM3QztBQUNBO0FBQ0Esc0RBQXNELHFEQUFTO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQiwwQ0FBTTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpRUFBaUU7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVSxrQkFBa0Isc0RBQVUsa0JBQWtCLHFEQUFTO0FBQ3pGLHdCQUF3QixzREFBVSxrQkFBa0Isc0RBQVUsa0JBQWtCLHFEQUFTO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixzREFBVSxpQkFBaUIsc0RBQVUsaUJBQWlCLHFEQUFTO0FBQ3ZGLHdCQUF3QixzREFBVSxpQkFBaUIsc0RBQVUsaUJBQWlCLHFEQUFTO0FBQ3ZGO0FBQ0EseUJBQXlCLHFEQUFTO0FBQ2xDLHlCQUF5QixxREFBUztBQUNsQztBQUNBO0FBQ0E7QUFDQSxjQUFjLGlFQUFpRTtBQUMvRTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EsNEJBQTRCLHNEQUFVLGVBQWUsc0RBQVUsZUFBZSxzREFBVTtBQUN4Riw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIscURBQVM7QUFDbEMsd0JBQXdCLHFEQUFTO0FBQ2pDO0FBQ0E7QUFDQSw0QkFBNEIsc0RBQVUsZUFBZSxzREFBVSxlQUFlLHNEQUFVO0FBQ3hGLDRCQUE0QixzREFBVSxlQUFlLHNEQUFVLGVBQWUsc0RBQVU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZUFBZSxFQUFFLG1EQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxREFBUztBQUNqQyxpQkFBaUIscURBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkMsV0FBVyxlQUFlLEVBQUUsbURBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLCtCQUErQiwwREFBZTtBQUM5QyxtQ0FBbUMsMERBQWU7QUFDbEQsbUNBQW1DLDBEQUFlO0FBQ2xELCtCQUErQiwwREFBZTtBQUNyRCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQG5vYmxlL2N1cnZlcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vc2hhNTEyLmpzP2Q5NjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSGFzaE1EIH0gZnJvbSAnLi9fbWQuanMnO1xuaW1wb3J0IHU2NCBmcm9tICcuL191NjQuanMnO1xuaW1wb3J0IHsgd3JhcENvbnN0cnVjdG9yIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBSb3VuZCBjb250YW50cyAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgY3ViZSByb290cyBvZiB0aGUgZmlyc3QgODAgcHJpbWVzIDIuLjQwOSk6XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFtTSEE1MTJfS2gsIFNIQTUxMl9LbF0gPSAvKiBAX19QVVJFX18gKi8gKCgpID0+IHU2NC5zcGxpdChbXG4gICAgJzB4NDI4YTJmOThkNzI4YWUyMicsICcweDcxMzc0NDkxMjNlZjY1Y2QnLCAnMHhiNWMwZmJjZmVjNGQzYjJmJywgJzB4ZTliNWRiYTU4MTg5ZGJiYycsXG4gICAgJzB4Mzk1NmMyNWJmMzQ4YjUzOCcsICcweDU5ZjExMWYxYjYwNWQwMTknLCAnMHg5MjNmODJhNGFmMTk0ZjliJywgJzB4YWIxYzVlZDVkYTZkODExOCcsXG4gICAgJzB4ZDgwN2FhOThhMzAzMDI0MicsICcweDEyODM1YjAxNDU3MDZmYmUnLCAnMHgyNDMxODViZTRlZTRiMjhjJywgJzB4NTUwYzdkYzNkNWZmYjRlMicsXG4gICAgJzB4NzJiZTVkNzRmMjdiODk2ZicsICcweDgwZGViMWZlM2IxNjk2YjEnLCAnMHg5YmRjMDZhNzI1YzcxMjM1JywgJzB4YzE5YmYxNzRjZjY5MjY5NCcsXG4gICAgJzB4ZTQ5YjY5YzE5ZWYxNGFkMicsICcweGVmYmU0Nzg2Mzg0ZjI1ZTMnLCAnMHgwZmMxOWRjNjhiOGNkNWI1JywgJzB4MjQwY2ExY2M3N2FjOWM2NScsXG4gICAgJzB4MmRlOTJjNmY1OTJiMDI3NScsICcweDRhNzQ4NGFhNmVhNmU0ODMnLCAnMHg1Y2IwYTlkY2JkNDFmYmQ0JywgJzB4NzZmOTg4ZGE4MzExNTNiNScsXG4gICAgJzB4OTgzZTUxNTJlZTY2ZGZhYicsICcweGE4MzFjNjZkMmRiNDMyMTAnLCAnMHhiMDAzMjdjODk4ZmIyMTNmJywgJzB4YmY1OTdmYzdiZWVmMGVlNCcsXG4gICAgJzB4YzZlMDBiZjMzZGE4OGZjMicsICcweGQ1YTc5MTQ3OTMwYWE3MjUnLCAnMHgwNmNhNjM1MWUwMDM4MjZmJywgJzB4MTQyOTI5NjcwYTBlNmU3MCcsXG4gICAgJzB4MjdiNzBhODU0NmQyMmZmYycsICcweDJlMWIyMTM4NWMyNmM5MjYnLCAnMHg0ZDJjNmRmYzVhYzQyYWVkJywgJzB4NTMzODBkMTM5ZDk1YjNkZicsXG4gICAgJzB4NjUwYTczNTQ4YmFmNjNkZScsICcweDc2NmEwYWJiM2M3N2IyYTgnLCAnMHg4MWMyYzkyZTQ3ZWRhZWU2JywgJzB4OTI3MjJjODUxNDgyMzUzYicsXG4gICAgJzB4YTJiZmU4YTE0Y2YxMDM2NCcsICcweGE4MWE2NjRiYmM0MjMwMDEnLCAnMHhjMjRiOGI3MGQwZjg5NzkxJywgJzB4Yzc2YzUxYTMwNjU0YmUzMCcsXG4gICAgJzB4ZDE5MmU4MTlkNmVmNTIxOCcsICcweGQ2OTkwNjI0NTU2NWE5MTAnLCAnMHhmNDBlMzU4NTU3NzEyMDJhJywgJzB4MTA2YWEwNzAzMmJiZDFiOCcsXG4gICAgJzB4MTlhNGMxMTZiOGQyZDBjOCcsICcweDFlMzc2YzA4NTE0MWFiNTMnLCAnMHgyNzQ4Nzc0Y2RmOGVlYjk5JywgJzB4MzRiMGJjYjVlMTliNDhhOCcsXG4gICAgJzB4MzkxYzBjYjNjNWM5NWE2MycsICcweDRlZDhhYTRhZTM0MThhY2InLCAnMHg1YjljY2E0Zjc3NjNlMzczJywgJzB4NjgyZTZmZjNkNmIyYjhhMycsXG4gICAgJzB4NzQ4ZjgyZWU1ZGVmYjJmYycsICcweDc4YTU2MzZmNDMxNzJmNjAnLCAnMHg4NGM4NzgxNGExZjBhYjcyJywgJzB4OGNjNzAyMDgxYTY0MzllYycsXG4gICAgJzB4OTBiZWZmZmEyMzYzMWUyOCcsICcweGE0NTA2Y2ViZGU4MmJkZTknLCAnMHhiZWY5YTNmN2IyYzY3OTE1JywgJzB4YzY3MTc4ZjJlMzcyNTMyYicsXG4gICAgJzB4Y2EyNzNlY2VlYTI2NjE5YycsICcweGQxODZiOGM3MjFjMGMyMDcnLCAnMHhlYWRhN2RkNmNkZTBlYjFlJywgJzB4ZjU3ZDRmN2ZlZTZlZDE3OCcsXG4gICAgJzB4MDZmMDY3YWE3MjE3NmZiYScsICcweDBhNjM3ZGM1YTJjODk4YTYnLCAnMHgxMTNmOTgwNGJlZjkwZGFlJywgJzB4MWI3MTBiMzUxMzFjNDcxYicsXG4gICAgJzB4MjhkYjc3ZjUyMzA0N2Q4NCcsICcweDMyY2FhYjdiNDBjNzI0OTMnLCAnMHgzYzllYmUwYTE1YzliZWJjJywgJzB4NDMxZDY3YzQ5YzEwMGQ0YycsXG4gICAgJzB4NGNjNWQ0YmVjYjNlNDJiNicsICcweDU5N2YyOTljZmM2NTdlMmEnLCAnMHg1ZmNiNmZhYjNhZDZmYWVjJywgJzB4NmM0NDE5OGM0YTQ3NTgxNydcbl0ubWFwKG4gPT4gQmlnSW50KG4pKSkpKCk7XG4vLyBUZW1wb3JhcnkgYnVmZmVyLCBub3QgdXNlZCB0byBzdG9yZSBhbnl0aGluZyBiZXR3ZWVuIHJ1bnNcbmNvbnN0IFNIQTUxMl9XX0ggPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmNvbnN0IFNIQTUxMl9XX0wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFVpbnQzMkFycmF5KDgwKTtcbmV4cG9ydCBjbGFzcyBTSEE1MTIgZXh0ZW5kcyBIYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigxMjgsIDY0LCAxNiwgZmFsc2UpO1xuICAgICAgICAvLyBXZSBjYW5ub3QgdXNlIGFycmF5IGhlcmUgc2luY2UgYXJyYXkgYWxsb3dzIGluZGV4aW5nIGJ5IHZhcmlhYmxlIHdoaWNoIG1lYW5zIG9wdGltaXplci9jb21waWxlciBjYW5ub3QgdXNlIHJlZ2lzdGVycy5cbiAgICAgICAgLy8gQWxzbyBsb29rcyBjbGVhbmVyIGFuZCBlYXNpZXIgdG8gdmVyaWZ5IHdpdGggc3BlYy5cbiAgICAgICAgLy8gSW5pdGlhbCBzdGF0ZSAoZmlyc3QgMzIgYml0cyBvZiB0aGUgZnJhY3Rpb25hbCBwYXJ0cyBvZiB0aGUgc3F1YXJlIHJvb3RzIG9mIHRoZSBmaXJzdCA4IHByaW1lcyAyLi4xOSk6XG4gICAgICAgIC8vIGggLS0gaGlnaCAzMiBiaXRzLCBsIC0tIGxvdyAzMiBiaXRzXG4gICAgICAgIHRoaXMuQWggPSAweDZhMDllNjY3IHwgMDtcbiAgICAgICAgdGhpcy5BbCA9IDB4ZjNiY2M5MDggfCAwO1xuICAgICAgICB0aGlzLkJoID0gMHhiYjY3YWU4NSB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSAweDg0Y2FhNzNiIHwgMDtcbiAgICAgICAgdGhpcy5DaCA9IDB4M2M2ZWYzNzIgfCAwO1xuICAgICAgICB0aGlzLkNsID0gMHhmZTk0ZjgyYiB8IDA7XG4gICAgICAgIHRoaXMuRGggPSAweGE1NGZmNTNhIHwgMDtcbiAgICAgICAgdGhpcy5EbCA9IDB4NWYxZDM2ZjEgfCAwO1xuICAgICAgICB0aGlzLkVoID0gMHg1MTBlNTI3ZiB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSAweGFkZTY4MmQxIHwgMDtcbiAgICAgICAgdGhpcy5GaCA9IDB4OWIwNTY4OGMgfCAwO1xuICAgICAgICB0aGlzLkZsID0gMHgyYjNlNmMxZiB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSAweDFmODNkOWFiIHwgMDtcbiAgICAgICAgdGhpcy5HbCA9IDB4ZmI0MWJkNmIgfCAwO1xuICAgICAgICB0aGlzLkhoID0gMHg1YmUwY2QxOSB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSAweDEzN2UyMTc5IHwgMDtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgZ2V0KCkge1xuICAgICAgICBjb25zdCB7IEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0FoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsXTtcbiAgICB9XG4gICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgc2V0KEFoLCBBbCwgQmgsIEJsLCBDaCwgQ2wsIERoLCBEbCwgRWgsIEVsLCBGaCwgRmwsIEdoLCBHbCwgSGgsIEhsKSB7XG4gICAgICAgIHRoaXMuQWggPSBBaCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSBBbCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSBCaCB8IDA7XG4gICAgICAgIHRoaXMuQmwgPSBCbCB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSBDaCB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSBDbCB8IDA7XG4gICAgICAgIHRoaXMuRGggPSBEaCB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSBEbCB8IDA7XG4gICAgICAgIHRoaXMuRWggPSBFaCB8IDA7XG4gICAgICAgIHRoaXMuRWwgPSBFbCB8IDA7XG4gICAgICAgIHRoaXMuRmggPSBGaCB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSBGbCB8IDA7XG4gICAgICAgIHRoaXMuR2ggPSBHaCB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSBHbCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSBIaCB8IDA7XG4gICAgICAgIHRoaXMuSGwgPSBIbCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDY0IHdvcmRzIHdbMTYuLjc5XSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KSB7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gdmlldy5nZXRVaW50MzIob2Zmc2V0KTtcbiAgICAgICAgICAgIFNIQTUxMl9XX0xbaV0gPSB2aWV3LmdldFVpbnQzMigob2Zmc2V0ICs9IDQpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMTY7IGkgPCA4MDsgaSsrKSB7XG4gICAgICAgICAgICAvLyBzMCA6PSAod1tpLTE1XSByaWdodHJvdGF0ZSAxKSB4b3IgKHdbaS0xNV0gcmlnaHRyb3RhdGUgOCkgeG9yICh3W2ktMTVdIHJpZ2h0c2hpZnQgNylcbiAgICAgICAgICAgIGNvbnN0IFcxNWggPSBTSEE1MTJfV19IW2kgLSAxNV0gfCAwO1xuICAgICAgICAgICAgY29uc3QgVzE1bCA9IFNIQTUxMl9XX0xbaSAtIDE1XSB8IDA7XG4gICAgICAgICAgICBjb25zdCBzMGggPSB1NjQucm90clNIKFcxNWgsIFcxNWwsIDEpIF4gdTY0LnJvdHJTSChXMTVoLCBXMTVsLCA4KSBeIHU2NC5zaHJTSChXMTVoLCBXMTVsLCA3KTtcbiAgICAgICAgICAgIGNvbnN0IHMwbCA9IHU2NC5yb3RyU0woVzE1aCwgVzE1bCwgMSkgXiB1NjQucm90clNMKFcxNWgsIFcxNWwsIDgpIF4gdTY0LnNoclNMKFcxNWgsIFcxNWwsIDcpO1xuICAgICAgICAgICAgLy8gczEgOj0gKHdbaS0yXSByaWdodHJvdGF0ZSAxOSkgeG9yICh3W2ktMl0gcmlnaHRyb3RhdGUgNjEpIHhvciAod1tpLTJdIHJpZ2h0c2hpZnQgNilcbiAgICAgICAgICAgIGNvbnN0IFcyaCA9IFNIQTUxMl9XX0hbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IFcybCA9IFNIQTUxMl9XX0xbaSAtIDJdIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHMxaCA9IHU2NC5yb3RyU0goVzJoLCBXMmwsIDE5KSBeIHU2NC5yb3RyQkgoVzJoLCBXMmwsIDYxKSBeIHU2NC5zaHJTSChXMmgsIFcybCwgNik7XG4gICAgICAgICAgICBjb25zdCBzMWwgPSB1NjQucm90clNMKFcyaCwgVzJsLCAxOSkgXiB1NjQucm90ckJMKFcyaCwgVzJsLCA2MSkgXiB1NjQuc2hyU0woVzJoLCBXMmwsIDYpO1xuICAgICAgICAgICAgLy8gU0hBMjU2X1dbaV0gPSBzMCArIHMxICsgU0hBMjU2X1dbaSAtIDddICsgU0hBMjU2X1dbaSAtIDE2XTtcbiAgICAgICAgICAgIGNvbnN0IFNVTWwgPSB1NjQuYWRkNEwoczBsLCBzMWwsIFNIQTUxMl9XX0xbaSAtIDddLCBTSEE1MTJfV19MW2kgLSAxNl0pO1xuICAgICAgICAgICAgY29uc3QgU1VNaCA9IHU2NC5hZGQ0SChTVU1sLCBzMGgsIHMxaCwgU0hBNTEyX1dfSFtpIC0gN10sIFNIQTUxMl9XX0hbaSAtIDE2XSk7XG4gICAgICAgICAgICBTSEE1MTJfV19IW2ldID0gU1VNaCB8IDA7XG4gICAgICAgICAgICBTSEE1MTJfV19MW2ldID0gU1VNbCB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgQWgsIEFsLCBCaCwgQmwsIENoLCBDbCwgRGgsIERsLCBFaCwgRWwsIEZoLCBGbCwgR2gsIEdsLCBIaCwgSGwgfSA9IHRoaXM7XG4gICAgICAgIC8vIENvbXByZXNzaW9uIGZ1bmN0aW9uIG1haW4gbG9vcCwgODAgcm91bmRzXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgODA7IGkrKykge1xuICAgICAgICAgICAgLy8gUzEgOj0gKGUgcmlnaHRyb3RhdGUgMTQpIHhvciAoZSByaWdodHJvdGF0ZSAxOCkgeG9yIChlIHJpZ2h0cm90YXRlIDQxKVxuICAgICAgICAgICAgY29uc3Qgc2lnbWExaCA9IHU2NC5yb3RyU0goRWgsIEVsLCAxNCkgXiB1NjQucm90clNIKEVoLCBFbCwgMTgpIF4gdTY0LnJvdHJCSChFaCwgRWwsIDQxKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMWwgPSB1NjQucm90clNMKEVoLCBFbCwgMTQpIF4gdTY0LnJvdHJTTChFaCwgRWwsIDE4KSBeIHU2NC5yb3RyQkwoRWgsIEVsLCA0MSk7XG4gICAgICAgICAgICAvL2NvbnN0IFQxID0gKEggKyBzaWdtYTEgKyBDaGkoRSwgRiwgRykgKyBTSEEyNTZfS1tpXSArIFNIQTI1Nl9XW2ldKSB8IDA7XG4gICAgICAgICAgICBjb25zdCBDSEloID0gKEVoICYgRmgpIF4gKH5FaCAmIEdoKTtcbiAgICAgICAgICAgIGNvbnN0IENISWwgPSAoRWwgJiBGbCkgXiAofkVsICYgR2wpO1xuICAgICAgICAgICAgLy8gVDEgPSBIICsgc2lnbWExICsgQ2hpKEUsIEYsIEcpICsgU0hBNTEyX0tbaV0gKyBTSEE1MTJfV1tpXVxuICAgICAgICAgICAgLy8gcHJldHRpZXItaWdub3JlXG4gICAgICAgICAgICBjb25zdCBUMWxsID0gdTY0LmFkZDVMKEhsLCBzaWdtYTFsLCBDSElsLCBTSEE1MTJfS2xbaV0sIFNIQTUxMl9XX0xbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFoID0gdTY0LmFkZDVIKFQxbGwsIEhoLCBzaWdtYTFoLCBDSEloLCBTSEE1MTJfS2hbaV0sIFNIQTUxMl9XX0hbaV0pO1xuICAgICAgICAgICAgY29uc3QgVDFsID0gVDFsbCB8IDA7XG4gICAgICAgICAgICAvLyBTMCA6PSAoYSByaWdodHJvdGF0ZSAyOCkgeG9yIChhIHJpZ2h0cm90YXRlIDM0KSB4b3IgKGEgcmlnaHRyb3RhdGUgMzkpXG4gICAgICAgICAgICBjb25zdCBzaWdtYTBoID0gdTY0LnJvdHJTSChBaCwgQWwsIDI4KSBeIHU2NC5yb3RyQkgoQWgsIEFsLCAzNCkgXiB1NjQucm90ckJIKEFoLCBBbCwgMzkpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbWEwbCA9IHU2NC5yb3RyU0woQWgsIEFsLCAyOCkgXiB1NjQucm90ckJMKEFoLCBBbCwgMzQpIF4gdTY0LnJvdHJCTChBaCwgQWwsIDM5KTtcbiAgICAgICAgICAgIGNvbnN0IE1BSmggPSAoQWggJiBCaCkgXiAoQWggJiBDaCkgXiAoQmggJiBDaCk7XG4gICAgICAgICAgICBjb25zdCBNQUpsID0gKEFsICYgQmwpIF4gKEFsICYgQ2wpIF4gKEJsICYgQ2wpO1xuICAgICAgICAgICAgSGggPSBHaCB8IDA7XG4gICAgICAgICAgICBIbCA9IEdsIHwgMDtcbiAgICAgICAgICAgIEdoID0gRmggfCAwO1xuICAgICAgICAgICAgR2wgPSBGbCB8IDA7XG4gICAgICAgICAgICBGaCA9IEVoIHwgMDtcbiAgICAgICAgICAgIEZsID0gRWwgfCAwO1xuICAgICAgICAgICAgKHsgaDogRWgsIGw6IEVsIH0gPSB1NjQuYWRkKERoIHwgMCwgRGwgfCAwLCBUMWggfCAwLCBUMWwgfCAwKSk7XG4gICAgICAgICAgICBEaCA9IENoIHwgMDtcbiAgICAgICAgICAgIERsID0gQ2wgfCAwO1xuICAgICAgICAgICAgQ2ggPSBCaCB8IDA7XG4gICAgICAgICAgICBDbCA9IEJsIHwgMDtcbiAgICAgICAgICAgIEJoID0gQWggfCAwO1xuICAgICAgICAgICAgQmwgPSBBbCB8IDA7XG4gICAgICAgICAgICBjb25zdCBBbGwgPSB1NjQuYWRkM0woVDFsLCBzaWdtYTBsLCBNQUpsKTtcbiAgICAgICAgICAgIEFoID0gdTY0LmFkZDNIKEFsbCwgVDFoLCBzaWdtYTBoLCBNQUpoKTtcbiAgICAgICAgICAgIEFsID0gQWxsIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBBZGQgdGhlIGNvbXByZXNzZWQgY2h1bmsgdG8gdGhlIGN1cnJlbnQgaGFzaCB2YWx1ZVxuICAgICAgICAoeyBoOiBBaCwgbDogQWwgfSA9IHU2NC5hZGQodGhpcy5BaCB8IDAsIHRoaXMuQWwgfCAwLCBBaCB8IDAsIEFsIHwgMCkpO1xuICAgICAgICAoeyBoOiBCaCwgbDogQmwgfSA9IHU2NC5hZGQodGhpcy5CaCB8IDAsIHRoaXMuQmwgfCAwLCBCaCB8IDAsIEJsIHwgMCkpO1xuICAgICAgICAoeyBoOiBDaCwgbDogQ2wgfSA9IHU2NC5hZGQodGhpcy5DaCB8IDAsIHRoaXMuQ2wgfCAwLCBDaCB8IDAsIENsIHwgMCkpO1xuICAgICAgICAoeyBoOiBEaCwgbDogRGwgfSA9IHU2NC5hZGQodGhpcy5EaCB8IDAsIHRoaXMuRGwgfCAwLCBEaCB8IDAsIERsIHwgMCkpO1xuICAgICAgICAoeyBoOiBFaCwgbDogRWwgfSA9IHU2NC5hZGQodGhpcy5FaCB8IDAsIHRoaXMuRWwgfCAwLCBFaCB8IDAsIEVsIHwgMCkpO1xuICAgICAgICAoeyBoOiBGaCwgbDogRmwgfSA9IHU2NC5hZGQodGhpcy5GaCB8IDAsIHRoaXMuRmwgfCAwLCBGaCB8IDAsIEZsIHwgMCkpO1xuICAgICAgICAoeyBoOiBHaCwgbDogR2wgfSA9IHU2NC5hZGQodGhpcy5HaCB8IDAsIHRoaXMuR2wgfCAwLCBHaCB8IDAsIEdsIHwgMCkpO1xuICAgICAgICAoeyBoOiBIaCwgbDogSGwgfSA9IHU2NC5hZGQodGhpcy5IaCB8IDAsIHRoaXMuSGwgfCAwLCBIaCB8IDAsIEhsIHwgMCkpO1xuICAgICAgICB0aGlzLnNldChBaCwgQWwsIEJoLCBCbCwgQ2gsIENsLCBEaCwgRGwsIEVoLCBFbCwgRmgsIEZsLCBHaCwgR2wsIEhoLCBIbCk7XG4gICAgfVxuICAgIHJvdW5kQ2xlYW4oKSB7XG4gICAgICAgIFNIQTUxMl9XX0guZmlsbCgwKTtcbiAgICAgICAgU0hBNTEyX1dfTC5maWxsKDApO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICB0aGlzLmJ1ZmZlci5maWxsKDApO1xuICAgICAgICB0aGlzLnNldCgwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwKTtcbiAgICB9XG59XG5jbGFzcyBTSEE1MTJfMjI0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4OGMzZDM3YzggfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHgxOTU0NGRhMiB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDczZTE5OTY2IHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4ODlkY2Q0ZDYgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHgxZGZhYjdhZSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMyZmY5YzgyIHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4Njc5ZGQ1MTQgfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHg1ODJmOWZjZiB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDBmNmQyYjY5IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4N2JkNDRkYTggfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg3N2UzNmY3MyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDA0YzQ4OTQyIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4M2Y5ZDg1YTggfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2YTFkMzZjOCB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDExMTJlNmFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4OTFkNjkyYTEgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbmNsYXNzIFNIQTUxMl8yNTYgZXh0ZW5kcyBTSEE1MTIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBoIC0tIGhpZ2ggMzIgYml0cywgbCAtLSBsb3cgMzIgYml0c1xuICAgICAgICB0aGlzLkFoID0gMHgyMjMxMjE5NCB8IDA7XG4gICAgICAgIHRoaXMuQWwgPSAweGZjMmJmNzJjIHwgMDtcbiAgICAgICAgdGhpcy5CaCA9IDB4OWY1NTVmYTMgfCAwO1xuICAgICAgICB0aGlzLkJsID0gMHhjODRjNjRjMiB8IDA7XG4gICAgICAgIHRoaXMuQ2ggPSAweDIzOTNiODZiIHwgMDtcbiAgICAgICAgdGhpcy5DbCA9IDB4NmY1M2IxNTEgfCAwO1xuICAgICAgICB0aGlzLkRoID0gMHg5NjM4NzcxOSB8IDA7XG4gICAgICAgIHRoaXMuRGwgPSAweDU5NDBlYWJkIHwgMDtcbiAgICAgICAgdGhpcy5FaCA9IDB4OTYyODNlZTIgfCAwO1xuICAgICAgICB0aGlzLkVsID0gMHhhODhlZmZlMyB8IDA7XG4gICAgICAgIHRoaXMuRmggPSAweGJlNWUxZTI1IHwgMDtcbiAgICAgICAgdGhpcy5GbCA9IDB4NTM4NjM5OTIgfCAwO1xuICAgICAgICB0aGlzLkdoID0gMHgyYjAxOTlmYyB8IDA7XG4gICAgICAgIHRoaXMuR2wgPSAweDJjODViOGFhIHwgMDtcbiAgICAgICAgdGhpcy5IaCA9IDB4MGViNzJkZGMgfCAwO1xuICAgICAgICB0aGlzLkhsID0gMHg4MWM1MmNhMiB8IDA7XG4gICAgICAgIHRoaXMub3V0cHV0TGVuID0gMzI7XG4gICAgfVxufVxuY2xhc3MgU0hBMzg0IGV4dGVuZHMgU0hBNTEyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gaCAtLSBoaWdoIDMyIGJpdHMsIGwgLS0gbG93IDMyIGJpdHNcbiAgICAgICAgdGhpcy5BaCA9IDB4Y2JiYjlkNWQgfCAwO1xuICAgICAgICB0aGlzLkFsID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQmggPSAweDYyOWEyOTJhIHwgMDtcbiAgICAgICAgdGhpcy5CbCA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkNoID0gMHg5MTU5MDE1YSB8IDA7XG4gICAgICAgIHRoaXMuQ2wgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EaCA9IDB4MTUyZmVjZDggfCAwO1xuICAgICAgICB0aGlzLkRsID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRWggPSAweDY3MzMyNjY3IHwgMDtcbiAgICAgICAgdGhpcy5FbCA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkZoID0gMHg4ZWI0NGE4NyB8IDA7XG4gICAgICAgIHRoaXMuRmwgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HaCA9IDB4ZGIwYzJlMGQgfCAwO1xuICAgICAgICB0aGlzLkdsID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSGggPSAweDQ3YjU0ODFkIHwgMDtcbiAgICAgICAgdGhpcy5IbCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDQ4O1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBzaGE1MTIgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEE1MTIoKSk7XG5leHBvcnQgY29uc3Qgc2hhNTEyXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMl8yMjQoKSk7XG5leHBvcnQgY29uc3Qgc2hhNTEyXzI1NiA9IC8qIEBfX1BVUkVfXyAqLyB3cmFwQ29uc3RydWN0b3IoKCkgPT4gbmV3IFNIQTUxMl8yNTYoKSk7XG5leHBvcnQgY29uc3Qgc2hhMzg0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMzg0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhNTEyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/sha512.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: function() { return /* binding */ Hash; },\n/* harmony export */   asyncLoop: function() { return /* binding */ asyncLoop; },\n/* harmony export */   byteSwap: function() { return /* binding */ byteSwap; },\n/* harmony export */   byteSwap32: function() { return /* binding */ byteSwap32; },\n/* harmony export */   byteSwapIfBE: function() { return /* binding */ byteSwapIfBE; },\n/* harmony export */   bytesToHex: function() { return /* binding */ bytesToHex; },\n/* harmony export */   checkOpts: function() { return /* binding */ checkOpts; },\n/* harmony export */   concatBytes: function() { return /* binding */ concatBytes; },\n/* harmony export */   createView: function() { return /* binding */ createView; },\n/* harmony export */   hexToBytes: function() { return /* binding */ hexToBytes; },\n/* harmony export */   isBytes: function() { return /* binding */ isBytes; },\n/* harmony export */   isLE: function() { return /* binding */ isLE; },\n/* harmony export */   nextTick: function() { return /* binding */ nextTick; },\n/* harmony export */   randomBytes: function() { return /* binding */ randomBytes; },\n/* harmony export */   rotl: function() { return /* binding */ rotl; },\n/* harmony export */   rotr: function() { return /* binding */ rotr; },\n/* harmony export */   toBytes: function() { return /* binding */ toBytes; },\n/* harmony export */   u32: function() { return /* binding */ u32; },\n/* harmony export */   u8: function() { return /* binding */ u8; },\n/* harmony export */   utf8ToBytes: function() { return /* binding */ utf8ToBytes; },\n/* harmony export */   wrapConstructor: function() { return /* binding */ wrapConstructor; },\n/* harmony export */   wrapConstructorWithOpts: function() { return /* binding */ wrapConstructorWithOpts; },\n/* harmony export */   wrapXOFConstructorWithOpts: function() { return /* binding */ wrapXOFConstructorWithOpts; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/crypto.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/_assert.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nconst byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDOEM7QUFDQztBQUMvQyxZQUFZLFVBQVU7QUFDdEI7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1Asb0JBQW9CLGdCQUFnQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxhQUFhO0FBQ3hEO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsSUFBSSxpREFBTTtBQUNWO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsV0FBVztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLElBQUksaURBQU07QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQSxRQUFRLGlEQUFNO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNUO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQLFFBQVEsd0RBQU0sV0FBVyx3REFBTTtBQUMvQixlQUFlLHdEQUFNO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Abm9ibGUvY3VydmVzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS91dGlscy5qcz9hNzc5Il0sInNvdXJjZXNDb250ZW50IjpbIi8qISBub2JsZS1oYXNoZXMgLSBNSVQgTGljZW5zZSAoYykgMjAyMiBQYXVsIE1pbGxlciAocGF1bG1pbGxyLmNvbSkgKi9cbi8vIFdlIHVzZSBXZWJDcnlwdG8gYWthIGdsb2JhbFRoaXMuY3J5cHRvLCB3aGljaCBleGlzdHMgaW4gYnJvd3NlcnMgYW5kIG5vZGUuanMgMTYrLlxuLy8gbm9kZS5qcyB2ZXJzaW9ucyBlYXJsaWVyIHRoYW4gdjE5IGRvbid0IGRlY2xhcmUgaXQgaW4gZ2xvYmFsIHNjb3BlLlxuLy8gRm9yIG5vZGUuanMsIHBhY2thZ2UuanNvbiNleHBvcnRzIGZpZWxkIG1hcHBpbmcgcmV3cml0ZXMgaW1wb3J0XG4vLyBmcm9tIGBjcnlwdG9gIHRvIGBjcnlwdG9Ob2RlYCwgd2hpY2ggaW1wb3J0cyBuYXRpdmUgbW9kdWxlLlxuLy8gTWFrZXMgdGhlIHV0aWxzIHVuLWltcG9ydGFibGUgaW4gYnJvd3NlcnMgd2l0aG91dCBhIGJ1bmRsZXIuXG4vLyBPbmNlIG5vZGUuanMgMTggaXMgZGVwcmVjYXRlZCAoMjAyNS0wNC0zMCksIHdlIGNhbiBqdXN0IGRyb3AgdGhlIGltcG9ydC5cbmltcG9ydCB7IGNyeXB0byB9IGZyb20gJ0Bub2JsZS9oYXNoZXMvY3J5cHRvJztcbmltcG9ydCB7IGJ5dGVzIGFzIGFieXRlcyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG4vLyBleHBvcnQgeyBpc0J5dGVzIH0gZnJvbSAnLi9fYXNzZXJ0LmpzJztcbi8vIFdlIGNhbid0IHJldXNlIGlzQnl0ZXMgZnJvbSBfYXNzZXJ0LCBiZWNhdXNlIHNvbWVob3cgdGhpcyBjYXVzZXMgaHVnZSBwZXJmIGlzc3Vlc1xuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXMoYSkge1xuICAgIHJldHVybiAoYSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgfHxcbiAgICAgICAgKGEgIT0gbnVsbCAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcgJiYgYS5jb25zdHJ1Y3Rvci5uYW1lID09PSAnVWludDhBcnJheScpKTtcbn1cbi8vIENhc3QgYXJyYXkgdG8gZGlmZmVyZW50IHR5cGVcbmV4cG9ydCBjb25zdCB1OCA9IChhcnIpID0+IG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBhcnIuYnl0ZUxlbmd0aCk7XG5leHBvcnQgY29uc3QgdTMyID0gKGFycikgPT4gbmV3IFVpbnQzMkFycmF5KGFyci5idWZmZXIsIGFyci5ieXRlT2Zmc2V0LCBNYXRoLmZsb29yKGFyci5ieXRlTGVuZ3RoIC8gNCkpO1xuLy8gQ2FzdCBhcnJheSB0byB2aWV3XG5leHBvcnQgY29uc3QgY3JlYXRlVmlldyA9IChhcnIpID0+IG5ldyBEYXRhVmlldyhhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuLy8gVGhlIHJvdGF0ZSByaWdodCAoY2lyY3VsYXIgcmlnaHQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90ciA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgKDMyIC0gc2hpZnQpKSB8ICh3b3JkID4+PiBzaGlmdCk7XG4vLyBUaGUgcm90YXRlIGxlZnQgKGNpcmN1bGFyIGxlZnQgc2hpZnQpIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3Qgcm90bCA9ICh3b3JkLCBzaGlmdCkgPT4gKHdvcmQgPDwgc2hpZnQpIHwgKCh3b3JkID4+PiAoMzIgLSBzaGlmdCkpID4+PiAwKTtcbmV4cG9ydCBjb25zdCBpc0xFID0gbmV3IFVpbnQ4QXJyYXkobmV3IFVpbnQzMkFycmF5KFsweDExMjIzMzQ0XSkuYnVmZmVyKVswXSA9PT0gMHg0NDtcbi8vIFRoZSBieXRlIHN3YXAgb3BlcmF0aW9uIGZvciB1aW50MzJcbmV4cG9ydCBjb25zdCBieXRlU3dhcCA9ICh3b3JkKSA9PiAoKHdvcmQgPDwgMjQpICYgMHhmZjAwMDAwMCkgfFxuICAgICgod29yZCA8PCA4KSAmIDB4ZmYwMDAwKSB8XG4gICAgKCh3b3JkID4+PiA4KSAmIDB4ZmYwMCkgfFxuICAgICgod29yZCA+Pj4gMjQpICYgMHhmZik7XG4vLyBDb25kaXRpb25hbGx5IGJ5dGUgc3dhcCBpZiBvbiBhIGJpZy1lbmRpYW4gcGxhdGZvcm1cbmV4cG9ydCBjb25zdCBieXRlU3dhcElmQkUgPSBpc0xFID8gKG4pID0+IG4gOiAobikgPT4gYnl0ZVN3YXAobik7XG4vLyBJbiBwbGFjZSBieXRlIHN3YXAgZm9yIFVpbnQzMkFycmF5XG5leHBvcnQgZnVuY3Rpb24gYnl0ZVN3YXAzMihhcnIpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBieXRlU3dhcChhcnJbaV0pO1xuICAgIH1cbn1cbi8vIEFycmF5IHdoZXJlIGluZGV4IDB4ZjAgKDI0MCkgaXMgbWFwcGVkIHRvIHN0cmluZyAnZjAnXG5jb25zdCBoZXhlcyA9IC8qIEBfX1BVUkVfXyAqLyBBcnJheS5mcm9tKHsgbGVuZ3RoOiAyNTYgfSwgKF8sIGkpID0+IGkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJykpO1xuLyoqXG4gKiBAZXhhbXBsZSBieXRlc1RvSGV4KFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pKSAvLyAnY2FmZTAxMjMnXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBieXRlc1RvSGV4KGJ5dGVzKSB7XG4gICAgYWJ5dGVzKGJ5dGVzKTtcbiAgICAvLyBwcmUtY2FjaGluZyBpbXByb3ZlcyB0aGUgc3BlZWQgNnhcbiAgICBsZXQgaGV4ID0gJyc7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBoZXggKz0gaGV4ZXNbYnl0ZXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gaGV4O1xufVxuLy8gV2UgdXNlIG9wdGltaXplZCB0ZWNobmlxdWUgdG8gY29udmVydCBoZXggc3RyaW5nIHRvIGJ5dGUgYXJyYXlcbmNvbnN0IGFzY2lpcyA9IHsgXzA6IDQ4LCBfOTogNTcsIF9BOiA2NSwgX0Y6IDcwLCBfYTogOTcsIF9mOiAxMDIgfTtcbmZ1bmN0aW9uIGFzY2lpVG9CYXNlMTYoY2hhcikge1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fMCAmJiBjaGFyIDw9IGFzY2lpcy5fOSlcbiAgICAgICAgcmV0dXJuIGNoYXIgLSBhc2NpaXMuXzA7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9BICYmIGNoYXIgPD0gYXNjaWlzLl9GKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX0EgLSAxMCk7XG4gICAgaWYgKGNoYXIgPj0gYXNjaWlzLl9hICYmIGNoYXIgPD0gYXNjaWlzLl9mKVxuICAgICAgICByZXR1cm4gY2hhciAtIChhc2NpaXMuX2EgLSAxMCk7XG4gICAgcmV0dXJuO1xufVxuLyoqXG4gKiBAZXhhbXBsZSBoZXhUb0J5dGVzKCdjYWZlMDEyMycpIC8vIFVpbnQ4QXJyYXkuZnJvbShbMHhjYSwgMHhmZSwgMHgwMSwgMHgyM10pXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZXhUb0J5dGVzKGhleCkge1xuICAgIGlmICh0eXBlb2YgaGV4ICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgJyArIHR5cGVvZiBoZXgpO1xuICAgIGNvbnN0IGhsID0gaGV4Lmxlbmd0aDtcbiAgICBjb25zdCBhbCA9IGhsIC8gMjtcbiAgICBpZiAoaGwgJSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3BhZGRlZCBoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3QgdW5wYWRkZWQgaGV4IG9mIGxlbmd0aCAnICsgaGwpO1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoYWwpO1xuICAgIGZvciAobGV0IGFpID0gMCwgaGkgPSAwOyBhaSA8IGFsOyBhaSsrLCBoaSArPSAyKSB7XG4gICAgICAgIGNvbnN0IG4xID0gYXNjaWlUb0Jhc2UxNihoZXguY2hhckNvZGVBdChoaSkpO1xuICAgICAgICBjb25zdCBuMiA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkgKyAxKSk7XG4gICAgICAgIGlmIChuMSA9PT0gdW5kZWZpbmVkIHx8IG4yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXIgPSBoZXhbaGldICsgaGV4W2hpICsgMV07XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2hleCBzdHJpbmcgZXhwZWN0ZWQsIGdvdCBub24taGV4IGNoYXJhY3RlciBcIicgKyBjaGFyICsgJ1wiIGF0IGluZGV4ICcgKyBoaSk7XG4gICAgICAgIH1cbiAgICAgICAgYXJyYXlbYWldID0gbjEgKiAxNiArIG4yO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG4vLyBUaGVyZSBpcyBubyBzZXRJbW1lZGlhdGUgaW4gYnJvd3NlciBhbmQgc2V0VGltZW91dCBpcyBzbG93LlxuLy8gY2FsbCBvZiBhc3luYyBmbiB3aWxsIHJldHVybiBQcm9taXNlLCB3aGljaCB3aWxsIGJlIGZ1bGxmaWxlZCBvbmx5IG9uXG4vLyBuZXh0IHNjaGVkdWxlciBxdWV1ZSBwcm9jZXNzaW5nIHN0ZXAgYW5kIHRoaXMgaXMgZXhhY3RseSB3aGF0IHdlIG5lZWQuXG5leHBvcnQgY29uc3QgbmV4dFRpY2sgPSBhc3luYyAoKSA9PiB7IH07XG4vLyBSZXR1cm5zIGNvbnRyb2wgdG8gdGhyZWFkIGVhY2ggJ3RpY2snIG1zIHRvIGF2b2lkIGJsb2NraW5nXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gYXN5bmNMb29wKGl0ZXJzLCB0aWNrLCBjYikge1xuICAgIGxldCB0cyA9IERhdGUubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyczsgaSsrKSB7XG4gICAgICAgIGNiKGkpO1xuICAgICAgICAvLyBEYXRlLm5vdygpIGlzIG5vdCBtb25vdG9uaWMsIHNvIGluIGNhc2UgaWYgY2xvY2sgZ29lcyBiYWNrd2FyZHMgd2UgcmV0dXJuIHJldHVybiBjb250cm9sIHRvb1xuICAgICAgICBjb25zdCBkaWZmID0gRGF0ZS5ub3coKSAtIHRzO1xuICAgICAgICBpZiAoZGlmZiA+PSAwICYmIGRpZmYgPCB0aWNrKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGF3YWl0IG5leHRUaWNrKCk7XG4gICAgICAgIHRzICs9IGRpZmY7XG4gICAgfVxufVxuLyoqXG4gKiBAZXhhbXBsZSB1dGY4VG9CeXRlcygnYWJjJykgLy8gbmV3IFVpbnQ4QXJyYXkoWzk3LCA5OCwgOTldKVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXRmOFRvQnl0ZXMoc3RyKSB7XG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHV0ZjhUb0J5dGVzIGV4cGVjdGVkIHN0cmluZywgZ290ICR7dHlwZW9mIHN0cn1gKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkobmV3IFRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpOyAvLyBodHRwczovL2J1Z3ppbC5sYS8xNjgxODA5XG59XG4vKipcbiAqIE5vcm1hbGl6ZXMgKG5vbi1oZXgpIHN0cmluZyBvciBVaW50OEFycmF5IHRvIFVpbnQ4QXJyYXkuXG4gKiBXYXJuaW5nOiB3aGVuIFVpbnQ4QXJyYXkgaXMgcGFzc2VkLCBpdCB3b3VsZCBOT1QgZ2V0IGNvcGllZC5cbiAqIEtlZXAgaW4gbWluZCBmb3IgZnV0dXJlIG11dGFibGUgb3BlcmF0aW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvQnl0ZXMoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpXG4gICAgICAgIGRhdGEgPSB1dGY4VG9CeXRlcyhkYXRhKTtcbiAgICBhYnl0ZXMoZGF0YSk7XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIENvcGllcyBzZXZlcmFsIFVpbnQ4QXJyYXlzIGludG8gb25lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0Qnl0ZXMoLi4uYXJyYXlzKSB7XG4gICAgbGV0IHN1bSA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgYWJ5dGVzKGEpO1xuICAgICAgICBzdW0gKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIGNvbnN0IHJlcyA9IG5ldyBVaW50OEFycmF5KHN1bSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIHBhZCA9IDA7IGkgPCBhcnJheXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFycmF5c1tpXTtcbiAgICAgICAgcmVzLnNldChhLCBwYWQpO1xuICAgICAgICBwYWQgKz0gYS5sZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG59XG4vLyBGb3IgcnVudGltZSBjaGVjayBpZiBjbGFzcyBpbXBsZW1lbnRzIGludGVyZmFjZVxuZXhwb3J0IGNsYXNzIEhhc2gge1xuICAgIC8vIFNhZmUgdmVyc2lvbiB0aGF0IGNsb25lcyBpbnRlcm5hbCBzdGF0ZVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvbmVJbnRvKCk7XG4gICAgfVxufVxuY29uc3QgdG9TdHIgPSB7fS50b1N0cmluZztcbmV4cG9ydCBmdW5jdGlvbiBjaGVja09wdHMoZGVmYXVsdHMsIG9wdHMpIHtcbiAgICBpZiAob3B0cyAhPT0gdW5kZWZpbmVkICYmIHRvU3RyLmNhbGwob3B0cykgIT09ICdbb2JqZWN0IE9iamVjdF0nKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09wdGlvbnMgc2hvdWxkIGJlIG9iamVjdCBvciB1bmRlZmluZWQnKTtcbiAgICBjb25zdCBtZXJnZWQgPSBPYmplY3QuYXNzaWduKGRlZmF1bHRzLCBvcHRzKTtcbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcihoYXNoQ29ucykge1xuICAgIGNvbnN0IGhhc2hDID0gKG1zZykgPT4gaGFzaENvbnMoKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucygpO1xuICAgIGhhc2hDLm91dHB1dExlbiA9IHRtcC5vdXRwdXRMZW47XG4gICAgaGFzaEMuYmxvY2tMZW4gPSB0bXAuYmxvY2tMZW47XG4gICAgaGFzaEMuY3JlYXRlID0gKCkgPT4gaGFzaENvbnMoKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcENvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG5leHBvcnQgZnVuY3Rpb24gd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2csIG9wdHMpID0+IGhhc2hDb25zKG9wdHMpLnVwZGF0ZSh0b0J5dGVzKG1zZykpLmRpZ2VzdCgpO1xuICAgIGNvbnN0IHRtcCA9IGhhc2hDb25zKHt9KTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9IChvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKTtcbiAgICByZXR1cm4gaGFzaEM7XG59XG4vKipcbiAqIFNlY3VyZSBQUk5HLiBVc2VzIGBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzYCwgd2hpY2ggZGVmZXJzIHRvIE9TLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmFuZG9tQnl0ZXMoYnl0ZXNMZW5ndGggPSAzMikge1xuICAgIGlmIChjcnlwdG8gJiYgdHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXNMZW5ndGgpKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIG11c3QgYmUgZGVmaW5lZCcpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@noble/curves/node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/lib/esm/index.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/lib/esm/index.js ***!
  \********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   transact: function() { return /* binding */ transact; }\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _solana_mobile_mobile_wallet_adapter_protocol__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana-mobile/mobile-wallet-adapter-protocol */ \"(app-pages-browser)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bs58 */ \"(app-pages-browser)/./node_modules/bs58/index.js\");\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nfunction fromUint8Array(byteArray) {\n    return window.btoa(String.fromCharCode.call(null, ...byteArray));\n}\nfunction toUint8Array(base64EncodedByteArray) {\n    return new Uint8Array(window\n        .atob(base64EncodedByteArray)\n        .split('')\n        .map((c) => c.charCodeAt(0)));\n}\n\nfunction getPayloadFromTransaction(transaction) {\n    const serializedTransaction = 'version' in transaction\n        ? transaction.serialize()\n        : transaction.serialize({\n            requireAllSignatures: false,\n            verifySignatures: false,\n        });\n    const payload = fromUint8Array(serializedTransaction);\n    return payload;\n}\nfunction getTransactionFromWireMessage(byteArray) {\n    const numSignatures = byteArray[0];\n    const messageOffset = numSignatures * _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.SIGNATURE_LENGTH_IN_BYTES + 1;\n    const version = _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.VersionedMessage.deserializeMessageVersion(byteArray.slice(messageOffset, byteArray.length));\n    if (version === 'legacy') {\n        return _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction.from(byteArray);\n    }\n    else {\n        return _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.VersionedTransaction.deserialize(byteArray);\n    }\n}\nfunction transact(callback, config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const augmentedCallback = (wallet) => {\n            const augmentedAPI = new Proxy({}, {\n                get(target, p) {\n                    if (target[p] == null) {\n                        switch (p) {\n                            case 'signAndSendTransactions':\n                                target[p] = function (_a) {\n                                    var { minContextSlot, commitment, skipPreflight, maxRetries, waitForCommitmentToSendNextTransaction, transactions } = _a, rest = __rest(_a, [\"minContextSlot\", \"commitment\", \"skipPreflight\", \"maxRetries\", \"waitForCommitmentToSendNextTransaction\", \"transactions\"]);\n                                    return __awaiter(this, void 0, void 0, function* () {\n                                        const payloads = transactions.map(getPayloadFromTransaction);\n                                        const options = {\n                                            min_context_slot: minContextSlot,\n                                            commitment: commitment,\n                                            skip_preflight: skipPreflight,\n                                            max_retries: maxRetries,\n                                            wait_for_commitment_to_send_next_transaction: waitForCommitmentToSendNextTransaction\n                                        };\n                                        const { signatures: base64EncodedSignatures } = yield wallet.signAndSendTransactions(Object.assign(Object.assign(Object.assign({}, rest), (Object.values(options).some(element => element != null)\n                                            ? { options: options }\n                                            : null)), { payloads }));\n                                        const signatures = base64EncodedSignatures.map(toUint8Array).map(bs58__WEBPACK_IMPORTED_MODULE_2__.encode);\n                                        return signatures;\n                                    });\n                                };\n                                break;\n                            case 'signMessages':\n                                target[p] = function (_a) {\n                                    var { payloads } = _a, rest = __rest(_a, [\"payloads\"]);\n                                    return __awaiter(this, void 0, void 0, function* () {\n                                        const base64EncodedPayloads = payloads.map(fromUint8Array);\n                                        const { signed_payloads: base64EncodedSignedMessages } = yield wallet.signMessages(Object.assign(Object.assign({}, rest), { payloads: base64EncodedPayloads }));\n                                        const signedMessages = base64EncodedSignedMessages.map(toUint8Array);\n                                        return signedMessages;\n                                    });\n                                };\n                                break;\n                            case 'signTransactions':\n                                target[p] = function (_a) {\n                                    var { transactions } = _a, rest = __rest(_a, [\"transactions\"]);\n                                    return __awaiter(this, void 0, void 0, function* () {\n                                        const payloads = transactions.map(getPayloadFromTransaction);\n                                        const { signed_payloads: base64EncodedCompiledTransactions } = yield wallet.signTransactions(Object.assign(Object.assign({}, rest), { payloads }));\n                                        const compiledTransactions = base64EncodedCompiledTransactions.map(toUint8Array);\n                                        const signedTransactions = compiledTransactions.map(getTransactionFromWireMessage);\n                                        return signedTransactions;\n                                    });\n                                };\n                                break;\n                            default: {\n                                target[p] = wallet[p];\n                                break;\n                            }\n                        }\n                    }\n                    return target[p];\n                },\n                defineProperty() {\n                    return false;\n                },\n                deleteProperty() {\n                    return false;\n                },\n            });\n            return callback(augmentedAPI);\n        };\n        return yield (0,_solana_mobile_mobile_wallet_adapter_protocol__WEBPACK_IMPORTED_MODULE_1__.transact)(augmentedCallback, config);\n    });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hLW1vYmlsZS9tb2JpbGUtd2FsbGV0LWFkYXB0ZXItcHJvdG9jb2wtd2ViM2pzL2xpYi9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFpSDtBQUMxQjtBQUMvRDs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNFQUF5QjtBQUNuRSxvQkFBb0IsNkRBQWdCO0FBQ3BDO0FBQ0EsZUFBZSx3REFBVztBQUMxQjtBQUNBO0FBQ0EsZUFBZSxpRUFBb0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDhHQUE4RztBQUN4SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsc0NBQXNDLG1GQUFtRjtBQUN6SyxnREFBZ0Q7QUFDaEQsd0RBQXdELFVBQVU7QUFDbEUseUdBQXlHLHdDQUFXO0FBQ3BIO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBLGdEQUFnRCwrQ0FBK0MsMERBQTBELFdBQVcsaUNBQWlDO0FBQ3JNO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZUFBZTtBQUN6RDtBQUNBO0FBQ0EsZ0RBQWdELHFEQUFxRCw4REFBOEQsV0FBVyxVQUFVO0FBQ3hMO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EscUJBQXFCLHVGQUFVO0FBQy9CLEtBQUs7QUFDTDs7QUFFb0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEtbW9iaWxlL21vYmlsZS13YWxsZXQtYWRhcHRlci1wcm90b2NvbC13ZWIzanMvbGliL2VzbS9pbmRleC5qcz81ZmFhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlcnNpb25lZE1lc3NhZ2UsIFRyYW5zYWN0aW9uLCBWZXJzaW9uZWRUcmFuc2FjdGlvbiwgU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5pbXBvcnQgeyB0cmFuc2FjdCBhcyB0cmFuc2FjdCQxIH0gZnJvbSAnQHNvbGFuYS1tb2JpbGUvbW9iaWxlLXdhbGxldC1hZGFwdGVyLXByb3RvY29sJztcbmltcG9ydCBiczU4IGZyb20gJ2JzNTgnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxuXG5mdW5jdGlvbiBmcm9tVWludDhBcnJheShieXRlQXJyYXkpIHtcbiAgICByZXR1cm4gd2luZG93LmJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZS5jYWxsKG51bGwsIC4uLmJ5dGVBcnJheSkpO1xufVxuZnVuY3Rpb24gdG9VaW50OEFycmF5KGJhc2U2NEVuY29kZWRCeXRlQXJyYXkpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkod2luZG93XG4gICAgICAgIC5hdG9iKGJhc2U2NEVuY29kZWRCeXRlQXJyYXkpXG4gICAgICAgIC5zcGxpdCgnJylcbiAgICAgICAgLm1hcCgoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG59XG5cbmZ1bmN0aW9uIGdldFBheWxvYWRGcm9tVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSAndmVyc2lvbicgaW4gdHJhbnNhY3Rpb25cbiAgICAgICAgPyB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKVxuICAgICAgICA6IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSh7XG4gICAgICAgICAgICByZXF1aXJlQWxsU2lnbmF0dXJlczogZmFsc2UsXG4gICAgICAgICAgICB2ZXJpZnlTaWduYXR1cmVzOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgY29uc3QgcGF5bG9hZCA9IGZyb21VaW50OEFycmF5KHNlcmlhbGl6ZWRUcmFuc2FjdGlvbik7XG4gICAgcmV0dXJuIHBheWxvYWQ7XG59XG5mdW5jdGlvbiBnZXRUcmFuc2FjdGlvbkZyb21XaXJlTWVzc2FnZShieXRlQXJyYXkpIHtcbiAgICBjb25zdCBudW1TaWduYXR1cmVzID0gYnl0ZUFycmF5WzBdO1xuICAgIGNvbnN0IG1lc3NhZ2VPZmZzZXQgPSBudW1TaWduYXR1cmVzICogU0lHTkFUVVJFX0xFTkdUSF9JTl9CWVRFUyArIDE7XG4gICAgY29uc3QgdmVyc2lvbiA9IFZlcnNpb25lZE1lc3NhZ2UuZGVzZXJpYWxpemVNZXNzYWdlVmVyc2lvbihieXRlQXJyYXkuc2xpY2UobWVzc2FnZU9mZnNldCwgYnl0ZUFycmF5Lmxlbmd0aCkpO1xuICAgIGlmICh2ZXJzaW9uID09PSAnbGVnYWN5Jykge1xuICAgICAgICByZXR1cm4gVHJhbnNhY3Rpb24uZnJvbShieXRlQXJyYXkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFZlcnNpb25lZFRyYW5zYWN0aW9uLmRlc2VyaWFsaXplKGJ5dGVBcnJheSk7XG4gICAgfVxufVxuZnVuY3Rpb24gdHJhbnNhY3QoY2FsbGJhY2ssIGNvbmZpZykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGF1Z21lbnRlZENhbGxiYWNrID0gKHdhbGxldCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXVnbWVudGVkQVBJID0gbmV3IFByb3h5KHt9LCB7XG4gICAgICAgICAgICAgICAgZ2V0KHRhcmdldCwgcCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0W3BdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAocCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NpZ25BbmRTZW5kVHJhbnNhY3Rpb25zJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W3BdID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeyBtaW5Db250ZXh0U2xvdCwgY29tbWl0bWVudCwgc2tpcFByZWZsaWdodCwgbWF4UmV0cmllcywgd2FpdEZvckNvbW1pdG1lbnRUb1NlbmROZXh0VHJhbnNhY3Rpb24sIHRyYW5zYWN0aW9ucyB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcIm1pbkNvbnRleHRTbG90XCIsIFwiY29tbWl0bWVudFwiLCBcInNraXBQcmVmbGlnaHRcIiwgXCJtYXhSZXRyaWVzXCIsIFwid2FpdEZvckNvbW1pdG1lbnRUb1NlbmROZXh0VHJhbnNhY3Rpb25cIiwgXCJ0cmFuc2FjdGlvbnNcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXlsb2FkcyA9IHRyYW5zYWN0aW9ucy5tYXAoZ2V0UGF5bG9hZEZyb21UcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWluX2NvbnRleHRfc2xvdDogbWluQ29udGV4dFNsb3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IGNvbW1pdG1lbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBfcHJlZmxpZ2h0OiBza2lwUHJlZmxpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhfcmV0cmllczogbWF4UmV0cmllcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FpdF9mb3JfY29tbWl0bWVudF90b19zZW5kX25leHRfdHJhbnNhY3Rpb246IHdhaXRGb3JDb21taXRtZW50VG9TZW5kTmV4dFRyYW5zYWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IHNpZ25hdHVyZXM6IGJhc2U2NEVuY29kZWRTaWduYXR1cmVzIH0gPSB5aWVsZCB3YWxsZXQuc2lnbkFuZFNlbmRUcmFuc2FjdGlvbnMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpLCAoT2JqZWN0LnZhbHVlcyhvcHRpb25zKS5zb21lKGVsZW1lbnQgPT4gZWxlbWVudCAhPSBudWxsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHsgb3B0aW9uczogb3B0aW9ucyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbnVsbCkpLCB7IHBheWxvYWRzIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduYXR1cmVzID0gYmFzZTY0RW5jb2RlZFNpZ25hdHVyZXMubWFwKHRvVWludDhBcnJheSkubWFwKGJzNTguZW5jb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzaWduTWVzc2FnZXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcF0gPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB7IHBheWxvYWRzIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wicGF5bG9hZHNcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBiYXNlNjRFbmNvZGVkUGF5bG9hZHMgPSBwYXlsb2Fkcy5tYXAoZnJvbVVpbnQ4QXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2lnbmVkX3BheWxvYWRzOiBiYXNlNjRFbmNvZGVkU2lnbmVkTWVzc2FnZXMgfSA9IHlpZWxkIHdhbGxldC5zaWduTWVzc2FnZXMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0KSwgeyBwYXlsb2FkczogYmFzZTY0RW5jb2RlZFBheWxvYWRzIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzaWduZWRNZXNzYWdlcyA9IGJhc2U2NEVuY29kZWRTaWduZWRNZXNzYWdlcy5tYXAodG9VaW50OEFycmF5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmVkTWVzc2FnZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnc2lnblRyYW5zYWN0aW9ucyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtwXSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHsgdHJhbnNhY3Rpb25zIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1widHJhbnNhY3Rpb25zXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF5bG9hZHMgPSB0cmFuc2FjdGlvbnMubWFwKGdldFBheWxvYWRGcm9tVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgc2lnbmVkX3BheWxvYWRzOiBiYXNlNjRFbmNvZGVkQ29tcGlsZWRUcmFuc2FjdGlvbnMgfSA9IHlpZWxkIHdhbGxldC5zaWduVHJhbnNhY3Rpb25zKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdCksIHsgcGF5bG9hZHMgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbXBpbGVkVHJhbnNhY3Rpb25zID0gYmFzZTY0RW5jb2RlZENvbXBpbGVkVHJhbnNhY3Rpb25zLm1hcCh0b1VpbnQ4QXJyYXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9ucyA9IGNvbXBpbGVkVHJhbnNhY3Rpb25zLm1hcChnZXRUcmFuc2FjdGlvbkZyb21XaXJlTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25lZFRyYW5zYWN0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtwXSA9IHdhbGxldFtwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcF07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eSgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZGVsZXRlUHJvcGVydHkoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soYXVnbWVudGVkQVBJKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHlpZWxkIHRyYW5zYWN0JDEoYXVnbWVudGVkQ2FsbGJhY2ssIGNvbmZpZyk7XG4gICAgfSk7XG59XG5cbmV4cG9ydCB7IHRyYW5zYWN0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/lib/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaCloneAuthorization: function() { return /* binding */ SolanaCloneAuthorization; },\n/* harmony export */   SolanaMobileWalletAdapterError: function() { return /* binding */ SolanaMobileWalletAdapterError; },\n/* harmony export */   SolanaMobileWalletAdapterErrorCode: function() { return /* binding */ SolanaMobileWalletAdapterErrorCode; },\n/* harmony export */   SolanaMobileWalletAdapterProtocolError: function() { return /* binding */ SolanaMobileWalletAdapterProtocolError; },\n/* harmony export */   SolanaMobileWalletAdapterProtocolErrorCode: function() { return /* binding */ SolanaMobileWalletAdapterProtocolErrorCode; },\n/* harmony export */   SolanaSignInWithSolana: function() { return /* binding */ SolanaSignInWithSolana; },\n/* harmony export */   SolanaSignTransactions: function() { return /* binding */ SolanaSignTransactions; },\n/* harmony export */   transact: function() { return /* binding */ transact; }\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/wallet-standard-util */ \"(app-pages-browser)/./node_modules/@solana/wallet-standard-util/lib/esm/signIn.js\");\n\n\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaMobileWalletAdapterErrorCode = {\n    ERROR_ASSOCIATION_PORT_OUT_OF_RANGE: 'ERROR_ASSOCIATION_PORT_OUT_OF_RANGE',\n    ERROR_FORBIDDEN_WALLET_BASE_URL: 'ERROR_FORBIDDEN_WALLET_BASE_URL',\n    ERROR_SECURE_CONTEXT_REQUIRED: 'ERROR_SECURE_CONTEXT_REQUIRED',\n    ERROR_SESSION_CLOSED: 'ERROR_SESSION_CLOSED',\n    ERROR_SESSION_TIMEOUT: 'ERROR_SESSION_TIMEOUT',\n    ERROR_WALLET_NOT_FOUND: 'ERROR_WALLET_NOT_FOUND',\n    ERROR_INVALID_PROTOCOL_VERSION: 'ERROR_INVALID_PROTOCOL_VERSION',\n};\nclass SolanaMobileWalletAdapterError extends Error {\n    constructor(...args) {\n        const [code, message, data] = args;\n        super(message);\n        this.code = code;\n        this.data = data;\n        this.name = 'SolanaMobileWalletAdapterError';\n    }\n}\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst SolanaMobileWalletAdapterProtocolErrorCode = {\n    // Keep these in sync with `mobilewalletadapter/common/ProtocolContract.java`.\n    ERROR_AUTHORIZATION_FAILED: -1,\n    ERROR_INVALID_PAYLOADS: -2,\n    ERROR_NOT_SIGNED: -3,\n    ERROR_NOT_SUBMITTED: -4,\n    ERROR_TOO_MANY_PAYLOADS: -5,\n    ERROR_ATTEST_ORIGIN_ANDROID: -100,\n};\nclass SolanaMobileWalletAdapterProtocolError extends Error {\n    constructor(...args) {\n        const [jsonRpcMessageId, code, message, data] = args;\n        super(message);\n        this.code = code;\n        this.data = data;\n        this.jsonRpcMessageId = jsonRpcMessageId;\n        this.name = 'SolanaMobileWalletAdapterProtocolError';\n    }\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nfunction createHelloReq(ecdhPublicKey, associationKeypairPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const publicKeyBuffer = yield crypto.subtle.exportKey('raw', ecdhPublicKey);\n        const signatureBuffer = yield crypto.subtle.sign({ hash: 'SHA-256', name: 'ECDSA' }, associationKeypairPrivateKey, publicKeyBuffer);\n        const response = new Uint8Array(publicKeyBuffer.byteLength + signatureBuffer.byteLength);\n        response.set(new Uint8Array(publicKeyBuffer), 0);\n        response.set(new Uint8Array(signatureBuffer), publicKeyBuffer.byteLength);\n        return response;\n    });\n}\n\nfunction encode(input) {\n    return window.btoa(input);\n}\n\nfunction createSIWSMessage(payload) {\n    return (0,_solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_0__.createSignInMessageText)(payload);\n}\nfunction createSIWSMessageBase64(payload) {\n    return encode(createSIWSMessage(payload));\n}\n\n// optional features\nconst SolanaSignTransactions = 'solana:signTransactions';\nconst SolanaCloneAuthorization = 'solana:cloneAuthorization';\nconst SolanaSignInWithSolana = 'solana:signInWithSolana';\n\n/**\n * Creates a {@link MobileWallet} proxy that handles backwards compatibility and API to RPC conversion.\n *\n * @param protocolVersion the protocol version in use for this session/request\n * @param protocolRequestHandler callback function that handles sending the RPC request to the wallet endpoint.\n * @returns a {@link MobileWallet} proxy\n */\nfunction createMobileWalletProxy(protocolVersion, protocolRequestHandler) {\n    return new Proxy({}, {\n        get(target, p) {\n            if (target[p] == null) {\n                target[p] = function (inputParams) {\n                    return __awaiter(this, void 0, void 0, function* () {\n                        const { method, params } = handleMobileWalletRequest(p, inputParams, protocolVersion);\n                        const result = yield protocolRequestHandler(method, params);\n                        // if the request tried to sign in but the wallet did not return a sign in result, fallback on message signing\n                        if (method === 'authorize' && params.sign_in_payload && !result.sign_in_result) {\n                            result['sign_in_result'] = yield signInFallback(params.sign_in_payload, result, protocolRequestHandler);\n                        }\n                        return handleMobileWalletResponse(p, result, protocolVersion);\n                    });\n                };\n            }\n            return target[p];\n        },\n        defineProperty() {\n            return false;\n        },\n        deleteProperty() {\n            return false;\n        },\n    });\n}\n/**\n * Handles all {@link MobileWallet} API requests and determines the correct MWA RPC method and params to call.\n * This handles backwards compatibility, based on the provided @protocolVersion.\n *\n * @param methodName the name of {@link MobileWallet} method that was called\n * @param methodParams the parameters that were passed to the method\n * @param protocolVersion the protocol version in use for this session/request\n * @returns the RPC request method and params that should be sent to the wallet endpoint\n */\nfunction handleMobileWalletRequest(methodName, methodParams, protocolVersion) {\n    let params = methodParams;\n    let method = methodName\n        .toString()\n        .replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`)\n        .toLowerCase();\n    switch (methodName) {\n        case 'authorize': {\n            let { chain } = params;\n            if (protocolVersion === 'legacy') {\n                switch (chain) {\n                    case 'solana:testnet': {\n                        chain = 'testnet';\n                        break;\n                    }\n                    case 'solana:devnet': {\n                        chain = 'devnet';\n                        break;\n                    }\n                    case 'solana:mainnet': {\n                        chain = 'mainnet-beta';\n                        break;\n                    }\n                    default: {\n                        chain = params.cluster;\n                    }\n                }\n                params.cluster = chain;\n            }\n            else {\n                switch (chain) {\n                    case 'testnet':\n                    case 'devnet': {\n                        chain = `solana:${chain}`;\n                        break;\n                    }\n                    case 'mainnet-beta': {\n                        chain = 'solana:mainnet';\n                        break;\n                    }\n                }\n                params.chain = chain;\n            }\n        }\n        case 'reauthorize': {\n            const { auth_token, identity } = params;\n            if (auth_token) {\n                switch (protocolVersion) {\n                    case 'legacy': {\n                        method = 'reauthorize';\n                        params = { auth_token: auth_token, identity: identity };\n                        break;\n                    }\n                    default: {\n                        method = 'authorize';\n                        break;\n                    }\n                }\n            }\n            break;\n        }\n    }\n    return { method, params };\n}\n/**\n * Handles all {@link MobileWallet} API responses and modifies the response for backwards compatibility, if needed\n *\n * @param method the {@link MobileWallet} method that was called\n * @param response the original response that was returned by the method call\n * @param protocolVersion the protocol version in use for this session/request\n * @returns the possibly modified response\n */\nfunction handleMobileWalletResponse(method, response, protocolVersion) {\n    switch (method) {\n        case 'getCapabilities': {\n            const capabilities = response;\n            switch (protocolVersion) {\n                case 'legacy': {\n                    const features = [SolanaSignTransactions];\n                    if (capabilities.supports_clone_authorization === true) {\n                        features.push(SolanaCloneAuthorization);\n                    }\n                    return Object.assign(Object.assign({}, capabilities), { features: features });\n                }\n                case 'v1': {\n                    return Object.assign(Object.assign({}, capabilities), { supports_sign_and_send_transactions: true, supports_clone_authorization: capabilities.features.includes(SolanaCloneAuthorization) });\n                }\n            }\n        }\n    }\n    return response;\n}\nfunction signInFallback(signInPayload, authorizationResult, protocolRequestHandler) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n        const domain = (_a = signInPayload.domain) !== null && _a !== void 0 ? _a : window.location.host;\n        const address = authorizationResult.accounts[0].address;\n        const siwsMessage = createSIWSMessageBase64(Object.assign(Object.assign({}, signInPayload), { domain, address }));\n        const signMessageResult = yield protocolRequestHandler('sign_messages', {\n            addresses: [address],\n            payloads: [siwsMessage]\n        });\n        const signInResult = {\n            address: address,\n            signed_message: siwsMessage,\n            signature: signMessageResult.signed_payloads[0].slice(siwsMessage.length)\n        };\n        return signInResult;\n    });\n}\n\nconst SEQUENCE_NUMBER_BYTES = 4;\nfunction createSequenceNumberVector(sequenceNumber) {\n    if (sequenceNumber >= 4294967296) {\n        throw new Error('Outbound sequence number overflow. The maximum sequence number is 32-bytes.');\n    }\n    const byteArray = new ArrayBuffer(SEQUENCE_NUMBER_BYTES);\n    const view = new DataView(byteArray);\n    view.setUint32(0, sequenceNumber, /* littleEndian */ false);\n    return new Uint8Array(byteArray);\n}\n\nconst INITIALIZATION_VECTOR_BYTES = 12;\nconst ENCODED_PUBLIC_KEY_LENGTH_BYTES = 65;\nfunction encryptMessage(plaintext, sequenceNumber, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const sequenceNumberVector = createSequenceNumberVector(sequenceNumber);\n        const initializationVector = new Uint8Array(INITIALIZATION_VECTOR_BYTES);\n        crypto.getRandomValues(initializationVector);\n        const ciphertext = yield crypto.subtle.encrypt(getAlgorithmParams(sequenceNumberVector, initializationVector), sharedSecret, new TextEncoder().encode(plaintext));\n        const response = new Uint8Array(sequenceNumberVector.byteLength + initializationVector.byteLength + ciphertext.byteLength);\n        response.set(new Uint8Array(sequenceNumberVector), 0);\n        response.set(new Uint8Array(initializationVector), sequenceNumberVector.byteLength);\n        response.set(new Uint8Array(ciphertext), sequenceNumberVector.byteLength + initializationVector.byteLength);\n        return response;\n    });\n}\nfunction decryptMessage(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const sequenceNumberVector = message.slice(0, SEQUENCE_NUMBER_BYTES);\n        const initializationVector = message.slice(SEQUENCE_NUMBER_BYTES, SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES);\n        const ciphertext = message.slice(SEQUENCE_NUMBER_BYTES + INITIALIZATION_VECTOR_BYTES);\n        const plaintextBuffer = yield crypto.subtle.decrypt(getAlgorithmParams(sequenceNumberVector, initializationVector), sharedSecret, ciphertext);\n        const plaintext = getUtf8Decoder().decode(plaintextBuffer);\n        return plaintext;\n    });\n}\nfunction getAlgorithmParams(sequenceNumber, initializationVector) {\n    return {\n        additionalData: sequenceNumber,\n        iv: initializationVector,\n        name: 'AES-GCM',\n        tagLength: 128, // 16 byte tag => 128 bits\n    };\n}\nlet _utf8Decoder;\nfunction getUtf8Decoder() {\n    if (_utf8Decoder === undefined) {\n        _utf8Decoder = new TextDecoder('utf-8');\n    }\n    return _utf8Decoder;\n}\n\nfunction generateAssociationKeypair() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield crypto.subtle.generateKey({\n            name: 'ECDSA',\n            namedCurve: 'P-256',\n        }, false /* extractable */, ['sign'] /* keyUsages */);\n    });\n}\n\nfunction generateECDHKeypair() {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield crypto.subtle.generateKey({\n            name: 'ECDH',\n            namedCurve: 'P-256',\n        }, false /* extractable */, ['deriveKey', 'deriveBits'] /* keyUsages */);\n    });\n}\n\nfunction encryptJsonRpcMessage(jsonRpcMessage, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const plaintext = JSON.stringify(jsonRpcMessage);\n        const sequenceNumber = jsonRpcMessage.id;\n        return encryptMessage(plaintext, sequenceNumber, sharedSecret);\n    });\n}\nfunction decryptJsonRpcMessage(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const plaintext = yield decryptMessage(message, sharedSecret);\n        const jsonRpcMessage = JSON.parse(plaintext);\n        if (Object.hasOwnProperty.call(jsonRpcMessage, 'error')) {\n            throw new SolanaMobileWalletAdapterProtocolError(jsonRpcMessage.id, jsonRpcMessage.error.code, jsonRpcMessage.error.message);\n        }\n        return jsonRpcMessage;\n    });\n}\n\nfunction parseHelloRsp(payloadBuffer, // The X9.62-encoded wallet endpoint ephemeral ECDH public keypoint.\nassociationPublicKey, ecdhPrivateKey) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const [associationPublicKeyBuffer, walletPublicKey] = yield Promise.all([\n            crypto.subtle.exportKey('raw', associationPublicKey),\n            crypto.subtle.importKey('raw', payloadBuffer.slice(0, ENCODED_PUBLIC_KEY_LENGTH_BYTES), { name: 'ECDH', namedCurve: 'P-256' }, false /* extractable */, [] /* keyUsages */),\n        ]);\n        const sharedSecret = yield crypto.subtle.deriveBits({ name: 'ECDH', public: walletPublicKey }, ecdhPrivateKey, 256);\n        const ecdhSecretKey = yield crypto.subtle.importKey('raw', sharedSecret, 'HKDF', false /* extractable */, ['deriveKey'] /* keyUsages */);\n        const aesKeyMaterialVal = yield crypto.subtle.deriveKey({\n            name: 'HKDF',\n            hash: 'SHA-256',\n            salt: new Uint8Array(associationPublicKeyBuffer),\n            info: new Uint8Array(),\n        }, ecdhSecretKey, { name: 'AES-GCM', length: 128 }, false /* extractable */, ['encrypt', 'decrypt']);\n        return aesKeyMaterialVal;\n    });\n}\n\nfunction parseSessionProps(message, sharedSecret) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const plaintext = yield decryptMessage(message, sharedSecret);\n        const jsonProperties = JSON.parse(plaintext);\n        let protocolVersion = 'legacy';\n        if (Object.hasOwnProperty.call(jsonProperties, 'v')) {\n            switch (jsonProperties.v) {\n                case 1:\n                case '1':\n                case 'v1':\n                    protocolVersion = 'v1';\n                    break;\n                case 'legacy':\n                    protocolVersion = 'legacy';\n                    break;\n                default:\n                    throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_INVALID_PROTOCOL_VERSION, `Unknown/unsupported protocol version: ${jsonProperties.v}`);\n            }\n        }\n        return ({\n            protocol_version: protocolVersion\n        });\n    });\n}\n\nfunction getRandomAssociationPort() {\n    return assertAssociationPort(49152 + Math.floor(Math.random() * (65535 - 49152 + 1)));\n}\nfunction assertAssociationPort(port) {\n    if (port < 49152 || port > 65535) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_ASSOCIATION_PORT_OUT_OF_RANGE, `Association port number must be between 49152 and 65535. ${port} given.`, { port });\n    }\n    return port;\n}\n\n// https://stackoverflow.com/a/9458996/802047\nfunction arrayBufferToBase64String(buffer) {\n    let binary = '';\n    const bytes = new Uint8Array(buffer);\n    const len = bytes.byteLength;\n    for (let ii = 0; ii < len; ii++) {\n        binary += String.fromCharCode(bytes[ii]);\n    }\n    return window.btoa(binary);\n}\n\nfunction getStringWithURLUnsafeCharactersReplaced(unsafeBase64EncodedString) {\n    return unsafeBase64EncodedString.replace(/[/+=]/g, (m) => ({\n        '/': '_',\n        '+': '-',\n        '=': '.',\n    }[m]));\n}\n\nconst INTENT_NAME = 'solana-wallet';\nfunction getPathParts(pathString) {\n    return (pathString\n        // Strip leading and trailing slashes\n        .replace(/(^\\/+|\\/+$)/g, '')\n        // Return an array of directories\n        .split('/'));\n}\nfunction getIntentURL(methodPathname, intentUrlBase) {\n    let baseUrl = null;\n    if (intentUrlBase) {\n        try {\n            baseUrl = new URL(intentUrlBase);\n        }\n        catch (_a) { } // eslint-disable-line no-empty\n        if ((baseUrl === null || baseUrl === void 0 ? void 0 : baseUrl.protocol) !== 'https:') {\n            throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, 'Base URLs supplied by wallets must be valid `https` URLs');\n        }\n    }\n    baseUrl || (baseUrl = new URL(`${INTENT_NAME}:/`));\n    const pathname = methodPathname.startsWith('/')\n        ? // Method is an absolute path. Replace it wholesale.\n            methodPathname\n        : // Method is a relative path. Merge it with the existing one.\n            [...getPathParts(baseUrl.pathname), ...getPathParts(methodPathname)].join('/');\n    return new URL(pathname, baseUrl);\n}\nfunction getAssociateAndroidIntentURL(associationPublicKey, putativePort, associationURLBase, protocolVersions = ['v1']) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const associationPort = assertAssociationPort(putativePort);\n        const exportedKey = yield crypto.subtle.exportKey('raw', associationPublicKey);\n        const encodedKey = arrayBufferToBase64String(exportedKey);\n        const url = getIntentURL('v1/associate/local', associationURLBase);\n        url.searchParams.set('association', getStringWithURLUnsafeCharactersReplaced(encodedKey));\n        url.searchParams.set('port', `${associationPort}`);\n        protocolVersions.forEach((version) => {\n            url.searchParams.set('v', version);\n        });\n        return url;\n    });\n}\n\n// Typescript `enums` thwart tree-shaking. See https://bargsten.org/jsts/enums/\nconst Browser = {\n    Firefox: 0,\n    Other: 1,\n};\nfunction assertUnreachable(x) {\n    return x;\n}\nfunction getBrowser() {\n    return navigator.userAgent.indexOf('Firefox/') !== -1 ? Browser.Firefox : Browser.Other;\n}\nfunction getDetectionPromise() {\n    // Chrome and others silently fail if a custom protocol is not supported.\n    // For these, we wait to see if the browser is navigated away from in\n    // a reasonable amount of time (ie. the native wallet opened).\n    return new Promise((resolve, reject) => {\n        function cleanup() {\n            clearTimeout(timeoutId);\n            window.removeEventListener('blur', handleBlur);\n        }\n        function handleBlur() {\n            cleanup();\n            resolve();\n        }\n        window.addEventListener('blur', handleBlur);\n        const timeoutId = setTimeout(() => {\n            cleanup();\n            reject();\n        }, 2000);\n    });\n}\nlet _frame = null;\nfunction launchUrlThroughHiddenFrame(url) {\n    if (_frame == null) {\n        _frame = document.createElement('iframe');\n        _frame.style.display = 'none';\n        document.body.appendChild(_frame);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    _frame.contentWindow.location.href = url.toString();\n}\nfunction startSession(associationPublicKey, associationURLBase) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const randomAssociationPort = getRandomAssociationPort();\n        const associationUrl = yield getAssociateAndroidIntentURL(associationPublicKey, randomAssociationPort, associationURLBase);\n        if (associationUrl.protocol === 'https:') {\n            // The association URL is an Android 'App Link' or iOS 'Universal Link'.\n            // These are regular web URLs that are designed to launch an app if it\n            // is installed or load the actual target webpage if not.\n            window.location.assign(associationUrl);\n        }\n        else {\n            // The association URL has a custom protocol (eg. `solana-wallet:`)\n            try {\n                const browser = getBrowser();\n                switch (browser) {\n                    case Browser.Firefox:\n                        // If a custom protocol is not supported in Firefox, it throws.\n                        launchUrlThroughHiddenFrame(associationUrl);\n                        // If we reached this line, it's supported.\n                        break;\n                    case Browser.Other: {\n                        const detectionPromise = getDetectionPromise();\n                        window.location.assign(associationUrl);\n                        yield detectionPromise;\n                        break;\n                    }\n                    default:\n                        assertUnreachable(browser);\n                }\n            }\n            catch (e) {\n                throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_WALLET_NOT_FOUND, 'Found no installed wallet that supports the mobile wallet protocol.');\n            }\n        }\n        return randomAssociationPort;\n    });\n}\n\nconst WEBSOCKET_CONNECTION_CONFIG = {\n    /**\n     * 300 milliseconds is a generally accepted threshold for what someone\n     * would consider an acceptable response time for a user interface\n     * after having performed a low-attention tapping task. We set the initial\n     * interval at which we wait for the wallet to set up the websocket at\n     * half this, as per the Nyquist frequency, with a progressive backoff\n     * sequence from there. The total wait time is 30s, which allows for the\n     * user to be presented with a disambiguation dialog, select a wallet, and\n     * for the wallet app to subsequently start.\n     */\n    retryDelayScheduleMs: [150, 150, 200, 500, 500, 750, 750, 1000],\n    timeoutMs: 30000,\n};\nconst WEBSOCKET_PROTOCOL = 'com.solana.mobilewalletadapter.v1';\nfunction assertSecureContext() {\n    if (typeof window === 'undefined' || window.isSecureContext !== true) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SECURE_CONTEXT_REQUIRED, 'The mobile wallet adapter protocol must be used in a secure context (`https`).');\n    }\n}\nfunction assertSecureEndpointSpecificURI(walletUriBase) {\n    let url;\n    try {\n        url = new URL(walletUriBase);\n    }\n    catch (_a) {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, 'Invalid base URL supplied by wallet');\n    }\n    if (url.protocol !== 'https:') {\n        throw new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_FORBIDDEN_WALLET_BASE_URL, 'Base URLs supplied by wallets must be valid `https` URLs');\n    }\n}\nfunction getSequenceNumberFromByteArray(byteArray) {\n    const view = new DataView(byteArray);\n    return view.getUint32(0, /* littleEndian */ false);\n}\nfunction transact(callback, config) {\n    return __awaiter(this, void 0, void 0, function* () {\n        assertSecureContext();\n        const associationKeypair = yield generateAssociationKeypair();\n        const sessionPort = yield startSession(associationKeypair.publicKey, config === null || config === void 0 ? void 0 : config.baseUri);\n        const websocketURL = `ws://localhost:${sessionPort}/solana-wallet`;\n        let connectionStartTime;\n        const getNextRetryDelayMs = (() => {\n            const schedule = [...WEBSOCKET_CONNECTION_CONFIG.retryDelayScheduleMs];\n            return () => (schedule.length > 1 ? schedule.shift() : schedule[0]);\n        })();\n        let nextJsonRpcMessageId = 1;\n        let lastKnownInboundSequenceNumber = 0;\n        let state = { __type: 'disconnected' };\n        return new Promise((resolve, reject) => {\n            let socket;\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const jsonRpcResponsePromises = {};\n            const handleOpen = () => __awaiter(this, void 0, void 0, function* () {\n                if (state.__type !== 'connecting') {\n                    console.warn('Expected adapter state to be `connecting` at the moment the websocket opens. ' +\n                        `Got \\`${state.__type}\\`.`);\n                    return;\n                }\n                const { associationKeypair } = state;\n                socket.removeEventListener('open', handleOpen);\n                const ecdhKeypair = yield generateECDHKeypair();\n                socket.send(yield createHelloReq(ecdhKeypair.publicKey, associationKeypair.privateKey));\n                state = {\n                    __type: 'hello_req_sent',\n                    associationPublicKey: associationKeypair.publicKey,\n                    ecdhPrivateKey: ecdhKeypair.privateKey,\n                };\n            });\n            const handleClose = (evt) => {\n                if (evt.wasClean) {\n                    state = { __type: 'disconnected' };\n                }\n                else {\n                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_CLOSED, `The wallet session dropped unexpectedly (${evt.code}: ${evt.reason}).`, { closeEvent: evt }));\n                }\n                disposeSocket();\n            };\n            const handleError = (_evt) => __awaiter(this, void 0, void 0, function* () {\n                disposeSocket();\n                if (Date.now() - connectionStartTime >= WEBSOCKET_CONNECTION_CONFIG.timeoutMs) {\n                    reject(new SolanaMobileWalletAdapterError(SolanaMobileWalletAdapterErrorCode.ERROR_SESSION_TIMEOUT, `Failed to connect to the wallet websocket on port ${sessionPort}.`));\n                }\n                else {\n                    yield new Promise((resolve) => {\n                        const retryDelayMs = getNextRetryDelayMs();\n                        retryWaitTimeoutId = window.setTimeout(resolve, retryDelayMs);\n                    });\n                    attemptSocketConnection();\n                }\n            });\n            const handleMessage = (evt) => __awaiter(this, void 0, void 0, function* () {\n                const responseBuffer = yield evt.data.arrayBuffer();\n                switch (state.__type) {\n                    case 'connected':\n                        try {\n                            const sequenceNumberVector = responseBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                            const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                            if (sequenceNumber !== (lastKnownInboundSequenceNumber + 1)) {\n                                throw new Error('Encrypted message has invalid sequence number');\n                            }\n                            lastKnownInboundSequenceNumber = sequenceNumber;\n                            const jsonRpcMessage = yield decryptJsonRpcMessage(responseBuffer, state.sharedSecret);\n                            const responsePromise = jsonRpcResponsePromises[jsonRpcMessage.id];\n                            delete jsonRpcResponsePromises[jsonRpcMessage.id];\n                            responsePromise.resolve(jsonRpcMessage.result);\n                        }\n                        catch (e) {\n                            if (e instanceof SolanaMobileWalletAdapterProtocolError) {\n                                const responsePromise = jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                delete jsonRpcResponsePromises[e.jsonRpcMessageId];\n                                responsePromise.reject(e);\n                            }\n                            else {\n                                throw e;\n                            }\n                        }\n                        break;\n                    case 'hello_req_sent': {\n                        const sharedSecret = yield parseHelloRsp(responseBuffer, state.associationPublicKey, state.ecdhPrivateKey);\n                        const sessionPropertiesBuffer = responseBuffer.slice(ENCODED_PUBLIC_KEY_LENGTH_BYTES);\n                        const sessionProperties = sessionPropertiesBuffer.byteLength !== 0\n                            ? yield (() => __awaiter(this, void 0, void 0, function* () {\n                                const sequenceNumberVector = sessionPropertiesBuffer.slice(0, SEQUENCE_NUMBER_BYTES);\n                                const sequenceNumber = getSequenceNumberFromByteArray(sequenceNumberVector);\n                                if (sequenceNumber !== (lastKnownInboundSequenceNumber + 1)) {\n                                    throw new Error('Encrypted message has invalid sequence number');\n                                }\n                                lastKnownInboundSequenceNumber = sequenceNumber;\n                                return parseSessionProps(sessionPropertiesBuffer, sharedSecret);\n                            }))() : { protocol_version: 'legacy' };\n                        state = { __type: 'connected', sharedSecret, sessionProperties };\n                        const wallet = createMobileWalletProxy(sessionProperties.protocol_version, (method, params) => __awaiter(this, void 0, void 0, function* () {\n                            const id = nextJsonRpcMessageId++;\n                            socket.send(yield encryptJsonRpcMessage({\n                                id,\n                                jsonrpc: '2.0',\n                                method,\n                                params: params !== null && params !== void 0 ? params : {},\n                            }, sharedSecret));\n                            return new Promise((resolve, reject) => {\n                                jsonRpcResponsePromises[id] = {\n                                    resolve(result) {\n                                        switch (method) {\n                                            case 'authorize':\n                                            case 'reauthorize': {\n                                                const { wallet_uri_base } = result;\n                                                if (wallet_uri_base != null) {\n                                                    try {\n                                                        assertSecureEndpointSpecificURI(wallet_uri_base);\n                                                    }\n                                                    catch (e) {\n                                                        reject(e);\n                                                        return;\n                                                    }\n                                                }\n                                                break;\n                                            }\n                                        }\n                                        resolve(result);\n                                    },\n                                    reject,\n                                };\n                            });\n                        }));\n                        try {\n                            resolve(yield callback(wallet));\n                        }\n                        catch (e) {\n                            reject(e);\n                        }\n                        finally {\n                            disposeSocket();\n                            socket.close();\n                        }\n                        break;\n                    }\n                }\n            });\n            let disposeSocket;\n            let retryWaitTimeoutId;\n            const attemptSocketConnection = () => {\n                if (disposeSocket) {\n                    disposeSocket();\n                }\n                state = { __type: 'connecting', associationKeypair };\n                if (connectionStartTime === undefined) {\n                    connectionStartTime = Date.now();\n                }\n                socket = new WebSocket(websocketURL, [WEBSOCKET_PROTOCOL]);\n                socket.addEventListener('open', handleOpen);\n                socket.addEventListener('close', handleClose);\n                socket.addEventListener('error', handleError);\n                socket.addEventListener('message', handleMessage);\n                disposeSocket = () => {\n                    window.clearTimeout(retryWaitTimeoutId);\n                    socket.removeEventListener('open', handleOpen);\n                    socket.removeEventListener('close', handleClose);\n                    socket.removeEventListener('error', handleError);\n                    socket.removeEventListener('message', handleMessage);\n                };\n            };\n            attemptSocketConnection();\n        });\n    });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hLW1vYmlsZS9tb2JpbGUtd2FsbGV0LWFkYXB0ZXItcHJvdG9jb2wvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBdUU7O0FBRXZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxnQ0FBZ0M7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxxRkFBdUI7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjLG9CQUFvQjtBQUNsQztBQUNBO0FBQ0E7QUFDQSxlQUFlLG9CQUFvQjtBQUNuQztBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGlCQUFpQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGdCQUFnQjtBQUN4RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFlBQVk7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxhQUFhO0FBQzlDO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0EsbUtBQW1LLFNBQVMsSUFBSSxXQUFXLE9BQU8saUJBQWlCO0FBQ25OO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZLQUE2SyxZQUFZO0FBQ3pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsU0FBUztBQUN0QyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGO0FBQzFGLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDs7QUFFc1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEtbW9iaWxlL21vYmlsZS13YWxsZXQtYWRhcHRlci1wcm90b2NvbC9saWIvZXNtL2luZGV4LmpzPzY4OGEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlU2lnbkluTWVzc2FnZVRleHQgfSBmcm9tICdAc29sYW5hL3dhbGxldC1zdGFuZGFyZC11dGlsJztcblxuLy8gVHlwZXNjcmlwdCBgZW51bXNgIHRod2FydCB0cmVlLXNoYWtpbmcuIFNlZSBodHRwczovL2JhcmdzdGVuLm9yZy9qc3RzL2VudW1zL1xuY29uc3QgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZSA9IHtcbiAgICBFUlJPUl9BU1NPQ0lBVElPTl9QT1JUX09VVF9PRl9SQU5HRTogJ0VSUk9SX0FTU09DSUFUSU9OX1BPUlRfT1VUX09GX1JBTkdFJyxcbiAgICBFUlJPUl9GT1JCSURERU5fV0FMTEVUX0JBU0VfVVJMOiAnRVJST1JfRk9SQklEREVOX1dBTExFVF9CQVNFX1VSTCcsXG4gICAgRVJST1JfU0VDVVJFX0NPTlRFWFRfUkVRVUlSRUQ6ICdFUlJPUl9TRUNVUkVfQ09OVEVYVF9SRVFVSVJFRCcsXG4gICAgRVJST1JfU0VTU0lPTl9DTE9TRUQ6ICdFUlJPUl9TRVNTSU9OX0NMT1NFRCcsXG4gICAgRVJST1JfU0VTU0lPTl9USU1FT1VUOiAnRVJST1JfU0VTU0lPTl9USU1FT1VUJyxcbiAgICBFUlJPUl9XQUxMRVRfTk9UX0ZPVU5EOiAnRVJST1JfV0FMTEVUX05PVF9GT1VORCcsXG4gICAgRVJST1JfSU5WQUxJRF9QUk9UT0NPTF9WRVJTSU9OOiAnRVJST1JfSU5WQUxJRF9QUk9UT0NPTF9WRVJTSU9OJyxcbn07XG5jbGFzcyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgICAgICBjb25zdCBbY29kZSwgbWVzc2FnZSwgZGF0YV0gPSBhcmdzO1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1NvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcic7XG4gICAgfVxufVxuLy8gVHlwZXNjcmlwdCBgZW51bXNgIHRod2FydCB0cmVlLXNoYWtpbmcuIFNlZSBodHRwczovL2JhcmdzdGVuLm9yZy9qc3RzL2VudW1zL1xuY29uc3QgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3JDb2RlID0ge1xuICAgIC8vIEtlZXAgdGhlc2UgaW4gc3luYyB3aXRoIGBtb2JpbGV3YWxsZXRhZGFwdGVyL2NvbW1vbi9Qcm90b2NvbENvbnRyYWN0LmphdmFgLlxuICAgIEVSUk9SX0FVVEhPUklaQVRJT05fRkFJTEVEOiAtMSxcbiAgICBFUlJPUl9JTlZBTElEX1BBWUxPQURTOiAtMixcbiAgICBFUlJPUl9OT1RfU0lHTkVEOiAtMyxcbiAgICBFUlJPUl9OT1RfU1VCTUlUVEVEOiAtNCxcbiAgICBFUlJPUl9UT09fTUFOWV9QQVlMT0FEUzogLTUsXG4gICAgRVJST1JfQVRURVNUX09SSUdJTl9BTkRST0lEOiAtMTAwLFxufTtcbmNsYXNzIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJQcm90b2NvbEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgW2pzb25ScGNNZXNzYWdlSWQsIGNvZGUsIG1lc3NhZ2UsIGRhdGFdID0gYXJncztcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuanNvblJwY01lc3NhZ2VJZCA9IGpzb25ScGNNZXNzYWdlSWQ7XG4gICAgICAgIHRoaXMubmFtZSA9ICdTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvcic7XG4gICAgfVxufVxuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cblxuZnVuY3Rpb24gY3JlYXRlSGVsbG9SZXEoZWNkaFB1YmxpY0tleSwgYXNzb2NpYXRpb25LZXlwYWlyUHJpdmF0ZUtleSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleUJ1ZmZlciA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuZXhwb3J0S2V5KCdyYXcnLCBlY2RoUHVibGljS2V5KTtcbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlQnVmZmVyID0geWllbGQgY3J5cHRvLnN1YnRsZS5zaWduKHsgaGFzaDogJ1NIQS0yNTYnLCBuYW1lOiAnRUNEU0EnIH0sIGFzc29jaWF0aW9uS2V5cGFpclByaXZhdGVLZXksIHB1YmxpY0tleUJ1ZmZlcik7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IFVpbnQ4QXJyYXkocHVibGljS2V5QnVmZmVyLmJ5dGVMZW5ndGggKyBzaWduYXR1cmVCdWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJlc3BvbnNlLnNldChuZXcgVWludDhBcnJheShwdWJsaWNLZXlCdWZmZXIpLCAwKTtcbiAgICAgICAgcmVzcG9uc2Uuc2V0KG5ldyBVaW50OEFycmF5KHNpZ25hdHVyZUJ1ZmZlciksIHB1YmxpY0tleUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcbiAgICByZXR1cm4gd2luZG93LmJ0b2EoaW5wdXQpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTSVdTTWVzc2FnZShwYXlsb2FkKSB7XG4gICAgcmV0dXJuIGNyZWF0ZVNpZ25Jbk1lc3NhZ2VUZXh0KHBheWxvYWQpO1xufVxuZnVuY3Rpb24gY3JlYXRlU0lXU01lc3NhZ2VCYXNlNjQocGF5bG9hZCkge1xuICAgIHJldHVybiBlbmNvZGUoY3JlYXRlU0lXU01lc3NhZ2UocGF5bG9hZCkpO1xufVxuXG4vLyBvcHRpb25hbCBmZWF0dXJlc1xuY29uc3QgU29sYW5hU2lnblRyYW5zYWN0aW9ucyA9ICdzb2xhbmE6c2lnblRyYW5zYWN0aW9ucyc7XG5jb25zdCBTb2xhbmFDbG9uZUF1dGhvcml6YXRpb24gPSAnc29sYW5hOmNsb25lQXV0aG9yaXphdGlvbic7XG5jb25zdCBTb2xhbmFTaWduSW5XaXRoU29sYW5hID0gJ3NvbGFuYTpzaWduSW5XaXRoU29sYW5hJztcblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIE1vYmlsZVdhbGxldH0gcHJveHkgdGhhdCBoYW5kbGVzIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGFuZCBBUEkgdG8gUlBDIGNvbnZlcnNpb24uXG4gKlxuICogQHBhcmFtIHByb3RvY29sVmVyc2lvbiB0aGUgcHJvdG9jb2wgdmVyc2lvbiBpbiB1c2UgZm9yIHRoaXMgc2Vzc2lvbi9yZXF1ZXN0XG4gKiBAcGFyYW0gcHJvdG9jb2xSZXF1ZXN0SGFuZGxlciBjYWxsYmFjayBmdW5jdGlvbiB0aGF0IGhhbmRsZXMgc2VuZGluZyB0aGUgUlBDIHJlcXVlc3QgdG8gdGhlIHdhbGxldCBlbmRwb2ludC5cbiAqIEByZXR1cm5zIGEge0BsaW5rIE1vYmlsZVdhbGxldH0gcHJveHlcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTW9iaWxlV2FsbGV0UHJveHkocHJvdG9jb2xWZXJzaW9uLCBwcm90b2NvbFJlcXVlc3RIYW5kbGVyKSB7XG4gICAgcmV0dXJuIG5ldyBQcm94eSh7fSwge1xuICAgICAgICBnZXQodGFyZ2V0LCBwKSB7XG4gICAgICAgICAgICBpZiAodGFyZ2V0W3BdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbcF0gPSBmdW5jdGlvbiAoaW5wdXRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbWV0aG9kLCBwYXJhbXMgfSA9IGhhbmRsZU1vYmlsZVdhbGxldFJlcXVlc3QocCwgaW5wdXRQYXJhbXMsIHByb3RvY29sVmVyc2lvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBwcm90b2NvbFJlcXVlc3RIYW5kbGVyKG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSByZXF1ZXN0IHRyaWVkIHRvIHNpZ24gaW4gYnV0IHRoZSB3YWxsZXQgZGlkIG5vdCByZXR1cm4gYSBzaWduIGluIHJlc3VsdCwgZmFsbGJhY2sgb24gbWVzc2FnZSBzaWduaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0aG9kID09PSAnYXV0aG9yaXplJyAmJiBwYXJhbXMuc2lnbl9pbl9wYXlsb2FkICYmICFyZXN1bHQuc2lnbl9pbl9yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbJ3NpZ25faW5fcmVzdWx0J10gPSB5aWVsZCBzaWduSW5GYWxsYmFjayhwYXJhbXMuc2lnbl9pbl9wYXlsb2FkLCByZXN1bHQsIHByb3RvY29sUmVxdWVzdEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZU1vYmlsZVdhbGxldFJlc3BvbnNlKHAsIHJlc3VsdCwgcHJvdG9jb2xWZXJzaW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXJnZXRbcF07XG4gICAgICAgIH0sXG4gICAgICAgIGRlZmluZVByb3BlcnR5KCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBkZWxldGVQcm9wZXJ0eSgpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cbi8qKlxuICogSGFuZGxlcyBhbGwge0BsaW5rIE1vYmlsZVdhbGxldH0gQVBJIHJlcXVlc3RzIGFuZCBkZXRlcm1pbmVzIHRoZSBjb3JyZWN0IE1XQSBSUEMgbWV0aG9kIGFuZCBwYXJhbXMgdG8gY2FsbC5cbiAqIFRoaXMgaGFuZGxlcyBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgYmFzZWQgb24gdGhlIHByb3ZpZGVkIEBwcm90b2NvbFZlcnNpb24uXG4gKlxuICogQHBhcmFtIG1ldGhvZE5hbWUgdGhlIG5hbWUgb2Yge0BsaW5rIE1vYmlsZVdhbGxldH0gbWV0aG9kIHRoYXQgd2FzIGNhbGxlZFxuICogQHBhcmFtIG1ldGhvZFBhcmFtcyB0aGUgcGFyYW1ldGVycyB0aGF0IHdlcmUgcGFzc2VkIHRvIHRoZSBtZXRob2RcbiAqIEBwYXJhbSBwcm90b2NvbFZlcnNpb24gdGhlIHByb3RvY29sIHZlcnNpb24gaW4gdXNlIGZvciB0aGlzIHNlc3Npb24vcmVxdWVzdFxuICogQHJldHVybnMgdGhlIFJQQyByZXF1ZXN0IG1ldGhvZCBhbmQgcGFyYW1zIHRoYXQgc2hvdWxkIGJlIHNlbnQgdG8gdGhlIHdhbGxldCBlbmRwb2ludFxuICovXG5mdW5jdGlvbiBoYW5kbGVNb2JpbGVXYWxsZXRSZXF1ZXN0KG1ldGhvZE5hbWUsIG1ldGhvZFBhcmFtcywgcHJvdG9jb2xWZXJzaW9uKSB7XG4gICAgbGV0IHBhcmFtcyA9IG1ldGhvZFBhcmFtcztcbiAgICBsZXQgbWV0aG9kID0gbWV0aG9kTmFtZVxuICAgICAgICAudG9TdHJpbmcoKVxuICAgICAgICAucmVwbGFjZSgvW0EtWl0vZywgKGxldHRlcikgPT4gYF8ke2xldHRlci50b0xvd2VyQ2FzZSgpfWApXG4gICAgICAgIC50b0xvd2VyQ2FzZSgpO1xuICAgIHN3aXRjaCAobWV0aG9kTmFtZSkge1xuICAgICAgICBjYXNlICdhdXRob3JpemUnOiB7XG4gICAgICAgICAgICBsZXQgeyBjaGFpbiB9ID0gcGFyYW1zO1xuICAgICAgICAgICAgaWYgKHByb3RvY29sVmVyc2lvbiA9PT0gJ2xlZ2FjeScpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGNoYWluKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NvbGFuYTp0ZXN0bmV0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4gPSAndGVzdG5ldCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdzb2xhbmE6ZGV2bmV0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4gPSAnZGV2bmV0JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3NvbGFuYTptYWlubmV0Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4gPSAnbWFpbm5ldC1iZXRhJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluID0gcGFyYW1zLmNsdXN0ZXI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNsdXN0ZXIgPSBjaGFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoY2hhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndGVzdG5ldCc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Rldm5ldCc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluID0gYHNvbGFuYToke2NoYWlufWA7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXNlICdtYWlubmV0LWJldGEnOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbiA9ICdzb2xhbmE6bWFpbm5ldCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJhbXMuY2hhaW4gPSBjaGFpbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXNlICdyZWF1dGhvcml6ZSc6IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXV0aF90b2tlbiwgaWRlbnRpdHkgfSA9IHBhcmFtcztcbiAgICAgICAgICAgIGlmIChhdXRoX3Rva2VuKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChwcm90b2NvbFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnbGVnYWN5Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kID0gJ3JlYXV0aG9yaXplJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IHsgYXV0aF90b2tlbjogYXV0aF90b2tlbiwgaWRlbnRpdHk6IGlkZW50aXR5IH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QgPSAnYXV0aG9yaXplJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgbWV0aG9kLCBwYXJhbXMgfTtcbn1cbi8qKlxuICogSGFuZGxlcyBhbGwge0BsaW5rIE1vYmlsZVdhbGxldH0gQVBJIHJlc3BvbnNlcyBhbmQgbW9kaWZpZXMgdGhlIHJlc3BvbnNlIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgaWYgbmVlZGVkXG4gKlxuICogQHBhcmFtIG1ldGhvZCB0aGUge0BsaW5rIE1vYmlsZVdhbGxldH0gbWV0aG9kIHRoYXQgd2FzIGNhbGxlZFxuICogQHBhcmFtIHJlc3BvbnNlIHRoZSBvcmlnaW5hbCByZXNwb25zZSB0aGF0IHdhcyByZXR1cm5lZCBieSB0aGUgbWV0aG9kIGNhbGxcbiAqIEBwYXJhbSBwcm90b2NvbFZlcnNpb24gdGhlIHByb3RvY29sIHZlcnNpb24gaW4gdXNlIGZvciB0aGlzIHNlc3Npb24vcmVxdWVzdFxuICogQHJldHVybnMgdGhlIHBvc3NpYmx5IG1vZGlmaWVkIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZU1vYmlsZVdhbGxldFJlc3BvbnNlKG1ldGhvZCwgcmVzcG9uc2UsIHByb3RvY29sVmVyc2lvbikge1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgIGNhc2UgJ2dldENhcGFiaWxpdGllcyc6IHtcbiAgICAgICAgICAgIGNvbnN0IGNhcGFiaWxpdGllcyA9IHJlc3BvbnNlO1xuICAgICAgICAgICAgc3dpdGNoIChwcm90b2NvbFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdsZWdhY3knOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZlYXR1cmVzID0gW1NvbGFuYVNpZ25UcmFuc2FjdGlvbnNdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FwYWJpbGl0aWVzLnN1cHBvcnRzX2Nsb25lX2F1dGhvcml6YXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzLnB1c2goU29sYW5hQ2xvbmVBdXRob3JpemF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBjYXBhYmlsaXRpZXMpLCB7IGZlYXR1cmVzOiBmZWF0dXJlcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSAndjEnOiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNhcGFiaWxpdGllcyksIHsgc3VwcG9ydHNfc2lnbl9hbmRfc2VuZF90cmFuc2FjdGlvbnM6IHRydWUsIHN1cHBvcnRzX2Nsb25lX2F1dGhvcml6YXRpb246IGNhcGFiaWxpdGllcy5mZWF0dXJlcy5pbmNsdWRlcyhTb2xhbmFDbG9uZUF1dGhvcml6YXRpb24pIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5mdW5jdGlvbiBzaWduSW5GYWxsYmFjayhzaWduSW5QYXlsb2FkLCBhdXRob3JpemF0aW9uUmVzdWx0LCBwcm90b2NvbFJlcXVlc3RIYW5kbGVyKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IGRvbWFpbiA9IChfYSA9IHNpZ25JblBheWxvYWQuZG9tYWluKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB3aW5kb3cubG9jYXRpb24uaG9zdDtcbiAgICAgICAgY29uc3QgYWRkcmVzcyA9IGF1dGhvcml6YXRpb25SZXN1bHQuYWNjb3VudHNbMF0uYWRkcmVzcztcbiAgICAgICAgY29uc3Qgc2l3c01lc3NhZ2UgPSBjcmVhdGVTSVdTTWVzc2FnZUJhc2U2NChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHNpZ25JblBheWxvYWQpLCB7IGRvbWFpbiwgYWRkcmVzcyB9KSk7XG4gICAgICAgIGNvbnN0IHNpZ25NZXNzYWdlUmVzdWx0ID0geWllbGQgcHJvdG9jb2xSZXF1ZXN0SGFuZGxlcignc2lnbl9tZXNzYWdlcycsIHtcbiAgICAgICAgICAgIGFkZHJlc3NlczogW2FkZHJlc3NdLFxuICAgICAgICAgICAgcGF5bG9hZHM6IFtzaXdzTWVzc2FnZV1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNpZ25JblJlc3VsdCA9IHtcbiAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgICAgICBzaWduZWRfbWVzc2FnZTogc2l3c01lc3NhZ2UsXG4gICAgICAgICAgICBzaWduYXR1cmU6IHNpZ25NZXNzYWdlUmVzdWx0LnNpZ25lZF9wYXlsb2Fkc1swXS5zbGljZShzaXdzTWVzc2FnZS5sZW5ndGgpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBzaWduSW5SZXN1bHQ7XG4gICAgfSk7XG59XG5cbmNvbnN0IFNFUVVFTkNFX05VTUJFUl9CWVRFUyA9IDQ7XG5mdW5jdGlvbiBjcmVhdGVTZXF1ZW5jZU51bWJlclZlY3RvcihzZXF1ZW5jZU51bWJlcikge1xuICAgIGlmIChzZXF1ZW5jZU51bWJlciA+PSA0Mjk0OTY3Mjk2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignT3V0Ym91bmQgc2VxdWVuY2UgbnVtYmVyIG92ZXJmbG93LiBUaGUgbWF4aW11bSBzZXF1ZW5jZSBudW1iZXIgaXMgMzItYnl0ZXMuJyk7XG4gICAgfVxuICAgIGNvbnN0IGJ5dGVBcnJheSA9IG5ldyBBcnJheUJ1ZmZlcihTRVFVRU5DRV9OVU1CRVJfQllURVMpO1xuICAgIGNvbnN0IHZpZXcgPSBuZXcgRGF0YVZpZXcoYnl0ZUFycmF5KTtcbiAgICB2aWV3LnNldFVpbnQzMigwLCBzZXF1ZW5jZU51bWJlciwgLyogbGl0dGxlRW5kaWFuICovIGZhbHNlKTtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnl0ZUFycmF5KTtcbn1cblxuY29uc3QgSU5JVElBTElaQVRJT05fVkVDVE9SX0JZVEVTID0gMTI7XG5jb25zdCBFTkNPREVEX1BVQkxJQ19LRVlfTEVOR1RIX0JZVEVTID0gNjU7XG5mdW5jdGlvbiBlbmNyeXB0TWVzc2FnZShwbGFpbnRleHQsIHNlcXVlbmNlTnVtYmVyLCBzaGFyZWRTZWNyZXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlclZlY3RvciA9IGNyZWF0ZVNlcXVlbmNlTnVtYmVyVmVjdG9yKHNlcXVlbmNlTnVtYmVyKTtcbiAgICAgICAgY29uc3QgaW5pdGlhbGl6YXRpb25WZWN0b3IgPSBuZXcgVWludDhBcnJheShJTklUSUFMSVpBVElPTl9WRUNUT1JfQllURVMpO1xuICAgICAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGluaXRpYWxpemF0aW9uVmVjdG9yKTtcbiAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuZW5jcnlwdChnZXRBbGdvcml0aG1QYXJhbXMoc2VxdWVuY2VOdW1iZXJWZWN0b3IsIGluaXRpYWxpemF0aW9uVmVjdG9yKSwgc2hhcmVkU2VjcmV0LCBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocGxhaW50ZXh0KSk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gbmV3IFVpbnQ4QXJyYXkoc2VxdWVuY2VOdW1iZXJWZWN0b3IuYnl0ZUxlbmd0aCArIGluaXRpYWxpemF0aW9uVmVjdG9yLmJ5dGVMZW5ndGggKyBjaXBoZXJ0ZXh0LmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXNwb25zZS5zZXQobmV3IFVpbnQ4QXJyYXkoc2VxdWVuY2VOdW1iZXJWZWN0b3IpLCAwKTtcbiAgICAgICAgcmVzcG9uc2Uuc2V0KG5ldyBVaW50OEFycmF5KGluaXRpYWxpemF0aW9uVmVjdG9yKSwgc2VxdWVuY2VOdW1iZXJWZWN0b3IuYnl0ZUxlbmd0aCk7XG4gICAgICAgIHJlc3BvbnNlLnNldChuZXcgVWludDhBcnJheShjaXBoZXJ0ZXh0KSwgc2VxdWVuY2VOdW1iZXJWZWN0b3IuYnl0ZUxlbmd0aCArIGluaXRpYWxpemF0aW9uVmVjdG9yLmJ5dGVMZW5ndGgpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBkZWNyeXB0TWVzc2FnZShtZXNzYWdlLCBzaGFyZWRTZWNyZXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlclZlY3RvciA9IG1lc3NhZ2Uuc2xpY2UoMCwgU0VRVUVOQ0VfTlVNQkVSX0JZVEVTKTtcbiAgICAgICAgY29uc3QgaW5pdGlhbGl6YXRpb25WZWN0b3IgPSBtZXNzYWdlLnNsaWNlKFNFUVVFTkNFX05VTUJFUl9CWVRFUywgU0VRVUVOQ0VfTlVNQkVSX0JZVEVTICsgSU5JVElBTElaQVRJT05fVkVDVE9SX0JZVEVTKTtcbiAgICAgICAgY29uc3QgY2lwaGVydGV4dCA9IG1lc3NhZ2Uuc2xpY2UoU0VRVUVOQ0VfTlVNQkVSX0JZVEVTICsgSU5JVElBTElaQVRJT05fVkVDVE9SX0JZVEVTKTtcbiAgICAgICAgY29uc3QgcGxhaW50ZXh0QnVmZmVyID0geWllbGQgY3J5cHRvLnN1YnRsZS5kZWNyeXB0KGdldEFsZ29yaXRobVBhcmFtcyhzZXF1ZW5jZU51bWJlclZlY3RvciwgaW5pdGlhbGl6YXRpb25WZWN0b3IpLCBzaGFyZWRTZWNyZXQsIGNpcGhlcnRleHQpO1xuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBnZXRVdGY4RGVjb2RlcigpLmRlY29kZShwbGFpbnRleHRCdWZmZXIpO1xuICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0QWxnb3JpdGhtUGFyYW1zKHNlcXVlbmNlTnVtYmVyLCBpbml0aWFsaXphdGlvblZlY3Rvcikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZGl0aW9uYWxEYXRhOiBzZXF1ZW5jZU51bWJlcixcbiAgICAgICAgaXY6IGluaXRpYWxpemF0aW9uVmVjdG9yLFxuICAgICAgICBuYW1lOiAnQUVTLUdDTScsXG4gICAgICAgIHRhZ0xlbmd0aDogMTI4LCAvLyAxNiBieXRlIHRhZyA9PiAxMjggYml0c1xuICAgIH07XG59XG5sZXQgX3V0ZjhEZWNvZGVyO1xuZnVuY3Rpb24gZ2V0VXRmOERlY29kZXIoKSB7XG4gICAgaWYgKF91dGY4RGVjb2RlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIF91dGY4RGVjb2RlciA9IG5ldyBUZXh0RGVjb2RlcigndXRmLTgnKTtcbiAgICB9XG4gICAgcmV0dXJuIF91dGY4RGVjb2Rlcjtcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVBc3NvY2lhdGlvbktleXBhaXIoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgcmV0dXJuIHlpZWxkIGNyeXB0by5zdWJ0bGUuZ2VuZXJhdGVLZXkoe1xuICAgICAgICAgICAgbmFtZTogJ0VDRFNBJyxcbiAgICAgICAgICAgIG5hbWVkQ3VydmU6ICdQLTI1NicsXG4gICAgICAgIH0sIGZhbHNlIC8qIGV4dHJhY3RhYmxlICovLCBbJ3NpZ24nXSAvKiBrZXlVc2FnZXMgKi8pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZUVDREhLZXlwYWlyKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHJldHVybiB5aWVsZCBjcnlwdG8uc3VidGxlLmdlbmVyYXRlS2V5KHtcbiAgICAgICAgICAgIG5hbWU6ICdFQ0RIJyxcbiAgICAgICAgICAgIG5hbWVkQ3VydmU6ICdQLTI1NicsXG4gICAgICAgIH0sIGZhbHNlIC8qIGV4dHJhY3RhYmxlICovLCBbJ2Rlcml2ZUtleScsICdkZXJpdmVCaXRzJ10gLyoga2V5VXNhZ2VzICovKTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gZW5jcnlwdEpzb25ScGNNZXNzYWdlKGpzb25ScGNNZXNzYWdlLCBzaGFyZWRTZWNyZXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSBKU09OLnN0cmluZ2lmeShqc29uUnBjTWVzc2FnZSk7XG4gICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyID0ganNvblJwY01lc3NhZ2UuaWQ7XG4gICAgICAgIHJldHVybiBlbmNyeXB0TWVzc2FnZShwbGFpbnRleHQsIHNlcXVlbmNlTnVtYmVyLCBzaGFyZWRTZWNyZXQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZGVjcnlwdEpzb25ScGNNZXNzYWdlKG1lc3NhZ2UsIHNoYXJlZFNlY3JldCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHBsYWludGV4dCA9IHlpZWxkIGRlY3J5cHRNZXNzYWdlKG1lc3NhZ2UsIHNoYXJlZFNlY3JldCk7XG4gICAgICAgIGNvbnN0IGpzb25ScGNNZXNzYWdlID0gSlNPTi5wYXJzZShwbGFpbnRleHQpO1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoanNvblJwY01lc3NhZ2UsICdlcnJvcicpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlclByb3RvY29sRXJyb3IoanNvblJwY01lc3NhZ2UuaWQsIGpzb25ScGNNZXNzYWdlLmVycm9yLmNvZGUsIGpzb25ScGNNZXNzYWdlLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBqc29uUnBjTWVzc2FnZTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2VIZWxsb1JzcChwYXlsb2FkQnVmZmVyLCAvLyBUaGUgWDkuNjItZW5jb2RlZCB3YWxsZXQgZW5kcG9pbnQgZXBoZW1lcmFsIEVDREggcHVibGljIGtleXBvaW50LlxuYXNzb2NpYXRpb25QdWJsaWNLZXksIGVjZGhQcml2YXRlS2V5KSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgW2Fzc29jaWF0aW9uUHVibGljS2V5QnVmZmVyLCB3YWxsZXRQdWJsaWNLZXldID0geWllbGQgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgY3J5cHRvLnN1YnRsZS5leHBvcnRLZXkoJ3JhdycsIGFzc29jaWF0aW9uUHVibGljS2V5KSxcbiAgICAgICAgICAgIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBwYXlsb2FkQnVmZmVyLnNsaWNlKDAsIEVOQ09ERURfUFVCTElDX0tFWV9MRU5HVEhfQllURVMpLCB7IG5hbWU6ICdFQ0RIJywgbmFtZWRDdXJ2ZTogJ1AtMjU2JyB9LCBmYWxzZSAvKiBleHRyYWN0YWJsZSAqLywgW10gLyoga2V5VXNhZ2VzICovKSxcbiAgICAgICAgXSk7XG4gICAgICAgIGNvbnN0IHNoYXJlZFNlY3JldCA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuZGVyaXZlQml0cyh7IG5hbWU6ICdFQ0RIJywgcHVibGljOiB3YWxsZXRQdWJsaWNLZXkgfSwgZWNkaFByaXZhdGVLZXksIDI1Nik7XG4gICAgICAgIGNvbnN0IGVjZGhTZWNyZXRLZXkgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3Jywgc2hhcmVkU2VjcmV0LCAnSEtERicsIGZhbHNlIC8qIGV4dHJhY3RhYmxlICovLCBbJ2Rlcml2ZUtleSddIC8qIGtleVVzYWdlcyAqLyk7XG4gICAgICAgIGNvbnN0IGFlc0tleU1hdGVyaWFsVmFsID0geWllbGQgY3J5cHRvLnN1YnRsZS5kZXJpdmVLZXkoe1xuICAgICAgICAgICAgbmFtZTogJ0hLREYnLFxuICAgICAgICAgICAgaGFzaDogJ1NIQS0yNTYnLFxuICAgICAgICAgICAgc2FsdDogbmV3IFVpbnQ4QXJyYXkoYXNzb2NpYXRpb25QdWJsaWNLZXlCdWZmZXIpLFxuICAgICAgICAgICAgaW5mbzogbmV3IFVpbnQ4QXJyYXkoKSxcbiAgICAgICAgfSwgZWNkaFNlY3JldEtleSwgeyBuYW1lOiAnQUVTLUdDTScsIGxlbmd0aDogMTI4IH0sIGZhbHNlIC8qIGV4dHJhY3RhYmxlICovLCBbJ2VuY3J5cHQnLCAnZGVjcnlwdCddKTtcbiAgICAgICAgcmV0dXJuIGFlc0tleU1hdGVyaWFsVmFsO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNlc3Npb25Qcm9wcyhtZXNzYWdlLCBzaGFyZWRTZWNyZXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBwbGFpbnRleHQgPSB5aWVsZCBkZWNyeXB0TWVzc2FnZShtZXNzYWdlLCBzaGFyZWRTZWNyZXQpO1xuICAgICAgICBjb25zdCBqc29uUHJvcGVydGllcyA9IEpTT04ucGFyc2UocGxhaW50ZXh0KTtcbiAgICAgICAgbGV0IHByb3RvY29sVmVyc2lvbiA9ICdsZWdhY3knO1xuICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoanNvblByb3BlcnRpZXMsICd2JykpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoanNvblByb3BlcnRpZXMudikge1xuICAgICAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjYXNlICcxJzpcbiAgICAgICAgICAgICAgICBjYXNlICd2MSc6XG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sVmVyc2lvbiA9ICd2MSc7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlZ2FjeSc6XG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sVmVyc2lvbiA9ICdsZWdhY3knO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfSU5WQUxJRF9QUk9UT0NPTF9WRVJTSU9OLCBgVW5rbm93bi91bnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uOiAke2pzb25Qcm9wZXJ0aWVzLnZ9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICh7XG4gICAgICAgICAgICBwcm90b2NvbF92ZXJzaW9uOiBwcm90b2NvbFZlcnNpb25cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFJhbmRvbUFzc29jaWF0aW9uUG9ydCgpIHtcbiAgICByZXR1cm4gYXNzZXJ0QXNzb2NpYXRpb25Qb3J0KDQ5MTUyICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogKDY1NTM1IC0gNDkxNTIgKyAxKSkpO1xufVxuZnVuY3Rpb24gYXNzZXJ0QXNzb2NpYXRpb25Qb3J0KHBvcnQpIHtcbiAgICBpZiAocG9ydCA8IDQ5MTUyIHx8IHBvcnQgPiA2NTUzNSkge1xuICAgICAgICB0aHJvdyBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfQVNTT0NJQVRJT05fUE9SVF9PVVRfT0ZfUkFOR0UsIGBBc3NvY2lhdGlvbiBwb3J0IG51bWJlciBtdXN0IGJlIGJldHdlZW4gNDkxNTIgYW5kIDY1NTM1LiAke3BvcnR9IGdpdmVuLmAsIHsgcG9ydCB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcnQ7XG59XG5cbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS85NDU4OTk2LzgwMjA0N1xuZnVuY3Rpb24gYXJyYXlCdWZmZXJUb0Jhc2U2NFN0cmluZyhidWZmZXIpIHtcbiAgICBsZXQgYmluYXJ5ID0gJyc7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShidWZmZXIpO1xuICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgZm9yIChsZXQgaWkgPSAwOyBpaSA8IGxlbjsgaWkrKykge1xuICAgICAgICBiaW5hcnkgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpaV0pO1xuICAgIH1cbiAgICByZXR1cm4gd2luZG93LmJ0b2EoYmluYXJ5KTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RyaW5nV2l0aFVSTFVuc2FmZUNoYXJhY3RlcnNSZXBsYWNlZCh1bnNhZmVCYXNlNjRFbmNvZGVkU3RyaW5nKSB7XG4gICAgcmV0dXJuIHVuc2FmZUJhc2U2NEVuY29kZWRTdHJpbmcucmVwbGFjZSgvWy8rPV0vZywgKG0pID0+ICh7XG4gICAgICAgICcvJzogJ18nLFxuICAgICAgICAnKyc6ICctJyxcbiAgICAgICAgJz0nOiAnLicsXG4gICAgfVttXSkpO1xufVxuXG5jb25zdCBJTlRFTlRfTkFNRSA9ICdzb2xhbmEtd2FsbGV0JztcbmZ1bmN0aW9uIGdldFBhdGhQYXJ0cyhwYXRoU3RyaW5nKSB7XG4gICAgcmV0dXJuIChwYXRoU3RyaW5nXG4gICAgICAgIC8vIFN0cmlwIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoZXNcbiAgICAgICAgLnJlcGxhY2UoLyheXFwvK3xcXC8rJCkvZywgJycpXG4gICAgICAgIC8vIFJldHVybiBhbiBhcnJheSBvZiBkaXJlY3Rvcmllc1xuICAgICAgICAuc3BsaXQoJy8nKSk7XG59XG5mdW5jdGlvbiBnZXRJbnRlbnRVUkwobWV0aG9kUGF0aG5hbWUsIGludGVudFVybEJhc2UpIHtcbiAgICBsZXQgYmFzZVVybCA9IG51bGw7XG4gICAgaWYgKGludGVudFVybEJhc2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGJhc2VVcmwgPSBuZXcgVVJMKGludGVudFVybEJhc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkgeyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgICAgICAgaWYgKChiYXNlVXJsID09PSBudWxsIHx8IGJhc2VVcmwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJhc2VVcmwucHJvdG9jb2wpICE9PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX0ZPUkJJRERFTl9XQUxMRVRfQkFTRV9VUkwsICdCYXNlIFVSTHMgc3VwcGxpZWQgYnkgd2FsbGV0cyBtdXN0IGJlIHZhbGlkIGBodHRwc2AgVVJMcycpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGJhc2VVcmwgfHwgKGJhc2VVcmwgPSBuZXcgVVJMKGAke0lOVEVOVF9OQU1FfTovYCkpO1xuICAgIGNvbnN0IHBhdGhuYW1lID0gbWV0aG9kUGF0aG5hbWUuc3RhcnRzV2l0aCgnLycpXG4gICAgICAgID8gLy8gTWV0aG9kIGlzIGFuIGFic29sdXRlIHBhdGguIFJlcGxhY2UgaXQgd2hvbGVzYWxlLlxuICAgICAgICAgICAgbWV0aG9kUGF0aG5hbWVcbiAgICAgICAgOiAvLyBNZXRob2QgaXMgYSByZWxhdGl2ZSBwYXRoLiBNZXJnZSBpdCB3aXRoIHRoZSBleGlzdGluZyBvbmUuXG4gICAgICAgICAgICBbLi4uZ2V0UGF0aFBhcnRzKGJhc2VVcmwucGF0aG5hbWUpLCAuLi5nZXRQYXRoUGFydHMobWV0aG9kUGF0aG5hbWUpXS5qb2luKCcvJyk7XG4gICAgcmV0dXJuIG5ldyBVUkwocGF0aG5hbWUsIGJhc2VVcmwpO1xufVxuZnVuY3Rpb24gZ2V0QXNzb2NpYXRlQW5kcm9pZEludGVudFVSTChhc3NvY2lhdGlvblB1YmxpY0tleSwgcHV0YXRpdmVQb3J0LCBhc3NvY2lhdGlvblVSTEJhc2UsIHByb3RvY29sVmVyc2lvbnMgPSBbJ3YxJ10pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBhc3NvY2lhdGlvblBvcnQgPSBhc3NlcnRBc3NvY2lhdGlvblBvcnQocHV0YXRpdmVQb3J0KTtcbiAgICAgICAgY29uc3QgZXhwb3J0ZWRLZXkgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmV4cG9ydEtleSgncmF3JywgYXNzb2NpYXRpb25QdWJsaWNLZXkpO1xuICAgICAgICBjb25zdCBlbmNvZGVkS2V5ID0gYXJyYXlCdWZmZXJUb0Jhc2U2NFN0cmluZyhleHBvcnRlZEtleSk7XG4gICAgICAgIGNvbnN0IHVybCA9IGdldEludGVudFVSTCgndjEvYXNzb2NpYXRlL2xvY2FsJywgYXNzb2NpYXRpb25VUkxCYXNlKTtcbiAgICAgICAgdXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2Fzc29jaWF0aW9uJywgZ2V0U3RyaW5nV2l0aFVSTFVuc2FmZUNoYXJhY3RlcnNSZXBsYWNlZChlbmNvZGVkS2V5KSk7XG4gICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCdwb3J0JywgYCR7YXNzb2NpYXRpb25Qb3J0fWApO1xuICAgICAgICBwcm90b2NvbFZlcnNpb25zLmZvckVhY2goKHZlcnNpb24pID0+IHtcbiAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuc2V0KCd2JywgdmVyc2lvbik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdXJsO1xuICAgIH0pO1xufVxuXG4vLyBUeXBlc2NyaXB0IGBlbnVtc2AgdGh3YXJ0IHRyZWUtc2hha2luZy4gU2VlIGh0dHBzOi8vYmFyZ3N0ZW4ub3JnL2pzdHMvZW51bXMvXG5jb25zdCBCcm93c2VyID0ge1xuICAgIEZpcmVmb3g6IDAsXG4gICAgT3RoZXI6IDEsXG59O1xuZnVuY3Rpb24gYXNzZXJ0VW5yZWFjaGFibGUoeCkge1xuICAgIHJldHVybiB4O1xufVxuZnVuY3Rpb24gZ2V0QnJvd3NlcigpIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94LycpICE9PSAtMSA/IEJyb3dzZXIuRmlyZWZveCA6IEJyb3dzZXIuT3RoZXI7XG59XG5mdW5jdGlvbiBnZXREZXRlY3Rpb25Qcm9taXNlKCkge1xuICAgIC8vIENocm9tZSBhbmQgb3RoZXJzIHNpbGVudGx5IGZhaWwgaWYgYSBjdXN0b20gcHJvdG9jb2wgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAvLyBGb3IgdGhlc2UsIHdlIHdhaXQgdG8gc2VlIGlmIHRoZSBicm93c2VyIGlzIG5hdmlnYXRlZCBhd2F5IGZyb20gaW5cbiAgICAvLyBhIHJlYXNvbmFibGUgYW1vdW50IG9mIHRpbWUgKGllLiB0aGUgbmF0aXZlIHdhbGxldCBvcGVuZWQpLlxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgaGFuZGxlQmx1cik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlQmx1cigpIHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZUJsdXIpO1xuICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIHJlamVjdCgpO1xuICAgICAgICB9LCAyMDAwKTtcbiAgICB9KTtcbn1cbmxldCBfZnJhbWUgPSBudWxsO1xuZnVuY3Rpb24gbGF1bmNoVXJsVGhyb3VnaEhpZGRlbkZyYW1lKHVybCkge1xuICAgIGlmIChfZnJhbWUgPT0gbnVsbCkge1xuICAgICAgICBfZnJhbWUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgX2ZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoX2ZyYW1lKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICBfZnJhbWUuY29udGVudFdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiBzdGFydFNlc3Npb24oYXNzb2NpYXRpb25QdWJsaWNLZXksIGFzc29jaWF0aW9uVVJMQmFzZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHJhbmRvbUFzc29jaWF0aW9uUG9ydCA9IGdldFJhbmRvbUFzc29jaWF0aW9uUG9ydCgpO1xuICAgICAgICBjb25zdCBhc3NvY2lhdGlvblVybCA9IHlpZWxkIGdldEFzc29jaWF0ZUFuZHJvaWRJbnRlbnRVUkwoYXNzb2NpYXRpb25QdWJsaWNLZXksIHJhbmRvbUFzc29jaWF0aW9uUG9ydCwgYXNzb2NpYXRpb25VUkxCYXNlKTtcbiAgICAgICAgaWYgKGFzc29jaWF0aW9uVXJsLnByb3RvY29sID09PSAnaHR0cHM6Jykge1xuICAgICAgICAgICAgLy8gVGhlIGFzc29jaWF0aW9uIFVSTCBpcyBhbiBBbmRyb2lkICdBcHAgTGluaycgb3IgaU9TICdVbml2ZXJzYWwgTGluaycuXG4gICAgICAgICAgICAvLyBUaGVzZSBhcmUgcmVndWxhciB3ZWIgVVJMcyB0aGF0IGFyZSBkZXNpZ25lZCB0byBsYXVuY2ggYW4gYXBwIGlmIGl0XG4gICAgICAgICAgICAvLyBpcyBpbnN0YWxsZWQgb3IgbG9hZCB0aGUgYWN0dWFsIHRhcmdldCB3ZWJwYWdlIGlmIG5vdC5cbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5hc3NpZ24oYXNzb2NpYXRpb25VcmwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlIGFzc29jaWF0aW9uIFVSTCBoYXMgYSBjdXN0b20gcHJvdG9jb2wgKGVnLiBgc29sYW5hLXdhbGxldDpgKVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBicm93c2VyID0gZ2V0QnJvd3NlcigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYnJvd3Nlcikge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEJyb3dzZXIuRmlyZWZveDpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGEgY3VzdG9tIHByb3RvY29sIGlzIG5vdCBzdXBwb3J0ZWQgaW4gRmlyZWZveCwgaXQgdGhyb3dzLlxuICAgICAgICAgICAgICAgICAgICAgICAgbGF1bmNoVXJsVGhyb3VnaEhpZGRlbkZyYW1lKGFzc29jaWF0aW9uVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHJlYWNoZWQgdGhpcyBsaW5lLCBpdCdzIHN1cHBvcnRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIEJyb3dzZXIuT3RoZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRldGVjdGlvblByb21pc2UgPSBnZXREZXRlY3Rpb25Qcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKGFzc29jaWF0aW9uVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIGRldGVjdGlvblByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0VW5yZWFjaGFibGUoYnJvd3Nlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yKFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUuRVJST1JfV0FMTEVUX05PVF9GT1VORCwgJ0ZvdW5kIG5vIGluc3RhbGxlZCB3YWxsZXQgdGhhdCBzdXBwb3J0cyB0aGUgbW9iaWxlIHdhbGxldCBwcm90b2NvbC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmFuZG9tQXNzb2NpYXRpb25Qb3J0O1xuICAgIH0pO1xufVxuXG5jb25zdCBXRUJTT0NLRVRfQ09OTkVDVElPTl9DT05GSUcgPSB7XG4gICAgLyoqXG4gICAgICogMzAwIG1pbGxpc2Vjb25kcyBpcyBhIGdlbmVyYWxseSBhY2NlcHRlZCB0aHJlc2hvbGQgZm9yIHdoYXQgc29tZW9uZVxuICAgICAqIHdvdWxkIGNvbnNpZGVyIGFuIGFjY2VwdGFibGUgcmVzcG9uc2UgdGltZSBmb3IgYSB1c2VyIGludGVyZmFjZVxuICAgICAqIGFmdGVyIGhhdmluZyBwZXJmb3JtZWQgYSBsb3ctYXR0ZW50aW9uIHRhcHBpbmcgdGFzay4gV2Ugc2V0IHRoZSBpbml0aWFsXG4gICAgICogaW50ZXJ2YWwgYXQgd2hpY2ggd2Ugd2FpdCBmb3IgdGhlIHdhbGxldCB0byBzZXQgdXAgdGhlIHdlYnNvY2tldCBhdFxuICAgICAqIGhhbGYgdGhpcywgYXMgcGVyIHRoZSBOeXF1aXN0IGZyZXF1ZW5jeSwgd2l0aCBhIHByb2dyZXNzaXZlIGJhY2tvZmZcbiAgICAgKiBzZXF1ZW5jZSBmcm9tIHRoZXJlLiBUaGUgdG90YWwgd2FpdCB0aW1lIGlzIDMwcywgd2hpY2ggYWxsb3dzIGZvciB0aGVcbiAgICAgKiB1c2VyIHRvIGJlIHByZXNlbnRlZCB3aXRoIGEgZGlzYW1iaWd1YXRpb24gZGlhbG9nLCBzZWxlY3QgYSB3YWxsZXQsIGFuZFxuICAgICAqIGZvciB0aGUgd2FsbGV0IGFwcCB0byBzdWJzZXF1ZW50bHkgc3RhcnQuXG4gICAgICovXG4gICAgcmV0cnlEZWxheVNjaGVkdWxlTXM6IFsxNTAsIDE1MCwgMjAwLCA1MDAsIDUwMCwgNzUwLCA3NTAsIDEwMDBdLFxuICAgIHRpbWVvdXRNczogMzAwMDAsXG59O1xuY29uc3QgV0VCU09DS0VUX1BST1RPQ09MID0gJ2NvbS5zb2xhbmEubW9iaWxld2FsbGV0YWRhcHRlci52MSc7XG5mdW5jdGlvbiBhc3NlcnRTZWN1cmVDb250ZXh0KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCB3aW5kb3cuaXNTZWN1cmVDb250ZXh0ICE9PSB0cnVlKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9TRUNVUkVfQ09OVEVYVF9SRVFVSVJFRCwgJ1RoZSBtb2JpbGUgd2FsbGV0IGFkYXB0ZXIgcHJvdG9jb2wgbXVzdCBiZSB1c2VkIGluIGEgc2VjdXJlIGNvbnRleHQgKGBodHRwc2ApLicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydFNlY3VyZUVuZHBvaW50U3BlY2lmaWNVUkkod2FsbGV0VXJpQmFzZSkge1xuICAgIGxldCB1cmw7XG4gICAgdHJ5IHtcbiAgICAgICAgdXJsID0gbmV3IFVSTCh3YWxsZXRVcmlCYXNlKTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHRocm93IG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9GT1JCSURERU5fV0FMTEVUX0JBU0VfVVJMLCAnSW52YWxpZCBiYXNlIFVSTCBzdXBwbGllZCBieSB3YWxsZXQnKTtcbiAgICB9XG4gICAgaWYgKHVybC5wcm90b2NvbCAhPT0gJ2h0dHBzOicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvcihTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3JDb2RlLkVSUk9SX0ZPUkJJRERFTl9XQUxMRVRfQkFTRV9VUkwsICdCYXNlIFVSTHMgc3VwcGxpZWQgYnkgd2FsbGV0cyBtdXN0IGJlIHZhbGlkIGBodHRwc2AgVVJMcycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFNlcXVlbmNlTnVtYmVyRnJvbUJ5dGVBcnJheShieXRlQXJyYXkpIHtcbiAgICBjb25zdCB2aWV3ID0gbmV3IERhdGFWaWV3KGJ5dGVBcnJheSk7XG4gICAgcmV0dXJuIHZpZXcuZ2V0VWludDMyKDAsIC8qIGxpdHRsZUVuZGlhbiAqLyBmYWxzZSk7XG59XG5mdW5jdGlvbiB0cmFuc2FjdChjYWxsYmFjaywgY29uZmlnKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgYXNzZXJ0U2VjdXJlQ29udGV4dCgpO1xuICAgICAgICBjb25zdCBhc3NvY2lhdGlvbktleXBhaXIgPSB5aWVsZCBnZW5lcmF0ZUFzc29jaWF0aW9uS2V5cGFpcigpO1xuICAgICAgICBjb25zdCBzZXNzaW9uUG9ydCA9IHlpZWxkIHN0YXJ0U2Vzc2lvbihhc3NvY2lhdGlvbktleXBhaXIucHVibGljS2V5LCBjb25maWcgPT09IG51bGwgfHwgY29uZmlnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjb25maWcuYmFzZVVyaSk7XG4gICAgICAgIGNvbnN0IHdlYnNvY2tldFVSTCA9IGB3czovL2xvY2FsaG9zdDoke3Nlc3Npb25Qb3J0fS9zb2xhbmEtd2FsbGV0YDtcbiAgICAgICAgbGV0IGNvbm5lY3Rpb25TdGFydFRpbWU7XG4gICAgICAgIGNvbnN0IGdldE5leHRSZXRyeURlbGF5TXMgPSAoKCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2NoZWR1bGUgPSBbLi4uV0VCU09DS0VUX0NPTk5FQ1RJT05fQ09ORklHLnJldHJ5RGVsYXlTY2hlZHVsZU1zXTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiAoc2NoZWR1bGUubGVuZ3RoID4gMSA/IHNjaGVkdWxlLnNoaWZ0KCkgOiBzY2hlZHVsZVswXSk7XG4gICAgICAgIH0pKCk7XG4gICAgICAgIGxldCBuZXh0SnNvblJwY01lc3NhZ2VJZCA9IDE7XG4gICAgICAgIGxldCBsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgPSAwO1xuICAgICAgICBsZXQgc3RhdGUgPSB7IF9fdHlwZTogJ2Rpc2Nvbm5lY3RlZCcgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGxldCBzb2NrZXQ7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICAgICAgY29uc3QganNvblJwY1Jlc3BvbnNlUHJvbWlzZXMgPSB7fTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZU9wZW4gPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLl9fdHlwZSAhPT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRXhwZWN0ZWQgYWRhcHRlciBzdGF0ZSB0byBiZSBgY29ubmVjdGluZ2AgYXQgdGhlIG1vbWVudCB0aGUgd2Vic29ja2V0IG9wZW5zLiAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGBHb3QgXFxgJHtzdGF0ZS5fX3R5cGV9XFxgLmApO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXNzb2NpYXRpb25LZXlwYWlyIH0gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignb3BlbicsIGhhbmRsZU9wZW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVjZGhLZXlwYWlyID0geWllbGQgZ2VuZXJhdGVFQ0RIS2V5cGFpcigpO1xuICAgICAgICAgICAgICAgIHNvY2tldC5zZW5kKHlpZWxkIGNyZWF0ZUhlbGxvUmVxKGVjZGhLZXlwYWlyLnB1YmxpY0tleSwgYXNzb2NpYXRpb25LZXlwYWlyLnByaXZhdGVLZXkpKTtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgX190eXBlOiAnaGVsbG9fcmVxX3NlbnQnLFxuICAgICAgICAgICAgICAgICAgICBhc3NvY2lhdGlvblB1YmxpY0tleTogYXNzb2NpYXRpb25LZXlwYWlyLnB1YmxpY0tleSxcbiAgICAgICAgICAgICAgICAgICAgZWNkaFByaXZhdGVLZXk6IGVjZGhLZXlwYWlyLnByaXZhdGVLZXksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlQ2xvc2UgPSAoZXZ0KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2dC53YXNDbGVhbikge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IHsgX190eXBlOiAnZGlzY29ubmVjdGVkJyB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9TRVNTSU9OX0NMT1NFRCwgYFRoZSB3YWxsZXQgc2Vzc2lvbiBkcm9wcGVkIHVuZXhwZWN0ZWRseSAoJHtldnQuY29kZX06ICR7ZXZ0LnJlYXNvbn0pLmAsIHsgY2xvc2VFdmVudDogZXZ0IH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZUVycm9yID0gKF9ldnQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBkaXNwb3NlU29ja2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKERhdGUubm93KCkgLSBjb25uZWN0aW9uU3RhcnRUaW1lID49IFdFQlNPQ0tFVF9DT05ORUNUSU9OX0NPTkZJRy50aW1lb3V0TXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IoU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlckVycm9yQ29kZS5FUlJPUl9TRVNTSU9OX1RJTUVPVVQsIGBGYWlsZWQgdG8gY29ubmVjdCB0byB0aGUgd2FsbGV0IHdlYnNvY2tldCBvbiBwb3J0ICR7c2Vzc2lvblBvcnR9LmApKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXRyeURlbGF5TXMgPSBnZXROZXh0UmV0cnlEZWxheU1zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXRyeVdhaXRUaW1lb3V0SWQgPSB3aW5kb3cuc2V0VGltZW91dChyZXNvbHZlLCByZXRyeURlbGF5TXMpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdFNvY2tldENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZU1lc3NhZ2UgPSAoZXZ0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VCdWZmZXIgPSB5aWVsZCBldnQuZGF0YS5hcnJheUJ1ZmZlcigpO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoc3RhdGUuX190eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyVmVjdG9yID0gcmVzcG9uc2VCdWZmZXIuc2xpY2UoMCwgU0VRVUVOQ0VfTlVNQkVSX0JZVEVTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXF1ZW5jZU51bWJlciA9IGdldFNlcXVlbmNlTnVtYmVyRnJvbUJ5dGVBcnJheShzZXF1ZW5jZU51bWJlclZlY3Rvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlcXVlbmNlTnVtYmVyICE9PSAobGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyICsgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0ZWQgbWVzc2FnZSBoYXMgaW52YWxpZCBzZXF1ZW5jZSBudW1iZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdEtub3duSW5ib3VuZFNlcXVlbmNlTnVtYmVyID0gc2VxdWVuY2VOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QganNvblJwY01lc3NhZ2UgPSB5aWVsZCBkZWNyeXB0SnNvblJwY01lc3NhZ2UocmVzcG9uc2VCdWZmZXIsIHN0YXRlLnNoYXJlZFNlY3JldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VQcm9taXNlID0ganNvblJwY1Jlc3BvbnNlUHJvbWlzZXNbanNvblJwY01lc3NhZ2UuaWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tqc29uUnBjTWVzc2FnZS5pZF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlc29sdmUoanNvblJwY01lc3NhZ2UucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZVByb21pc2UgPSBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tlLmpzb25ScGNNZXNzYWdlSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUganNvblJwY1Jlc3BvbnNlUHJvbWlzZXNbZS5qc29uUnBjTWVzc2FnZUlkXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VQcm9taXNlLnJlamVjdChlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2hlbGxvX3JlcV9zZW50Jzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hhcmVkU2VjcmV0ID0geWllbGQgcGFyc2VIZWxsb1JzcChyZXNwb25zZUJ1ZmZlciwgc3RhdGUuYXNzb2NpYXRpb25QdWJsaWNLZXksIHN0YXRlLmVjZGhQcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyID0gcmVzcG9uc2VCdWZmZXIuc2xpY2UoRU5DT0RFRF9QVUJMSUNfS0VZX0xFTkdUSF9CWVRFUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXNzaW9uUHJvcGVydGllcyA9IHNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyLmJ5dGVMZW5ndGggIT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHlpZWxkICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlcXVlbmNlTnVtYmVyVmVjdG9yID0gc2Vzc2lvblByb3BlcnRpZXNCdWZmZXIuc2xpY2UoMCwgU0VRVUVOQ0VfTlVNQkVSX0JZVEVTKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VxdWVuY2VOdW1iZXIgPSBnZXRTZXF1ZW5jZU51bWJlckZyb21CeXRlQXJyYXkoc2VxdWVuY2VOdW1iZXJWZWN0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VxdWVuY2VOdW1iZXIgIT09IChsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgKyAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0ZWQgbWVzc2FnZSBoYXMgaW52YWxpZCBzZXF1ZW5jZSBudW1iZXInKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0S25vd25JbmJvdW5kU2VxdWVuY2VOdW1iZXIgPSBzZXF1ZW5jZU51bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlU2Vzc2lvblByb3BzKHNlc3Npb25Qcm9wZXJ0aWVzQnVmZmVyLCBzaGFyZWRTZWNyZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSgpIDogeyBwcm90b2NvbF92ZXJzaW9uOiAnbGVnYWN5JyB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSB7IF9fdHlwZTogJ2Nvbm5lY3RlZCcsIHNoYXJlZFNlY3JldCwgc2Vzc2lvblByb3BlcnRpZXMgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdhbGxldCA9IGNyZWF0ZU1vYmlsZVdhbGxldFByb3h5KHNlc3Npb25Qcm9wZXJ0aWVzLnByb3RvY29sX3ZlcnNpb24sIChtZXRob2QsIHBhcmFtcykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gbmV4dEpzb25ScGNNZXNzYWdlSWQrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXQuc2VuZCh5aWVsZCBlbmNyeXB0SnNvblJwY01lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvbnJwYzogJzIuMCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMgIT09IG51bGwgJiYgcGFyYW1zICE9PSB2b2lkIDAgPyBwYXJhbXMgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBzaGFyZWRTZWNyZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uUnBjUmVzcG9uc2VQcm9taXNlc1tpZF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F1dGhvcml6ZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3JlYXV0aG9yaXplJzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgeyB3YWxsZXRfdXJpX2Jhc2UgfSA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3YWxsZXRfdXJpX2Jhc2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydFNlY3VyZUVuZHBvaW50U3BlY2lmaWNVUkkod2FsbGV0X3VyaV9iYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh5aWVsZCBjYWxsYmFjayh3YWxsZXQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBkaXNwb3NlU29ja2V0O1xuICAgICAgICAgICAgbGV0IHJldHJ5V2FpdFRpbWVvdXRJZDtcbiAgICAgICAgICAgIGNvbnN0IGF0dGVtcHRTb2NrZXRDb25uZWN0aW9uID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChkaXNwb3NlU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUgPSB7IF9fdHlwZTogJ2Nvbm5lY3RpbmcnLCBhc3NvY2lhdGlvbktleXBhaXIgfTtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvblN0YXJ0VGltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25TdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHdlYnNvY2tldFVSTCwgW1dFQlNPQ0tFVF9QUk9UT0NPTF0pO1xuICAgICAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdvcGVuJywgaGFuZGxlT3Blbik7XG4gICAgICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgaGFuZGxlQ2xvc2UpO1xuICAgICAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICAgICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGhhbmRsZU1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGRpc3Bvc2VTb2NrZXQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQocmV0cnlXYWl0VGltZW91dElkKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ29wZW4nLCBoYW5kbGVPcGVuKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgaGFuZGxlQ2xvc2UpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignZXJyb3InLCBoYW5kbGVFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgaGFuZGxlTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBhdHRlbXB0U29ja2V0Q29ubmVjdGlvbigpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgU29sYW5hQ2xvbmVBdXRob3JpemF0aW9uLCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3IsIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJFcnJvckNvZGUsIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJQcm90b2NvbEVycm9yLCBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyUHJvdG9jb2xFcnJvckNvZGUsIFNvbGFuYVNpZ25JbldpdGhTb2xhbmEsIFNvbGFuYVNpZ25UcmFuc2FjdGlvbnMsIHRyYW5zYWN0IH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol/lib/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaMobileWalletAdapter: function() { return /* binding */ SolanaMobileWalletAdapter; },\n/* harmony export */   SolanaMobileWalletAdapterWalletName: function() { return /* binding */ SolanaMobileWalletAdapterWalletName; },\n/* harmony export */   createDefaultAddressSelector: function() { return /* binding */ createDefaultAddressSelector; },\n/* harmony export */   createDefaultAuthorizationResultCache: function() { return /* binding */ createDefaultAuthorizationResultCache; },\n/* harmony export */   createDefaultWalletNotFoundHandler: function() { return /* binding */ createDefaultWalletNotFoundHandler; }\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/signer.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _solana_mobile_mobile_wallet_adapter_protocol_web3js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana-mobile/mobile-wallet-adapter-protocol-web3js */ \"(app-pages-browser)/./node_modules/@solana-mobile/mobile-wallet-adapter-protocol-web3js/lib/esm/index.js\");\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\nfunction toUint8Array(base64EncodedByteArray) {\n    return new Uint8Array(window\n        .atob(base64EncodedByteArray)\n        .split('')\n        .map((c) => c.charCodeAt(0)));\n}\n\nfunction getIsSupported() {\n    return (typeof window !== 'undefined' &&\n        window.isSecureContext &&\n        typeof document !== 'undefined' &&\n        /android/i.test(navigator.userAgent));\n}\n\nconst SolanaMobileWalletAdapterWalletName = 'Mobile Wallet Adapter';\nconst SIGNATURE_LENGTH_IN_BYTES = 64;\nfunction getPublicKeyFromAddress(address) {\n    const publicKeyByteArray = toUint8Array(address);\n    return new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(publicKeyByteArray);\n}\nfunction isVersionedTransaction(transaction) {\n    return 'version' in transaction;\n}\nclass SolanaMobileWalletAdapter extends _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.BaseSignInMessageSignerWalletAdapter {\n    constructor(config) {\n        var _a;\n        super();\n        this.supportedTransactionVersions = new Set(\n        // FIXME(#244): We can't actually know what versions are supported until we know which wallet we're talking to.\n        ['legacy', 0]);\n        this.name = SolanaMobileWalletAdapterWalletName;\n        this.url = 'https://solanamobile.com/wallets';\n        this.icon = 'data:image/svg+xml;base64,PHN2ZyBmaWxsPSJub25lIiBoZWlnaHQ9IjI4IiB3aWR0aD0iMjgiIHZpZXdCb3g9Ii0zIDAgMjggMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGcgZmlsbD0iI0RDQjhGRiI+PHBhdGggZD0iTTE3LjQgMTcuNEgxNXYyLjRoMi40di0yLjRabTEuMi05LjZoLTIuNHYyLjRoMi40VjcuOFoiLz48cGF0aCBkPSJNMjEuNiAzVjBoLTIuNHYzaC0zLjZWMGgtMi40djNoLTIuNHY2LjZINC41YTIuMSAyLjEgMCAxIDEgMC00LjJoMi43VjNINC41QTQuNSA0LjUgMCAwIDAgMCA3LjVWMjRoMjEuNnYtNi42aC0yLjR2NC4ySDIuNFYxMS41Yy41LjMgMS4yLjQgMS44LjVoNy41QTYuNiA2LjYgMCAwIDAgMjQgOVYzaC0yLjRabTAgNS43YTQuMiA0LjIgMCAxIDEtOC40IDBWNS40aDguNHYzLjNaIi8+PC9nPjwvc3ZnPg==';\n        this._connecting = false;\n        /**\n         * Every time the connection is recycled in some way (eg. `disconnect()` is called)\n         * increment this and use it to make sure that `transact` calls from the previous\n         * 'generation' don't continue to do work and throw exceptions.\n         */\n        this._connectionGeneration = 0;\n        this._readyState = getIsSupported() ? _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Loadable : _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Unsupported;\n        this._authorizationResultCache = config.authorizationResultCache;\n        this._addressSelector = config.addressSelector;\n        this._appIdentity = config.appIdentity;\n        this._chain = (_a = config.chain) !== null && _a !== void 0 ? _a : config.cluster;\n        this._onWalletNotFound = config.onWalletNotFound;\n        if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Unsupported) {\n            this._authorizationResultCache.get().then((authorizationResult) => {\n                if (authorizationResult) {\n                    // Having a prior authorization result is, right now, the best\n                    // indication that a mobile wallet is installed. There is no API\n                    // we can use to test for whether the association URI is supported.\n                    this.declareWalletAsInstalled();\n                }\n            });\n        }\n    }\n    get publicKey() {\n        if (this._publicKey == null && this._selectedAddress != null) {\n            try {\n                this._publicKey = getPublicKeyFromAddress(this._selectedAddress);\n            }\n            catch (e) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletPublicKeyError((e instanceof Error && (e === null || e === void 0 ? void 0 : e.message)) || 'Unknown error', e);\n            }\n        }\n        return this._publicKey ? this._publicKey : null;\n    }\n    get connected() {\n        return !!this._authorizationResult;\n    }\n    get connecting() {\n        return this._connecting;\n    }\n    get readyState() {\n        return this._readyState;\n    }\n    declareWalletAsInstalled() {\n        if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Installed) {\n            this.emit('readyStateChange', (this._readyState = _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Installed));\n        }\n    }\n    runWithGuard(callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                return yield callback();\n            }\n            catch (e) {\n                this.emit('error', e);\n                throw e;\n            }\n        });\n    }\n    /** @deprecated Use `autoConnect()` instead. */\n    autoConnect_DO_NOT_USE_OR_YOU_WILL_BE_FIRED() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.autoConnect();\n        });\n    }\n    autoConnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.connecting || this.connected) {\n                return;\n            }\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Loadable) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletNotReadyError();\n                }\n                this._connecting = true;\n                try {\n                    const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n                    if (cachedAuthorizationResult) {\n                        // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                        this.handleAuthorizationResult(cachedAuthorizationResult);\n                    }\n                }\n                catch (e) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletConnectionError((e instanceof Error && e.message) || 'Unknown error', e);\n                }\n                finally {\n                    this._connecting = false;\n                }\n            }));\n        });\n    }\n    connect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.connecting || this.connected) {\n                return;\n            }\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Loadable) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletNotReadyError();\n                }\n                this._connecting = true;\n                try {\n                    yield this.performAuthorization();\n                }\n                catch (e) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletConnectionError((e instanceof Error && e.message) || 'Unknown error', e);\n                }\n                finally {\n                    this._connecting = false;\n                }\n            }));\n        });\n    }\n    performAuthorization(signInPayload) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const cachedAuthorizationResult = yield this._authorizationResultCache.get();\n                if (cachedAuthorizationResult) {\n                    // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                    this.handleAuthorizationResult(cachedAuthorizationResult);\n                    return cachedAuthorizationResult;\n                }\n                return yield this.transact((wallet) => __awaiter(this, void 0, void 0, function* () {\n                    const authorizationResult = yield wallet.authorize({\n                        chain: this._chain,\n                        identity: this._appIdentity,\n                        sign_in_payload: signInPayload,\n                    });\n                    // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                    Promise.all([\n                        this._authorizationResultCache.set(authorizationResult),\n                        this.handleAuthorizationResult(authorizationResult),\n                    ]);\n                    return authorizationResult;\n                }));\n            }\n            catch (e) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletConnectionError((e instanceof Error && e.message) || 'Unknown error', e);\n            }\n        });\n    }\n    handleAuthorizationResult(authorizationResult) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const didPublicKeysChange = \n            // Case 1: We started from having no authorization.\n            this._authorizationResult == null ||\n                // Case 2: The number of authorized accounts changed.\n                ((_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.accounts.length) !== authorizationResult.accounts.length ||\n                // Case 3: The new list of addresses isn't exactly the same as the old list, in the same order.\n                this._authorizationResult.accounts.some((account, ii) => account.address !== authorizationResult.accounts[ii].address);\n            this._authorizationResult = authorizationResult;\n            this.declareWalletAsInstalled();\n            if (didPublicKeysChange) {\n                const nextSelectedAddress = yield this._addressSelector.select(authorizationResult.accounts.map(({ address }) => address));\n                if (nextSelectedAddress !== this._selectedAddress) {\n                    this._selectedAddress = nextSelectedAddress;\n                    delete this._publicKey;\n                    this.emit('connect', \n                    // Having just set `this._selectedAddress`, `this.publicKey` is definitely non-null\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    this.publicKey);\n                }\n            }\n        });\n    }\n    performReauthorization(wallet, authToken) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                const authorizationResult = yield wallet.authorize({\n                    auth_token: authToken,\n                    identity: this._appIdentity,\n                });\n                // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n                Promise.all([\n                    this._authorizationResultCache.set(authorizationResult),\n                    this.handleAuthorizationResult(authorizationResult),\n                ]);\n            }\n            catch (e) {\n                this.disconnect();\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletDisconnectedError((e instanceof Error && (e === null || e === void 0 ? void 0 : e.message)) || 'Unknown error', e);\n            }\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._authorizationResultCache.clear(); // TODO: Evaluate whether there's any threat to not `awaiting` this expression\n            this._connecting = false;\n            this._connectionGeneration++;\n            delete this._authorizationResult;\n            delete this._publicKey;\n            delete this._selectedAddress;\n            this.emit('disconnect');\n        });\n    }\n    transact(callback) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const walletUriBase = (_a = this._authorizationResult) === null || _a === void 0 ? void 0 : _a.wallet_uri_base;\n            const config = walletUriBase ? { baseUri: walletUriBase } : undefined;\n            const currentConnectionGeneration = this._connectionGeneration;\n            try {\n                return yield (0,_solana_mobile_mobile_wallet_adapter_protocol_web3js__WEBPACK_IMPORTED_MODULE_1__.transact)(callback, config);\n            }\n            catch (e) {\n                if (this._connectionGeneration !== currentConnectionGeneration) {\n                    yield new Promise(() => { }); // Never resolve.\n                }\n                if (e instanceof Error &&\n                    e.name === 'SolanaMobileWalletAdapterError' &&\n                    e.code === 'ERROR_WALLET_NOT_FOUND') {\n                    yield this._onWalletNotFound(this);\n                }\n                throw e;\n            }\n        });\n    }\n    assertIsAuthorized() {\n        if (!this._authorizationResult || !this._selectedAddress)\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletNotConnectedError();\n        return {\n            authToken: this._authorizationResult.auth_token,\n            selectedAddress: this._selectedAddress,\n        };\n    }\n    performSignTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { authToken } = this.assertIsAuthorized();\n            try {\n                return yield this.transact((wallet) => __awaiter(this, void 0, void 0, function* () {\n                    yield this.performReauthorization(wallet, authToken);\n                    const signedTransactions = yield wallet.signTransactions({\n                        transactions,\n                    });\n                    return signedTransactions;\n                }));\n            }\n            catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletSignTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n            }\n        });\n    }\n    sendTransaction(transaction, connection, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                const { authToken } = this.assertIsAuthorized();\n                const minContextSlot = options === null || options === void 0 ? void 0 : options.minContextSlot;\n                try {\n                    return yield this.transact((wallet) => __awaiter(this, void 0, void 0, function* () {\n                        function getTargetCommitment() {\n                            let targetCommitment;\n                            switch (connection.commitment) {\n                                case 'confirmed':\n                                case 'finalized':\n                                case 'processed':\n                                    targetCommitment = connection.commitment;\n                                    break;\n                                default:\n                                    targetCommitment = 'finalized';\n                            }\n                            let targetPreflightCommitment;\n                            switch (options === null || options === void 0 ? void 0 : options.preflightCommitment) {\n                                case 'confirmed':\n                                case 'finalized':\n                                case 'processed':\n                                    targetPreflightCommitment = options.preflightCommitment;\n                                    break;\n                                case undefined:\n                                    targetPreflightCommitment = targetCommitment;\n                                    break;\n                                default:\n                                    targetPreflightCommitment = 'finalized';\n                            }\n                            const preflightCommitmentScore = targetPreflightCommitment === 'finalized'\n                                ? 2\n                                : targetPreflightCommitment === 'confirmed'\n                                    ? 1\n                                    : 0;\n                            const targetCommitmentScore = targetCommitment === 'finalized' ? 2 : targetCommitment === 'confirmed' ? 1 : 0;\n                            return preflightCommitmentScore < targetCommitmentScore\n                                ? targetPreflightCommitment\n                                : targetCommitment;\n                        }\n                        const [capabilities, _1, _2] = yield Promise.all([\n                            wallet.getCapabilities(),\n                            this.performReauthorization(wallet, authToken),\n                            isVersionedTransaction(transaction)\n                                ? null\n                                : /**\n                                   * Unlike versioned transactions, legacy `Transaction` objects\n                                   * may not have an associated `feePayer` or `recentBlockhash`.\n                                   * This code exists to patch them up in case they are missing.\n                                   */\n                                    (() => __awaiter(this, void 0, void 0, function* () {\n                                        var _a;\n                                        transaction.feePayer || (transaction.feePayer = (_a = this.publicKey) !== null && _a !== void 0 ? _a : undefined);\n                                        if (transaction.recentBlockhash == null) {\n                                            const { blockhash } = yield connection.getLatestBlockhash({\n                                                commitment: getTargetCommitment(),\n                                            });\n                                            transaction.recentBlockhash = blockhash;\n                                        }\n                                    }))(),\n                        ]);\n                        if (capabilities.supports_sign_and_send_transactions) {\n                            const signatures = yield wallet.signAndSendTransactions({\n                                minContextSlot,\n                                transactions: [transaction],\n                            });\n                            return signatures[0];\n                        }\n                        else {\n                            const [signedTransaction] = yield wallet.signTransactions({\n                                transactions: [transaction],\n                            });\n                            if (isVersionedTransaction(signedTransaction)) {\n                                return yield connection.sendTransaction(signedTransaction);\n                            }\n                            else {\n                                const serializedTransaction = signedTransaction.serialize();\n                                return yield connection.sendRawTransaction(serializedTransaction, Object.assign(Object.assign({}, options), { preflightCommitment: getTargetCommitment() }));\n                            }\n                        }\n                    }));\n                }\n                catch (error) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletSendTransactionError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n            }));\n        });\n    }\n    signTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                const [signedTransaction] = yield this.performSignTransactions([transaction]);\n                return signedTransaction;\n            }));\n        });\n    }\n    signAllTransactions(transactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                const signedTransactions = yield this.performSignTransactions(transactions);\n                return signedTransactions;\n            }));\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                const { authToken, selectedAddress } = this.assertIsAuthorized();\n                try {\n                    return yield this.transact((wallet) => __awaiter(this, void 0, void 0, function* () {\n                        yield this.performReauthorization(wallet, authToken);\n                        const [signedMessage] = yield wallet.signMessages({\n                            addresses: [selectedAddress],\n                            payloads: [message],\n                        });\n                        const signature = signedMessage.slice(-SIGNATURE_LENGTH_IN_BYTES);\n                        return signature;\n                    }));\n                }\n                catch (error) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletSignMessageError(error === null || error === void 0 ? void 0 : error.message, error);\n                }\n            }));\n        });\n    }\n    signIn(input) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return yield this.runWithGuard(() => __awaiter(this, void 0, void 0, function* () {\n                var _a, _b;\n                if (this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Installed && this._readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Loadable) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletNotReadyError();\n                }\n                this._connecting = true;\n                try {\n                    const authorizationResult = yield this.performAuthorization(Object.assign(Object.assign({}, input), { domain: (_a = input === null || input === void 0 ? void 0 : input.domain) !== null && _a !== void 0 ? _a : window.location.host }));\n                    if (!authorizationResult.sign_in_result) {\n                        throw new Error(\"Sign in failed, no sign in result returned by wallet\");\n                    }\n                    const signedInAddress = authorizationResult.sign_in_result.address;\n                    const signedInAccount = Object.assign(Object.assign({}, (_b = authorizationResult.accounts.find(acc => acc.address == signedInAddress)) !== null && _b !== void 0 ? _b : {\n                        address: signedInAddress\n                    }), { publicKey: toUint8Array(signedInAddress) });\n                    return {\n                        account: signedInAccount,\n                        signedMessage: toUint8Array(authorizationResult.sign_in_result.signed_message),\n                        signature: toUint8Array(authorizationResult.sign_in_result.signature)\n                    };\n                }\n                catch (e) {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletConnectionError((e instanceof Error && e.message) || 'Unknown error', e);\n                }\n                finally {\n                    this._connecting = false;\n                }\n            }));\n        });\n    }\n}\n\nfunction createDefaultAddressSelector() {\n    return {\n        select(addresses) {\n            return __awaiter(this, void 0, void 0, function* () {\n                return addresses[0];\n            });\n        },\n    };\n}\n\nconst CACHE_KEY = 'SolanaMobileWalletAdapterDefaultAuthorizationCache';\nfunction createDefaultAuthorizationResultCache() {\n    let storage;\n    try {\n        storage = window.localStorage;\n        // eslint-disable-next-line no-empty\n    }\n    catch (_a) { }\n    return {\n        clear() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!storage) {\n                    return;\n                }\n                try {\n                    storage.removeItem(CACHE_KEY);\n                    // eslint-disable-next-line no-empty\n                }\n                catch (_a) { }\n            });\n        },\n        get() {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!storage) {\n                    return;\n                }\n                try {\n                    return JSON.parse(storage.getItem(CACHE_KEY)) || undefined;\n                    // eslint-disable-next-line no-empty\n                }\n                catch (_a) { }\n            });\n        },\n        set(authorizationResult) {\n            return __awaiter(this, void 0, void 0, function* () {\n                if (!storage) {\n                    return;\n                }\n                try {\n                    storage.setItem(CACHE_KEY, JSON.stringify(authorizationResult));\n                    // eslint-disable-next-line no-empty\n                }\n                catch (_a) { }\n            });\n        },\n    };\n}\n\nfunction defaultWalletNotFoundHandler(mobileWalletAdapter) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (typeof window !== 'undefined') {\n            window.location.assign(mobileWalletAdapter.url);\n        }\n    });\n}\nfunction createDefaultWalletNotFoundHandler() {\n    return defaultWalletNotFoundHandler;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hLW1vYmlsZS93YWxsZXQtYWRhcHRlci1tb2JpbGUvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQXlTO0FBQzdQO0FBQ29DOztBQUVoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHNEQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDZGQUFvQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLHlFQUFnQixZQUFZLHlFQUFnQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlFQUFnQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDZFQUFvQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHlFQUFnQjtBQUNqRCw4REFBOEQseUVBQWdCO0FBQzlFO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVtTCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS1tb2JpbGUvd2FsbGV0LWFkYXB0ZXItbW9iaWxlL2xpYi9lc20vaW5kZXguanM/YTA1NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlU2lnbkluTWVzc2FnZVNpZ25lcldhbGxldEFkYXB0ZXIsIFdhbGxldFJlYWR5U3RhdGUsIFdhbGxldFB1YmxpY0tleUVycm9yLCBXYWxsZXROb3RSZWFkeUVycm9yLCBXYWxsZXRDb25uZWN0aW9uRXJyb3IsIFdhbGxldERpc2Nvbm5lY3RlZEVycm9yLCBXYWxsZXROb3RDb25uZWN0ZWRFcnJvciwgV2FsbGV0U2lnblRyYW5zYWN0aW9uRXJyb3IsIFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yLCBXYWxsZXRTaWduTWVzc2FnZUVycm9yIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlJztcbmltcG9ydCB7IFB1YmxpY0tleSB9IGZyb20gJ0Bzb2xhbmEvd2ViMy5qcyc7XG5pbXBvcnQgeyB0cmFuc2FjdCB9IGZyb20gJ0Bzb2xhbmEtbW9iaWxlL21vYmlsZS13YWxsZXQtYWRhcHRlci1wcm90b2NvbC13ZWIzanMnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cblxuZnVuY3Rpb24gdG9VaW50OEFycmF5KGJhc2U2NEVuY29kZWRCeXRlQXJyYXkpIHtcbiAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkod2luZG93XG4gICAgICAgIC5hdG9iKGJhc2U2NEVuY29kZWRCeXRlQXJyYXkpXG4gICAgICAgIC5zcGxpdCgnJylcbiAgICAgICAgLm1hcCgoYykgPT4gYy5jaGFyQ29kZUF0KDApKSk7XG59XG5cbmZ1bmN0aW9uIGdldElzU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgICAgd2luZG93LmlzU2VjdXJlQ29udGV4dCAmJlxuICAgICAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIC9hbmRyb2lkL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSk7XG59XG5cbmNvbnN0IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lID0gJ01vYmlsZSBXYWxsZXQgQWRhcHRlcic7XG5jb25zdCBTSUdOQVRVUkVfTEVOR1RIX0lOX0JZVEVTID0gNjQ7XG5mdW5jdGlvbiBnZXRQdWJsaWNLZXlGcm9tQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgY29uc3QgcHVibGljS2V5Qnl0ZUFycmF5ID0gdG9VaW50OEFycmF5KGFkZHJlc3MpO1xuICAgIHJldHVybiBuZXcgUHVibGljS2V5KHB1YmxpY0tleUJ5dGVBcnJheSk7XG59XG5mdW5jdGlvbiBpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgcmV0dXJuICd2ZXJzaW9uJyBpbiB0cmFuc2FjdGlvbjtcbn1cbmNsYXNzIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXIgZXh0ZW5kcyBCYXNlU2lnbkluTWVzc2FnZVNpZ25lcldhbGxldEFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucyA9IG5ldyBTZXQoXG4gICAgICAgIC8vIEZJWE1FKCMyNDQpOiBXZSBjYW4ndCBhY3R1YWxseSBrbm93IHdoYXQgdmVyc2lvbnMgYXJlIHN1cHBvcnRlZCB1bnRpbCB3ZSBrbm93IHdoaWNoIHdhbGxldCB3ZSdyZSB0YWxraW5nIHRvLlxuICAgICAgICBbJ2xlZ2FjeScsIDBdKTtcbiAgICAgICAgdGhpcy5uYW1lID0gU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldE5hbWU7XG4gICAgICAgIHRoaXMudXJsID0gJ2h0dHBzOi8vc29sYW5hbW9iaWxlLmNvbS93YWxsZXRzJztcbiAgICAgICAgdGhpcy5pY29uID0gJ2RhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsUEhOMlp5Qm1hV3hzUFNKdWIyNWxJaUJvWldsbmFIUTlJakk0SWlCM2FXUjBhRDBpTWpnaUlIWnBaWGRDYjNnOUlpMHpJREFnTWpnZ01qZ2lJSGh0Ykc1elBTSm9kSFJ3T2k4dmQzZDNMbmN6TG05eVp5OHlNREF3TDNOMlp5SStQR2NnWm1sc2JEMGlJMFJEUWpoR1JpSStQSEJoZEdnZ1pEMGlUVEUzTGpRZ01UY3VORWd4TlhZeUxqUm9NaTQwZGkweUxqUmFiVEV1TWkwNUxqWm9MVEl1TkhZeUxqUm9NaTQwVmpjdU9Gb2lMejQ4Y0dGMGFDQmtQU0pOTWpFdU5pQXpWakJvTFRJdU5IWXphQzB6TGpaV01HZ3RNaTQwZGpOb0xUSXVOSFkyTGpaSU5DNDFZVEl1TVNBeUxqRWdNQ0F4SURFZ01DMDBMakpvTWk0M1ZqTklOQzQxUVRRdU5TQTBMalVnTUNBd0lEQWdNQ0EzTGpWV01qUm9NakV1Tm5ZdE5pNDJhQzB5TGpSMk5DNHlTREl1TkZZeE1TNDFZeTQxTGpNZ01TNHlMalFnTVM0NExqVm9OeTQxUVRZdU5pQTJMallnTUNBd0lEQWdNalFnT1ZZemFDMHlMalJhYlRBZ05TNDNZVFF1TWlBMExqSWdNQ0F4SURFdE9DNDBJREJXTlM0MGFEZ3VOSFl6TGpOYUlpOCtQQzluUGp3dmMzWm5QZz09JztcbiAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogRXZlcnkgdGltZSB0aGUgY29ubmVjdGlvbiBpcyByZWN5Y2xlZCBpbiBzb21lIHdheSAoZWcuIGBkaXNjb25uZWN0KClgIGlzIGNhbGxlZClcbiAgICAgICAgICogaW5jcmVtZW50IHRoaXMgYW5kIHVzZSBpdCB0byBtYWtlIHN1cmUgdGhhdCBgdHJhbnNhY3RgIGNhbGxzIGZyb20gdGhlIHByZXZpb3VzXG4gICAgICAgICAqICdnZW5lcmF0aW9uJyBkb24ndCBjb250aW51ZSB0byBkbyB3b3JrIGFuZCB0aHJvdyBleGNlcHRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fY29ubmVjdGlvbkdlbmVyYXRpb24gPSAwO1xuICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gZ2V0SXNTdXBwb3J0ZWQoKSA/IFdhbGxldFJlYWR5U3RhdGUuTG9hZGFibGUgOiBXYWxsZXRSZWFkeVN0YXRlLlVuc3VwcG9ydGVkO1xuICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUgPSBjb25maWcuYXV0aG9yaXphdGlvblJlc3VsdENhY2hlO1xuICAgICAgICB0aGlzLl9hZGRyZXNzU2VsZWN0b3IgPSBjb25maWcuYWRkcmVzc1NlbGVjdG9yO1xuICAgICAgICB0aGlzLl9hcHBJZGVudGl0eSA9IGNvbmZpZy5hcHBJZGVudGl0eTtcbiAgICAgICAgdGhpcy5fY2hhaW4gPSAoX2EgPSBjb25maWcuY2hhaW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNvbmZpZy5jbHVzdGVyO1xuICAgICAgICB0aGlzLl9vbldhbGxldE5vdEZvdW5kID0gY29uZmlnLm9uV2FsbGV0Tm90Rm91bmQ7XG4gICAgICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLlVuc3VwcG9ydGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuZ2V0KCkudGhlbigoYXV0aG9yaXphdGlvblJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhdXRob3JpemF0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhdmluZyBhIHByaW9yIGF1dGhvcml6YXRpb24gcmVzdWx0IGlzLCByaWdodCBub3csIHRoZSBiZXN0XG4gICAgICAgICAgICAgICAgICAgIC8vIGluZGljYXRpb24gdGhhdCBhIG1vYmlsZSB3YWxsZXQgaXMgaW5zdGFsbGVkLiBUaGVyZSBpcyBubyBBUElcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgY2FuIHVzZSB0byB0ZXN0IGZvciB3aGV0aGVyIHRoZSBhc3NvY2lhdGlvbiBVUkkgaXMgc3VwcG9ydGVkLlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlY2xhcmVXYWxsZXRBc0luc3RhbGxlZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBwdWJsaWNLZXkoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wdWJsaWNLZXkgPT0gbnVsbCAmJiB0aGlzLl9zZWxlY3RlZEFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wdWJsaWNLZXkgPSBnZXRQdWJsaWNLZXlGcm9tQWRkcmVzcyh0aGlzLl9zZWxlY3RlZEFkZHJlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0UHVibGljS2V5RXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiAoZSA9PT0gbnVsbCB8fCBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlLm1lc3NhZ2UpKSB8fCAnVW5rbm93biBlcnJvcicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9wdWJsaWNLZXkgPyB0aGlzLl9wdWJsaWNLZXkgOiBudWxsO1xuICAgIH1cbiAgICBnZXQgY29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0O1xuICAgIH1cbiAgICBnZXQgY29ubmVjdGluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nvbm5lY3Rpbmc7XG4gICAgfVxuICAgIGdldCByZWFkeVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcbiAgICB9XG4gICAgZGVjbGFyZVdhbGxldEFzSW5zdGFsbGVkKCkge1xuICAgICAgICBpZiAodGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVhZHlTdGF0ZUNoYW5nZScsICh0aGlzLl9yZWFkeVN0YXRlID0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5XaXRoR3VhcmQoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkIFVzZSBgYXV0b0Nvbm5lY3QoKWAgaW5zdGVhZC4gKi9cbiAgICBhdXRvQ29ubmVjdF9ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuYXV0b0Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGF1dG9Db25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdGluZyB8fCB0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkICYmIHRoaXMuX3JlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuTG9hZGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdFJlYWR5RXJyb3IoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FjaGVkQXV0aG9yaXphdGlvblJlc3VsdCA9IHlpZWxkIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZS5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IEV2YWx1YXRlIHdoZXRoZXIgdGhlcmUncyBhbnkgdGhyZWF0IHRvIG5vdCBgYXdhaXRpbmdgIHRoaXMgZXhwcmVzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVBdXRob3JpemF0aW9uUmVzdWx0KGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25uZWN0aW9uRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RpbmcgfHwgdGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLkluc3RhbGxlZCAmJiB0aGlzLl9yZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLkxvYWRhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RSZWFkeUVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGVyZm9ybUF1dGhvcml6YXRpb24oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldENvbm5lY3Rpb25FcnJvcigoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZSkgfHwgJ1Vua25vd24gZXJyb3InLCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Nvbm5lY3RpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwZXJmb3JtQXV0aG9yaXphdGlvbihzaWduSW5QYXlsb2FkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQgPSB5aWVsZCB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuZ2V0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQXV0aG9yaXphdGlvblJlc3VsdChjYWNoZWRBdXRob3JpemF0aW9uUmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhY2hlZEF1dGhvcml6YXRpb25SZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnRyYW5zYWN0KCh3YWxsZXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvblJlc3VsdCA9IHlpZWxkIHdhbGxldC5hdXRob3JpemUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW46IHRoaXMuX2NoYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWRlbnRpdHk6IHRoaXMuX2FwcElkZW50aXR5LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbl9pbl9wYXlsb2FkOiBzaWduSW5QYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHRDYWNoZS5zZXQoYXV0aG9yaXphdGlvblJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUF1dGhvcml6YXRpb25SZXN1bHQoYXV0aG9yaXphdGlvblJlc3VsdCksXG4gICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXV0aG9yaXphdGlvblJlc3VsdDtcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25uZWN0aW9uRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVBdXRob3JpemF0aW9uUmVzdWx0KGF1dGhvcml6YXRpb25SZXN1bHQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGlkUHVibGljS2V5c0NoYW5nZSA9IFxuICAgICAgICAgICAgLy8gQ2FzZSAxOiBXZSBzdGFydGVkIGZyb20gaGF2aW5nIG5vIGF1dGhvcml6YXRpb24uXG4gICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0ID09IG51bGwgfHxcbiAgICAgICAgICAgICAgICAvLyBDYXNlIDI6IFRoZSBudW1iZXIgb2YgYXV0aG9yaXplZCBhY2NvdW50cyBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICgoX2EgPSB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWNjb3VudHMubGVuZ3RoKSAhPT0gYXV0aG9yaXphdGlvblJlc3VsdC5hY2NvdW50cy5sZW5ndGggfHxcbiAgICAgICAgICAgICAgICAvLyBDYXNlIDM6IFRoZSBuZXcgbGlzdCBvZiBhZGRyZXNzZXMgaXNuJ3QgZXhhY3RseSB0aGUgc2FtZSBhcyB0aGUgb2xkIGxpc3QsIGluIHRoZSBzYW1lIG9yZGVyLlxuICAgICAgICAgICAgICAgIHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQuYWNjb3VudHMuc29tZSgoYWNjb3VudCwgaWkpID0+IGFjY291bnQuYWRkcmVzcyAhPT0gYXV0aG9yaXphdGlvblJlc3VsdC5hY2NvdW50c1tpaV0uYWRkcmVzcyk7XG4gICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0ID0gYXV0aG9yaXphdGlvblJlc3VsdDtcbiAgICAgICAgICAgIHRoaXMuZGVjbGFyZVdhbGxldEFzSW5zdGFsbGVkKCk7XG4gICAgICAgICAgICBpZiAoZGlkUHVibGljS2V5c0NoYW5nZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRTZWxlY3RlZEFkZHJlc3MgPSB5aWVsZCB0aGlzLl9hZGRyZXNzU2VsZWN0b3Iuc2VsZWN0KGF1dGhvcml6YXRpb25SZXN1bHQuYWNjb3VudHMubWFwKCh7IGFkZHJlc3MgfSkgPT4gYWRkcmVzcykpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0U2VsZWN0ZWRBZGRyZXNzICE9PSB0aGlzLl9zZWxlY3RlZEFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VsZWN0ZWRBZGRyZXNzID0gbmV4dFNlbGVjdGVkQWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3B1YmxpY0tleTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0JywgXG4gICAgICAgICAgICAgICAgICAgIC8vIEhhdmluZyBqdXN0IHNldCBgdGhpcy5fc2VsZWN0ZWRBZGRyZXNzYCwgYHRoaXMucHVibGljS2V5YCBpcyBkZWZpbml0ZWx5IG5vbi1udWxsXG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHVibGljS2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwZXJmb3JtUmVhdXRob3JpemF0aW9uKHdhbGxldCwgYXV0aFRva2VuKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF1dGhvcml6YXRpb25SZXN1bHQgPSB5aWVsZCB3YWxsZXQuYXV0aG9yaXplKHtcbiAgICAgICAgICAgICAgICAgICAgYXV0aF90b2tlbjogYXV0aFRva2VuLFxuICAgICAgICAgICAgICAgICAgICBpZGVudGl0eTogdGhpcy5fYXBwSWRlbnRpdHksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogRXZhbHVhdGUgd2hldGhlciB0aGVyZSdzIGFueSB0aHJlYXQgdG8gbm90IGBhd2FpdGluZ2AgdGhpcyBleHByZXNzaW9uXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5hbGwoW1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUuc2V0KGF1dGhvcml6YXRpb25SZXN1bHQpLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUF1dGhvcml6YXRpb25SZXN1bHQoYXV0aG9yaXphdGlvblJlc3VsdCksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXREaXNjb25uZWN0ZWRFcnJvcigoZSBpbnN0YW5jZW9mIEVycm9yICYmIChlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUubWVzc2FnZSkpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdENhY2hlLmNsZWFyKCk7IC8vIFRPRE86IEV2YWx1YXRlIHdoZXRoZXIgdGhlcmUncyBhbnkgdGhyZWF0IHRvIG5vdCBgYXdhaXRpbmdgIHRoaXMgZXhwcmVzc2lvblxuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fY29ubmVjdGlvbkdlbmVyYXRpb24rKztcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0O1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3B1YmxpY0tleTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zZWxlY3RlZEFkZHJlc3M7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRyYW5zYWN0KGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHdhbGxldFVyaUJhc2UgPSAoX2EgPSB0aGlzLl9hdXRob3JpemF0aW9uUmVzdWx0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2FsbGV0X3VyaV9iYXNlO1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gd2FsbGV0VXJpQmFzZSA/IHsgYmFzZVVyaTogd2FsbGV0VXJpQmFzZSB9IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudENvbm5lY3Rpb25HZW5lcmF0aW9uID0gdGhpcy5fY29ubmVjdGlvbkdlbmVyYXRpb247XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0cmFuc2FjdChjYWxsYmFjaywgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2Nvbm5lY3Rpb25HZW5lcmF0aW9uICE9PSBjdXJyZW50Q29ubmVjdGlvbkdlbmVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgbmV3IFByb21pc2UoKCkgPT4geyB9KTsgLy8gTmV2ZXIgcmVzb2x2ZS5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICBlLm5hbWUgPT09ICdTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyRXJyb3InICYmXG4gICAgICAgICAgICAgICAgICAgIGUuY29kZSA9PT0gJ0VSUk9SX1dBTExFVF9OT1RfRk9VTkQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuX29uV2FsbGV0Tm90Rm91bmQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3NlcnRJc0F1dGhvcml6ZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fYXV0aG9yaXphdGlvblJlc3VsdCB8fCAhdGhpcy5fc2VsZWN0ZWRBZGRyZXNzKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhdXRoVG9rZW46IHRoaXMuX2F1dGhvcml6YXRpb25SZXN1bHQuYXV0aF90b2tlbixcbiAgICAgICAgICAgIHNlbGVjdGVkQWRkcmVzczogdGhpcy5fc2VsZWN0ZWRBZGRyZXNzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBwZXJmb3JtU2lnblRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXV0aFRva2VuIH0gPSB0aGlzLmFzc2VydElzQXV0aG9yaXplZCgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy50cmFuc2FjdCgod2FsbGV0KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGVyZm9ybVJlYXV0aG9yaXphdGlvbih3YWxsZXQsIGF1dGhUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9ucyA9IHlpZWxkIHdhbGxldC5zaWduVHJhbnNhY3Rpb25zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaWduZWRUcmFuc2FjdGlvbnM7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBhdXRoVG9rZW4gfSA9IHRoaXMuYXNzZXJ0SXNBdXRob3JpemVkKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbWluQ29udGV4dFNsb3QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWluQ29udGV4dFNsb3Q7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMudHJhbnNhY3QoKHdhbGxldCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gZ2V0VGFyZ2V0Q29tbWl0bWVudCgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0Q29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbm5lY3Rpb24uY29tbWl0bWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmaW5hbGl6ZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q29tbWl0bWVudCA9IGNvbm5lY3Rpb24uY29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Q29tbWl0bWVudCA9ICdmaW5hbGl6ZWQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbmZpcm1lZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbmFsaXplZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3Byb2Nlc3NlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRQcmVmbGlnaHRDb21taXRtZW50ID0gb3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudCA9IHRhcmdldENvbW1pdG1lbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFByZWZsaWdodENvbW1pdG1lbnQgPSAnZmluYWxpemVkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZmxpZ2h0Q29tbWl0bWVudFNjb3JlID0gdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudCA9PT0gJ2ZpbmFsaXplZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGFyZ2V0UHJlZmxpZ2h0Q29tbWl0bWVudCA9PT0gJ2NvbmZpcm1lZCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldENvbW1pdG1lbnRTY29yZSA9IHRhcmdldENvbW1pdG1lbnQgPT09ICdmaW5hbGl6ZWQnID8gMiA6IHRhcmdldENvbW1pdG1lbnQgPT09ICdjb25maXJtZWQnID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZWZsaWdodENvbW1pdG1lbnRTY29yZSA8IHRhcmdldENvbW1pdG1lbnRTY29yZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRhcmdldFByZWZsaWdodENvbW1pdG1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB0YXJnZXRDb21taXRtZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgW2NhcGFiaWxpdGllcywgXzEsIF8yXSA9IHlpZWxkIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWxsZXQuZ2V0Q2FwYWJpbGl0aWVzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wZXJmb3JtUmVhdXRob3JpemF0aW9uKHdhbGxldCwgYXV0aFRva2VuKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBVbmxpa2UgdmVyc2lvbmVkIHRyYW5zYWN0aW9ucywgbGVnYWN5IGBUcmFuc2FjdGlvbmAgb2JqZWN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIG1heSBub3QgaGF2ZSBhbiBhc3NvY2lhdGVkIGBmZWVQYXllcmAgb3IgYHJlY2VudEJsb2NraGFzaGAuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogVGhpcyBjb2RlIGV4aXN0cyB0byBwYXRjaCB0aGVtIHVwIGluIGNhc2UgdGhleSBhcmUgbWlzc2luZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uLmZlZVBheWVyIHx8ICh0cmFuc2FjdGlvbi5mZWVQYXllciA9IChfYSA9IHRoaXMucHVibGljS2V5KSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbi5yZWNlbnRCbG9ja2hhc2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IGJsb2NraGFzaCB9ID0geWllbGQgY29ubmVjdGlvbi5nZXRMYXRlc3RCbG9ja2hhc2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWl0bWVudDogZ2V0VGFyZ2V0Q29tbWl0bWVudCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID0gYmxvY2toYXNoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FwYWJpbGl0aWVzLnN1cHBvcnRzX3NpZ25fYW5kX3NlbmRfdHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlcyA9IHlpZWxkIHdhbGxldC5zaWduQW5kU2VuZFRyYW5zYWN0aW9ucyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkNvbnRleHRTbG90LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZXNbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbc2lnbmVkVHJhbnNhY3Rpb25dID0geWllbGQgd2FsbGV0LnNpZ25UcmFuc2FjdGlvbnMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbnM6IFt0cmFuc2FjdGlvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCBjb25uZWN0aW9uLnNlbmRUcmFuc2FjdGlvbihzaWduZWRUcmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSBzaWduZWRUcmFuc2FjdGlvbi5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIGNvbm5lY3Rpb24uc2VuZFJhd1RyYW5zYWN0aW9uKHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgeyBwcmVmbGlnaHRDb21taXRtZW50OiBnZXRUYXJnZXRDb21taXRtZW50KCkgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yKGVycm9yID09PSBudWxsIHx8IGVycm9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnJvci5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtzaWduZWRUcmFuc2FjdGlvbl0gPSB5aWVsZCB0aGlzLnBlcmZvcm1TaWduVHJhbnNhY3Rpb25zKFt0cmFuc2FjdGlvbl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBzaWduZWRUcmFuc2FjdGlvbjtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25BbGxUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5ydW5XaXRoR3VhcmQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9ucyA9IHlpZWxkIHRoaXMucGVyZm9ybVNpZ25UcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnbmVkVHJhbnNhY3Rpb25zO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucnVuV2l0aEd1YXJkKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGF1dGhUb2tlbiwgc2VsZWN0ZWRBZGRyZXNzIH0gPSB0aGlzLmFzc2VydElzQXV0aG9yaXplZCgpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnRyYW5zYWN0KCh3YWxsZXQpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMucGVyZm9ybVJlYXV0aG9yaXphdGlvbih3YWxsZXQsIGF1dGhUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBbc2lnbmVkTWVzc2FnZV0gPSB5aWVsZCB3YWxsZXQuc2lnbk1lc3NhZ2VzKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRyZXNzZXM6IFtzZWxlY3RlZEFkZHJlc3NdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWRzOiBbbWVzc2FnZV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHNpZ25lZE1lc3NhZ2Uuc2xpY2UoLVNJR05BVFVSRV9MRU5HVEhfSU5fQllURVMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpZ25hdHVyZTtcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNpZ25NZXNzYWdlRXJyb3IoZXJyb3IgPT09IG51bGwgfHwgZXJyb3IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yLm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaWduSW4oaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnJ1bldpdGhHdWFyZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQgJiYgdGhpcy5fcmVhZHlTdGF0ZSAhPT0gV2FsbGV0UmVhZHlTdGF0ZS5Mb2FkYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90UmVhZHlFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhdXRob3JpemF0aW9uUmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtQXV0aG9yaXphdGlvbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGlucHV0KSwgeyBkb21haW46IChfYSA9IGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbnB1dC5kb21haW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHdpbmRvdy5sb2NhdGlvbi5ob3N0IH0pKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFhdXRob3JpemF0aW9uUmVzdWx0LnNpZ25faW5fcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTaWduIGluIGZhaWxlZCwgbm8gc2lnbiBpbiByZXN1bHQgcmV0dXJuZWQgYnkgd2FsbGV0XCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25lZEluQWRkcmVzcyA9IGF1dGhvcml6YXRpb25SZXN1bHQuc2lnbl9pbl9yZXN1bHQuYWRkcmVzcztcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnbmVkSW5BY2NvdW50ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoX2IgPSBhdXRob3JpemF0aW9uUmVzdWx0LmFjY291bnRzLmZpbmQoYWNjID0+IGFjYy5hZGRyZXNzID09IHNpZ25lZEluQWRkcmVzcykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHNpZ25lZEluQWRkcmVzc1xuICAgICAgICAgICAgICAgICAgICB9KSwgeyBwdWJsaWNLZXk6IHRvVWludDhBcnJheShzaWduZWRJbkFkZHJlc3MpIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWNjb3VudDogc2lnbmVkSW5BY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmVkTWVzc2FnZTogdG9VaW50OEFycmF5KGF1dGhvcml6YXRpb25SZXN1bHQuc2lnbl9pbl9yZXN1bHQuc2lnbmVkX21lc3NhZ2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2lnbmF0dXJlOiB0b1VpbnQ4QXJyYXkoYXV0aG9yaXphdGlvblJlc3VsdC5zaWduX2luX3Jlc3VsdC5zaWduYXR1cmUpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25uZWN0aW9uRXJyb3IoKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm1lc3NhZ2UpIHx8ICdVbmtub3duIGVycm9yJywgZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRBZGRyZXNzU2VsZWN0b3IoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VsZWN0KGFkZHJlc3Nlcykge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWRkcmVzc2VzWzBdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuY29uc3QgQ0FDSEVfS0VZID0gJ1NvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJEZWZhdWx0QXV0aG9yaXphdGlvbkNhY2hlJztcbmZ1bmN0aW9uIGNyZWF0ZURlZmF1bHRBdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUoKSB7XG4gICAgbGV0IHN0b3JhZ2U7XG4gICAgdHJ5IHtcbiAgICAgICAgc3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgIH1cbiAgICBjYXRjaCAoX2EpIHsgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGNsZWFyKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnJlbW92ZUl0ZW0oQ0FDSEVfS0VZKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfYSkgeyB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzdG9yYWdlLmdldEl0ZW0oQ0FDSEVfS0VZKSkgfHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZW1wdHlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoYXV0aG9yaXphdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0b3JhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0oQ0FDSEVfS0VZLCBKU09OLnN0cmluZ2lmeShhdXRob3JpemF0aW9uUmVzdWx0KSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1lbXB0eVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFdhbGxldE5vdEZvdW5kSGFuZGxlcihtb2JpbGVXYWxsZXRBZGFwdGVyKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uYXNzaWduKG1vYmlsZVdhbGxldEFkYXB0ZXIudXJsKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRGVmYXVsdFdhbGxldE5vdEZvdW5kSGFuZGxlcigpIHtcbiAgICByZXR1cm4gZGVmYXVsdFdhbGxldE5vdEZvdW5kSGFuZGxlcjtcbn1cblxuZXhwb3J0IHsgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlciwgU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldE5hbWUsIGNyZWF0ZURlZmF1bHRBZGRyZXNzU2VsZWN0b3IsIGNyZWF0ZURlZmF1bHRBdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUsIGNyZWF0ZURlZmF1bHRXYWxsZXROb3RGb3VuZEhhbmRsZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseWalletAdapter: function() { return /* binding */ BaseWalletAdapter; },\n/* harmony export */   EventEmitter: function() { return /* reexport default export from named module */ eventemitter3__WEBPACK_IMPORTED_MODULE_0__; },\n/* harmony export */   WalletReadyState: function() { return /* binding */ WalletReadyState; },\n/* harmony export */   isIosAndRedirectable: function() { return /* binding */ isIosAndRedirectable; },\n/* harmony export */   scopePollingDetectionStrategy: function() { return /* binding */ scopePollingDetectionStrategy; }\n/* harmony export */ });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ \"(app-pages-browser)/./node_modules/eventemitter3/index.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n\n\n\n/**\n * A wallet's readiness describes a series of states that the wallet can be in,\n * depending on what kind of wallet it is. An installable wallet (eg. a browser\n * extension like Phantom) might be `Installed` if we've found the Phantom API\n * in the global scope, or `NotDetected` otherwise. A loadable, zero-install\n * runtime (eg. Torus Wallet) might simply signal that it's `Loadable`. Use this\n * metadata to personalize the wallet list for each user (eg. to show their\n * installed wallets first).\n */\nvar WalletReadyState;\n(function (WalletReadyState) {\n    /**\n     * User-installable wallets can typically be detected by scanning for an API\n     * that they've injected into the global context. If such an API is present,\n     * we consider the wallet to have been installed.\n     */\n    WalletReadyState[\"Installed\"] = \"Installed\";\n    WalletReadyState[\"NotDetected\"] = \"NotDetected\";\n    /**\n     * Loadable wallets are always available to you. Since you can load them at\n     * any time, it's meaningless to say that they have been detected.\n     */\n    WalletReadyState[\"Loadable\"] = \"Loadable\";\n    /**\n     * If a wallet is not supported on a given platform (eg. server-rendering, or\n     * mobile) then it will stay in the `Unsupported` state.\n     */\n    WalletReadyState[\"Unsupported\"] = \"Unsupported\";\n})(WalletReadyState || (WalletReadyState = {}));\nclass BaseWalletAdapter extends eventemitter3__WEBPACK_IMPORTED_MODULE_0__ {\n    get connected() {\n        return !!this.publicKey;\n    }\n    async autoConnect() {\n        await this.connect();\n    }\n    async prepareTransaction(transaction, connection, options = {}) {\n        const publicKey = this.publicKey;\n        if (!publicKey)\n            throw new _errors_js__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError();\n        transaction.feePayer = transaction.feePayer || publicKey;\n        transaction.recentBlockhash =\n            transaction.recentBlockhash ||\n                (await connection.getLatestBlockhash({\n                    commitment: options.preflightCommitment,\n                    minContextSlot: options.minContextSlot,\n                })).blockhash;\n        return transaction;\n    }\n}\nfunction scopePollingDetectionStrategy(detect) {\n    // Early return when server-side rendering\n    if (typeof window === 'undefined' || typeof document === 'undefined')\n        return;\n    const disposers = [];\n    function detectAndDispose() {\n        const detected = detect();\n        if (detected) {\n            for (const dispose of disposers) {\n                dispose();\n            }\n        }\n    }\n    // Strategy #1: Try detecting every second.\n    const interval = \n    // TODO: #334 Replace with idle callback strategy.\n    setInterval(detectAndDispose, 1000);\n    disposers.push(() => clearInterval(interval));\n    // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.\n    if (\n    // Implies that `DOMContentLoaded` has not yet fired.\n    document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', detectAndDispose, { once: true });\n        disposers.push(() => document.removeEventListener('DOMContentLoaded', detectAndDispose));\n    }\n    // Strategy #3: Detect after the `window` has fully loaded.\n    if (\n    // If the `complete` state has been reached, we're too late.\n    document.readyState !== 'complete') {\n        window.addEventListener('load', detectAndDispose, { once: true });\n        disposers.push(() => window.removeEventListener('load', detectAndDispose));\n    }\n    // Strategy #4: Detect synchronously, now.\n    detectAndDispose();\n}\n/**\n * Users on iOS can be redirected into a wallet's in-app browser automatically,\n * if that wallet has a universal link configured to do so\n * But should not be redirected from within a webview, eg. if they're already\n * inside a wallet's browser\n * This function can be used to identify users who are on iOS and can be redirected\n *\n * @returns true if the user can be redirected\n */\nfunction isIosAndRedirectable() {\n    // SSR: return false\n    if (!navigator)\n        return false;\n    const userAgent = navigator.userAgent.toLowerCase();\n    // if on iOS the user agent will contain either iPhone or iPad\n    // caveat: if requesting desktop site then this won't work\n    const isIos = userAgent.includes('iphone') || userAgent.includes('ipad');\n    // if in a webview then it will not include Safari\n    // note that other iOS browsers also include Safari\n    // so we will redirect only if Safari is also included\n    const isSafari = userAgent.includes('safari');\n    return isIos && isSafari;\n}\n//# sourceMappingURL=adapter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS9hZGFwdGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBeUM7QUFDYTtBQUM5QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDO0FBQ3RDLGdDQUFnQywwQ0FBWTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBLHNCQUFzQiwrREFBdUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFlBQVk7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFlBQVk7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vYWRhcHRlci5qcz9iOTJhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnZXZlbnRlbWl0dGVyMyc7XG5pbXBvcnQgeyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvciB9IGZyb20gJy4vZXJyb3JzLmpzJztcbmV4cG9ydCB7IEV2ZW50RW1pdHRlciB9O1xuLyoqXG4gKiBBIHdhbGxldCdzIHJlYWRpbmVzcyBkZXNjcmliZXMgYSBzZXJpZXMgb2Ygc3RhdGVzIHRoYXQgdGhlIHdhbGxldCBjYW4gYmUgaW4sXG4gKiBkZXBlbmRpbmcgb24gd2hhdCBraW5kIG9mIHdhbGxldCBpdCBpcy4gQW4gaW5zdGFsbGFibGUgd2FsbGV0IChlZy4gYSBicm93c2VyXG4gKiBleHRlbnNpb24gbGlrZSBQaGFudG9tKSBtaWdodCBiZSBgSW5zdGFsbGVkYCBpZiB3ZSd2ZSBmb3VuZCB0aGUgUGhhbnRvbSBBUElcbiAqIGluIHRoZSBnbG9iYWwgc2NvcGUsIG9yIGBOb3REZXRlY3RlZGAgb3RoZXJ3aXNlLiBBIGxvYWRhYmxlLCB6ZXJvLWluc3RhbGxcbiAqIHJ1bnRpbWUgKGVnLiBUb3J1cyBXYWxsZXQpIG1pZ2h0IHNpbXBseSBzaWduYWwgdGhhdCBpdCdzIGBMb2FkYWJsZWAuIFVzZSB0aGlzXG4gKiBtZXRhZGF0YSB0byBwZXJzb25hbGl6ZSB0aGUgd2FsbGV0IGxpc3QgZm9yIGVhY2ggdXNlciAoZWcuIHRvIHNob3cgdGhlaXJcbiAqIGluc3RhbGxlZCB3YWxsZXRzIGZpcnN0KS5cbiAqL1xuZXhwb3J0IHZhciBXYWxsZXRSZWFkeVN0YXRlO1xuKGZ1bmN0aW9uIChXYWxsZXRSZWFkeVN0YXRlKSB7XG4gICAgLyoqXG4gICAgICogVXNlci1pbnN0YWxsYWJsZSB3YWxsZXRzIGNhbiB0eXBpY2FsbHkgYmUgZGV0ZWN0ZWQgYnkgc2Nhbm5pbmcgZm9yIGFuIEFQSVxuICAgICAqIHRoYXQgdGhleSd2ZSBpbmplY3RlZCBpbnRvIHRoZSBnbG9iYWwgY29udGV4dC4gSWYgc3VjaCBhbiBBUEkgaXMgcHJlc2VudCxcbiAgICAgKiB3ZSBjb25zaWRlciB0aGUgd2FsbGV0IHRvIGhhdmUgYmVlbiBpbnN0YWxsZWQuXG4gICAgICovXG4gICAgV2FsbGV0UmVhZHlTdGF0ZVtcIkluc3RhbGxlZFwiXSA9IFwiSW5zdGFsbGVkXCI7XG4gICAgV2FsbGV0UmVhZHlTdGF0ZVtcIk5vdERldGVjdGVkXCJdID0gXCJOb3REZXRlY3RlZFwiO1xuICAgIC8qKlxuICAgICAqIExvYWRhYmxlIHdhbGxldHMgYXJlIGFsd2F5cyBhdmFpbGFibGUgdG8geW91LiBTaW5jZSB5b3UgY2FuIGxvYWQgdGhlbSBhdFxuICAgICAqIGFueSB0aW1lLCBpdCdzIG1lYW5pbmdsZXNzIHRvIHNheSB0aGF0IHRoZXkgaGF2ZSBiZWVuIGRldGVjdGVkLlxuICAgICAqL1xuICAgIFdhbGxldFJlYWR5U3RhdGVbXCJMb2FkYWJsZVwiXSA9IFwiTG9hZGFibGVcIjtcbiAgICAvKipcbiAgICAgKiBJZiBhIHdhbGxldCBpcyBub3Qgc3VwcG9ydGVkIG9uIGEgZ2l2ZW4gcGxhdGZvcm0gKGVnLiBzZXJ2ZXItcmVuZGVyaW5nLCBvclxuICAgICAqIG1vYmlsZSkgdGhlbiBpdCB3aWxsIHN0YXkgaW4gdGhlIGBVbnN1cHBvcnRlZGAgc3RhdGUuXG4gICAgICovXG4gICAgV2FsbGV0UmVhZHlTdGF0ZVtcIlVuc3VwcG9ydGVkXCJdID0gXCJVbnN1cHBvcnRlZFwiO1xufSkoV2FsbGV0UmVhZHlTdGF0ZSB8fCAoV2FsbGV0UmVhZHlTdGF0ZSA9IHt9KSk7XG5leHBvcnQgY2xhc3MgQmFzZVdhbGxldEFkYXB0ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAgIGdldCBjb25uZWN0ZWQoKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucHVibGljS2V5O1xuICAgIH1cbiAgICBhc3luYyBhdXRvQ29ubmVjdCgpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5jb25uZWN0KCk7XG4gICAgfVxuICAgIGFzeW5jIHByZXBhcmVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHB1YmxpY0tleSA9IHRoaXMucHVibGljS2V5O1xuICAgICAgICBpZiAoIXB1YmxpY0tleSlcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICB0cmFuc2FjdGlvbi5mZWVQYXllciA9IHRyYW5zYWN0aW9uLmZlZVBheWVyIHx8IHB1YmxpY0tleTtcbiAgICAgICAgdHJhbnNhY3Rpb24ucmVjZW50QmxvY2toYXNoID1cbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnJlY2VudEJsb2NraGFzaCB8fFxuICAgICAgICAgICAgICAgIChhd2FpdCBjb25uZWN0aW9uLmdldExhdGVzdEJsb2NraGFzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1pdG1lbnQ6IG9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCxcbiAgICAgICAgICAgICAgICAgICAgbWluQ29udGV4dFNsb3Q6IG9wdGlvbnMubWluQ29udGV4dFNsb3QsXG4gICAgICAgICAgICAgICAgfSkpLmJsb2NraGFzaDtcbiAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBzY29wZVBvbGxpbmdEZXRlY3Rpb25TdHJhdGVneShkZXRlY3QpIHtcbiAgICAvLyBFYXJseSByZXR1cm4gd2hlbiBzZXJ2ZXItc2lkZSByZW5kZXJpbmdcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGRpc3Bvc2VycyA9IFtdO1xuICAgIGZ1bmN0aW9uIGRldGVjdEFuZERpc3Bvc2UoKSB7XG4gICAgICAgIGNvbnN0IGRldGVjdGVkID0gZGV0ZWN0KCk7XG4gICAgICAgIGlmIChkZXRlY3RlZCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBkaXNwb3NlIG9mIGRpc3Bvc2Vycykge1xuICAgICAgICAgICAgICAgIGRpc3Bvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTdHJhdGVneSAjMTogVHJ5IGRldGVjdGluZyBldmVyeSBzZWNvbmQuXG4gICAgY29uc3QgaW50ZXJ2YWwgPSBcbiAgICAvLyBUT0RPOiAjMzM0IFJlcGxhY2Ugd2l0aCBpZGxlIGNhbGxiYWNrIHN0cmF0ZWd5LlxuICAgIHNldEludGVydmFsKGRldGVjdEFuZERpc3Bvc2UsIDEwMDApO1xuICAgIGRpc3Bvc2Vycy5wdXNoKCgpID0+IGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpKTtcbiAgICAvLyBTdHJhdGVneSAjMjogRGV0ZWN0IGFzIHNvb24gYXMgdGhlIERPTSBiZWNvbWVzICdyZWFkeScvJ2ludGVyYWN0aXZlJy5cbiAgICBpZiAoXG4gICAgLy8gSW1wbGllcyB0aGF0IGBET01Db250ZW50TG9hZGVkYCBoYXMgbm90IHlldCBmaXJlZC5cbiAgICBkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnbG9hZGluZycpIHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGRldGVjdEFuZERpc3Bvc2UsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgZGlzcG9zZXJzLnB1c2goKCkgPT4gZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGRldGVjdEFuZERpc3Bvc2UpKTtcbiAgICB9XG4gICAgLy8gU3RyYXRlZ3kgIzM6IERldGVjdCBhZnRlciB0aGUgYHdpbmRvd2AgaGFzIGZ1bGx5IGxvYWRlZC5cbiAgICBpZiAoXG4gICAgLy8gSWYgdGhlIGBjb21wbGV0ZWAgc3RhdGUgaGFzIGJlZW4gcmVhY2hlZCwgd2UncmUgdG9vIGxhdGUuXG4gICAgZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJykge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGRldGVjdEFuZERpc3Bvc2UsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgZGlzcG9zZXJzLnB1c2goKCkgPT4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBkZXRlY3RBbmREaXNwb3NlKSk7XG4gICAgfVxuICAgIC8vIFN0cmF0ZWd5ICM0OiBEZXRlY3Qgc3luY2hyb25vdXNseSwgbm93LlxuICAgIGRldGVjdEFuZERpc3Bvc2UoKTtcbn1cbi8qKlxuICogVXNlcnMgb24gaU9TIGNhbiBiZSByZWRpcmVjdGVkIGludG8gYSB3YWxsZXQncyBpbi1hcHAgYnJvd3NlciBhdXRvbWF0aWNhbGx5LFxuICogaWYgdGhhdCB3YWxsZXQgaGFzIGEgdW5pdmVyc2FsIGxpbmsgY29uZmlndXJlZCB0byBkbyBzb1xuICogQnV0IHNob3VsZCBub3QgYmUgcmVkaXJlY3RlZCBmcm9tIHdpdGhpbiBhIHdlYnZpZXcsIGVnLiBpZiB0aGV5J3JlIGFscmVhZHlcbiAqIGluc2lkZSBhIHdhbGxldCdzIGJyb3dzZXJcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgdXNlcnMgd2hvIGFyZSBvbiBpT1MgYW5kIGNhbiBiZSByZWRpcmVjdGVkXG4gKlxuICogQHJldHVybnMgdHJ1ZSBpZiB0aGUgdXNlciBjYW4gYmUgcmVkaXJlY3RlZFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJb3NBbmRSZWRpcmVjdGFibGUoKSB7XG4gICAgLy8gU1NSOiByZXR1cm4gZmFsc2VcbiAgICBpZiAoIW5hdmlnYXRvcilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IHVzZXJBZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAvLyBpZiBvbiBpT1MgdGhlIHVzZXIgYWdlbnQgd2lsbCBjb250YWluIGVpdGhlciBpUGhvbmUgb3IgaVBhZFxuICAgIC8vIGNhdmVhdDogaWYgcmVxdWVzdGluZyBkZXNrdG9wIHNpdGUgdGhlbiB0aGlzIHdvbid0IHdvcmtcbiAgICBjb25zdCBpc0lvcyA9IHVzZXJBZ2VudC5pbmNsdWRlcygnaXBob25lJykgfHwgdXNlckFnZW50LmluY2x1ZGVzKCdpcGFkJyk7XG4gICAgLy8gaWYgaW4gYSB3ZWJ2aWV3IHRoZW4gaXQgd2lsbCBub3QgaW5jbHVkZSBTYWZhcmlcbiAgICAvLyBub3RlIHRoYXQgb3RoZXIgaU9TIGJyb3dzZXJzIGFsc28gaW5jbHVkZSBTYWZhcmlcbiAgICAvLyBzbyB3ZSB3aWxsIHJlZGlyZWN0IG9ubHkgaWYgU2FmYXJpIGlzIGFsc28gaW5jbHVkZWRcbiAgICBjb25zdCBpc1NhZmFyaSA9IHVzZXJBZ2VudC5pbmNsdWRlcygnc2FmYXJpJyk7XG4gICAgcmV0dXJuIGlzSW9zICYmIGlzU2FmYXJpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRhcHRlci5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js":
/*!********************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletAccountError: function() { return /* binding */ WalletAccountError; },\n/* harmony export */   WalletConfigError: function() { return /* binding */ WalletConfigError; },\n/* harmony export */   WalletConnectionError: function() { return /* binding */ WalletConnectionError; },\n/* harmony export */   WalletDisconnectedError: function() { return /* binding */ WalletDisconnectedError; },\n/* harmony export */   WalletDisconnectionError: function() { return /* binding */ WalletDisconnectionError; },\n/* harmony export */   WalletError: function() { return /* binding */ WalletError; },\n/* harmony export */   WalletKeypairError: function() { return /* binding */ WalletKeypairError; },\n/* harmony export */   WalletLoadError: function() { return /* binding */ WalletLoadError; },\n/* harmony export */   WalletNotConnectedError: function() { return /* binding */ WalletNotConnectedError; },\n/* harmony export */   WalletNotReadyError: function() { return /* binding */ WalletNotReadyError; },\n/* harmony export */   WalletPublicKeyError: function() { return /* binding */ WalletPublicKeyError; },\n/* harmony export */   WalletSendTransactionError: function() { return /* binding */ WalletSendTransactionError; },\n/* harmony export */   WalletSignInError: function() { return /* binding */ WalletSignInError; },\n/* harmony export */   WalletSignMessageError: function() { return /* binding */ WalletSignMessageError; },\n/* harmony export */   WalletSignTransactionError: function() { return /* binding */ WalletSignTransactionError; },\n/* harmony export */   WalletTimeoutError: function() { return /* binding */ WalletTimeoutError; },\n/* harmony export */   WalletWindowBlockedError: function() { return /* binding */ WalletWindowBlockedError; },\n/* harmony export */   WalletWindowClosedError: function() { return /* binding */ WalletWindowClosedError; }\n/* harmony export */ });\nclass WalletError extends Error {\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    constructor(message, error) {\n        super(message);\n        this.error = error;\n    }\n}\nclass WalletNotReadyError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletNotReadyError';\n    }\n}\nclass WalletLoadError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletLoadError';\n    }\n}\nclass WalletConfigError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletConfigError';\n    }\n}\nclass WalletConnectionError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletConnectionError';\n    }\n}\nclass WalletDisconnectedError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletDisconnectedError';\n    }\n}\nclass WalletDisconnectionError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletDisconnectionError';\n    }\n}\nclass WalletAccountError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletAccountError';\n    }\n}\nclass WalletPublicKeyError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletPublicKeyError';\n    }\n}\nclass WalletKeypairError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletKeypairError';\n    }\n}\nclass WalletNotConnectedError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletNotConnectedError';\n    }\n}\nclass WalletSendTransactionError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletSendTransactionError';\n    }\n}\nclass WalletSignTransactionError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletSignTransactionError';\n    }\n}\nclass WalletSignMessageError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletSignMessageError';\n    }\n}\nclass WalletSignInError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletSignInError';\n    }\n}\nclass WalletTimeoutError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletTimeoutError';\n    }\n}\nclass WalletWindowBlockedError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletWindowBlockedError';\n    }\n}\nclass WalletWindowClosedError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletWindowClosedError';\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS9lcnJvcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vZXJyb3JzLmpzP2FmMTMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFdhbGxldEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvZXhwbGljaXQtbW9kdWxlLWJvdW5kYXJ5LXR5cGVzXG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZXJyb3IpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0Tm90UmVhZHlFcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldE5vdFJlYWR5RXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXRMb2FkRXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXRMb2FkRXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXRDb25maWdFcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldENvbmZpZ0Vycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0Q29ubmVjdGlvbkVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0Q29ubmVjdGlvbkVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0RGlzY29ubmVjdGVkRXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXREaXNjb25uZWN0ZWRFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldERpc2Nvbm5lY3Rpb25FcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldERpc2Nvbm5lY3Rpb25FcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldEFjY291bnRFcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldEFjY291bnRFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldFB1YmxpY0tleUVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0UHVibGljS2V5RXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXRLZXlwYWlyRXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXRLZXlwYWlyRXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldE5vdENvbm5lY3RlZEVycm9yJztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXRTZW5kVHJhbnNhY3Rpb25FcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0U2lnblRyYW5zYWN0aW9uRXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXRTaWduTWVzc2FnZUVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0U2lnbk1lc3NhZ2VFcnJvcic7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFdhbGxldFNpZ25JbkVycm9yIGV4dGVuZHMgV2FsbGV0RXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnV2FsbGV0U2lnbkluRXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXRUaW1lb3V0RXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXRUaW1lb3V0RXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXRXaW5kb3dCbG9ja2VkRXJyb3IgZXh0ZW5kcyBXYWxsZXRFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdXYWxsZXRXaW5kb3dCbG9ja2VkRXJyb3InO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXRXaW5kb3dDbG9zZWRFcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldFdpbmRvd0Nsb3NlZEVycm9yJztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/signer.js":
/*!********************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-base/lib/esm/signer.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseMessageSignerWalletAdapter: function() { return /* binding */ BaseMessageSignerWalletAdapter; },\n/* harmony export */   BaseSignInMessageSignerWalletAdapter: function() { return /* binding */ BaseSignInMessageSignerWalletAdapter; },\n/* harmony export */   BaseSignerWalletAdapter: function() { return /* binding */ BaseSignerWalletAdapter; }\n/* harmony export */ });\n/* harmony import */ var _adapter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./adapter.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _transaction_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transaction.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js\");\n\n\n\nclass BaseSignerWalletAdapter extends _adapter_js__WEBPACK_IMPORTED_MODULE_0__.BaseWalletAdapter {\n    async sendTransaction(transaction, connection, options = {}) {\n        let emit = true;\n        try {\n            if ((0,_transaction_js__WEBPACK_IMPORTED_MODULE_1__.isVersionedTransaction)(transaction)) {\n                if (!this.supportedTransactionVersions)\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(`Sending versioned transactions isn't supported by this wallet`);\n                if (!this.supportedTransactionVersions.has(transaction.version))\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(`Sending transaction version ${transaction.version} isn't supported by this wallet`);\n                try {\n                    transaction = await this.signTransaction(transaction);\n                    const rawTransaction = transaction.serialize();\n                    return await connection.sendRawTransaction(rawTransaction, options);\n                }\n                catch (error) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(error?.message, error);\n                }\n            }\n            else {\n                try {\n                    const { signers, ...sendOptions } = options;\n                    transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n                    signers?.length && transaction.partialSign(...signers);\n                    transaction = await this.signTransaction(transaction);\n                    const rawTransaction = transaction.serialize();\n                    return await connection.sendRawTransaction(rawTransaction, sendOptions);\n                }\n                catch (error) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSendTransactionError(error?.message, error);\n                }\n            }\n        }\n        catch (error) {\n            if (emit) {\n                this.emit('error', error);\n            }\n            throw error;\n        }\n    }\n    async signAllTransactions(transactions) {\n        for (const transaction of transactions) {\n            if ((0,_transaction_js__WEBPACK_IMPORTED_MODULE_1__.isVersionedTransaction)(transaction)) {\n                if (!this.supportedTransactionVersions)\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError(`Signing versioned transactions isn't supported by this wallet`);\n                if (!this.supportedTransactionVersions.has(transaction.version))\n                    throw new _errors_js__WEBPACK_IMPORTED_MODULE_2__.WalletSignTransactionError(`Signing transaction version ${transaction.version} isn't supported by this wallet`);\n            }\n        }\n        const signedTransactions = [];\n        for (const transaction of transactions) {\n            signedTransactions.push(await this.signTransaction(transaction));\n        }\n        return signedTransactions;\n    }\n}\nclass BaseMessageSignerWalletAdapter extends BaseSignerWalletAdapter {\n}\nclass BaseSignInMessageSignerWalletAdapter extends BaseMessageSignerWalletAdapter {\n}\n//# sourceMappingURL=signer.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS9zaWduZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWtEO0FBQ21DO0FBQzNCO0FBQ25ELHNDQUFzQywwREFBaUI7QUFDOUQsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQSxnQkFBZ0IsdUVBQXNCO0FBQ3RDO0FBQ0EsOEJBQThCLGtFQUEwQjtBQUN4RDtBQUNBLDhCQUE4QixrRUFBMEIsZ0NBQWdDLHFCQUFxQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrRUFBMEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtFQUEwQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwQkFBMEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrRUFBMEI7QUFDbkU7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtFQUEwQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsdUVBQXNCO0FBQ3RDO0FBQ0EsOEJBQThCLGtFQUEwQjtBQUN4RDtBQUNBLDhCQUE4QixrRUFBMEIsZ0NBQWdDLHFCQUFxQjtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS9zaWduZXIuanM/YWExOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCYXNlV2FsbGV0QWRhcHRlciwgfSBmcm9tICcuL2FkYXB0ZXIuanMnO1xuaW1wb3J0IHsgV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IsIFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yIH0gZnJvbSAnLi9lcnJvcnMuanMnO1xuaW1wb3J0IHsgaXNWZXJzaW9uZWRUcmFuc2FjdGlvbiB9IGZyb20gJy4vdHJhbnNhY3Rpb24uanMnO1xuZXhwb3J0IGNsYXNzIEJhc2VTaWduZXJXYWxsZXRBZGFwdGVyIGV4dGVuZHMgQmFzZVdhbGxldEFkYXB0ZXIge1xuICAgIGFzeW5jIHNlbmRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGxldCBlbWl0ID0gdHJ1ZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zKVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IoYFNlbmRpbmcgdmVyc2lvbmVkIHRyYW5zYWN0aW9ucyBpc24ndCBzdXBwb3J0ZWQgYnkgdGhpcyB3YWxsZXRgKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucy5oYXModHJhbnNhY3Rpb24udmVyc2lvbikpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTZW5kVHJhbnNhY3Rpb25FcnJvcihgU2VuZGluZyB0cmFuc2FjdGlvbiB2ZXJzaW9uICR7dHJhbnNhY3Rpb24udmVyc2lvbn0gaXNuJ3Qgc3VwcG9ydGVkIGJ5IHRoaXMgd2FsbGV0YCk7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd1RyYW5zYWN0aW9uID0gdHJhbnNhY3Rpb24uc2VyaWFsaXplKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCBjb25uZWN0aW9uLnNlbmRSYXdUcmFuc2FjdGlvbihyYXdUcmFuc2FjdGlvbiwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgZXJyb3Igd2FzIHRocm93biBieSBgc2lnblRyYW5zYWN0aW9uYCwgcmV0aHJvdyBpdCBhbmQgZG9uJ3QgZW1pdCBhIGR1cGxpY2F0ZSBldmVudFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZW1pdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yKGVycm9yPy5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzaWduZXJzLCAuLi5zZW5kT3B0aW9ucyB9ID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNhY3Rpb24gPSBhd2FpdCB0aGlzLnByZXBhcmVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwgc2VuZE9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBzaWduZXJzPy5sZW5ndGggJiYgdHJhbnNhY3Rpb24ucGFydGlhbFNpZ24oLi4uc2lnbmVycyk7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gYXdhaXQgdGhpcy5zaWduVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByYXdUcmFuc2FjdGlvbiA9IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24ocmF3VHJhbnNhY3Rpb24sIHNlbmRPcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBlcnJvciB3YXMgdGhyb3duIGJ5IGBzaWduVHJhbnNhY3Rpb25gLCByZXRocm93IGl0IGFuZCBkb24ndCBlbWl0IGEgZHVwbGljYXRlIGV2ZW50XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbWl0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2VuZFRyYW5zYWN0aW9uRXJyb3IoZXJyb3I/Lm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZW1pdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzaWduQWxsVHJhbnNhY3Rpb25zKHRyYW5zYWN0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IHRyYW5zYWN0aW9uIG9mIHRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgaWYgKGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnMpXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvcihgU2lnbmluZyB2ZXJzaW9uZWQgdHJhbnNhY3Rpb25zIGlzbid0IHN1cHBvcnRlZCBieSB0aGlzIHdhbGxldGApO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zLmhhcyh0cmFuc2FjdGlvbi52ZXJzaW9uKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yKGBTaWduaW5nIHRyYW5zYWN0aW9uIHZlcnNpb24gJHt0cmFuc2FjdGlvbi52ZXJzaW9ufSBpc24ndCBzdXBwb3J0ZWQgYnkgdGhpcyB3YWxsZXRgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0cmFuc2FjdGlvbiBvZiB0cmFuc2FjdGlvbnMpIHtcbiAgICAgICAgICAgIHNpZ25lZFRyYW5zYWN0aW9ucy5wdXNoKGF3YWl0IHRoaXMuc2lnblRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpZ25lZFRyYW5zYWN0aW9ucztcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQmFzZU1lc3NhZ2VTaWduZXJXYWxsZXRBZGFwdGVyIGV4dGVuZHMgQmFzZVNpZ25lcldhbGxldEFkYXB0ZXIge1xufVxuZXhwb3J0IGNsYXNzIEJhc2VTaWduSW5NZXNzYWdlU2lnbmVyV2FsbGV0QWRhcHRlciBleHRlbmRzIEJhc2VNZXNzYWdlU2lnbmVyV2FsbGV0QWRhcHRlciB7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/signer.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/standard.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-base/lib/esm/standard.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isWalletAdapterCompatibleStandardWallet: function() { return /* binding */ isWalletAdapterCompatibleStandardWallet; }\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(app-pages-browser)/./node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(app-pages-browser)/./node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @wallet-standard/features */ \"(app-pages-browser)/./node_modules/@wallet-standard/features/lib/esm/connect.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wallet-standard/features */ \"(app-pages-browser)/./node_modules/@wallet-standard/features/lib/esm/events.js\");\n\n\nfunction isWalletAdapterCompatibleStandardWallet(wallet) {\n    return (_wallet_standard_features__WEBPACK_IMPORTED_MODULE_0__.StandardConnect in wallet.features &&\n        _wallet_standard_features__WEBPACK_IMPORTED_MODULE_1__.StandardEvents in wallet.features &&\n        (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_2__.SolanaSignAndSendTransaction in wallet.features || _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_3__.SolanaSignTransaction in wallet.features));\n}\n//# sourceMappingURL=standard.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS9zdGFuZGFyZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF3RztBQUMzQjtBQUN0RTtBQUNQLFlBQVksc0VBQWU7QUFDM0IsUUFBUSxxRUFBYztBQUN0QixTQUFTLDBGQUE0Qix1QkFBdUIsbUZBQXFCO0FBQ2pGO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZS9saWIvZXNtL3N0YW5kYXJkLmpzP2ZhYjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU29sYW5hU2lnbkFuZFNlbmRUcmFuc2FjdGlvbiwgU29sYW5hU2lnblRyYW5zYWN0aW9uLCB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLWZlYXR1cmVzJztcbmltcG9ydCB7IFN0YW5kYXJkQ29ubmVjdCwgU3RhbmRhcmRFdmVudHMsIH0gZnJvbSAnQHdhbGxldC1zdGFuZGFyZC9mZWF0dXJlcyc7XG5leHBvcnQgZnVuY3Rpb24gaXNXYWxsZXRBZGFwdGVyQ29tcGF0aWJsZVN0YW5kYXJkV2FsbGV0KHdhbGxldCkge1xuICAgIHJldHVybiAoU3RhbmRhcmRDb25uZWN0IGluIHdhbGxldC5mZWF0dXJlcyAmJlxuICAgICAgICBTdGFuZGFyZEV2ZW50cyBpbiB3YWxsZXQuZmVhdHVyZXMgJiZcbiAgICAgICAgKFNvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24gaW4gd2FsbGV0LmZlYXR1cmVzIHx8IFNvbGFuYVNpZ25UcmFuc2FjdGlvbiBpbiB3YWxsZXQuZmVhdHVyZXMpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YW5kYXJkLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/standard.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isVersionedTransaction: function() { return /* binding */ isVersionedTransaction; }\n/* harmony export */ });\nfunction isVersionedTransaction(transaction) {\n    return 'version' in transaction;\n}\n//# sourceMappingURL=transaction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS90cmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZS9saWIvZXNtL3RyYW5zYWN0aW9uLmpzPzk4MjAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICByZXR1cm4gJ3ZlcnNpb24nIGluIHRyYW5zYWN0aW9uO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJhbnNhY3Rpb24uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/types.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-base/lib/esm/types.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletAdapterNetwork: function() { return /* binding */ WalletAdapterNetwork; }\n/* harmony export */ });\nvar WalletAdapterNetwork;\n(function (WalletAdapterNetwork) {\n    WalletAdapterNetwork[\"Mainnet\"] = \"mainnet-beta\";\n    WalletAdapterNetwork[\"Testnet\"] = \"testnet\";\n    WalletAdapterNetwork[\"Devnet\"] = \"devnet\";\n})(WalletAdapterNetwork || (WalletAdapterNetwork = {}));\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS90eXBlcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsb0RBQW9EO0FBQ3JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS90eXBlcy5qcz82MjAxIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB2YXIgV2FsbGV0QWRhcHRlck5ldHdvcms7XG4oZnVuY3Rpb24gKFdhbGxldEFkYXB0ZXJOZXR3b3JrKSB7XG4gICAgV2FsbGV0QWRhcHRlck5ldHdvcmtbXCJNYWlubmV0XCJdID0gXCJtYWlubmV0LWJldGFcIjtcbiAgICBXYWxsZXRBZGFwdGVyTmV0d29ya1tcIlRlc3RuZXRcIl0gPSBcInRlc3RuZXRcIjtcbiAgICBXYWxsZXRBZGFwdGVyTmV0d29ya1tcIkRldm5ldFwiXSA9IFwiZGV2bmV0XCI7XG59KShXYWxsZXRBZGFwdGVyTmV0d29yayB8fCAoV2FsbGV0QWRhcHRlck5ldHdvcmsgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/Button.js":
/*!************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react-ui/lib/esm/Button.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Button: function() { return /* binding */ Button; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nconst Button = (props) => {\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { className: `wallet-adapter-button ${props.className || ''}`, disabled: props.disabled, style: props.style, onClick: props.onClick, tabIndex: props.tabIndex || 0, type: \"button\" },\n        props.startIcon && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"i\", { className: \"wallet-adapter-button-start-icon\" }, props.startIcon),\n        props.children,\n        props.endIcon && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"i\", { className: \"wallet-adapter-button-end-icon\" }, props.endIcon)));\n};\n//# sourceMappingURL=Button.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0LXVpL2xpYi9lc20vQnV0dG9uLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBCO0FBQ25CO0FBQ1AsWUFBWSxnREFBbUIsYUFBYSxvQ0FBb0Msc0JBQXNCLHdIQUF3SDtBQUM5TiwyQkFBMkIsZ0RBQW1CLFFBQVEsK0NBQStDO0FBQ3JHO0FBQ0EseUJBQXlCLGdEQUFtQixRQUFRLDZDQUE2QztBQUNqRztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0LXVpL2xpYi9lc20vQnV0dG9uLmpzPzgyY2YiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBjb25zdCBCdXR0b24gPSAocHJvcHMpID0+IHtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiwgeyBjbGFzc05hbWU6IGB3YWxsZXQtYWRhcHRlci1idXR0b24gJHtwcm9wcy5jbGFzc05hbWUgfHwgJyd9YCwgZGlzYWJsZWQ6IHByb3BzLmRpc2FibGVkLCBzdHlsZTogcHJvcHMuc3R5bGUsIG9uQ2xpY2s6IHByb3BzLm9uQ2xpY2ssIHRhYkluZGV4OiBwcm9wcy50YWJJbmRleCB8fCAwLCB0eXBlOiBcImJ1dHRvblwiIH0sXG4gICAgICAgIHByb3BzLnN0YXJ0SWNvbiAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaVwiLCB7IGNsYXNzTmFtZTogXCJ3YWxsZXQtYWRhcHRlci1idXR0b24tc3RhcnQtaWNvblwiIH0sIHByb3BzLnN0YXJ0SWNvbiksXG4gICAgICAgIHByb3BzLmNoaWxkcmVuLFxuICAgICAgICBwcm9wcy5lbmRJY29uICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpXCIsIHsgY2xhc3NOYW1lOiBcIndhbGxldC1hZGFwdGVyLWJ1dHRvbi1lbmQtaWNvblwiIH0sIHByb3BzLmVuZEljb24pKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QnV0dG9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/Button.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/Collapse.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react-ui/lib/esm/Collapse.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Collapse: function() { return /* binding */ Collapse; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nconst Collapse = ({ id, children, expanded = false }) => {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const instant = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    const transition = 'height 250ms ease-out';\n    const openCollapse = () => {\n        const node = ref.current;\n        if (!node)\n            return;\n        requestAnimationFrame(() => {\n            node.style.height = node.scrollHeight + 'px';\n        });\n    };\n    const closeCollapse = () => {\n        const node = ref.current;\n        if (!node)\n            return;\n        requestAnimationFrame(() => {\n            node.style.height = node.offsetHeight + 'px';\n            node.style.overflow = 'hidden';\n            requestAnimationFrame(() => {\n                node.style.height = '0';\n            });\n        });\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n        if (expanded) {\n            openCollapse();\n        }\n        else {\n            closeCollapse();\n        }\n    }, [expanded]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n        const node = ref.current;\n        if (!node)\n            return;\n        function handleComplete() {\n            if (!node)\n                return;\n            node.style.overflow = expanded ? 'initial' : 'hidden';\n            if (expanded) {\n                node.style.height = 'auto';\n            }\n        }\n        function handleTransitionEnd(event) {\n            if (node && event.target === node && event.propertyName === 'height') {\n                handleComplete();\n            }\n        }\n        if (instant.current) {\n            handleComplete();\n            instant.current = false;\n        }\n        node.addEventListener('transitionend', handleTransitionEnd);\n        return () => node.removeEventListener('transitionend', handleTransitionEnd);\n    }, [expanded]);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"wallet-adapter-collapse\", id: id, ref: ref, role: \"region\", style: { height: 0, transition: instant.current ? undefined : transition } }, children));\n};\n//# sourceMappingURL=Collapse.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0LXVpL2xpYi9lc20vQ29sbGFwc2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUQ7QUFDaEQsb0JBQW9CLGdDQUFnQztBQUMzRCxnQkFBZ0IsNkNBQU07QUFDdEIsb0JBQW9CLDZDQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBLElBQUksc0RBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksc0RBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxnREFBbUIsVUFBVSxpRkFBaUYsbUVBQW1FO0FBQzdMO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QtdWkvbGliL2VzbS9Db2xsYXBzZS5qcz80NTE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VMYXlvdXRFZmZlY3QsIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBjb25zdCBDb2xsYXBzZSA9ICh7IGlkLCBjaGlsZHJlbiwgZXhwYW5kZWQgPSBmYWxzZSB9KSA9PiB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGluc3RhbnQgPSB1c2VSZWYodHJ1ZSk7XG4gICAgY29uc3QgdHJhbnNpdGlvbiA9ICdoZWlnaHQgMjUwbXMgZWFzZS1vdXQnO1xuICAgIGNvbnN0IG9wZW5Db2xsYXBzZSA9ICgpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9IG5vZGUuc2Nyb2xsSGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBjbG9zZUNvbGxhcHNlID0gKCkgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIG5vZGUuc3R5bGUuaGVpZ2h0ID0gbm9kZS5vZmZzZXRIZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9ICcwJztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChleHBhbmRlZCkge1xuICAgICAgICAgICAgb3BlbkNvbGxhcHNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbG9zZUNvbGxhcHNlKCk7XG4gICAgICAgIH1cbiAgICB9LCBbZXhwYW5kZWRdKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBub2RlID0gcmVmLmN1cnJlbnQ7XG4gICAgICAgIGlmICghbm9kZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlQ29tcGxldGUoKSB7XG4gICAgICAgICAgICBpZiAoIW5vZGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5vdmVyZmxvdyA9IGV4cGFuZGVkID8gJ2luaXRpYWwnIDogJ2hpZGRlbic7XG4gICAgICAgICAgICBpZiAoZXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVUcmFuc2l0aW9uRW5kKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAobm9kZSAmJiBldmVudC50YXJnZXQgPT09IG5vZGUgJiYgZXZlbnQucHJvcGVydHlOYW1lID09PSAnaGVpZ2h0Jykge1xuICAgICAgICAgICAgICAgIGhhbmRsZUNvbXBsZXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluc3RhbnQuY3VycmVudCkge1xuICAgICAgICAgICAgaGFuZGxlQ29tcGxldGUoKTtcbiAgICAgICAgICAgIGluc3RhbnQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcigndHJhbnNpdGlvbmVuZCcsIGhhbmRsZVRyYW5zaXRpb25FbmQpO1xuICAgICAgICByZXR1cm4gKCkgPT4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgaGFuZGxlVHJhbnNpdGlvbkVuZCk7XG4gICAgfSwgW2V4cGFuZGVkXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcIndhbGxldC1hZGFwdGVyLWNvbGxhcHNlXCIsIGlkOiBpZCwgcmVmOiByZWYsIHJvbGU6IFwicmVnaW9uXCIsIHN0eWxlOiB7IGhlaWdodDogMCwgdHJhbnNpdGlvbjogaW5zdGFudC5jdXJyZW50ID8gdW5kZWZpbmVkIDogdHJhbnNpdGlvbiB9IH0sIGNoaWxkcmVuKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29sbGFwc2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/Collapse.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletIcon.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletIcon.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletIcon: function() { return /* binding */ WalletIcon; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nconst WalletIcon = ({ wallet, ...props }) => {\n    return wallet && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"img\", { src: wallet.adapter.icon, alt: `${wallet.adapter.name} icon`, ...props });\n};\n//# sourceMappingURL=WalletIcon.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0LXVpL2xpYi9lc20vV2FsbGV0SWNvbi5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUEwQjtBQUNuQixzQkFBc0Isa0JBQWtCO0FBQy9DLHFCQUFxQixnREFBbUIsVUFBVSxrQ0FBa0MscUJBQXFCLGlCQUFpQjtBQUMxSDtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0LXVpL2xpYi9lc20vV2FsbGV0SWNvbi5qcz9iNThkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgY29uc3QgV2FsbGV0SWNvbiA9ICh7IHdhbGxldCwgLi4ucHJvcHMgfSkgPT4ge1xuICAgIHJldHVybiB3YWxsZXQgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChcImltZ1wiLCB7IHNyYzogd2FsbGV0LmFkYXB0ZXIuaWNvbiwgYWx0OiBgJHt3YWxsZXQuYWRhcHRlci5uYW1lfSBpY29uYCwgLi4ucHJvcHMgfSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2FsbGV0SWNvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletIcon.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletListItem.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletListItem.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletListItem: function() { return /* binding */ WalletListItem; }\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _Button_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Button.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/Button.js\");\n/* harmony import */ var _WalletIcon_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WalletIcon.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletIcon.js\");\n\n\n\n\nconst WalletListItem = ({ handleClick, tabIndex, wallet }) => {\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"li\", null,\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Button_js__WEBPACK_IMPORTED_MODULE_1__.Button, { onClick: handleClick, startIcon: react__WEBPACK_IMPORTED_MODULE_0__.createElement(_WalletIcon_js__WEBPACK_IMPORTED_MODULE_2__.WalletIcon, { wallet: wallet }), tabIndex: tabIndex },\n            wallet.adapter.name,\n            wallet.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletReadyState.Installed && react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null, \"Detected\"))));\n};\n//# sourceMappingURL=WalletListItem.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0LXVpL2xpYi9lc20vV2FsbGV0TGlzdEl0ZW0uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBK0Q7QUFDckM7QUFDVztBQUNRO0FBQ3RDLDBCQUEwQiwrQkFBK0I7QUFDaEUsWUFBWSxnREFBbUI7QUFDL0IsUUFBUSxnREFBbUIsQ0FBQyw4Q0FBTSxJQUFJLGlDQUFpQyxnREFBbUIsQ0FBQyxzREFBVSxJQUFJLGdCQUFnQix1QkFBdUI7QUFDaEo7QUFDQSxrQ0FBa0MseUVBQWdCLGNBQWMsZ0RBQW1CO0FBQ25GO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QtdWkvbGliL2VzbS9XYWxsZXRMaXN0SXRlbS5qcz81ZjdmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdhbGxldFJlYWR5U3RhdGUgfSBmcm9tICdAc29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEJ1dHRvbiB9IGZyb20gJy4vQnV0dG9uLmpzJztcbmltcG9ydCB7IFdhbGxldEljb24gfSBmcm9tICcuL1dhbGxldEljb24uanMnO1xuZXhwb3J0IGNvbnN0IFdhbGxldExpc3RJdGVtID0gKHsgaGFuZGxlQ2xpY2ssIHRhYkluZGV4LCB3YWxsZXQgfSkgPT4ge1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImxpXCIsIG51bGwsXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQnV0dG9uLCB7IG9uQ2xpY2s6IGhhbmRsZUNsaWNrLCBzdGFydEljb246IFJlYWN0LmNyZWF0ZUVsZW1lbnQoV2FsbGV0SWNvbiwgeyB3YWxsZXQ6IHdhbGxldCB9KSwgdGFiSW5kZXg6IHRhYkluZGV4IH0sXG4gICAgICAgICAgICB3YWxsZXQuYWRhcHRlci5uYW1lLFxuICAgICAgICAgICAgd2FsbGV0LnJlYWR5U3RhdGUgPT09IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkICYmIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIG51bGwsIFwiRGV0ZWN0ZWRcIikpKSk7XG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9V2FsbGV0TGlzdEl0ZW0uanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletListItem.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModal.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModal.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletModal: function() { return /* binding */ WalletModal; }\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-adapter-react */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-dom */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react-dom/index.js\");\n/* harmony import */ var _Collapse_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Collapse.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/Collapse.js\");\n/* harmony import */ var _WalletListItem_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./WalletListItem.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletListItem.js\");\n/* harmony import */ var _WalletSVG_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./WalletSVG.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletSVG.js\");\n/* harmony import */ var _useWalletModal_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useWalletModal.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/useWalletModal.js\");\n\n\n\n\n\n\n\n\nconst WalletModal = ({ className = '', container = 'body' }) => {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n    const { wallets, select } = (0,_solana_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_2__.useWallet)();\n    const { setVisible } = (0,_useWalletModal_js__WEBPACK_IMPORTED_MODULE_3__.useWalletModal)();\n    const [expanded, setExpanded] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [fadeIn, setFadeIn] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [portal, setPortal] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n    const [listedWallets, collapsedWallets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => {\n        const installed = [];\n        const notInstalled = [];\n        for (const wallet of wallets) {\n            if (wallet.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_4__.WalletReadyState.Installed) {\n                installed.push(wallet);\n            }\n            else {\n                notInstalled.push(wallet);\n            }\n        }\n        return installed.length ? [installed, notInstalled] : [notInstalled, []];\n    }, [wallets]);\n    const hideModal = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n        setFadeIn(false);\n        setTimeout(() => setVisible(false), 150);\n    }, [setVisible]);\n    const handleClose = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\n        event.preventDefault();\n        hideModal();\n    }, [hideModal]);\n    const handleWalletClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event, walletName) => {\n        select(walletName);\n        handleClose(event);\n    }, [select, handleClose]);\n    const handleCollapseClick = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => setExpanded(!expanded), [expanded]);\n    const handleTabKey = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((event) => {\n        const node = ref.current;\n        if (!node)\n            return;\n        // here we query all focusable elements\n        const focusableElements = node.querySelectorAll('button');\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const firstElement = focusableElements[0];\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const lastElement = focusableElements[focusableElements.length - 1];\n        if (event.shiftKey) {\n            // if going backward by pressing tab and firstElement is active, shift focus to last focusable element\n            if (document.activeElement === firstElement) {\n                lastElement.focus();\n                event.preventDefault();\n            }\n        }\n        else {\n            // if going forward by pressing tab and lastElement is active, shift focus to first focusable element\n            if (document.activeElement === lastElement) {\n                firstElement.focus();\n                event.preventDefault();\n            }\n        }\n    }, [ref]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => {\n        const handleKeyDown = (event) => {\n            if (event.key === 'Escape') {\n                hideModal();\n            }\n            else if (event.key === 'Tab') {\n                handleTabKey(event);\n            }\n        };\n        // Get original overflow\n        const { overflow } = window.getComputedStyle(document.body);\n        // Hack to enable fade in animation after mount\n        setTimeout(() => setFadeIn(true), 0);\n        // Prevent scrolling on mount\n        document.body.style.overflow = 'hidden';\n        // Listen for keydown events\n        window.addEventListener('keydown', handleKeyDown, false);\n        return () => {\n            // Re-enable scrolling when component unmounts\n            document.body.style.overflow = overflow;\n            window.removeEventListener('keydown', handleKeyDown, false);\n        };\n    }, [hideModal, handleTabKey]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect)(() => setPortal(document.querySelector(container)), [container]);\n    return (portal &&\n        (0,react_dom__WEBPACK_IMPORTED_MODULE_1__.createPortal)(react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { \"aria-labelledby\": \"wallet-adapter-modal-title\", \"aria-modal\": \"true\", className: `wallet-adapter-modal ${fadeIn && 'wallet-adapter-modal-fade-in'} ${className}`, ref: ref, role: \"dialog\" },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"wallet-adapter-modal-container\" },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"wallet-adapter-modal-wrapper\" },\n                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { onClick: handleClose, className: \"wallet-adapter-modal-button-close\" },\n                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { width: \"14\", height: \"14\" },\n                            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M14 12.461 8.3 6.772l5.234-5.233L12.006 0 6.772 5.234 1.54 0 0 1.539l5.234 5.233L0 12.006l1.539 1.528L6.772 8.3l5.69 5.7L14 12.461z\" }))),\n                    listedWallets.length ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h1\", { className: \"wallet-adapter-modal-title\" }, \"Connect a wallet on Solana to continue\"),\n                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"ul\", { className: \"wallet-adapter-modal-list\" },\n                            listedWallets.map((wallet) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_WalletListItem_js__WEBPACK_IMPORTED_MODULE_5__.WalletListItem, { key: wallet.adapter.name, handleClick: (event) => handleWalletClick(event, wallet.adapter.name), wallet: wallet }))),\n                            collapsedWallets.length ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Collapse_js__WEBPACK_IMPORTED_MODULE_6__.Collapse, { expanded: expanded, id: \"wallet-adapter-modal-collapse\" }, collapsedWallets.map((wallet) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_WalletListItem_js__WEBPACK_IMPORTED_MODULE_5__.WalletListItem, { key: wallet.adapter.name, handleClick: (event) => handleWalletClick(event, wallet.adapter.name), tabIndex: expanded ? 0 : -1, wallet: wallet }))))) : null),\n                        collapsedWallets.length ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { className: \"wallet-adapter-modal-list-more\", onClick: handleCollapseClick, tabIndex: 0 },\n                            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null,\n                                expanded ? 'Less ' : 'More ',\n                                \"options\"),\n                            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { width: \"13\", height: \"7\", viewBox: \"0 0 13 7\", xmlns: \"http://www.w3.org/2000/svg\", className: `${expanded ? 'wallet-adapter-modal-list-more-icon-rotate' : ''}` },\n                                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0.71418 1.626L5.83323 6.26188C5.91574 6.33657 6.0181 6.39652 6.13327 6.43762C6.24844 6.47872 6.37371 6.5 6.50048 6.5C6.62725 6.5 6.75252 6.47872 6.8677 6.43762C6.98287 6.39652 7.08523 6.33657 7.16774 6.26188L12.2868 1.626C12.7753 1.1835 12.3703 0.5 11.6195 0.5H1.37997C0.629216 0.5 0.224175 1.1835 0.71418 1.626Z\" })))) : null)) : (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"h1\", { className: \"wallet-adapter-modal-title\" }, \"You'll need a wallet on Solana to continue\"),\n                        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"wallet-adapter-modal-middle\" },\n                            react__WEBPACK_IMPORTED_MODULE_0__.createElement(_WalletSVG_js__WEBPACK_IMPORTED_MODULE_7__.WalletSVG, null)),\n                        collapsedWallets.length ? (react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null,\n                            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"button\", { className: \"wallet-adapter-modal-list-more\", onClick: handleCollapseClick, tabIndex: 0 },\n                                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"span\", null,\n                                    expanded ? 'Hide ' : 'Already have a wallet? View ',\n                                    \"options\"),\n                                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { width: \"13\", height: \"7\", viewBox: \"0 0 13 7\", xmlns: \"http://www.w3.org/2000/svg\", className: `${expanded ? 'wallet-adapter-modal-list-more-icon-rotate' : ''}` },\n                                    react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M0.71418 1.626L5.83323 6.26188C5.91574 6.33657 6.0181 6.39652 6.13327 6.43762C6.24844 6.47872 6.37371 6.5 6.50048 6.5C6.62725 6.5 6.75252 6.47872 6.8677 6.43762C6.98287 6.39652 7.08523 6.33657 7.16774 6.26188L12.2868 1.626C12.7753 1.1835 12.3703 0.5 11.6195 0.5H1.37997C0.629216 0.5 0.224175 1.1835 0.71418 1.626Z\" }))),\n                            react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Collapse_js__WEBPACK_IMPORTED_MODULE_6__.Collapse, { expanded: expanded, id: \"wallet-adapter-modal-collapse\" },\n                                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"ul\", { className: \"wallet-adapter-modal-list\" }, collapsedWallets.map((wallet) => (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_WalletListItem_js__WEBPACK_IMPORTED_MODULE_5__.WalletListItem, { key: wallet.adapter.name, handleClick: (event) => handleWalletClick(event, wallet.adapter.name), tabIndex: expanded ? 0 : -1, wallet: wallet }))))))) : null)))),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"div\", { className: \"wallet-adapter-modal-overlay\", onMouseDown: handleClose })), portal));\n};\n//# sourceMappingURL=WalletModal.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0LXVpL2xpYi9lc20vV2FsbGV0TW9kYWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQStEO0FBQ047QUFDOEI7QUFDOUM7QUFDQTtBQUNZO0FBQ1Y7QUFDVTtBQUM5Qyx1QkFBdUIsb0NBQW9DO0FBQ2xFLGdCQUFnQiw2Q0FBTTtBQUN0QixZQUFZLGtCQUFrQixFQUFFLHVFQUFTO0FBQ3pDLFlBQVksYUFBYSxFQUFFLGtFQUFjO0FBQ3pDLG9DQUFvQywrQ0FBUTtBQUM1QyxnQ0FBZ0MsK0NBQVE7QUFDeEMsZ0NBQWdDLCtDQUFRO0FBQ3hDLDhDQUE4Qyw4Q0FBTztBQUNyRDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MseUVBQWdCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHNCQUFzQixrREFBVztBQUNqQztBQUNBO0FBQ0EsS0FBSztBQUNMLHdCQUF3QixrREFBVztBQUNuQztBQUNBO0FBQ0EsS0FBSztBQUNMLDhCQUE4QixrREFBVztBQUN6QztBQUNBO0FBQ0EsS0FBSztBQUNMLGdDQUFnQyxrREFBVztBQUMzQyx5QkFBeUIsa0RBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLHNEQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSxzREFBZTtBQUNuQjtBQUNBLFFBQVEsdURBQVksQ0FBQyxnREFBbUIsVUFBVSwwR0FBMEcsMENBQTBDLEVBQUUsVUFBVSw2QkFBNkI7QUFDL08sWUFBWSxnREFBbUIsVUFBVSw2Q0FBNkM7QUFDdEYsZ0JBQWdCLGdEQUFtQixVQUFVLDJDQUEyQztBQUN4RixvQkFBb0IsZ0RBQW1CLGFBQWEsc0VBQXNFO0FBQzFILHdCQUF3QixnREFBbUIsVUFBVSwyQkFBMkI7QUFDaEYsNEJBQTRCLGdEQUFtQixXQUFXLDBJQUEwSTtBQUNwTSw0Q0FBNEMsZ0RBQW1CLENBQUMsMkNBQWM7QUFDOUUsd0JBQXdCLGdEQUFtQixTQUFTLHlDQUF5QztBQUM3Rix3QkFBd0IsZ0RBQW1CLFNBQVMsd0NBQXdDO0FBQzVGLDJEQUEyRCxnREFBbUIsQ0FBQyw4REFBYyxJQUFJLGlIQUFpSDtBQUNsTix1REFBdUQsZ0RBQW1CLENBQUMsa0RBQVEsSUFBSSx5REFBeUQsb0NBQW9DLGdEQUFtQixDQUFDLDhEQUFjLElBQUksOElBQThJO0FBQ3hXLG1EQUFtRCxnREFBbUIsYUFBYSx3RkFBd0Y7QUFDM0ssNEJBQTRCLGdEQUFtQjtBQUMvQztBQUNBO0FBQ0EsNEJBQTRCLGdEQUFtQixVQUFVLGtHQUFrRyw2REFBNkQsR0FBRztBQUMzTixnQ0FBZ0MsZ0RBQW1CLFdBQVcsZ1VBQWdVLGlCQUFpQixnREFBbUIsQ0FBQywyQ0FBYztBQUNqYix3QkFBd0IsZ0RBQW1CLFNBQVMseUNBQXlDO0FBQzdGLHdCQUF3QixnREFBbUIsVUFBVSwwQ0FBMEM7QUFDL0YsNEJBQTRCLGdEQUFtQixDQUFDLG9EQUFTO0FBQ3pELG1EQUFtRCxnREFBbUIsQ0FBQywyQ0FBYztBQUNyRiw0QkFBNEIsZ0RBQW1CLGFBQWEsd0ZBQXdGO0FBQ3BKLGdDQUFnQyxnREFBbUI7QUFDbkQ7QUFDQTtBQUNBLGdDQUFnQyxnREFBbUIsVUFBVSxrR0FBa0csNkRBQTZELEdBQUc7QUFDL04sb0NBQW9DLGdEQUFtQixXQUFXLGdVQUFnVTtBQUNsWSw0QkFBNEIsZ0RBQW1CLENBQUMsa0RBQVEsSUFBSSx5REFBeUQ7QUFDckgsZ0NBQWdDLGdEQUFtQixTQUFTLHdDQUF3QyxvQ0FBb0MsZ0RBQW1CLENBQUMsOERBQWMsSUFBSSw4SUFBOEk7QUFDNVQsWUFBWSxnREFBbUIsVUFBVSxxRUFBcUU7QUFDOUc7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC11aS9saWIvZXNtL1dhbGxldE1vZGFsLmpzPzgxZTAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgV2FsbGV0UmVhZHlTdGF0ZSB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZSc7XG5pbXBvcnQgeyB1c2VXYWxsZXQgfSBmcm9tICdAc29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0JztcbmltcG9ydCBSZWFjdCwgeyB1c2VDYWxsYmFjaywgdXNlTGF5b3V0RWZmZWN0LCB1c2VNZW1vLCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAncmVhY3QtZG9tJztcbmltcG9ydCB7IENvbGxhcHNlIH0gZnJvbSAnLi9Db2xsYXBzZS5qcyc7XG5pbXBvcnQgeyBXYWxsZXRMaXN0SXRlbSB9IGZyb20gJy4vV2FsbGV0TGlzdEl0ZW0uanMnO1xuaW1wb3J0IHsgV2FsbGV0U1ZHIH0gZnJvbSAnLi9XYWxsZXRTVkcuanMnO1xuaW1wb3J0IHsgdXNlV2FsbGV0TW9kYWwgfSBmcm9tICcuL3VzZVdhbGxldE1vZGFsLmpzJztcbmV4cG9ydCBjb25zdCBXYWxsZXRNb2RhbCA9ICh7IGNsYXNzTmFtZSA9ICcnLCBjb250YWluZXIgPSAnYm9keScgfSkgPT4ge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCB7IHdhbGxldHMsIHNlbGVjdCB9ID0gdXNlV2FsbGV0KCk7XG4gICAgY29uc3QgeyBzZXRWaXNpYmxlIH0gPSB1c2VXYWxsZXRNb2RhbCgpO1xuICAgIGNvbnN0IFtleHBhbmRlZCwgc2V0RXhwYW5kZWRdID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IFtmYWRlSW4sIHNldEZhZGVJbl0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgW3BvcnRhbCwgc2V0UG9ydGFsXSA9IHVzZVN0YXRlKG51bGwpO1xuICAgIGNvbnN0IFtsaXN0ZWRXYWxsZXRzLCBjb2xsYXBzZWRXYWxsZXRzXSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBpbnN0YWxsZWQgPSBbXTtcbiAgICAgICAgY29uc3Qgbm90SW5zdGFsbGVkID0gW107XG4gICAgICAgIGZvciAoY29uc3Qgd2FsbGV0IG9mIHdhbGxldHMpIHtcbiAgICAgICAgICAgIGlmICh3YWxsZXQucmVhZHlTdGF0ZSA9PT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQpIHtcbiAgICAgICAgICAgICAgICBpbnN0YWxsZWQucHVzaCh3YWxsZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm90SW5zdGFsbGVkLnB1c2god2FsbGV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaW5zdGFsbGVkLmxlbmd0aCA/IFtpbnN0YWxsZWQsIG5vdEluc3RhbGxlZF0gOiBbbm90SW5zdGFsbGVkLCBbXV07XG4gICAgfSwgW3dhbGxldHNdKTtcbiAgICBjb25zdCBoaWRlTW9kYWwgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHNldEZhZGVJbihmYWxzZSk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gc2V0VmlzaWJsZShmYWxzZSksIDE1MCk7XG4gICAgfSwgW3NldFZpc2libGVdKTtcbiAgICBjb25zdCBoYW5kbGVDbG9zZSA9IHVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBoaWRlTW9kYWwoKTtcbiAgICB9LCBbaGlkZU1vZGFsXSk7XG4gICAgY29uc3QgaGFuZGxlV2FsbGV0Q2xpY2sgPSB1c2VDYWxsYmFjaygoZXZlbnQsIHdhbGxldE5hbWUpID0+IHtcbiAgICAgICAgc2VsZWN0KHdhbGxldE5hbWUpO1xuICAgICAgICBoYW5kbGVDbG9zZShldmVudCk7XG4gICAgfSwgW3NlbGVjdCwgaGFuZGxlQ2xvc2VdKTtcbiAgICBjb25zdCBoYW5kbGVDb2xsYXBzZUNsaWNrID0gdXNlQ2FsbGJhY2soKCkgPT4gc2V0RXhwYW5kZWQoIWV4cGFuZGVkKSwgW2V4cGFuZGVkXSk7XG4gICAgY29uc3QgaGFuZGxlVGFiS2V5ID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSByZWYuY3VycmVudDtcbiAgICAgICAgaWYgKCFub2RlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBoZXJlIHdlIHF1ZXJ5IGFsbCBmb2N1c2FibGUgZWxlbWVudHNcbiAgICAgICAgY29uc3QgZm9jdXNhYmxlRWxlbWVudHMgPSBub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2J1dHRvbicpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBjb25zdCBmaXJzdEVsZW1lbnQgPSBmb2N1c2FibGVFbGVtZW50c1swXTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgY29uc3QgbGFzdEVsZW1lbnQgPSBmb2N1c2FibGVFbGVtZW50c1tmb2N1c2FibGVFbGVtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAvLyBpZiBnb2luZyBiYWNrd2FyZCBieSBwcmVzc2luZyB0YWIgYW5kIGZpcnN0RWxlbWVudCBpcyBhY3RpdmUsIHNoaWZ0IGZvY3VzIHRvIGxhc3QgZm9jdXNhYmxlIGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSBmaXJzdEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBsYXN0RWxlbWVudC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiBnb2luZyBmb3J3YXJkIGJ5IHByZXNzaW5nIHRhYiBhbmQgbGFzdEVsZW1lbnQgaXMgYWN0aXZlLCBzaGlmdCBmb2N1cyB0byBmaXJzdCBmb2N1c2FibGUgZWxlbWVudFxuICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGxhc3RFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgZmlyc3RFbGVtZW50LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtyZWZdKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgIGhpZGVNb2RhbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5ID09PSAnVGFiJykge1xuICAgICAgICAgICAgICAgIGhhbmRsZVRhYktleShldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIEdldCBvcmlnaW5hbCBvdmVyZmxvd1xuICAgICAgICBjb25zdCB7IG92ZXJmbG93IH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KTtcbiAgICAgICAgLy8gSGFjayB0byBlbmFibGUgZmFkZSBpbiBhbmltYXRpb24gYWZ0ZXIgbW91bnRcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzZXRGYWRlSW4odHJ1ZSksIDApO1xuICAgICAgICAvLyBQcmV2ZW50IHNjcm9sbGluZyBvbiBtb3VudFxuICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gJ2hpZGRlbic7XG4gICAgICAgIC8vIExpc3RlbiBmb3Iga2V5ZG93biBldmVudHNcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duLCBmYWxzZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAvLyBSZS1lbmFibGUgc2Nyb2xsaW5nIHdoZW4gY29tcG9uZW50IHVubW91bnRzXG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnN0eWxlLm92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24sIGZhbHNlKTtcbiAgICAgICAgfTtcbiAgICB9LCBbaGlkZU1vZGFsLCBoYW5kbGVUYWJLZXldKTtcbiAgICB1c2VMYXlvdXRFZmZlY3QoKCkgPT4gc2V0UG9ydGFsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoY29udGFpbmVyKSksIFtjb250YWluZXJdKTtcbiAgICByZXR1cm4gKHBvcnRhbCAmJlxuICAgICAgICBjcmVhdGVQb3J0YWwoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IFwiYXJpYS1sYWJlbGxlZGJ5XCI6IFwid2FsbGV0LWFkYXB0ZXItbW9kYWwtdGl0bGVcIiwgXCJhcmlhLW1vZGFsXCI6IFwidHJ1ZVwiLCBjbGFzc05hbWU6IGB3YWxsZXQtYWRhcHRlci1tb2RhbCAke2ZhZGVJbiAmJiAnd2FsbGV0LWFkYXB0ZXItbW9kYWwtZmFkZS1pbid9ICR7Y2xhc3NOYW1lfWAsIHJlZjogcmVmLCByb2xlOiBcImRpYWxvZ1wiIH0sXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcIndhbGxldC1hZGFwdGVyLW1vZGFsLWNvbnRhaW5lclwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJ3YWxsZXQtYWRhcHRlci1tb2RhbC13cmFwcGVyXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IG9uQ2xpY2s6IGhhbmRsZUNsb3NlLCBjbGFzc05hbWU6IFwid2FsbGV0LWFkYXB0ZXItbW9kYWwtYnV0dG9uLWNsb3NlXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB3aWR0aDogXCIxNFwiLCBoZWlnaHQ6IFwiMTRcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNMTQgMTIuNDYxIDguMyA2Ljc3Mmw1LjIzNC01LjIzM0wxMi4wMDYgMCA2Ljc3MiA1LjIzNCAxLjU0IDAgMCAxLjUzOWw1LjIzNCA1LjIzM0wwIDEyLjAwNmwxLjUzOSAxLjUyOEw2Ljc3MiA4LjNsNS42OSA1LjdMMTQgMTIuNDYxelwiIH0pKSksXG4gICAgICAgICAgICAgICAgICAgIGxpc3RlZFdhbGxldHMubGVuZ3RoID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDFcIiwgeyBjbGFzc05hbWU6IFwid2FsbGV0LWFkYXB0ZXItbW9kYWwtdGl0bGVcIiB9LCBcIkNvbm5lY3QgYSB3YWxsZXQgb24gU29sYW5hIHRvIGNvbnRpbnVlXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInVsXCIsIHsgY2xhc3NOYW1lOiBcIndhbGxldC1hZGFwdGVyLW1vZGFsLWxpc3RcIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlZFdhbGxldHMubWFwKCh3YWxsZXQpID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFdhbGxldExpc3RJdGVtLCB7IGtleTogd2FsbGV0LmFkYXB0ZXIubmFtZSwgaGFuZGxlQ2xpY2s6IChldmVudCkgPT4gaGFuZGxlV2FsbGV0Q2xpY2soZXZlbnQsIHdhbGxldC5hZGFwdGVyLm5hbWUpLCB3YWxsZXQ6IHdhbGxldCB9KSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxhcHNlZFdhbGxldHMubGVuZ3RoID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29sbGFwc2UsIHsgZXhwYW5kZWQ6IGV4cGFuZGVkLCBpZDogXCJ3YWxsZXQtYWRhcHRlci1tb2RhbC1jb2xsYXBzZVwiIH0sIGNvbGxhcHNlZFdhbGxldHMubWFwKCh3YWxsZXQpID0+IChSZWFjdC5jcmVhdGVFbGVtZW50KFdhbGxldExpc3RJdGVtLCB7IGtleTogd2FsbGV0LmFkYXB0ZXIubmFtZSwgaGFuZGxlQ2xpY2s6IChldmVudCkgPT4gaGFuZGxlV2FsbGV0Q2xpY2soZXZlbnQsIHdhbGxldC5hZGFwdGVyLm5hbWUpLCB0YWJJbmRleDogZXhwYW5kZWQgPyAwIDogLTEsIHdhbGxldDogd2FsbGV0IH0pKSkpKSA6IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkV2FsbGV0cy5sZW5ndGggPyAoUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB7IGNsYXNzTmFtZTogXCJ3YWxsZXQtYWRhcHRlci1tb2RhbC1saXN0LW1vcmVcIiwgb25DbGljazogaGFuZGxlQ29sbGFwc2VDbGljaywgdGFiSW5kZXg6IDAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRlZCA/ICdMZXNzICcgOiAnTW9yZSAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIm9wdGlvbnNcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN2Z1wiLCB7IHdpZHRoOiBcIjEzXCIsIGhlaWdodDogXCI3XCIsIHZpZXdCb3g6IFwiMCAwIDEzIDdcIiwgeG1sbnM6IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiwgY2xhc3NOYW1lOiBgJHtleHBhbmRlZCA/ICd3YWxsZXQtYWRhcHRlci1tb2RhbC1saXN0LW1vcmUtaWNvbi1yb3RhdGUnIDogJyd9YCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTAuNzE0MTggMS42MjZMNS44MzMyMyA2LjI2MTg4QzUuOTE1NzQgNi4zMzY1NyA2LjAxODEgNi4zOTY1MiA2LjEzMzI3IDYuNDM3NjJDNi4yNDg0NCA2LjQ3ODcyIDYuMzczNzEgNi41IDYuNTAwNDggNi41QzYuNjI3MjUgNi41IDYuNzUyNTIgNi40Nzg3MiA2Ljg2NzcgNi40Mzc2MkM2Ljk4Mjg3IDYuMzk2NTIgNy4wODUyMyA2LjMzNjU3IDcuMTY3NzQgNi4yNjE4OEwxMi4yODY4IDEuNjI2QzEyLjc3NTMgMS4xODM1IDEyLjM3MDMgMC41IDExLjYxOTUgMC41SDEuMzc5OTdDMC42MjkyMTYgMC41IDAuMjI0MTc1IDEuMTgzNSAwLjcxNDE4IDEuNjI2WlwiIH0pKSkpIDogbnVsbCkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiaDFcIiwgeyBjbGFzc05hbWU6IFwid2FsbGV0LWFkYXB0ZXItbW9kYWwtdGl0bGVcIiB9LCBcIllvdSdsbCBuZWVkIGEgd2FsbGV0IG9uIFNvbGFuYSB0byBjb250aW51ZVwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwid2FsbGV0LWFkYXB0ZXItbW9kYWwtbWlkZGxlXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFdhbGxldFNWRywgbnVsbCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGFwc2VkV2FsbGV0cy5sZW5ndGggPyAoUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIsIHsgY2xhc3NOYW1lOiBcIndhbGxldC1hZGFwdGVyLW1vZGFsLWxpc3QtbW9yZVwiLCBvbkNsaWNrOiBoYW5kbGVDb2xsYXBzZUNsaWNrLCB0YWJJbmRleDogMCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhwYW5kZWQgPyAnSGlkZSAnIDogJ0FscmVhZHkgaGF2ZSBhIHdhbGxldD8gVmlldyAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJvcHRpb25zXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3ZnXCIsIHsgd2lkdGg6IFwiMTNcIiwgaGVpZ2h0OiBcIjdcIiwgdmlld0JveDogXCIwIDAgMTMgN1wiLCB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCBjbGFzc05hbWU6IGAke2V4cGFuZGVkID8gJ3dhbGxldC1hZGFwdGVyLW1vZGFsLWxpc3QtbW9yZS1pY29uLXJvdGF0ZScgOiAnJ31gIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwicGF0aFwiLCB7IGQ6IFwiTTAuNzE0MTggMS42MjZMNS44MzMyMyA2LjI2MTg4QzUuOTE1NzQgNi4zMzY1NyA2LjAxODEgNi4zOTY1MiA2LjEzMzI3IDYuNDM3NjJDNi4yNDg0NCA2LjQ3ODcyIDYuMzczNzEgNi41IDYuNTAwNDggNi41QzYuNjI3MjUgNi41IDYuNzUyNTIgNi40Nzg3MiA2Ljg2NzcgNi40Mzc2MkM2Ljk4Mjg3IDYuMzk2NTIgNy4wODUyMyA2LjMzNjU3IDcuMTY3NzQgNi4yNjE4OEwxMi4yODY4IDEuNjI2QzEyLjc3NTMgMS4xODM1IDEyLjM3MDMgMC41IDExLjYxOTUgMC41SDEuMzc5OTdDMC42MjkyMTYgMC41IDAuMjI0MTc1IDEuMTgzNSAwLjcxNDE4IDEuNjI2WlwiIH0pKSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb2xsYXBzZSwgeyBleHBhbmRlZDogZXhwYW5kZWQsIGlkOiBcIndhbGxldC1hZGFwdGVyLW1vZGFsLWNvbGxhcHNlXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInVsXCIsIHsgY2xhc3NOYW1lOiBcIndhbGxldC1hZGFwdGVyLW1vZGFsLWxpc3RcIiB9LCBjb2xsYXBzZWRXYWxsZXRzLm1hcCgod2FsbGV0KSA9PiAoUmVhY3QuY3JlYXRlRWxlbWVudChXYWxsZXRMaXN0SXRlbSwgeyBrZXk6IHdhbGxldC5hZGFwdGVyLm5hbWUsIGhhbmRsZUNsaWNrOiAoZXZlbnQpID0+IGhhbmRsZVdhbGxldENsaWNrKGV2ZW50LCB3YWxsZXQuYWRhcHRlci5uYW1lKSwgdGFiSW5kZXg6IGV4cGFuZGVkID8gMCA6IC0xLCB3YWxsZXQ6IHdhbGxldCB9KSkpKSkpKSA6IG51bGwpKSkpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJ3YWxsZXQtYWRhcHRlci1tb2RhbC1vdmVybGF5XCIsIG9uTW91c2VEb3duOiBoYW5kbGVDbG9zZSB9KSksIHBvcnRhbCkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdhbGxldE1vZGFsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModal.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModalProvider.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModalProvider.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletModalProvider: function() { return /* binding */ WalletModalProvider; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _useWalletModal_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./useWalletModal.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/useWalletModal.js\");\n/* harmony import */ var _WalletModal_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./WalletModal.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModal.js\");\n\n\n\nconst WalletModalProvider = ({ children, ...props }) => {\n    const [visible, setVisible] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_useWalletModal_js__WEBPACK_IMPORTED_MODULE_1__.WalletModalContext.Provider, { value: {\n            visible,\n            setVisible,\n        } },\n        children,\n        visible && react__WEBPACK_IMPORTED_MODULE_0__.createElement(_WalletModal_js__WEBPACK_IMPORTED_MODULE_2__.WalletModal, { ...props })));\n};\n//# sourceMappingURL=WalletModalProvider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0LXVpL2xpYi9lc20vV2FsbGV0TW9kYWxQcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdDO0FBQ2lCO0FBQ1Y7QUFDeEMsK0JBQStCLG9CQUFvQjtBQUMxRCxrQ0FBa0MsK0NBQVE7QUFDMUMsWUFBWSxnREFBbUIsQ0FBQyxrRUFBa0IsYUFBYTtBQUMvRDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsbUJBQW1CLGdEQUFtQixDQUFDLHdEQUFXLElBQUksVUFBVTtBQUNoRTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0LXVpL2xpYi9lc20vV2FsbGV0TW9kYWxQcm92aWRlci5qcz9iYTgwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFdhbGxldE1vZGFsQ29udGV4dCB9IGZyb20gJy4vdXNlV2FsbGV0TW9kYWwuanMnO1xuaW1wb3J0IHsgV2FsbGV0TW9kYWwgfSBmcm9tICcuL1dhbGxldE1vZGFsLmpzJztcbmV4cG9ydCBjb25zdCBXYWxsZXRNb2RhbFByb3ZpZGVyID0gKHsgY2hpbGRyZW4sIC4uLnByb3BzIH0pID0+IHtcbiAgICBjb25zdCBbdmlzaWJsZSwgc2V0VmlzaWJsZV0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFdhbGxldE1vZGFsQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZToge1xuICAgICAgICAgICAgdmlzaWJsZSxcbiAgICAgICAgICAgIHNldFZpc2libGUsXG4gICAgICAgIH0gfSxcbiAgICAgICAgY2hpbGRyZW4sXG4gICAgICAgIHZpc2libGUgJiYgUmVhY3QuY3JlYXRlRWxlbWVudChXYWxsZXRNb2RhbCwgeyAuLi5wcm9wcyB9KSkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdhbGxldE1vZGFsUHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletModalProvider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletSVG.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletSVG.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletSVG: function() { return /* binding */ WalletSVG; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nconst WalletSVG = () => {\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"svg\", { width: \"97\", height: \"96\", viewBox: \"0 0 97 96\", fill: \"none\", xmlns: \"http://www.w3.org/2000/svg\" },\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", { cx: \"48.5\", cy: \"48\", r: \"48\", fill: \"url(#paint0_linear_880_5115)\", fillOpacity: \"0.1\" }),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"circle\", { cx: \"48.5\", cy: \"48\", r: \"47\", stroke: \"url(#paint1_linear_880_5115)\", strokeOpacity: \"0.4\", strokeWidth: \"2\" }),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"g\", { clipPath: \"url(#clip0_880_5115)\" },\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M65.5769 28.1523H31.4231C27.6057 28.1523 24.5 31.258 24.5 35.0754V60.9215C24.5 64.7389 27.6057 67.8446 31.4231 67.8446H65.5769C69.3943 67.8446 72.5 64.7389 72.5 60.9215V35.0754C72.5 31.258 69.3943 28.1523 65.5769 28.1523ZM69.7308 52.1523H59.5769C57.2865 52.1523 55.4231 50.289 55.4231 47.9985C55.4231 45.708 57.2864 43.8446 59.5769 43.8446H69.7308V52.1523ZM69.7308 41.0754H59.5769C55.7595 41.0754 52.6539 44.1811 52.6539 47.9985C52.6539 51.8159 55.7595 54.9215 59.5769 54.9215H69.7308V60.9215C69.7308 63.2119 67.8674 65.0754 65.5769 65.0754H31.4231C29.1327 65.0754 27.2692 63.212 27.2692 60.9215V35.0754C27.2692 32.785 29.1326 30.9215 31.4231 30.9215H65.5769C67.8673 30.9215 69.7308 32.7849 69.7308 35.0754V41.0754Z\", fill: \"url(#paint2_linear_880_5115)\" }),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"path\", { d: \"M61.4231 46.6172H59.577C58.8123 46.6172 58.1924 47.2371 58.1924 48.0018C58.1924 48.7665 58.8123 49.3863 59.577 49.3863H61.4231C62.1878 49.3863 62.8077 48.7664 62.8077 48.0018C62.8077 47.2371 62.1878 46.6172 61.4231 46.6172Z\", fill: \"url(#paint3_linear_880_5115)\" })),\n        react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"defs\", null,\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"linearGradient\", { id: \"paint0_linear_880_5115\", x1: \"3.41664\", y1: \"98.0933\", x2: \"103.05\", y2: \"8.42498\", gradientUnits: \"userSpaceOnUse\" },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { stopColor: \"#9945FF\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"0.14\", stopColor: \"#8A53F4\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"0.42\", stopColor: \"#6377D6\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"0.79\", stopColor: \"#24B0A7\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"0.99\", stopColor: \"#00D18C\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"1\", stopColor: \"#00D18C\" })),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"linearGradient\", { id: \"paint1_linear_880_5115\", x1: \"3.41664\", y1: \"98.0933\", x2: \"103.05\", y2: \"8.42498\", gradientUnits: \"userSpaceOnUse\" },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { stopColor: \"#9945FF\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"0.14\", stopColor: \"#8A53F4\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"0.42\", stopColor: \"#6377D6\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"0.79\", stopColor: \"#24B0A7\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"0.99\", stopColor: \"#00D18C\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"1\", stopColor: \"#00D18C\" })),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"linearGradient\", { id: \"paint2_linear_880_5115\", x1: \"25.9583\", y1: \"68.7101\", x2: \"67.2337\", y2: \"23.7879\", gradientUnits: \"userSpaceOnUse\" },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { stopColor: \"#9945FF\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"0.14\", stopColor: \"#8A53F4\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"0.42\", stopColor: \"#6377D6\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"0.79\", stopColor: \"#24B0A7\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"0.99\", stopColor: \"#00D18C\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"1\", stopColor: \"#00D18C\" })),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"linearGradient\", { id: \"paint3_linear_880_5115\", x1: \"58.3326\", y1: \"49.4467\", x2: \"61.0002\", y2: \"45.4453\", gradientUnits: \"userSpaceOnUse\" },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { stopColor: \"#9945FF\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"0.14\", stopColor: \"#8A53F4\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"0.42\", stopColor: \"#6377D6\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"0.79\", stopColor: \"#24B0A7\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"0.99\", stopColor: \"#00D18C\" }),\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"stop\", { offset: \"1\", stopColor: \"#00D18C\" })),\n            react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"clipPath\", { id: \"clip0_880_5115\" },\n                react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"rect\", { width: \"48\", height: \"48\", fill: \"white\", transform: \"translate(24.5 24)\" })))));\n};\n//# sourceMappingURL=WalletSVG.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0LXVpL2xpYi9lc20vV2FsbGV0U1ZHLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBCO0FBQ25CO0FBQ1AsWUFBWSxnREFBbUIsVUFBVSxvR0FBb0c7QUFDN0ksUUFBUSxnREFBbUIsYUFBYSx5RkFBeUY7QUFDakksUUFBUSxnREFBbUIsYUFBYSwrR0FBK0c7QUFDdkosUUFBUSxnREFBbUIsUUFBUSxrQ0FBa0M7QUFDckUsWUFBWSxnREFBbUIsV0FBVyx3dkJBQXd2QjtBQUNseUIsWUFBWSxnREFBbUIsV0FBVyw0UUFBNFE7QUFDdFQsUUFBUSxnREFBbUI7QUFDM0IsWUFBWSxnREFBbUIscUJBQXFCLDBIQUEwSDtBQUM5SyxnQkFBZ0IsZ0RBQW1CLFdBQVcsc0JBQXNCO0FBQ3BFLGdCQUFnQixnREFBbUIsV0FBVyxzQ0FBc0M7QUFDcEYsZ0JBQWdCLGdEQUFtQixXQUFXLHNDQUFzQztBQUNwRixnQkFBZ0IsZ0RBQW1CLFdBQVcsc0NBQXNDO0FBQ3BGLGdCQUFnQixnREFBbUIsV0FBVyxzQ0FBc0M7QUFDcEYsZ0JBQWdCLGdEQUFtQixXQUFXLG1DQUFtQztBQUNqRixZQUFZLGdEQUFtQixxQkFBcUIsMEhBQTBIO0FBQzlLLGdCQUFnQixnREFBbUIsV0FBVyxzQkFBc0I7QUFDcEUsZ0JBQWdCLGdEQUFtQixXQUFXLHNDQUFzQztBQUNwRixnQkFBZ0IsZ0RBQW1CLFdBQVcsc0NBQXNDO0FBQ3BGLGdCQUFnQixnREFBbUIsV0FBVyxzQ0FBc0M7QUFDcEYsZ0JBQWdCLGdEQUFtQixXQUFXLHNDQUFzQztBQUNwRixnQkFBZ0IsZ0RBQW1CLFdBQVcsbUNBQW1DO0FBQ2pGLFlBQVksZ0RBQW1CLHFCQUFxQiwySEFBMkg7QUFDL0ssZ0JBQWdCLGdEQUFtQixXQUFXLHNCQUFzQjtBQUNwRSxnQkFBZ0IsZ0RBQW1CLFdBQVcsc0NBQXNDO0FBQ3BGLGdCQUFnQixnREFBbUIsV0FBVyxzQ0FBc0M7QUFDcEYsZ0JBQWdCLGdEQUFtQixXQUFXLHNDQUFzQztBQUNwRixnQkFBZ0IsZ0RBQW1CLFdBQVcsc0NBQXNDO0FBQ3BGLGdCQUFnQixnREFBbUIsV0FBVyxtQ0FBbUM7QUFDakYsWUFBWSxnREFBbUIscUJBQXFCLDJIQUEySDtBQUMvSyxnQkFBZ0IsZ0RBQW1CLFdBQVcsc0JBQXNCO0FBQ3BFLGdCQUFnQixnREFBbUIsV0FBVyxzQ0FBc0M7QUFDcEYsZ0JBQWdCLGdEQUFtQixXQUFXLHNDQUFzQztBQUNwRixnQkFBZ0IsZ0RBQW1CLFdBQVcsc0NBQXNDO0FBQ3BGLGdCQUFnQixnREFBbUIsV0FBVyxzQ0FBc0M7QUFDcEYsZ0JBQWdCLGdEQUFtQixXQUFXLG1DQUFtQztBQUNqRixZQUFZLGdEQUFtQixlQUFlLHNCQUFzQjtBQUNwRSxnQkFBZ0IsZ0RBQW1CLFdBQVcsMkVBQTJFO0FBQ3pIO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QtdWkvbGliL2VzbS9XYWxsZXRTVkcuanM/NTY1MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuZXhwb3J0IGNvbnN0IFdhbGxldFNWRyA9ICgpID0+IHtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdmdcIiwgeyB3aWR0aDogXCI5N1wiLCBoZWlnaHQ6IFwiOTZcIiwgdmlld0JveDogXCIwIDAgOTcgOTZcIiwgZmlsbDogXCJub25lXCIsIHhtbG5zOiBcImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgfSxcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImNpcmNsZVwiLCB7IGN4OiBcIjQ4LjVcIiwgY3k6IFwiNDhcIiwgcjogXCI0OFwiLCBmaWxsOiBcInVybCgjcGFpbnQwX2xpbmVhcl84ODBfNTExNSlcIiwgZmlsbE9wYWNpdHk6IFwiMC4xXCIgfSksXG4gICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJjaXJjbGVcIiwgeyBjeDogXCI0OC41XCIsIGN5OiBcIjQ4XCIsIHI6IFwiNDdcIiwgc3Ryb2tlOiBcInVybCgjcGFpbnQxX2xpbmVhcl84ODBfNTExNSlcIiwgc3Ryb2tlT3BhY2l0eTogXCIwLjRcIiwgc3Ryb2tlV2lkdGg6IFwiMlwiIH0pLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZ1wiLCB7IGNsaXBQYXRoOiBcInVybCgjY2xpcDBfODgwXzUxMTUpXCIgfSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwYXRoXCIsIHsgZDogXCJNNjUuNTc2OSAyOC4xNTIzSDMxLjQyMzFDMjcuNjA1NyAyOC4xNTIzIDI0LjUgMzEuMjU4IDI0LjUgMzUuMDc1NFY2MC45MjE1QzI0LjUgNjQuNzM4OSAyNy42MDU3IDY3Ljg0NDYgMzEuNDIzMSA2Ny44NDQ2SDY1LjU3NjlDNjkuMzk0MyA2Ny44NDQ2IDcyLjUgNjQuNzM4OSA3Mi41IDYwLjkyMTVWMzUuMDc1NEM3Mi41IDMxLjI1OCA2OS4zOTQzIDI4LjE1MjMgNjUuNTc2OSAyOC4xNTIzWk02OS43MzA4IDUyLjE1MjNINTkuNTc2OUM1Ny4yODY1IDUyLjE1MjMgNTUuNDIzMSA1MC4yODkgNTUuNDIzMSA0Ny45OTg1QzU1LjQyMzEgNDUuNzA4IDU3LjI4NjQgNDMuODQ0NiA1OS41NzY5IDQzLjg0NDZINjkuNzMwOFY1Mi4xNTIzWk02OS43MzA4IDQxLjA3NTRINTkuNTc2OUM1NS43NTk1IDQxLjA3NTQgNTIuNjUzOSA0NC4xODExIDUyLjY1MzkgNDcuOTk4NUM1Mi42NTM5IDUxLjgxNTkgNTUuNzU5NSA1NC45MjE1IDU5LjU3NjkgNTQuOTIxNUg2OS43MzA4VjYwLjkyMTVDNjkuNzMwOCA2My4yMTE5IDY3Ljg2NzQgNjUuMDc1NCA2NS41NzY5IDY1LjA3NTRIMzEuNDIzMUMyOS4xMzI3IDY1LjA3NTQgMjcuMjY5MiA2My4yMTIgMjcuMjY5MiA2MC45MjE1VjM1LjA3NTRDMjcuMjY5MiAzMi43ODUgMjkuMTMyNiAzMC45MjE1IDMxLjQyMzEgMzAuOTIxNUg2NS41NzY5QzY3Ljg2NzMgMzAuOTIxNSA2OS43MzA4IDMyLjc4NDkgNjkuNzMwOCAzNS4wNzU0VjQxLjA3NTRaXCIsIGZpbGw6IFwidXJsKCNwYWludDJfbGluZWFyXzg4MF81MTE1KVwiIH0pLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInBhdGhcIiwgeyBkOiBcIk02MS40MjMxIDQ2LjYxNzJINTkuNTc3QzU4LjgxMjMgNDYuNjE3MiA1OC4xOTI0IDQ3LjIzNzEgNTguMTkyNCA0OC4wMDE4QzU4LjE5MjQgNDguNzY2NSA1OC44MTIzIDQ5LjM4NjMgNTkuNTc3IDQ5LjM4NjNINjEuNDIzMUM2Mi4xODc4IDQ5LjM4NjMgNjIuODA3NyA0OC43NjY0IDYyLjgwNzcgNDguMDAxOEM2Mi44MDc3IDQ3LjIzNzEgNjIuMTg3OCA0Ni42MTcyIDYxLjQyMzEgNDYuNjE3MlpcIiwgZmlsbDogXCJ1cmwoI3BhaW50M19saW5lYXJfODgwXzUxMTUpXCIgfSkpLFxuICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGVmc1wiLCBudWxsLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVhckdyYWRpZW50XCIsIHsgaWQ6IFwicGFpbnQwX2xpbmVhcl84ODBfNTExNVwiLCB4MTogXCIzLjQxNjY0XCIsIHkxOiBcIjk4LjA5MzNcIiwgeDI6IFwiMTAzLjA1XCIsIHkyOiBcIjguNDI0OThcIiwgZ3JhZGllbnRVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBzdG9wQ29sb3I6IFwiIzk5NDVGRlwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjAuMTRcIiwgc3RvcENvbG9yOiBcIiM4QTUzRjRcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIwLjQyXCIsIHN0b3BDb2xvcjogXCIjNjM3N0Q2XCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMC43OVwiLCBzdG9wQ29sb3I6IFwiIzI0QjBBN1wiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjAuOTlcIiwgc3RvcENvbG9yOiBcIiMwMEQxOENcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIxXCIsIHN0b3BDb2xvcjogXCIjMDBEMThDXCIgfSkpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVhckdyYWRpZW50XCIsIHsgaWQ6IFwicGFpbnQxX2xpbmVhcl84ODBfNTExNVwiLCB4MTogXCIzLjQxNjY0XCIsIHkxOiBcIjk4LjA5MzNcIiwgeDI6IFwiMTAzLjA1XCIsIHkyOiBcIjguNDI0OThcIiwgZ3JhZGllbnRVbml0czogXCJ1c2VyU3BhY2VPblVzZVwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBzdG9wQ29sb3I6IFwiIzk5NDVGRlwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjAuMTRcIiwgc3RvcENvbG9yOiBcIiM4QTUzRjRcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIwLjQyXCIsIHN0b3BDb2xvcjogXCIjNjM3N0Q2XCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMC43OVwiLCBzdG9wQ29sb3I6IFwiIzI0QjBBN1wiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjAuOTlcIiwgc3RvcENvbG9yOiBcIiMwMEQxOENcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIxXCIsIHN0b3BDb2xvcjogXCIjMDBEMThDXCIgfSkpLFxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcImxpbmVhckdyYWRpZW50XCIsIHsgaWQ6IFwicGFpbnQyX2xpbmVhcl84ODBfNTExNVwiLCB4MTogXCIyNS45NTgzXCIsIHkxOiBcIjY4LjcxMDFcIiwgeDI6IFwiNjcuMjMzN1wiLCB5MjogXCIyMy43ODc5XCIsIGdyYWRpZW50VW5pdHM6IFwidXNlclNwYWNlT25Vc2VcIiB9LFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgc3RvcENvbG9yOiBcIiM5OTQ1RkZcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIwLjE0XCIsIHN0b3BDb2xvcjogXCIjOEE1M0Y0XCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMC40MlwiLCBzdG9wQ29sb3I6IFwiIzYzNzdENlwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjAuNzlcIiwgc3RvcENvbG9yOiBcIiMyNEIwQTdcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIwLjk5XCIsIHN0b3BDb2xvcjogXCIjMDBEMThDXCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMVwiLCBzdG9wQ29sb3I6IFwiIzAwRDE4Q1wiIH0pKSxcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaW5lYXJHcmFkaWVudFwiLCB7IGlkOiBcInBhaW50M19saW5lYXJfODgwXzUxMTVcIiwgeDE6IFwiNTguMzMyNlwiLCB5MTogXCI0OS40NDY3XCIsIHgyOiBcIjYxLjAwMDJcIiwgeTI6IFwiNDUuNDQ1M1wiLCBncmFkaWVudFVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCIgfSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IHN0b3BDb2xvcjogXCIjOTk0NUZGXCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMC4xNFwiLCBzdG9wQ29sb3I6IFwiIzhBNTNGNFwiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjAuNDJcIiwgc3RvcENvbG9yOiBcIiM2Mzc3RDZcIiB9KSxcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwic3RvcFwiLCB7IG9mZnNldDogXCIwLjc5XCIsIHN0b3BDb2xvcjogXCIjMjRCMEE3XCIgfSksXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInN0b3BcIiwgeyBvZmZzZXQ6IFwiMC45OVwiLCBzdG9wQ29sb3I6IFwiIzAwRDE4Q1wiIH0pLFxuICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzdG9wXCIsIHsgb2Zmc2V0OiBcIjFcIiwgc3RvcENvbG9yOiBcIiMwMEQxOENcIiB9KSksXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiY2xpcFBhdGhcIiwgeyBpZDogXCJjbGlwMF84ODBfNTExNVwiIH0sXG4gICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInJlY3RcIiwgeyB3aWR0aDogXCI0OFwiLCBoZWlnaHQ6IFwiNDhcIiwgZmlsbDogXCJ3aGl0ZVwiLCB0cmFuc2Zvcm06IFwidHJhbnNsYXRlKDI0LjUgMjQpXCIgfSkpKSkpO1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdhbGxldFNWRy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-react-ui/lib/esm/WalletSVG.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/ConnectionProvider.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/ConnectionProvider.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionProvider: function() { return /* binding */ ConnectionProvider; }\n/* harmony export */ });\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _useConnection_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./useConnection.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js\");\n\n\n\nconst ConnectionProvider = ({ children, endpoint, config = { commitment: 'confirmed' }, }) => {\n    const connection = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Connection(endpoint, config), [endpoint, config]);\n    return react__WEBPACK_IMPORTED_MODULE_1__.createElement(_useConnection_js__WEBPACK_IMPORTED_MODULE_2__.ConnectionContext.Provider, { value: { connection } }, children);\n};\n//# sourceMappingURL=ConnectionProvider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0L2xpYi9lc20vQ29ubmVjdGlvblByb3ZpZGVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBNkM7QUFDTjtBQUNnQjtBQUNoRCw4QkFBOEIsK0JBQStCLHlCQUF5QixHQUFHO0FBQ2hHLHVCQUF1Qiw4Q0FBTyxXQUFXLHVEQUFVO0FBQ25ELFdBQVcsZ0RBQW1CLENBQUMsZ0VBQWlCLGFBQWEsU0FBUyxjQUFjO0FBQ3BGO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS9Db25uZWN0aW9uUHJvdmlkZXIuanM/M2VlYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBDb25uZWN0aW9uIH0gZnJvbSAnQHNvbGFuYS93ZWIzLmpzJztcbmltcG9ydCBSZWFjdCwgeyB1c2VNZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgQ29ubmVjdGlvbkNvbnRleHQgfSBmcm9tICcuL3VzZUNvbm5lY3Rpb24uanMnO1xuZXhwb3J0IGNvbnN0IENvbm5lY3Rpb25Qcm92aWRlciA9ICh7IGNoaWxkcmVuLCBlbmRwb2ludCwgY29uZmlnID0geyBjb21taXRtZW50OiAnY29uZmlybWVkJyB9LCB9KSA9PiB7XG4gICAgY29uc3QgY29ubmVjdGlvbiA9IHVzZU1lbW8oKCkgPT4gbmV3IENvbm5lY3Rpb24oZW5kcG9pbnQsIGNvbmZpZyksIFtlbmRwb2ludCwgY29uZmlnXSk7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29ubmVjdGlvbkNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHsgY29ubmVjdGlvbiB9IH0sIGNoaWxkcmVuKTtcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25uZWN0aW9uUHJvdmlkZXIuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/ConnectionProvider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProvider.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProvider.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletProvider: function() { return /* binding */ WalletProvider; }\n/* harmony export */ });\n/* harmony import */ var _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana-mobile/wallet-adapter-mobile */ \"(app-pages-browser)/./node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js\");\n/* harmony import */ var _solana_wallet_standard_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @solana/wallet-standard-wallet-adapter-react */ \"(app-pages-browser)/./node_modules/@solana/wallet-standard-wallet-adapter-react/lib/esm/useStandardWalletAdapters.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _getEnvironment_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getEnvironment.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/getEnvironment.js\");\n/* harmony import */ var _getInferredClusterFromEndpoint_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./getInferredClusterFromEndpoint.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/getInferredClusterFromEndpoint.js\");\n/* harmony import */ var _useConnection_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./useConnection.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js\");\n/* harmony import */ var _useLocalStorage_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./useLocalStorage.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/useLocalStorage.js\");\n/* harmony import */ var _WalletProviderBase_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./WalletProviderBase.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProviderBase.js\");\n\n\n\n\n\n\n\n\nlet _userAgent;\nfunction getUserAgent() {\n    if (_userAgent === undefined) {\n        _userAgent = globalThis.navigator?.userAgent ?? null;\n    }\n    return _userAgent;\n}\nfunction getIsMobile(adapters) {\n    const userAgentString = getUserAgent();\n    return (0,_getEnvironment_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"])({ adapters, userAgentString }) === _getEnvironment_js__WEBPACK_IMPORTED_MODULE_2__.Environment.MOBILE_WEB;\n}\nfunction getUriForAppIdentity() {\n    const location = globalThis.location;\n    if (!location)\n        return;\n    return `${location.protocol}//${location.host}`;\n}\nfunction WalletProvider({ children, wallets: adapters, autoConnect, localStorageKey = 'walletName', onError, }) {\n    const { connection } = (0,_useConnection_js__WEBPACK_IMPORTED_MODULE_3__.useConnection)();\n    const adaptersWithStandardAdapters = (0,_solana_wallet_standard_wallet_adapter_react__WEBPACK_IMPORTED_MODULE_4__.useStandardWalletAdapters)(adapters);\n    const mobileWalletAdapter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n        if (!getIsMobile(adaptersWithStandardAdapters)) {\n            return null;\n        }\n        const existingMobileWalletAdapter = adaptersWithStandardAdapters.find((adapter) => adapter.name === _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName);\n        if (existingMobileWalletAdapter) {\n            return existingMobileWalletAdapter;\n        }\n        return new _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapter({\n            addressSelector: (0,_solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.createDefaultAddressSelector)(),\n            appIdentity: {\n                uri: getUriForAppIdentity(),\n            },\n            authorizationResultCache: (0,_solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.createDefaultAuthorizationResultCache)(),\n            cluster: (0,_getInferredClusterFromEndpoint_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"])(connection?.rpcEndpoint),\n            onWalletNotFound: (0,_solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.createDefaultWalletNotFoundHandler)(),\n        });\n    }, [adaptersWithStandardAdapters, connection?.rpcEndpoint]);\n    const adaptersWithMobileWalletAdapter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n        if (mobileWalletAdapter == null || adaptersWithStandardAdapters.indexOf(mobileWalletAdapter) !== -1) {\n            return adaptersWithStandardAdapters;\n        }\n        return [mobileWalletAdapter, ...adaptersWithStandardAdapters];\n    }, [adaptersWithStandardAdapters, mobileWalletAdapter]);\n    const [walletName, setWalletName] = (0,_useLocalStorage_js__WEBPACK_IMPORTED_MODULE_6__.useLocalStorage)(localStorageKey, getIsMobile(adaptersWithStandardAdapters) ? _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName : null);\n    const adapter = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => adaptersWithMobileWalletAdapter.find((a) => a.name === walletName) ?? null, [adaptersWithMobileWalletAdapter, walletName]);\n    const changeWallet = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((nextWalletName) => {\n        if (walletName === nextWalletName)\n            return;\n        if (adapter &&\n            // Selecting a wallet other than the mobile wallet adapter is not\n            // sufficient reason to call `disconnect` on the mobile wallet adapter.\n            // Calling `disconnect` on the mobile wallet adapter causes the entire\n            // authorization store to be wiped.\n            adapter.name !== _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName) {\n            adapter.disconnect();\n        }\n        setWalletName(nextWalletName);\n    }, [adapter, setWalletName, walletName]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        if (!adapter)\n            return;\n        function handleDisconnect() {\n            if (isUnloadingRef.current)\n                return;\n            // Leave the adapter selected in the event of a disconnection.\n            if (walletName === _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters))\n                return;\n            setWalletName(null);\n        }\n        adapter.on('disconnect', handleDisconnect);\n        return () => {\n            adapter.off('disconnect', handleDisconnect);\n        };\n    }, [adapter, adaptersWithStandardAdapters, setWalletName, walletName]);\n    const hasUserSelectedAWallet = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const handleAutoConnectRequest = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)(() => {\n        if (!autoConnect || !adapter)\n            return;\n        return async () => {\n            // If autoConnect is true or returns true, use the default autoConnect behavior.\n            if (autoConnect === true || (await autoConnect(adapter))) {\n                if (hasUserSelectedAWallet.current) {\n                    await adapter.connect();\n                }\n                else {\n                    await adapter.autoConnect();\n                }\n            }\n        };\n    }, [autoConnect, adapter]);\n    const isUnloadingRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {\n        if (walletName === _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n            isUnloadingRef.current = false;\n            return;\n        }\n        function handleBeforeUnload() {\n            isUnloadingRef.current = true;\n        }\n        /**\n         * Some wallets fire disconnection events when the window unloads. Since there's no way to\n         * distinguish between a disconnection event received because a user initiated it, and one\n         * that was received because they've closed the window, we have to track window unload\n         * events themselves. Downstream components use this information to decide whether to act\n         * upon or drop wallet events and errors.\n         */\n        window.addEventListener('beforeunload', handleBeforeUnload);\n        return () => {\n            window.removeEventListener('beforeunload', handleBeforeUnload);\n        };\n    }, [adaptersWithStandardAdapters, walletName]);\n    const handleConnectError = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(() => {\n        if (adapter && adapter.name !== _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName) {\n            // If any error happens while connecting, unset the adapter.\n            changeWallet(null);\n        }\n    }, [adapter, changeWallet]);\n    const selectWallet = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((walletName) => {\n        hasUserSelectedAWallet.current = true;\n        changeWallet(walletName);\n    }, [changeWallet]);\n    return (react__WEBPACK_IMPORTED_MODULE_1__.createElement(_WalletProviderBase_js__WEBPACK_IMPORTED_MODULE_7__.WalletProviderBase, { wallets: adaptersWithMobileWalletAdapter, adapter: adapter, isUnloadingRef: isUnloadingRef, onAutoConnectRequest: handleAutoConnectRequest, onConnectError: handleConnectError, onError: onError, onSelectWallet: selectWallet }, children));\n}\n//# sourceMappingURL=WalletProvider.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0L2xpYi9lc20vV2FsbGV0UHJvdmlkZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQWdPO0FBQ3ZJO0FBQ2xCO0FBQ0w7QUFDZTtBQUM5QjtBQUNJO0FBQ007QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4REFBYyxHQUFHLDJCQUEyQixNQUFNLDJEQUFXO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGtCQUFrQixJQUFJLGNBQWM7QUFDbEQ7QUFDTywwQkFBMEIsb0ZBQW9GO0FBQ3JILFlBQVksYUFBYSxFQUFFLGdFQUFhO0FBQ3hDLHlDQUF5Qyx1R0FBeUI7QUFDbEUsZ0NBQWdDLDhDQUFPO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDRHQUE0RyxxR0FBbUM7QUFDL0k7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDJGQUF5QjtBQUM1Qyw2QkFBNkIsa0dBQTRCO0FBQ3pEO0FBQ0E7QUFDQSxhQUFhO0FBQ2Isc0NBQXNDLDJHQUFxQztBQUMzRSxxQkFBcUIsOEVBQThCO0FBQ25ELDhCQUE4Qix3R0FBa0M7QUFDaEUsU0FBUztBQUNULEtBQUs7QUFDTCw0Q0FBNEMsOENBQU87QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsd0NBQXdDLG9FQUFlLDhEQUE4RCxxR0FBbUM7QUFDeEosb0JBQW9CLDhDQUFPO0FBQzNCLHlCQUF5QixrREFBVztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixxR0FBbUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUdBQW1DO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1DQUFtQyw2Q0FBTTtBQUN6QyxxQ0FBcUMsOENBQU87QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsMkJBQTJCLDZDQUFNO0FBQ2pDLElBQUksZ0RBQVM7QUFDYiwyQkFBMkIscUdBQW1DO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsK0JBQStCLGtEQUFXO0FBQzFDLHdDQUF3QyxxR0FBbUM7QUFDM0U7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLHlCQUF5QixrREFBVztBQUNwQztBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksZ0RBQW1CLENBQUMsc0VBQWtCLElBQUksZ09BQWdPO0FBQ3RSO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS9XYWxsZXRQcm92aWRlci5qcz81YTRjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZURlZmF1bHRBZGRyZXNzU2VsZWN0b3IsIGNyZWF0ZURlZmF1bHRBdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUsIGNyZWF0ZURlZmF1bHRXYWxsZXROb3RGb3VuZEhhbmRsZXIsIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXIsIFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lLCB9IGZyb20gJ0Bzb2xhbmEtbW9iaWxlL3dhbGxldC1hZGFwdGVyLW1vYmlsZSc7XG5pbXBvcnQgeyB1c2VTdGFuZGFyZFdhbGxldEFkYXB0ZXJzIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtd2FsbGV0LWFkYXB0ZXItcmVhY3QnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBnZXRFbnZpcm9ubWVudCwgeyBFbnZpcm9ubWVudCB9IGZyb20gJy4vZ2V0RW52aXJvbm1lbnQuanMnO1xuaW1wb3J0IGdldEluZmVycmVkQ2x1c3RlckZyb21FbmRwb2ludCBmcm9tICcuL2dldEluZmVycmVkQ2x1c3RlckZyb21FbmRwb2ludC5qcyc7XG5pbXBvcnQgeyB1c2VDb25uZWN0aW9uIH0gZnJvbSAnLi91c2VDb25uZWN0aW9uLmpzJztcbmltcG9ydCB7IHVzZUxvY2FsU3RvcmFnZSB9IGZyb20gJy4vdXNlTG9jYWxTdG9yYWdlLmpzJztcbmltcG9ydCB7IFdhbGxldFByb3ZpZGVyQmFzZSB9IGZyb20gJy4vV2FsbGV0UHJvdmlkZXJCYXNlLmpzJztcbmxldCBfdXNlckFnZW50O1xuZnVuY3Rpb24gZ2V0VXNlckFnZW50KCkge1xuICAgIGlmIChfdXNlckFnZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgX3VzZXJBZ2VudCA9IGdsb2JhbFRoaXMubmF2aWdhdG9yPy51c2VyQWdlbnQgPz8gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIF91c2VyQWdlbnQ7XG59XG5mdW5jdGlvbiBnZXRJc01vYmlsZShhZGFwdGVycykge1xuICAgIGNvbnN0IHVzZXJBZ2VudFN0cmluZyA9IGdldFVzZXJBZ2VudCgpO1xuICAgIHJldHVybiBnZXRFbnZpcm9ubWVudCh7IGFkYXB0ZXJzLCB1c2VyQWdlbnRTdHJpbmcgfSkgPT09IEVudmlyb25tZW50Lk1PQklMRV9XRUI7XG59XG5mdW5jdGlvbiBnZXRVcmlGb3JBcHBJZGVudGl0eSgpIHtcbiAgICBjb25zdCBsb2NhdGlvbiA9IGdsb2JhbFRoaXMubG9jYXRpb247XG4gICAgaWYgKCFsb2NhdGlvbilcbiAgICAgICAgcmV0dXJuO1xuICAgIHJldHVybiBgJHtsb2NhdGlvbi5wcm90b2NvbH0vLyR7bG9jYXRpb24uaG9zdH1gO1xufVxuZXhwb3J0IGZ1bmN0aW9uIFdhbGxldFByb3ZpZGVyKHsgY2hpbGRyZW4sIHdhbGxldHM6IGFkYXB0ZXJzLCBhdXRvQ29ubmVjdCwgbG9jYWxTdG9yYWdlS2V5ID0gJ3dhbGxldE5hbWUnLCBvbkVycm9yLCB9KSB7XG4gICAgY29uc3QgeyBjb25uZWN0aW9uIH0gPSB1c2VDb25uZWN0aW9uKCk7XG4gICAgY29uc3QgYWRhcHRlcnNXaXRoU3RhbmRhcmRBZGFwdGVycyA9IHVzZVN0YW5kYXJkV2FsbGV0QWRhcHRlcnMoYWRhcHRlcnMpO1xuICAgIGNvbnN0IG1vYmlsZVdhbGxldEFkYXB0ZXIgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKCFnZXRJc01vYmlsZShhZGFwdGVyc1dpdGhTdGFuZGFyZEFkYXB0ZXJzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhpc3RpbmdNb2JpbGVXYWxsZXRBZGFwdGVyID0gYWRhcHRlcnNXaXRoU3RhbmRhcmRBZGFwdGVycy5maW5kKChhZGFwdGVyKSA9PiBhZGFwdGVyLm5hbWUgPT09IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nTW9iaWxlV2FsbGV0QWRhcHRlcikge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nTW9iaWxlV2FsbGV0QWRhcHRlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXIoe1xuICAgICAgICAgICAgYWRkcmVzc1NlbGVjdG9yOiBjcmVhdGVEZWZhdWx0QWRkcmVzc1NlbGVjdG9yKCksXG4gICAgICAgICAgICBhcHBJZGVudGl0eToge1xuICAgICAgICAgICAgICAgIHVyaTogZ2V0VXJpRm9yQXBwSWRlbnRpdHkoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBhdXRob3JpemF0aW9uUmVzdWx0Q2FjaGU6IGNyZWF0ZURlZmF1bHRBdXRob3JpemF0aW9uUmVzdWx0Q2FjaGUoKSxcbiAgICAgICAgICAgIGNsdXN0ZXI6IGdldEluZmVycmVkQ2x1c3RlckZyb21FbmRwb2ludChjb25uZWN0aW9uPy5ycGNFbmRwb2ludCksXG4gICAgICAgICAgICBvbldhbGxldE5vdEZvdW5kOiBjcmVhdGVEZWZhdWx0V2FsbGV0Tm90Rm91bmRIYW5kbGVyKCksXG4gICAgICAgIH0pO1xuICAgIH0sIFthZGFwdGVyc1dpdGhTdGFuZGFyZEFkYXB0ZXJzLCBjb25uZWN0aW9uPy5ycGNFbmRwb2ludF0pO1xuICAgIGNvbnN0IGFkYXB0ZXJzV2l0aE1vYmlsZVdhbGxldEFkYXB0ZXIgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKG1vYmlsZVdhbGxldEFkYXB0ZXIgPT0gbnVsbCB8fCBhZGFwdGVyc1dpdGhTdGFuZGFyZEFkYXB0ZXJzLmluZGV4T2YobW9iaWxlV2FsbGV0QWRhcHRlcikgIT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gYWRhcHRlcnNXaXRoU3RhbmRhcmRBZGFwdGVycztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW21vYmlsZVdhbGxldEFkYXB0ZXIsIC4uLmFkYXB0ZXJzV2l0aFN0YW5kYXJkQWRhcHRlcnNdO1xuICAgIH0sIFthZGFwdGVyc1dpdGhTdGFuZGFyZEFkYXB0ZXJzLCBtb2JpbGVXYWxsZXRBZGFwdGVyXSk7XG4gICAgY29uc3QgW3dhbGxldE5hbWUsIHNldFdhbGxldE5hbWVdID0gdXNlTG9jYWxTdG9yYWdlKGxvY2FsU3RvcmFnZUtleSwgZ2V0SXNNb2JpbGUoYWRhcHRlcnNXaXRoU3RhbmRhcmRBZGFwdGVycykgPyBTb2xhbmFNb2JpbGVXYWxsZXRBZGFwdGVyV2FsbGV0TmFtZSA6IG51bGwpO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB1c2VNZW1vKCgpID0+IGFkYXB0ZXJzV2l0aE1vYmlsZVdhbGxldEFkYXB0ZXIuZmluZCgoYSkgPT4gYS5uYW1lID09PSB3YWxsZXROYW1lKSA/PyBudWxsLCBbYWRhcHRlcnNXaXRoTW9iaWxlV2FsbGV0QWRhcHRlciwgd2FsbGV0TmFtZV0pO1xuICAgIGNvbnN0IGNoYW5nZVdhbGxldCA9IHVzZUNhbGxiYWNrKChuZXh0V2FsbGV0TmFtZSkgPT4ge1xuICAgICAgICBpZiAod2FsbGV0TmFtZSA9PT0gbmV4dFdhbGxldE5hbWUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChhZGFwdGVyICYmXG4gICAgICAgICAgICAvLyBTZWxlY3RpbmcgYSB3YWxsZXQgb3RoZXIgdGhhbiB0aGUgbW9iaWxlIHdhbGxldCBhZGFwdGVyIGlzIG5vdFxuICAgICAgICAgICAgLy8gc3VmZmljaWVudCByZWFzb24gdG8gY2FsbCBgZGlzY29ubmVjdGAgb24gdGhlIG1vYmlsZSB3YWxsZXQgYWRhcHRlci5cbiAgICAgICAgICAgIC8vIENhbGxpbmcgYGRpc2Nvbm5lY3RgIG9uIHRoZSBtb2JpbGUgd2FsbGV0IGFkYXB0ZXIgY2F1c2VzIHRoZSBlbnRpcmVcbiAgICAgICAgICAgIC8vIGF1dGhvcml6YXRpb24gc3RvcmUgdG8gYmUgd2lwZWQuXG4gICAgICAgICAgICBhZGFwdGVyLm5hbWUgIT09IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lKSB7XG4gICAgICAgICAgICBhZGFwdGVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRXYWxsZXROYW1lKG5leHRXYWxsZXROYW1lKTtcbiAgICB9LCBbYWRhcHRlciwgc2V0V2FsbGV0TmFtZSwgd2FsbGV0TmFtZV0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghYWRhcHRlcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlRGlzY29ubmVjdCgpIHtcbiAgICAgICAgICAgIGlmIChpc1VubG9hZGluZ1JlZi5jdXJyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8vIExlYXZlIHRoZSBhZGFwdGVyIHNlbGVjdGVkIGluIHRoZSBldmVudCBvZiBhIGRpc2Nvbm5lY3Rpb24uXG4gICAgICAgICAgICBpZiAod2FsbGV0TmFtZSA9PT0gU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldE5hbWUgJiYgZ2V0SXNNb2JpbGUoYWRhcHRlcnNXaXRoU3RhbmRhcmRBZGFwdGVycykpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgc2V0V2FsbGV0TmFtZShudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBhZGFwdGVyLm9uKCdkaXNjb25uZWN0JywgaGFuZGxlRGlzY29ubmVjdCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBhZGFwdGVyLm9mZignZGlzY29ubmVjdCcsIGhhbmRsZURpc2Nvbm5lY3QpO1xuICAgICAgICB9O1xuICAgIH0sIFthZGFwdGVyLCBhZGFwdGVyc1dpdGhTdGFuZGFyZEFkYXB0ZXJzLCBzZXRXYWxsZXROYW1lLCB3YWxsZXROYW1lXSk7XG4gICAgY29uc3QgaGFzVXNlclNlbGVjdGVkQVdhbGxldCA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3QgaGFuZGxlQXV0b0Nvbm5lY3RSZXF1ZXN0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGlmICghYXV0b0Nvbm5lY3QgfHwgIWFkYXB0ZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJldHVybiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAvLyBJZiBhdXRvQ29ubmVjdCBpcyB0cnVlIG9yIHJldHVybnMgdHJ1ZSwgdXNlIHRoZSBkZWZhdWx0IGF1dG9Db25uZWN0IGJlaGF2aW9yLlxuICAgICAgICAgICAgaWYgKGF1dG9Db25uZWN0ID09PSB0cnVlIHx8IChhd2FpdCBhdXRvQ29ubmVjdChhZGFwdGVyKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzVXNlclNlbGVjdGVkQVdhbGxldC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGFkYXB0ZXIuY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgYWRhcHRlci5hdXRvQ29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9LCBbYXV0b0Nvbm5lY3QsIGFkYXB0ZXJdKTtcbiAgICBjb25zdCBpc1VubG9hZGluZ1JlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHdhbGxldE5hbWUgPT09IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lICYmIGdldElzTW9iaWxlKGFkYXB0ZXJzV2l0aFN0YW5kYXJkQWRhcHRlcnMpKSB7XG4gICAgICAgICAgICBpc1VubG9hZGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlQmVmb3JlVW5sb2FkKCkge1xuICAgICAgICAgICAgaXNVbmxvYWRpbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvbWUgd2FsbGV0cyBmaXJlIGRpc2Nvbm5lY3Rpb24gZXZlbnRzIHdoZW4gdGhlIHdpbmRvdyB1bmxvYWRzLiBTaW5jZSB0aGVyZSdzIG5vIHdheSB0b1xuICAgICAgICAgKiBkaXN0aW5ndWlzaCBiZXR3ZWVuIGEgZGlzY29ubmVjdGlvbiBldmVudCByZWNlaXZlZCBiZWNhdXNlIGEgdXNlciBpbml0aWF0ZWQgaXQsIGFuZCBvbmVcbiAgICAgICAgICogdGhhdCB3YXMgcmVjZWl2ZWQgYmVjYXVzZSB0aGV5J3ZlIGNsb3NlZCB0aGUgd2luZG93LCB3ZSBoYXZlIHRvIHRyYWNrIHdpbmRvdyB1bmxvYWRcbiAgICAgICAgICogZXZlbnRzIHRoZW1zZWx2ZXMuIERvd25zdHJlYW0gY29tcG9uZW50cyB1c2UgdGhpcyBpbmZvcm1hdGlvbiB0byBkZWNpZGUgd2hldGhlciB0byBhY3RcbiAgICAgICAgICogdXBvbiBvciBkcm9wIHdhbGxldCBldmVudHMgYW5kIGVycm9ycy5cbiAgICAgICAgICovXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCBoYW5kbGVCZWZvcmVVbmxvYWQpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGhhbmRsZUJlZm9yZVVubG9hZCk7XG4gICAgICAgIH07XG4gICAgfSwgW2FkYXB0ZXJzV2l0aFN0YW5kYXJkQWRhcHRlcnMsIHdhbGxldE5hbWVdKTtcbiAgICBjb25zdCBoYW5kbGVDb25uZWN0RXJyb3IgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlmIChhZGFwdGVyICYmIGFkYXB0ZXIubmFtZSAhPT0gU29sYW5hTW9iaWxlV2FsbGV0QWRhcHRlcldhbGxldE5hbWUpIHtcbiAgICAgICAgICAgIC8vIElmIGFueSBlcnJvciBoYXBwZW5zIHdoaWxlIGNvbm5lY3RpbmcsIHVuc2V0IHRoZSBhZGFwdGVyLlxuICAgICAgICAgICAgY2hhbmdlV2FsbGV0KG51bGwpO1xuICAgICAgICB9XG4gICAgfSwgW2FkYXB0ZXIsIGNoYW5nZVdhbGxldF0pO1xuICAgIGNvbnN0IHNlbGVjdFdhbGxldCA9IHVzZUNhbGxiYWNrKCh3YWxsZXROYW1lKSA9PiB7XG4gICAgICAgIGhhc1VzZXJTZWxlY3RlZEFXYWxsZXQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIGNoYW5nZVdhbGxldCh3YWxsZXROYW1lKTtcbiAgICB9LCBbY2hhbmdlV2FsbGV0XSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFdhbGxldFByb3ZpZGVyQmFzZSwgeyB3YWxsZXRzOiBhZGFwdGVyc1dpdGhNb2JpbGVXYWxsZXRBZGFwdGVyLCBhZGFwdGVyOiBhZGFwdGVyLCBpc1VubG9hZGluZ1JlZjogaXNVbmxvYWRpbmdSZWYsIG9uQXV0b0Nvbm5lY3RSZXF1ZXN0OiBoYW5kbGVBdXRvQ29ubmVjdFJlcXVlc3QsIG9uQ29ubmVjdEVycm9yOiBoYW5kbGVDb25uZWN0RXJyb3IsIG9uRXJyb3I6IG9uRXJyb3IsIG9uU2VsZWN0V2FsbGV0OiBzZWxlY3RXYWxsZXQgfSwgY2hpbGRyZW4pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdhbGxldFByb3ZpZGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProvider.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProviderBase.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProviderBase.js ***!
  \*********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletProviderBase: function() { return /* binding */ WalletProviderBase; }\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _errors_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./errors.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/errors.js\");\n/* harmony import */ var _useWallet_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./useWallet.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js\");\n\n\n\n\nfunction WalletProviderBase({ children, wallets: adapters, adapter, isUnloadingRef, onAutoConnectRequest, onConnectError, onError, onSelectWallet, }) {\n    const isConnectingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const [connecting, setConnecting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const isDisconnectingRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    const [disconnecting, setDisconnecting] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n    const [publicKey, setPublicKey] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => adapter?.publicKey ?? null);\n    const [connected, setConnected] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => adapter?.connected ?? false);\n    /**\n     * Store the error handlers as refs so that a change in the\n     * custom error handler does not recompute other dependencies.\n     */\n    const onErrorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(onError);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        onErrorRef.current = onError;\n        return () => {\n            onErrorRef.current = undefined;\n        };\n    }, [onError]);\n    const handleErrorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)((error, adapter) => {\n        if (!isUnloadingRef.current) {\n            if (onErrorRef.current) {\n                onErrorRef.current(error, adapter);\n            }\n            else {\n                console.error(error, adapter);\n                if (error instanceof _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotReadyError && typeof window !== 'undefined' && adapter) {\n                    window.open(adapter.url, '_blank');\n                }\n            }\n        }\n        return error;\n    });\n    // Wrap adapters to conform to the `Wallet` interface\n    const [wallets, setWallets] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => adapters\n        .map((adapter) => ({\n        adapter,\n        readyState: adapter.readyState,\n    }))\n        .filter(({ readyState }) => readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Unsupported));\n    // When the adapters change, start to listen for changes to their `readyState`\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        // When the adapters change, wrap them to conform to the `Wallet` interface\n        setWallets((wallets) => adapters\n            .map((adapter, index) => {\n            const wallet = wallets[index];\n            // If the wallet hasn't changed, return the same instance\n            return wallet && wallet.adapter === adapter && wallet.readyState === adapter.readyState\n                ? wallet\n                : {\n                    adapter: adapter,\n                    readyState: adapter.readyState,\n                };\n        })\n            .filter(({ readyState }) => readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Unsupported));\n        function handleReadyStateChange(readyState) {\n            setWallets((prevWallets) => {\n                const index = prevWallets.findIndex(({ adapter }) => adapter === this);\n                if (index === -1)\n                    return prevWallets;\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const { adapter } = prevWallets[index];\n                return [\n                    ...prevWallets.slice(0, index),\n                    { adapter, readyState },\n                    ...prevWallets.slice(index + 1),\n                ].filter(({ readyState }) => readyState !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Unsupported);\n            });\n        }\n        adapters.forEach((adapter) => adapter.on('readyStateChange', handleReadyStateChange, adapter));\n        return () => {\n            adapters.forEach((adapter) => adapter.off('readyStateChange', handleReadyStateChange, adapter));\n        };\n    }, [adapter, adapters]);\n    const wallet = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => wallets.find((wallet) => wallet.adapter === adapter) ?? null, [adapter, wallets]);\n    // Setup and teardown event listeners when the adapter changes\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!adapter)\n            return;\n        const handleConnect = (publicKey) => {\n            setPublicKey(publicKey);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(true);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n        const handleDisconnect = () => {\n            if (isUnloadingRef.current)\n                return;\n            setPublicKey(null);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(false);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n        const handleError = (error) => {\n            handleErrorRef.current(error, adapter);\n        };\n        adapter.on('connect', handleConnect);\n        adapter.on('disconnect', handleDisconnect);\n        adapter.on('error', handleError);\n        return () => {\n            adapter.off('connect', handleConnect);\n            adapter.off('disconnect', handleDisconnect);\n            adapter.off('error', handleError);\n            handleDisconnect();\n        };\n    }, [adapter, isUnloadingRef]);\n    // When the adapter changes, clear the `autoConnect` tracking flag\n    const didAttemptAutoConnectRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        return () => {\n            didAttemptAutoConnectRef.current = false;\n        };\n    }, [adapter]);\n    // If auto-connect is enabled, request to connect when the adapter changes and is ready\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (didAttemptAutoConnectRef.current ||\n            isConnectingRef.current ||\n            connected ||\n            !onAutoConnectRequest ||\n            !(wallet?.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Installed || wallet?.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Loadable))\n            return;\n        isConnectingRef.current = true;\n        setConnecting(true);\n        didAttemptAutoConnectRef.current = true;\n        (async function () {\n            try {\n                await onAutoConnectRequest();\n            }\n            catch {\n                onConnectError();\n                // Drop the error. It will be caught by `handleError` anyway.\n            }\n            finally {\n                setConnecting(false);\n                isConnectingRef.current = false;\n            }\n        })();\n    }, [connected, onAutoConnectRequest, onConnectError, wallet]);\n    // Send a transaction using the provided connection\n    const sendTransaction = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async (transaction, connection, options) => {\n        if (!adapter)\n            throw handleErrorRef.current(new _errors_js__WEBPACK_IMPORTED_MODULE_3__.WalletNotSelectedError());\n        if (!connected)\n            throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError(), adapter);\n        return await adapter.sendTransaction(transaction, connection, options);\n    }, [adapter, connected]);\n    // Sign a transaction if the wallet supports it\n    const signTransaction = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => adapter && 'signTransaction' in adapter\n        ? async (transaction) => {\n            if (!connected)\n                throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError(), adapter);\n            return await adapter.signTransaction(transaction);\n        }\n        : undefined, [adapter, connected]);\n    // Sign multiple transactions if the wallet supports it\n    const signAllTransactions = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => adapter && 'signAllTransactions' in adapter\n        ? async (transactions) => {\n            if (!connected)\n                throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError(), adapter);\n            return await adapter.signAllTransactions(transactions);\n        }\n        : undefined, [adapter, connected]);\n    // Sign an arbitrary message if the wallet supports it\n    const signMessage = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => adapter && 'signMessage' in adapter\n        ? async (message) => {\n            if (!connected)\n                throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotConnectedError(), adapter);\n            return await adapter.signMessage(message);\n        }\n        : undefined, [adapter, connected]);\n    // Sign in if the wallet supports it\n    const signIn = (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => adapter && 'signIn' in adapter\n        ? async (input) => {\n            return await adapter.signIn(input);\n        }\n        : undefined, [adapter]);\n    const handleConnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => {\n        if (isConnectingRef.current || isDisconnectingRef.current || wallet?.adapter.connected)\n            return;\n        if (!wallet)\n            throw handleErrorRef.current(new _errors_js__WEBPACK_IMPORTED_MODULE_3__.WalletNotSelectedError());\n        const { adapter, readyState } = wallet;\n        if (!(readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Installed || readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Loadable))\n            throw handleErrorRef.current(new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletNotReadyError(), adapter);\n        isConnectingRef.current = true;\n        setConnecting(true);\n        try {\n            await adapter.connect();\n        }\n        catch (e) {\n            onConnectError();\n            throw e;\n        }\n        finally {\n            setConnecting(false);\n            isConnectingRef.current = false;\n        }\n    }, [onConnectError, wallet]);\n    const handleDisconnect = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(async () => {\n        if (isDisconnectingRef.current)\n            return;\n        if (!adapter)\n            return;\n        isDisconnectingRef.current = true;\n        setDisconnecting(true);\n        try {\n            await adapter.disconnect();\n        }\n        finally {\n            setDisconnecting(false);\n            isDisconnectingRef.current = false;\n        }\n    }, [adapter]);\n    return (react__WEBPACK_IMPORTED_MODULE_0__.createElement(_useWallet_js__WEBPACK_IMPORTED_MODULE_4__.WalletContext.Provider, { value: {\n            autoConnect: !!onAutoConnectRequest,\n            wallets,\n            wallet,\n            publicKey,\n            connected,\n            connecting,\n            disconnecting,\n            select: onSelectWallet,\n            connect: handleConnect,\n            disconnect: handleDisconnect,\n            sendTransaction,\n            signTransaction,\n            signAllTransactions,\n            signMessage,\n            signIn,\n        } }, children));\n}\n//# sourceMappingURL=WalletProviderBase.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0L2xpYi9lc20vV2FsbGV0UHJvdmlkZXJCYXNlLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUE4RztBQUM3QjtBQUM1QjtBQUNOO0FBQ3hDLDhCQUE4QixzSEFBc0g7QUFDM0osNEJBQTRCLDZDQUFNO0FBQ2xDLHdDQUF3QywrQ0FBUTtBQUNoRCwrQkFBK0IsNkNBQU07QUFDckMsOENBQThDLCtDQUFRO0FBQ3RELHNDQUFzQywrQ0FBUTtBQUM5QyxzQ0FBc0MsK0NBQVE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNkNBQU07QUFDN0IsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDJCQUEyQiw2Q0FBTTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsNEVBQW1CO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQ0FBa0MsK0NBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG1CQUFtQixZQUFZLG9CQUFvQix5RUFBZ0I7QUFDbkU7QUFDQSxJQUFJLGdEQUFTO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCx1QkFBdUIsWUFBWSxvQkFBb0IseUVBQWdCO0FBQ3ZFO0FBQ0E7QUFDQSx1REFBdUQsU0FBUztBQUNoRTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBVTtBQUNsQztBQUNBO0FBQ0Esc0JBQXNCLHFCQUFxQjtBQUMzQztBQUNBLDRCQUE0QixZQUFZLG9CQUFvQix5RUFBZ0I7QUFDNUUsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsbUJBQW1CLDhDQUFPO0FBQzFCO0FBQ0EsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxxQ0FBcUMsNkNBQU07QUFDM0MsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyx5RUFBZ0IscUNBQXFDLHlFQUFnQjtBQUMxRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQSw0QkFBNEIsa0RBQVc7QUFDdkM7QUFDQSw2Q0FBNkMsOERBQXNCO0FBQ25FO0FBQ0EsNkNBQTZDLGdGQUF1QjtBQUNwRTtBQUNBLEtBQUs7QUFDTDtBQUNBLDRCQUE0Qiw4Q0FBTztBQUNuQztBQUNBO0FBQ0EsaURBQWlELGdGQUF1QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4Q0FBTztBQUN2QztBQUNBO0FBQ0EsaURBQWlELGdGQUF1QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qiw4Q0FBTztBQUMvQjtBQUNBO0FBQ0EsaURBQWlELGdGQUF1QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4Q0FBTztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrREFBVztBQUNyQztBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsOERBQXNCO0FBQ25FLGdCQUFnQixzQkFBc0I7QUFDdEMsNkJBQTZCLHlFQUFnQiw2QkFBNkIseUVBQWdCO0FBQzFGLDZDQUE2Qyw0RUFBbUI7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsNkJBQTZCLGtEQUFXO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVksZ0RBQW1CLENBQUMsd0RBQWEsYUFBYTtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL1dhbGxldFByb3ZpZGVyQmFzZS5qcz8yNmMwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFdhbGxldE5vdENvbm5lY3RlZEVycm9yLCBXYWxsZXROb3RSZWFkeUVycm9yLCBXYWxsZXRSZWFkeVN0YXRlLCB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZSc7XG5pbXBvcnQgUmVhY3QsIHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IFdhbGxldE5vdFNlbGVjdGVkRXJyb3IgfSBmcm9tICcuL2Vycm9ycy5qcyc7XG5pbXBvcnQgeyBXYWxsZXRDb250ZXh0IH0gZnJvbSAnLi91c2VXYWxsZXQuanMnO1xuZXhwb3J0IGZ1bmN0aW9uIFdhbGxldFByb3ZpZGVyQmFzZSh7IGNoaWxkcmVuLCB3YWxsZXRzOiBhZGFwdGVycywgYWRhcHRlciwgaXNVbmxvYWRpbmdSZWYsIG9uQXV0b0Nvbm5lY3RSZXF1ZXN0LCBvbkNvbm5lY3RFcnJvciwgb25FcnJvciwgb25TZWxlY3RXYWxsZXQsIH0pIHtcbiAgICBjb25zdCBpc0Nvbm5lY3RpbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IFtjb25uZWN0aW5nLCBzZXRDb25uZWN0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBpc0Rpc2Nvbm5lY3RpbmdSZWYgPSB1c2VSZWYoZmFsc2UpO1xuICAgIGNvbnN0IFtkaXNjb25uZWN0aW5nLCBzZXREaXNjb25uZWN0aW5nXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbcHVibGljS2V5LCBzZXRQdWJsaWNLZXldID0gdXNlU3RhdGUoKCkgPT4gYWRhcHRlcj8ucHVibGljS2V5ID8/IG51bGwpO1xuICAgIGNvbnN0IFtjb25uZWN0ZWQsIHNldENvbm5lY3RlZF0gPSB1c2VTdGF0ZSgoKSA9PiBhZGFwdGVyPy5jb25uZWN0ZWQgPz8gZmFsc2UpO1xuICAgIC8qKlxuICAgICAqIFN0b3JlIHRoZSBlcnJvciBoYW5kbGVycyBhcyByZWZzIHNvIHRoYXQgYSBjaGFuZ2UgaW4gdGhlXG4gICAgICogY3VzdG9tIGVycm9yIGhhbmRsZXIgZG9lcyBub3QgcmVjb21wdXRlIG90aGVyIGRlcGVuZGVuY2llcy5cbiAgICAgKi9cbiAgICBjb25zdCBvbkVycm9yUmVmID0gdXNlUmVmKG9uRXJyb3IpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIG9uRXJyb3JSZWYuY3VycmVudCA9IG9uRXJyb3I7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBvbkVycm9yUmVmLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH07XG4gICAgfSwgW29uRXJyb3JdKTtcbiAgICBjb25zdCBoYW5kbGVFcnJvclJlZiA9IHVzZVJlZigoZXJyb3IsIGFkYXB0ZXIpID0+IHtcbiAgICAgICAgaWYgKCFpc1VubG9hZGluZ1JlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBpZiAob25FcnJvclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgb25FcnJvclJlZi5jdXJyZW50KGVycm9yLCBhZGFwdGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IsIGFkYXB0ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFdhbGxldE5vdFJlYWR5RXJyb3IgJiYgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgYWRhcHRlcikge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cub3BlbihhZGFwdGVyLnVybCwgJ19ibGFuaycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfSk7XG4gICAgLy8gV3JhcCBhZGFwdGVycyB0byBjb25mb3JtIHRvIHRoZSBgV2FsbGV0YCBpbnRlcmZhY2VcbiAgICBjb25zdCBbd2FsbGV0cywgc2V0V2FsbGV0c10gPSB1c2VTdGF0ZSgoKSA9PiBhZGFwdGVyc1xuICAgICAgICAubWFwKChhZGFwdGVyKSA9PiAoe1xuICAgICAgICBhZGFwdGVyLFxuICAgICAgICByZWFkeVN0YXRlOiBhZGFwdGVyLnJlYWR5U3RhdGUsXG4gICAgfSkpXG4gICAgICAgIC5maWx0ZXIoKHsgcmVhZHlTdGF0ZSB9KSA9PiByZWFkeVN0YXRlICE9PSBXYWxsZXRSZWFkeVN0YXRlLlVuc3VwcG9ydGVkKSk7XG4gICAgLy8gV2hlbiB0aGUgYWRhcHRlcnMgY2hhbmdlLCBzdGFydCB0byBsaXN0ZW4gZm9yIGNoYW5nZXMgdG8gdGhlaXIgYHJlYWR5U3RhdGVgXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLy8gV2hlbiB0aGUgYWRhcHRlcnMgY2hhbmdlLCB3cmFwIHRoZW0gdG8gY29uZm9ybSB0byB0aGUgYFdhbGxldGAgaW50ZXJmYWNlXG4gICAgICAgIHNldFdhbGxldHMoKHdhbGxldHMpID0+IGFkYXB0ZXJzXG4gICAgICAgICAgICAubWFwKChhZGFwdGVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgd2FsbGV0ID0gd2FsbGV0c1tpbmRleF07XG4gICAgICAgICAgICAvLyBJZiB0aGUgd2FsbGV0IGhhc24ndCBjaGFuZ2VkLCByZXR1cm4gdGhlIHNhbWUgaW5zdGFuY2VcbiAgICAgICAgICAgIHJldHVybiB3YWxsZXQgJiYgd2FsbGV0LmFkYXB0ZXIgPT09IGFkYXB0ZXIgJiYgd2FsbGV0LnJlYWR5U3RhdGUgPT09IGFkYXB0ZXIucmVhZHlTdGF0ZVxuICAgICAgICAgICAgICAgID8gd2FsbGV0XG4gICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIGFkYXB0ZXI6IGFkYXB0ZXIsXG4gICAgICAgICAgICAgICAgICAgIHJlYWR5U3RhdGU6IGFkYXB0ZXIucmVhZHlTdGF0ZSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoeyByZWFkeVN0YXRlIH0pID0+IHJlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuVW5zdXBwb3J0ZWQpKTtcbiAgICAgICAgZnVuY3Rpb24gaGFuZGxlUmVhZHlTdGF0ZUNoYW5nZShyZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICBzZXRXYWxsZXRzKChwcmV2V2FsbGV0cykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcHJldldhbGxldHMuZmluZEluZGV4KCh7IGFkYXB0ZXIgfSkgPT4gYWRhcHRlciA9PT0gdGhpcyk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSAtMSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByZXZXYWxsZXRzO1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgeyBhZGFwdGVyIH0gPSBwcmV2V2FsbGV0c1tpbmRleF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgLi4ucHJldldhbGxldHMuc2xpY2UoMCwgaW5kZXgpLFxuICAgICAgICAgICAgICAgICAgICB7IGFkYXB0ZXIsIHJlYWR5U3RhdGUgfSxcbiAgICAgICAgICAgICAgICAgICAgLi4ucHJldldhbGxldHMuc2xpY2UoaW5kZXggKyAxKSxcbiAgICAgICAgICAgICAgICBdLmZpbHRlcigoeyByZWFkeVN0YXRlIH0pID0+IHJlYWR5U3RhdGUgIT09IFdhbGxldFJlYWR5U3RhdGUuVW5zdXBwb3J0ZWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYWRhcHRlcnMuZm9yRWFjaCgoYWRhcHRlcikgPT4gYWRhcHRlci5vbigncmVhZHlTdGF0ZUNoYW5nZScsIGhhbmRsZVJlYWR5U3RhdGVDaGFuZ2UsIGFkYXB0ZXIpKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGFkYXB0ZXJzLmZvckVhY2goKGFkYXB0ZXIpID0+IGFkYXB0ZXIub2ZmKCdyZWFkeVN0YXRlQ2hhbmdlJywgaGFuZGxlUmVhZHlTdGF0ZUNoYW5nZSwgYWRhcHRlcikpO1xuICAgICAgICB9O1xuICAgIH0sIFthZGFwdGVyLCBhZGFwdGVyc10pO1xuICAgIGNvbnN0IHdhbGxldCA9IHVzZU1lbW8oKCkgPT4gd2FsbGV0cy5maW5kKCh3YWxsZXQpID0+IHdhbGxldC5hZGFwdGVyID09PSBhZGFwdGVyKSA/PyBudWxsLCBbYWRhcHRlciwgd2FsbGV0c10pO1xuICAgIC8vIFNldHVwIGFuZCB0ZWFyZG93biBldmVudCBsaXN0ZW5lcnMgd2hlbiB0aGUgYWRhcHRlciBjaGFuZ2VzXG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFhZGFwdGVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBoYW5kbGVDb25uZWN0ID0gKHB1YmxpY0tleSkgPT4ge1xuICAgICAgICAgICAgc2V0UHVibGljS2V5KHB1YmxpY0tleSk7XG4gICAgICAgICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgc2V0Q29ubmVjdGluZyhmYWxzZSk7XG4gICAgICAgICAgICBzZXRDb25uZWN0ZWQodHJ1ZSk7XG4gICAgICAgICAgICBpc0Rpc2Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgc2V0RGlzY29ubmVjdGluZyhmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGhhbmRsZURpc2Nvbm5lY3QgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoaXNVbmxvYWRpbmdSZWYuY3VycmVudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBzZXRQdWJsaWNLZXkobnVsbCk7XG4gICAgICAgICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgc2V0Q29ubmVjdGluZyhmYWxzZSk7XG4gICAgICAgICAgICBzZXRDb25uZWN0ZWQoZmFsc2UpO1xuICAgICAgICAgICAgaXNEaXNjb25uZWN0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHNldERpc2Nvbm5lY3RpbmcoZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVFcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3JSZWYuY3VycmVudChlcnJvciwgYWRhcHRlcik7XG4gICAgICAgIH07XG4gICAgICAgIGFkYXB0ZXIub24oJ2Nvbm5lY3QnLCBoYW5kbGVDb25uZWN0KTtcbiAgICAgICAgYWRhcHRlci5vbignZGlzY29ubmVjdCcsIGhhbmRsZURpc2Nvbm5lY3QpO1xuICAgICAgICBhZGFwdGVyLm9uKCdlcnJvcicsIGhhbmRsZUVycm9yKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGFkYXB0ZXIub2ZmKCdjb25uZWN0JywgaGFuZGxlQ29ubmVjdCk7XG4gICAgICAgICAgICBhZGFwdGVyLm9mZignZGlzY29ubmVjdCcsIGhhbmRsZURpc2Nvbm5lY3QpO1xuICAgICAgICAgICAgYWRhcHRlci5vZmYoJ2Vycm9yJywgaGFuZGxlRXJyb3IpO1xuICAgICAgICAgICAgaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgICB9O1xuICAgIH0sIFthZGFwdGVyLCBpc1VubG9hZGluZ1JlZl0pO1xuICAgIC8vIFdoZW4gdGhlIGFkYXB0ZXIgY2hhbmdlcywgY2xlYXIgdGhlIGBhdXRvQ29ubmVjdGAgdHJhY2tpbmcgZmxhZ1xuICAgIGNvbnN0IGRpZEF0dGVtcHRBdXRvQ29ubmVjdFJlZiA9IHVzZVJlZihmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGRpZEF0dGVtcHRBdXRvQ29ubmVjdFJlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfSwgW2FkYXB0ZXJdKTtcbiAgICAvLyBJZiBhdXRvLWNvbm5lY3QgaXMgZW5hYmxlZCwgcmVxdWVzdCB0byBjb25uZWN0IHdoZW4gdGhlIGFkYXB0ZXIgY2hhbmdlcyBhbmQgaXMgcmVhZHlcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZGlkQXR0ZW1wdEF1dG9Db25uZWN0UmVmLmN1cnJlbnQgfHxcbiAgICAgICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50IHx8XG4gICAgICAgICAgICBjb25uZWN0ZWQgfHxcbiAgICAgICAgICAgICFvbkF1dG9Db25uZWN0UmVxdWVzdCB8fFxuICAgICAgICAgICAgISh3YWxsZXQ/LnJlYWR5U3RhdGUgPT09IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkIHx8IHdhbGxldD8ucmVhZHlTdGF0ZSA9PT0gV2FsbGV0UmVhZHlTdGF0ZS5Mb2FkYWJsZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgc2V0Q29ubmVjdGluZyh0cnVlKTtcbiAgICAgICAgZGlkQXR0ZW1wdEF1dG9Db25uZWN0UmVmLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAoYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBvbkF1dG9Db25uZWN0UmVxdWVzdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2gge1xuICAgICAgICAgICAgICAgIG9uQ29ubmVjdEVycm9yKCk7XG4gICAgICAgICAgICAgICAgLy8gRHJvcCB0aGUgZXJyb3IuIEl0IHdpbGwgYmUgY2F1Z2h0IGJ5IGBoYW5kbGVFcnJvcmAgYW55d2F5LlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc2V0Q29ubmVjdGluZyhmYWxzZSk7XG4gICAgICAgICAgICAgICAgaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9LCBbY29ubmVjdGVkLCBvbkF1dG9Db25uZWN0UmVxdWVzdCwgb25Db25uZWN0RXJyb3IsIHdhbGxldF0pO1xuICAgIC8vIFNlbmQgYSB0cmFuc2FjdGlvbiB1c2luZyB0aGUgcHJvdmlkZWQgY29ubmVjdGlvblxuICAgIGNvbnN0IHNlbmRUcmFuc2FjdGlvbiA9IHVzZUNhbGxiYWNrKGFzeW5jICh0cmFuc2FjdGlvbiwgY29ubmVjdGlvbiwgb3B0aW9ucykgPT4ge1xuICAgICAgICBpZiAoIWFkYXB0ZXIpXG4gICAgICAgICAgICB0aHJvdyBoYW5kbGVFcnJvclJlZi5jdXJyZW50KG5ldyBXYWxsZXROb3RTZWxlY3RlZEVycm9yKCkpO1xuICAgICAgICBpZiAoIWNvbm5lY3RlZClcbiAgICAgICAgICAgIHRocm93IGhhbmRsZUVycm9yUmVmLmN1cnJlbnQobmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCksIGFkYXB0ZXIpO1xuICAgICAgICByZXR1cm4gYXdhaXQgYWRhcHRlci5zZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIG9wdGlvbnMpO1xuICAgIH0sIFthZGFwdGVyLCBjb25uZWN0ZWRdKTtcbiAgICAvLyBTaWduIGEgdHJhbnNhY3Rpb24gaWYgdGhlIHdhbGxldCBzdXBwb3J0cyBpdFxuICAgIGNvbnN0IHNpZ25UcmFuc2FjdGlvbiA9IHVzZU1lbW8oKCkgPT4gYWRhcHRlciAmJiAnc2lnblRyYW5zYWN0aW9uJyBpbiBhZGFwdGVyXG4gICAgICAgID8gYXN5bmMgKHRyYW5zYWN0aW9uKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWNvbm5lY3RlZClcbiAgICAgICAgICAgICAgICB0aHJvdyBoYW5kbGVFcnJvclJlZi5jdXJyZW50KG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpLCBhZGFwdGVyKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBhZGFwdGVyLnNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQsIFthZGFwdGVyLCBjb25uZWN0ZWRdKTtcbiAgICAvLyBTaWduIG11bHRpcGxlIHRyYW5zYWN0aW9ucyBpZiB0aGUgd2FsbGV0IHN1cHBvcnRzIGl0XG4gICAgY29uc3Qgc2lnbkFsbFRyYW5zYWN0aW9ucyA9IHVzZU1lbW8oKCkgPT4gYWRhcHRlciAmJiAnc2lnbkFsbFRyYW5zYWN0aW9ucycgaW4gYWRhcHRlclxuICAgICAgICA/IGFzeW5jICh0cmFuc2FjdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGVkKVxuICAgICAgICAgICAgICAgIHRocm93IGhhbmRsZUVycm9yUmVmLmN1cnJlbnQobmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCksIGFkYXB0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGFkYXB0ZXIuc2lnbkFsbFRyYW5zYWN0aW9ucyh0cmFuc2FjdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIDogdW5kZWZpbmVkLCBbYWRhcHRlciwgY29ubmVjdGVkXSk7XG4gICAgLy8gU2lnbiBhbiBhcmJpdHJhcnkgbWVzc2FnZSBpZiB0aGUgd2FsbGV0IHN1cHBvcnRzIGl0XG4gICAgY29uc3Qgc2lnbk1lc3NhZ2UgPSB1c2VNZW1vKCgpID0+IGFkYXB0ZXIgJiYgJ3NpZ25NZXNzYWdlJyBpbiBhZGFwdGVyXG4gICAgICAgID8gYXN5bmMgKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIGlmICghY29ubmVjdGVkKVxuICAgICAgICAgICAgICAgIHRocm93IGhhbmRsZUVycm9yUmVmLmN1cnJlbnQobmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCksIGFkYXB0ZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGFkYXB0ZXIuc2lnbk1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQsIFthZGFwdGVyLCBjb25uZWN0ZWRdKTtcbiAgICAvLyBTaWduIGluIGlmIHRoZSB3YWxsZXQgc3VwcG9ydHMgaXRcbiAgICBjb25zdCBzaWduSW4gPSB1c2VNZW1vKCgpID0+IGFkYXB0ZXIgJiYgJ3NpZ25JbicgaW4gYWRhcHRlclxuICAgICAgICA/IGFzeW5jIChpbnB1dCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGFkYXB0ZXIuc2lnbkluKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZCwgW2FkYXB0ZXJdKTtcbiAgICBjb25zdCBoYW5kbGVDb25uZWN0ID0gdXNlQ2FsbGJhY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICBpZiAoaXNDb25uZWN0aW5nUmVmLmN1cnJlbnQgfHwgaXNEaXNjb25uZWN0aW5nUmVmLmN1cnJlbnQgfHwgd2FsbGV0Py5hZGFwdGVyLmNvbm5lY3RlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCF3YWxsZXQpXG4gICAgICAgICAgICB0aHJvdyBoYW5kbGVFcnJvclJlZi5jdXJyZW50KG5ldyBXYWxsZXROb3RTZWxlY3RlZEVycm9yKCkpO1xuICAgICAgICBjb25zdCB7IGFkYXB0ZXIsIHJlYWR5U3RhdGUgfSA9IHdhbGxldDtcbiAgICAgICAgaWYgKCEocmVhZHlTdGF0ZSA9PT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQgfHwgcmVhZHlTdGF0ZSA9PT0gV2FsbGV0UmVhZHlTdGF0ZS5Mb2FkYWJsZSkpXG4gICAgICAgICAgICB0aHJvdyBoYW5kbGVFcnJvclJlZi5jdXJyZW50KG5ldyBXYWxsZXROb3RSZWFkeUVycm9yKCksIGFkYXB0ZXIpO1xuICAgICAgICBpc0Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHNldENvbm5lY3RpbmcodHJ1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBhZGFwdGVyLmNvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgb25Db25uZWN0RXJyb3IoKTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBzZXRDb25uZWN0aW5nKGZhbHNlKTtcbiAgICAgICAgICAgIGlzQ29ubmVjdGluZ1JlZi5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9LCBbb25Db25uZWN0RXJyb3IsIHdhbGxldF0pO1xuICAgIGNvbnN0IGhhbmRsZURpc2Nvbm5lY3QgPSB1c2VDYWxsYmFjayhhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmIChpc0Rpc2Nvbm5lY3RpbmdSZWYuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCFhZGFwdGVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpc0Rpc2Nvbm5lY3RpbmdSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgIHNldERpc2Nvbm5lY3RpbmcodHJ1ZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBhZGFwdGVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNldERpc2Nvbm5lY3RpbmcoZmFsc2UpO1xuICAgICAgICAgICAgaXNEaXNjb25uZWN0aW5nUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0sIFthZGFwdGVyXSk7XG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFdhbGxldENvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHtcbiAgICAgICAgICAgIGF1dG9Db25uZWN0OiAhIW9uQXV0b0Nvbm5lY3RSZXF1ZXN0LFxuICAgICAgICAgICAgd2FsbGV0cyxcbiAgICAgICAgICAgIHdhbGxldCxcbiAgICAgICAgICAgIHB1YmxpY0tleSxcbiAgICAgICAgICAgIGNvbm5lY3RlZCxcbiAgICAgICAgICAgIGNvbm5lY3RpbmcsXG4gICAgICAgICAgICBkaXNjb25uZWN0aW5nLFxuICAgICAgICAgICAgc2VsZWN0OiBvblNlbGVjdFdhbGxldCxcbiAgICAgICAgICAgIGNvbm5lY3Q6IGhhbmRsZUNvbm5lY3QsXG4gICAgICAgICAgICBkaXNjb25uZWN0OiBoYW5kbGVEaXNjb25uZWN0LFxuICAgICAgICAgICAgc2VuZFRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgc2lnblRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgc2lnbkFsbFRyYW5zYWN0aW9ucyxcbiAgICAgICAgICAgIHNpZ25NZXNzYWdlLFxuICAgICAgICAgICAgc2lnbkluLFxuICAgICAgICB9IH0sIGNoaWxkcmVuKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1XYWxsZXRQcm92aWRlckJhc2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProviderBase.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/errors.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/errors.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   WalletNotSelectedError: function() { return /* binding */ WalletNotSelectedError; }\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n\nclass WalletNotSelectedError extends _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_0__.WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletNotSelectedError';\n    }\n}\n//# sourceMappingURL=errors.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0L2xpYi9lc20vZXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQTBEO0FBQ25ELHFDQUFxQyxvRUFBVztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS9lcnJvcnMuanM/Y2UxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBXYWxsZXRFcnJvciB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZSc7XG5leHBvcnQgY2xhc3MgV2FsbGV0Tm90U2VsZWN0ZWRFcnJvciBleHRlbmRzIFdhbGxldEVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1dhbGxldE5vdFNlbGVjdGVkRXJyb3InO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVycm9ycy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/errors.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/getEnvironment.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/getEnvironment.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Environment: function() { return /* binding */ Environment; },\n/* harmony export */   \"default\": function() { return /* binding */ getEnvironment; }\n/* harmony export */ });\n/* harmony import */ var _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana-mobile/wallet-adapter-mobile */ \"(app-pages-browser)/./node_modules/@solana-mobile/wallet-adapter-mobile/lib/esm/index.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n\n\nvar Environment;\n(function (Environment) {\n    Environment[Environment[\"DESKTOP_WEB\"] = 0] = \"DESKTOP_WEB\";\n    Environment[Environment[\"MOBILE_WEB\"] = 1] = \"MOBILE_WEB\";\n})(Environment || (Environment = {}));\nfunction isWebView(userAgentString) {\n    return /(WebView|Version\\/.+(Chrome)\\/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)|; wv\\).+(Chrome)\\/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+))/i.test(userAgentString);\n}\nfunction getEnvironment({ adapters, userAgentString }) {\n    if (adapters.some((adapter) => adapter.name !== _solana_mobile_wallet_adapter_mobile__WEBPACK_IMPORTED_MODULE_0__.SolanaMobileWalletAdapterWalletName &&\n        adapter.readyState === _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_1__.WalletReadyState.Installed)) {\n        /**\n         * There are only two ways a browser extension adapter should be able to reach `Installed` status:\n         *\n         *     1. Its browser extension is installed.\n         *     2. The app is running on a mobile wallet's in-app browser.\n         *\n         * In either case, we consider the environment to be desktop-like.\n         */\n        return Environment.DESKTOP_WEB;\n    }\n    if (userAgentString &&\n        // Step 1: Check whether we're on a platform that supports MWA at all.\n        /android/i.test(userAgentString) &&\n        // Step 2: Determine that we are *not* running in a WebView.\n        !isWebView(userAgentString)) {\n        return Environment.MOBILE_WEB;\n    }\n    else {\n        return Environment.DESKTOP_WEB;\n    }\n}\n//# sourceMappingURL=getEnvironment.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0L2xpYi9lc20vZ2V0RW52aXJvbm1lbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUEyRjtBQUM1QjtBQUN4RDtBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0NBQWtDO0FBQ25DO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ2UsMEJBQTBCLDJCQUEyQjtBQUNwRSxvREFBb0QscUdBQW1DO0FBQ3ZGLCtCQUErQix5RUFBZ0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS9nZXRFbnZpcm9ubWVudC5qcz82ODM5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lIH0gZnJvbSAnQHNvbGFuYS1tb2JpbGUvd2FsbGV0LWFkYXB0ZXItbW9iaWxlJztcbmltcG9ydCB7IFdhbGxldFJlYWR5U3RhdGUgfSBmcm9tICdAc29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UnO1xuZXhwb3J0IHZhciBFbnZpcm9ubWVudDtcbihmdW5jdGlvbiAoRW52aXJvbm1lbnQpIHtcbiAgICBFbnZpcm9ubWVudFtFbnZpcm9ubWVudFtcIkRFU0tUT1BfV0VCXCJdID0gMF0gPSBcIkRFU0tUT1BfV0VCXCI7XG4gICAgRW52aXJvbm1lbnRbRW52aXJvbm1lbnRbXCJNT0JJTEVfV0VCXCJdID0gMV0gPSBcIk1PQklMRV9XRUJcIjtcbn0pKEVudmlyb25tZW50IHx8IChFbnZpcm9ubWVudCA9IHt9KSk7XG5mdW5jdGlvbiBpc1dlYlZpZXcodXNlckFnZW50U3RyaW5nKSB7XG4gICAgcmV0dXJuIC8oV2ViVmlld3xWZXJzaW9uXFwvLisoQ2hyb21lKVxcLyhcXGQrKVxcLihcXGQrKVxcLihcXGQrKVxcLihcXGQrKXw7IHd2XFwpLisoQ2hyb21lKVxcLyhcXGQrKVxcLihcXGQrKVxcLihcXGQrKVxcLihcXGQrKSkvaS50ZXN0KHVzZXJBZ2VudFN0cmluZyk7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRFbnZpcm9ubWVudCh7IGFkYXB0ZXJzLCB1c2VyQWdlbnRTdHJpbmcgfSkge1xuICAgIGlmIChhZGFwdGVycy5zb21lKChhZGFwdGVyKSA9PiBhZGFwdGVyLm5hbWUgIT09IFNvbGFuYU1vYmlsZVdhbGxldEFkYXB0ZXJXYWxsZXROYW1lICYmXG4gICAgICAgIGFkYXB0ZXIucmVhZHlTdGF0ZSA9PT0gV2FsbGV0UmVhZHlTdGF0ZS5JbnN0YWxsZWQpKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGVyZSBhcmUgb25seSB0d28gd2F5cyBhIGJyb3dzZXIgZXh0ZW5zaW9uIGFkYXB0ZXIgc2hvdWxkIGJlIGFibGUgdG8gcmVhY2ggYEluc3RhbGxlZGAgc3RhdHVzOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgICAgMS4gSXRzIGJyb3dzZXIgZXh0ZW5zaW9uIGlzIGluc3RhbGxlZC5cbiAgICAgICAgICogICAgIDIuIFRoZSBhcHAgaXMgcnVubmluZyBvbiBhIG1vYmlsZSB3YWxsZXQncyBpbi1hcHAgYnJvd3Nlci5cbiAgICAgICAgICpcbiAgICAgICAgICogSW4gZWl0aGVyIGNhc2UsIHdlIGNvbnNpZGVyIHRoZSBlbnZpcm9ubWVudCB0byBiZSBkZXNrdG9wLWxpa2UuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gRW52aXJvbm1lbnQuREVTS1RPUF9XRUI7XG4gICAgfVxuICAgIGlmICh1c2VyQWdlbnRTdHJpbmcgJiZcbiAgICAgICAgLy8gU3RlcCAxOiBDaGVjayB3aGV0aGVyIHdlJ3JlIG9uIGEgcGxhdGZvcm0gdGhhdCBzdXBwb3J0cyBNV0EgYXQgYWxsLlxuICAgICAgICAvYW5kcm9pZC9pLnRlc3QodXNlckFnZW50U3RyaW5nKSAmJlxuICAgICAgICAvLyBTdGVwIDI6IERldGVybWluZSB0aGF0IHdlIGFyZSAqbm90KiBydW5uaW5nIGluIGEgV2ViVmlldy5cbiAgICAgICAgIWlzV2ViVmlldyh1c2VyQWdlbnRTdHJpbmcpKSB7XG4gICAgICAgIHJldHVybiBFbnZpcm9ubWVudC5NT0JJTEVfV0VCO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIEVudmlyb25tZW50LkRFU0tUT1BfV0VCO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldEVudmlyb25tZW50LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/getEnvironment.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/getInferredClusterFromEndpoint.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/getInferredClusterFromEndpoint.js ***!
  \*********************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ getInferredClusterFromEndpoint; }\n/* harmony export */ });\nfunction getInferredClusterFromEndpoint(endpoint) {\n    if (!endpoint) {\n        return 'mainnet-beta';\n    }\n    if (/devnet/i.test(endpoint)) {\n        return 'devnet';\n    }\n    else if (/testnet/i.test(endpoint)) {\n        return 'testnet';\n    }\n    else {\n        return 'mainnet-beta';\n    }\n}\n//# sourceMappingURL=getInferredClusterFromEndpoint.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0L2xpYi9lc20vZ2V0SW5mZXJyZWRDbHVzdGVyRnJvbUVuZHBvaW50LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS9nZXRJbmZlcnJlZENsdXN0ZXJGcm9tRW5kcG9pbnQuanM/ZGMzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRJbmZlcnJlZENsdXN0ZXJGcm9tRW5kcG9pbnQoZW5kcG9pbnQpIHtcbiAgICBpZiAoIWVuZHBvaW50KSB7XG4gICAgICAgIHJldHVybiAnbWFpbm5ldC1iZXRhJztcbiAgICB9XG4gICAgaWYgKC9kZXZuZXQvaS50ZXN0KGVuZHBvaW50KSkge1xuICAgICAgICByZXR1cm4gJ2Rldm5ldCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKC90ZXN0bmV0L2kudGVzdChlbmRwb2ludCkpIHtcbiAgICAgICAgcmV0dXJuICd0ZXN0bmV0JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAnbWFpbm5ldC1iZXRhJztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRJbmZlcnJlZENsdXN0ZXJGcm9tRW5kcG9pbnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/getInferredClusterFromEndpoint.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionContext: function() { return /* binding */ ConnectionContext; },\n/* harmony export */   useConnection: function() { return /* binding */ useConnection; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nconst ConnectionContext = (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)({});\nfunction useConnection() {\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(ConnectionContext);\n}\n//# sourceMappingURL=useConnection.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0L2xpYi9lc20vdXNlQ29ubmVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBa0Q7QUFDM0MsMEJBQTBCLG9EQUFhLEdBQUc7QUFDMUM7QUFDUCxXQUFXLGlEQUFVO0FBQ3JCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItcmVhY3QvbGliL2VzbS91c2VDb25uZWN0aW9uLmpzP2E3YmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCB9IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBjb25zdCBDb25uZWN0aW9uQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQoe30pO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNvbm5lY3Rpb24oKSB7XG4gICAgcmV0dXJuIHVzZUNvbnRleHQoQ29ubmVjdGlvbkNvbnRleHQpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlQ29ubmVjdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/useLocalStorage.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@solana/wallet-adapter-react/lib/esm/useLocalStorage.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useLocalStorage: function() { return /* binding */ useLocalStorage; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\nfunction useLocalStorage(key, defaultState) {\n    const state = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => {\n        try {\n            const value = localStorage.getItem(key);\n            if (value)\n                return JSON.parse(value);\n        }\n        catch (error) {\n            if (typeof window !== 'undefined') {\n                console.error(error);\n            }\n        }\n        return defaultState;\n    });\n    const value = state[0];\n    const isFirstRenderRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(true);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (isFirstRenderRef.current) {\n            isFirstRenderRef.current = false;\n            return;\n        }\n        try {\n            if (value === null) {\n                localStorage.removeItem(key);\n            }\n            else {\n                localStorage.setItem(key, JSON.stringify(value));\n            }\n        }\n        catch (error) {\n            if (typeof window !== 'undefined') {\n                console.error(error);\n            }\n        }\n    }, [value, key]);\n    return state;\n}\n//# sourceMappingURL=useLocalStorage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0L2xpYi9lc20vdXNlTG9jYWxTdG9yYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW9EO0FBQzdDO0FBQ1Asa0JBQWtCLCtDQUFRO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSw2QkFBNkIsNkNBQU07QUFDbkMsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1hZGFwdGVyLXJlYWN0L2xpYi9lc20vdXNlTG9jYWxTdG9yYWdlLmpzP2NlMjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUxvY2FsU3RvcmFnZShrZXksIGRlZmF1bHRTdGF0ZSkge1xuICAgIGNvbnN0IHN0YXRlID0gdXNlU3RhdGUoKCkgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShrZXkpO1xuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWZhdWx0U3RhdGU7XG4gICAgfSk7XG4gICAgY29uc3QgdmFsdWUgPSBzdGF0ZVswXTtcbiAgICBjb25zdCBpc0ZpcnN0UmVuZGVyUmVmID0gdXNlUmVmKHRydWUpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpc0ZpcnN0UmVuZGVyUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIGlzRmlyc3RSZW5kZXJSZWYuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbdmFsdWUsIGtleV0pO1xuICAgIHJldHVybiBzdGF0ZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXVzZUxvY2FsU3RvcmFnZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-adapter-react/lib/esm/useLocalStorage.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-standard-chains/lib/esm/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-chains/lib/esm/index.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SOLANA_CHAINS: function() { return /* binding */ SOLANA_CHAINS; },\n/* harmony export */   SOLANA_DEVNET_CHAIN: function() { return /* binding */ SOLANA_DEVNET_CHAIN; },\n/* harmony export */   SOLANA_LOCALNET_CHAIN: function() { return /* binding */ SOLANA_LOCALNET_CHAIN; },\n/* harmony export */   SOLANA_MAINNET_CHAIN: function() { return /* binding */ SOLANA_MAINNET_CHAIN; },\n/* harmony export */   SOLANA_TESTNET_CHAIN: function() { return /* binding */ SOLANA_TESTNET_CHAIN; },\n/* harmony export */   isSolanaChain: function() { return /* binding */ isSolanaChain; }\n/* harmony export */ });\n/** Solana Mainnet (beta) cluster, e.g. https://api.mainnet-beta.solana.com */\nconst SOLANA_MAINNET_CHAIN = 'solana:mainnet';\n/** Solana Devnet cluster, e.g. https://api.devnet.solana.com */\nconst SOLANA_DEVNET_CHAIN = 'solana:devnet';\n/** Solana Testnet cluster, e.g. https://api.testnet.solana.com */\nconst SOLANA_TESTNET_CHAIN = 'solana:testnet';\n/** Solana Localnet cluster, e.g. http://localhost:8899 */\nconst SOLANA_LOCALNET_CHAIN = 'solana:localnet';\n/** Array of all Solana clusters */\nconst SOLANA_CHAINS = [\n    SOLANA_MAINNET_CHAIN,\n    SOLANA_DEVNET_CHAIN,\n    SOLANA_TESTNET_CHAIN,\n    SOLANA_LOCALNET_CHAIN,\n];\n/**\n * Check if a chain corresponds with one of the Solana clusters.\n */\nfunction isSolanaChain(chain) {\n    return SOLANA_CHAINS.includes(chain);\n}\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC1jaGFpbnMvbGliL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBQTtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtY2hhaW5zL2xpYi9lc20vaW5kZXguanM/MWQ3NiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogU29sYW5hIE1haW5uZXQgKGJldGEpIGNsdXN0ZXIsIGUuZy4gaHR0cHM6Ly9hcGkubWFpbm5ldC1iZXRhLnNvbGFuYS5jb20gKi9cbmV4cG9ydCBjb25zdCBTT0xBTkFfTUFJTk5FVF9DSEFJTiA9ICdzb2xhbmE6bWFpbm5ldCc7XG4vKiogU29sYW5hIERldm5ldCBjbHVzdGVyLCBlLmcuIGh0dHBzOi8vYXBpLmRldm5ldC5zb2xhbmEuY29tICovXG5leHBvcnQgY29uc3QgU09MQU5BX0RFVk5FVF9DSEFJTiA9ICdzb2xhbmE6ZGV2bmV0Jztcbi8qKiBTb2xhbmEgVGVzdG5ldCBjbHVzdGVyLCBlLmcuIGh0dHBzOi8vYXBpLnRlc3RuZXQuc29sYW5hLmNvbSAqL1xuZXhwb3J0IGNvbnN0IFNPTEFOQV9URVNUTkVUX0NIQUlOID0gJ3NvbGFuYTp0ZXN0bmV0Jztcbi8qKiBTb2xhbmEgTG9jYWxuZXQgY2x1c3RlciwgZS5nLiBodHRwOi8vbG9jYWxob3N0Ojg4OTkgKi9cbmV4cG9ydCBjb25zdCBTT0xBTkFfTE9DQUxORVRfQ0hBSU4gPSAnc29sYW5hOmxvY2FsbmV0Jztcbi8qKiBBcnJheSBvZiBhbGwgU29sYW5hIGNsdXN0ZXJzICovXG5leHBvcnQgY29uc3QgU09MQU5BX0NIQUlOUyA9IFtcbiAgICBTT0xBTkFfTUFJTk5FVF9DSEFJTixcbiAgICBTT0xBTkFfREVWTkVUX0NIQUlOLFxuICAgIFNPTEFOQV9URVNUTkVUX0NIQUlOLFxuICAgIFNPTEFOQV9MT0NBTE5FVF9DSEFJTixcbl07XG4vKipcbiAqIENoZWNrIGlmIGEgY2hhaW4gY29ycmVzcG9uZHMgd2l0aCBvbmUgb2YgdGhlIFNvbGFuYSBjbHVzdGVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzU29sYW5hQ2hhaW4oY2hhaW4pIHtcbiAgICByZXR1cm4gU09MQU5BX0NIQUlOUy5pbmNsdWRlcyhjaGFpbik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-standard-chains/lib/esm/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js ***!
  \*****************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaSignAndSendTransaction: function() { return /* binding */ SolanaSignAndSendTransaction; }\n/* harmony export */ });\n/** Name of the feature. */\nconst SolanaSignAndSendTransaction = 'solana:signAndSendTransaction';\n//# sourceMappingURL=signAndSendTransaction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC1mZWF0dXJlcy9saWIvZXNtL3NpZ25BbmRTZW5kVHJhbnNhY3Rpb24uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtZmVhdHVyZXMvbGliL2VzbS9zaWduQW5kU2VuZFRyYW5zYWN0aW9uLmpzPzZmN2UiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIE5hbWUgb2YgdGhlIGZlYXR1cmUuICovXG5leHBvcnQgY29uc3QgU29sYW5hU2lnbkFuZFNlbmRUcmFuc2FjdGlvbiA9ICdzb2xhbmE6c2lnbkFuZFNlbmRUcmFuc2FjdGlvbic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduQW5kU2VuZFRyYW5zYWN0aW9uLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-standard-features/lib/esm/signIn.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-features/lib/esm/signIn.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaSignIn: function() { return /* binding */ SolanaSignIn; }\n/* harmony export */ });\n/** Name of the feature. */\nconst SolanaSignIn = 'solana:signIn';\n//# sourceMappingURL=signIn.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC1mZWF0dXJlcy9saWIvZXNtL3NpZ25Jbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC1mZWF0dXJlcy9saWIvZXNtL3NpZ25Jbi5qcz80NzY4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBOYW1lIG9mIHRoZSBmZWF0dXJlLiAqL1xuZXhwb3J0IGNvbnN0IFNvbGFuYVNpZ25JbiA9ICdzb2xhbmE6c2lnbkluJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25Jbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-standard-features/lib/esm/signIn.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-standard-features/lib/esm/signMessage.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-features/lib/esm/signMessage.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaSignMessage: function() { return /* binding */ SolanaSignMessage; }\n/* harmony export */ });\n/** Name of the feature. */\nconst SolanaSignMessage = 'solana:signMessage';\n//# sourceMappingURL=signMessage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC1mZWF0dXJlcy9saWIvZXNtL3NpZ25NZXNzYWdlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNPO0FBQ1AiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLWZlYXR1cmVzL2xpYi9lc20vc2lnbk1lc3NhZ2UuanM/MDY3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogTmFtZSBvZiB0aGUgZmVhdHVyZS4gKi9cbmV4cG9ydCBjb25zdCBTb2xhbmFTaWduTWVzc2FnZSA9ICdzb2xhbmE6c2lnbk1lc3NhZ2UnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2lnbk1lc3NhZ2UuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-standard-features/lib/esm/signMessage.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SolanaSignTransaction: function() { return /* binding */ SolanaSignTransaction; }\n/* harmony export */ });\n/** Name of the feature. */\nconst SolanaSignTransaction = 'solana:signTransaction';\n//# sourceMappingURL=signTransaction.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC1mZWF0dXJlcy9saWIvZXNtL3NpZ25UcmFuc2FjdGlvbi5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC1mZWF0dXJlcy9saWIvZXNtL3NpZ25UcmFuc2FjdGlvbi5qcz9lOTEwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKiBOYW1lIG9mIHRoZSBmZWF0dXJlLiAqL1xuZXhwb3J0IGNvbnN0IFNvbGFuYVNpZ25UcmFuc2FjdGlvbiA9ICdzb2xhbmE6c2lnblRyYW5zYWN0aW9uJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25UcmFuc2FjdGlvbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-standard-util/lib/esm/commitment.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-util/lib/esm/commitment.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCommitment: function() { return /* binding */ getCommitment; }\n/* harmony export */ });\n/**\n * TODO: docs\n */\nfunction getCommitment(commitment) {\n    switch (commitment) {\n        case 'processed':\n        case 'confirmed':\n        case 'finalized':\n        case undefined:\n            return commitment;\n        case 'recent':\n            return 'processed';\n        case 'single':\n        case 'singleGossip':\n            return 'confirmed';\n        case 'max':\n        case 'root':\n            return 'finalized';\n        default:\n            return undefined;\n    }\n}\n//# sourceMappingURL=commitment.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC11dGlsL2xpYi9lc20vY29tbWl0bWVudC5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtdXRpbC9saWIvZXNtL2NvbW1pdG1lbnQuanM/NDU0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRPRE86IGRvY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbW1pdG1lbnQoY29tbWl0bWVudCkge1xuICAgIHN3aXRjaCAoY29tbWl0bWVudCkge1xuICAgICAgICBjYXNlICdwcm9jZXNzZWQnOlxuICAgICAgICBjYXNlICdjb25maXJtZWQnOlxuICAgICAgICBjYXNlICdmaW5hbGl6ZWQnOlxuICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIHJldHVybiBjb21taXRtZW50O1xuICAgICAgICBjYXNlICdyZWNlbnQnOlxuICAgICAgICAgICAgcmV0dXJuICdwcm9jZXNzZWQnO1xuICAgICAgICBjYXNlICdzaW5nbGUnOlxuICAgICAgICBjYXNlICdzaW5nbGVHb3NzaXAnOlxuICAgICAgICAgICAgcmV0dXJuICdjb25maXJtZWQnO1xuICAgICAgICBjYXNlICdtYXgnOlxuICAgICAgICBjYXNlICdyb290JzpcbiAgICAgICAgICAgIHJldHVybiAnZmluYWxpemVkJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbWl0bWVudC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-standard-util/lib/esm/commitment.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-standard-util/lib/esm/endpoint.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-util/lib/esm/endpoint.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEVNET_ENDPOINT: function() { return /* binding */ DEVNET_ENDPOINT; },\n/* harmony export */   LOCALNET_ENDPOINT: function() { return /* binding */ LOCALNET_ENDPOINT; },\n/* harmony export */   MAINNET_ENDPOINT: function() { return /* binding */ MAINNET_ENDPOINT; },\n/* harmony export */   TESTNET_ENDPOINT: function() { return /* binding */ TESTNET_ENDPOINT; },\n/* harmony export */   getChainForEndpoint: function() { return /* binding */ getChainForEndpoint; },\n/* harmony export */   getEndpointForChain: function() { return /* binding */ getEndpointForChain; }\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/wallet-standard-chains */ \"(app-pages-browser)/./node_modules/@solana/wallet-standard-chains/lib/esm/index.js\");\n\n/** TODO: docs */\nconst MAINNET_ENDPOINT = 'https://api.mainnet-beta.solana.com';\n/** TODO: docs */\nconst DEVNET_ENDPOINT = 'https://api.devnet.solana.com';\n/** TODO: docs */\nconst TESTNET_ENDPOINT = 'https://api.testnet.solana.com';\n/** TODO: docs */\nconst LOCALNET_ENDPOINT = 'http://localhost:8899';\n/**\n * TODO: docs\n */\nfunction getChainForEndpoint(endpoint) {\n    if (endpoint.includes(MAINNET_ENDPOINT))\n        return _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_MAINNET_CHAIN;\n    if (/\\bdevnet\\b/i.test(endpoint))\n        return _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_DEVNET_CHAIN;\n    if (/\\btestnet\\b/i.test(endpoint))\n        return _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_TESTNET_CHAIN;\n    if (/\\blocalhost\\b/i.test(endpoint) || /\\b127\\.0\\.0\\.1\\b/.test(endpoint))\n        return _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_LOCALNET_CHAIN;\n    return _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_MAINNET_CHAIN;\n}\n/**\n * TODO: docs\n */\nfunction getEndpointForChain(chain, endpoint) {\n    if (endpoint)\n        return endpoint;\n    if (chain === _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_MAINNET_CHAIN)\n        return MAINNET_ENDPOINT;\n    if (chain === _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_DEVNET_CHAIN)\n        return DEVNET_ENDPOINT;\n    if (chain === _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_TESTNET_CHAIN)\n        return TESTNET_ENDPOINT;\n    if (chain === _solana_wallet_standard_chains__WEBPACK_IMPORTED_MODULE_0__.SOLANA_LOCALNET_CHAIN)\n        return LOCALNET_ENDPOINT;\n    return MAINNET_ENDPOINT;\n}\n//# sourceMappingURL=endpoint.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC11dGlsL2xpYi9lc20vZW5kcG9pbnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUF5STtBQUN6STtBQUNPO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBLGVBQWUsZ0ZBQW9CO0FBQ25DO0FBQ0EsZUFBZSwrRUFBbUI7QUFDbEM7QUFDQSxlQUFlLGdGQUFvQjtBQUNuQztBQUNBLGVBQWUsaUZBQXFCO0FBQ3BDLFdBQVcsZ0ZBQW9CO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0Esa0JBQWtCLGdGQUFvQjtBQUN0QztBQUNBLGtCQUFrQiwrRUFBbUI7QUFDckM7QUFDQSxrQkFBa0IsZ0ZBQW9CO0FBQ3RDO0FBQ0Esa0JBQWtCLGlGQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtdXRpbC9saWIvZXNtL2VuZHBvaW50LmpzPzViYjAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU09MQU5BX0RFVk5FVF9DSEFJTiwgU09MQU5BX0xPQ0FMTkVUX0NIQUlOLCBTT0xBTkFfTUFJTk5FVF9DSEFJTiwgU09MQU5BX1RFU1RORVRfQ0hBSU4sIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtY2hhaW5zJztcbi8qKiBUT0RPOiBkb2NzICovXG5leHBvcnQgY29uc3QgTUFJTk5FVF9FTkRQT0lOVCA9ICdodHRwczovL2FwaS5tYWlubmV0LWJldGEuc29sYW5hLmNvbSc7XG4vKiogVE9ETzogZG9jcyAqL1xuZXhwb3J0IGNvbnN0IERFVk5FVF9FTkRQT0lOVCA9ICdodHRwczovL2FwaS5kZXZuZXQuc29sYW5hLmNvbSc7XG4vKiogVE9ETzogZG9jcyAqL1xuZXhwb3J0IGNvbnN0IFRFU1RORVRfRU5EUE9JTlQgPSAnaHR0cHM6Ly9hcGkudGVzdG5ldC5zb2xhbmEuY29tJztcbi8qKiBUT0RPOiBkb2NzICovXG5leHBvcnQgY29uc3QgTE9DQUxORVRfRU5EUE9JTlQgPSAnaHR0cDovL2xvY2FsaG9zdDo4ODk5Jztcbi8qKlxuICogVE9ETzogZG9jc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q2hhaW5Gb3JFbmRwb2ludChlbmRwb2ludCkge1xuICAgIGlmIChlbmRwb2ludC5pbmNsdWRlcyhNQUlOTkVUX0VORFBPSU5UKSlcbiAgICAgICAgcmV0dXJuIFNPTEFOQV9NQUlOTkVUX0NIQUlOO1xuICAgIGlmICgvXFxiZGV2bmV0XFxiL2kudGVzdChlbmRwb2ludCkpXG4gICAgICAgIHJldHVybiBTT0xBTkFfREVWTkVUX0NIQUlOO1xuICAgIGlmICgvXFxidGVzdG5ldFxcYi9pLnRlc3QoZW5kcG9pbnQpKVxuICAgICAgICByZXR1cm4gU09MQU5BX1RFU1RORVRfQ0hBSU47XG4gICAgaWYgKC9cXGJsb2NhbGhvc3RcXGIvaS50ZXN0KGVuZHBvaW50KSB8fCAvXFxiMTI3XFwuMFxcLjBcXC4xXFxiLy50ZXN0KGVuZHBvaW50KSlcbiAgICAgICAgcmV0dXJuIFNPTEFOQV9MT0NBTE5FVF9DSEFJTjtcbiAgICByZXR1cm4gU09MQU5BX01BSU5ORVRfQ0hBSU47XG59XG4vKipcbiAqIFRPRE86IGRvY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVuZHBvaW50Rm9yQ2hhaW4oY2hhaW4sIGVuZHBvaW50KSB7XG4gICAgaWYgKGVuZHBvaW50KVxuICAgICAgICByZXR1cm4gZW5kcG9pbnQ7XG4gICAgaWYgKGNoYWluID09PSBTT0xBTkFfTUFJTk5FVF9DSEFJTilcbiAgICAgICAgcmV0dXJuIE1BSU5ORVRfRU5EUE9JTlQ7XG4gICAgaWYgKGNoYWluID09PSBTT0xBTkFfREVWTkVUX0NIQUlOKVxuICAgICAgICByZXR1cm4gREVWTkVUX0VORFBPSU5UO1xuICAgIGlmIChjaGFpbiA9PT0gU09MQU5BX1RFU1RORVRfQ0hBSU4pXG4gICAgICAgIHJldHVybiBURVNUTkVUX0VORFBPSU5UO1xuICAgIGlmIChjaGFpbiA9PT0gU09MQU5BX0xPQ0FMTkVUX0NIQUlOKVxuICAgICAgICByZXR1cm4gTE9DQUxORVRfRU5EUE9JTlQ7XG4gICAgcmV0dXJuIE1BSU5ORVRfRU5EUE9JTlQ7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbmRwb2ludC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-standard-util/lib/esm/endpoint.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-standard-util/lib/esm/signIn.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-util/lib/esm/signIn.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createSignInMessage: function() { return /* binding */ createSignInMessage; },\n/* harmony export */   createSignInMessageText: function() { return /* binding */ createSignInMessageText; },\n/* harmony export */   deriveSignInMessage: function() { return /* binding */ deriveSignInMessage; },\n/* harmony export */   deriveSignInMessageText: function() { return /* binding */ deriveSignInMessageText; },\n/* harmony export */   parseSignInMessage: function() { return /* binding */ parseSignInMessage; },\n/* harmony export */   parseSignInMessageText: function() { return /* binding */ parseSignInMessageText; },\n/* harmony export */   verifySignIn: function() { return /* binding */ verifySignIn; }\n/* harmony export */ });\n/* harmony import */ var _signMessage_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./signMessage.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-standard-util/lib/esm/signMessage.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-standard-util/lib/esm/util.js\");\n\n\n/**\n * TODO: docs\n */\nfunction verifySignIn(input, output) {\n    const { signedMessage, signature, account: { publicKey }, } = output;\n    const message = deriveSignInMessage(input, output);\n    return !!message && (0,_signMessage_js__WEBPACK_IMPORTED_MODULE_0__.verifyMessageSignature)({ message, signedMessage, signature, publicKey });\n}\n/**\n * TODO: docs\n */\nfunction deriveSignInMessage(input, output) {\n    const text = deriveSignInMessageText(input, output);\n    if (!text)\n        return null;\n    return new TextEncoder().encode(text);\n}\n/**\n * TODO: docs\n */\nfunction deriveSignInMessageText(input, output) {\n    const parsed = parseSignInMessage(output.signedMessage);\n    if (!parsed)\n        return null;\n    if (input.domain && input.domain !== parsed.domain)\n        return null;\n    if (input.address && input.address !== parsed.address)\n        return null;\n    if (input.statement !== parsed.statement)\n        return null;\n    if (input.uri !== parsed.uri)\n        return null;\n    if (input.version !== parsed.version)\n        return null;\n    if (input.chainId !== parsed.chainId)\n        return null;\n    if (input.nonce !== parsed.nonce)\n        return null;\n    if (input.issuedAt !== parsed.issuedAt)\n        return null;\n    if (input.expirationTime !== parsed.expirationTime)\n        return null;\n    if (input.notBefore !== parsed.notBefore)\n        return null;\n    if (input.requestId !== parsed.requestId)\n        return null;\n    if (input.resources) {\n        if (!parsed.resources)\n            return null;\n        if (!(0,_util_js__WEBPACK_IMPORTED_MODULE_1__.arraysEqual)(input.resources, parsed.resources))\n            return null;\n    }\n    else if (parsed.resources)\n        return null;\n    return createSignInMessageText(parsed);\n}\n/**\n * TODO: docs\n */\nfunction parseSignInMessage(message) {\n    const text = new TextDecoder().decode(message);\n    return parseSignInMessageText(text);\n}\n// TODO: implement https://github.com/solana-labs/solana/blob/master/docs/src/proposals/off-chain-message-signing.md\nconst DOMAIN = '(?<domain>[^\\\\n]+?) wants you to sign in with your Solana account:\\\\n';\nconst ADDRESS = '(?<address>[^\\\\n]+)(?:\\\\n|$)';\nconst STATEMENT = '(?:\\\\n(?<statement>[\\\\S\\\\s]*?)(?:\\\\n|$))??';\nconst URI = '(?:\\\\nURI: (?<uri>[^\\\\n]+))?';\nconst VERSION = '(?:\\\\nVersion: (?<version>[^\\\\n]+))?';\nconst CHAIN_ID = '(?:\\\\nChain ID: (?<chainId>[^\\\\n]+))?';\nconst NONCE = '(?:\\\\nNonce: (?<nonce>[^\\\\n]+))?';\nconst ISSUED_AT = '(?:\\\\nIssued At: (?<issuedAt>[^\\\\n]+))?';\nconst EXPIRATION_TIME = '(?:\\\\nExpiration Time: (?<expirationTime>[^\\\\n]+))?';\nconst NOT_BEFORE = '(?:\\\\nNot Before: (?<notBefore>[^\\\\n]+))?';\nconst REQUEST_ID = '(?:\\\\nRequest ID: (?<requestId>[^\\\\n]+))?';\nconst RESOURCES = '(?:\\\\nResources:(?<resources>(?:\\\\n- [^\\\\n]+)*))?';\nconst FIELDS = `${URI}${VERSION}${CHAIN_ID}${NONCE}${ISSUED_AT}${EXPIRATION_TIME}${NOT_BEFORE}${REQUEST_ID}${RESOURCES}`;\nconst MESSAGE = new RegExp(`^${DOMAIN}${ADDRESS}${STATEMENT}${FIELDS}\\\\n*$`);\n/**\n * TODO: docs\n */\nfunction parseSignInMessageText(text) {\n    const match = MESSAGE.exec(text);\n    if (!match)\n        return null;\n    const groups = match.groups;\n    if (!groups)\n        return null;\n    return {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        domain: groups.domain,\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        address: groups.address,\n        statement: groups.statement,\n        uri: groups.uri,\n        version: groups.version,\n        nonce: groups.nonce,\n        chainId: groups.chainId,\n        issuedAt: groups.issuedAt,\n        expirationTime: groups.expirationTime,\n        notBefore: groups.notBefore,\n        requestId: groups.requestId,\n        resources: groups.resources?.split('\\n- ').slice(1),\n    };\n}\n/**\n * TODO: docs\n */\nfunction createSignInMessage(input) {\n    const text = createSignInMessageText(input);\n    return new TextEncoder().encode(text);\n}\n/**\n * TODO: docs\n */\nfunction createSignInMessageText(input) {\n    // ${domain} wants you to sign in with your Solana account:\n    // ${address}\n    //\n    // ${statement}\n    //\n    // URI: ${uri}\n    // Version: ${version}\n    // Chain ID: ${chain}\n    // Nonce: ${nonce}\n    // Issued At: ${issued-at}\n    // Expiration Time: ${expiration-time}\n    // Not Before: ${not-before}\n    // Request ID: ${request-id}\n    // Resources:\n    // - ${resources[0]}\n    // - ${resources[1]}\n    // ...\n    // - ${resources[n]}\n    let message = `${input.domain} wants you to sign in with your Solana account:\\n`;\n    message += `${input.address}`;\n    if (input.statement) {\n        message += `\\n\\n${input.statement}`;\n    }\n    const fields = [];\n    if (input.uri) {\n        fields.push(`URI: ${input.uri}`);\n    }\n    if (input.version) {\n        fields.push(`Version: ${input.version}`);\n    }\n    if (input.chainId) {\n        fields.push(`Chain ID: ${input.chainId}`);\n    }\n    if (input.nonce) {\n        fields.push(`Nonce: ${input.nonce}`);\n    }\n    if (input.issuedAt) {\n        fields.push(`Issued At: ${input.issuedAt}`);\n    }\n    if (input.expirationTime) {\n        fields.push(`Expiration Time: ${input.expirationTime}`);\n    }\n    if (input.notBefore) {\n        fields.push(`Not Before: ${input.notBefore}`);\n    }\n    if (input.requestId) {\n        fields.push(`Request ID: ${input.requestId}`);\n    }\n    if (input.resources) {\n        fields.push(`Resources:`);\n        for (const resource of input.resources) {\n            fields.push(`- ${resource}`);\n        }\n    }\n    if (fields.length) {\n        message += `\\n\\n${fields.join('\\n')}`;\n    }\n    return message;\n}\n//# sourceMappingURL=signIn.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC11dGlsL2xpYi9lc20vc2lnbkluLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUEwRDtBQUNsQjtBQUN4QztBQUNBO0FBQ0E7QUFDTztBQUNQLFlBQVkscUNBQXFDLFdBQVcsSUFBSTtBQUNoRTtBQUNBLHdCQUF3Qix1RUFBc0IsR0FBRyw4Q0FBOEM7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxxREFBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLElBQUksRUFBRSxRQUFRLEVBQUUsU0FBUyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQUUsZ0JBQWdCLEVBQUUsV0FBVyxFQUFFLFdBQVcsRUFBRSxVQUFVO0FBQ3ZILCtCQUErQixPQUFPLEVBQUUsUUFBUSxFQUFFLFVBQVUsRUFBRSxPQUFPO0FBQ3JFO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxTQUFTLFFBQVE7QUFDakIsU0FBUztBQUNUO0FBQ0EsU0FBUztBQUNUO0FBQ0EsY0FBYztBQUNkLGtCQUFrQjtBQUNsQixtQkFBbUI7QUFDbkIsZ0JBQWdCO0FBQ2hCLG9CQUFvQjtBQUNwQiwwQkFBMEI7QUFDMUIscUJBQXFCO0FBQ3JCLHFCQUFxQjtBQUNyQjtBQUNBLFdBQVc7QUFDWCxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1gscUJBQXFCLGNBQWM7QUFDbkMsa0JBQWtCLGNBQWM7QUFDaEM7QUFDQSwwQkFBMEIsZ0JBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0EsaUNBQWlDLGNBQWM7QUFDL0M7QUFDQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDO0FBQ0E7QUFDQSxrQ0FBa0MsZUFBZTtBQUNqRDtBQUNBO0FBQ0Esd0NBQXdDLHFCQUFxQjtBQUM3RDtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixTQUFTO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixrQkFBa0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXV0aWwvbGliL2VzbS9zaWduSW4uanM/MTg4OCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB2ZXJpZnlNZXNzYWdlU2lnbmF0dXJlIH0gZnJvbSAnLi9zaWduTWVzc2FnZS5qcyc7XG5pbXBvcnQgeyBhcnJheXNFcXVhbCB9IGZyb20gJy4vdXRpbC5qcyc7XG4vKipcbiAqIFRPRE86IGRvY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVNpZ25JbihpbnB1dCwgb3V0cHV0KSB7XG4gICAgY29uc3QgeyBzaWduZWRNZXNzYWdlLCBzaWduYXR1cmUsIGFjY291bnQ6IHsgcHVibGljS2V5IH0sIH0gPSBvdXRwdXQ7XG4gICAgY29uc3QgbWVzc2FnZSA9IGRlcml2ZVNpZ25Jbk1lc3NhZ2UoaW5wdXQsIG91dHB1dCk7XG4gICAgcmV0dXJuICEhbWVzc2FnZSAmJiB2ZXJpZnlNZXNzYWdlU2lnbmF0dXJlKHsgbWVzc2FnZSwgc2lnbmVkTWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkgfSk7XG59XG4vKipcbiAqIFRPRE86IGRvY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZVNpZ25Jbk1lc3NhZ2UoaW5wdXQsIG91dHB1dCkge1xuICAgIGNvbnN0IHRleHQgPSBkZXJpdmVTaWduSW5NZXNzYWdlVGV4dChpbnB1dCwgb3V0cHV0KTtcbiAgICBpZiAoIXRleHQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIHJldHVybiBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodGV4dCk7XG59XG4vKipcbiAqIFRPRE86IGRvY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlcml2ZVNpZ25Jbk1lc3NhZ2VUZXh0KGlucHV0LCBvdXRwdXQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZVNpZ25Jbk1lc3NhZ2Uob3V0cHV0LnNpZ25lZE1lc3NhZ2UpO1xuICAgIGlmICghcGFyc2VkKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaW5wdXQuZG9tYWluICYmIGlucHV0LmRvbWFpbiAhPT0gcGFyc2VkLmRvbWFpbilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGlucHV0LmFkZHJlc3MgJiYgaW5wdXQuYWRkcmVzcyAhPT0gcGFyc2VkLmFkZHJlc3MpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChpbnB1dC5zdGF0ZW1lbnQgIT09IHBhcnNlZC5zdGF0ZW1lbnQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChpbnB1dC51cmkgIT09IHBhcnNlZC51cmkpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChpbnB1dC52ZXJzaW9uICE9PSBwYXJzZWQudmVyc2lvbilcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGlucHV0LmNoYWluSWQgIT09IHBhcnNlZC5jaGFpbklkKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaW5wdXQubm9uY2UgIT09IHBhcnNlZC5ub25jZSlcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgaWYgKGlucHV0Lmlzc3VlZEF0ICE9PSBwYXJzZWQuaXNzdWVkQXQpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGlmIChpbnB1dC5leHBpcmF0aW9uVGltZSAhPT0gcGFyc2VkLmV4cGlyYXRpb25UaW1lKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaW5wdXQubm90QmVmb3JlICE9PSBwYXJzZWQubm90QmVmb3JlKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaW5wdXQucmVxdWVzdElkICE9PSBwYXJzZWQucmVxdWVzdElkKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICBpZiAoaW5wdXQucmVzb3VyY2VzKSB7XG4gICAgICAgIGlmICghcGFyc2VkLnJlc291cmNlcylcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBpZiAoIWFycmF5c0VxdWFsKGlucHV0LnJlc291cmNlcywgcGFyc2VkLnJlc291cmNlcykpXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFyc2VkLnJlc291cmNlcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIGNyZWF0ZVNpZ25Jbk1lc3NhZ2VUZXh0KHBhcnNlZCk7XG59XG4vKipcbiAqIFRPRE86IGRvY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU2lnbkluTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgY29uc3QgdGV4dCA9IG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShtZXNzYWdlKTtcbiAgICByZXR1cm4gcGFyc2VTaWduSW5NZXNzYWdlVGV4dCh0ZXh0KTtcbn1cbi8vIFRPRE86IGltcGxlbWVudCBodHRwczovL2dpdGh1Yi5jb20vc29sYW5hLWxhYnMvc29sYW5hL2Jsb2IvbWFzdGVyL2RvY3Mvc3JjL3Byb3Bvc2Fscy9vZmYtY2hhaW4tbWVzc2FnZS1zaWduaW5nLm1kXG5jb25zdCBET01BSU4gPSAnKD88ZG9tYWluPlteXFxcXG5dKz8pIHdhbnRzIHlvdSB0byBzaWduIGluIHdpdGggeW91ciBTb2xhbmEgYWNjb3VudDpcXFxcbic7XG5jb25zdCBBRERSRVNTID0gJyg/PGFkZHJlc3M+W15cXFxcbl0rKSg/OlxcXFxufCQpJztcbmNvbnN0IFNUQVRFTUVOVCA9ICcoPzpcXFxcbig/PHN0YXRlbWVudD5bXFxcXFNcXFxcc10qPykoPzpcXFxcbnwkKSk/Pyc7XG5jb25zdCBVUkkgPSAnKD86XFxcXG5VUkk6ICg/PHVyaT5bXlxcXFxuXSspKT8nO1xuY29uc3QgVkVSU0lPTiA9ICcoPzpcXFxcblZlcnNpb246ICg/PHZlcnNpb24+W15cXFxcbl0rKSk/JztcbmNvbnN0IENIQUlOX0lEID0gJyg/OlxcXFxuQ2hhaW4gSUQ6ICg/PGNoYWluSWQ+W15cXFxcbl0rKSk/JztcbmNvbnN0IE5PTkNFID0gJyg/OlxcXFxuTm9uY2U6ICg/PG5vbmNlPlteXFxcXG5dKykpPyc7XG5jb25zdCBJU1NVRURfQVQgPSAnKD86XFxcXG5Jc3N1ZWQgQXQ6ICg/PGlzc3VlZEF0PlteXFxcXG5dKykpPyc7XG5jb25zdCBFWFBJUkFUSU9OX1RJTUUgPSAnKD86XFxcXG5FeHBpcmF0aW9uIFRpbWU6ICg/PGV4cGlyYXRpb25UaW1lPlteXFxcXG5dKykpPyc7XG5jb25zdCBOT1RfQkVGT1JFID0gJyg/OlxcXFxuTm90IEJlZm9yZTogKD88bm90QmVmb3JlPlteXFxcXG5dKykpPyc7XG5jb25zdCBSRVFVRVNUX0lEID0gJyg/OlxcXFxuUmVxdWVzdCBJRDogKD88cmVxdWVzdElkPlteXFxcXG5dKykpPyc7XG5jb25zdCBSRVNPVVJDRVMgPSAnKD86XFxcXG5SZXNvdXJjZXM6KD88cmVzb3VyY2VzPig/OlxcXFxuLSBbXlxcXFxuXSspKikpPyc7XG5jb25zdCBGSUVMRFMgPSBgJHtVUkl9JHtWRVJTSU9OfSR7Q0hBSU5fSUR9JHtOT05DRX0ke0lTU1VFRF9BVH0ke0VYUElSQVRJT05fVElNRX0ke05PVF9CRUZPUkV9JHtSRVFVRVNUX0lEfSR7UkVTT1VSQ0VTfWA7XG5jb25zdCBNRVNTQUdFID0gbmV3IFJlZ0V4cChgXiR7RE9NQUlOfSR7QUREUkVTU30ke1NUQVRFTUVOVH0ke0ZJRUxEU31cXFxcbiokYCk7XG4vKipcbiAqIFRPRE86IGRvY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU2lnbkluTWVzc2FnZVRleHQodGV4dCkge1xuICAgIGNvbnN0IG1hdGNoID0gTUVTU0FHRS5leGVjKHRleHQpO1xuICAgIGlmICghbWF0Y2gpXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNvbnN0IGdyb3VwcyA9IG1hdGNoLmdyb3VwcztcbiAgICBpZiAoIWdyb3VwcylcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgZG9tYWluOiBncm91cHMuZG9tYWluLFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICBhZGRyZXNzOiBncm91cHMuYWRkcmVzcyxcbiAgICAgICAgc3RhdGVtZW50OiBncm91cHMuc3RhdGVtZW50LFxuICAgICAgICB1cmk6IGdyb3Vwcy51cmksXG4gICAgICAgIHZlcnNpb246IGdyb3Vwcy52ZXJzaW9uLFxuICAgICAgICBub25jZTogZ3JvdXBzLm5vbmNlLFxuICAgICAgICBjaGFpbklkOiBncm91cHMuY2hhaW5JZCxcbiAgICAgICAgaXNzdWVkQXQ6IGdyb3Vwcy5pc3N1ZWRBdCxcbiAgICAgICAgZXhwaXJhdGlvblRpbWU6IGdyb3Vwcy5leHBpcmF0aW9uVGltZSxcbiAgICAgICAgbm90QmVmb3JlOiBncm91cHMubm90QmVmb3JlLFxuICAgICAgICByZXF1ZXN0SWQ6IGdyb3Vwcy5yZXF1ZXN0SWQsXG4gICAgICAgIHJlc291cmNlczogZ3JvdXBzLnJlc291cmNlcz8uc3BsaXQoJ1xcbi0gJykuc2xpY2UoMSksXG4gICAgfTtcbn1cbi8qKlxuICogVE9ETzogZG9jc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2lnbkluTWVzc2FnZShpbnB1dCkge1xuICAgIGNvbnN0IHRleHQgPSBjcmVhdGVTaWduSW5NZXNzYWdlVGV4dChpbnB1dCk7XG4gICAgcmV0dXJuIG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0ZXh0KTtcbn1cbi8qKlxuICogVE9ETzogZG9jc1xuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlU2lnbkluTWVzc2FnZVRleHQoaW5wdXQpIHtcbiAgICAvLyAke2RvbWFpbn0gd2FudHMgeW91IHRvIHNpZ24gaW4gd2l0aCB5b3VyIFNvbGFuYSBhY2NvdW50OlxuICAgIC8vICR7YWRkcmVzc31cbiAgICAvL1xuICAgIC8vICR7c3RhdGVtZW50fVxuICAgIC8vXG4gICAgLy8gVVJJOiAke3VyaX1cbiAgICAvLyBWZXJzaW9uOiAke3ZlcnNpb259XG4gICAgLy8gQ2hhaW4gSUQ6ICR7Y2hhaW59XG4gICAgLy8gTm9uY2U6ICR7bm9uY2V9XG4gICAgLy8gSXNzdWVkIEF0OiAke2lzc3VlZC1hdH1cbiAgICAvLyBFeHBpcmF0aW9uIFRpbWU6ICR7ZXhwaXJhdGlvbi10aW1lfVxuICAgIC8vIE5vdCBCZWZvcmU6ICR7bm90LWJlZm9yZX1cbiAgICAvLyBSZXF1ZXN0IElEOiAke3JlcXVlc3QtaWR9XG4gICAgLy8gUmVzb3VyY2VzOlxuICAgIC8vIC0gJHtyZXNvdXJjZXNbMF19XG4gICAgLy8gLSAke3Jlc291cmNlc1sxXX1cbiAgICAvLyAuLi5cbiAgICAvLyAtICR7cmVzb3VyY2VzW25dfVxuICAgIGxldCBtZXNzYWdlID0gYCR7aW5wdXQuZG9tYWlufSB3YW50cyB5b3UgdG8gc2lnbiBpbiB3aXRoIHlvdXIgU29sYW5hIGFjY291bnQ6XFxuYDtcbiAgICBtZXNzYWdlICs9IGAke2lucHV0LmFkZHJlc3N9YDtcbiAgICBpZiAoaW5wdXQuc3RhdGVtZW50KSB7XG4gICAgICAgIG1lc3NhZ2UgKz0gYFxcblxcbiR7aW5wdXQuc3RhdGVtZW50fWA7XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgIGlmIChpbnB1dC51cmkpIHtcbiAgICAgICAgZmllbGRzLnB1c2goYFVSSTogJHtpbnB1dC51cml9YCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC52ZXJzaW9uKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGBWZXJzaW9uOiAke2lucHV0LnZlcnNpb259YCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5jaGFpbklkKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGBDaGFpbiBJRDogJHtpbnB1dC5jaGFpbklkfWApO1xuICAgIH1cbiAgICBpZiAoaW5wdXQubm9uY2UpIHtcbiAgICAgICAgZmllbGRzLnB1c2goYE5vbmNlOiAke2lucHV0Lm5vbmNlfWApO1xuICAgIH1cbiAgICBpZiAoaW5wdXQuaXNzdWVkQXQpIHtcbiAgICAgICAgZmllbGRzLnB1c2goYElzc3VlZCBBdDogJHtpbnB1dC5pc3N1ZWRBdH1gKTtcbiAgICB9XG4gICAgaWYgKGlucHV0LmV4cGlyYXRpb25UaW1lKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGBFeHBpcmF0aW9uIFRpbWU6ICR7aW5wdXQuZXhwaXJhdGlvblRpbWV9YCk7XG4gICAgfVxuICAgIGlmIChpbnB1dC5ub3RCZWZvcmUpIHtcbiAgICAgICAgZmllbGRzLnB1c2goYE5vdCBCZWZvcmU6ICR7aW5wdXQubm90QmVmb3JlfWApO1xuICAgIH1cbiAgICBpZiAoaW5wdXQucmVxdWVzdElkKSB7XG4gICAgICAgIGZpZWxkcy5wdXNoKGBSZXF1ZXN0IElEOiAke2lucHV0LnJlcXVlc3RJZH1gKTtcbiAgICB9XG4gICAgaWYgKGlucHV0LnJlc291cmNlcykge1xuICAgICAgICBmaWVsZHMucHVzaChgUmVzb3VyY2VzOmApO1xuICAgICAgICBmb3IgKGNvbnN0IHJlc291cmNlIG9mIGlucHV0LnJlc291cmNlcykge1xuICAgICAgICAgICAgZmllbGRzLnB1c2goYC0gJHtyZXNvdXJjZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoZmllbGRzLmxlbmd0aCkge1xuICAgICAgICBtZXNzYWdlICs9IGBcXG5cXG4ke2ZpZWxkcy5qb2luKCdcXG4nKX1gO1xuICAgIH1cbiAgICByZXR1cm4gbWVzc2FnZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNpZ25Jbi5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-standard-util/lib/esm/signIn.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-standard-util/lib/esm/signMessage.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-util/lib/esm/signMessage.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   verifyMessageSignature: function() { return /* binding */ verifyMessageSignature; },\n/* harmony export */   verifySignMessage: function() { return /* binding */ verifySignMessage; }\n/* harmony export */ });\n/* harmony import */ var _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/curves/ed25519 */ \"(app-pages-browser)/./node_modules/@noble/curves/esm/ed25519.js\");\n/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util.js */ \"(app-pages-browser)/./node_modules/@solana/wallet-standard-util/lib/esm/util.js\");\n\n\n/**\n * TODO: docs\n */\nfunction verifyMessageSignature({ message, signedMessage, signature, publicKey, }) {\n    // TODO: implement https://github.com/solana-labs/solana/blob/master/docs/src/proposals/off-chain-message-signing.md\n    return (0,_util_js__WEBPACK_IMPORTED_MODULE_0__.bytesEqual)(message, signedMessage) && _noble_curves_ed25519__WEBPACK_IMPORTED_MODULE_1__.ed25519.verify(signature, signedMessage, publicKey);\n}\n/**\n * TODO: docs\n */\nfunction verifySignMessage(input, output) {\n    const { message, account: { publicKey }, } = input;\n    const { signedMessage, signature } = output;\n    return verifyMessageSignature({ message, signedMessage, signature, publicKey });\n}\n//# sourceMappingURL=signMessage.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC11dGlsL2xpYi9lc20vc2lnbk1lc3NhZ2UuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRDtBQUNUO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNPLGtDQUFrQywrQ0FBK0M7QUFDeEY7QUFDQSxXQUFXLG9EQUFVLDRCQUE0QiwwREFBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsWUFBWSxvQkFBb0IsV0FBVyxJQUFJO0FBQy9DLFlBQVksMkJBQTJCO0FBQ3ZDLG9DQUFvQyw4Q0FBOEM7QUFDbEY7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtdXRpbC9saWIvZXNtL3NpZ25NZXNzYWdlLmpzP2Q1ZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZWQyNTUxOSB9IGZyb20gJ0Bub2JsZS9jdXJ2ZXMvZWQyNTUxOSc7XG5pbXBvcnQgeyBieXRlc0VxdWFsIH0gZnJvbSAnLi91dGlsLmpzJztcbi8qKlxuICogVE9ETzogZG9jc1xuICovXG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5TWVzc2FnZVNpZ25hdHVyZSh7IG1lc3NhZ2UsIHNpZ25lZE1lc3NhZ2UsIHNpZ25hdHVyZSwgcHVibGljS2V5LCB9KSB7XG4gICAgLy8gVE9ETzogaW1wbGVtZW50IGh0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy9zb2xhbmEvYmxvYi9tYXN0ZXIvZG9jcy9zcmMvcHJvcG9zYWxzL29mZi1jaGFpbi1tZXNzYWdlLXNpZ25pbmcubWRcbiAgICByZXR1cm4gYnl0ZXNFcXVhbChtZXNzYWdlLCBzaWduZWRNZXNzYWdlKSAmJiBlZDI1NTE5LnZlcmlmeShzaWduYXR1cmUsIHNpZ25lZE1lc3NhZ2UsIHB1YmxpY0tleSk7XG59XG4vKipcbiAqIFRPRE86IGRvY3NcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHZlcmlmeVNpZ25NZXNzYWdlKGlucHV0LCBvdXRwdXQpIHtcbiAgICBjb25zdCB7IG1lc3NhZ2UsIGFjY291bnQ6IHsgcHVibGljS2V5IH0sIH0gPSBpbnB1dDtcbiAgICBjb25zdCB7IHNpZ25lZE1lc3NhZ2UsIHNpZ25hdHVyZSB9ID0gb3V0cHV0O1xuICAgIHJldHVybiB2ZXJpZnlNZXNzYWdlU2lnbmF0dXJlKHsgbWVzc2FnZSwgc2lnbmVkTWVzc2FnZSwgc2lnbmF0dXJlLCBwdWJsaWNLZXkgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zaWduTWVzc2FnZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-standard-util/lib/esm/signMessage.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-standard-util/lib/esm/util.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-util/lib/esm/util.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arraysEqual: function() { return /* binding */ arraysEqual; },\n/* harmony export */   bytesEqual: function() { return /* binding */ bytesEqual; }\n/* harmony export */ });\n/**\n * @internal\n *\n * Efficiently compare {@link Indexed} arrays (e.g. `Array` and `Uint8Array`).\n *\n * @param a An array.\n * @param b Another array.\n *\n * @return `true` if the arrays have the same length and elements, `false` otherwise.\n *\n * @group Internal\n */\nfunction arraysEqual(a, b) {\n    if (a === b)\n        return true;\n    const length = a.length;\n    if (length !== b.length)\n        return false;\n    for (let i = 0; i < length; i++) {\n        if (a[i] !== b[i])\n            return false;\n    }\n    return true;\n}\n/**\n * @internal\n *\n * Efficiently compare byte arrays, using {@link arraysEqual}.\n *\n * @param a A byte array.\n * @param b Another byte array.\n *\n * @return `true` if the byte arrays have the same length and bytes, `false` otherwise.\n *\n * @group Internal\n */\nfunction bytesEqual(a, b) {\n    return arraysEqual(a, b);\n}\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC11dGlsL2xpYi9lc20vdXRpbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixlQUFlO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGtCQUFrQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXV0aWwvbGliL2VzbS91dGlsLmpzPzcxYTciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBFZmZpY2llbnRseSBjb21wYXJlIHtAbGluayBJbmRleGVkfSBhcnJheXMgKGUuZy4gYEFycmF5YCBhbmQgYFVpbnQ4QXJyYXlgKS5cbiAqXG4gKiBAcGFyYW0gYSBBbiBhcnJheS5cbiAqIEBwYXJhbSBiIEFub3RoZXIgYXJyYXkuXG4gKlxuICogQHJldHVybiBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBoYXZlIHRoZSBzYW1lIGxlbmd0aCBhbmQgZWxlbWVudHMsIGBmYWxzZWAgb3RoZXJ3aXNlLlxuICpcbiAqIEBncm91cCBJbnRlcm5hbFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlzRXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqXG4gKiBFZmZpY2llbnRseSBjb21wYXJlIGJ5dGUgYXJyYXlzLCB1c2luZyB7QGxpbmsgYXJyYXlzRXF1YWx9LlxuICpcbiAqIEBwYXJhbSBhIEEgYnl0ZSBhcnJheS5cbiAqIEBwYXJhbSBiIEFub3RoZXIgYnl0ZSBhcnJheS5cbiAqXG4gKiBAcmV0dXJuIGB0cnVlYCBpZiB0aGUgYnl0ZSBhcnJheXMgaGF2ZSB0aGUgc2FtZSBsZW5ndGggYW5kIGJ5dGVzLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZ3JvdXAgSW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVzRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhcnJheXNFcXVhbChhLCBiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWwuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-standard-util/lib/esm/util.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/adapter.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/adapter.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   StandardWalletAdapter: function() { return /* binding */ StandardWalletAdapter; }\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js\");\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(app-pages-browser)/./node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(app-pages-browser)/./node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(app-pages-browser)/./node_modules/@solana/wallet-standard-features/lib/esm/signMessage.js\");\n/* harmony import */ var _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @solana/wallet-standard-features */ \"(app-pages-browser)/./node_modules/@solana/wallet-standard-features/lib/esm/signIn.js\");\n/* harmony import */ var _solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @solana/wallet-standard-util */ \"(app-pages-browser)/./node_modules/@solana/wallet-standard-util/lib/esm/endpoint.js\");\n/* harmony import */ var _solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @solana/wallet-standard-util */ \"(app-pages-browser)/./node_modules/@solana/wallet-standard-util/lib/esm/commitment.js\");\n/* harmony import */ var _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/web3.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/lib/index.browser.esm.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @wallet-standard/features */ \"(app-pages-browser)/./node_modules/@wallet-standard/features/lib/esm/events.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @wallet-standard/features */ \"(app-pages-browser)/./node_modules/@wallet-standard/features/lib/esm/disconnect.js\");\n/* harmony import */ var _wallet_standard_features__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @wallet-standard/features */ \"(app-pages-browser)/./node_modules/@wallet-standard/features/lib/esm/connect.js\");\n/* harmony import */ var _wallet_standard_wallet__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @wallet-standard/wallet */ \"(app-pages-browser)/./node_modules/@wallet-standard/wallet/lib/esm/util.js\");\n/* harmony import */ var bs58__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bs58 */ \"(app-pages-browser)/./node_modules/bs58/index.js\");\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _StandardWalletAdapter_instances, _StandardWalletAdapter_account, _StandardWalletAdapter_publicKey, _StandardWalletAdapter_connecting, _StandardWalletAdapter_disconnecting, _StandardWalletAdapter_off, _StandardWalletAdapter_supportedTransactionVersions, _StandardWalletAdapter_wallet, _StandardWalletAdapter_readyState, _StandardWalletAdapter_connect, _StandardWalletAdapter_connected, _StandardWalletAdapter_disconnected, _StandardWalletAdapter_reset, _StandardWalletAdapter_changed, _StandardWalletAdapter_signTransaction, _StandardWalletAdapter_signAllTransactions, _StandardWalletAdapter_signMessage, _StandardWalletAdapter_signIn;\n\n\n\n\n\n\n\n/** TODO: docs */\nclass StandardWalletAdapter extends _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.BaseWalletAdapter {\n    constructor({ wallet }) {\n        super();\n        _StandardWalletAdapter_instances.add(this);\n        _StandardWalletAdapter_account.set(this, void 0);\n        _StandardWalletAdapter_publicKey.set(this, void 0);\n        _StandardWalletAdapter_connecting.set(this, void 0);\n        _StandardWalletAdapter_disconnecting.set(this, void 0);\n        _StandardWalletAdapter_off.set(this, void 0);\n        _StandardWalletAdapter_supportedTransactionVersions.set(this, void 0);\n        _StandardWalletAdapter_wallet.set(this, void 0);\n        _StandardWalletAdapter_readyState.set(this, typeof window === 'undefined' || typeof document === 'undefined'\n            ? _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Unsupported\n            : _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Installed);\n        _StandardWalletAdapter_changed.set(this, (properties) => {\n            // If accounts have changed on the wallet, reflect this on the adapter.\n            if ('accounts' in properties) {\n                const account = __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").accounts[0];\n                // If the adapter isn't connected, or is disconnecting, or the first account hasn't changed, do nothing.\n                if (__classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\") && !__classPrivateFieldGet(this, _StandardWalletAdapter_disconnecting, \"f\") && account !== __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\")) {\n                    // If there's a connected account, connect the adapter. Otherwise, disconnect it.\n                    if (account) {\n                        // Connect the adapter.\n                        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connected).call(this, account);\n                    }\n                    else {\n                        // Emit an error because the wallet spontaneously disconnected.\n                        this.emit('error', new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletDisconnectedError());\n                        // Disconnect the adapter.\n                        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_disconnected).call(this);\n                    }\n                }\n            }\n            // After reflecting account changes, if features have changed on the wallet, reflect this on the adapter.\n            if ('features' in properties) {\n                __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n            }\n        });\n        __classPrivateFieldSet(this, _StandardWalletAdapter_wallet, wallet, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_account, null, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, null, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, false, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, false, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_off, __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_wallet_standard_features__WEBPACK_IMPORTED_MODULE_4__.StandardEvents].on('change', __classPrivateFieldGet(this, _StandardWalletAdapter_changed, \"f\")), \"f\");\n        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n    }\n    get name() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").name;\n    }\n    get url() {\n        return 'https://github.com/solana-labs/wallet-standard';\n    }\n    get icon() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").icon;\n    }\n    get readyState() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_readyState, \"f\");\n    }\n    get publicKey() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_publicKey, \"f\");\n    }\n    get connecting() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_connecting, \"f\");\n    }\n    get supportedTransactionVersions() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_supportedTransactionVersions, \"f\");\n    }\n    get wallet() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\");\n    }\n    get standard() {\n        return true;\n    }\n    destroy() {\n        __classPrivateFieldSet(this, _StandardWalletAdapter_account, null, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, null, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, false, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, false, \"f\");\n        const off = __classPrivateFieldGet(this, _StandardWalletAdapter_off, \"f\");\n        if (off) {\n            __classPrivateFieldSet(this, _StandardWalletAdapter_off, null, \"f\");\n            off();\n        }\n    }\n    async autoConnect() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connect).call(this, { silent: true });\n    }\n    async connect() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connect).call(this);\n    }\n    async disconnect() {\n        if (_wallet_standard_features__WEBPACK_IMPORTED_MODULE_5__.StandardDisconnect in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n            try {\n                __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, true, \"f\");\n                await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_wallet_standard_features__WEBPACK_IMPORTED_MODULE_5__.StandardDisconnect].disconnect();\n            }\n            catch (error) {\n                this.emit('error', new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletDisconnectionError(error?.message, error));\n            }\n            finally {\n                __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, false, \"f\");\n            }\n        }\n        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_disconnected).call(this);\n    }\n    async sendTransaction(transaction, connection, options = {}) {\n        try {\n            const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n            if (!account)\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n            let feature;\n            if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n                if (account.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction)) {\n                    feature = _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction;\n                }\n                else if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features &&\n                    account.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction)) {\n                    feature = _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction;\n                }\n                else {\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletAccountError();\n                }\n            }\n            else if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n                if (!account.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction))\n                    throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletAccountError();\n                feature = _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction;\n            }\n            else {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConfigError();\n            }\n            const chain = (0,_solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_8__.getChainForEndpoint)(connection.rpcEndpoint);\n            if (!account.chains.includes(chain))\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSendTransactionError();\n            try {\n                const { signers, ...sendOptions } = options;\n                let serializedTransaction;\n                if ((0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_9__.isVersionedTransaction)(transaction)) {\n                    signers?.length && transaction.sign(signers);\n                    serializedTransaction = transaction.serialize();\n                }\n                else {\n                    transaction = (await this.prepareTransaction(transaction, connection, sendOptions));\n                    signers?.length && transaction.partialSign(...signers);\n                    serializedTransaction = new Uint8Array(transaction.serialize({\n                        requireAllSignatures: false,\n                        verifySignatures: false,\n                    }));\n                }\n                if (feature === _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction) {\n                    const [output] = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction].signAndSendTransaction({\n                        account,\n                        chain,\n                        transaction: serializedTransaction,\n                        options: {\n                            preflightCommitment: (0,_solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_10__.getCommitment)(sendOptions.preflightCommitment || connection.commitment),\n                            skipPreflight: sendOptions.skipPreflight,\n                            maxRetries: sendOptions.maxRetries,\n                            minContextSlot: sendOptions.minContextSlot,\n                        },\n                    });\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    return bs58__WEBPACK_IMPORTED_MODULE_1__.encode(output.signature);\n                }\n                else {\n                    const [output] = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction].signTransaction({\n                        account,\n                        chain,\n                        transaction: serializedTransaction,\n                        options: {\n                            preflightCommitment: (0,_solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_10__.getCommitment)(sendOptions.preflightCommitment || connection.commitment),\n                            minContextSlot: sendOptions.minContextSlot,\n                        },\n                    });\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    return await connection.sendRawTransaction(output.signedTransaction, {\n                        ...sendOptions,\n                        preflightCommitment: (0,_solana_wallet_standard_util__WEBPACK_IMPORTED_MODULE_10__.getCommitment)(sendOptions.preflightCommitment || connection.commitment),\n                    });\n                }\n            }\n            catch (error) {\n                if (error instanceof _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletError)\n                    throw error;\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSendTransactionError(error?.message, error);\n            }\n        }\n        catch (error) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n}\n_StandardWalletAdapter_account = new WeakMap(), _StandardWalletAdapter_publicKey = new WeakMap(), _StandardWalletAdapter_connecting = new WeakMap(), _StandardWalletAdapter_disconnecting = new WeakMap(), _StandardWalletAdapter_off = new WeakMap(), _StandardWalletAdapter_supportedTransactionVersions = new WeakMap(), _StandardWalletAdapter_wallet = new WeakMap(), _StandardWalletAdapter_readyState = new WeakMap(), _StandardWalletAdapter_changed = new WeakMap(), _StandardWalletAdapter_instances = new WeakSet(), _StandardWalletAdapter_connect = async function _StandardWalletAdapter_connect(input) {\n    try {\n        if (this.connected || this.connecting)\n            return;\n        if (__classPrivateFieldGet(this, _StandardWalletAdapter_readyState, \"f\") !== _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.WalletReadyState.Installed)\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotReadyError();\n        __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, true, \"f\");\n        if (!__classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").accounts.length) {\n            try {\n                await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_wallet_standard_features__WEBPACK_IMPORTED_MODULE_11__.StandardConnect].connect(input);\n            }\n            catch (error) {\n                throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConnectionError(error?.message, error);\n            }\n        }\n        const account = __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").accounts[0];\n        if (!account)\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletAccountError();\n        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connected).call(this, account);\n    }\n    catch (error) {\n        this.emit('error', error);\n        throw error;\n    }\n    finally {\n        __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, false, \"f\");\n    }\n}, _StandardWalletAdapter_connected = function _StandardWalletAdapter_connected(account) {\n    let publicKey;\n    try {\n        // Use account.address instead of account.publicKey since address could be a PDA\n        publicKey = new _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.PublicKey(account.address);\n    }\n    catch (error) {\n        throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletPublicKeyError(error?.message, error);\n    }\n    __classPrivateFieldSet(this, _StandardWalletAdapter_account, account, \"f\");\n    __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, publicKey, \"f\");\n    __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n    this.emit('connect', publicKey);\n}, _StandardWalletAdapter_disconnected = function _StandardWalletAdapter_disconnected() {\n    __classPrivateFieldSet(this, _StandardWalletAdapter_account, null, \"f\");\n    __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, null, \"f\");\n    __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n    this.emit('disconnect');\n}, _StandardWalletAdapter_reset = function _StandardWalletAdapter_reset() {\n    const supportedTransactionVersions = _solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features\n        ? __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_6__.SolanaSignAndSendTransaction].supportedTransactionVersions\n        : __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction].supportedTransactionVersions;\n    __classPrivateFieldSet(this, _StandardWalletAdapter_supportedTransactionVersions, (0,_wallet_standard_wallet__WEBPACK_IMPORTED_MODULE_12__.arraysEqual)(supportedTransactionVersions, ['legacy'])\n        ? null\n        : new Set(supportedTransactionVersions), \"f\");\n    if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features && __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\")?.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction)) {\n        this.signTransaction = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signTransaction);\n        this.signAllTransactions = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signAllTransactions);\n    }\n    else {\n        delete this.signTransaction;\n        delete this.signAllTransactions;\n    }\n    if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_13__.SolanaSignMessage in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features && __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\")?.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_13__.SolanaSignMessage)) {\n        this.signMessage = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signMessage);\n    }\n    else {\n        delete this.signMessage;\n    }\n    if (_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_14__.SolanaSignIn in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n        this.signIn = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signIn);\n    }\n    else {\n        delete this.signIn;\n    }\n}, _StandardWalletAdapter_signTransaction = async function _StandardWalletAdapter_signTransaction(transaction) {\n    try {\n        const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n        if (!account)\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n        if (!(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features))\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConfigError();\n        if (!account.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction))\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletAccountError();\n        try {\n            const signedTransactions = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction].signTransaction({\n                account,\n                transaction: (0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_9__.isVersionedTransaction)(transaction)\n                    ? transaction.serialize()\n                    : new Uint8Array(transaction.serialize({\n                        requireAllSignatures: false,\n                        verifySignatures: false,\n                    })),\n            });\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const serializedTransaction = signedTransactions[0].signedTransaction;\n            return ((0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_9__.isVersionedTransaction)(transaction)\n                ? _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.VersionedTransaction.deserialize(serializedTransaction)\n                : _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction.from(serializedTransaction));\n        }\n        catch (error) {\n            if (error instanceof _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletError)\n                throw error;\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignTransactionError(error?.message, error);\n        }\n    }\n    catch (error) {\n        this.emit('error', error);\n        throw error;\n    }\n}, _StandardWalletAdapter_signAllTransactions = async function _StandardWalletAdapter_signAllTransactions(transactions) {\n    try {\n        const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n        if (!account)\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n        if (!(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features))\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConfigError();\n        if (!account.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction))\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletAccountError();\n        try {\n            const signedTransactions = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_7__.SolanaSignTransaction].signTransaction(...transactions.map((transaction) => ({\n                account,\n                transaction: (0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_9__.isVersionedTransaction)(transaction)\n                    ? transaction.serialize()\n                    : new Uint8Array(transaction.serialize({\n                        requireAllSignatures: false,\n                        verifySignatures: false,\n                    })),\n            })));\n            return transactions.map((transaction, index) => {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const signedTransaction = signedTransactions[index].signedTransaction;\n                return ((0,_solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_9__.isVersionedTransaction)(transaction)\n                    ? _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.VersionedTransaction.deserialize(signedTransaction)\n                    : _solana_web3_js__WEBPACK_IMPORTED_MODULE_0__.Transaction.from(signedTransaction));\n            });\n        }\n        catch (error) {\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignTransactionError(error?.message, error);\n        }\n    }\n    catch (error) {\n        this.emit('error', error);\n        throw error;\n    }\n}, _StandardWalletAdapter_signMessage = async function _StandardWalletAdapter_signMessage(message) {\n    try {\n        const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n        if (!account)\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletNotConnectedError();\n        if (!(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_13__.SolanaSignMessage in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features))\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConfigError();\n        if (!account.features.includes(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_13__.SolanaSignMessage))\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletAccountError();\n        try {\n            const signedMessages = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_13__.SolanaSignMessage].signMessage({\n                account,\n                message,\n            });\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return signedMessages[0].signature;\n        }\n        catch (error) {\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignMessageError(error?.message, error);\n        }\n    }\n    catch (error) {\n        this.emit('error', error);\n        throw error;\n    }\n}, _StandardWalletAdapter_signIn = async function _StandardWalletAdapter_signIn(input = {}) {\n    try {\n        if (!(_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_14__.SolanaSignIn in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features))\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletConfigError();\n        let output;\n        try {\n            [output] = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[_solana_wallet_standard_features__WEBPACK_IMPORTED_MODULE_14__.SolanaSignIn].signIn(input);\n        }\n        catch (error) {\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignInError(error?.message, error);\n        }\n        if (!output)\n            throw new _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.WalletSignInError();\n        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connected).call(this, output.account);\n        return output;\n    }\n    catch (error) {\n        this.emit('error', error);\n        throw error;\n    }\n};\n//# sourceMappingURL=adapter.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC13YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vYWRhcHRlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNnWjtBQUN2UTtBQUN2RDtBQUNIO0FBQ2tCO0FBQzNDO0FBQzlCO0FBQ3hCO0FBQ08sb0NBQW9DLDBFQUFpQjtBQUM1RCxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUVBQWdCO0FBQzlCLGNBQWMseUVBQWdCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLGdGQUF1QjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJJQUEySSxxRUFBYztBQUN6SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0lBQWdJLGNBQWM7QUFDOUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUVBQWtCO0FBQzlCO0FBQ0E7QUFDQSxnR0FBZ0cs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Q0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXdhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS9hZGFwdGVyLmpzP2JjYTEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2FjY291bnQsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcHVibGljS2V5LCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3RpbmcsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfZGlzY29ubmVjdGluZywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9vZmYsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcmVhZHlTdGF0ZSwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jb25uZWN0LCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3RlZCwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9kaXNjb25uZWN0ZWQsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcmVzZXQsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY2hhbmdlZCwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zaWduVHJhbnNhY3Rpb24sIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfc2lnbkFsbFRyYW5zYWN0aW9ucywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zaWduTWVzc2FnZSwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zaWduSW47XG5pbXBvcnQgeyBCYXNlV2FsbGV0QWRhcHRlciwgaXNWZXJzaW9uZWRUcmFuc2FjdGlvbiwgV2FsbGV0QWNjb3VudEVycm9yLCBXYWxsZXRDb25maWdFcnJvciwgV2FsbGV0Q29ubmVjdGlvbkVycm9yLCBXYWxsZXREaXNjb25uZWN0ZWRFcnJvciwgV2FsbGV0RGlzY29ubmVjdGlvbkVycm9yLCBXYWxsZXRFcnJvciwgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IsIFdhbGxldE5vdFJlYWR5RXJyb3IsIFdhbGxldFB1YmxpY0tleUVycm9yLCBXYWxsZXRSZWFkeVN0YXRlLCBXYWxsZXRTZW5kVHJhbnNhY3Rpb25FcnJvciwgV2FsbGV0U2lnbkluRXJyb3IsIFdhbGxldFNpZ25NZXNzYWdlRXJyb3IsIFdhbGxldFNpZ25UcmFuc2FjdGlvbkVycm9yLCB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LWFkYXB0ZXItYmFzZSc7XG5pbXBvcnQgeyBTb2xhbmFTaWduQW5kU2VuZFRyYW5zYWN0aW9uLCBTb2xhbmFTaWduSW4sIFNvbGFuYVNpZ25NZXNzYWdlLCBTb2xhbmFTaWduVHJhbnNhY3Rpb24sIH0gZnJvbSAnQHNvbGFuYS93YWxsZXQtc3RhbmRhcmQtZmVhdHVyZXMnO1xuaW1wb3J0IHsgZ2V0Q2hhaW5Gb3JFbmRwb2ludCwgZ2V0Q29tbWl0bWVudCB9IGZyb20gJ0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXV0aWwnO1xuaW1wb3J0IHsgUHVibGljS2V5LCBUcmFuc2FjdGlvbiwgVmVyc2lvbmVkVHJhbnNhY3Rpb24gfSBmcm9tICdAc29sYW5hL3dlYjMuanMnO1xuaW1wb3J0IHsgU3RhbmRhcmRDb25uZWN0LCBTdGFuZGFyZERpc2Nvbm5lY3QsIFN0YW5kYXJkRXZlbnRzLCB9IGZyb20gJ0B3YWxsZXQtc3RhbmRhcmQvZmVhdHVyZXMnO1xuaW1wb3J0IHsgYXJyYXlzRXF1YWwgfSBmcm9tICdAd2FsbGV0LXN0YW5kYXJkL3dhbGxldCc7XG5pbXBvcnQgYnM1OCBmcm9tICdiczU4Jztcbi8qKiBUT0RPOiBkb2NzICovXG5leHBvcnQgY2xhc3MgU3RhbmRhcmRXYWxsZXRBZGFwdGVyIGV4dGVuZHMgQmFzZVdhbGxldEFkYXB0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHsgd2FsbGV0IH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMuYWRkKHRoaXMpO1xuICAgICAgICBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2FjY291bnQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcHVibGljS2V5LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3Rpbmcuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfZGlzY29ubmVjdGluZy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9vZmYuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcmVhZHlTdGF0ZS5zZXQodGhpcywgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgPyBXYWxsZXRSZWFkeVN0YXRlLlVuc3VwcG9ydGVkXG4gICAgICAgICAgICA6IFdhbGxldFJlYWR5U3RhdGUuSW5zdGFsbGVkKTtcbiAgICAgICAgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jaGFuZ2VkLnNldCh0aGlzLCAocHJvcGVydGllcykgPT4ge1xuICAgICAgICAgICAgLy8gSWYgYWNjb3VudHMgaGF2ZSBjaGFuZ2VkIG9uIHRoZSB3YWxsZXQsIHJlZmxlY3QgdGhpcyBvbiB0aGUgYWRhcHRlci5cbiAgICAgICAgICAgIGlmICgnYWNjb3VudHMnIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY2NvdW50ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmFjY291bnRzWzBdO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBhZGFwdGVyIGlzbid0IGNvbm5lY3RlZCwgb3IgaXMgZGlzY29ubmVjdGluZywgb3IgdGhlIGZpcnN0IGFjY291bnQgaGFzbid0IGNoYW5nZWQsIGRvIG5vdGhpbmcuXG4gICAgICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9hY2NvdW50LCBcImZcIikgJiYgIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9kaXNjb25uZWN0aW5nLCBcImZcIikgJiYgYWNjb3VudCAhPT0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2FjY291bnQsIFwiZlwiKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgY29ubmVjdGVkIGFjY291bnQsIGNvbm5lY3QgdGhlIGFkYXB0ZXIuIE90aGVyd2lzZSwgZGlzY29ubmVjdCBpdC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFjY291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbm5lY3QgdGhlIGFkYXB0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jb25uZWN0ZWQpLmNhbGwodGhpcywgYWNjb3VudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFbWl0IGFuIGVycm9yIGJlY2F1c2UgdGhlIHdhbGxldCBzcG9udGFuZW91c2x5IGRpc2Nvbm5lY3RlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgV2FsbGV0RGlzY29ubmVjdGVkRXJyb3IoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNjb25uZWN0IHRoZSBhZGFwdGVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2luc3RhbmNlcywgXCJtXCIsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfZGlzY29ubmVjdGVkKS5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWZ0ZXIgcmVmbGVjdGluZyBhY2NvdW50IGNoYW5nZXMsIGlmIGZlYXR1cmVzIGhhdmUgY2hhbmdlZCBvbiB0aGUgd2FsbGV0LCByZWZsZWN0IHRoaXMgb24gdGhlIGFkYXB0ZXIuXG4gICAgICAgICAgICBpZiAoJ2ZlYXR1cmVzJyBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2luc3RhbmNlcywgXCJtXCIsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcmVzZXQpLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCB3YWxsZXQsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2FjY291bnQsIG51bGwsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3B1YmxpY0tleSwgbnVsbCwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdGluZywgZmFsc2UsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Rpc2Nvbm5lY3RpbmcsIGZhbHNlLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9vZmYsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlc1tTdGFuZGFyZEV2ZW50c10ub24oJ2NoYW5nZScsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jaGFuZ2VkLCBcImZcIikpLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3Jlc2V0KS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5uYW1lO1xuICAgIH1cbiAgICBnZXQgdXJsKCkge1xuICAgICAgICByZXR1cm4gJ2h0dHBzOi8vZ2l0aHViLmNvbS9zb2xhbmEtbGFicy93YWxsZXQtc3RhbmRhcmQnO1xuICAgIH1cbiAgICBnZXQgaWNvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5pY29uO1xuICAgIH1cbiAgICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9yZWFkeVN0YXRlLCBcImZcIik7XG4gICAgfVxuICAgIGdldCBwdWJsaWNLZXkoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcHVibGljS2V5LCBcImZcIik7XG4gICAgfVxuICAgIGdldCBjb25uZWN0aW5nKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3RpbmcsIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IHN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucywgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgd2FsbGV0KCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpO1xuICAgIH1cbiAgICBnZXQgc3RhbmRhcmQoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfYWNjb3VudCwgbnVsbCwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcHVibGljS2V5LCBudWxsLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jb25uZWN0aW5nLCBmYWxzZSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfZGlzY29ubmVjdGluZywgZmFsc2UsIFwiZlwiKTtcbiAgICAgICAgY29uc3Qgb2ZmID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX29mZiwgXCJmXCIpO1xuICAgICAgICBpZiAob2ZmKSB7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfb2ZmLCBudWxsLCBcImZcIik7XG4gICAgICAgICAgICBvZmYoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBhdXRvQ29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3QpLmNhbGwodGhpcywgeyBzaWxlbnQ6IHRydWUgfSk7XG4gICAgfVxuICAgIGFzeW5jIGNvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jb25uZWN0KS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBhc3luYyBkaXNjb25uZWN0KCkge1xuICAgICAgICBpZiAoU3RhbmRhcmREaXNjb25uZWN0IGluIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlcykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfZGlzY29ubmVjdGluZywgdHJ1ZSwgXCJmXCIpO1xuICAgICAgICAgICAgICAgIGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlc1tTdGFuZGFyZERpc2Nvbm5lY3RdLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgV2FsbGV0RGlzY29ubmVjdGlvbkVycm9yKGVycm9yPy5tZXNzYWdlLCBlcnJvcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Rpc2Nvbm5lY3RpbmcsIGZhbHNlLCBcImZcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2luc3RhbmNlcywgXCJtXCIsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfZGlzY29ubmVjdGVkKS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24sIGNvbm5lY3Rpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYWNjb3VudCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9hY2NvdW50LCBcImZcIik7XG4gICAgICAgICAgICBpZiAoIWFjY291bnQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldE5vdENvbm5lY3RlZEVycm9yKCk7XG4gICAgICAgICAgICBsZXQgZmVhdHVyZTtcbiAgICAgICAgICAgIGlmIChTb2xhbmFTaWduQW5kU2VuZFRyYW5zYWN0aW9uIGluIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlcykge1xuICAgICAgICAgICAgICAgIGlmIChhY2NvdW50LmZlYXR1cmVzLmluY2x1ZGVzKFNvbGFuYVNpZ25BbmRTZW5kVHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUgPSBTb2xhbmFTaWduQW5kU2VuZFRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChTb2xhbmFTaWduVHJhbnNhY3Rpb24gaW4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzICYmXG4gICAgICAgICAgICAgICAgICAgIGFjY291bnQuZmVhdHVyZXMuaW5jbHVkZXMoU29sYW5hU2lnblRyYW5zYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlID0gU29sYW5hU2lnblRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldEFjY291bnRFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFNvbGFuYVNpZ25UcmFuc2FjdGlvbiBpbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuZmVhdHVyZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFjY291bnQuZmVhdHVyZXMuaW5jbHVkZXMoU29sYW5hU2lnblRyYW5zYWN0aW9uKSlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldEFjY291bnRFcnJvcigpO1xuICAgICAgICAgICAgICAgIGZlYXR1cmUgPSBTb2xhbmFTaWduVHJhbnNhY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Q29uZmlnRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNoYWluID0gZ2V0Q2hhaW5Gb3JFbmRwb2ludChjb25uZWN0aW9uLnJwY0VuZHBvaW50KTtcbiAgICAgICAgICAgIGlmICghYWNjb3VudC5jaGFpbnMuaW5jbHVkZXMoY2hhaW4pKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTZW5kVHJhbnNhY3Rpb25FcnJvcigpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNpZ25lcnMsIC4uLnNlbmRPcHRpb25zIH0gPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGxldCBzZXJpYWxpemVkVHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgaWYgKGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpZ25lcnM/Lmxlbmd0aCAmJiB0cmFuc2FjdGlvbi5zaWduKHNpZ25lcnMpO1xuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkVHJhbnNhY3Rpb24gPSB0cmFuc2FjdGlvbi5zZXJpYWxpemUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uID0gKGF3YWl0IHRoaXMucHJlcGFyZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uLCBjb25uZWN0aW9uLCBzZW5kT3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICBzaWduZXJzPy5sZW5ndGggJiYgdHJhbnNhY3Rpb24ucGFydGlhbFNpZ24oLi4uc2lnbmVycyk7XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IG5ldyBVaW50OEFycmF5KHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1aXJlQWxsU2lnbmF0dXJlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB2ZXJpZnlTaWduYXR1cmVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZSA9PT0gU29sYW5hU2lnbkFuZFNlbmRUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbb3V0cHV0XSA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlc1tTb2xhbmFTaWduQW5kU2VuZFRyYW5zYWN0aW9uXS5zaWduQW5kU2VuZFRyYW5zYWN0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjY291bnQsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFpbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBzZXJpYWxpemVkVHJhbnNhY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlZmxpZ2h0Q29tbWl0bWVudDogZ2V0Q29tbWl0bWVudChzZW5kT3B0aW9ucy5wcmVmbGlnaHRDb21taXRtZW50IHx8IGNvbm5lY3Rpb24uY29tbWl0bWVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcFByZWZsaWdodDogc2VuZE9wdGlvbnMuc2tpcFByZWZsaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhSZXRyaWVzOiBzZW5kT3B0aW9ucy5tYXhSZXRyaWVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkNvbnRleHRTbG90OiBzZW5kT3B0aW9ucy5taW5Db250ZXh0U2xvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYnM1OC5lbmNvZGUob3V0cHV0LnNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBbb3V0cHV0XSA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlc1tTb2xhbmFTaWduVHJhbnNhY3Rpb25dLnNpZ25UcmFuc2FjdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW4sXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogc2VyaWFsaXplZFRyYW5zYWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQ6IGdldENvbW1pdG1lbnQoc2VuZE9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCB8fCBjb25uZWN0aW9uLmNvbW1pdG1lbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1pbkNvbnRleHRTbG90OiBzZW5kT3B0aW9ucy5taW5Db250ZXh0U2xvdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgY29ubmVjdGlvbi5zZW5kUmF3VHJhbnNhY3Rpb24ob3V0cHV0LnNpZ25lZFRyYW5zYWN0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zZW5kT3B0aW9ucyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByZWZsaWdodENvbW1pdG1lbnQ6IGdldENvbW1pdG1lbnQoc2VuZE9wdGlvbnMucHJlZmxpZ2h0Q29tbWl0bWVudCB8fCBjb25uZWN0aW9uLmNvbW1pdG1lbnQpLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBXYWxsZXRFcnJvcilcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNlbmRUcmFuc2FjdGlvbkVycm9yKGVycm9yPy5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG59XG5fU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2FjY291bnQgPSBuZXcgV2Vha01hcCgpLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3B1YmxpY0tleSA9IG5ldyBXZWFrTWFwKCksIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdGluZyA9IG5ldyBXZWFrTWFwKCksIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfZGlzY29ubmVjdGluZyA9IG5ldyBXZWFrTWFwKCksIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfb2ZmID0gbmV3IFdlYWtNYXAoKSwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zID0gbmV3IFdlYWtNYXAoKSwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQgPSBuZXcgV2Vha01hcCgpLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3JlYWR5U3RhdGUgPSBuZXcgV2Vha01hcCgpLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2NoYW5nZWQgPSBuZXcgV2Vha01hcCgpLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2luc3RhbmNlcyA9IG5ldyBXZWFrU2V0KCksIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdCA9IGFzeW5jIGZ1bmN0aW9uIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdChpbnB1dCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCB8fCB0aGlzLmNvbm5lY3RpbmcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcmVhZHlTdGF0ZSwgXCJmXCIpICE9PSBXYWxsZXRSZWFkeVN0YXRlLkluc3RhbGxlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RSZWFkeUVycm9yKCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jb25uZWN0aW5nLCB0cnVlLCBcImZcIik7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmFjY291bnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuZmVhdHVyZXNbU3RhbmRhcmRDb25uZWN0XS5jb25uZWN0KGlucHV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25uZWN0aW9uRXJyb3IoZXJyb3I/Lm1lc3NhZ2UsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhY2NvdW50ID0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmFjY291bnRzWzBdO1xuICAgICAgICBpZiAoIWFjY291bnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0QWNjb3VudEVycm9yKCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3RlZCkuY2FsbCh0aGlzLCBhY2NvdW50KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3RpbmcsIGZhbHNlLCBcImZcIik7XG4gICAgfVxufSwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9jb25uZWN0ZWQgPSBmdW5jdGlvbiBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Nvbm5lY3RlZChhY2NvdW50KSB7XG4gICAgbGV0IHB1YmxpY0tleTtcbiAgICB0cnkge1xuICAgICAgICAvLyBVc2UgYWNjb3VudC5hZGRyZXNzIGluc3RlYWQgb2YgYWNjb3VudC5wdWJsaWNLZXkgc2luY2UgYWRkcmVzcyBjb3VsZCBiZSBhIFBEQVxuICAgICAgICBwdWJsaWNLZXkgPSBuZXcgUHVibGljS2V5KGFjY291bnQuYWRkcmVzcyk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgV2FsbGV0UHVibGljS2V5RXJyb3IoZXJyb3I/Lm1lc3NhZ2UsIGVycm9yKTtcbiAgICB9XG4gICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2FjY291bnQsIGFjY291bnQsIFwiZlwiKTtcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcHVibGljS2V5LCBwdWJsaWNLZXksIFwiZlwiKTtcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9yZXNldCkuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmVtaXQoJ2Nvbm5lY3QnLCBwdWJsaWNLZXkpO1xufSwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9kaXNjb25uZWN0ZWQgPSBmdW5jdGlvbiBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2Rpc2Nvbm5lY3RlZCgpIHtcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfYWNjb3VudCwgbnVsbCwgXCJmXCIpO1xuICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9wdWJsaWNLZXksIG51bGwsIFwiZlwiKTtcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9yZXNldCkuY2FsbCh0aGlzKTtcbiAgICB0aGlzLmVtaXQoJ2Rpc2Nvbm5lY3QnKTtcbn0sIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfcmVzZXQgPSBmdW5jdGlvbiBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3Jlc2V0KCkge1xuICAgIGNvbnN0IHN1cHBvcnRlZFRyYW5zYWN0aW9uVmVyc2lvbnMgPSBTb2xhbmFTaWduQW5kU2VuZFRyYW5zYWN0aW9uIGluIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlc1xuICAgICAgICA/IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlc1tTb2xhbmFTaWduQW5kU2VuZFRyYW5zYWN0aW9uXS5zdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zXG4gICAgICAgIDogX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzW1NvbGFuYVNpZ25UcmFuc2FjdGlvbl0uc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucztcbiAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucywgYXJyYXlzRXF1YWwoc3VwcG9ydGVkVHJhbnNhY3Rpb25WZXJzaW9ucywgWydsZWdhY3knXSlcbiAgICAgICAgPyBudWxsXG4gICAgICAgIDogbmV3IFNldChzdXBwb3J0ZWRUcmFuc2FjdGlvblZlcnNpb25zKSwgXCJmXCIpO1xuICAgIGlmIChTb2xhbmFTaWduVHJhbnNhY3Rpb24gaW4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzICYmIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9hY2NvdW50LCBcImZcIik/LmZlYXR1cmVzLmluY2x1ZGVzKFNvbGFuYVNpZ25UcmFuc2FjdGlvbikpIHtcbiAgICAgICAgdGhpcy5zaWduVHJhbnNhY3Rpb24gPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zaWduVHJhbnNhY3Rpb24pO1xuICAgICAgICB0aGlzLnNpZ25BbGxUcmFuc2FjdGlvbnMgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfaW5zdGFuY2VzLCBcIm1cIiwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zaWduQWxsVHJhbnNhY3Rpb25zKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNpZ25UcmFuc2FjdGlvbjtcbiAgICAgICAgZGVsZXRlIHRoaXMuc2lnbkFsbFRyYW5zYWN0aW9ucztcbiAgICB9XG4gICAgaWYgKFNvbGFuYVNpZ25NZXNzYWdlIGluIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlcyAmJiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfYWNjb3VudCwgXCJmXCIpPy5mZWF0dXJlcy5pbmNsdWRlcyhTb2xhbmFTaWduTWVzc2FnZSkpIHtcbiAgICAgICAgdGhpcy5zaWduTWVzc2FnZSA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25NZXNzYWdlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnNpZ25NZXNzYWdlO1xuICAgIH1cbiAgICBpZiAoU29sYW5hU2lnbkluIGluIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlcykge1xuICAgICAgICB0aGlzLnNpZ25JbiA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9pbnN0YW5jZXMsIFwibVwiLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25Jbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBkZWxldGUgdGhpcy5zaWduSW47XG4gICAgfVxufSwgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zaWduVHJhbnNhY3Rpb24gPSBhc3luYyBmdW5jdGlvbiBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfYWNjb3VudCwgXCJmXCIpO1xuICAgICAgICBpZiAoIWFjY291bnQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Tm90Q29ubmVjdGVkRXJyb3IoKTtcbiAgICAgICAgaWYgKCEoU29sYW5hU2lnblRyYW5zYWN0aW9uIGluIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlcykpXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0Q29uZmlnRXJyb3IoKTtcbiAgICAgICAgaWYgKCFhY2NvdW50LmZlYXR1cmVzLmluY2x1ZGVzKFNvbGFuYVNpZ25UcmFuc2FjdGlvbikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0QWNjb3VudEVycm9yKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzaWduZWRUcmFuc2FjdGlvbnMgPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuZmVhdHVyZXNbU29sYW5hU2lnblRyYW5zYWN0aW9uXS5zaWduVHJhbnNhY3Rpb24oe1xuICAgICAgICAgICAgICAgIGFjY291bnQsXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IGlzVmVyc2lvbmVkVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pXG4gICAgICAgICAgICAgICAgICAgID8gdHJhbnNhY3Rpb24uc2VyaWFsaXplKClcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgVWludDhBcnJheSh0cmFuc2FjdGlvbi5zZXJpYWxpemUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWlyZUFsbFNpZ25hdHVyZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyaWZ5U2lnbmF0dXJlczogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRUcmFuc2FjdGlvbiA9IHNpZ25lZFRyYW5zYWN0aW9uc1swXS5zaWduZWRUcmFuc2FjdGlvbjtcbiAgICAgICAgICAgIHJldHVybiAoaXNWZXJzaW9uZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICA/IFZlcnNpb25lZFRyYW5zYWN0aW9uLmRlc2VyaWFsaXplKHNlcmlhbGl6ZWRUcmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICA6IFRyYW5zYWN0aW9uLmZyb20oc2VyaWFsaXplZFRyYW5zYWN0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBXYWxsZXRFcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvcihlcnJvcj8ubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59LCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25BbGxUcmFuc2FjdGlvbnMgPSBhc3luYyBmdW5jdGlvbiBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25BbGxUcmFuc2FjdGlvbnModHJhbnNhY3Rpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9hY2NvdW50LCBcImZcIik7XG4gICAgICAgIGlmICghYWNjb3VudClcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICBpZiAoIShTb2xhbmFTaWduVHJhbnNhY3Rpb24gaW4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25maWdFcnJvcigpO1xuICAgICAgICBpZiAoIWFjY291bnQuZmVhdHVyZXMuaW5jbHVkZXMoU29sYW5hU2lnblRyYW5zYWN0aW9uKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRBY2NvdW50RXJyb3IoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25lZFRyYW5zYWN0aW9ucyA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlc1tTb2xhbmFTaWduVHJhbnNhY3Rpb25dLnNpZ25UcmFuc2FjdGlvbiguLi50cmFuc2FjdGlvbnMubWFwKCh0cmFuc2FjdGlvbikgPT4gKHtcbiAgICAgICAgICAgICAgICBhY2NvdW50LFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiBpc1ZlcnNpb25lZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgICAgICAgICA/IHRyYW5zYWN0aW9uLnNlcmlhbGl6ZSgpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IFVpbnQ4QXJyYXkodHJhbnNhY3Rpb24uc2VyaWFsaXplKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVpcmVBbGxTaWduYXR1cmVzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcmlmeVNpZ25hdHVyZXM6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICB9KSksXG4gICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9ucy5tYXAoKHRyYW5zYWN0aW9uLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgICAgICAgICAgICAgY29uc3Qgc2lnbmVkVHJhbnNhY3Rpb24gPSBzaWduZWRUcmFuc2FjdGlvbnNbaW5kZXhdLnNpZ25lZFRyYW5zYWN0aW9uO1xuICAgICAgICAgICAgICAgIHJldHVybiAoaXNWZXJzaW9uZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgPyBWZXJzaW9uZWRUcmFuc2FjdGlvbi5kZXNlcmlhbGl6ZShzaWduZWRUcmFuc2FjdGlvbilcbiAgICAgICAgICAgICAgICAgICAgOiBUcmFuc2FjdGlvbi5mcm9tKHNpZ25lZFRyYW5zYWN0aW9uKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRTaWduVHJhbnNhY3Rpb25FcnJvcihlcnJvcj8ubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59LCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25NZXNzYWdlID0gYXN5bmMgZnVuY3Rpb24gX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9zaWduTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWNjb3VudCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl9hY2NvdW50LCBcImZcIik7XG4gICAgICAgIGlmICghYWNjb3VudClcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXROb3RDb25uZWN0ZWRFcnJvcigpO1xuICAgICAgICBpZiAoIShTb2xhbmFTaWduTWVzc2FnZSBpbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuZmVhdHVyZXMpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldENvbmZpZ0Vycm9yKCk7XG4gICAgICAgIGlmICghYWNjb3VudC5mZWF0dXJlcy5pbmNsdWRlcyhTb2xhbmFTaWduTWVzc2FnZSkpXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0QWNjb3VudEVycm9yKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBzaWduZWRNZXNzYWdlcyA9IGF3YWl0IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1N0YW5kYXJkV2FsbGV0QWRhcHRlcl93YWxsZXQsIFwiZlwiKS5mZWF0dXJlc1tTb2xhbmFTaWduTWVzc2FnZV0uc2lnbk1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGFjY291bnQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIHJldHVybiBzaWduZWRNZXNzYWdlc1swXS5zaWduYXR1cmU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2lnbk1lc3NhZ2VFcnJvcihlcnJvcj8ubWVzc2FnZSwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyb3IpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG59LCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3NpZ25JbiA9IGFzeW5jIGZ1bmN0aW9uIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfc2lnbkluKGlucHV0ID0ge30pIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIShTb2xhbmFTaWduSW4gaW4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX3dhbGxldCwgXCJmXCIpLmZlYXR1cmVzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBXYWxsZXRDb25maWdFcnJvcigpO1xuICAgICAgICBsZXQgb3V0cHV0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgW291dHB1dF0gPSBhd2FpdCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfd2FsbGV0LCBcImZcIikuZmVhdHVyZXNbU29sYW5hU2lnbkluXS5zaWduSW4oaW5wdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFdhbGxldFNpZ25JbkVycm9yKGVycm9yPy5tZXNzYWdlLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvdXRwdXQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgV2FsbGV0U2lnbkluRXJyb3IoKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfU3RhbmRhcmRXYWxsZXRBZGFwdGVyX2luc3RhbmNlcywgXCJtXCIsIF9TdGFuZGFyZFdhbGxldEFkYXB0ZXJfY29ubmVjdGVkKS5jYWxsKHRoaXMsIG91dHB1dC5hY2NvdW50KTtcbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hZGFwdGVyLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/adapter.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/types.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/types.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isWalletAdapterCompatibleWallet: function() { return /* binding */ isWalletAdapterCompatibleWallet; }\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @solana/wallet-adapter-base */ \"(app-pages-browser)/./node_modules/@solana/wallet-adapter-base/lib/esm/standard.js\");\n\n/**\n * @deprecated Use `isWalletAdapterCompatibleStandardWallet` from `@solana/wallet-adapter-base` instead.\n *\n * @group Deprecated\n */\nconst isWalletAdapterCompatibleWallet = _solana_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_0__.isWalletAdapterCompatibleStandardWallet;\n//# sourceMappingURL=types.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC13YWxsZXQtYWRhcHRlci1iYXNlL2xpYi9lc20vdHlwZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUY7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLHdDQUF3QyxnR0FBdUM7QUFDdEYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2FsbGV0LXN0YW5kYXJkLXdhbGxldC1hZGFwdGVyLWJhc2UvbGliL2VzbS90eXBlcy5qcz84NTFmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzV2FsbGV0QWRhcHRlckNvbXBhdGlibGVTdGFuZGFyZFdhbGxldCwgfSBmcm9tICdAc29sYW5hL3dhbGxldC1hZGFwdGVyLWJhc2UnO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2UgYGlzV2FsbGV0QWRhcHRlckNvbXBhdGlibGVTdGFuZGFyZFdhbGxldGAgZnJvbSBgQHNvbGFuYS93YWxsZXQtYWRhcHRlci1iYXNlYCBpbnN0ZWFkLlxuICpcbiAqIEBncm91cCBEZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBjb25zdCBpc1dhbGxldEFkYXB0ZXJDb21wYXRpYmxlV2FsbGV0ID0gaXNXYWxsZXRBZGFwdGVyQ29tcGF0aWJsZVN0YW5kYXJkV2FsbGV0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHlwZXMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/types.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/wallet-standard-wallet-adapter-react/lib/esm/useStandardWalletAdapters.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@solana/wallet-standard-wallet-adapter-react/lib/esm/useStandardWalletAdapters.js ***!
  \********************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useStandardWalletAdapters: function() { return /* binding */ useStandardWalletAdapters; }\n/* harmony export */ });\n/* harmony import */ var _solana_wallet_standard_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @solana/wallet-standard-wallet-adapter-base */ \"(app-pages-browser)/./node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/types.js\");\n/* harmony import */ var _solana_wallet_standard_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @solana/wallet-standard-wallet-adapter-base */ \"(app-pages-browser)/./node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/adapter.js\");\n/* harmony import */ var _wallet_standard_app__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @wallet-standard/app */ \"(app-pages-browser)/./node_modules/@wallet-standard/app/lib/esm/wallets.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n\n\n\nfunction useStandardWalletAdapters(adapters) {\n    const warnings = useConstant(() => new Set());\n    const { get, on } = useConstant(() => (0,_wallet_standard_app__WEBPACK_IMPORTED_MODULE_1__.DEPRECATED_getWallets)());\n    const [standardAdapters, setStandardAdapters] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(() => wrapWalletsWithAdapters(get()));\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        const listeners = [\n            on('register', (...wallets) => setStandardAdapters((standardAdapters) => [...standardAdapters, ...wrapWalletsWithAdapters(wallets)])),\n            on('unregister', (...wallets) => setStandardAdapters((standardAdapters) => standardAdapters.filter((standardAdapter) => wallets.some((wallet) => wallet === standardAdapter.wallet)))),\n        ];\n        return () => listeners.forEach((off) => off());\n    }, [on]);\n    const prevStandardAdapters = usePrevious(standardAdapters);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        if (!prevStandardAdapters)\n            return;\n        const currentAdapters = new Set(standardAdapters);\n        const removedAdapters = new Set(prevStandardAdapters.filter((previousAdapter) => !currentAdapters.has(previousAdapter)));\n        removedAdapters.forEach((adapter) => adapter.destroy());\n    }, [prevStandardAdapters, standardAdapters]);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => () => standardAdapters.forEach((adapter) => adapter.destroy()), []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_0__.useMemo)(() => [\n        ...standardAdapters,\n        ...adapters.filter(({ name }) => {\n            if (standardAdapters.some((standardAdapter) => standardAdapter.name === name)) {\n                if (!warnings.has(name)) {\n                    warnings.add(name);\n                    console.warn(`${name} was registered as a Standard Wallet. The Wallet Adapter for ${name} can be removed from your app.`);\n                }\n                return false;\n            }\n            return true;\n        }),\n    ], [standardAdapters, adapters, warnings]);\n}\nfunction useConstant(fn) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    if (!ref.current) {\n        ref.current = { value: fn() };\n    }\n    return ref.current.value;\n}\nfunction usePrevious(state) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n        ref.current = state;\n    });\n    return ref.current;\n}\nfunction wrapWalletsWithAdapters(wallets) {\n    return wallets.filter(_solana_wallet_standard_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_2__.isWalletAdapterCompatibleWallet).map((wallet) => new _solana_wallet_standard_wallet_adapter_base__WEBPACK_IMPORTED_MODULE_3__.StandardWalletAdapter({ wallet }));\n}\n//# sourceMappingURL=useStandardWalletAdapters.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC13YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL3VzZVN0YW5kYXJkV2FsbGV0QWRhcHRlcnMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBcUg7QUFDeEQ7QUFDQTtBQUN0RDtBQUNQO0FBQ0EsWUFBWSxVQUFVLG9CQUFvQiwyRUFBcUI7QUFDL0Qsb0RBQW9ELCtDQUFRO0FBQzVELElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSSxnREFBUztBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJLGdEQUFTO0FBQ2IsV0FBVyw4Q0FBTztBQUNsQjtBQUNBLDhCQUE4QixNQUFNO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxNQUFNLDhEQUE4RCxNQUFNO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2Q0FBTTtBQUN0QjtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw2Q0FBTTtBQUN0QixJQUFJLGdEQUFTO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHdHQUErQixzQkFBc0IsOEZBQXFCLEdBQUcsUUFBUTtBQUMvRztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dhbGxldC1zdGFuZGFyZC13YWxsZXQtYWRhcHRlci1yZWFjdC9saWIvZXNtL3VzZVN0YW5kYXJkV2FsbGV0QWRhcHRlcnMuanM/NDZkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1dhbGxldEFkYXB0ZXJDb21wYXRpYmxlV2FsbGV0LCBTdGFuZGFyZFdhbGxldEFkYXB0ZXIgfSBmcm9tICdAc29sYW5hL3dhbGxldC1zdGFuZGFyZC13YWxsZXQtYWRhcHRlci1iYXNlJztcbmltcG9ydCB7IERFUFJFQ0FURURfZ2V0V2FsbGV0cyB9IGZyb20gJ0B3YWxsZXQtc3RhbmRhcmQvYXBwJztcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlTWVtbywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmV4cG9ydCBmdW5jdGlvbiB1c2VTdGFuZGFyZFdhbGxldEFkYXB0ZXJzKGFkYXB0ZXJzKSB7XG4gICAgY29uc3Qgd2FybmluZ3MgPSB1c2VDb25zdGFudCgoKSA9PiBuZXcgU2V0KCkpO1xuICAgIGNvbnN0IHsgZ2V0LCBvbiB9ID0gdXNlQ29uc3RhbnQoKCkgPT4gREVQUkVDQVRFRF9nZXRXYWxsZXRzKCkpO1xuICAgIGNvbnN0IFtzdGFuZGFyZEFkYXB0ZXJzLCBzZXRTdGFuZGFyZEFkYXB0ZXJzXSA9IHVzZVN0YXRlKCgpID0+IHdyYXBXYWxsZXRzV2l0aEFkYXB0ZXJzKGdldCgpKSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gW1xuICAgICAgICAgICAgb24oJ3JlZ2lzdGVyJywgKC4uLndhbGxldHMpID0+IHNldFN0YW5kYXJkQWRhcHRlcnMoKHN0YW5kYXJkQWRhcHRlcnMpID0+IFsuLi5zdGFuZGFyZEFkYXB0ZXJzLCAuLi53cmFwV2FsbGV0c1dpdGhBZGFwdGVycyh3YWxsZXRzKV0pKSxcbiAgICAgICAgICAgIG9uKCd1bnJlZ2lzdGVyJywgKC4uLndhbGxldHMpID0+IHNldFN0YW5kYXJkQWRhcHRlcnMoKHN0YW5kYXJkQWRhcHRlcnMpID0+IHN0YW5kYXJkQWRhcHRlcnMuZmlsdGVyKChzdGFuZGFyZEFkYXB0ZXIpID0+IHdhbGxldHMuc29tZSgod2FsbGV0KSA9PiB3YWxsZXQgPT09IHN0YW5kYXJkQWRhcHRlci53YWxsZXQpKSkpLFxuICAgICAgICBdO1xuICAgICAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXJzLmZvckVhY2goKG9mZikgPT4gb2ZmKCkpO1xuICAgIH0sIFtvbl0pO1xuICAgIGNvbnN0IHByZXZTdGFuZGFyZEFkYXB0ZXJzID0gdXNlUHJldmlvdXMoc3RhbmRhcmRBZGFwdGVycyk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFwcmV2U3RhbmRhcmRBZGFwdGVycylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgY3VycmVudEFkYXB0ZXJzID0gbmV3IFNldChzdGFuZGFyZEFkYXB0ZXJzKTtcbiAgICAgICAgY29uc3QgcmVtb3ZlZEFkYXB0ZXJzID0gbmV3IFNldChwcmV2U3RhbmRhcmRBZGFwdGVycy5maWx0ZXIoKHByZXZpb3VzQWRhcHRlcikgPT4gIWN1cnJlbnRBZGFwdGVycy5oYXMocHJldmlvdXNBZGFwdGVyKSkpO1xuICAgICAgICByZW1vdmVkQWRhcHRlcnMuZm9yRWFjaCgoYWRhcHRlcikgPT4gYWRhcHRlci5kZXN0cm95KCkpO1xuICAgIH0sIFtwcmV2U3RhbmRhcmRBZGFwdGVycywgc3RhbmRhcmRBZGFwdGVyc10pO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICB1c2VFZmZlY3QoKCkgPT4gKCkgPT4gc3RhbmRhcmRBZGFwdGVycy5mb3JFYWNoKChhZGFwdGVyKSA9PiBhZGFwdGVyLmRlc3Ryb3koKSksIFtdKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiBbXG4gICAgICAgIC4uLnN0YW5kYXJkQWRhcHRlcnMsXG4gICAgICAgIC4uLmFkYXB0ZXJzLmZpbHRlcigoeyBuYW1lIH0pID0+IHtcbiAgICAgICAgICAgIGlmIChzdGFuZGFyZEFkYXB0ZXJzLnNvbWUoKHN0YW5kYXJkQWRhcHRlcikgPT4gc3RhbmRhcmRBZGFwdGVyLm5hbWUgPT09IG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF3YXJuaW5ncy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgd2FybmluZ3MuYWRkKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYCR7bmFtZX0gd2FzIHJlZ2lzdGVyZWQgYXMgYSBTdGFuZGFyZCBXYWxsZXQuIFRoZSBXYWxsZXQgQWRhcHRlciBmb3IgJHtuYW1lfSBjYW4gYmUgcmVtb3ZlZCBmcm9tIHlvdXIgYXBwLmApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSksXG4gICAgXSwgW3N0YW5kYXJkQWRhcHRlcnMsIGFkYXB0ZXJzLCB3YXJuaW5nc10pO1xufVxuZnVuY3Rpb24gdXNlQ29uc3RhbnQoZm4pIHtcbiAgICBjb25zdCByZWYgPSB1c2VSZWYoKTtcbiAgICBpZiAoIXJlZi5jdXJyZW50KSB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0geyB2YWx1ZTogZm4oKSB9O1xuICAgIH1cbiAgICByZXR1cm4gcmVmLmN1cnJlbnQudmFsdWU7XG59XG5mdW5jdGlvbiB1c2VQcmV2aW91cyhzdGF0ZSkge1xuICAgIGNvbnN0IHJlZiA9IHVzZVJlZigpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gc3RhdGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlZi5jdXJyZW50O1xufVxuZnVuY3Rpb24gd3JhcFdhbGxldHNXaXRoQWRhcHRlcnMod2FsbGV0cykge1xuICAgIHJldHVybiB3YWxsZXRzLmZpbHRlcihpc1dhbGxldEFkYXB0ZXJDb21wYXRpYmxlV2FsbGV0KS5tYXAoKHdhbGxldCkgPT4gbmV3IFN0YW5kYXJkV2FsbGV0QWRhcHRlcih7IHdhbGxldCB9KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VTdGFuZGFyZFdhbGxldEFkYXB0ZXJzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/wallet-standard-wallet-adapter-react/lib/esm/useStandardWalletAdapters.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_assert.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_assert.js ***!
  \********************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bool: function() { return /* binding */ bool; },\n/* harmony export */   bytes: function() { return /* binding */ bytes; },\n/* harmony export */   exists: function() { return /* binding */ exists; },\n/* harmony export */   hash: function() { return /* binding */ hash; },\n/* harmony export */   isBytes: function() { return /* binding */ isBytes; },\n/* harmony export */   number: function() { return /* binding */ number; },\n/* harmony export */   output: function() { return /* binding */ output; }\n/* harmony export */ });\nfunction number(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n        throw new Error(`positive integer expected, not ${n}`);\n}\nfunction bool(b) {\n    if (typeof b !== 'boolean')\n        throw new Error(`boolean expected, not ${b}`);\n}\n// copied from utils\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\nfunction bytes(b, ...lengths) {\n    if (!isBytes(b))\n        throw new Error('Uint8Array expected');\n    if (lengths.length > 0 && !lengths.includes(b.length))\n        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n    if (typeof h !== 'function' || typeof h.create !== 'function')\n        throw new Error('Hash should be wrapped by utils.wrapConstructor');\n    number(h.outputLen);\n    number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n    if (instance.destroyed)\n        throw new Error('Hash instance has been destroyed');\n    if (checkFinished && instance.finished)\n        throw new Error('Hash#digest() has already been called');\n}\nfunction output(out, instance) {\n    bytes(out);\n    const min = instance.outputLen;\n    if (out.length < min) {\n        throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n    }\n}\n\nconst assert = { number, bool, bytes, hash, exists, output };\n/* harmony default export */ __webpack_exports__[\"default\"] = (assert);\n//# sourceMappingURL=_assert.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19hc3NlcnQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQSwwREFBMEQsRUFBRTtBQUM1RDtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxRQUFRLGtCQUFrQixTQUFTO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsSUFBSTtBQUNyRjtBQUNBO0FBQ3FEO0FBQ3JELGlCQUFpQjtBQUNqQiwrREFBZSxNQUFNLEVBQUM7QUFDdEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX2Fzc2VydC5qcz85MWMzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIG51bWJlcihuKSB7XG4gICAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihuKSB8fCBuIDwgMClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBwb3NpdGl2ZSBpbnRlZ2VyIGV4cGVjdGVkLCBub3QgJHtufWApO1xufVxuZnVuY3Rpb24gYm9vbChiKSB7XG4gICAgaWYgKHR5cGVvZiBiICE9PSAnYm9vbGVhbicpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYm9vbGVhbiBleHBlY3RlZCwgbm90ICR7Yn1gKTtcbn1cbi8vIGNvcGllZCBmcm9tIHV0aWxzXG5leHBvcnQgZnVuY3Rpb24gaXNCeXRlcyhhKSB7XG4gICAgcmV0dXJuIChhIGluc3RhbmNlb2YgVWludDhBcnJheSB8fFxuICAgICAgICAoYSAhPSBudWxsICYmIHR5cGVvZiBhID09PSAnb2JqZWN0JyAmJiBhLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdVaW50OEFycmF5JykpO1xufVxuZnVuY3Rpb24gYnl0ZXMoYiwgLi4ubGVuZ3Rocykge1xuICAgIGlmICghaXNCeXRlcyhiKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVaW50OEFycmF5IGV4cGVjdGVkJyk7XG4gICAgaWYgKGxlbmd0aHMubGVuZ3RoID4gMCAmJiAhbGVuZ3Rocy5pbmNsdWRlcyhiLmxlbmd0aCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVWludDhBcnJheSBleHBlY3RlZCBvZiBsZW5ndGggJHtsZW5ndGhzfSwgbm90IG9mIGxlbmd0aD0ke2IubGVuZ3RofWApO1xufVxuZnVuY3Rpb24gaGFzaChoKSB7XG4gICAgaWYgKHR5cGVvZiBoICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBoLmNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoIHNob3VsZCBiZSB3cmFwcGVkIGJ5IHV0aWxzLndyYXBDb25zdHJ1Y3RvcicpO1xuICAgIG51bWJlcihoLm91dHB1dExlbik7XG4gICAgbnVtYmVyKGguYmxvY2tMZW4pO1xufVxuZnVuY3Rpb24gZXhpc3RzKGluc3RhbmNlLCBjaGVja0ZpbmlzaGVkID0gdHJ1ZSkge1xuICAgIGlmIChpbnN0YW5jZS5kZXN0cm95ZWQpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSGFzaCBpbnN0YW5jZSBoYXMgYmVlbiBkZXN0cm95ZWQnKTtcbiAgICBpZiAoY2hlY2tGaW5pc2hlZCAmJiBpbnN0YW5jZS5maW5pc2hlZClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdIYXNoI2RpZ2VzdCgpIGhhcyBhbHJlYWR5IGJlZW4gY2FsbGVkJyk7XG59XG5mdW5jdGlvbiBvdXRwdXQob3V0LCBpbnN0YW5jZSkge1xuICAgIGJ5dGVzKG91dCk7XG4gICAgY29uc3QgbWluID0gaW5zdGFuY2Uub3V0cHV0TGVuO1xuICAgIGlmIChvdXQubGVuZ3RoIDwgbWluKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgZGlnZXN0SW50bygpIGV4cGVjdHMgb3V0cHV0IGJ1ZmZlciBvZiBsZW5ndGggYXQgbGVhc3QgJHttaW59YCk7XG4gICAgfVxufVxuZXhwb3J0IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmNvbnN0IGFzc2VydCA9IHsgbnVtYmVyLCBib29sLCBieXRlcywgaGFzaCwgZXhpc3RzLCBvdXRwdXQgfTtcbmV4cG9ydCBkZWZhdWx0IGFzc2VydDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9hc3NlcnQuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_assert.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_md.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_md.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Chi: function() { return /* binding */ Chi; },\n/* harmony export */   HashMD: function() { return /* binding */ HashMD; },\n/* harmony export */   Maj: function() { return /* binding */ Maj; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// Polyfill for Safari 14\nfunction setBigUint64(view, byteOffset, value, isLE) {\n    if (typeof view.setBigUint64 === 'function')\n        return view.setBigUint64(byteOffset, value, isLE);\n    const _32n = BigInt(32);\n    const _u32_max = BigInt(0xffffffff);\n    const wh = Number((value >> _32n) & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE ? 4 : 0;\n    const l = isLE ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE);\n    view.setUint32(byteOffset + l, wl, isLE);\n}\n// Choice: a ? b : c\nconst Chi = (a, b, c) => (a & b) ^ (~a & c);\n// Majority function, true if any two inpust is true\nconst Maj = (a, b, c) => (a & b) ^ (a & c) ^ (b & c);\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nclass HashMD extends _utils_js__WEBPACK_IMPORTED_MODULE_0__.Hash {\n    constructor(blockLen, outputLen, padOffset, isLE) {\n        super();\n        this.blockLen = blockLen;\n        this.outputLen = outputLen;\n        this.padOffset = padOffset;\n        this.isLE = isLE;\n        this.finished = false;\n        this.length = 0;\n        this.pos = 0;\n        this.destroyed = false;\n        this.buffer = new Uint8Array(blockLen);\n        this.view = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(this.buffer);\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        const { view, buffer, blockLen } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            // Fast path: we have at least one block in input, cast it to view and process\n            if (take === blockLen) {\n                const dataView = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(data);\n                for (; blockLen <= len - pos; pos += blockLen)\n                    this.process(dataView, pos);\n                continue;\n            }\n            buffer.set(data.subarray(pos, pos + take), this.pos);\n            this.pos += take;\n            pos += take;\n            if (this.pos === blockLen) {\n                this.process(view, 0);\n                this.pos = 0;\n            }\n        }\n        this.length += data.length;\n        this.roundClean();\n        return this;\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.exists)(this);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_1__.output)(out, this);\n        this.finished = true;\n        // Padding\n        // We can avoid allocation of buffer for padding completely if it\n        // was previously not allocated here. But it won't change performance.\n        const { buffer, view, blockLen, isLE } = this;\n        let { pos } = this;\n        // append the bit '1' to the message\n        buffer[pos++] = 0b10000000;\n        this.buffer.subarray(pos).fill(0);\n        // we have less than padOffset left in buffer, so we cannot put length in\n        // current block, need process it and pad again\n        if (this.padOffset > blockLen - pos) {\n            this.process(view, 0);\n            pos = 0;\n        }\n        // Pad until full block byte with zeros\n        for (let i = pos; i < blockLen; i++)\n            buffer[i] = 0;\n        // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n        // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n        // So we just write lowest 64 bits of that value.\n        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n        this.process(view, 0);\n        const oview = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.createView)(out);\n        const len = this.outputLen;\n        // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n        if (len % 4)\n            throw new Error('_sha2: outputLen should be aligned to 32bit');\n        const outLen = len / 4;\n        const state = this.get();\n        if (outLen > state.length)\n            throw new Error('_sha2: outputLen bigger than state');\n        for (let i = 0; i < outLen; i++)\n            oview.setUint32(4 * i, state[i], isLE);\n    }\n    digest() {\n        const { buffer, outputLen } = this;\n        this.digestInto(buffer);\n        const res = buffer.slice(0, outputLen);\n        this.destroy();\n        return res;\n    }\n    _cloneInto(to) {\n        to || (to = new this.constructor());\n        to.set(...this.get());\n        const { blockLen, buffer, length, finished, destroyed, pos } = this;\n        to.length = length;\n        to.pos = pos;\n        to.finished = finished;\n        to.destroyed = destroyed;\n        if (length % blockLen)\n            to.buffer.set(buffer);\n        return to;\n    }\n}\n//# sourceMappingURL=_md.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL19tZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUE4QztBQUNTO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNPLHFCQUFxQiwyQ0FBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFEQUFVO0FBQzlCO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsZ0JBQWdCLHlCQUF5QjtBQUN6QyxlQUFlLGtEQUFPO0FBQ3RCO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFEQUFVO0FBQzNDLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtCQUErQjtBQUMvQyxjQUFjLE1BQU07QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsY0FBYztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IscURBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixZQUFZO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQkFBb0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vX21kLmpzPzU4MGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXhpc3RzLCBvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgSGFzaCwgY3JlYXRlVmlldywgdG9CeXRlcyB9IGZyb20gJy4vdXRpbHMuanMnO1xuLy8gUG9seWZpbGwgZm9yIFNhZmFyaSAxNFxuZnVuY3Rpb24gc2V0QmlnVWludDY0KHZpZXcsIGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKSB7XG4gICAgaWYgKHR5cGVvZiB2aWV3LnNldEJpZ1VpbnQ2NCA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIHZpZXcuc2V0QmlnVWludDY0KGJ5dGVPZmZzZXQsIHZhbHVlLCBpc0xFKTtcbiAgICBjb25zdCBfMzJuID0gQmlnSW50KDMyKTtcbiAgICBjb25zdCBfdTMyX21heCA9IEJpZ0ludCgweGZmZmZmZmZmKTtcbiAgICBjb25zdCB3aCA9IE51bWJlcigodmFsdWUgPj4gXzMybikgJiBfdTMyX21heCk7XG4gICAgY29uc3Qgd2wgPSBOdW1iZXIodmFsdWUgJiBfdTMyX21heCk7XG4gICAgY29uc3QgaCA9IGlzTEUgPyA0IDogMDtcbiAgICBjb25zdCBsID0gaXNMRSA/IDAgOiA0O1xuICAgIHZpZXcuc2V0VWludDMyKGJ5dGVPZmZzZXQgKyBoLCB3aCwgaXNMRSk7XG4gICAgdmlldy5zZXRVaW50MzIoYnl0ZU9mZnNldCArIGwsIHdsLCBpc0xFKTtcbn1cbi8vIENob2ljZTogYSA/IGIgOiBjXG5leHBvcnQgY29uc3QgQ2hpID0gKGEsIGIsIGMpID0+IChhICYgYikgXiAofmEgJiBjKTtcbi8vIE1ham9yaXR5IGZ1bmN0aW9uLCB0cnVlIGlmIGFueSB0d28gaW5wdXN0IGlzIHRydWVcbmV4cG9ydCBjb25zdCBNYWogPSAoYSwgYiwgYykgPT4gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuLyoqXG4gKiBNZXJrbGUtRGFtZ2FyZCBoYXNoIGNvbnN0cnVjdGlvbiBiYXNlIGNsYXNzLlxuICogQ291bGQgYmUgdXNlZCB0byBjcmVhdGUgTUQ1LCBSSVBFTUQsIFNIQTEsIFNIQTIuXG4gKi9cbmV4cG9ydCBjbGFzcyBIYXNoTUQgZXh0ZW5kcyBIYXNoIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgb3V0cHV0TGVuLCBwYWRPZmZzZXQsIGlzTEUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ibG9ja0xlbiA9IGJsb2NrTGVuO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5wYWRPZmZzZXQgPSBwYWRPZmZzZXQ7XG4gICAgICAgIHRoaXMuaXNMRSA9IGlzTEU7XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmxvY2tMZW4pO1xuICAgICAgICB0aGlzLnZpZXcgPSBjcmVhdGVWaWV3KHRoaXMuYnVmZmVyKTtcbiAgICB9XG4gICAgdXBkYXRlKGRhdGEpIHtcbiAgICAgICAgZXhpc3RzKHRoaXMpO1xuICAgICAgICBjb25zdCB7IHZpZXcsIGJ1ZmZlciwgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGRhdGEgPSB0b0J5dGVzKGRhdGEpO1xuICAgICAgICBjb25zdCBsZW4gPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuOykge1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3MsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGg6IHdlIGhhdmUgYXQgbGVhc3Qgb25lIGJsb2NrIGluIGlucHV0LCBjYXN0IGl0IHRvIHZpZXcgYW5kIHByb2Nlc3NcbiAgICAgICAgICAgIGlmICh0YWtlID09PSBibG9ja0xlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGFWaWV3ID0gY3JlYXRlVmlldyhkYXRhKTtcbiAgICAgICAgICAgICAgICBmb3IgKDsgYmxvY2tMZW4gPD0gbGVuIC0gcG9zOyBwb3MgKz0gYmxvY2tMZW4pXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2VzcyhkYXRhVmlldywgcG9zKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1ZmZlci5zZXQoZGF0YS5zdWJhcnJheShwb3MsIHBvcyArIHRha2UpLCB0aGlzLnBvcyk7XG4gICAgICAgICAgICB0aGlzLnBvcyArPSB0YWtlO1xuICAgICAgICAgICAgcG9zICs9IHRha2U7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgICAgIHRoaXMucG9zID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5yb3VuZENsZWFuKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBkaWdlc3RJbnRvKG91dCkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIG91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICB0aGlzLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgLy8gUGFkZGluZ1xuICAgICAgICAvLyBXZSBjYW4gYXZvaWQgYWxsb2NhdGlvbiBvZiBidWZmZXIgZm9yIHBhZGRpbmcgY29tcGxldGVseSBpZiBpdFxuICAgICAgICAvLyB3YXMgcHJldmlvdXNseSBub3QgYWxsb2NhdGVkIGhlcmUuIEJ1dCBpdCB3b24ndCBjaGFuZ2UgcGVyZm9ybWFuY2UuXG4gICAgICAgIGNvbnN0IHsgYnVmZmVyLCB2aWV3LCBibG9ja0xlbiwgaXNMRSB9ID0gdGhpcztcbiAgICAgICAgbGV0IHsgcG9zIH0gPSB0aGlzO1xuICAgICAgICAvLyBhcHBlbmQgdGhlIGJpdCAnMScgdG8gdGhlIG1lc3NhZ2VcbiAgICAgICAgYnVmZmVyW3BvcysrXSA9IDBiMTAwMDAwMDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnN1YmFycmF5KHBvcykuZmlsbCgwKTtcbiAgICAgICAgLy8gd2UgaGF2ZSBsZXNzIHRoYW4gcGFkT2Zmc2V0IGxlZnQgaW4gYnVmZmVyLCBzbyB3ZSBjYW5ub3QgcHV0IGxlbmd0aCBpblxuICAgICAgICAvLyBjdXJyZW50IGJsb2NrLCBuZWVkIHByb2Nlc3MgaXQgYW5kIHBhZCBhZ2FpblxuICAgICAgICBpZiAodGhpcy5wYWRPZmZzZXQgPiBibG9ja0xlbiAtIHBvcykge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzKHZpZXcsIDApO1xuICAgICAgICAgICAgcG9zID0gMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYWQgdW50aWwgZnVsbCBibG9jayBieXRlIHdpdGggemVyb3NcbiAgICAgICAgZm9yIChsZXQgaSA9IHBvczsgaSA8IGJsb2NrTGVuOyBpKyspXG4gICAgICAgICAgICBidWZmZXJbaV0gPSAwO1xuICAgICAgICAvLyBOb3RlOiBzaGE1MTIgcmVxdWlyZXMgbGVuZ3RoIHRvIGJlIDEyOGJpdCBpbnRlZ2VyLCBidXQgbGVuZ3RoIGluIEpTIHdpbGwgb3ZlcmZsb3cgYmVmb3JlIHRoYXRcbiAgICAgICAgLy8gWW91IG5lZWQgdG8gd3JpdGUgYXJvdW5kIDIgZXhhYnl0ZXMgKHU2NF9tYXggLyA4IC8gKDEwMjQqKjYpKSBmb3IgdGhpcyB0byBoYXBwZW4uXG4gICAgICAgIC8vIFNvIHdlIGp1c3Qgd3JpdGUgbG93ZXN0IDY0IGJpdHMgb2YgdGhhdCB2YWx1ZS5cbiAgICAgICAgc2V0QmlnVWludDY0KHZpZXcsIGJsb2NrTGVuIC0gOCwgQmlnSW50KHRoaXMubGVuZ3RoICogOCksIGlzTEUpO1xuICAgICAgICB0aGlzLnByb2Nlc3ModmlldywgMCk7XG4gICAgICAgIGNvbnN0IG92aWV3ID0gY3JlYXRlVmlldyhvdXQpO1xuICAgICAgICBjb25zdCBsZW4gPSB0aGlzLm91dHB1dExlbjtcbiAgICAgICAgLy8gTk9URTogd2UgZG8gZGl2aXNpb24gYnkgNCBsYXRlciwgd2hpY2ggc2hvdWxkIGJlIGZ1c2VkIGluIHNpbmdsZSBvcCB3aXRoIG1vZHVsbyBieSBKSVRcbiAgICAgICAgaWYgKGxlbiAlIDQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ19zaGEyOiBvdXRwdXRMZW4gc2hvdWxkIGJlIGFsaWduZWQgdG8gMzJiaXQnKTtcbiAgICAgICAgY29uc3Qgb3V0TGVuID0gbGVuIC8gNDtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldCgpO1xuICAgICAgICBpZiAob3V0TGVuID4gc3RhdGUubGVuZ3RoKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdfc2hhMjogb3V0cHV0TGVuIGJpZ2dlciB0aGFuIHN0YXRlJyk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0TGVuOyBpKyspXG4gICAgICAgICAgICBvdmlldy5zZXRVaW50MzIoNCAqIGksIHN0YXRlW2ldLCBpc0xFKTtcbiAgICB9XG4gICAgZGlnZXN0KCkge1xuICAgICAgICBjb25zdCB7IGJ1ZmZlciwgb3V0cHV0TGVuIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmRpZ2VzdEludG8oYnVmZmVyKTtcbiAgICAgICAgY29uc3QgcmVzID0gYnVmZmVyLnNsaWNlKDAsIG91dHB1dExlbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBfY2xvbmVJbnRvKHRvKSB7XG4gICAgICAgIHRvIHx8ICh0byA9IG5ldyB0aGlzLmNvbnN0cnVjdG9yKCkpO1xuICAgICAgICB0by5zZXQoLi4udGhpcy5nZXQoKSk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIGJ1ZmZlciwgbGVuZ3RoLCBmaW5pc2hlZCwgZGVzdHJveWVkLCBwb3MgfSA9IHRoaXM7XG4gICAgICAgIHRvLmxlbmd0aCA9IGxlbmd0aDtcbiAgICAgICAgdG8ucG9zID0gcG9zO1xuICAgICAgICB0by5maW5pc2hlZCA9IGZpbmlzaGVkO1xuICAgICAgICB0by5kZXN0cm95ZWQgPSBkZXN0cm95ZWQ7XG4gICAgICAgIGlmIChsZW5ndGggJSBibG9ja0xlbilcbiAgICAgICAgICAgIHRvLmJ1ZmZlci5zZXQoYnVmZmVyKTtcbiAgICAgICAgcmV0dXJuIHRvO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV9tZC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_md.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_u64.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_u64.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   add: function() { return /* binding */ add; },\n/* harmony export */   add3H: function() { return /* binding */ add3H; },\n/* harmony export */   add3L: function() { return /* binding */ add3L; },\n/* harmony export */   add4H: function() { return /* binding */ add4H; },\n/* harmony export */   add4L: function() { return /* binding */ add4L; },\n/* harmony export */   add5H: function() { return /* binding */ add5H; },\n/* harmony export */   add5L: function() { return /* binding */ add5L; },\n/* harmony export */   fromBig: function() { return /* binding */ fromBig; },\n/* harmony export */   rotlBH: function() { return /* binding */ rotlBH; },\n/* harmony export */   rotlBL: function() { return /* binding */ rotlBL; },\n/* harmony export */   rotlSH: function() { return /* binding */ rotlSH; },\n/* harmony export */   rotlSL: function() { return /* binding */ rotlSL; },\n/* harmony export */   rotr32H: function() { return /* binding */ rotr32H; },\n/* harmony export */   rotr32L: function() { return /* binding */ rotr32L; },\n/* harmony export */   rotrBH: function() { return /* binding */ rotrBH; },\n/* harmony export */   rotrBL: function() { return /* binding */ rotrBL; },\n/* harmony export */   rotrSH: function() { return /* binding */ rotrSH; },\n/* harmony export */   rotrSL: function() { return /* binding */ rotrSL; },\n/* harmony export */   shrSH: function() { return /* binding */ shrSH; },\n/* harmony export */   shrSL: function() { return /* binding */ shrSL; },\n/* harmony export */   split: function() { return /* binding */ split; },\n/* harmony export */   toBig: function() { return /* binding */ toBig; }\n/* harmony export */ });\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n// We are not using BigUint64Array, because they are extremely slow as per 2022\nfunction fromBig(n, le = false) {\n    if (le)\n        return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n    return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\nfunction split(lst, le = false) {\n    let Ah = new Uint32Array(lst.length);\n    let Al = new Uint32Array(lst.length);\n    for (let i = 0; i < lst.length; i++) {\n        const { h, l } = fromBig(lst[i], le);\n        [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n}\nconst toBig = (h, l) => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h, _l, s) => h >>> s;\nconst shrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h, l, s) => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h, l, s) => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h, l, s) => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h, l, s) => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h, l) => l;\nconst rotr32L = (h, _l) => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h, l, s) => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h, l, s) => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h, l, s) => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h, l, s) => (h << (s - 32)) | (l >>> (64 - s));\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low, Ah, Bh, Ch) => (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low, Ah, Bh, Ch, Dh) => (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low, Ah, Bh, Ch, Dh, Eh) => (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n// prettier-ignore\n\n// prettier-ignore\nconst u64 = {\n    fromBig, split, toBig,\n    shrSH, shrSL,\n    rotrSH, rotrSL, rotrBH, rotrBL,\n    rotr32H, rotr32L,\n    rotlSH, rotlSL, rotlBH, rotlBL,\n    add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n/* harmony default export */ __webpack_exports__[\"default\"] = (u64);\n//# sourceMappingURL=_u64.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL191NjQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGdCQUFnQjtBQUNwQyxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2lMO0FBQ2pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUFlLEdBQUcsRUFBQztBQUNuQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9fdTY0LmpzPzYxOTIiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgVTMyX01BU0s2NCA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMiAqKiAzMiAtIDEpO1xuY29uc3QgXzMybiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMzIpO1xuLy8gV2UgYXJlIG5vdCB1c2luZyBCaWdVaW50NjRBcnJheSwgYmVjYXVzZSB0aGV5IGFyZSBleHRyZW1lbHkgc2xvdyBhcyBwZXIgMjAyMlxuZnVuY3Rpb24gZnJvbUJpZyhuLCBsZSA9IGZhbHNlKSB7XG4gICAgaWYgKGxlKVxuICAgICAgICByZXR1cm4geyBoOiBOdW1iZXIobiAmIFUzMl9NQVNLNjQpLCBsOiBOdW1iZXIoKG4gPj4gXzMybikgJiBVMzJfTUFTSzY0KSB9O1xuICAgIHJldHVybiB7IGg6IE51bWJlcigobiA+PiBfMzJuKSAmIFUzMl9NQVNLNjQpIHwgMCwgbDogTnVtYmVyKG4gJiBVMzJfTUFTSzY0KSB8IDAgfTtcbn1cbmZ1bmN0aW9uIHNwbGl0KGxzdCwgbGUgPSBmYWxzZSkge1xuICAgIGxldCBBaCA9IG5ldyBVaW50MzJBcnJheShsc3QubGVuZ3RoKTtcbiAgICBsZXQgQWwgPSBuZXcgVWludDMyQXJyYXkobHN0Lmxlbmd0aCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgeyBoLCBsIH0gPSBmcm9tQmlnKGxzdFtpXSwgbGUpO1xuICAgICAgICBbQWhbaV0sIEFsW2ldXSA9IFtoLCBsXTtcbiAgICB9XG4gICAgcmV0dXJuIFtBaCwgQWxdO1xufVxuY29uc3QgdG9CaWcgPSAoaCwgbCkgPT4gKEJpZ0ludChoID4+PiAwKSA8PCBfMzJuKSB8IEJpZ0ludChsID4+PiAwKTtcbi8vIGZvciBTaGlmdCBpbiBbMCwgMzIpXG5jb25zdCBzaHJTSCA9IChoLCBfbCwgcykgPT4gaCA+Pj4gcztcbmNvbnN0IHNoclNMID0gKGgsIGwsIHMpID0+IChoIDw8ICgzMiAtIHMpKSB8IChsID4+PiBzKTtcbi8vIFJpZ2h0IHJvdGF0ZSBmb3IgU2hpZnQgaW4gWzEsIDMyKVxuY29uc3Qgcm90clNIID0gKGgsIGwsIHMpID0+IChoID4+PiBzKSB8IChsIDw8ICgzMiAtIHMpKTtcbmNvbnN0IHJvdHJTTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAoMzIgLSBzKSkgfCAobCA+Pj4gcyk7XG4vLyBSaWdodCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RyQkggPSAoaCwgbCwgcykgPT4gKGggPDwgKDY0IC0gcykpIHwgKGwgPj4+IChzIC0gMzIpKTtcbmNvbnN0IHJvdHJCTCA9IChoLCBsLCBzKSA9PiAoaCA+Pj4gKHMgLSAzMikpIHwgKGwgPDwgKDY0IC0gcykpO1xuLy8gUmlnaHQgcm90YXRlIGZvciBzaGlmdD09PTMyIChqdXN0IHN3YXBzIGwmaClcbmNvbnN0IHJvdHIzMkggPSAoX2gsIGwpID0+IGw7XG5jb25zdCByb3RyMzJMID0gKGgsIF9sKSA9PiBoO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluIFsxLCAzMilcbmNvbnN0IHJvdGxTSCA9IChoLCBsLCBzKSA9PiAoaCA8PCBzKSB8IChsID4+PiAoMzIgLSBzKSk7XG5jb25zdCByb3RsU0wgPSAoaCwgbCwgcykgPT4gKGwgPDwgcykgfCAoaCA+Pj4gKDMyIC0gcykpO1xuLy8gTGVmdCByb3RhdGUgZm9yIFNoaWZ0IGluICgzMiwgNjQpLCBOT1RFOiAzMiBpcyBzcGVjaWFsIGNhc2UuXG5jb25zdCByb3RsQkggPSAoaCwgbCwgcykgPT4gKGwgPDwgKHMgLSAzMikpIHwgKGggPj4+ICg2NCAtIHMpKTtcbmNvbnN0IHJvdGxCTCA9IChoLCBsLCBzKSA9PiAoaCA8PCAocyAtIDMyKSkgfCAobCA+Pj4gKDY0IC0gcykpO1xuLy8gSlMgdXNlcyAzMi1iaXQgc2lnbmVkIGludGVnZXJzIGZvciBiaXR3aXNlIG9wZXJhdGlvbnMgd2hpY2ggbWVhbnMgd2UgY2Fubm90XG4vLyBzaW1wbGUgdGFrZSBjYXJyeSBvdXQgb2YgbG93IGJpdCBzdW0gYnkgc2hpZnQsIHdlIG5lZWQgdG8gdXNlIGRpdmlzaW9uLlxuZnVuY3Rpb24gYWRkKEFoLCBBbCwgQmgsIEJsKSB7XG4gICAgY29uc3QgbCA9IChBbCA+Pj4gMCkgKyAoQmwgPj4+IDApO1xuICAgIHJldHVybiB7IGg6IChBaCArIEJoICsgKChsIC8gMiAqKiAzMikgfCAwKSkgfCAwLCBsOiBsIHwgMCB9O1xufVxuLy8gQWRkaXRpb24gd2l0aCBtb3JlIHRoYW4gMiBlbGVtZW50c1xuY29uc3QgYWRkM0wgPSAoQWwsIEJsLCBDbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApO1xuY29uc3QgYWRkM0ggPSAobG93LCBBaCwgQmgsIENoKSA9PiAoQWggKyBCaCArIENoICsgKChsb3cgLyAyICoqIDMyKSB8IDApKSB8IDA7XG5jb25zdCBhZGQ0TCA9IChBbCwgQmwsIENsLCBEbCkgPT4gKEFsID4+PiAwKSArIChCbCA+Pj4gMCkgKyAoQ2wgPj4+IDApICsgKERsID4+PiAwKTtcbmNvbnN0IGFkZDRIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgpID0+IChBaCArIEJoICsgQ2ggKyBEaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuY29uc3QgYWRkNUwgPSAoQWwsIEJsLCBDbCwgRGwsIEVsKSA9PiAoQWwgPj4+IDApICsgKEJsID4+PiAwKSArIChDbCA+Pj4gMCkgKyAoRGwgPj4+IDApICsgKEVsID4+PiAwKTtcbmNvbnN0IGFkZDVIID0gKGxvdywgQWgsIEJoLCBDaCwgRGgsIEVoKSA9PiAoQWggKyBCaCArIENoICsgRGggKyBFaCArICgobG93IC8gMiAqKiAzMikgfCAwKSkgfCAwO1xuLy8gcHJldHRpZXItaWdub3JlXG5leHBvcnQgeyBmcm9tQmlnLCBzcGxpdCwgdG9CaWcsIHNoclNILCBzaHJTTCwgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLCByb3RyMzJILCByb3RyMzJMLCByb3RsU0gsIHJvdGxTTCwgcm90bEJILCByb3RsQkwsIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCwgfTtcbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdTY0ID0ge1xuICAgIGZyb21CaWcsIHNwbGl0LCB0b0JpZyxcbiAgICBzaHJTSCwgc2hyU0wsXG4gICAgcm90clNILCByb3RyU0wsIHJvdHJCSCwgcm90ckJMLFxuICAgIHJvdHIzMkgsIHJvdHIzMkwsXG4gICAgcm90bFNILCByb3RsU0wsIHJvdGxCSCwgcm90bEJMLFxuICAgIGFkZCwgYWRkM0wsIGFkZDNILCBhZGQ0TCwgYWRkNEgsIGFkZDVILCBhZGQ1TCxcbn07XG5leHBvcnQgZGVmYXVsdCB1NjQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdTY0LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_u64.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/crypto.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/crypto.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   crypto: function() { return /* binding */ crypto; }\n/* harmony export */ });\nconst crypto = typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n//# sourceMappingURL=crypto.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL2NyeXB0by5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU87QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9jcnlwdG8uanM/NjNhMCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgY3J5cHRvID0gdHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnICYmICdjcnlwdG8nIGluIGdsb2JhbFRoaXMgPyBnbG9iYWxUaGlzLmNyeXB0byA6IHVuZGVmaW5lZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyeXB0by5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/crypto.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha256.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha256.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   sha224: function() { return /* binding */ sha224; },\n/* harmony export */   sha256: function() { return /* binding */ sha256; }\n/* harmony export */ });\n/* harmony import */ var _md_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_md.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_md.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js\");\n\n\n// SHA2-256 need to try 2^128 hashes to execute birthday attack.\n// BTC network is doing 2^67 hashes/sec as per early 2023.\n// Round constants:\n// first 32 bits of the fractional parts of the cube roots of the first 64 primes 2..311)\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n// Initial state:\n// first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n// Temporary buffer, not used to store anything between runs\n// Named this way because it matches specification.\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nclass SHA256 extends _md_js__WEBPACK_IMPORTED_MODULE_0__.HashMD {\n    constructor() {\n        super(64, 32, 8, false);\n        // We cannot use array here since array allows indexing by variable\n        // which means optimizer/compiler cannot use registers.\n        this.A = SHA256_IV[0] | 0;\n        this.B = SHA256_IV[1] | 0;\n        this.C = SHA256_IV[2] | 0;\n        this.D = SHA256_IV[3] | 0;\n        this.E = SHA256_IV[4] | 0;\n        this.F = SHA256_IV[5] | 0;\n        this.G = SHA256_IV[6] | 0;\n        this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n        const { A, B, C, D, E, F, G, H } = this;\n        return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n        this.A = A | 0;\n        this.B = B | 0;\n        this.C = C | 0;\n        this.D = D | 0;\n        this.E = E | 0;\n        this.F = F | 0;\n        this.G = G | 0;\n        this.H = H | 0;\n    }\n    process(view, offset) {\n        // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n        for (let i = 0; i < 16; i++, offset += 4)\n            SHA256_W[i] = view.getUint32(offset, false);\n        for (let i = 16; i < 64; i++) {\n            const W15 = SHA256_W[i - 15];\n            const W2 = SHA256_W[i - 2];\n            const s0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 7) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W15, 18) ^ (W15 >>> 3);\n            const s1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 17) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(W2, 19) ^ (W2 >>> 10);\n            SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n        }\n        // Compression function main loop, 64 rounds\n        let { A, B, C, D, E, F, G, H } = this;\n        for (let i = 0; i < 64; i++) {\n            const sigma1 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 6) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 11) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(E, 25);\n            const T1 = (H + sigma1 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n            const sigma0 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 2) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 13) ^ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.rotr)(A, 22);\n            const T2 = (sigma0 + (0,_md_js__WEBPACK_IMPORTED_MODULE_0__.Maj)(A, B, C)) | 0;\n            H = G;\n            G = F;\n            F = E;\n            E = (D + T1) | 0;\n            D = C;\n            C = B;\n            B = A;\n            A = (T1 + T2) | 0;\n        }\n        // Add the compressed chunk to the current hash value\n        A = (A + this.A) | 0;\n        B = (B + this.B) | 0;\n        C = (C + this.C) | 0;\n        D = (D + this.D) | 0;\n        E = (E + this.E) | 0;\n        F = (F + this.F) | 0;\n        G = (G + this.G) | 0;\n        H = (H + this.H) | 0;\n        this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n        SHA256_W.fill(0);\n    }\n    destroy() {\n        this.set(0, 0, 0, 0, 0, 0, 0, 0);\n        this.buffer.fill(0);\n    }\n}\n// Constants from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf\nclass SHA224 extends SHA256 {\n    constructor() {\n        super();\n        this.A = 0xc1059ed8 | 0;\n        this.B = 0x367cd507 | 0;\n        this.C = 0x3070dd17 | 0;\n        this.D = 0xf70e5939 | 0;\n        this.E = 0xffc00b31 | 0;\n        this.F = 0x68581511 | 0;\n        this.G = 0x64f98fa7 | 0;\n        this.H = 0xbefa4fa4 | 0;\n        this.outputLen = 28;\n    }\n}\n/**\n * SHA2-256 hash function\n * @param message - data that would be hashed\n */\nconst sha256 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA256());\nconst sha224 = /* @__PURE__ */ (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new SHA224());\n//# sourceMappingURL=sha256.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQTRDO0FBQ087QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBDQUFNO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUJBQXlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDLHVCQUF1QiwrQ0FBSSxXQUFXLCtDQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGNBQWMseUJBQXlCO0FBQ3ZDLHdCQUF3QixRQUFRO0FBQ2hDLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQscUNBQXFDLDJDQUFHO0FBQ3hDLDJCQUEyQiwrQ0FBSSxTQUFTLCtDQUFJLFVBQVUsK0NBQUk7QUFDMUQsaUNBQWlDLDJDQUFHO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTywrQkFBK0IsMERBQWU7QUFDOUMsK0JBQStCLDBEQUFlO0FBQ3JEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTI1Ni5qcz80MGM1Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEhhc2hNRCwgQ2hpLCBNYWogfSBmcm9tICcuL19tZC5qcyc7XG5pbXBvcnQgeyByb3RyLCB3cmFwQ29uc3RydWN0b3IgfSBmcm9tICcuL3V0aWxzLmpzJztcbi8vIFNIQTItMjU2IG5lZWQgdG8gdHJ5IDJeMTI4IGhhc2hlcyB0byBleGVjdXRlIGJpcnRoZGF5IGF0dGFjay5cbi8vIEJUQyBuZXR3b3JrIGlzIGRvaW5nIDJeNjcgaGFzaGVzL3NlYyBhcyBwZXIgZWFybHkgMjAyMy5cbi8vIFJvdW5kIGNvbnN0YW50czpcbi8vIGZpcnN0IDMyIGJpdHMgb2YgdGhlIGZyYWN0aW9uYWwgcGFydHMgb2YgdGhlIGN1YmUgcm9vdHMgb2YgdGhlIGZpcnN0IDY0IHByaW1lcyAyLi4zMTEpXG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9LID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheShbXG4gICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YiwgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSxcbiAgICAweGQ4MDdhYTk4LCAweDEyODM1YjAxLCAweDI0MzE4NWJlLCAweDU1MGM3ZGMzLCAweDcyYmU1ZDc0LCAweDgwZGViMWZlLCAweDliZGMwNmE3LCAweGMxOWJmMTc0LFxuICAgIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gICAgMHg5ODNlNTE1MiwgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NywgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NyxcbiAgICAweDI3YjcwYTg1LCAweDJlMWIyMTM4LCAweDRkMmM2ZGZjLCAweDUzMzgwZDEzLCAweDY1MGE3MzU0LCAweDc2NmEwYWJiLCAweDgxYzJjOTJlLCAweDkyNzIyYzg1LFxuICAgIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gICAgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCwgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZiwgMHg2ODJlNmZmMyxcbiAgICAweDc0OGY4MmVlLCAweDc4YTU2MzZmLCAweDg0Yzg3ODE0LCAweDhjYzcwMjA4LCAweDkwYmVmZmZhLCAweGE0NTA2Y2ViLCAweGJlZjlhM2Y3LCAweGM2NzE3OGYyXG5dKTtcbi8vIEluaXRpYWwgc3RhdGU6XG4vLyBmaXJzdCAzMiBiaXRzIG9mIHRoZSBmcmFjdGlvbmFsIHBhcnRzIG9mIHRoZSBzcXVhcmUgcm9vdHMgb2YgdGhlIGZpcnN0IDggcHJpbWVzIDIuLjE5XG4vLyBwcmV0dGllci1pZ25vcmVcbmNvbnN0IFNIQTI1Nl9JViA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVWludDMyQXJyYXkoW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsIDB4NTEwZTUyN2YsIDB4OWIwNTY4OGMsIDB4MWY4M2Q5YWIsIDB4NWJlMGNkMTlcbl0pO1xuLy8gVGVtcG9yYXJ5IGJ1ZmZlciwgbm90IHVzZWQgdG8gc3RvcmUgYW55dGhpbmcgYmV0d2VlbiBydW5zXG4vLyBOYW1lZCB0aGlzIHdheSBiZWNhdXNlIGl0IG1hdGNoZXMgc3BlY2lmaWNhdGlvbi5cbmNvbnN0IFNIQTI1Nl9XID0gLyogQF9fUFVSRV9fICovIG5ldyBVaW50MzJBcnJheSg2NCk7XG5jbGFzcyBTSEEyNTYgZXh0ZW5kcyBIYXNoTUQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcig2NCwgMzIsIDgsIGZhbHNlKTtcbiAgICAgICAgLy8gV2UgY2Fubm90IHVzZSBhcnJheSBoZXJlIHNpbmNlIGFycmF5IGFsbG93cyBpbmRleGluZyBieSB2YXJpYWJsZVxuICAgICAgICAvLyB3aGljaCBtZWFucyBvcHRpbWl6ZXIvY29tcGlsZXIgY2Fubm90IHVzZSByZWdpc3RlcnMuXG4gICAgICAgIHRoaXMuQSA9IFNIQTI1Nl9JVlswXSB8IDA7XG4gICAgICAgIHRoaXMuQiA9IFNIQTI1Nl9JVlsxXSB8IDA7XG4gICAgICAgIHRoaXMuQyA9IFNIQTI1Nl9JVlsyXSB8IDA7XG4gICAgICAgIHRoaXMuRCA9IFNIQTI1Nl9JVlszXSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IFNIQTI1Nl9JVls0XSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IFNIQTI1Nl9JVls1XSB8IDA7XG4gICAgICAgIHRoaXMuRyA9IFNIQTI1Nl9JVls2XSB8IDA7XG4gICAgICAgIHRoaXMuSCA9IFNIQTI1Nl9JVls3XSB8IDA7XG4gICAgfVxuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gW0EsIEIsIEMsIEQsIEUsIEYsIEcsIEhdO1xuICAgIH1cbiAgICAvLyBwcmV0dGllci1pZ25vcmVcbiAgICBzZXQoQSwgQiwgQywgRCwgRSwgRiwgRywgSCkge1xuICAgICAgICB0aGlzLkEgPSBBIHwgMDtcbiAgICAgICAgdGhpcy5CID0gQiB8IDA7XG4gICAgICAgIHRoaXMuQyA9IEMgfCAwO1xuICAgICAgICB0aGlzLkQgPSBEIHwgMDtcbiAgICAgICAgdGhpcy5FID0gRSB8IDA7XG4gICAgICAgIHRoaXMuRiA9IEYgfCAwO1xuICAgICAgICB0aGlzLkcgPSBHIHwgMDtcbiAgICAgICAgdGhpcy5IID0gSCB8IDA7XG4gICAgfVxuICAgIHByb2Nlc3Modmlldywgb2Zmc2V0KSB7XG4gICAgICAgIC8vIEV4dGVuZCB0aGUgZmlyc3QgMTYgd29yZHMgaW50byB0aGUgcmVtYWluaW5nIDQ4IHdvcmRzIHdbMTYuLjYzXSBvZiB0aGUgbWVzc2FnZSBzY2hlZHVsZSBhcnJheVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpKyssIG9mZnNldCArPSA0KVxuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSB2aWV3LmdldFVpbnQzMihvZmZzZXQsIGZhbHNlKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgVzE1ID0gU0hBMjU2X1dbaSAtIDE1XTtcbiAgICAgICAgICAgIGNvbnN0IFcyID0gU0hBMjU2X1dbaSAtIDJdO1xuICAgICAgICAgICAgY29uc3QgczAgPSByb3RyKFcxNSwgNykgXiByb3RyKFcxNSwgMTgpIF4gKFcxNSA+Pj4gMyk7XG4gICAgICAgICAgICBjb25zdCBzMSA9IHJvdHIoVzIsIDE3KSBeIHJvdHIoVzIsIDE5KSBeIChXMiA+Pj4gMTApO1xuICAgICAgICAgICAgU0hBMjU2X1dbaV0gPSAoczEgKyBTSEEyNTZfV1tpIC0gN10gKyBzMCArIFNIQTI1Nl9XW2kgLSAxNl0pIHwgMDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDb21wcmVzc2lvbiBmdW5jdGlvbiBtYWluIGxvb3AsIDY0IHJvdW5kc1xuICAgICAgICBsZXQgeyBBLCBCLCBDLCBELCBFLCBGLCBHLCBIIH0gPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMSA9IHJvdHIoRSwgNikgXiByb3RyKEUsIDExKSBeIHJvdHIoRSwgMjUpO1xuICAgICAgICAgICAgY29uc3QgVDEgPSAoSCArIHNpZ21hMSArIENoaShFLCBGLCBHKSArIFNIQTI1Nl9LW2ldICsgU0hBMjU2X1dbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHNpZ21hMCA9IHJvdHIoQSwgMikgXiByb3RyKEEsIDEzKSBeIHJvdHIoQSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgVDIgPSAoc2lnbWEwICsgTWFqKEEsIEIsIEMpKSB8IDA7XG4gICAgICAgICAgICBIID0gRztcbiAgICAgICAgICAgIEcgPSBGO1xuICAgICAgICAgICAgRiA9IEU7XG4gICAgICAgICAgICBFID0gKEQgKyBUMSkgfCAwO1xuICAgICAgICAgICAgRCA9IEM7XG4gICAgICAgICAgICBDID0gQjtcbiAgICAgICAgICAgIEIgPSBBO1xuICAgICAgICAgICAgQSA9IChUMSArIFQyKSB8IDA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBjb21wcmVzc2VkIGNodW5rIHRvIHRoZSBjdXJyZW50IGhhc2ggdmFsdWVcbiAgICAgICAgQSA9IChBICsgdGhpcy5BKSB8IDA7XG4gICAgICAgIEIgPSAoQiArIHRoaXMuQikgfCAwO1xuICAgICAgICBDID0gKEMgKyB0aGlzLkMpIHwgMDtcbiAgICAgICAgRCA9IChEICsgdGhpcy5EKSB8IDA7XG4gICAgICAgIEUgPSAoRSArIHRoaXMuRSkgfCAwO1xuICAgICAgICBGID0gKEYgKyB0aGlzLkYpIHwgMDtcbiAgICAgICAgRyA9IChHICsgdGhpcy5HKSB8IDA7XG4gICAgICAgIEggPSAoSCArIHRoaXMuSCkgfCAwO1xuICAgICAgICB0aGlzLnNldChBLCBCLCBDLCBELCBFLCBGLCBHLCBIKTtcbiAgICB9XG4gICAgcm91bmRDbGVhbigpIHtcbiAgICAgICAgU0hBMjU2X1cuZmlsbCgwKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5zZXQoMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCk7XG4gICAgICAgIHRoaXMuYnVmZmVyLmZpbGwoMCk7XG4gICAgfVxufVxuLy8gQ29uc3RhbnRzIGZyb20gaHR0cHM6Ly9udmxwdWJzLm5pc3QuZ292L25pc3RwdWJzL0ZJUFMvTklTVC5GSVBTLjE4MC00LnBkZlxuY2xhc3MgU0hBMjI0IGV4dGVuZHMgU0hBMjU2IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5BID0gMHhjMTA1OWVkOCB8IDA7XG4gICAgICAgIHRoaXMuQiA9IDB4MzY3Y2Q1MDcgfCAwO1xuICAgICAgICB0aGlzLkMgPSAweDMwNzBkZDE3IHwgMDtcbiAgICAgICAgdGhpcy5EID0gMHhmNzBlNTkzOSB8IDA7XG4gICAgICAgIHRoaXMuRSA9IDB4ZmZjMDBiMzEgfCAwO1xuICAgICAgICB0aGlzLkYgPSAweDY4NTgxNTExIHwgMDtcbiAgICAgICAgdGhpcy5HID0gMHg2NGY5OGZhNyB8IDA7XG4gICAgICAgIHRoaXMuSCA9IDB4YmVmYTRmYTQgfCAwO1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IDI4O1xuICAgIH1cbn1cbi8qKlxuICogU0hBMi0yNTYgaGFzaCBmdW5jdGlvblxuICogQHBhcmFtIG1lc3NhZ2UgLSBkYXRhIHRoYXQgd291bGQgYmUgaGFzaGVkXG4gKi9cbmV4cG9ydCBjb25zdCBzaGEyNTYgPSAvKiBAX19QVVJFX18gKi8gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBTSEEyNTYoKSk7XG5leHBvcnQgY29uc3Qgc2hhMjI0ID0gLyogQF9fUFVSRV9fICovIHdyYXBDb25zdHJ1Y3RvcigoKSA9PiBuZXcgU0hBMjI0KCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2hhMjU2LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha256.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha3.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha3.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Keccak: function() { return /* binding */ Keccak; },\n/* harmony export */   keccakP: function() { return /* binding */ keccakP; },\n/* harmony export */   keccak_224: function() { return /* binding */ keccak_224; },\n/* harmony export */   keccak_256: function() { return /* binding */ keccak_256; },\n/* harmony export */   keccak_384: function() { return /* binding */ keccak_384; },\n/* harmony export */   keccak_512: function() { return /* binding */ keccak_512; },\n/* harmony export */   sha3_224: function() { return /* binding */ sha3_224; },\n/* harmony export */   sha3_256: function() { return /* binding */ sha3_256; },\n/* harmony export */   sha3_384: function() { return /* binding */ sha3_384; },\n/* harmony export */   sha3_512: function() { return /* binding */ sha3_512; },\n/* harmony export */   shake128: function() { return /* binding */ shake128; },\n/* harmony export */   shake256: function() { return /* binding */ shake256; }\n/* harmony export */ });\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_assert.js\");\n/* harmony import */ var _u64_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_u64.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_u64.js\");\n/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js\");\n\n\n\n// SHA3 (keccak) is based on a new design: basically, the internal state is bigger than output size.\n// It's called a sponge function.\n// Various per round constants calculations\nconst SHA3_PI = [];\nconst SHA3_ROTL = [];\nconst _SHA3_IOTA = [];\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nconst _7n = /* @__PURE__ */ BigInt(7);\nconst _256n = /* @__PURE__ */ BigInt(256);\nconst _0x71n = /* @__PURE__ */ BigInt(0x71);\nfor (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {\n    // Pi\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    // Rotational\n    SHA3_ROTL.push((((round + 1) * (round + 2)) / 2) % 64);\n    // Iota\n    let t = _0n;\n    for (let j = 0; j < 7; j++) {\n        R = ((R << _1n) ^ ((R >> _7n) * _0x71n)) % _256n;\n        if (R & _2n)\n            t ^= _1n << ((_1n << /* @__PURE__ */ BigInt(j)) - _1n);\n    }\n    _SHA3_IOTA.push(t);\n}\nconst [SHA3_IOTA_H, SHA3_IOTA_L] = /* @__PURE__ */ (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.split)(_SHA3_IOTA, true);\n// Left rotation (without 0, 32, 64)\nconst rotlH = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBH)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSH)(h, l, s));\nconst rotlL = (h, l, s) => (s > 32 ? (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlBL)(h, l, s) : (0,_u64_js__WEBPACK_IMPORTED_MODULE_0__.rotlSL)(h, l, s));\n// Same as keccakf1600, but allows to skip some rounds\nfunction keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    // NOTE: all indices are x2 since we store state as u32 instead of u64 (bigints to slow in js)\n    for (let round = 24 - rounds; round < 24; round++) {\n        // Theta θ\n        for (let x = 0; x < 10; x++)\n            B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n        for (let x = 0; x < 10; x += 2) {\n            const idx1 = (x + 8) % 10;\n            const idx0 = (x + 2) % 10;\n            const B0 = B[idx0];\n            const B1 = B[idx0 + 1];\n            const Th = rotlH(B0, B1, 1) ^ B[idx1];\n            const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n            for (let y = 0; y < 50; y += 10) {\n                s[x + y] ^= Th;\n                s[x + y + 1] ^= Tl;\n            }\n        }\n        // Rho (ρ) and Pi (π)\n        let curH = s[2];\n        let curL = s[3];\n        for (let t = 0; t < 24; t++) {\n            const shift = SHA3_ROTL[t];\n            const Th = rotlH(curH, curL, shift);\n            const Tl = rotlL(curH, curL, shift);\n            const PI = SHA3_PI[t];\n            curH = s[PI];\n            curL = s[PI + 1];\n            s[PI] = Th;\n            s[PI + 1] = Tl;\n        }\n        // Chi (χ)\n        for (let y = 0; y < 50; y += 10) {\n            for (let x = 0; x < 10; x++)\n                B[x] = s[y + x];\n            for (let x = 0; x < 10; x++)\n                s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n        }\n        // Iota (ι)\n        s[0] ^= SHA3_IOTA_H[round];\n        s[1] ^= SHA3_IOTA_L[round];\n    }\n    B.fill(0);\n}\nclass Keccak extends _utils_js__WEBPACK_IMPORTED_MODULE_1__.Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n        super();\n        this.blockLen = blockLen;\n        this.suffix = suffix;\n        this.outputLen = outputLen;\n        this.enableXOF = enableXOF;\n        this.rounds = rounds;\n        this.pos = 0;\n        this.posOut = 0;\n        this.finished = false;\n        this.destroyed = false;\n        // Can be passed from user as dkLen\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(outputLen);\n        // 1600 = 5x5 matrix of 64bit.  1600 bits === 200 bytes\n        if (0 >= this.blockLen || this.blockLen >= 200)\n            throw new Error('Sha3 supports only keccak-f1600 function');\n        this.state = new Uint8Array(200);\n        this.state32 = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.u32)(this.state);\n    }\n    keccak() {\n        if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLE)\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.byteSwap32)(this.state32);\n        keccakP(this.state32, this.rounds);\n        if (!_utils_js__WEBPACK_IMPORTED_MODULE_1__.isLE)\n            (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.byteSwap32)(this.state32);\n        this.posOut = 0;\n        this.pos = 0;\n    }\n    update(data) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this);\n        const { blockLen, state } = this;\n        data = (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.toBytes)(data);\n        const len = data.length;\n        for (let pos = 0; pos < len;) {\n            const take = Math.min(blockLen - this.pos, len - pos);\n            for (let i = 0; i < take; i++)\n                state[this.pos++] ^= data[pos++];\n            if (this.pos === blockLen)\n                this.keccak();\n        }\n        return this;\n    }\n    finish() {\n        if (this.finished)\n            return;\n        this.finished = true;\n        const { state, suffix, pos, blockLen } = this;\n        // Do the padding\n        state[pos] ^= suffix;\n        if ((suffix & 0x80) !== 0 && pos === blockLen - 1)\n            this.keccak();\n        state[blockLen - 1] ^= 0x80;\n        this.keccak();\n    }\n    writeInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.exists)(this, false);\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.bytes)(out);\n        this.finish();\n        const bufferOut = this.state;\n        const { blockLen } = this;\n        for (let pos = 0, len = out.length; pos < len;) {\n            if (this.posOut >= blockLen)\n                this.keccak();\n            const take = Math.min(blockLen - this.posOut, len - pos);\n            out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n            this.posOut += take;\n            pos += take;\n        }\n        return out;\n    }\n    xofInto(out) {\n        // Sha3/Keccak usage with XOF is probably mistake, only SHAKE instances can do XOF\n        if (!this.enableXOF)\n            throw new Error('XOF is not possible for this instance');\n        return this.writeInto(out);\n    }\n    xof(bytes) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.number)(bytes);\n        return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_2__.output)(out, this);\n        if (this.finished)\n            throw new Error('digest() was already called');\n        this.writeInto(out);\n        this.destroy();\n        return out;\n    }\n    digest() {\n        return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n        this.destroyed = true;\n        this.state.fill(0);\n    }\n    _cloneInto(to) {\n        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n        to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n        to.state32.set(this.state32);\n        to.pos = this.pos;\n        to.posOut = this.posOut;\n        to.finished = this.finished;\n        to.rounds = rounds;\n        // Suffix can change in cSHAKE\n        to.suffix = suffix;\n        to.outputLen = outputLen;\n        to.enableXOF = enableXOF;\n        to.destroyed = this.destroyed;\n        return to;\n    }\n}\nconst gen = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));\nconst sha3_224 = /* @__PURE__ */ gen(0x06, 144, 224 / 8);\n/**\n * SHA3-256 hash function\n * @param message - that would be hashed\n */\nconst sha3_256 = /* @__PURE__ */ gen(0x06, 136, 256 / 8);\nconst sha3_384 = /* @__PURE__ */ gen(0x06, 104, 384 / 8);\nconst sha3_512 = /* @__PURE__ */ gen(0x06, 72, 512 / 8);\nconst keccak_224 = /* @__PURE__ */ gen(0x01, 144, 224 / 8);\n/**\n * keccak-256 hash function. Different from SHA3-256.\n * @param message - that would be hashed\n */\nconst keccak_256 = /* @__PURE__ */ gen(0x01, 136, 256 / 8);\nconst keccak_384 = /* @__PURE__ */ gen(0x01, 104, 384 / 8);\nconst keccak_512 = /* @__PURE__ */ gen(0x01, 72, 512 / 8);\nconst genShake = (suffix, blockLen, outputLen) => (0,_utils_js__WEBPACK_IMPORTED_MODULE_1__.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));\nconst shake128 = /* @__PURE__ */ genShake(0x1f, 168, 128 / 8);\nconst shake256 = /* @__PURE__ */ genShake(0x1f, 136, 256 / 8);\n//# sourceMappingURL=sha3.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3NoYTMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTZEO0FBQ0s7QUFDOEM7QUFDaEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFlBQVk7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsOENBQUs7QUFDeEQ7QUFDQSxxQ0FBcUMsK0NBQU0sWUFBWSwrQ0FBTTtBQUM3RCxxQ0FBcUMsK0NBQU0sWUFBWSwrQ0FBTTtBQUM3RDtBQUNPO0FBQ1A7QUFDQTtBQUNBLGtDQUFrQyxZQUFZO0FBQzlDO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEMsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08scUJBQXFCLDJDQUFJO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDhDQUFHO0FBQzFCO0FBQ0E7QUFDQSxhQUFhLDJDQUFJO0FBQ2pCLFlBQVkscURBQVU7QUFDdEI7QUFDQSxhQUFhLDJDQUFJO0FBQ2pCLFlBQVkscURBQVU7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGtEQUFNO0FBQ2QsZ0JBQWdCLGtCQUFrQjtBQUNsQyxlQUFlLGtEQUFPO0FBQ3RCO0FBQ0EsMEJBQTBCLFVBQVU7QUFDcEM7QUFDQSw0QkFBNEIsVUFBVTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZCxRQUFRLGlEQUFLO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQixXQUFXO0FBQzNCLDRDQUE0QyxVQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxrREFBTTtBQUNkO0FBQ0E7QUFDQTtBQUNBLFFBQVEsa0RBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlEQUFpRDtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDBEQUFlO0FBQ3JEO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDQTtBQUNBO0FBQ1Asa0RBQWtELHFFQUEwQixXQUFXO0FBQ2hGO0FBQ0E7QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHNvbGFuYS93ZWIzLmpzL25vZGVfbW9kdWxlcy9Abm9ibGUvaGFzaGVzL2VzbS9zaGEzLmpzPzA0NTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYnl0ZXMsIGV4aXN0cywgbnVtYmVyLCBvdXRwdXQgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuaW1wb3J0IHsgcm90bEJILCByb3RsQkwsIHJvdGxTSCwgcm90bFNMLCBzcGxpdCB9IGZyb20gJy4vX3U2NC5qcyc7XG5pbXBvcnQgeyBIYXNoLCB1MzIsIHRvQnl0ZXMsIHdyYXBDb25zdHJ1Y3Rvciwgd3JhcFhPRkNvbnN0cnVjdG9yV2l0aE9wdHMsIGlzTEUsIGJ5dGVTd2FwMzIsIH0gZnJvbSAnLi91dGlscy5qcyc7XG4vLyBTSEEzIChrZWNjYWspIGlzIGJhc2VkIG9uIGEgbmV3IGRlc2lnbjogYmFzaWNhbGx5LCB0aGUgaW50ZXJuYWwgc3RhdGUgaXMgYmlnZ2VyIHRoYW4gb3V0cHV0IHNpemUuXG4vLyBJdCdzIGNhbGxlZCBhIHNwb25nZSBmdW5jdGlvbi5cbi8vIFZhcmlvdXMgcGVyIHJvdW5kIGNvbnN0YW50cyBjYWxjdWxhdGlvbnNcbmNvbnN0IFNIQTNfUEkgPSBbXTtcbmNvbnN0IFNIQTNfUk9UTCA9IFtdO1xuY29uc3QgX1NIQTNfSU9UQSA9IFtdO1xuY29uc3QgXzBuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgwKTtcbmNvbnN0IF8xbiA9IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoMSk7XG5jb25zdCBfMm4gPSAvKiBAX19QVVJFX18gKi8gQmlnSW50KDIpO1xuY29uc3QgXzduID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCg3KTtcbmNvbnN0IF8yNTZuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgyNTYpO1xuY29uc3QgXzB4NzFuID0gLyogQF9fUFVSRV9fICovIEJpZ0ludCgweDcxKTtcbmZvciAobGV0IHJvdW5kID0gMCwgUiA9IF8xbiwgeCA9IDEsIHkgPSAwOyByb3VuZCA8IDI0OyByb3VuZCsrKSB7XG4gICAgLy8gUGlcbiAgICBbeCwgeV0gPSBbeSwgKDIgKiB4ICsgMyAqIHkpICUgNV07XG4gICAgU0hBM19QSS5wdXNoKDIgKiAoNSAqIHkgKyB4KSk7XG4gICAgLy8gUm90YXRpb25hbFxuICAgIFNIQTNfUk9UTC5wdXNoKCgoKHJvdW5kICsgMSkgKiAocm91bmQgKyAyKSkgLyAyKSAlIDY0KTtcbiAgICAvLyBJb3RhXG4gICAgbGV0IHQgPSBfMG47XG4gICAgZm9yIChsZXQgaiA9IDA7IGogPCA3OyBqKyspIHtcbiAgICAgICAgUiA9ICgoUiA8PCBfMW4pIF4gKChSID4+IF83bikgKiBfMHg3MW4pKSAlIF8yNTZuO1xuICAgICAgICBpZiAoUiAmIF8ybilcbiAgICAgICAgICAgIHQgXj0gXzFuIDw8ICgoXzFuIDw8IC8qIEBfX1BVUkVfXyAqLyBCaWdJbnQoaikpIC0gXzFuKTtcbiAgICB9XG4gICAgX1NIQTNfSU9UQS5wdXNoKHQpO1xufVxuY29uc3QgW1NIQTNfSU9UQV9ILCBTSEEzX0lPVEFfTF0gPSAvKiBAX19QVVJFX18gKi8gc3BsaXQoX1NIQTNfSU9UQSwgdHJ1ZSk7XG4vLyBMZWZ0IHJvdGF0aW9uICh3aXRob3V0IDAsIDMyLCA2NClcbmNvbnN0IHJvdGxIID0gKGgsIGwsIHMpID0+IChzID4gMzIgPyByb3RsQkgoaCwgbCwgcykgOiByb3RsU0goaCwgbCwgcykpO1xuY29uc3Qgcm90bEwgPSAoaCwgbCwgcykgPT4gKHMgPiAzMiA/IHJvdGxCTChoLCBsLCBzKSA6IHJvdGxTTChoLCBsLCBzKSk7XG4vLyBTYW1lIGFzIGtlY2Nha2YxNjAwLCBidXQgYWxsb3dzIHRvIHNraXAgc29tZSByb3VuZHNcbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWtQKHMsIHJvdW5kcyA9IDI0KSB7XG4gICAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheSg1ICogMik7XG4gICAgLy8gTk9URTogYWxsIGluZGljZXMgYXJlIHgyIHNpbmNlIHdlIHN0b3JlIHN0YXRlIGFzIHUzMiBpbnN0ZWFkIG9mIHU2NCAoYmlnaW50cyB0byBzbG93IGluIGpzKVxuICAgIGZvciAobGV0IHJvdW5kID0gMjQgLSByb3VuZHM7IHJvdW5kIDwgMjQ7IHJvdW5kKyspIHtcbiAgICAgICAgLy8gVGhldGEgzrhcbiAgICAgICAgZm9yIChsZXQgeCA9IDA7IHggPCAxMDsgeCsrKVxuICAgICAgICAgICAgQlt4XSA9IHNbeF0gXiBzW3ggKyAxMF0gXiBzW3ggKyAyMF0gXiBzW3ggKyAzMF0gXiBzW3ggKyA0MF07XG4gICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHggKz0gMikge1xuICAgICAgICAgICAgY29uc3QgaWR4MSA9ICh4ICsgOCkgJSAxMDtcbiAgICAgICAgICAgIGNvbnN0IGlkeDAgPSAoeCArIDIpICUgMTA7XG4gICAgICAgICAgICBjb25zdCBCMCA9IEJbaWR4MF07XG4gICAgICAgICAgICBjb25zdCBCMSA9IEJbaWR4MCArIDFdO1xuICAgICAgICAgICAgY29uc3QgVGggPSByb3RsSChCMCwgQjEsIDEpIF4gQltpZHgxXTtcbiAgICAgICAgICAgIGNvbnN0IFRsID0gcm90bEwoQjAsIEIxLCAxKSBeIEJbaWR4MSArIDFdO1xuICAgICAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCA1MDsgeSArPSAxMCkge1xuICAgICAgICAgICAgICAgIHNbeCArIHldIF49IFRoO1xuICAgICAgICAgICAgICAgIHNbeCArIHkgKyAxXSBePSBUbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSaG8gKM+BKSBhbmQgUGkgKM+AKVxuICAgICAgICBsZXQgY3VySCA9IHNbMl07XG4gICAgICAgIGxldCBjdXJMID0gc1szXTtcbiAgICAgICAgZm9yIChsZXQgdCA9IDA7IHQgPCAyNDsgdCsrKSB7XG4gICAgICAgICAgICBjb25zdCBzaGlmdCA9IFNIQTNfUk9UTFt0XTtcbiAgICAgICAgICAgIGNvbnN0IFRoID0gcm90bEgoY3VySCwgY3VyTCwgc2hpZnQpO1xuICAgICAgICAgICAgY29uc3QgVGwgPSByb3RsTChjdXJILCBjdXJMLCBzaGlmdCk7XG4gICAgICAgICAgICBjb25zdCBQSSA9IFNIQTNfUElbdF07XG4gICAgICAgICAgICBjdXJIID0gc1tQSV07XG4gICAgICAgICAgICBjdXJMID0gc1tQSSArIDFdO1xuICAgICAgICAgICAgc1tQSV0gPSBUaDtcbiAgICAgICAgICAgIHNbUEkgKyAxXSA9IFRsO1xuICAgICAgICB9XG4gICAgICAgIC8vIENoaSAoz4cpXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgNTA7IHkgKz0gMTApIHtcbiAgICAgICAgICAgIGZvciAobGV0IHggPSAwOyB4IDwgMTA7IHgrKylcbiAgICAgICAgICAgICAgICBCW3hdID0gc1t5ICsgeF07XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspXG4gICAgICAgICAgICAgICAgc1t5ICsgeF0gXj0gfkJbKHggKyAyKSAlIDEwXSAmIEJbKHggKyA0KSAlIDEwXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJb3RhICjOuSlcbiAgICAgICAgc1swXSBePSBTSEEzX0lPVEFfSFtyb3VuZF07XG4gICAgICAgIHNbMV0gXj0gU0hBM19JT1RBX0xbcm91bmRdO1xuICAgIH1cbiAgICBCLmZpbGwoMCk7XG59XG5leHBvcnQgY2xhc3MgS2VjY2FrIGV4dGVuZHMgSGFzaCB7XG4gICAgLy8gTk9URTogd2UgYWNjZXB0IGFyZ3VtZW50cyBpbiBieXRlcyBpbnN0ZWFkIG9mIGJpdHMgaGVyZS5cbiAgICBjb25zdHJ1Y3RvcihibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIGVuYWJsZVhPRiA9IGZhbHNlLCByb3VuZHMgPSAyNCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmJsb2NrTGVuID0gYmxvY2tMZW47XG4gICAgICAgIHRoaXMuc3VmZml4ID0gc3VmZml4O1xuICAgICAgICB0aGlzLm91dHB1dExlbiA9IG91dHB1dExlbjtcbiAgICAgICAgdGhpcy5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRoaXMucm91bmRzID0gcm91bmRzO1xuICAgICAgICB0aGlzLnBvcyA9IDA7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgICAgICAvLyBDYW4gYmUgcGFzc2VkIGZyb20gdXNlciBhcyBka0xlblxuICAgICAgICBudW1iZXIob3V0cHV0TGVuKTtcbiAgICAgICAgLy8gMTYwMCA9IDV4NSBtYXRyaXggb2YgNjRiaXQuICAxNjAwIGJpdHMgPT09IDIwMCBieXRlc1xuICAgICAgICBpZiAoMCA+PSB0aGlzLmJsb2NrTGVuIHx8IHRoaXMuYmxvY2tMZW4gPj0gMjAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTaGEzIHN1cHBvcnRzIG9ubHkga2VjY2FrLWYxNjAwIGZ1bmN0aW9uJyk7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBuZXcgVWludDhBcnJheSgyMDApO1xuICAgICAgICB0aGlzLnN0YXRlMzIgPSB1MzIodGhpcy5zdGF0ZSk7XG4gICAgfVxuICAgIGtlY2NhaygpIHtcbiAgICAgICAgaWYgKCFpc0xFKVxuICAgICAgICAgICAgYnl0ZVN3YXAzMih0aGlzLnN0YXRlMzIpO1xuICAgICAgICBrZWNjYWtQKHRoaXMuc3RhdGUzMiwgdGhpcy5yb3VuZHMpO1xuICAgICAgICBpZiAoIWlzTEUpXG4gICAgICAgICAgICBieXRlU3dhcDMyKHRoaXMuc3RhdGUzMik7XG4gICAgICAgIHRoaXMucG9zT3V0ID0gMDtcbiAgICAgICAgdGhpcy5wb3MgPSAwO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YSkge1xuICAgICAgICBleGlzdHModGhpcyk7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4sIHN0YXRlIH0gPSB0aGlzO1xuICAgICAgICBkYXRhID0gdG9CeXRlcyhkYXRhKTtcbiAgICAgICAgY29uc3QgbGVuID0gZGF0YS5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGNvbnN0IHRha2UgPSBNYXRoLm1pbihibG9ja0xlbiAtIHRoaXMucG9zLCBsZW4gLSBwb3MpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YWtlOyBpKyspXG4gICAgICAgICAgICAgICAgc3RhdGVbdGhpcy5wb3MrK10gXj0gZGF0YVtwb3MrK107XG4gICAgICAgICAgICBpZiAodGhpcy5wb3MgPT09IGJsb2NrTGVuKVxuICAgICAgICAgICAgICAgIHRoaXMua2VjY2FrKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZpbmlzaCgpIHtcbiAgICAgICAgaWYgKHRoaXMuZmluaXNoZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHN0YXRlLCBzdWZmaXgsIHBvcywgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIC8vIERvIHRoZSBwYWRkaW5nXG4gICAgICAgIHN0YXRlW3Bvc10gXj0gc3VmZml4O1xuICAgICAgICBpZiAoKHN1ZmZpeCAmIDB4ODApICE9PSAwICYmIHBvcyA9PT0gYmxvY2tMZW4gLSAxKVxuICAgICAgICAgICAgdGhpcy5rZWNjYWsoKTtcbiAgICAgICAgc3RhdGVbYmxvY2tMZW4gLSAxXSBePSAweDgwO1xuICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgIH1cbiAgICB3cml0ZUludG8ob3V0KSB7XG4gICAgICAgIGV4aXN0cyh0aGlzLCBmYWxzZSk7XG4gICAgICAgIGJ5dGVzKG91dCk7XG4gICAgICAgIHRoaXMuZmluaXNoKCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlck91dCA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgYmxvY2tMZW4gfSA9IHRoaXM7XG4gICAgICAgIGZvciAobGV0IHBvcyA9IDAsIGxlbiA9IG91dC5sZW5ndGg7IHBvcyA8IGxlbjspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvc091dCA+PSBibG9ja0xlbilcbiAgICAgICAgICAgICAgICB0aGlzLmtlY2NhaygpO1xuICAgICAgICAgICAgY29uc3QgdGFrZSA9IE1hdGgubWluKGJsb2NrTGVuIC0gdGhpcy5wb3NPdXQsIGxlbiAtIHBvcyk7XG4gICAgICAgICAgICBvdXQuc2V0KGJ1ZmZlck91dC5zdWJhcnJheSh0aGlzLnBvc091dCwgdGhpcy5wb3NPdXQgKyB0YWtlKSwgcG9zKTtcbiAgICAgICAgICAgIHRoaXMucG9zT3V0ICs9IHRha2U7XG4gICAgICAgICAgICBwb3MgKz0gdGFrZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICB4b2ZJbnRvKG91dCkge1xuICAgICAgICAvLyBTaGEzL0tlY2NhayB1c2FnZSB3aXRoIFhPRiBpcyBwcm9iYWJseSBtaXN0YWtlLCBvbmx5IFNIQUtFIGluc3RhbmNlcyBjYW4gZG8gWE9GXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVYT0YpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1hPRiBpcyBub3QgcG9zc2libGUgZm9yIHRoaXMgaW5zdGFuY2UnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgfVxuICAgIHhvZihieXRlcykge1xuICAgICAgICBudW1iZXIoYnl0ZXMpO1xuICAgICAgICByZXR1cm4gdGhpcy54b2ZJbnRvKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gICAgfVxuICAgIGRpZ2VzdEludG8ob3V0KSB7XG4gICAgICAgIG91dHB1dChvdXQsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5maW5pc2hlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZGlnZXN0KCkgd2FzIGFscmVhZHkgY2FsbGVkJyk7XG4gICAgICAgIHRoaXMud3JpdGVJbnRvKG91dCk7XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBkaWdlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpZ2VzdEludG8obmV3IFVpbnQ4QXJyYXkodGhpcy5vdXRwdXRMZW4pKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnN0YXRlLmZpbGwoMCk7XG4gICAgfVxuICAgIF9jbG9uZUludG8odG8pIHtcbiAgICAgICAgY29uc3QgeyBibG9ja0xlbiwgc3VmZml4LCBvdXRwdXRMZW4sIHJvdW5kcywgZW5hYmxlWE9GIH0gPSB0aGlzO1xuICAgICAgICB0byB8fCAodG8gPSBuZXcgS2VjY2FrKGJsb2NrTGVuLCBzdWZmaXgsIG91dHB1dExlbiwgZW5hYmxlWE9GLCByb3VuZHMpKTtcbiAgICAgICAgdG8uc3RhdGUzMi5zZXQodGhpcy5zdGF0ZTMyKTtcbiAgICAgICAgdG8ucG9zID0gdGhpcy5wb3M7XG4gICAgICAgIHRvLnBvc091dCA9IHRoaXMucG9zT3V0O1xuICAgICAgICB0by5maW5pc2hlZCA9IHRoaXMuZmluaXNoZWQ7XG4gICAgICAgIHRvLnJvdW5kcyA9IHJvdW5kcztcbiAgICAgICAgLy8gU3VmZml4IGNhbiBjaGFuZ2UgaW4gY1NIQUtFXG4gICAgICAgIHRvLnN1ZmZpeCA9IHN1ZmZpeDtcbiAgICAgICAgdG8ub3V0cHV0TGVuID0gb3V0cHV0TGVuO1xuICAgICAgICB0by5lbmFibGVYT0YgPSBlbmFibGVYT0Y7XG4gICAgICAgIHRvLmRlc3Ryb3llZCA9IHRoaXMuZGVzdHJveWVkO1xuICAgICAgICByZXR1cm4gdG87XG4gICAgfVxufVxuY29uc3QgZ2VuID0gKHN1ZmZpeCwgYmxvY2tMZW4sIG91dHB1dExlbikgPT4gd3JhcENvbnN0cnVjdG9yKCgpID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3V0cHV0TGVuKSk7XG5leHBvcnQgY29uc3Qgc2hhM18yMjQgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDYsIDE0NCwgMjI0IC8gOCk7XG4vKipcbiAqIFNIQTMtMjU2IGhhc2ggZnVuY3Rpb25cbiAqIEBwYXJhbSBtZXNzYWdlIC0gdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IHNoYTNfMjU2ID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCAxMzYsIDI1NiAvIDgpO1xuZXhwb3J0IGNvbnN0IHNoYTNfMzg0ID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCAxMDQsIDM4NCAvIDgpO1xuZXhwb3J0IGNvbnN0IHNoYTNfNTEyID0gLyogQF9fUFVSRV9fICovIGdlbigweDA2LCA3MiwgNTEyIC8gOCk7XG5leHBvcnQgY29uc3Qga2VjY2FrXzIyNCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTQ0LCAyMjQgLyA4KTtcbi8qKlxuICoga2VjY2FrLTI1NiBoYXNoIGZ1bmN0aW9uLiBEaWZmZXJlbnQgZnJvbSBTSEEzLTI1Ni5cbiAqIEBwYXJhbSBtZXNzYWdlIC0gdGhhdCB3b3VsZCBiZSBoYXNoZWRcbiAqL1xuZXhwb3J0IGNvbnN0IGtlY2Nha18yNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuKDB4MDEsIDEzNiwgMjU2IC8gOCk7XG5leHBvcnQgY29uc3Qga2VjY2FrXzM4NCA9IC8qIEBfX1BVUkVfXyAqLyBnZW4oMHgwMSwgMTA0LCAzODQgLyA4KTtcbmV4cG9ydCBjb25zdCBrZWNjYWtfNTEyID0gLyogQF9fUFVSRV9fICovIGdlbigweDAxLCA3MiwgNTEyIC8gOCk7XG5jb25zdCBnZW5TaGFrZSA9IChzdWZmaXgsIGJsb2NrTGVuLCBvdXRwdXRMZW4pID0+IHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKChvcHRzID0ge30pID0+IG5ldyBLZWNjYWsoYmxvY2tMZW4sIHN1ZmZpeCwgb3B0cy5ka0xlbiA9PT0gdW5kZWZpbmVkID8gb3V0cHV0TGVuIDogb3B0cy5ka0xlbiwgdHJ1ZSkpO1xuZXhwb3J0IGNvbnN0IHNoYWtlMTI4ID0gLyogQF9fUFVSRV9fICovIGdlblNoYWtlKDB4MWYsIDE2OCwgMTI4IC8gOCk7XG5leHBvcnQgY29uc3Qgc2hha2UyNTYgPSAvKiBAX19QVVJFX18gKi8gZ2VuU2hha2UoMHgxZiwgMTM2LCAyNTYgLyA4KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/sha3.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hash: function() { return /* binding */ Hash; },\n/* harmony export */   asyncLoop: function() { return /* binding */ asyncLoop; },\n/* harmony export */   byteSwap: function() { return /* binding */ byteSwap; },\n/* harmony export */   byteSwap32: function() { return /* binding */ byteSwap32; },\n/* harmony export */   byteSwapIfBE: function() { return /* binding */ byteSwapIfBE; },\n/* harmony export */   bytesToHex: function() { return /* binding */ bytesToHex; },\n/* harmony export */   checkOpts: function() { return /* binding */ checkOpts; },\n/* harmony export */   concatBytes: function() { return /* binding */ concatBytes; },\n/* harmony export */   createView: function() { return /* binding */ createView; },\n/* harmony export */   hexToBytes: function() { return /* binding */ hexToBytes; },\n/* harmony export */   isBytes: function() { return /* binding */ isBytes; },\n/* harmony export */   isLE: function() { return /* binding */ isLE; },\n/* harmony export */   nextTick: function() { return /* binding */ nextTick; },\n/* harmony export */   randomBytes: function() { return /* binding */ randomBytes; },\n/* harmony export */   rotl: function() { return /* binding */ rotl; },\n/* harmony export */   rotr: function() { return /* binding */ rotr; },\n/* harmony export */   toBytes: function() { return /* binding */ toBytes; },\n/* harmony export */   u32: function() { return /* binding */ u32; },\n/* harmony export */   u8: function() { return /* binding */ u8; },\n/* harmony export */   utf8ToBytes: function() { return /* binding */ utf8ToBytes; },\n/* harmony export */   wrapConstructor: function() { return /* binding */ wrapConstructor; },\n/* harmony export */   wrapConstructorWithOpts: function() { return /* binding */ wrapConstructorWithOpts; },\n/* harmony export */   wrapXOFConstructorWithOpts: function() { return /* binding */ wrapXOFConstructorWithOpts; }\n/* harmony export */ });\n/* harmony import */ var _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @noble/hashes/crypto */ \"(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/crypto.js\");\n/* harmony import */ var _assert_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_assert.js */ \"(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/_assert.js\");\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\n\n\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nfunction isBytes(a) {\n    return (a instanceof Uint8Array ||\n        (a != null && typeof a === 'object' && a.constructor.name === 'Uint8Array'));\n}\n// Cast array to different type\nconst u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\nconst u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n// Cast array to view\nconst createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n// The rotate right (circular right shift) operation for uint32\nconst rotr = (word, shift) => (word << (32 - shift)) | (word >>> shift);\n// The rotate left (circular left shift) operation for uint32\nconst rotl = (word, shift) => (word << shift) | ((word >>> (32 - shift)) >>> 0);\nconst isLE = new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44;\n// The byte swap operation for uint32\nconst byteSwap = (word) => ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff);\n// Conditionally byte swap if on a big-endian platform\nconst byteSwapIfBE = isLE ? (n) => n : (n) => byteSwap(n);\n// In place byte swap for Uint32Array\nfunction byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = byteSwap(arr[i]);\n    }\n}\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(bytes);\n    // pre-caching improves the speed 6x\n    let hex = '';\n    for (let i = 0; i < bytes.length; i++) {\n        hex += hexes[bytes[i]];\n    }\n    return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };\nfunction asciiToBase16(char) {\n    if (char >= asciis._0 && char <= asciis._9)\n        return char - asciis._0;\n    if (char >= asciis._A && char <= asciis._F)\n        return char - (asciis._A - 10);\n    if (char >= asciis._a && char <= asciis._f)\n        return char - (asciis._a - 10);\n    return;\n}\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n    if (typeof hex !== 'string')\n        throw new Error('hex string expected, got ' + typeof hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n        throw new Error('padded hex string expected, got unpadded hex of length ' + hl);\n    const array = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n        const n1 = asciiToBase16(hex.charCodeAt(hi));\n        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n        if (n1 === undefined || n2 === undefined) {\n            const char = hex[hi] + hex[hi + 1];\n            throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n        }\n        array[ai] = n1 * 16 + n2;\n    }\n    return array;\n}\n// There is no setImmediate in browser and setTimeout is slow.\n// call of async fn will return Promise, which will be fullfiled only on\n// next scheduler queue processing step and this is exactly what we need.\nconst nextTick = async () => { };\n// Returns control to thread each 'tick' ms to avoid blocking\nasync function asyncLoop(iters, tick, cb) {\n    let ts = Date.now();\n    for (let i = 0; i < iters; i++) {\n        cb(i);\n        // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n        const diff = Date.now() - ts;\n        if (diff >= 0 && diff < tick)\n            continue;\n        await nextTick();\n        ts += diff;\n    }\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n    if (typeof str !== 'string')\n        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n    return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nfunction toBytes(data) {\n    if (typeof data === 'string')\n        data = utf8ToBytes(data);\n    (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(data);\n    return data;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        (0,_assert_js__WEBPACK_IMPORTED_MODULE_0__.bytes)(a);\n        sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n        const a = arrays[i];\n        res.set(a, pad);\n        pad += a.length;\n    }\n    return res;\n}\n// For runtime check if class implements interface\nclass Hash {\n    // Safe version that clones internal state\n    clone() {\n        return this._cloneInto();\n    }\n}\nconst toStr = {}.toString;\nfunction checkOpts(defaults, opts) {\n    if (opts !== undefined && toStr.call(opts) !== '[object Object]')\n        throw new Error('Options should be object or undefined');\n    const merged = Object.assign(defaults, opts);\n    return merged;\n}\nfunction wrapConstructor(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n}\nfunction wrapConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\nfunction wrapXOFConstructorWithOpts(hashCons) {\n    const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();\n    const tmp = hashCons({});\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = (opts) => hashCons(opts);\n    return hashC;\n}\n/**\n * Secure PRNG. Uses `crypto.getRandomValues`, which defers to OS.\n */\nfunction randomBytes(bytesLength = 32) {\n    if (_noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto && typeof _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues === 'function') {\n        return _noble_hashes_crypto__WEBPACK_IMPORTED_MODULE_1__.crypto.getRandomValues(new Uint8Array(bytesLength));\n    }\n    throw new Error('crypto.getRandomValues must be defined');\n}\n//# sourceMappingURL=utils.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ac29sYW5hL3dlYjMuanMvbm9kZV9tb2R1bGVzL0Bub2JsZS9oYXNoZXMvZXNtL3V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUM4QztBQUNDO0FBQy9DLFlBQVksVUFBVTtBQUN0QjtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNPO0FBQ0E7QUFDUDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUCxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLGFBQWE7QUFDeEQ7QUFDQTtBQUNBO0FBQ087QUFDUCxJQUFJLGlEQUFNO0FBQ1Y7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLFNBQVM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ087QUFDUDtBQUNBLG9CQUFvQixXQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSw0REFBNEQsV0FBVztBQUN2RSwwREFBMEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0EsSUFBSSxpREFBTTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLG1CQUFtQjtBQUN2QztBQUNBLFFBQVEsaURBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsbUJBQW1CO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ1Q7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsUUFBUSx3REFBTSxXQUFXLHdEQUFNO0FBQy9CLGVBQWUsd0RBQU07QUFDckI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0Bzb2xhbmEvd2ViMy5qcy9ub2RlX21vZHVsZXMvQG5vYmxlL2hhc2hlcy9lc20vdXRpbHMuanM/NjRkZiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiEgbm9ibGUtaGFzaGVzIC0gTUlUIExpY2Vuc2UgKGMpIDIwMjIgUGF1bCBNaWxsZXIgKHBhdWxtaWxsci5jb20pICovXG4vLyBXZSB1c2UgV2ViQ3J5cHRvIGFrYSBnbG9iYWxUaGlzLmNyeXB0bywgd2hpY2ggZXhpc3RzIGluIGJyb3dzZXJzIGFuZCBub2RlLmpzIDE2Ky5cbi8vIG5vZGUuanMgdmVyc2lvbnMgZWFybGllciB0aGFuIHYxOSBkb24ndCBkZWNsYXJlIGl0IGluIGdsb2JhbCBzY29wZS5cbi8vIEZvciBub2RlLmpzLCBwYWNrYWdlLmpzb24jZXhwb3J0cyBmaWVsZCBtYXBwaW5nIHJld3JpdGVzIGltcG9ydFxuLy8gZnJvbSBgY3J5cHRvYCB0byBgY3J5cHRvTm9kZWAsIHdoaWNoIGltcG9ydHMgbmF0aXZlIG1vZHVsZS5cbi8vIE1ha2VzIHRoZSB1dGlscyB1bi1pbXBvcnRhYmxlIGluIGJyb3dzZXJzIHdpdGhvdXQgYSBidW5kbGVyLlxuLy8gT25jZSBub2RlLmpzIDE4IGlzIGRlcHJlY2F0ZWQgKDIwMjUtMDQtMzApLCB3ZSBjYW4ganVzdCBkcm9wIHRoZSBpbXBvcnQuXG5pbXBvcnQgeyBjcnlwdG8gfSBmcm9tICdAbm9ibGUvaGFzaGVzL2NyeXB0byc7XG5pbXBvcnQgeyBieXRlcyBhcyBhYnl0ZXMgfSBmcm9tICcuL19hc3NlcnQuanMnO1xuLy8gZXhwb3J0IHsgaXNCeXRlcyB9IGZyb20gJy4vX2Fzc2VydC5qcyc7XG4vLyBXZSBjYW4ndCByZXVzZSBpc0J5dGVzIGZyb20gX2Fzc2VydCwgYmVjYXVzZSBzb21laG93IHRoaXMgY2F1c2VzIGh1Z2UgcGVyZiBpc3N1ZXNcbmV4cG9ydCBmdW5jdGlvbiBpc0J5dGVzKGEpIHtcbiAgICByZXR1cm4gKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5IHx8XG4gICAgICAgIChhICE9IG51bGwgJiYgdHlwZW9mIGEgPT09ICdvYmplY3QnICYmIGEuY29uc3RydWN0b3IubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSk7XG59XG4vLyBDYXN0IGFycmF5IHRvIGRpZmZlcmVudCB0eXBlXG5leHBvcnQgY29uc3QgdTggPSAoYXJyKSA9PiBuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgYXJyLmJ5dGVMZW5ndGgpO1xuZXhwb3J0IGNvbnN0IHUzMiA9IChhcnIpID0+IG5ldyBVaW50MzJBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgTWF0aC5mbG9vcihhcnIuYnl0ZUxlbmd0aCAvIDQpKTtcbi8vIENhc3QgYXJyYXkgdG8gdmlld1xuZXhwb3J0IGNvbnN0IGNyZWF0ZVZpZXcgPSAoYXJyKSA9PiBuZXcgRGF0YVZpZXcoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIGFyci5ieXRlTGVuZ3RoKTtcbi8vIFRoZSByb3RhdGUgcmlnaHQgKGNpcmN1bGFyIHJpZ2h0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdHIgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8ICgzMiAtIHNoaWZ0KSkgfCAod29yZCA+Pj4gc2hpZnQpO1xuLy8gVGhlIHJvdGF0ZSBsZWZ0IChjaXJjdWxhciBsZWZ0IHNoaWZ0KSBvcGVyYXRpb24gZm9yIHVpbnQzMlxuZXhwb3J0IGNvbnN0IHJvdGwgPSAod29yZCwgc2hpZnQpID0+ICh3b3JkIDw8IHNoaWZ0KSB8ICgod29yZCA+Pj4gKDMyIC0gc2hpZnQpKSA+Pj4gMCk7XG5leHBvcnQgY29uc3QgaXNMRSA9IG5ldyBVaW50OEFycmF5KG5ldyBVaW50MzJBcnJheShbMHgxMTIyMzM0NF0pLmJ1ZmZlcilbMF0gPT09IDB4NDQ7XG4vLyBUaGUgYnl0ZSBzd2FwIG9wZXJhdGlvbiBmb3IgdWludDMyXG5leHBvcnQgY29uc3QgYnl0ZVN3YXAgPSAod29yZCkgPT4gKCh3b3JkIDw8IDI0KSAmIDB4ZmYwMDAwMDApIHxcbiAgICAoKHdvcmQgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICgod29yZCA+Pj4gOCkgJiAweGZmMDApIHxcbiAgICAoKHdvcmQgPj4+IDI0KSAmIDB4ZmYpO1xuLy8gQ29uZGl0aW9uYWxseSBieXRlIHN3YXAgaWYgb24gYSBiaWctZW5kaWFuIHBsYXRmb3JtXG5leHBvcnQgY29uc3QgYnl0ZVN3YXBJZkJFID0gaXNMRSA/IChuKSA9PiBuIDogKG4pID0+IGJ5dGVTd2FwKG4pO1xuLy8gSW4gcGxhY2UgYnl0ZSBzd2FwIGZvciBVaW50MzJBcnJheVxuZXhwb3J0IGZ1bmN0aW9uIGJ5dGVTd2FwMzIoYXJyKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJyW2ldID0gYnl0ZVN3YXAoYXJyW2ldKTtcbiAgICB9XG59XG4vLyBBcnJheSB3aGVyZSBpbmRleCAweGYwICgyNDApIGlzIG1hcHBlZCB0byBzdHJpbmcgJ2YwJ1xuY29uc3QgaGV4ZXMgPSAvKiBAX19QVVJFX18gKi8gQXJyYXkuZnJvbSh7IGxlbmd0aDogMjU2IH0sIChfLCBpKSA9PiBpLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCAnMCcpKTtcbi8qKlxuICogQGV4YW1wbGUgYnl0ZXNUb0hleChVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKSkgLy8gJ2NhZmUwMTIzJ1xuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNUb0hleChieXRlcykge1xuICAgIGFieXRlcyhieXRlcyk7XG4gICAgLy8gcHJlLWNhY2hpbmcgaW1wcm92ZXMgdGhlIHNwZWVkIDZ4XG4gICAgbGV0IGhleCA9ICcnO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaGV4ICs9IGhleGVzW2J5dGVzW2ldXTtcbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbn1cbi8vIFdlIHVzZSBvcHRpbWl6ZWQgdGVjaG5pcXVlIHRvIGNvbnZlcnQgaGV4IHN0cmluZyB0byBieXRlIGFycmF5XG5jb25zdCBhc2NpaXMgPSB7IF8wOiA0OCwgXzk6IDU3LCBfQTogNjUsIF9GOiA3MCwgX2E6IDk3LCBfZjogMTAyIH07XG5mdW5jdGlvbiBhc2NpaVRvQmFzZTE2KGNoYXIpIHtcbiAgICBpZiAoY2hhciA+PSBhc2NpaXMuXzAgJiYgY2hhciA8PSBhc2NpaXMuXzkpXG4gICAgICAgIHJldHVybiBjaGFyIC0gYXNjaWlzLl8wO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fQSAmJiBjaGFyIDw9IGFzY2lpcy5fRilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9BIC0gMTApO1xuICAgIGlmIChjaGFyID49IGFzY2lpcy5fYSAmJiBjaGFyIDw9IGFzY2lpcy5fZilcbiAgICAgICAgcmV0dXJuIGNoYXIgLSAoYXNjaWlzLl9hIC0gMTApO1xuICAgIHJldHVybjtcbn1cbi8qKlxuICogQGV4YW1wbGUgaGV4VG9CeXRlcygnY2FmZTAxMjMnKSAvLyBVaW50OEFycmF5LmZyb20oWzB4Y2EsIDB4ZmUsIDB4MDEsIDB4MjNdKVxuICovXG5leHBvcnQgZnVuY3Rpb24gaGV4VG9CeXRlcyhoZXgpIHtcbiAgICBpZiAodHlwZW9mIGhleCAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaGV4IHN0cmluZyBleHBlY3RlZCwgZ290ICcgKyB0eXBlb2YgaGV4KTtcbiAgICBjb25zdCBobCA9IGhleC5sZW5ndGg7XG4gICAgY29uc3QgYWwgPSBobCAvIDI7XG4gICAgaWYgKGhsICUgMilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYWRkZWQgaGV4IHN0cmluZyBleHBlY3RlZCwgZ290IHVucGFkZGVkIGhleCBvZiBsZW5ndGggJyArIGhsKTtcbiAgICBjb25zdCBhcnJheSA9IG5ldyBVaW50OEFycmF5KGFsKTtcbiAgICBmb3IgKGxldCBhaSA9IDAsIGhpID0gMDsgYWkgPCBhbDsgYWkrKywgaGkgKz0gMikge1xuICAgICAgICBjb25zdCBuMSA9IGFzY2lpVG9CYXNlMTYoaGV4LmNoYXJDb2RlQXQoaGkpKTtcbiAgICAgICAgY29uc3QgbjIgPSBhc2NpaVRvQmFzZTE2KGhleC5jaGFyQ29kZUF0KGhpICsgMSkpO1xuICAgICAgICBpZiAobjEgPT09IHVuZGVmaW5lZCB8fCBuMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gaGV4W2hpXSArIGhleFtoaSArIDFdO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdoZXggc3RyaW5nIGV4cGVjdGVkLCBnb3Qgbm9uLWhleCBjaGFyYWN0ZXIgXCInICsgY2hhciArICdcIiBhdCBpbmRleCAnICsgaGkpO1xuICAgICAgICB9XG4gICAgICAgIGFycmF5W2FpXSA9IG4xICogMTYgKyBuMjtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuLy8gVGhlcmUgaXMgbm8gc2V0SW1tZWRpYXRlIGluIGJyb3dzZXIgYW5kIHNldFRpbWVvdXQgaXMgc2xvdy5cbi8vIGNhbGwgb2YgYXN5bmMgZm4gd2lsbCByZXR1cm4gUHJvbWlzZSwgd2hpY2ggd2lsbCBiZSBmdWxsZmlsZWQgb25seSBvblxuLy8gbmV4dCBzY2hlZHVsZXIgcXVldWUgcHJvY2Vzc2luZyBzdGVwIGFuZCB0aGlzIGlzIGV4YWN0bHkgd2hhdCB3ZSBuZWVkLlxuZXhwb3J0IGNvbnN0IG5leHRUaWNrID0gYXN5bmMgKCkgPT4geyB9O1xuLy8gUmV0dXJucyBjb250cm9sIHRvIHRocmVhZCBlYWNoICd0aWNrJyBtcyB0byBhdm9pZCBibG9ja2luZ1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGFzeW5jTG9vcChpdGVycywgdGljaywgY2IpIHtcbiAgICBsZXQgdHMgPSBEYXRlLm5vdygpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaXRlcnM7IGkrKykge1xuICAgICAgICBjYihpKTtcbiAgICAgICAgLy8gRGF0ZS5ub3coKSBpcyBub3QgbW9ub3RvbmljLCBzbyBpbiBjYXNlIGlmIGNsb2NrIGdvZXMgYmFja3dhcmRzIHdlIHJldHVybiByZXR1cm4gY29udHJvbCB0b29cbiAgICAgICAgY29uc3QgZGlmZiA9IERhdGUubm93KCkgLSB0cztcbiAgICAgICAgaWYgKGRpZmYgPj0gMCAmJiBkaWZmIDwgdGljaylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICBhd2FpdCBuZXh0VGljaygpO1xuICAgICAgICB0cyArPSBkaWZmO1xuICAgIH1cbn1cbi8qKlxuICogQGV4YW1wbGUgdXRmOFRvQnl0ZXMoJ2FiYycpIC8vIG5ldyBVaW50OEFycmF5KFs5NywgOTgsIDk5XSlcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHV0ZjhUb0J5dGVzKHN0cikge1xuICAgIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1dGY4VG9CeXRlcyBleHBlY3RlZCBzdHJpbmcsIGdvdCAke3R5cGVvZiBzdHJ9YCk7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShzdHIpKTsgLy8gaHR0cHM6Ly9idWd6aWwubGEvMTY4MTgwOVxufVxuLyoqXG4gKiBOb3JtYWxpemVzIChub24taGV4KSBzdHJpbmcgb3IgVWludDhBcnJheSB0byBVaW50OEFycmF5LlxuICogV2FybmluZzogd2hlbiBVaW50OEFycmF5IGlzIHBhc3NlZCwgaXQgd291bGQgTk9UIGdldCBjb3BpZWQuXG4gKiBLZWVwIGluIG1pbmQgZm9yIGZ1dHVyZSBtdXRhYmxlIG9wZXJhdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0J5dGVzKGRhdGEpIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKVxuICAgICAgICBkYXRhID0gdXRmOFRvQnl0ZXMoZGF0YSk7XG4gICAgYWJ5dGVzKGRhdGEpO1xuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBDb3BpZXMgc2V2ZXJhbCBVaW50OEFycmF5cyBpbnRvIG9uZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbmNhdEJ5dGVzKC4uLmFycmF5cykge1xuICAgIGxldCBzdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIGFieXRlcyhhKTtcbiAgICAgICAgc3VtICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICBjb25zdCByZXMgPSBuZXcgVWludDhBcnJheShzdW0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBwYWQgPSAwOyBpIDwgYXJyYXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcnJheXNbaV07XG4gICAgICAgIHJlcy5zZXQoYSwgcGFkKTtcbiAgICAgICAgcGFkICs9IGEubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuLy8gRm9yIHJ1bnRpbWUgY2hlY2sgaWYgY2xhc3MgaW1wbGVtZW50cyBpbnRlcmZhY2VcbmV4cG9ydCBjbGFzcyBIYXNoIHtcbiAgICAvLyBTYWZlIHZlcnNpb24gdGhhdCBjbG9uZXMgaW50ZXJuYWwgc3RhdGVcbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Nsb25lSW50bygpO1xuICAgIH1cbn1cbmNvbnN0IHRvU3RyID0ge30udG9TdHJpbmc7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tPcHRzKGRlZmF1bHRzLCBvcHRzKSB7XG4gICAgaWYgKG9wdHMgIT09IHVuZGVmaW5lZCAmJiB0b1N0ci5jYWxsKG9wdHMpICE9PSAnW29iamVjdCBPYmplY3RdJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPcHRpb25zIHNob3VsZCBiZSBvYmplY3Qgb3IgdW5kZWZpbmVkJyk7XG4gICAgY29uc3QgbWVyZ2VkID0gT2JqZWN0LmFzc2lnbihkZWZhdWx0cywgb3B0cyk7XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3cmFwQ29uc3RydWN0b3IoaGFzaENvbnMpIHtcbiAgICBjb25zdCBoYXNoQyA9IChtc2cpID0+IGhhc2hDb25zKCkudXBkYXRlKHRvQnl0ZXMobXNnKSkuZGlnZXN0KCk7XG4gICAgY29uc3QgdG1wID0gaGFzaENvbnMoKTtcbiAgICBoYXNoQy5vdXRwdXRMZW4gPSB0bXAub3V0cHV0TGVuO1xuICAgIGhhc2hDLmJsb2NrTGVuID0gdG1wLmJsb2NrTGVuO1xuICAgIGhhc2hDLmNyZWF0ZSA9ICgpID0+IGhhc2hDb25zKCk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBYT0ZDb25zdHJ1Y3RvcldpdGhPcHRzKGhhc2hDb25zKSB7XG4gICAgY29uc3QgaGFzaEMgPSAobXNnLCBvcHRzKSA9PiBoYXNoQ29ucyhvcHRzKS51cGRhdGUodG9CeXRlcyhtc2cpKS5kaWdlc3QoKTtcbiAgICBjb25zdCB0bXAgPSBoYXNoQ29ucyh7fSk7XG4gICAgaGFzaEMub3V0cHV0TGVuID0gdG1wLm91dHB1dExlbjtcbiAgICBoYXNoQy5ibG9ja0xlbiA9IHRtcC5ibG9ja0xlbjtcbiAgICBoYXNoQy5jcmVhdGUgPSAob3B0cykgPT4gaGFzaENvbnMob3B0cyk7XG4gICAgcmV0dXJuIGhhc2hDO1xufVxuLyoqXG4gKiBTZWN1cmUgUFJORy4gVXNlcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlc2AsIHdoaWNoIGRlZmVycyB0byBPUy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbUJ5dGVzKGJ5dGVzTGVuZ3RoID0gMzIpIHtcbiAgICBpZiAoY3J5cHRvICYmIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KGJ5dGVzTGVuZ3RoKSk7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBtdXN0IGJlIGRlZmluZWQnKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@solana/web3.js/node_modules/@noble/hashes/esm/utils.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@wallet-standard/app/lib/esm/wallets.js":
/*!**************************************************************!*\
  !*** ./node_modules/@wallet-standard/app/lib/esm/wallets.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DEPRECATED_getWallets: function() { return /* binding */ DEPRECATED_getWallets; },\n/* harmony export */   getWallets: function() { return /* binding */ getWallets; }\n/* harmony export */ });\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _AppReadyEvent_detail;\nlet wallets = undefined;\nconst registered = new Set();\nconst listeners = {};\n/**\n * Get an API for {@link Wallets.get | getting}, {@link Wallets.on | listening for}, and\n * {@link Wallets.register | registering} {@link \"@wallet-standard/base\".Wallet | Wallets}.\n *\n * When called for the first time --\n *\n * This dispatches a {@link \"@wallet-standard/base\".WindowAppReadyEvent} to notify each Wallet that the app is ready\n * to register it.\n *\n * This also adds a listener for {@link \"@wallet-standard/base\".WindowRegisterWalletEvent} to listen for a notification\n * from each Wallet that the Wallet is ready to be registered by the app.\n *\n * This combination of event dispatch and listener guarantees that each Wallet will be registered synchronously as soon\n * as the app is ready whether the app loads before or after each Wallet.\n *\n * @return API for getting, listening for, and registering Wallets.\n *\n * @group App\n */\nfunction getWallets() {\n    if (wallets)\n        return wallets;\n    wallets = Object.freeze({ register, get, on });\n    if (typeof window === 'undefined')\n        return wallets;\n    const api = Object.freeze({ register });\n    try {\n        window.addEventListener('wallet-standard:register-wallet', ({ detail: callback }) => callback(api));\n    }\n    catch (error) {\n        console.error('wallet-standard:register-wallet event listener could not be added\\n', error);\n    }\n    try {\n        window.dispatchEvent(new AppReadyEvent(api));\n    }\n    catch (error) {\n        console.error('wallet-standard:app-ready event could not be dispatched\\n', error);\n    }\n    return wallets;\n}\nfunction register(...wallets) {\n    // Filter out wallets that have already been registered.\n    // This prevents the same wallet from being registered twice, but it also prevents wallets from being\n    // unregistered by reusing a reference to the wallet to obtain the unregister function for it.\n    wallets = wallets.filter((wallet) => !registered.has(wallet));\n    // If there are no new wallets to register, just return a no-op unregister function.\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    if (!wallets.length)\n        return () => { };\n    wallets.forEach((wallet) => registered.add(wallet));\n    listeners['register']?.forEach((listener) => guard(() => listener(...wallets)));\n    // Return a function that unregisters the registered wallets.\n    return function unregister() {\n        wallets.forEach((wallet) => registered.delete(wallet));\n        listeners['unregister']?.forEach((listener) => guard(() => listener(...wallets)));\n    };\n}\nfunction get() {\n    return [...registered];\n}\nfunction on(event, listener) {\n    listeners[event]?.push(listener) || (listeners[event] = [listener]);\n    // Return a function that removes the event listener.\n    return function off() {\n        listeners[event] = listeners[event]?.filter((existingListener) => listener !== existingListener);\n    };\n}\nfunction guard(callback) {\n    try {\n        callback();\n    }\n    catch (error) {\n        console.error(error);\n    }\n}\nclass AppReadyEvent extends Event {\n    constructor(api) {\n        super('wallet-standard:app-ready', {\n            bubbles: false,\n            cancelable: false,\n            composed: false,\n        });\n        _AppReadyEvent_detail.set(this, void 0);\n        __classPrivateFieldSet(this, _AppReadyEvent_detail, api, \"f\");\n    }\n    get detail() {\n        return __classPrivateFieldGet(this, _AppReadyEvent_detail, \"f\");\n    }\n    get type() {\n        return 'wallet-standard:app-ready';\n    }\n    /** @deprecated */\n    preventDefault() {\n        throw new Error('preventDefault cannot be called');\n    }\n    /** @deprecated */\n    stopImmediatePropagation() {\n        throw new Error('stopImmediatePropagation cannot be called');\n    }\n    /** @deprecated */\n    stopPropagation() {\n        throw new Error('stopPropagation cannot be called');\n    }\n}\n_AppReadyEvent_detail = new WeakMap();\n/**\n * @deprecated Use {@link getWallets} instead.\n *\n * @group Deprecated\n */\nfunction DEPRECATED_getWallets() {\n    if (wallets)\n        return wallets;\n    wallets = getWallets();\n    if (typeof window === 'undefined')\n        return wallets;\n    const callbacks = window.navigator.wallets || [];\n    if (!Array.isArray(callbacks)) {\n        console.error('window.navigator.wallets is not an array');\n        return wallets;\n    }\n    const { register } = wallets;\n    const push = (...callbacks) => callbacks.forEach((callback) => guard(() => callback({ register })));\n    try {\n        Object.defineProperty(window.navigator, 'wallets', {\n            value: Object.freeze({ push }),\n        });\n    }\n    catch (error) {\n        console.error('window.navigator.wallets could not be set');\n        return wallets;\n    }\n    push(...callbacks);\n    return wallets;\n}\n//# sourceMappingURL=wallets.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ad2FsbGV0LXN0YW5kYXJkL2FwcC9saWIvZXNtL3dhbGxldHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFJLElBQUksU0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsNEJBQTRCLEdBQUcsaUNBQWlDO0FBQ25GLElBQUksdUNBQXVDLCtDQUErQztBQUMxRjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbURBQW1EO0FBQ3pFO0FBQ0E7QUFDQSxrQ0FBa0MseURBQXlEO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBLDhCQUE4QixtQkFBbUI7QUFDakQ7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0Esc0VBQXNFLGtCQUFrQjtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksV0FBVztBQUN2QiwwRkFBMEYsVUFBVTtBQUNwRztBQUNBO0FBQ0EsbUNBQW1DLE1BQU07QUFDekMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHdhbGxldC1zdGFuZGFyZC9hcHAvbGliL2VzbS93YWxsZXRzLmpzP2Y3OWQiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fY2xhc3NQcml2YXRlRmllbGRTZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRTZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIHZhbHVlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCB3cml0ZSBwcml2YXRlIG1lbWJlciB0byBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xufTtcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XG59O1xudmFyIF9BcHBSZWFkeUV2ZW50X2RldGFpbDtcbmxldCB3YWxsZXRzID0gdW5kZWZpbmVkO1xuY29uc3QgcmVnaXN0ZXJlZCA9IG5ldyBTZXQoKTtcbmNvbnN0IGxpc3RlbmVycyA9IHt9O1xuLyoqXG4gKiBHZXQgYW4gQVBJIGZvciB7QGxpbmsgV2FsbGV0cy5nZXQgfCBnZXR0aW5nfSwge0BsaW5rIFdhbGxldHMub24gfCBsaXN0ZW5pbmcgZm9yfSwgYW5kXG4gKiB7QGxpbmsgV2FsbGV0cy5yZWdpc3RlciB8IHJlZ2lzdGVyaW5nfSB7QGxpbmsgXCJAd2FsbGV0LXN0YW5kYXJkL2Jhc2VcIi5XYWxsZXQgfCBXYWxsZXRzfS5cbiAqXG4gKiBXaGVuIGNhbGxlZCBmb3IgdGhlIGZpcnN0IHRpbWUgLS1cbiAqXG4gKiBUaGlzIGRpc3BhdGNoZXMgYSB7QGxpbmsgXCJAd2FsbGV0LXN0YW5kYXJkL2Jhc2VcIi5XaW5kb3dBcHBSZWFkeUV2ZW50fSB0byBub3RpZnkgZWFjaCBXYWxsZXQgdGhhdCB0aGUgYXBwIGlzIHJlYWR5XG4gKiB0byByZWdpc3RlciBpdC5cbiAqXG4gKiBUaGlzIGFsc28gYWRkcyBhIGxpc3RlbmVyIGZvciB7QGxpbmsgXCJAd2FsbGV0LXN0YW5kYXJkL2Jhc2VcIi5XaW5kb3dSZWdpc3RlcldhbGxldEV2ZW50fSB0byBsaXN0ZW4gZm9yIGEgbm90aWZpY2F0aW9uXG4gKiBmcm9tIGVhY2ggV2FsbGV0IHRoYXQgdGhlIFdhbGxldCBpcyByZWFkeSB0byBiZSByZWdpc3RlcmVkIGJ5IHRoZSBhcHAuXG4gKlxuICogVGhpcyBjb21iaW5hdGlvbiBvZiBldmVudCBkaXNwYXRjaCBhbmQgbGlzdGVuZXIgZ3VhcmFudGVlcyB0aGF0IGVhY2ggV2FsbGV0IHdpbGwgYmUgcmVnaXN0ZXJlZCBzeW5jaHJvbm91c2x5IGFzIHNvb25cbiAqIGFzIHRoZSBhcHAgaXMgcmVhZHkgd2hldGhlciB0aGUgYXBwIGxvYWRzIGJlZm9yZSBvciBhZnRlciBlYWNoIFdhbGxldC5cbiAqXG4gKiBAcmV0dXJuIEFQSSBmb3IgZ2V0dGluZywgbGlzdGVuaW5nIGZvciwgYW5kIHJlZ2lzdGVyaW5nIFdhbGxldHMuXG4gKlxuICogQGdyb3VwIEFwcFxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0V2FsbGV0cygpIHtcbiAgICBpZiAod2FsbGV0cylcbiAgICAgICAgcmV0dXJuIHdhbGxldHM7XG4gICAgd2FsbGV0cyA9IE9iamVjdC5mcmVlemUoeyByZWdpc3RlciwgZ2V0LCBvbiB9KTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiB3YWxsZXRzO1xuICAgIGNvbnN0IGFwaSA9IE9iamVjdC5mcmVlemUoeyByZWdpc3RlciB9KTtcbiAgICB0cnkge1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignd2FsbGV0LXN0YW5kYXJkOnJlZ2lzdGVyLXdhbGxldCcsICh7IGRldGFpbDogY2FsbGJhY2sgfSkgPT4gY2FsbGJhY2soYXBpKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCd3YWxsZXQtc3RhbmRhcmQ6cmVnaXN0ZXItd2FsbGV0IGV2ZW50IGxpc3RlbmVyIGNvdWxkIG5vdCBiZSBhZGRlZFxcbicsIGVycm9yKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgd2luZG93LmRpc3BhdGNoRXZlbnQobmV3IEFwcFJlYWR5RXZlbnQoYXBpKSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCd3YWxsZXQtc3RhbmRhcmQ6YXBwLXJlYWR5IGV2ZW50IGNvdWxkIG5vdCBiZSBkaXNwYXRjaGVkXFxuJywgZXJyb3IpO1xuICAgIH1cbiAgICByZXR1cm4gd2FsbGV0cztcbn1cbmZ1bmN0aW9uIHJlZ2lzdGVyKC4uLndhbGxldHMpIHtcbiAgICAvLyBGaWx0ZXIgb3V0IHdhbGxldHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiByZWdpc3RlcmVkLlxuICAgIC8vIFRoaXMgcHJldmVudHMgdGhlIHNhbWUgd2FsbGV0IGZyb20gYmVpbmcgcmVnaXN0ZXJlZCB0d2ljZSwgYnV0IGl0IGFsc28gcHJldmVudHMgd2FsbGV0cyBmcm9tIGJlaW5nXG4gICAgLy8gdW5yZWdpc3RlcmVkIGJ5IHJldXNpbmcgYSByZWZlcmVuY2UgdG8gdGhlIHdhbGxldCB0byBvYnRhaW4gdGhlIHVucmVnaXN0ZXIgZnVuY3Rpb24gZm9yIGl0LlxuICAgIHdhbGxldHMgPSB3YWxsZXRzLmZpbHRlcigod2FsbGV0KSA9PiAhcmVnaXN0ZXJlZC5oYXMod2FsbGV0KSk7XG4gICAgLy8gSWYgdGhlcmUgYXJlIG5vIG5ldyB3YWxsZXRzIHRvIHJlZ2lzdGVyLCBqdXN0IHJldHVybiBhIG5vLW9wIHVucmVnaXN0ZXIgZnVuY3Rpb24uXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1lbXB0eS1mdW5jdGlvblxuICAgIGlmICghd2FsbGV0cy5sZW5ndGgpXG4gICAgICAgIHJldHVybiAoKSA9PiB7IH07XG4gICAgd2FsbGV0cy5mb3JFYWNoKCh3YWxsZXQpID0+IHJlZ2lzdGVyZWQuYWRkKHdhbGxldCkpO1xuICAgIGxpc3RlbmVyc1sncmVnaXN0ZXInXT8uZm9yRWFjaCgobGlzdGVuZXIpID0+IGd1YXJkKCgpID0+IGxpc3RlbmVyKC4uLndhbGxldHMpKSk7XG4gICAgLy8gUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB1bnJlZ2lzdGVycyB0aGUgcmVnaXN0ZXJlZCB3YWxsZXRzLlxuICAgIHJldHVybiBmdW5jdGlvbiB1bnJlZ2lzdGVyKCkge1xuICAgICAgICB3YWxsZXRzLmZvckVhY2goKHdhbGxldCkgPT4gcmVnaXN0ZXJlZC5kZWxldGUod2FsbGV0KSk7XG4gICAgICAgIGxpc3RlbmVyc1sndW5yZWdpc3RlciddPy5mb3JFYWNoKChsaXN0ZW5lcikgPT4gZ3VhcmQoKCkgPT4gbGlzdGVuZXIoLi4ud2FsbGV0cykpKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBbLi4ucmVnaXN0ZXJlZF07XG59XG5mdW5jdGlvbiBvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBsaXN0ZW5lcnNbZXZlbnRdPy5wdXNoKGxpc3RlbmVyKSB8fCAobGlzdGVuZXJzW2V2ZW50XSA9IFtsaXN0ZW5lcl0pO1xuICAgIC8vIFJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXIuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIG9mZigpIHtcbiAgICAgICAgbGlzdGVuZXJzW2V2ZW50XSA9IGxpc3RlbmVyc1tldmVudF0/LmZpbHRlcigoZXhpc3RpbmdMaXN0ZW5lcikgPT4gbGlzdGVuZXIgIT09IGV4aXN0aW5nTGlzdGVuZXIpO1xuICAgIH07XG59XG5mdW5jdGlvbiBndWFyZChjYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG59XG5jbGFzcyBBcHBSZWFkeUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGFwaSkge1xuICAgICAgICBzdXBlcignd2FsbGV0LXN0YW5kYXJkOmFwcC1yZWFkeScsIHtcbiAgICAgICAgICAgIGJ1YmJsZXM6IGZhbHNlLFxuICAgICAgICAgICAgY2FuY2VsYWJsZTogZmFsc2UsXG4gICAgICAgICAgICBjb21wb3NlZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBfQXBwUmVhZHlFdmVudF9kZXRhaWwuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0FwcFJlYWR5RXZlbnRfZGV0YWlsLCBhcGksIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0IGRldGFpbCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0FwcFJlYWR5RXZlbnRfZGV0YWlsLCBcImZcIik7XG4gICAgfVxuICAgIGdldCB0eXBlKCkge1xuICAgICAgICByZXR1cm4gJ3dhbGxldC1zdGFuZGFyZDphcHAtcmVhZHknO1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBwcmV2ZW50RGVmYXVsdCgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwcmV2ZW50RGVmYXVsdCBjYW5ub3QgYmUgY2FsbGVkJyk7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCAqL1xuICAgIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gY2Fubm90IGJlIGNhbGxlZCcpO1xuICAgIH1cbiAgICAvKiogQGRlcHJlY2F0ZWQgKi9cbiAgICBzdG9wUHJvcGFnYXRpb24oKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignc3RvcFByb3BhZ2F0aW9uIGNhbm5vdCBiZSBjYWxsZWQnKTtcbiAgICB9XG59XG5fQXBwUmVhZHlFdmVudF9kZXRhaWwgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKiBAZGVwcmVjYXRlZCBVc2Uge0BsaW5rIGdldFdhbGxldHN9IGluc3RlYWQuXG4gKlxuICogQGdyb3VwIERlcHJlY2F0ZWRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIERFUFJFQ0FURURfZ2V0V2FsbGV0cygpIHtcbiAgICBpZiAod2FsbGV0cylcbiAgICAgICAgcmV0dXJuIHdhbGxldHM7XG4gICAgd2FsbGV0cyA9IGdldFdhbGxldHMoKTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgIHJldHVybiB3YWxsZXRzO1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IHdpbmRvdy5uYXZpZ2F0b3Iud2FsbGV0cyB8fCBbXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY2FsbGJhY2tzKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCd3aW5kb3cubmF2aWdhdG9yLndhbGxldHMgaXMgbm90IGFuIGFycmF5Jyk7XG4gICAgICAgIHJldHVybiB3YWxsZXRzO1xuICAgIH1cbiAgICBjb25zdCB7IHJlZ2lzdGVyIH0gPSB3YWxsZXRzO1xuICAgIGNvbnN0IHB1c2ggPSAoLi4uY2FsbGJhY2tzKSA9PiBjYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IGd1YXJkKCgpID0+IGNhbGxiYWNrKHsgcmVnaXN0ZXIgfSkpKTtcbiAgICB0cnkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93Lm5hdmlnYXRvciwgJ3dhbGxldHMnLCB7XG4gICAgICAgICAgICB2YWx1ZTogT2JqZWN0LmZyZWV6ZSh7IHB1c2ggfSksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignd2luZG93Lm5hdmlnYXRvci53YWxsZXRzIGNvdWxkIG5vdCBiZSBzZXQnKTtcbiAgICAgICAgcmV0dXJuIHdhbGxldHM7XG4gICAgfVxuICAgIHB1c2goLi4uY2FsbGJhY2tzKTtcbiAgICByZXR1cm4gd2FsbGV0cztcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhbGxldHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@wallet-standard/app/lib/esm/wallets.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@wallet-standard/features/lib/esm/connect.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@wallet-standard/features/lib/esm/connect.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Connect: function() { return /* binding */ Connect; },\n/* harmony export */   StandardConnect: function() { return /* binding */ StandardConnect; }\n/* harmony export */ });\n/** Name of the feature. */\nconst StandardConnect = 'standard:connect';\n/**\n * @deprecated Use {@link StandardConnect} instead.\n *\n * @group Deprecated\n */\nconst Connect = StandardConnect;\n//# sourceMappingURL=connect.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ad2FsbGV0LXN0YW5kYXJkL2ZlYXR1cmVzL2xpYi9lc20vY29ubmVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ087QUFDUDtBQUNBLG9CQUFvQix1QkFBdUI7QUFDM0M7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHdhbGxldC1zdGFuZGFyZC9mZWF0dXJlcy9saWIvZXNtL2Nvbm5lY3QuanM/ZjEyMyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogTmFtZSBvZiB0aGUgZmVhdHVyZS4gKi9cbmV4cG9ydCBjb25zdCBTdGFuZGFyZENvbm5lY3QgPSAnc3RhbmRhcmQ6Y29ubmVjdCc7XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgU3RhbmRhcmRDb25uZWN0fSBpbnN0ZWFkLlxuICpcbiAqIEBncm91cCBEZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBjb25zdCBDb25uZWN0ID0gU3RhbmRhcmRDb25uZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29ubmVjdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@wallet-standard/features/lib/esm/connect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@wallet-standard/features/lib/esm/disconnect.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@wallet-standard/features/lib/esm/disconnect.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Disconnect: function() { return /* binding */ Disconnect; },\n/* harmony export */   StandardDisconnect: function() { return /* binding */ StandardDisconnect; }\n/* harmony export */ });\n/** Name of the feature. */\nconst StandardDisconnect = 'standard:disconnect';\n/**\n * @deprecated Use {@link StandardDisconnect} instead.\n *\n * @group Deprecated\n */\nconst Disconnect = StandardDisconnect;\n//# sourceMappingURL=disconnect.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ad2FsbGV0LXN0YW5kYXJkL2ZlYXR1cmVzL2xpYi9lc20vZGlzY29ubmVjdC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBO0FBQ087QUFDUDtBQUNBLG9CQUFvQiwwQkFBMEI7QUFDOUM7QUFDQTtBQUNBO0FBQ087QUFDUCIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQHdhbGxldC1zdGFuZGFyZC9mZWF0dXJlcy9saWIvZXNtL2Rpc2Nvbm5lY3QuanM/NGNiNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiogTmFtZSBvZiB0aGUgZmVhdHVyZS4gKi9cbmV4cG9ydCBjb25zdCBTdGFuZGFyZERpc2Nvbm5lY3QgPSAnc3RhbmRhcmQ6ZGlzY29ubmVjdCc7XG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgU3RhbmRhcmREaXNjb25uZWN0fSBpbnN0ZWFkLlxuICpcbiAqIEBncm91cCBEZXByZWNhdGVkXG4gKi9cbmV4cG9ydCBjb25zdCBEaXNjb25uZWN0ID0gU3RhbmRhcmREaXNjb25uZWN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGlzY29ubmVjdC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@wallet-standard/features/lib/esm/disconnect.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@wallet-standard/features/lib/esm/events.js":
/*!******************************************************************!*\
  !*** ./node_modules/@wallet-standard/features/lib/esm/events.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Events: function() { return /* binding */ Events; },\n/* harmony export */   StandardEvents: function() { return /* binding */ StandardEvents; }\n/* harmony export */ });\n/** Name of the feature. */\nconst StandardEvents = 'standard:events';\n/**\n * @deprecated Use {@link StandardEvents} instead.\n *\n * @group Deprecated\n */\nconst Events = StandardEvents;\n//# sourceMappingURL=events.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ad2FsbGV0LXN0YW5kYXJkL2ZlYXR1cmVzL2xpYi9lc20vZXZlbnRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQUE7QUFDTztBQUNQO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDTztBQUNQIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ad2FsbGV0LXN0YW5kYXJkL2ZlYXR1cmVzL2xpYi9lc20vZXZlbnRzLmpzPzgxMzciXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIE5hbWUgb2YgdGhlIGZlYXR1cmUuICovXG5leHBvcnQgY29uc3QgU3RhbmRhcmRFdmVudHMgPSAnc3RhbmRhcmQ6ZXZlbnRzJztcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBTdGFuZGFyZEV2ZW50c30gaW5zdGVhZC5cbiAqXG4gKiBAZ3JvdXAgRGVwcmVjYXRlZFxuICovXG5leHBvcnQgY29uc3QgRXZlbnRzID0gU3RhbmRhcmRFdmVudHM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ldmVudHMuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@wallet-standard/features/lib/esm/events.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@wallet-standard/wallet/lib/esm/util.js":
/*!**************************************************************!*\
  !*** ./node_modules/@wallet-standard/wallet/lib/esm/util.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ReadonlyWalletAccount: function() { return /* binding */ ReadonlyWalletAccount; },\n/* harmony export */   arraysEqual: function() { return /* binding */ arraysEqual; },\n/* harmony export */   bytesEqual: function() { return /* binding */ bytesEqual; },\n/* harmony export */   concatBytes: function() { return /* binding */ concatBytes; },\n/* harmony export */   guard: function() { return /* binding */ guard; },\n/* harmony export */   pick: function() { return /* binding */ pick; }\n/* harmony export */ });\nvar __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar _ReadonlyWalletAccount_address, _ReadonlyWalletAccount_publicKey, _ReadonlyWalletAccount_chains, _ReadonlyWalletAccount_features, _ReadonlyWalletAccount_label, _ReadonlyWalletAccount_icon;\n/**\n * Base implementation of a {@link \"@wallet-standard/base\".WalletAccount} to be used or extended by a\n * {@link \"@wallet-standard/base\".Wallet}.\n *\n * `WalletAccount` properties must be read-only. This class enforces this by making all properties\n * [truly private](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/Private_class_fields) and\n * read-only, using getters for access, returning copies instead of references, and calling\n * [Object.freeze](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze)\n * on the instance.\n *\n * @group Account\n */\nclass ReadonlyWalletAccount {\n    /**\n     * Create and freeze a read-only account.\n     *\n     * @param account Account to copy properties from.\n     */\n    constructor(account) {\n        _ReadonlyWalletAccount_address.set(this, void 0);\n        _ReadonlyWalletAccount_publicKey.set(this, void 0);\n        _ReadonlyWalletAccount_chains.set(this, void 0);\n        _ReadonlyWalletAccount_features.set(this, void 0);\n        _ReadonlyWalletAccount_label.set(this, void 0);\n        _ReadonlyWalletAccount_icon.set(this, void 0);\n        if (new.target === ReadonlyWalletAccount) {\n            Object.freeze(this);\n        }\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_address, account.address, \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_publicKey, account.publicKey.slice(), \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_chains, account.chains.slice(), \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_features, account.features.slice(), \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_label, account.label, \"f\");\n        __classPrivateFieldSet(this, _ReadonlyWalletAccount_icon, account.icon, \"f\");\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.address | WalletAccount::address} */\n    get address() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_address, \"f\");\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.publicKey | WalletAccount::publicKey} */\n    get publicKey() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_publicKey, \"f\").slice();\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.chains | WalletAccount::chains} */\n    get chains() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_chains, \"f\").slice();\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.features | WalletAccount::features} */\n    get features() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_features, \"f\").slice();\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.label | WalletAccount::label} */\n    get label() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_label, \"f\");\n    }\n    /** Implementation of {@link \"@wallet-standard/base\".WalletAccount.icon | WalletAccount::icon} */\n    get icon() {\n        return __classPrivateFieldGet(this, _ReadonlyWalletAccount_icon, \"f\");\n    }\n}\n_ReadonlyWalletAccount_address = new WeakMap(), _ReadonlyWalletAccount_publicKey = new WeakMap(), _ReadonlyWalletAccount_chains = new WeakMap(), _ReadonlyWalletAccount_features = new WeakMap(), _ReadonlyWalletAccount_label = new WeakMap(), _ReadonlyWalletAccount_icon = new WeakMap();\n/**\n * Efficiently compare {@link Indexed} arrays (e.g. `Array` and `Uint8Array`).\n *\n * @param a An array.\n * @param b Another array.\n *\n * @return `true` if the arrays have the same length and elements, `false` otherwise.\n *\n * @group Util\n */\nfunction arraysEqual(a, b) {\n    if (a === b)\n        return true;\n    const length = a.length;\n    if (length !== b.length)\n        return false;\n    for (let i = 0; i < length; i++) {\n        if (a[i] !== b[i])\n            return false;\n    }\n    return true;\n}\n/**\n * Efficiently compare byte arrays, using {@link arraysEqual}.\n *\n * @param a A byte array.\n * @param b Another byte array.\n *\n * @return `true` if the byte arrays have the same length and bytes, `false` otherwise.\n *\n * @group Util\n */\nfunction bytesEqual(a, b) {\n    return arraysEqual(a, b);\n}\n/**\n * Efficiently concatenate byte arrays without modifying them.\n *\n * @param first  A byte array.\n * @param others Additional byte arrays.\n *\n * @return New byte array containing the concatenation of all the byte arrays.\n *\n * @group Util\n */\nfunction concatBytes(first, ...others) {\n    const length = others.reduce((length, bytes) => length + bytes.length, first.length);\n    const bytes = new Uint8Array(length);\n    bytes.set(first, 0);\n    for (const other of others) {\n        bytes.set(other, bytes.length);\n    }\n    return bytes;\n}\n/**\n * Create a new object with a subset of fields from a source object.\n *\n * @param source Object to pick fields from.\n * @param keys   Names of fields to pick.\n *\n * @return New object with only the picked fields.\n *\n * @group Util\n */\nfunction pick(source, ...keys) {\n    const picked = {};\n    for (const key of keys) {\n        picked[key] = source[key];\n    }\n    return picked;\n}\n/**\n * Call a callback function, catch an error if it throws, and log the error without rethrowing.\n *\n * @param callback Function to call.\n *\n * @group Util\n */\nfunction guard(callback) {\n    try {\n        callback();\n    }\n    catch (error) {\n        console.error(error);\n    }\n}\n//# sourceMappingURL=util.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9Ad2FsbGV0LXN0YW5kYXJkL3dhbGxldC9saWIvZXNtL3V0aWwuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQUEsOEJBQThCLFNBQUksSUFBSSxTQUFJO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDZDQUE2QztBQUMxRSxJQUFJLHFDQUFxQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDhFQUE4RTtBQUN6RztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsa0ZBQWtGO0FBQzdHO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0RUFBNEU7QUFDdkc7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGdGQUFnRjtBQUMzRztBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsMEVBQTBFO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQix3RUFBd0U7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxrQkFBa0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9Ad2FsbGV0LXN0YW5kYXJkL3dhbGxldC9saWIvZXNtL3V0aWwuanM/NDAyOSJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgX19jbGFzc1ByaXZhdGVGaWVsZFNldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZFNldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJtXCIpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIG1ldGhvZCBpcyBub3Qgd3JpdGFibGVcIik7XG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIChraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlciwgdmFsdWUpIDogZiA/IGYudmFsdWUgPSB2YWx1ZSA6IHN0YXRlLnNldChyZWNlaXZlciwgdmFsdWUpKSwgdmFsdWU7XG59O1xudmFyIF9fY2xhc3NQcml2YXRlRmllbGRHZXQgPSAodGhpcyAmJiB0aGlzLl9fY2xhc3NQcml2YXRlRmllbGRHZXQpIHx8IGZ1bmN0aW9uIChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcbn07XG52YXIgX1JlYWRvbmx5V2FsbGV0QWNjb3VudF9hZGRyZXNzLCBfUmVhZG9ubHlXYWxsZXRBY2NvdW50X3B1YmxpY0tleSwgX1JlYWRvbmx5V2FsbGV0QWNjb3VudF9jaGFpbnMsIF9SZWFkb25seVdhbGxldEFjY291bnRfZmVhdHVyZXMsIF9SZWFkb25seVdhbGxldEFjY291bnRfbGFiZWwsIF9SZWFkb25seVdhbGxldEFjY291bnRfaWNvbjtcbi8qKlxuICogQmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBhIHtAbGluayBcIkB3YWxsZXQtc3RhbmRhcmQvYmFzZVwiLldhbGxldEFjY291bnR9IHRvIGJlIHVzZWQgb3IgZXh0ZW5kZWQgYnkgYVxuICoge0BsaW5rIFwiQHdhbGxldC1zdGFuZGFyZC9iYXNlXCIuV2FsbGV0fS5cbiAqXG4gKiBgV2FsbGV0QWNjb3VudGAgcHJvcGVydGllcyBtdXN0IGJlIHJlYWQtb25seS4gVGhpcyBjbGFzcyBlbmZvcmNlcyB0aGlzIGJ5IG1ha2luZyBhbGwgcHJvcGVydGllc1xuICogW3RydWx5IHByaXZhdGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0NsYXNzZXMvUHJpdmF0ZV9jbGFzc19maWVsZHMpIGFuZFxuICogcmVhZC1vbmx5LCB1c2luZyBnZXR0ZXJzIGZvciBhY2Nlc3MsIHJldHVybmluZyBjb3BpZXMgaW5zdGVhZCBvZiByZWZlcmVuY2VzLCBhbmQgY2FsbGluZ1xuICogW09iamVjdC5mcmVlemVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9mcmVlemUpXG4gKiBvbiB0aGUgaW5zdGFuY2UuXG4gKlxuICogQGdyb3VwIEFjY291bnRcbiAqL1xuZXhwb3J0IGNsYXNzIFJlYWRvbmx5V2FsbGV0QWNjb3VudCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGFuZCBmcmVlemUgYSByZWFkLW9ubHkgYWNjb3VudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhY2NvdW50IEFjY291bnQgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYWNjb3VudCkge1xuICAgICAgICBfUmVhZG9ubHlXYWxsZXRBY2NvdW50X2FkZHJlc3Muc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9SZWFkb25seVdhbGxldEFjY291bnRfcHVibGljS2V5LnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBfUmVhZG9ubHlXYWxsZXRBY2NvdW50X2NoYWlucy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1JlYWRvbmx5V2FsbGV0QWNjb3VudF9mZWF0dXJlcy5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1JlYWRvbmx5V2FsbGV0QWNjb3VudF9sYWJlbC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX1JlYWRvbmx5V2FsbGV0QWNjb3VudF9pY29uLnNldCh0aGlzLCB2b2lkIDApO1xuICAgICAgICBpZiAobmV3LnRhcmdldCA9PT0gUmVhZG9ubHlXYWxsZXRBY2NvdW50KSB7XG4gICAgICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1JlYWRvbmx5V2FsbGV0QWNjb3VudF9hZGRyZXNzLCBhY2NvdW50LmFkZHJlc3MsIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfUmVhZG9ubHlXYWxsZXRBY2NvdW50X3B1YmxpY0tleSwgYWNjb3VudC5wdWJsaWNLZXkuc2xpY2UoKSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9SZWFkb25seVdhbGxldEFjY291bnRfY2hhaW5zLCBhY2NvdW50LmNoYWlucy5zbGljZSgpLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1JlYWRvbmx5V2FsbGV0QWNjb3VudF9mZWF0dXJlcywgYWNjb3VudC5mZWF0dXJlcy5zbGljZSgpLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1JlYWRvbmx5V2FsbGV0QWNjb3VudF9sYWJlbCwgYWNjb3VudC5sYWJlbCwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9SZWFkb25seVdhbGxldEFjY291bnRfaWNvbiwgYWNjb3VudC5pY29uLCBcImZcIik7XG4gICAgfVxuICAgIC8qKiBJbXBsZW1lbnRhdGlvbiBvZiB7QGxpbmsgXCJAd2FsbGV0LXN0YW5kYXJkL2Jhc2VcIi5XYWxsZXRBY2NvdW50LmFkZHJlc3MgfCBXYWxsZXRBY2NvdW50OjphZGRyZXNzfSAqL1xuICAgIGdldCBhZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUmVhZG9ubHlXYWxsZXRBY2NvdW50X2FkZHJlc3MsIFwiZlwiKTtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBcIkB3YWxsZXQtc3RhbmRhcmQvYmFzZVwiLldhbGxldEFjY291bnQucHVibGljS2V5IHwgV2FsbGV0QWNjb3VudDo6cHVibGljS2V5fSAqL1xuICAgIGdldCBwdWJsaWNLZXkoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9SZWFkb25seVdhbGxldEFjY291bnRfcHVibGljS2V5LCBcImZcIikuc2xpY2UoKTtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBcIkB3YWxsZXQtc3RhbmRhcmQvYmFzZVwiLldhbGxldEFjY291bnQuY2hhaW5zIHwgV2FsbGV0QWNjb3VudDo6Y2hhaW5zfSAqL1xuICAgIGdldCBjaGFpbnMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9SZWFkb25seVdhbGxldEFjY291bnRfY2hhaW5zLCBcImZcIikuc2xpY2UoKTtcbiAgICB9XG4gICAgLyoqIEltcGxlbWVudGF0aW9uIG9mIHtAbGluayBcIkB3YWxsZXQtc3RhbmRhcmQvYmFzZVwiLldhbGxldEFjY291bnQuZmVhdHVyZXMgfCBXYWxsZXRBY2NvdW50OjpmZWF0dXJlc30gKi9cbiAgICBnZXQgZmVhdHVyZXMoKSB7XG4gICAgICAgIHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9SZWFkb25seVdhbGxldEFjY291bnRfZmVhdHVyZXMsIFwiZlwiKS5zbGljZSgpO1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIFwiQHdhbGxldC1zdGFuZGFyZC9iYXNlXCIuV2FsbGV0QWNjb3VudC5sYWJlbCB8IFdhbGxldEFjY291bnQ6OmxhYmVsfSAqL1xuICAgIGdldCBsYWJlbCgpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1JlYWRvbmx5V2FsbGV0QWNjb3VudF9sYWJlbCwgXCJmXCIpO1xuICAgIH1cbiAgICAvKiogSW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIFwiQHdhbGxldC1zdGFuZGFyZC9iYXNlXCIuV2FsbGV0QWNjb3VudC5pY29uIHwgV2FsbGV0QWNjb3VudDo6aWNvbn0gKi9cbiAgICBnZXQgaWNvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1JlYWRvbmx5V2FsbGV0QWNjb3VudF9pY29uLCBcImZcIik7XG4gICAgfVxufVxuX1JlYWRvbmx5V2FsbGV0QWNjb3VudF9hZGRyZXNzID0gbmV3IFdlYWtNYXAoKSwgX1JlYWRvbmx5V2FsbGV0QWNjb3VudF9wdWJsaWNLZXkgPSBuZXcgV2Vha01hcCgpLCBfUmVhZG9ubHlXYWxsZXRBY2NvdW50X2NoYWlucyA9IG5ldyBXZWFrTWFwKCksIF9SZWFkb25seVdhbGxldEFjY291bnRfZmVhdHVyZXMgPSBuZXcgV2Vha01hcCgpLCBfUmVhZG9ubHlXYWxsZXRBY2NvdW50X2xhYmVsID0gbmV3IFdlYWtNYXAoKSwgX1JlYWRvbmx5V2FsbGV0QWNjb3VudF9pY29uID0gbmV3IFdlYWtNYXAoKTtcbi8qKlxuICogRWZmaWNpZW50bHkgY29tcGFyZSB7QGxpbmsgSW5kZXhlZH0gYXJyYXlzIChlLmcuIGBBcnJheWAgYW5kIGBVaW50OEFycmF5YCkuXG4gKlxuICogQHBhcmFtIGEgQW4gYXJyYXkuXG4gKiBAcGFyYW0gYiBBbm90aGVyIGFycmF5LlxuICpcbiAqIEByZXR1cm4gYHRydWVgIGlmIHRoZSBhcnJheXMgaGF2ZSB0aGUgc2FtZSBsZW5ndGggYW5kIGVsZW1lbnRzLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZ3JvdXAgVXRpbFxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlzRXF1YWwoYSwgYikge1xuICAgIGlmIChhID09PSBiKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBjb25zdCBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSBjb21wYXJlIGJ5dGUgYXJyYXlzLCB1c2luZyB7QGxpbmsgYXJyYXlzRXF1YWx9LlxuICpcbiAqIEBwYXJhbSBhIEEgYnl0ZSBhcnJheS5cbiAqIEBwYXJhbSBiIEFub3RoZXIgYnl0ZSBhcnJheS5cbiAqXG4gKiBAcmV0dXJuIGB0cnVlYCBpZiB0aGUgYnl0ZSBhcnJheXMgaGF2ZSB0aGUgc2FtZSBsZW5ndGggYW5kIGJ5dGVzLCBgZmFsc2VgIG90aGVyd2lzZS5cbiAqXG4gKiBAZ3JvdXAgVXRpbFxuICovXG5leHBvcnQgZnVuY3Rpb24gYnl0ZXNFcXVhbChhLCBiKSB7XG4gICAgcmV0dXJuIGFycmF5c0VxdWFsKGEsIGIpO1xufVxuLyoqXG4gKiBFZmZpY2llbnRseSBjb25jYXRlbmF0ZSBieXRlIGFycmF5cyB3aXRob3V0IG1vZGlmeWluZyB0aGVtLlxuICpcbiAqIEBwYXJhbSBmaXJzdCAgQSBieXRlIGFycmF5LlxuICogQHBhcmFtIG90aGVycyBBZGRpdGlvbmFsIGJ5dGUgYXJyYXlzLlxuICpcbiAqIEByZXR1cm4gTmV3IGJ5dGUgYXJyYXkgY29udGFpbmluZyB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgdGhlIGJ5dGUgYXJyYXlzLlxuICpcbiAqIEBncm91cCBVdGlsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXRCeXRlcyhmaXJzdCwgLi4ub3RoZXJzKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gb3RoZXJzLnJlZHVjZSgobGVuZ3RoLCBieXRlcykgPT4gbGVuZ3RoICsgYnl0ZXMubGVuZ3RoLCBmaXJzdC5sZW5ndGgpO1xuICAgIGNvbnN0IGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBieXRlcy5zZXQoZmlyc3QsIDApO1xuICAgIGZvciAoY29uc3Qgb3RoZXIgb2Ygb3RoZXJzKSB7XG4gICAgICAgIGJ5dGVzLnNldChvdGhlciwgYnl0ZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVzO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgb2JqZWN0IHdpdGggYSBzdWJzZXQgb2YgZmllbGRzIGZyb20gYSBzb3VyY2Ugb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBzb3VyY2UgT2JqZWN0IHRvIHBpY2sgZmllbGRzIGZyb20uXG4gKiBAcGFyYW0ga2V5cyAgIE5hbWVzIG9mIGZpZWxkcyB0byBwaWNrLlxuICpcbiAqIEByZXR1cm4gTmV3IG9iamVjdCB3aXRoIG9ubHkgdGhlIHBpY2tlZCBmaWVsZHMuXG4gKlxuICogQGdyb3VwIFV0aWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBpY2soc291cmNlLCAuLi5rZXlzKSB7XG4gICAgY29uc3QgcGlja2VkID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBwaWNrZWRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gcGlja2VkO1xufVxuLyoqXG4gKiBDYWxsIGEgY2FsbGJhY2sgZnVuY3Rpb24sIGNhdGNoIGFuIGVycm9yIGlmIGl0IHRocm93cywgYW5kIGxvZyB0aGUgZXJyb3Igd2l0aG91dCByZXRocm93aW5nLlxuICpcbiAqIEBwYXJhbSBjYWxsYmFjayBGdW5jdGlvbiB0byBjYWxsLlxuICpcbiAqIEBncm91cCBVdGlsXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBndWFyZChjYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGlsLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@wallet-standard/wallet/lib/esm/util.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/superstruct/lib/index.es.js":
/*!**************************************************!*\
  !*** ./node_modules/superstruct/lib/index.es.js ***!
  \**************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Struct: function() { return /* binding */ Struct; },\n/* harmony export */   StructError: function() { return /* binding */ StructError; },\n/* harmony export */   any: function() { return /* binding */ any; },\n/* harmony export */   array: function() { return /* binding */ array; },\n/* harmony export */   assert: function() { return /* binding */ assert; },\n/* harmony export */   assign: function() { return /* binding */ assign; },\n/* harmony export */   boolean: function() { return /* binding */ boolean; },\n/* harmony export */   coerce: function() { return /* binding */ coerce; },\n/* harmony export */   create: function() { return /* binding */ create; },\n/* harmony export */   date: function() { return /* binding */ date; },\n/* harmony export */   defaulted: function() { return /* binding */ defaulted; },\n/* harmony export */   define: function() { return /* binding */ define; },\n/* harmony export */   deprecated: function() { return /* binding */ deprecated; },\n/* harmony export */   dynamic: function() { return /* binding */ dynamic; },\n/* harmony export */   empty: function() { return /* binding */ empty; },\n/* harmony export */   enums: function() { return /* binding */ enums; },\n/* harmony export */   func: function() { return /* binding */ func; },\n/* harmony export */   instance: function() { return /* binding */ instance; },\n/* harmony export */   integer: function() { return /* binding */ integer; },\n/* harmony export */   intersection: function() { return /* binding */ intersection; },\n/* harmony export */   is: function() { return /* binding */ is; },\n/* harmony export */   lazy: function() { return /* binding */ lazy; },\n/* harmony export */   literal: function() { return /* binding */ literal; },\n/* harmony export */   map: function() { return /* binding */ map; },\n/* harmony export */   mask: function() { return /* binding */ mask; },\n/* harmony export */   max: function() { return /* binding */ max; },\n/* harmony export */   min: function() { return /* binding */ min; },\n/* harmony export */   never: function() { return /* binding */ never; },\n/* harmony export */   nullable: function() { return /* binding */ nullable; },\n/* harmony export */   number: function() { return /* binding */ number; },\n/* harmony export */   object: function() { return /* binding */ object; },\n/* harmony export */   omit: function() { return /* binding */ omit; },\n/* harmony export */   optional: function() { return /* binding */ optional; },\n/* harmony export */   partial: function() { return /* binding */ partial; },\n/* harmony export */   pattern: function() { return /* binding */ pattern; },\n/* harmony export */   pick: function() { return /* binding */ pick; },\n/* harmony export */   record: function() { return /* binding */ record; },\n/* harmony export */   refine: function() { return /* binding */ refine; },\n/* harmony export */   regexp: function() { return /* binding */ regexp; },\n/* harmony export */   set: function() { return /* binding */ set; },\n/* harmony export */   size: function() { return /* binding */ size; },\n/* harmony export */   string: function() { return /* binding */ string; },\n/* harmony export */   struct: function() { return /* binding */ struct; },\n/* harmony export */   trimmed: function() { return /* binding */ trimmed; },\n/* harmony export */   tuple: function() { return /* binding */ tuple; },\n/* harmony export */   type: function() { return /* binding */ type; },\n/* harmony export */   union: function() { return /* binding */ union; },\n/* harmony export */   unknown: function() { return /* binding */ unknown; },\n/* harmony export */   validate: function() { return /* binding */ validate; }\n/* harmony export */ });\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n  constructor(failure, failures) {\n    let cached;\n    const {\n      message,\n      ...rest\n    } = failure;\n    const {\n      path\n    } = failure;\n    const msg = path.length === 0 ? message : \"At path: \" + path.join('.') + \" -- \" + message;\n    super(msg);\n    Object.assign(this, rest);\n    this.name = this.constructor.name;\n\n    this.failures = () => {\n      var _cached;\n\n      return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];\n    };\n  }\n\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\n\n\nfunction isObject(x) {\n  return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a plain object.\n */\n\nfunction isPlainObject(x) {\n  if (Object.prototype.toString.call(x) !== '[object Object]') {\n    return false;\n  }\n\n  const prototype = Object.getPrototypeOf(x);\n  return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\n\nfunction print(value) {\n  return typeof value === 'string' ? JSON.stringify(value) : \"\" + value;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\nfunction shiftIterator(input) {\n  const {\n    done,\n    value\n  } = input.next();\n  return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\n\nfunction toFailure(result, context, struct, value) {\n  if (result === true) {\n    return;\n  } else if (result === false) {\n    result = {};\n  } else if (typeof result === 'string') {\n    result = {\n      message: result\n    };\n  }\n\n  const {\n    path,\n    branch\n  } = context;\n  const {\n    type\n  } = struct;\n  const {\n    refinement,\n    message = \"Expected a value of type `\" + type + \"`\" + (refinement ? \" with refinement `\" + refinement + \"`\" : '') + \", but received: `\" + print(value) + \"`\"\n  } = result;\n  return {\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch,\n    ...result,\n    message\n  };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\n\nfunction* toFailures(result, context, struct, value) {\n  if (!isIterable(result)) {\n    result = [result];\n  }\n\n  for (const r of result) {\n    const failure = toFailure(r, context, struct, value);\n\n    if (failure) {\n      yield failure;\n    }\n  }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\n\nfunction* run(value, struct, options = {}) {\n  const {\n    path = [],\n    branch = [value],\n    coerce = false,\n    mask = false\n  } = options;\n  const ctx = {\n    path,\n    branch\n  };\n\n  if (coerce) {\n    value = struct.coercer(value, ctx);\n\n    if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n      for (const key in value) {\n        if (struct.schema[key] === undefined) {\n          delete value[key];\n        }\n      }\n    }\n  }\n\n  let valid = true;\n\n  for (const failure of struct.validator(value, ctx)) {\n    valid = false;\n    yield [failure, undefined];\n  }\n\n  for (let [k, v, s] of struct.entries(value, ctx)) {\n    const ts = run(v, s, {\n      path: k === undefined ? path : [...path, k],\n      branch: k === undefined ? branch : [...branch, v],\n      coerce,\n      mask\n    });\n\n    for (const t of ts) {\n      if (t[0]) {\n        valid = false;\n        yield [t[0], undefined];\n      } else if (coerce) {\n        v = t[1];\n\n        if (k === undefined) {\n          value = v;\n        } else if (value instanceof Map) {\n          value.set(k, v);\n        } else if (value instanceof Set) {\n          value.add(v);\n        } else if (isObject(value)) {\n          value[k] = v;\n        }\n      }\n    }\n  }\n\n  if (valid) {\n    for (const failure of struct.refiner(value, ctx)) {\n      valid = false;\n      yield [failure, undefined];\n    }\n  }\n\n  if (valid) {\n    yield [undefined, value];\n  }\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\n\nclass Struct {\n  constructor(props) {\n    const {\n      type,\n      schema,\n      validator,\n      refiner,\n      coercer = value => value,\n      entries = function* () {}\n    } = props;\n    this.type = type;\n    this.schema = schema;\n    this.entries = entries;\n    this.coercer = coercer;\n\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.validator = () => [];\n    }\n\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.refiner = () => [];\n    }\n  }\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n\n\n  assert(value) {\n    return assert(value, this);\n  }\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n\n\n  create(value) {\n    return create(value, this);\n  }\n  /**\n   * Check if a value passes the struct's validation.\n   */\n\n\n  is(value) {\n    return is(value, this);\n  }\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */\n\n\n  mask(value) {\n    return mask(value, this);\n  }\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */\n\n\n  validate(value, options = {}) {\n    return validate(value, this, options);\n  }\n\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\n\nfunction assert(value, struct) {\n  const result = validate(value, struct);\n\n  if (result[0]) {\n    throw result[0];\n  }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\n\nfunction create(value, struct) {\n  const result = validate(value, struct, {\n    coerce: true\n  });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\n\nfunction mask(value, struct) {\n  const result = validate(value, struct, {\n    coerce: true,\n    mask: true\n  });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Check if a value passes a struct.\n */\n\nfunction is(value, struct) {\n  const result = validate(value, struct);\n  return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\n\nfunction validate(value, struct, options = {}) {\n  const tuples = run(value, struct, options);\n  const tuple = shiftIterator(tuples);\n\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const t of tuples) {\n        if (t[0]) {\n          yield t[0];\n        }\n      }\n    });\n    return [error, undefined];\n  } else {\n    const v = tuple[1];\n    return [undefined, v];\n  }\n}\n\nfunction assign(...Structs) {\n  const schemas = Structs.map(s => s.schema);\n  const schema = Object.assign({}, ...schemas);\n  return object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\n\nfunction define(name, validator) {\n  return new Struct({\n    type: name,\n    schema: null,\n    validator\n  });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\n\nfunction deprecated(struct, log) {\n  return new Struct({ ...struct,\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n\n    validator(value, ctx) {\n      if (value === undefined) {\n        return true;\n      } else {\n        log(value, ctx);\n        return struct.validator(value, ctx);\n      }\n    }\n\n  });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\n\nfunction dynamic(fn) {\n  return new Struct({\n    type: 'dynamic',\n    schema: null,\n\n    *entries(value, ctx) {\n      const struct = fn(value, ctx);\n      yield* struct.entries(value, ctx);\n    },\n\n    validator(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.validator(value, ctx);\n    },\n\n    coercer(value, ctx) {\n      const struct = fn(value, ctx);\n      return struct.coercer(value, ctx);\n    }\n\n  });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\n\nfunction lazy(fn) {\n  let struct;\n  return new Struct({\n    type: 'lazy',\n    schema: null,\n\n    *entries(value, ctx) {\n      var _struct;\n\n      (_struct = struct) != null ? _struct : struct = fn();\n      yield* struct.entries(value, ctx);\n    },\n\n    validator(value, ctx) {\n      var _struct2;\n\n      (_struct2 = struct) != null ? _struct2 : struct = fn();\n      return struct.validator(value, ctx);\n    },\n\n    coercer(value, ctx) {\n      var _struct3;\n\n      (_struct3 = struct) != null ? _struct3 : struct = fn();\n      return struct.coercer(value, ctx);\n    }\n\n  });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\n\nfunction omit(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = { ...schema\n  };\n\n  for (const key of keys) {\n    delete subschema[key];\n  }\n\n  return object(subschema);\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\n\nfunction partial(struct) {\n  const schema = struct instanceof Struct ? { ...struct.schema\n  } : { ...struct\n  };\n\n  for (const key in schema) {\n    schema[key] = optional(schema[key]);\n  }\n\n  return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\n\nfunction pick(struct, keys) {\n  const {\n    schema\n  } = struct;\n  const subschema = {};\n\n  for (const key of keys) {\n    subschema[key] = schema[key];\n  }\n\n  return object(subschema);\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\n\nfunction struct(name, validator) {\n  console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n  return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\n\nfunction any() {\n  return define('any', () => true);\n}\nfunction array(Element) {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [i, v] of value.entries()) {\n          yield [i, v, Element];\n        }\n      }\n    },\n\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n\n    validator(value) {\n      return Array.isArray(value) || \"Expected an array value, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a boolean.\n */\n\nfunction boolean() {\n  return define('boolean', value => {\n    return typeof value === 'boolean';\n  });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\n\nfunction date() {\n  return define('date', value => {\n    return value instanceof Date && !isNaN(value.getTime()) || \"Expected a valid `Date` object, but received: \" + print(value);\n  });\n}\nfunction enums(values) {\n  const schema = {};\n  const description = values.map(v => print(v)).join();\n\n  for (const key of values) {\n    schema[key] = key;\n  }\n\n  return new Struct({\n    type: 'enums',\n    schema,\n\n    validator(value) {\n      return values.includes(value) || \"Expected one of `\" + description + \"`, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a function.\n */\n\nfunction func() {\n  return define('func', value => {\n    return typeof value === 'function' || \"Expected a function, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\n\nfunction instance(Class) {\n  return define('instance', value => {\n    return value instanceof Class || \"Expected a `\" + Class.name + \"` instance, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value is an integer.\n */\n\nfunction integer() {\n  return define('integer', value => {\n    return typeof value === 'number' && !isNaN(value) && Number.isInteger(value) || \"Expected an integer, but received: \" + print(value);\n  });\n}\nfunction intersection(Structs) {\n  return new Struct({\n    type: 'intersection',\n    schema: null,\n\n    *entries(value, ctx) {\n      for (const S of Structs) {\n        yield* S.entries(value, ctx);\n      }\n    },\n\n    *validator(value, ctx) {\n      for (const S of Structs) {\n        yield* S.validator(value, ctx);\n      }\n    },\n\n    *refiner(value, ctx) {\n      for (const S of Structs) {\n        yield* S.refiner(value, ctx);\n      }\n    }\n\n  });\n}\nfunction literal(constant) {\n  const description = print(constant);\n  const t = typeof constant;\n  return new Struct({\n    type: 'literal',\n    schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n\n    validator(value) {\n      return value === constant || \"Expected the literal `\" + description + \"`, but received: \" + print(value);\n    }\n\n  });\n}\nfunction map(Key, Value) {\n  return new Struct({\n    type: 'map',\n    schema: null,\n\n    *entries(value) {\n      if (Key && Value && value instanceof Map) {\n        for (const [k, v] of value.entries()) {\n          yield [k, k, Key];\n          yield [k, v, Value];\n        }\n      }\n    },\n\n    coercer(value) {\n      return value instanceof Map ? new Map(value) : value;\n    },\n\n    validator(value) {\n      return value instanceof Map || \"Expected a `Map` object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that no value ever passes validation.\n */\n\nfunction never() {\n  return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\n\nfunction nullable(struct) {\n  return new Struct({ ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx)\n  });\n}\n/**\n * Ensure that a value is a number.\n */\n\nfunction number() {\n  return define('number', value => {\n    return typeof value === 'number' && !isNaN(value) || \"Expected a number, but received: \" + print(value);\n  });\n}\nfunction object(schema) {\n  const knowns = schema ? Object.keys(schema) : [];\n  const Never = never();\n  return new Struct({\n    type: 'object',\n    schema: schema ? schema : null,\n\n    *entries(value) {\n      if (schema && isObject(value)) {\n        const unknowns = new Set(Object.keys(value));\n\n        for (const key of knowns) {\n          unknowns.delete(key);\n          yield [key, value[key], schema[key]];\n        }\n\n        for (const key of unknowns) {\n          yield [key, value[key], Never];\n        }\n      }\n    },\n\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    },\n\n    coercer(value) {\n      return isObject(value) ? { ...value\n      } : value;\n    }\n\n  });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\n\nfunction optional(struct) {\n  return new Struct({ ...struct,\n    validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)\n  });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\n\nfunction record(Key, Value) {\n  return new Struct({\n    type: 'record',\n    schema: null,\n\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k in value) {\n          const v = value[k];\n          yield [k, k, Key];\n          yield [k, v, Value];\n        }\n      }\n    },\n\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\n\nfunction regexp() {\n  return define('regexp', value => {\n    return value instanceof RegExp;\n  });\n}\nfunction set(Element) {\n  return new Struct({\n    type: 'set',\n    schema: null,\n\n    *entries(value) {\n      if (Element && value instanceof Set) {\n        for (const v of value) {\n          yield [v, v, Element];\n        }\n      }\n    },\n\n    coercer(value) {\n      return value instanceof Set ? new Set(value) : value;\n    },\n\n    validator(value) {\n      return value instanceof Set || \"Expected a `Set` object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a string.\n */\n\nfunction string() {\n  return define('string', value => {\n    return typeof value === 'string' || \"Expected a string, but received: \" + print(value);\n  });\n}\nfunction tuple(Elements) {\n  const Never = never();\n  return new Struct({\n    type: 'tuple',\n    schema: null,\n\n    *entries(value) {\n      if (Array.isArray(value)) {\n        const length = Math.max(Elements.length, value.length);\n\n        for (let i = 0; i < length; i++) {\n          yield [i, value[i], Elements[i] || Never];\n        }\n      }\n    },\n\n    validator(value) {\n      return Array.isArray(value) || \"Expected an array, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\nfunction type(schema) {\n  const keys = Object.keys(schema);\n  return new Struct({\n    type: 'type',\n    schema,\n\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k of keys) {\n          yield [k, value[k], schema[k]];\n        }\n      }\n    },\n\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n\n  });\n}\nfunction union(Structs) {\n  const description = Structs.map(s => s.type).join(' | ');\n  return new Struct({\n    type: 'union',\n    schema: null,\n\n    validator(value, ctx) {\n      const failures = [];\n\n      for (const S of Structs) {\n        const [...tuples] = run(value, S, ctx);\n        const [first] = tuples;\n\n        if (!first[0]) {\n          return [];\n        } else {\n          for (const [failure] of tuples) {\n            if (failure) {\n              failures.push(failure);\n            }\n          }\n        }\n      }\n\n      return [\"Expected the value to satisfy a union of `\" + description + \"`, but received: \" + print(value), ...failures];\n    }\n\n  });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\nfunction unknown() {\n  return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction coerce(struct, condition, coercer) {\n  return new Struct({ ...struct,\n    coercer: (value, ctx) => {\n      return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n    }\n  });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction defaulted(struct, fallback, options = {}) {\n  return coerce(struct, unknown(), x => {\n    const f = typeof fallback === 'function' ? fallback() : fallback;\n\n    if (x === undefined) {\n      return f;\n    }\n\n    if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n      const ret = { ...x\n      };\n      let changed = false;\n\n      for (const key in f) {\n        if (ret[key] === undefined) {\n          ret[key] = f[key];\n          changed = true;\n        }\n      }\n\n      if (changed) {\n        return ret;\n      }\n    }\n\n    return x;\n  });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction trimmed(struct) {\n  return coerce(struct, string(), x => x.trim());\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\n\nfunction empty(struct) {\n  const expected = \"Expected an empty \" + struct.type;\n  return refine(struct, 'empty', value => {\n    if (value instanceof Map || value instanceof Set) {\n      const {\n        size\n      } = value;\n      return size === 0 || expected + \" but received one with a size of `\" + size + \"`\";\n    } else {\n      const {\n        length\n      } = value;\n      return length === 0 || expected + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\n\nfunction max(struct, threshold, options = {}) {\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'max', value => {\n    return exclusive ? value < threshold : value <= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\n\nfunction min(struct, threshold, options = {}) {\n  const {\n    exclusive\n  } = options;\n  return refine(struct, 'min', value => {\n    return exclusive ? value > threshold : value >= threshold || \"Expected a \" + struct.type + \" greater than \" + (exclusive ? '' : 'or equal to ') + threshold + \" but received `\" + value + \"`\";\n  });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\n\nfunction pattern(struct, regexp) {\n  return refine(struct, 'pattern', value => {\n    return regexp.test(value) || \"Expected a \" + struct.type + \" matching `/\" + regexp.source + \"/` but received \\\"\" + value + \"\\\"\";\n  });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\n\nfunction size(struct, min, max = min) {\n  const expected = \"Expected a \" + struct.type;\n  const of = min === max ? \"of `\" + min + \"`\" : \"between `\" + min + \"` and `\" + max + \"`\";\n  return refine(struct, 'size', value => {\n    if (typeof value === 'number' || value instanceof Date) {\n      return min <= value && value <= max || expected + \" \" + of + \" but received `\" + value + \"`\";\n    } else if (value instanceof Map || value instanceof Set) {\n      const {\n        size\n      } = value;\n      return min <= size && size <= max || expected + \" with a size \" + of + \" but received one with a size of `\" + size + \"`\";\n    } else {\n      const {\n        length\n      } = value;\n      return min <= length && length <= max || expected + \" with a length \" + of + \" but received one with a length of `\" + length + \"`\";\n    }\n  });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\n\nfunction refine(struct, name, refiner) {\n  return new Struct({ ...struct,\n\n    *refiner(value, ctx) {\n      yield* struct.refiner(value, ctx);\n      const result = refiner(value, ctx);\n      const failures = toFailures(result, ctx, struct, value);\n\n      for (const failure of failures) {\n        yield { ...failure,\n          refinement: name\n        };\n      }\n    }\n\n  });\n}\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9zdXBlcnN0cnVjdC9saWIvaW5kZXguZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLHNCQUFzQjtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QztBQUM5QyxJQUFJLElBQUk7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLGlDQUFpQztBQUNqQyxRQUFRO0FBQ1I7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlEO0FBQ2pEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRTJZO0FBQzNZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9zdXBlcnN0cnVjdC9saWIvaW5kZXguZXMuanM/MWQ2ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEEgYFN0cnVjdEZhaWx1cmVgIHJlcHJlc2VudHMgYSBzaW5nbGUgc3BlY2lmaWMgZmFpbHVyZSBpbiB2YWxpZGF0aW9uLlxuICovXG5cbi8qKlxuICogYFN0cnVjdEVycm9yYCBvYmplY3RzIGFyZSB0aHJvd24gKG9yIHJldHVybmVkKSB3aGVuIHZhbGlkYXRpb24gZmFpbHMuXG4gKlxuICogVmFsaWRhdGlvbiBsb2dpYyBpcyBkZXNpZ24gdG8gZXhpdCBlYXJseSBmb3IgbWF4aW11bSBwZXJmb3JtYW5jZS4gVGhlIGVycm9yXG4gKiByZXByZXNlbnRzIHRoZSBmaXJzdCBlcnJvciBlbmNvdW50ZXJlZCBkdXJpbmcgdmFsaWRhdGlvbi4gRm9yIG1vcmUgZGV0YWlsLFxuICogdGhlIGBlcnJvci5mYWlsdXJlc2AgcHJvcGVydHkgaXMgYSBnZW5lcmF0b3IgZnVuY3Rpb24gdGhhdCBjYW4gYmUgcnVuIHRvXG4gKiBjb250aW51ZSB2YWxpZGF0aW9uIGFuZCByZWNlaXZlIGFsbCB0aGUgZmFpbHVyZXMgaW4gdGhlIGRhdGEuXG4gKi9cbmNsYXNzIFN0cnVjdEVycm9yIGV4dGVuZHMgVHlwZUVycm9yIHtcbiAgY29uc3RydWN0b3IoZmFpbHVyZSwgZmFpbHVyZXMpIHtcbiAgICBsZXQgY2FjaGVkO1xuICAgIGNvbnN0IHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICAuLi5yZXN0XG4gICAgfSA9IGZhaWx1cmU7XG4gICAgY29uc3Qge1xuICAgICAgcGF0aFxuICAgIH0gPSBmYWlsdXJlO1xuICAgIGNvbnN0IG1zZyA9IHBhdGgubGVuZ3RoID09PSAwID8gbWVzc2FnZSA6IFwiQXQgcGF0aDogXCIgKyBwYXRoLmpvaW4oJy4nKSArIFwiIC0tIFwiICsgbWVzc2FnZTtcbiAgICBzdXBlcihtc2cpO1xuICAgIE9iamVjdC5hc3NpZ24odGhpcywgcmVzdCk7XG4gICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuXG4gICAgdGhpcy5mYWlsdXJlcyA9ICgpID0+IHtcbiAgICAgIHZhciBfY2FjaGVkO1xuXG4gICAgICByZXR1cm4gKF9jYWNoZWQgPSBjYWNoZWQpICE9IG51bGwgPyBfY2FjaGVkIDogY2FjaGVkID0gW2ZhaWx1cmUsIC4uLmZhaWx1cmVzKCldO1xuICAgIH07XG4gIH1cblxufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gaXRlcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIGlzSXRlcmFibGUoeCkge1xuICByZXR1cm4gaXNPYmplY3QoeCkgJiYgdHlwZW9mIHhbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIG9iamVjdC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGlzT2JqZWN0KHgpIHtcbiAgcmV0dXJuIHR5cGVvZiB4ID09PSAnb2JqZWN0JyAmJiB4ICE9IG51bGw7XG59XG4vKipcbiAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBvYmplY3QuXG4gKi9cblxuZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh4KSB7XG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeCkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgY29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHgpO1xuICByZXR1cm4gcHJvdG90eXBlID09PSBudWxsIHx8IHByb3RvdHlwZSA9PT0gT2JqZWN0LnByb3RvdHlwZTtcbn1cbi8qKlxuICogUmV0dXJuIGEgdmFsdWUgYXMgYSBwcmludGFibGUgc3RyaW5nLlxuICovXG5cbmZ1bmN0aW9uIHByaW50KHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gSlNPTi5zdHJpbmdpZnkodmFsdWUpIDogXCJcIiArIHZhbHVlO1xufVxuLyoqXG4gKiBTaGlmdHMgKHJlbW92ZXMgYW5kIHJldHVybnMpIHRoZSBmaXJzdCB2YWx1ZSBmcm9tIHRoZSBgaW5wdXRgIGl0ZXJhdG9yLlxuICogTGlrZSBgQXJyYXkucHJvdG90eXBlLnNoaWZ0KClgIGJ1dCBmb3IgYW4gYEl0ZXJhdG9yYC5cbiAqL1xuXG5mdW5jdGlvbiBzaGlmdEl0ZXJhdG9yKGlucHV0KSB7XG4gIGNvbnN0IHtcbiAgICBkb25lLFxuICAgIHZhbHVlXG4gIH0gPSBpbnB1dC5uZXh0KCk7XG4gIHJldHVybiBkb25lID8gdW5kZWZpbmVkIDogdmFsdWU7XG59XG4vKipcbiAqIENvbnZlcnQgYSBzaW5nbGUgdmFsaWRhdGlvbiByZXN1bHQgdG8gYSBmYWlsdXJlLlxuICovXG5cbmZ1bmN0aW9uIHRvRmFpbHVyZShyZXN1bHQsIGNvbnRleHQsIHN0cnVjdCwgdmFsdWUpIHtcbiAgaWYgKHJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgcmVzdWx0ID0ge307XG4gIH0gZWxzZSBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ3N0cmluZycpIHtcbiAgICByZXN1bHQgPSB7XG4gICAgICBtZXNzYWdlOiByZXN1bHRcbiAgICB9O1xuICB9XG5cbiAgY29uc3Qge1xuICAgIHBhdGgsXG4gICAgYnJhbmNoXG4gIH0gPSBjb250ZXh0O1xuICBjb25zdCB7XG4gICAgdHlwZVxuICB9ID0gc3RydWN0O1xuICBjb25zdCB7XG4gICAgcmVmaW5lbWVudCxcbiAgICBtZXNzYWdlID0gXCJFeHBlY3RlZCBhIHZhbHVlIG9mIHR5cGUgYFwiICsgdHlwZSArIFwiYFwiICsgKHJlZmluZW1lbnQgPyBcIiB3aXRoIHJlZmluZW1lbnQgYFwiICsgcmVmaW5lbWVudCArIFwiYFwiIDogJycpICsgXCIsIGJ1dCByZWNlaXZlZDogYFwiICsgcHJpbnQodmFsdWUpICsgXCJgXCJcbiAgfSA9IHJlc3VsdDtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZSxcbiAgICB0eXBlLFxuICAgIHJlZmluZW1lbnQsXG4gICAga2V5OiBwYXRoW3BhdGgubGVuZ3RoIC0gMV0sXG4gICAgcGF0aCxcbiAgICBicmFuY2gsXG4gICAgLi4ucmVzdWx0LFxuICAgIG1lc3NhZ2VcbiAgfTtcbn1cbi8qKlxuICogQ29udmVydCBhIHZhbGlkYXRpb24gcmVzdWx0IHRvIGFuIGl0ZXJhYmxlIG9mIGZhaWx1cmVzLlxuICovXG5cbmZ1bmN0aW9uKiB0b0ZhaWx1cmVzKHJlc3VsdCwgY29udGV4dCwgc3RydWN0LCB2YWx1ZSkge1xuICBpZiAoIWlzSXRlcmFibGUocmVzdWx0KSkge1xuICAgIHJlc3VsdCA9IFtyZXN1bHRdO1xuICB9XG5cbiAgZm9yIChjb25zdCByIG9mIHJlc3VsdCkge1xuICAgIGNvbnN0IGZhaWx1cmUgPSB0b0ZhaWx1cmUociwgY29udGV4dCwgc3RydWN0LCB2YWx1ZSk7XG5cbiAgICBpZiAoZmFpbHVyZSkge1xuICAgICAgeWllbGQgZmFpbHVyZTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogQ2hlY2sgYSB2YWx1ZSBhZ2FpbnN0IGEgc3RydWN0LCB0cmF2ZXJzaW5nIGRlZXBseSBpbnRvIG5lc3RlZCB2YWx1ZXMsIGFuZFxuICogcmV0dXJuaW5nIGFuIGl0ZXJhdG9yIG9mIGZhaWx1cmVzIG9yIHN1Y2Nlc3MuXG4gKi9cblxuZnVuY3Rpb24qIHJ1bih2YWx1ZSwgc3RydWN0LCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHBhdGggPSBbXSxcbiAgICBicmFuY2ggPSBbdmFsdWVdLFxuICAgIGNvZXJjZSA9IGZhbHNlLFxuICAgIG1hc2sgPSBmYWxzZVxuICB9ID0gb3B0aW9ucztcbiAgY29uc3QgY3R4ID0ge1xuICAgIHBhdGgsXG4gICAgYnJhbmNoXG4gIH07XG5cbiAgaWYgKGNvZXJjZSkge1xuICAgIHZhbHVlID0gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG5cbiAgICBpZiAobWFzayAmJiBzdHJ1Y3QudHlwZSAhPT0gJ3R5cGUnICYmIGlzT2JqZWN0KHN0cnVjdC5zY2hlbWEpICYmIGlzT2JqZWN0KHZhbHVlKSAmJiAhQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlKSB7XG4gICAgICAgIGlmIChzdHJ1Y3Quc2NoZW1hW2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbGV0IHZhbGlkID0gdHJ1ZTtcblxuICBmb3IgKGNvbnN0IGZhaWx1cmUgb2Ygc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KSkge1xuICAgIHZhbGlkID0gZmFsc2U7XG4gICAgeWllbGQgW2ZhaWx1cmUsIHVuZGVmaW5lZF07XG4gIH1cblxuICBmb3IgKGxldCBbaywgdiwgc10gb2Ygc3RydWN0LmVudHJpZXModmFsdWUsIGN0eCkpIHtcbiAgICBjb25zdCB0cyA9IHJ1bih2LCBzLCB7XG4gICAgICBwYXRoOiBrID09PSB1bmRlZmluZWQgPyBwYXRoIDogWy4uLnBhdGgsIGtdLFxuICAgICAgYnJhbmNoOiBrID09PSB1bmRlZmluZWQgPyBicmFuY2ggOiBbLi4uYnJhbmNoLCB2XSxcbiAgICAgIGNvZXJjZSxcbiAgICAgIG1hc2tcbiAgICB9KTtcblxuICAgIGZvciAoY29uc3QgdCBvZiB0cykge1xuICAgICAgaWYgKHRbMF0pIHtcbiAgICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgICAgeWllbGQgW3RbMF0sIHVuZGVmaW5lZF07XG4gICAgICB9IGVsc2UgaWYgKGNvZXJjZSkge1xuICAgICAgICB2ID0gdFsxXTtcblxuICAgICAgICBpZiAoayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFsdWUgPSB2O1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgdmFsdWUuc2V0KGssIHYpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgICAgdmFsdWUuYWRkKHYpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICh2YWxpZCkge1xuICAgIGZvciAoY29uc3QgZmFpbHVyZSBvZiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSkge1xuICAgICAgdmFsaWQgPSBmYWxzZTtcbiAgICAgIHlpZWxkIFtmYWlsdXJlLCB1bmRlZmluZWRdO1xuICAgIH1cbiAgfVxuXG4gIGlmICh2YWxpZCkge1xuICAgIHlpZWxkIFt1bmRlZmluZWQsIHZhbHVlXTtcbiAgfVxufVxuXG4vKipcbiAqIGBTdHJ1Y3RgIG9iamVjdHMgZW5jYXBzdWxhdGUgdGhlIHZhbGlkYXRpb24gbG9naWMgZm9yIGEgc3BlY2lmaWMgdHlwZSBvZlxuICogdmFsdWVzLiBPbmNlIGNvbnN0cnVjdGVkLCB5b3UgdXNlIHRoZSBgYXNzZXJ0YCwgYGlzYCBvciBgdmFsaWRhdGVgIGhlbHBlcnMgdG9cbiAqIHZhbGlkYXRlIHVua25vd24gaW5wdXQgZGF0YSBhZ2FpbnN0IHRoZSBzdHJ1Y3QuXG4gKi9cblxuY2xhc3MgU3RydWN0IHtcbiAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlLFxuICAgICAgc2NoZW1hLFxuICAgICAgdmFsaWRhdG9yLFxuICAgICAgcmVmaW5lcixcbiAgICAgIGNvZXJjZXIgPSB2YWx1ZSA9PiB2YWx1ZSxcbiAgICAgIGVudHJpZXMgPSBmdW5jdGlvbiogKCkge31cbiAgICB9ID0gcHJvcHM7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICB0aGlzLmVudHJpZXMgPSBlbnRyaWVzO1xuICAgIHRoaXMuY29lcmNlciA9IGNvZXJjZXI7XG5cbiAgICBpZiAodmFsaWRhdG9yKSB7XG4gICAgICB0aGlzLnZhbGlkYXRvciA9ICh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB2YWxpZGF0b3IodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICByZXR1cm4gdG9GYWlsdXJlcyhyZXN1bHQsIGNvbnRleHQsIHRoaXMsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsaWRhdG9yID0gKCkgPT4gW107XG4gICAgfVxuXG4gICAgaWYgKHJlZmluZXIpIHtcbiAgICAgIHRoaXMucmVmaW5lciA9ICh2YWx1ZSwgY29udGV4dCkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSByZWZpbmVyKHZhbHVlLCBjb250ZXh0KTtcbiAgICAgICAgcmV0dXJuIHRvRmFpbHVyZXMocmVzdWx0LCBjb250ZXh0LCB0aGlzLCB2YWx1ZSk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJlZmluZXIgPSAoKSA9PiBbXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEFzc2VydCB0aGF0IGEgdmFsdWUgcGFzc2VzIHRoZSBzdHJ1Y3QncyB2YWxpZGF0aW9uLCB0aHJvd2luZyBpZiBpdCBkb2Vzbid0LlxuICAgKi9cblxuXG4gIGFzc2VydCh2YWx1ZSkge1xuICAgIHJldHVybiBhc3NlcnQodmFsdWUsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSB2YWx1ZSB3aXRoIHRoZSBzdHJ1Y3QncyBjb2VyY2lvbiBsb2dpYywgdGhlbiB2YWxpZGF0ZSBpdC5cbiAgICovXG5cblxuICBjcmVhdGUodmFsdWUpIHtcbiAgICByZXR1cm4gY3JlYXRlKHZhbHVlLCB0aGlzKTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBwYXNzZXMgdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24uXG4gICAqL1xuXG5cbiAgaXModmFsdWUpIHtcbiAgICByZXR1cm4gaXModmFsdWUsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBNYXNrIGEgdmFsdWUsIGNvZXJjaW5nIGFuZCB2YWxpZGF0aW5nIGl0LCBidXQgcmV0dXJuaW5nIG9ubHkgdGhlIHN1YnNldCBvZlxuICAgKiBwcm9wZXJ0aWVzIGRlZmluZWQgYnkgdGhlIHN0cnVjdCdzIHNjaGVtYS5cbiAgICovXG5cblxuICBtYXNrKHZhbHVlKSB7XG4gICAgcmV0dXJuIG1hc2sodmFsdWUsIHRoaXMpO1xuICB9XG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBhIHZhbHVlIHdpdGggdGhlIHN0cnVjdCdzIHZhbGlkYXRpb24gbG9naWMsIHJldHVybmluZyBhIHR1cGxlXG4gICAqIHJlcHJlc2VudGluZyB0aGUgcmVzdWx0LlxuICAgKlxuICAgKiBZb3UgbWF5IG9wdGlvbmFsbHkgcGFzcyBgdHJ1ZWAgZm9yIHRoZSBgd2l0aENvZXJjaW9uYCBhcmd1bWVudCB0byBjb2VyY2VcbiAgICogdGhlIHZhbHVlIGJlZm9yZSBhdHRlbXB0aW5nIHRvIHZhbGlkYXRlIGl0LiBJZiB5b3UgZG8sIHRoZSByZXN1bHQgd2lsbFxuICAgKiBjb250YWluIHRoZSBjb2VyY2VkIHJlc3VsdCB3aGVuIHN1Y2Nlc3NmdWwuXG4gICAqL1xuXG5cbiAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB2YWxpZGF0ZSh2YWx1ZSwgdGhpcywgb3B0aW9ucyk7XG4gIH1cblxufVxuLyoqXG4gKiBBc3NlcnQgdGhhdCBhIHZhbHVlIHBhc3NlcyBhIHN0cnVjdCwgdGhyb3dpbmcgaWYgaXQgZG9lc24ndC5cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnQodmFsdWUsIHN0cnVjdCkge1xuICBjb25zdCByZXN1bHQgPSB2YWxpZGF0ZSh2YWx1ZSwgc3RydWN0KTtcblxuICBpZiAocmVzdWx0WzBdKSB7XG4gICAgdGhyb3cgcmVzdWx0WzBdO1xuICB9XG59XG4vKipcbiAqIENyZWF0ZSBhIHZhbHVlIHdpdGggdGhlIGNvZXJjaW9uIGxvZ2ljIG9mIHN0cnVjdCBhbmQgdmFsaWRhdGUgaXQuXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlKHZhbHVlLCBzdHJ1Y3QpIHtcbiAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwge1xuICAgIGNvZXJjZTogdHJ1ZVxuICB9KTtcblxuICBpZiAocmVzdWx0WzBdKSB7XG4gICAgdGhyb3cgcmVzdWx0WzBdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXN1bHRbMV07XG4gIH1cbn1cbi8qKlxuICogTWFzayBhIHZhbHVlLCByZXR1cm5pbmcgb25seSB0aGUgc3Vic2V0IG9mIHByb3BlcnRpZXMgZGVmaW5lZCBieSBhIHN0cnVjdC5cbiAqL1xuXG5mdW5jdGlvbiBtYXNrKHZhbHVlLCBzdHJ1Y3QpIHtcbiAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdGUodmFsdWUsIHN0cnVjdCwge1xuICAgIGNvZXJjZTogdHJ1ZSxcbiAgICBtYXNrOiB0cnVlXG4gIH0pO1xuXG4gIGlmIChyZXN1bHRbMF0pIHtcbiAgICB0aHJvdyByZXN1bHRbMF07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHJlc3VsdFsxXTtcbiAgfVxufVxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIHBhc3NlcyBhIHN0cnVjdC5cbiAqL1xuXG5mdW5jdGlvbiBpcyh2YWx1ZSwgc3RydWN0KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QpO1xuICByZXR1cm4gIXJlc3VsdFswXTtcbn1cbi8qKlxuICogVmFsaWRhdGUgYSB2YWx1ZSBhZ2FpbnN0IGEgc3RydWN0LCByZXR1cm5pbmcgYW4gZXJyb3IgaWYgaW52YWxpZCwgb3IgdGhlXG4gKiB2YWx1ZSAod2l0aCBwb3RlbnRpYWwgY29lcmNpb24pIGlmIHZhbGlkLlxuICovXG5cbmZ1bmN0aW9uIHZhbGlkYXRlKHZhbHVlLCBzdHJ1Y3QsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB0dXBsZXMgPSBydW4odmFsdWUsIHN0cnVjdCwgb3B0aW9ucyk7XG4gIGNvbnN0IHR1cGxlID0gc2hpZnRJdGVyYXRvcih0dXBsZXMpO1xuXG4gIGlmICh0dXBsZVswXSkge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IFN0cnVjdEVycm9yKHR1cGxlWzBdLCBmdW5jdGlvbiogKCkge1xuICAgICAgZm9yIChjb25zdCB0IG9mIHR1cGxlcykge1xuICAgICAgICBpZiAodFswXSkge1xuICAgICAgICAgIHlpZWxkIHRbMF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gW2Vycm9yLCB1bmRlZmluZWRdO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHYgPSB0dXBsZVsxXTtcbiAgICByZXR1cm4gW3VuZGVmaW5lZCwgdl07XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduKC4uLlN0cnVjdHMpIHtcbiAgY29uc3Qgc2NoZW1hcyA9IFN0cnVjdHMubWFwKHMgPT4gcy5zY2hlbWEpO1xuICBjb25zdCBzY2hlbWEgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5zY2hlbWFzKTtcbiAgcmV0dXJuIG9iamVjdChzY2hlbWEpO1xufVxuLyoqXG4gKiBEZWZpbmUgYSBuZXcgc3RydWN0IHR5cGUgd2l0aCBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uLlxuICovXG5cbmZ1bmN0aW9uIGRlZmluZShuYW1lLCB2YWxpZGF0b3IpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6IG5hbWUsXG4gICAgc2NoZW1hOiBudWxsLFxuICAgIHZhbGlkYXRvclxuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBzdHJ1Y3QsIGJ1dCB0aGUgdmFsdWUgaXMgYWxsb3dlZCB0b1xuICogYmUgYHVuZGVmaW5lZGAuIGBsb2dgIHdpbGwgYmUgY2FsbGVkIGlmIHRoZSB2YWx1ZSBpcyBub3QgYHVuZGVmaW5lZGAuXG4gKi9cblxuZnVuY3Rpb24gZGVwcmVjYXRlZChzdHJ1Y3QsIGxvZykge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7IC4uLnN0cnVjdCxcbiAgICByZWZpbmVyOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxvZyh2YWx1ZSwgY3R4KTtcbiAgICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgICB9XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBzdHJ1Y3Qgd2l0aCBkeW5hbWljIHZhbGlkYXRpb24gbG9naWMuXG4gKlxuICogVGhlIGNhbGxiYWNrIHdpbGwgcmVjZWl2ZSB0aGUgdmFsdWUgY3VycmVudGx5IGJlaW5nIHZhbGlkYXRlZCwgYW5kIG11c3RcbiAqIHJldHVybiBhIHN0cnVjdCBvYmplY3QgdG8gdmFsaWRhdGUgaXQgd2l0aC4gVGhpcyBjYW4gYmUgdXNlZnVsIHRvIG1vZGVsXG4gKiB2YWxpZGF0aW9uIGxvZ2ljIHRoYXQgY2hhbmdlcyBiYXNlZCBvbiBpdHMgaW5wdXQuXG4gKi9cblxuZnVuY3Rpb24gZHluYW1pYyhmbikge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2R5bmFtaWMnLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgICplbnRyaWVzKHZhbHVlLCBjdHgpIHtcbiAgICAgIGNvbnN0IHN0cnVjdCA9IGZuKHZhbHVlLCBjdHgpO1xuICAgICAgeWllbGQqIHN0cnVjdC5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUsIGN0eCkge1xuICAgICAgY29uc3Qgc3RydWN0ID0gZm4odmFsdWUsIGN0eCk7XG4gICAgICByZXR1cm4gc3RydWN0LnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICB9LFxuXG4gICAgY29lcmNlcih2YWx1ZSwgY3R4KSB7XG4gICAgICBjb25zdCBzdHJ1Y3QgPSBmbih2YWx1ZSwgY3R4KTtcbiAgICAgIHJldHVybiBzdHJ1Y3QuY29lcmNlcih2YWx1ZSwgY3R4KTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHN0cnVjdCB3aXRoIGxhemlseSBldmFsdWF0ZWQgdmFsaWRhdGlvbiBsb2dpYy5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB2YWxpZGF0aW9uIGlzIHJ1biB3aXRoIHRoZSBzdHJ1Y3QsIHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZFxuICogYW5kIG11c3QgcmV0dXJuIGEgc3RydWN0IG9iamVjdCB0byB1c2UuIFRoaXMgaXMgdXNlZnVsIGZvciBjYXNlcyB3aGVyZSB5b3VcbiAqIHdhbnQgdG8gaGF2ZSBzZWxmLXJlZmVyZW50aWFsIHN0cnVjdHMgZm9yIG5lc3RlZCBkYXRhIHN0cnVjdHVyZXMgdG8gYXZvaWQgYVxuICogY2lyY3VsYXIgZGVmaW5pdGlvbiBwcm9ibGVtLlxuICovXG5cbmZ1bmN0aW9uIGxhenkoZm4pIHtcbiAgbGV0IHN0cnVjdDtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdsYXp5JyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICB2YXIgX3N0cnVjdDtcblxuICAgICAgKF9zdHJ1Y3QgPSBzdHJ1Y3QpICE9IG51bGwgPyBfc3RydWN0IDogc3RydWN0ID0gZm4oKTtcbiAgICAgIHlpZWxkKiBzdHJ1Y3QuZW50cmllcyh2YWx1ZSwgY3R4KTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgIHZhciBfc3RydWN0MjtcblxuICAgICAgKF9zdHJ1Y3QyID0gc3RydWN0KSAhPSBudWxsID8gX3N0cnVjdDIgOiBzdHJ1Y3QgPSBmbigpO1xuICAgICAgcmV0dXJuIHN0cnVjdC52YWxpZGF0b3IodmFsdWUsIGN0eCk7XG4gICAgfSxcblxuICAgIGNvZXJjZXIodmFsdWUsIGN0eCkge1xuICAgICAgdmFyIF9zdHJ1Y3QzO1xuXG4gICAgICAoX3N0cnVjdDMgPSBzdHJ1Y3QpICE9IG51bGwgPyBfc3RydWN0MyA6IHN0cnVjdCA9IGZuKCk7XG4gICAgICByZXR1cm4gc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgc3RydWN0IGJhc2VkIG9uIGFuIGV4aXN0aW5nIG9iamVjdCBzdHJ1Y3QsIGJ1dCBleGNsdWRpbmdcbiAqIHNwZWNpZmljIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYE9taXRgIHV0aWxpdHkuXG4gKi9cblxuZnVuY3Rpb24gb21pdChzdHJ1Y3QsIGtleXMpIHtcbiAgY29uc3Qge1xuICAgIHNjaGVtYVxuICB9ID0gc3RydWN0O1xuICBjb25zdCBzdWJzY2hlbWEgPSB7IC4uLnNjaGVtYVxuICB9O1xuXG4gIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICBkZWxldGUgc3Vic2NoZW1hW2tleV07XG4gIH1cblxuICByZXR1cm4gb2JqZWN0KHN1YnNjaGVtYSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBzdHJ1Y3QgYmFzZWQgb24gYW4gZXhpc3Rpbmcgb2JqZWN0IHN0cnVjdCwgYnV0IHdpdGggYWxsIG9mIGl0c1xuICogcHJvcGVydGllcyBhbGxvd2VkIHRvIGJlIGB1bmRlZmluZWRgLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBQYXJ0aWFsYCB1dGlsaXR5LlxuICovXG5cbmZ1bmN0aW9uIHBhcnRpYWwoc3RydWN0KSB7XG4gIGNvbnN0IHNjaGVtYSA9IHN0cnVjdCBpbnN0YW5jZW9mIFN0cnVjdCA/IHsgLi4uc3RydWN0LnNjaGVtYVxuICB9IDogeyAuLi5zdHJ1Y3RcbiAgfTtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBzY2hlbWEpIHtcbiAgICBzY2hlbWFba2V5XSA9IG9wdGlvbmFsKHNjaGVtYVtrZXldKTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Qoc2NoZW1hKTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHN0cnVjdCBiYXNlZCBvbiBhbiBleGlzdGluZyBvYmplY3Qgc3RydWN0LCBidXQgb25seSBpbmNsdWRpbmdcbiAqIHNwZWNpZmljIHByb3BlcnRpZXMuXG4gKlxuICogTGlrZSBUeXBlU2NyaXB0J3MgYFBpY2tgIHV0aWxpdHkuXG4gKi9cblxuZnVuY3Rpb24gcGljayhzdHJ1Y3QsIGtleXMpIHtcbiAgY29uc3Qge1xuICAgIHNjaGVtYVxuICB9ID0gc3RydWN0O1xuICBjb25zdCBzdWJzY2hlbWEgPSB7fTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgc3Vic2NoZW1hW2tleV0gPSBzY2hlbWFba2V5XTtcbiAgfVxuXG4gIHJldHVybiBvYmplY3Qoc3Vic2NoZW1hKTtcbn1cbi8qKlxuICogRGVmaW5lIGEgbmV3IHN0cnVjdCB0eXBlIHdpdGggYSBjdXN0b20gdmFsaWRhdGlvbiBmdW5jdGlvbi5cbiAqXG4gKiBAZGVwcmVjYXRlZCBUaGlzIGZ1bmN0aW9uIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGRlZmluZWAuXG4gKi9cblxuZnVuY3Rpb24gc3RydWN0KG5hbWUsIHZhbGlkYXRvcikge1xuICBjb25zb2xlLndhcm4oJ3N1cGVyc3RydWN0QDAuMTEgLSBUaGUgYHN0cnVjdGAgaGVscGVyIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGRlZmluZWAuJyk7XG4gIHJldHVybiBkZWZpbmUobmFtZSwgdmFsaWRhdG9yKTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhbnkgdmFsdWUgcGFzc2VzIHZhbGlkYXRpb24uXG4gKi9cblxuZnVuY3Rpb24gYW55KCkge1xuICByZXR1cm4gZGVmaW5lKCdhbnknLCAoKSA9PiB0cnVlKTtcbn1cbmZ1bmN0aW9uIGFycmF5KEVsZW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdhcnJheScsXG4gICAgc2NoZW1hOiBFbGVtZW50LFxuXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChFbGVtZW50ICYmIEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2ksIHZdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgIHlpZWxkIFtpLCB2LCBFbGVtZW50XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICBjb2VyY2VyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5zbGljZSgpIDogdmFsdWU7XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpIHx8IFwiRXhwZWN0ZWQgYW4gYXJyYXkgdmFsdWUsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgYm9vbGVhbi5cbiAqL1xuXG5mdW5jdGlvbiBib29sZWFuKCkge1xuICByZXR1cm4gZGVmaW5lKCdib29sZWFuJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJztcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSB2YWxpZCBgRGF0ZWAuXG4gKlxuICogTm90ZTogdGhpcyBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgdmFsdWUgaXMgKm5vdCogYW4gaW52YWxpZCBgRGF0ZWAgb2JqZWN0LFxuICogd2hpY2ggY2FuIG9jY3VyIHdoZW4gcGFyc2luZyBhIGRhdGUgZmFpbHMgYnV0IHN0aWxsIHJldHVybnMgYSBgRGF0ZWAuXG4gKi9cblxuZnVuY3Rpb24gZGF0ZSgpIHtcbiAgcmV0dXJuIGRlZmluZSgnZGF0ZScsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlICYmICFpc05hTih2YWx1ZS5nZXRUaW1lKCkpIHx8IFwiRXhwZWN0ZWQgYSB2YWxpZCBgRGF0ZWAgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGVudW1zKHZhbHVlcykge1xuICBjb25zdCBzY2hlbWEgPSB7fTtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSB2YWx1ZXMubWFwKHYgPT4gcHJpbnQodikpLmpvaW4oKTtcblxuICBmb3IgKGNvbnN0IGtleSBvZiB2YWx1ZXMpIHtcbiAgICBzY2hlbWFba2V5XSA9IGtleTtcbiAgfVxuXG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnZW51bXMnLFxuICAgIHNjaGVtYSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlcy5pbmNsdWRlcyh2YWx1ZSkgfHwgXCJFeHBlY3RlZCBvbmUgb2YgYFwiICsgZGVzY3JpcHRpb24gKyBcImAsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGEgZnVuY3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gZnVuYygpIHtcbiAgcmV0dXJuIGRlZmluZSgnZnVuYycsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nIHx8IFwiRXhwZWN0ZWQgYSBmdW5jdGlvbiwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gaW5zdGFuY2Ugb2YgYSBzcGVjaWZpYyBjbGFzcy5cbiAqL1xuXG5mdW5jdGlvbiBpbnN0YW5jZShDbGFzcykge1xuICByZXR1cm4gZGVmaW5lKCdpbnN0YW5jZScsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBDbGFzcyB8fCBcIkV4cGVjdGVkIGEgYFwiICsgQ2xhc3MubmFtZSArIFwiYCBpbnN0YW5jZSwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYW4gaW50ZWdlci5cbiAqL1xuXG5mdW5jdGlvbiBpbnRlZ2VyKCkge1xuICByZXR1cm4gZGVmaW5lKCdpbnRlZ2VyJywgdmFsdWUgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmICFpc05hTih2YWx1ZSkgJiYgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgfHwgXCJFeHBlY3RlZCBhbiBpbnRlZ2VyLCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdGlvbihTdHJ1Y3RzKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAnaW50ZXJzZWN0aW9uJyxcbiAgICBzY2hlbWE6IG51bGwsXG5cbiAgICAqZW50cmllcyh2YWx1ZSwgY3R4KSB7XG4gICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICB5aWVsZCogUy5lbnRyaWVzKHZhbHVlLCBjdHgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAqdmFsaWRhdG9yKHZhbHVlLCBjdHgpIHtcbiAgICAgIGZvciAoY29uc3QgUyBvZiBTdHJ1Y3RzKSB7XG4gICAgICAgIHlpZWxkKiBTLnZhbGlkYXRvcih2YWx1ZSwgY3R4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgKnJlZmluZXIodmFsdWUsIGN0eCkge1xuICAgICAgZm9yIChjb25zdCBTIG9mIFN0cnVjdHMpIHtcbiAgICAgICAgeWllbGQqIFMucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7XG59XG5mdW5jdGlvbiBsaXRlcmFsKGNvbnN0YW50KSB7XG4gIGNvbnN0IGRlc2NyaXB0aW9uID0gcHJpbnQoY29uc3RhbnQpO1xuICBjb25zdCB0ID0gdHlwZW9mIGNvbnN0YW50O1xuICByZXR1cm4gbmV3IFN0cnVjdCh7XG4gICAgdHlwZTogJ2xpdGVyYWwnLFxuICAgIHNjaGVtYTogdCA9PT0gJ3N0cmluZycgfHwgdCA9PT0gJ251bWJlcicgfHwgdCA9PT0gJ2Jvb2xlYW4nID8gY29uc3RhbnQgOiBudWxsLFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IGNvbnN0YW50IHx8IFwiRXhwZWN0ZWQgdGhlIGxpdGVyYWwgYFwiICsgZGVzY3JpcHRpb24gKyBcImAsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfVxuXG4gIH0pO1xufVxuZnVuY3Rpb24gbWFwKEtleSwgVmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdtYXAnLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoS2V5ICYmIFZhbHVlICYmIHZhbHVlIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgIHlpZWxkIFtrLCBrLCBLZXldO1xuICAgICAgICAgIHlpZWxkIFtrLCB2LCBWYWx1ZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgTWFwID8gbmV3IE1hcCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBNYXAgfHwgXCJFeHBlY3RlZCBhIGBNYXBgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IG5vIHZhbHVlIGV2ZXIgcGFzc2VzIHZhbGlkYXRpb24uXG4gKi9cblxuZnVuY3Rpb24gbmV2ZXIoKSB7XG4gIHJldHVybiBkZWZpbmUoJ25ldmVyJywgKCkgPT4gZmFsc2UpO1xufVxuLyoqXG4gKiBBdWdtZW50IGFuIGV4aXN0aW5nIHN0cnVjdCB0byBhbGxvdyBgbnVsbGAgdmFsdWVzLlxuICovXG5cbmZ1bmN0aW9uIG51bGxhYmxlKHN0cnVjdCkge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7IC4uLnN0cnVjdCxcbiAgICB2YWxpZGF0b3I6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gbnVsbCB8fCBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KVxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBpcyBhIG51bWJlci5cbiAqL1xuXG5mdW5jdGlvbiBudW1iZXIoKSB7XG4gIHJldHVybiBkZWZpbmUoJ251bWJlcicsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiAhaXNOYU4odmFsdWUpIHx8IFwiRXhwZWN0ZWQgYSBudW1iZXIsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gb2JqZWN0KHNjaGVtYSkge1xuICBjb25zdCBrbm93bnMgPSBzY2hlbWEgPyBPYmplY3Qua2V5cyhzY2hlbWEpIDogW107XG4gIGNvbnN0IE5ldmVyID0gbmV2ZXIoKTtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdvYmplY3QnLFxuICAgIHNjaGVtYTogc2NoZW1hID8gc2NoZW1hIDogbnVsbCxcblxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoc2NoZW1hICYmIGlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICBjb25zdCB1bmtub3ducyA9IG5ldyBTZXQoT2JqZWN0LmtleXModmFsdWUpKTtcblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrbm93bnMpIHtcbiAgICAgICAgICB1bmtub3ducy5kZWxldGUoa2V5KTtcbiAgICAgICAgICB5aWVsZCBba2V5LCB2YWx1ZVtrZXldLCBzY2hlbWFba2V5XV07XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiB1bmtub3ducykge1xuICAgICAgICAgIHlpZWxkIFtrZXksIHZhbHVlW2tleV0sIE5ldmVyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgfHwgXCJFeHBlY3RlZCBhbiBvYmplY3QsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSk7XG4gICAgfSxcblxuICAgIGNvZXJjZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdCh2YWx1ZSkgPyB7IC4uLnZhbHVlXG4gICAgICB9IDogdmFsdWU7XG4gICAgfVxuXG4gIH0pO1xufVxuLyoqXG4gKiBBdWdtZW50IGEgc3RydWN0IHRvIGFsbG93IGB1bmRlZmluZWRgIHZhbHVlcy5cbiAqL1xuXG5mdW5jdGlvbiBvcHRpb25hbChzdHJ1Y3QpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3QoeyAuLi5zdHJ1Y3QsXG4gICAgdmFsaWRhdG9yOiAodmFsdWUsIGN0eCkgPT4gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCBzdHJ1Y3QudmFsaWRhdG9yKHZhbHVlLCBjdHgpLFxuICAgIHJlZmluZXI6ICh2YWx1ZSwgY3R4KSA9PiB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHN0cnVjdC5yZWZpbmVyKHZhbHVlLCBjdHgpXG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIHZhbHVlIGlzIGFuIG9iamVjdCB3aXRoIGtleXMgYW5kIHZhbHVlcyBvZiBzcGVjaWZpYyB0eXBlcywgYnV0XG4gKiB3aXRob3V0IGVuc3VyaW5nIGFueSBzcGVjaWZpYyBzaGFwZSBvZiBwcm9wZXJ0aWVzLlxuICpcbiAqIExpa2UgVHlwZVNjcmlwdCdzIGBSZWNvcmRgIHV0aWxpdHkuXG4gKi9cblxuZnVuY3Rpb24gcmVjb3JkKEtleSwgVmFsdWUpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdyZWNvcmQnLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIGZvciAoY29uc3QgayBpbiB2YWx1ZSkge1xuICAgICAgICAgIGNvbnN0IHYgPSB2YWx1ZVtrXTtcbiAgICAgICAgICB5aWVsZCBbaywgaywgS2V5XTtcbiAgICAgICAgICB5aWVsZCBbaywgdiwgVmFsdWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSB8fCBcIkV4cGVjdGVkIGFuIG9iamVjdCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBgUmVnRXhwYC5cbiAqXG4gKiBOb3RlOiB0aGlzIGRvZXMgbm90IHRlc3QgdGhlIHZhbHVlIGFnYWluc3QgdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiEgRm9yIHRoYXRcbiAqIHlvdSBuZWVkIHRvIHVzZSB0aGUgYHBhdHRlcm4oKWAgcmVmaW5lbWVudC5cbiAqL1xuXG5mdW5jdGlvbiByZWdleHAoKSB7XG4gIHJldHVybiBkZWZpbmUoJ3JlZ2V4cCcsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBSZWdFeHA7XG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0KEVsZW1lbnQpIHtcbiAgcmV0dXJuIG5ldyBTdHJ1Y3Qoe1xuICAgIHR5cGU6ICdzZXQnLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoRWxlbWVudCAmJiB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgdmFsdWUpIHtcbiAgICAgICAgICB5aWVsZCBbdiwgdiwgRWxlbWVudF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY29lcmNlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgU2V0ID8gbmV3IFNldCh2YWx1ZSkgOiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBTZXQgfHwgXCJFeHBlY3RlZCBhIGBTZXRgIG9iamVjdCwgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgdmFsdWUgaXMgYSBzdHJpbmcuXG4gKi9cblxuZnVuY3Rpb24gc3RyaW5nKCkge1xuICByZXR1cm4gZGVmaW5lKCdzdHJpbmcnLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgXCJFeHBlY3RlZCBhIHN0cmluZywgYnV0IHJlY2VpdmVkOiBcIiArIHByaW50KHZhbHVlKTtcbiAgfSk7XG59XG5mdW5jdGlvbiB0dXBsZShFbGVtZW50cykge1xuICBjb25zdCBOZXZlciA9IG5ldmVyKCk7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAndHVwbGUnLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgICplbnRyaWVzKHZhbHVlKSB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gTWF0aC5tYXgoRWxlbWVudHMubGVuZ3RoLCB2YWx1ZS5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB5aWVsZCBbaSwgdmFsdWVbaV0sIEVsZW1lbnRzW2ldIHx8IE5ldmVyXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICB2YWxpZGF0b3IodmFsdWUpIHtcbiAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSB8fCBcIkV4cGVjdGVkIGFuIGFycmF5LCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSB2YWx1ZSBoYXMgYSBzZXQgb2Yga25vd24gcHJvcGVydGllcyBvZiBzcGVjaWZpYyB0eXBlcy5cbiAqXG4gKiBOb3RlOiBVbnJlY29nbml6ZWQgcHJvcGVydGllcyBhcmUgYWxsb3dlZCBhbmQgdW50b3VjaGVkLiBUaGlzIGlzIHNpbWlsYXIgdG9cbiAqIGhvdyBUeXBlU2NyaXB0J3Mgc3RydWN0dXJhbCB0eXBpbmcgd29ya3MuXG4gKi9cblxuZnVuY3Rpb24gdHlwZShzY2hlbWEpIHtcbiAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHNjaGVtYSk7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAndHlwZScsXG4gICAgc2NoZW1hLFxuXG4gICAgKmVudHJpZXModmFsdWUpIHtcbiAgICAgIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBrIG9mIGtleXMpIHtcbiAgICAgICAgICB5aWVsZCBbaywgdmFsdWVba10sIHNjaGVtYVtrXV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgdmFsaWRhdG9yKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3QodmFsdWUpIHx8IFwiRXhwZWN0ZWQgYW4gb2JqZWN0LCBidXQgcmVjZWl2ZWQ6IFwiICsgcHJpbnQodmFsdWUpO1xuICAgIH1cblxuICB9KTtcbn1cbmZ1bmN0aW9uIHVuaW9uKFN0cnVjdHMpIHtcbiAgY29uc3QgZGVzY3JpcHRpb24gPSBTdHJ1Y3RzLm1hcChzID0+IHMudHlwZSkuam9pbignIHwgJyk7XG4gIHJldHVybiBuZXcgU3RydWN0KHtcbiAgICB0eXBlOiAndW5pb24nLFxuICAgIHNjaGVtYTogbnVsbCxcblxuICAgIHZhbGlkYXRvcih2YWx1ZSwgY3R4KSB7XG4gICAgICBjb25zdCBmYWlsdXJlcyA9IFtdO1xuXG4gICAgICBmb3IgKGNvbnN0IFMgb2YgU3RydWN0cykge1xuICAgICAgICBjb25zdCBbLi4udHVwbGVzXSA9IHJ1bih2YWx1ZSwgUywgY3R4KTtcbiAgICAgICAgY29uc3QgW2ZpcnN0XSA9IHR1cGxlcztcblxuICAgICAgICBpZiAoIWZpcnN0WzBdKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgW2ZhaWx1cmVdIG9mIHR1cGxlcykge1xuICAgICAgICAgICAgaWYgKGZhaWx1cmUpIHtcbiAgICAgICAgICAgICAgZmFpbHVyZXMucHVzaChmYWlsdXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIFtcIkV4cGVjdGVkIHRoZSB2YWx1ZSB0byBzYXRpc2Z5IGEgdW5pb24gb2YgYFwiICsgZGVzY3JpcHRpb24gKyBcImAsIGJ1dCByZWNlaXZlZDogXCIgKyBwcmludCh2YWx1ZSksIC4uLmZhaWx1cmVzXTtcbiAgICB9XG5cbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGFueSB2YWx1ZSBwYXNzZXMgdmFsaWRhdGlvbiwgd2l0aG91dCB3aWRlbmluZyBpdHMgdHlwZSB0byBgYW55YC5cbiAqL1xuXG5mdW5jdGlvbiB1bmtub3duKCkge1xuICByZXR1cm4gZGVmaW5lKCd1bmtub3duJywgKCkgPT4gdHJ1ZSk7XG59XG5cbi8qKlxuICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIGNvZXJjaW9uIHN0ZXAgdG8gaXRzIGlucHV0LlxuICpcbiAqIFRoaXMgYWxsb3dzIHlvdSB0byB0cmFuc2Zvcm0gaW5wdXQgZGF0YSBiZWZvcmUgdmFsaWRhdGluZyBpdCwgdG8gaW5jcmVhc2UgdGhlXG4gKiBsaWtlbGlob29kIHRoYXQgaXQgcGFzc2VzIHZhbGlkYXRpb27igJRmb3IgZXhhbXBsZSBmb3IgZGVmYXVsdCB2YWx1ZXMsIHBhcnNpbmdcbiAqIGRpZmZlcmVudCBmb3JtYXRzLCBldGMuXG4gKlxuICogTm90ZTogWW91IG11c3QgdXNlIGBjcmVhdGUodmFsdWUsIFN0cnVjdClgIG9uIHRoZSB2YWx1ZSB0byBoYXZlIHRoZSBjb2VyY2lvblxuICogdGFrZSBlZmZlY3QhIFVzaW5nIHNpbXBseSBgYXNzZXJ0KClgIG9yIGBpcygpYCB3aWxsIG5vdCB1c2UgY29lcmNpb24uXG4gKi9cblxuZnVuY3Rpb24gY29lcmNlKHN0cnVjdCwgY29uZGl0aW9uLCBjb2VyY2VyKSB7XG4gIHJldHVybiBuZXcgU3RydWN0KHsgLi4uc3RydWN0LFxuICAgIGNvZXJjZXI6ICh2YWx1ZSwgY3R4KSA9PiB7XG4gICAgICByZXR1cm4gaXModmFsdWUsIGNvbmRpdGlvbikgPyBzdHJ1Y3QuY29lcmNlcihjb2VyY2VyKHZhbHVlLCBjdHgpLCBjdHgpIDogc3RydWN0LmNvZXJjZXIodmFsdWUsIGN0eCk7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIHN0cnVjdCB0byByZXBsYWNlIGB1bmRlZmluZWRgIHZhbHVlcyB3aXRoIGEgZGVmYXVsdC5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqL1xuXG5mdW5jdGlvbiBkZWZhdWx0ZWQoc3RydWN0LCBmYWxsYmFjaywgb3B0aW9ucyA9IHt9KSB7XG4gIHJldHVybiBjb2VyY2Uoc3RydWN0LCB1bmtub3duKCksIHggPT4ge1xuICAgIGNvbnN0IGYgPSB0eXBlb2YgZmFsbGJhY2sgPT09ICdmdW5jdGlvbicgPyBmYWxsYmFjaygpIDogZmFsbGJhY2s7XG5cbiAgICBpZiAoeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZjtcbiAgICB9XG5cbiAgICBpZiAoIW9wdGlvbnMuc3RyaWN0ICYmIGlzUGxhaW5PYmplY3QoeCkgJiYgaXNQbGFpbk9iamVjdChmKSkge1xuICAgICAgY29uc3QgcmV0ID0geyAuLi54XG4gICAgICB9O1xuICAgICAgbGV0IGNoYW5nZWQgPSBmYWxzZTtcblxuICAgICAgZm9yIChjb25zdCBrZXkgaW4gZikge1xuICAgICAgICBpZiAocmV0W2tleV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldFtrZXldID0gZltrZXldO1xuICAgICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHg7XG4gIH0pO1xufVxuLyoqXG4gKiBBdWdtZW50IGEgc3RydWN0IHRvIHRyaW0gc3RyaW5nIGlucHV0cy5cbiAqXG4gKiBOb3RlOiBZb3UgbXVzdCB1c2UgYGNyZWF0ZSh2YWx1ZSwgU3RydWN0KWAgb24gdGhlIHZhbHVlIHRvIGhhdmUgdGhlIGNvZXJjaW9uXG4gKiB0YWtlIGVmZmVjdCEgVXNpbmcgc2ltcGx5IGBhc3NlcnQoKWAgb3IgYGlzKClgIHdpbGwgbm90IHVzZSBjb2VyY2lvbi5cbiAqL1xuXG5mdW5jdGlvbiB0cmltbWVkKHN0cnVjdCkge1xuICByZXR1cm4gY29lcmNlKHN0cnVjdCwgc3RyaW5nKCksIHggPT4geC50cmltKCkpO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbWFwLCBvciBzZXQgaXMgZW1wdHkuXG4gKi9cblxuZnVuY3Rpb24gZW1wdHkoc3RydWN0KSB7XG4gIGNvbnN0IGV4cGVjdGVkID0gXCJFeHBlY3RlZCBhbiBlbXB0eSBcIiArIHN0cnVjdC50eXBlO1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ2VtcHR5JywgdmFsdWUgPT4ge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE1hcCB8fCB2YWx1ZSBpbnN0YW5jZW9mIFNldCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBzaXplXG4gICAgICB9ID0gdmFsdWU7XG4gICAgICByZXR1cm4gc2l6ZSA9PT0gMCB8fCBleHBlY3RlZCArIFwiIGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIHNpemUgb2YgYFwiICsgc2l6ZSArIFwiYFwiO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxlbmd0aFxuICAgICAgfSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIGxlbmd0aCA9PT0gMCB8fCBleHBlY3RlZCArIFwiIGJ1dCByZWNlaXZlZCBvbmUgd2l0aCBhIGxlbmd0aCBvZiBgXCIgKyBsZW5ndGggKyBcImBcIjtcbiAgICB9XG4gIH0pO1xufVxuLyoqXG4gKiBFbnN1cmUgdGhhdCBhIG51bWJlciBvciBkYXRlIGlzIGJlbG93IGEgdGhyZXNob2xkLlxuICovXG5cbmZ1bmN0aW9uIG1heChzdHJ1Y3QsIHRocmVzaG9sZCwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHtcbiAgICBleGNsdXNpdmVcbiAgfSA9IG9wdGlvbnM7XG4gIHJldHVybiByZWZpbmUoc3RydWN0LCAnbWF4JywgdmFsdWUgPT4ge1xuICAgIHJldHVybiBleGNsdXNpdmUgPyB2YWx1ZSA8IHRocmVzaG9sZCA6IHZhbHVlIDw9IHRocmVzaG9sZCB8fCBcIkV4cGVjdGVkIGEgXCIgKyBzdHJ1Y3QudHlwZSArIFwiIGdyZWF0ZXIgdGhhbiBcIiArIChleGNsdXNpdmUgPyAnJyA6ICdvciBlcXVhbCB0byAnKSArIHRocmVzaG9sZCArIFwiIGJ1dCByZWNlaXZlZCBgXCIgKyB2YWx1ZSArIFwiYFwiO1xuICB9KTtcbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgYSBudW1iZXIgb3IgZGF0ZSBpcyBhYm92ZSBhIHRocmVzaG9sZC5cbiAqL1xuXG5mdW5jdGlvbiBtaW4oc3RydWN0LCB0aHJlc2hvbGQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCB7XG4gICAgZXhjbHVzaXZlXG4gIH0gPSBvcHRpb25zO1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ21pbicsIHZhbHVlID0+IHtcbiAgICByZXR1cm4gZXhjbHVzaXZlID8gdmFsdWUgPiB0aHJlc2hvbGQgOiB2YWx1ZSA+PSB0aHJlc2hvbGQgfHwgXCJFeHBlY3RlZCBhIFwiICsgc3RydWN0LnR5cGUgKyBcIiBncmVhdGVyIHRoYW4gXCIgKyAoZXhjbHVzaXZlID8gJycgOiAnb3IgZXF1YWwgdG8gJykgKyB0aHJlc2hvbGQgKyBcIiBidXQgcmVjZWl2ZWQgYFwiICsgdmFsdWUgKyBcImBcIjtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nIG1hdGNoZXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gKi9cblxuZnVuY3Rpb24gcGF0dGVybihzdHJ1Y3QsIHJlZ2V4cCkge1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3BhdHRlcm4nLCB2YWx1ZSA9PiB7XG4gICAgcmV0dXJuIHJlZ2V4cC50ZXN0KHZhbHVlKSB8fCBcIkV4cGVjdGVkIGEgXCIgKyBzdHJ1Y3QudHlwZSArIFwiIG1hdGNoaW5nIGAvXCIgKyByZWdleHAuc291cmNlICsgXCIvYCBidXQgcmVjZWl2ZWQgXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIjtcbiAgfSk7XG59XG4vKipcbiAqIEVuc3VyZSB0aGF0IGEgc3RyaW5nLCBhcnJheSwgbnVtYmVyLCBkYXRlLCBtYXAsIG9yIHNldCBoYXMgYSBzaXplIChvciBsZW5ndGgsIG9yIHRpbWUpIGJldHdlZW4gYG1pbmAgYW5kIGBtYXhgLlxuICovXG5cbmZ1bmN0aW9uIHNpemUoc3RydWN0LCBtaW4sIG1heCA9IG1pbikge1xuICBjb25zdCBleHBlY3RlZCA9IFwiRXhwZWN0ZWQgYSBcIiArIHN0cnVjdC50eXBlO1xuICBjb25zdCBvZiA9IG1pbiA9PT0gbWF4ID8gXCJvZiBgXCIgKyBtaW4gKyBcImBcIiA6IFwiYmV0d2VlbiBgXCIgKyBtaW4gKyBcImAgYW5kIGBcIiArIG1heCArIFwiYFwiO1xuICByZXR1cm4gcmVmaW5lKHN0cnVjdCwgJ3NpemUnLCB2YWx1ZSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICByZXR1cm4gbWluIDw9IHZhbHVlICYmIHZhbHVlIDw9IG1heCB8fCBleHBlY3RlZCArIFwiIFwiICsgb2YgKyBcIiBidXQgcmVjZWl2ZWQgYFwiICsgdmFsdWUgKyBcImBcIjtcbiAgICB9IGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgTWFwIHx8IHZhbHVlIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNpemVcbiAgICAgIH0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBtaW4gPD0gc2l6ZSAmJiBzaXplIDw9IG1heCB8fCBleHBlY3RlZCArIFwiIHdpdGggYSBzaXplIFwiICsgb2YgKyBcIiBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBzaXplIG9mIGBcIiArIHNpemUgKyBcImBcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBtaW4gPD0gbGVuZ3RoICYmIGxlbmd0aCA8PSBtYXggfHwgZXhwZWN0ZWQgKyBcIiB3aXRoIGEgbGVuZ3RoIFwiICsgb2YgKyBcIiBidXQgcmVjZWl2ZWQgb25lIHdpdGggYSBsZW5ndGggb2YgYFwiICsgbGVuZ3RoICsgXCJgXCI7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQXVnbWVudCBhIGBTdHJ1Y3RgIHRvIGFkZCBhbiBhZGRpdGlvbmFsIHJlZmluZW1lbnQgdG8gdGhlIHZhbGlkYXRpb24uXG4gKlxuICogVGhlIHJlZmluZXIgZnVuY3Rpb24gaXMgZ3VhcmFudGVlZCB0byByZWNlaXZlIGEgdmFsdWUgb2YgdGhlIHN0cnVjdCdzIHR5cGUsXG4gKiBiZWNhdXNlIHRoZSBzdHJ1Y3QncyBleGlzdGluZyB2YWxpZGF0aW9uIHdpbGwgYWxyZWFkeSBoYXZlIHBhc3NlZC4gVGhpc1xuICogYWxsb3dzIHlvdSB0byBsYXllciBhZGRpdGlvbmFsIHZhbGlkYXRpb24gb24gdG9wIG9mIGV4aXN0aW5nIHN0cnVjdHMuXG4gKi9cblxuZnVuY3Rpb24gcmVmaW5lKHN0cnVjdCwgbmFtZSwgcmVmaW5lcikge1xuICByZXR1cm4gbmV3IFN0cnVjdCh7IC4uLnN0cnVjdCxcblxuICAgICpyZWZpbmVyKHZhbHVlLCBjdHgpIHtcbiAgICAgIHlpZWxkKiBzdHJ1Y3QucmVmaW5lcih2YWx1ZSwgY3R4KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHJlZmluZXIodmFsdWUsIGN0eCk7XG4gICAgICBjb25zdCBmYWlsdXJlcyA9IHRvRmFpbHVyZXMocmVzdWx0LCBjdHgsIHN0cnVjdCwgdmFsdWUpO1xuXG4gICAgICBmb3IgKGNvbnN0IGZhaWx1cmUgb2YgZmFpbHVyZXMpIHtcbiAgICAgICAgeWllbGQgeyAuLi5mYWlsdXJlLFxuICAgICAgICAgIHJlZmluZW1lbnQ6IG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgfSk7XG59XG5cbmV4cG9ydCB7IFN0cnVjdCwgU3RydWN0RXJyb3IsIGFueSwgYXJyYXksIGFzc2VydCwgYXNzaWduLCBib29sZWFuLCBjb2VyY2UsIGNyZWF0ZSwgZGF0ZSwgZGVmYXVsdGVkLCBkZWZpbmUsIGRlcHJlY2F0ZWQsIGR5bmFtaWMsIGVtcHR5LCBlbnVtcywgZnVuYywgaW5zdGFuY2UsIGludGVnZXIsIGludGVyc2VjdGlvbiwgaXMsIGxhenksIGxpdGVyYWwsIG1hcCwgbWFzaywgbWF4LCBtaW4sIG5ldmVyLCBudWxsYWJsZSwgbnVtYmVyLCBvYmplY3QsIG9taXQsIG9wdGlvbmFsLCBwYXJ0aWFsLCBwYXR0ZXJuLCBwaWNrLCByZWNvcmQsIHJlZmluZSwgcmVnZXhwLCBzZXQsIHNpemUsIHN0cmluZywgc3RydWN0LCB0cmltbWVkLCB0dXBsZSwgdHlwZSwgdW5pb24sIHVua25vd24sIHZhbGlkYXRlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/superstruct/lib/index.es.js\n"));

/***/ })

});